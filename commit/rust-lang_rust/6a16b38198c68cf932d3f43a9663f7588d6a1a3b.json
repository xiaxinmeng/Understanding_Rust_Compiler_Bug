{"sha": "6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhMTZiMzgxOThjNjhjZjkzMmQzZjQzYTk2NjNmNzU4OGQ2YTFhM2I=", "commit": {"author": {"name": "csmoe", "email": "35686186+csmoe@users.noreply.github.com", "date": "2018-07-11T12:05:29Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-07-16T13:09:16Z"}, "message": "ExprKind", "tree": {"sha": "9829ff20d98be827da8d81726b436afdf5b6e028", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9829ff20d98be827da8d81726b436afdf5b6e028"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "html_url": "https://github.com/rust-lang/rust/commit/6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/comments", "author": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d19e0c8097ead99d306a91b0912f3e6f9c9ddd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d19e0c8097ead99d306a91b0912f3e6f9c9ddd1", "html_url": "https://github.com/rust-lang/rust/commit/1d19e0c8097ead99d306a91b0912f3e6f9c9ddd1"}], "stats": {"total": 1333, "additions": 666, "deletions": 667}, "files": [{"sha": "f1e27946915568a32451a1c5498cefc184a5ac57", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -179,12 +179,12 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n     fn expr(&mut self, expr: &hir::Expr, pred: CFGIndex) -> CFGIndex {\n         match expr.node {\n-            hir::ExprBlock(ref blk, _) => {\n+            hir::ExprKind::Block(ref blk, _) => {\n                 let blk_exit = self.block(&blk, pred);\n                 self.add_ast_node(expr.hir_id.local_id, &[blk_exit])\n             }\n \n-            hir::ExprIf(ref cond, ref then, None) => {\n+            hir::ExprKind::If(ref cond, ref then, None) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -204,7 +204,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_ast_node(expr.hir_id.local_id, &[cond_exit, then_exit])      // 3,4\n             }\n \n-            hir::ExprIf(ref cond, ref then, Some(ref otherwise)) => {\n+            hir::ExprKind::If(ref cond, ref then, Some(ref otherwise)) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -225,7 +225,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_ast_node(expr.hir_id.local_id, &[then_exit, else_exit])      // 4, 5\n             }\n \n-            hir::ExprWhile(ref cond, ref body, _) => {\n+            hir::ExprKind::While(ref cond, ref body, _) => {\n                 //\n                 //         [pred]\n                 //           |\n@@ -267,7 +267,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 expr_exit\n             }\n \n-            hir::ExprLoop(ref body, _, _) => {\n+            hir::ExprKind::Loop(ref body, _, _) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -295,11 +295,11 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 expr_exit\n             }\n \n-            hir::ExprMatch(ref discr, ref arms, _) => {\n+            hir::ExprKind::Match(ref discr, ref arms, _) => {\n                 self.match_(expr.hir_id.local_id, &discr, &arms, pred)\n             }\n \n-            hir::ExprBinary(op, ref l, ref r) if op.node.is_lazy() => {\n+            hir::ExprKind::Binary(op, ref l, ref r) if op.node.is_lazy() => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -319,14 +319,14 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_ast_node(expr.hir_id.local_id, &[l_exit, r_exit])            // 3,4\n             }\n \n-            hir::ExprRet(ref v) => {\n+            hir::ExprKind::Ret(ref v) => {\n                 let v_exit = self.opt_expr(v, pred);\n                 let b = self.add_ast_node(expr.hir_id.local_id, &[v_exit]);\n                 self.add_returning_edge(expr, b);\n                 self.add_unreachable_node()\n             }\n \n-            hir::ExprBreak(destination, ref opt_expr) => {\n+            hir::ExprKind::Break(destination, ref opt_expr) => {\n                 let v = self.opt_expr(opt_expr, pred);\n                 let (target_scope, break_dest) =\n                     self.find_scope_edge(expr, destination, ScopeCfKind::Break);\n@@ -335,74 +335,74 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_unreachable_node()\n             }\n \n-            hir::ExprContinue(destination) => {\n+            hir::ExprKind::Continue(destination) => {\n                 let (target_scope, cont_dest) =\n                     self.find_scope_edge(expr, destination, ScopeCfKind::Continue);\n                 let a = self.add_ast_node(expr.hir_id.local_id, &[pred]);\n                 self.add_exiting_edge(expr, a, target_scope, cont_dest);\n                 self.add_unreachable_node()\n             }\n \n-            hir::ExprArray(ref elems) => {\n+            hir::ExprKind::Array(ref elems) => {\n                 self.straightline(expr, pred, elems.iter().map(|e| &*e))\n             }\n \n-            hir::ExprCall(ref func, ref args) => {\n+            hir::ExprKind::Call(ref func, ref args) => {\n                 self.call(expr, pred, &func, args.iter().map(|e| &*e))\n             }\n \n-            hir::ExprMethodCall(.., ref args) => {\n+            hir::ExprKind::MethodCall(.., ref args) => {\n                 self.call(expr, pred, &args[0], args[1..].iter().map(|e| &*e))\n             }\n \n-            hir::ExprIndex(ref l, ref r) |\n-            hir::ExprBinary(_, ref l, ref r) if self.tables.is_method_call(expr) => {\n+            hir::ExprKind::Index(ref l, ref r) |\n+            hir::ExprKind::Binary(_, ref l, ref r) if self.tables.is_method_call(expr) => {\n                 self.call(expr, pred, &l, Some(&**r).into_iter())\n             }\n \n-            hir::ExprUnary(_, ref e) if self.tables.is_method_call(expr) => {\n+            hir::ExprKind::Unary(_, ref e) if self.tables.is_method_call(expr) => {\n                 self.call(expr, pred, &e, None::<hir::Expr>.iter())\n             }\n \n-            hir::ExprTup(ref exprs) => {\n+            hir::ExprKind::Tup(ref exprs) => {\n                 self.straightline(expr, pred, exprs.iter().map(|e| &*e))\n             }\n \n-            hir::ExprStruct(_, ref fields, ref base) => {\n+            hir::ExprKind::Struct(_, ref fields, ref base) => {\n                 let field_cfg = self.straightline(expr, pred, fields.iter().map(|f| &*f.expr));\n                 self.opt_expr(base, field_cfg)\n             }\n \n-            hir::ExprAssign(ref l, ref r) |\n-            hir::ExprAssignOp(_, ref l, ref r) => {\n+            hir::ExprKind::Assign(ref l, ref r) |\n+            hir::ExprKind::AssignOp(_, ref l, ref r) => {\n                 self.straightline(expr, pred, [r, l].iter().map(|&e| &**e))\n             }\n \n-            hir::ExprIndex(ref l, ref r) |\n-            hir::ExprBinary(_, ref l, ref r) => { // NB: && and || handled earlier\n+            hir::ExprKind::Index(ref l, ref r) |\n+            hir::ExprKind::Binary(_, ref l, ref r) => { // NB: && and || handled earlier\n                 self.straightline(expr, pred, [l, r].iter().map(|&e| &**e))\n             }\n \n-            hir::ExprBox(ref e) |\n-            hir::ExprAddrOf(_, ref e) |\n-            hir::ExprCast(ref e, _) |\n-            hir::ExprType(ref e, _) |\n-            hir::ExprUnary(_, ref e) |\n-            hir::ExprField(ref e, _) |\n-            hir::ExprYield(ref e) |\n-            hir::ExprRepeat(ref e, _) => {\n+            hir::ExprKind::Box(ref e) |\n+            hir::ExprKind::AddrOf(_, ref e) |\n+            hir::ExprKind::Cast(ref e, _) |\n+            hir::ExprKind::Type(ref e, _) |\n+            hir::ExprKind::Unary(_, ref e) |\n+            hir::ExprKind::Field(ref e, _) |\n+            hir::ExprKind::Yield(ref e) |\n+            hir::ExprKind::Repeat(ref e, _) => {\n                 self.straightline(expr, pred, Some(&**e).into_iter())\n             }\n \n-            hir::ExprInlineAsm(_, ref outputs, ref inputs) => {\n+            hir::ExprKind::InlineAsm(_, ref outputs, ref inputs) => {\n                 let post_outputs = self.exprs(outputs.iter().map(|e| &*e), pred);\n                 let post_inputs = self.exprs(inputs.iter().map(|e| &*e), post_outputs);\n                 self.add_ast_node(expr.hir_id.local_id, &[post_inputs])\n             }\n \n-            hir::ExprClosure(..) |\n-            hir::ExprLit(..) |\n-            hir::ExprPath(_) => {\n+            hir::ExprKind::Closure(..) |\n+            hir::ExprKind::Lit(..) |\n+            hir::ExprKind::Path(_) => {\n                 self.straightline(expr, pred, None::<hir::Expr>.iter())\n             }\n         }"}, {"sha": "71f160dd321878798bf4644bd31c4f0f4cc4fa8a", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -283,7 +283,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n \n     fn check_expr_attributes(&self, expr: &hir::Expr) {\n         let target = match expr.node {\n-            hir::ExprClosure(..) => Target::Closure,\n+            hir::ExprKind::Closure(..) => Target::Closure,\n             _ => Target::Expression,\n         };\n         for attr in expr.attrs.iter() {"}, {"sha": "11800d7f9c9ed21ff390492a5a990fa9e5455ec9", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -963,17 +963,17 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n     visitor.visit_id(expression.id);\n     walk_list!(visitor, visit_attribute, expression.attrs.iter());\n     match expression.node {\n-        ExprBox(ref subexpression) => {\n+        ExprKind::Box(ref subexpression) => {\n             visitor.visit_expr(subexpression)\n         }\n-        ExprArray(ref subexpressions) => {\n+        ExprKind::Array(ref subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }\n-        ExprRepeat(ref element, ref count) => {\n+        ExprKind::Repeat(ref element, ref count) => {\n             visitor.visit_expr(element);\n             visitor.visit_anon_const(count)\n         }\n-        ExprStruct(ref qpath, ref fields, ref optional_base) => {\n+        ExprKind::Struct(ref qpath, ref fields, ref optional_base) => {\n             visitor.visit_qpath(qpath, expression.id, expression.span);\n             for field in fields {\n                 visitor.visit_id(field.id);\n@@ -982,78 +982,78 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             }\n             walk_list!(visitor, visit_expr, optional_base);\n         }\n-        ExprTup(ref subexpressions) => {\n+        ExprKind::Tup(ref subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }\n-        ExprCall(ref callee_expression, ref arguments) => {\n+        ExprKind::Call(ref callee_expression, ref arguments) => {\n             visitor.visit_expr(callee_expression);\n             walk_list!(visitor, visit_expr, arguments);\n         }\n-        ExprMethodCall(ref segment, _, ref arguments) => {\n+        ExprKind::MethodCall(ref segment, _, ref arguments) => {\n             visitor.visit_path_segment(expression.span, segment);\n             walk_list!(visitor, visit_expr, arguments);\n         }\n-        ExprBinary(_, ref left_expression, ref right_expression) => {\n+        ExprKind::Binary(_, ref left_expression, ref right_expression) => {\n             visitor.visit_expr(left_expression);\n             visitor.visit_expr(right_expression)\n         }\n-        ExprAddrOf(_, ref subexpression) | ExprUnary(_, ref subexpression) => {\n+        ExprKind::AddrOf(_, ref subexpression) | ExprKind::Unary(_, ref subexpression) => {\n             visitor.visit_expr(subexpression)\n         }\n-        ExprLit(_) => {}\n-        ExprCast(ref subexpression, ref typ) | ExprType(ref subexpression, ref typ) => {\n+        ExprKind::Lit(_) => {}\n+        ExprKind::Cast(ref subexpression, ref typ) | ExprKind::Type(ref subexpression, ref typ) => {\n             visitor.visit_expr(subexpression);\n             visitor.visit_ty(typ)\n         }\n-        ExprIf(ref head_expression, ref if_block, ref optional_else) => {\n+        ExprKind::If(ref head_expression, ref if_block, ref optional_else) => {\n             visitor.visit_expr(head_expression);\n             visitor.visit_expr(if_block);\n             walk_list!(visitor, visit_expr, optional_else);\n         }\n-        ExprWhile(ref subexpression, ref block, ref opt_label) => {\n+        ExprKind::While(ref subexpression, ref block, ref opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n         }\n-        ExprLoop(ref block, ref opt_label, _) => {\n+        ExprKind::Loop(ref block, ref opt_label, _) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_block(block);\n         }\n-        ExprMatch(ref subexpression, ref arms, _) => {\n+        ExprKind::Match(ref subexpression, ref arms, _) => {\n             visitor.visit_expr(subexpression);\n             walk_list!(visitor, visit_arm, arms);\n         }\n-        ExprClosure(_, ref function_declaration, body, _fn_decl_span, _gen) => {\n+        ExprKind::Closure(_, ref function_declaration, body, _fn_decl_span, _gen) => {\n             visitor.visit_fn(FnKind::Closure(&expression.attrs),\n                              function_declaration,\n                              body,\n                              expression.span,\n                              expression.id)\n         }\n-        ExprBlock(ref block, ref opt_label) => {\n+        ExprKind::Block(ref block, ref opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_block(block);\n         }\n-        ExprAssign(ref left_hand_expression, ref right_hand_expression) => {\n+        ExprKind::Assign(ref left_hand_expression, ref right_hand_expression) => {\n             visitor.visit_expr(right_hand_expression);\n             visitor.visit_expr(left_hand_expression)\n         }\n-        ExprAssignOp(_, ref left_expression, ref right_expression) => {\n+        ExprKind::AssignOp(_, ref left_expression, ref right_expression) => {\n             visitor.visit_expr(right_expression);\n             visitor.visit_expr(left_expression)\n         }\n-        ExprField(ref subexpression, ident) => {\n+        ExprKind::Field(ref subexpression, ident) => {\n             visitor.visit_expr(subexpression);\n             visitor.visit_ident(ident);\n         }\n-        ExprIndex(ref main_expression, ref index_expression) => {\n+        ExprKind::Index(ref main_expression, ref index_expression) => {\n             visitor.visit_expr(main_expression);\n             visitor.visit_expr(index_expression)\n         }\n-        ExprPath(ref qpath) => {\n+        ExprKind::Path(ref qpath) => {\n             visitor.visit_qpath(qpath, expression.id, expression.span);\n         }\n-        ExprBreak(ref destination, ref opt_expr) => {\n+        ExprKind::Break(ref destination, ref opt_expr) => {\n             if let Some(ref label) = destination.label {\n                 visitor.visit_label(label);\n                 match destination.target_id {\n@@ -1063,7 +1063,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             }\n             walk_list!(visitor, visit_expr, opt_expr);\n         }\n-        ExprContinue(ref destination) => {\n+        ExprKind::Continue(ref destination) => {\n             if let Some(ref label) = destination.label {\n                 visitor.visit_label(label);\n                 match destination.target_id {\n@@ -1072,18 +1072,18 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n                 };\n             }\n         }\n-        ExprRet(ref optional_expression) => {\n+        ExprKind::Ret(ref optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);\n         }\n-        ExprInlineAsm(_, ref outputs, ref inputs) => {\n+        ExprKind::InlineAsm(_, ref outputs, ref inputs) => {\n             for output in outputs {\n                 visitor.visit_expr(output)\n             }\n             for input in inputs {\n                 visitor.visit_expr(input)\n             }\n         }\n-        ExprYield(ref subexpression) => {\n+        ExprKind::Yield(ref subexpression) => {\n             visitor.visit_expr(subexpression);\n         }\n     }"}, {"sha": "a583ef0c09f1e82e1de6f3e767cc89129bb2d1e4", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -853,7 +853,7 @@ impl<'a> LoweringContext<'a> {\n         closure_node_id: NodeId,\n         ret_ty: Option<&Ty>,\n         body: impl FnOnce(&mut LoweringContext) -> hir::Expr,\n-    ) -> hir::Expr_ {\n+    ) -> hir::ExprKind {\n         let prev_is_generator = mem::replace(&mut self.is_generator, true);\n         let body_expr = body(self);\n         let span = body_expr.span;\n@@ -875,7 +875,7 @@ impl<'a> LoweringContext<'a> {\n         let generator = hir::Expr {\n             id: closure_node_id,\n             hir_id: closure_hir_id,\n-            node: hir::ExprClosure(capture_clause, decl, body_id, span,\n+            node: hir::ExprKind::Closure(capture_clause, decl, body_id, span,\n                 Some(hir::GeneratorMovability::Static)),\n             span,\n             attrs: ThinVec::new(),\n@@ -884,7 +884,7 @@ impl<'a> LoweringContext<'a> {\n         let unstable_span = self.allow_internal_unstable(CompilerDesugaringKind::Async, span);\n         let gen_future = self.expr_std_path(\n             unstable_span, &[\"future\", \"from_generator\"], None, ThinVec::new());\n-        hir::ExprCall(P(gen_future), hir_vec![generator])\n+        hir::ExprKind::Call(P(gen_future), hir_vec![generator])\n     }\n \n     fn lower_body<F>(&mut self, decl: Option<&FnDecl>, f: F) -> hir::BodyId\n@@ -3468,25 +3468,25 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_expr(&mut self, e: &Expr) -> hir::Expr {\n         let kind = match e.node {\n-            ExprKind::Box(ref inner) => hir::ExprBox(P(self.lower_expr(inner))),\n+            ExprKind::Box(ref inner) => hir::ExprKind::Box(P(self.lower_expr(inner))),\n             ExprKind::ObsoleteInPlace(..) => {\n                 self.sess.abort_if_errors();\n                 span_bug!(e.span, \"encountered ObsoleteInPlace expr during lowering\");\n             }\n             ExprKind::Array(ref exprs) => {\n-                hir::ExprArray(exprs.iter().map(|x| self.lower_expr(x)).collect())\n+                hir::ExprKind::Array(exprs.iter().map(|x| self.lower_expr(x)).collect())\n             }\n             ExprKind::Repeat(ref expr, ref count) => {\n                 let expr = P(self.lower_expr(expr));\n                 let count = self.lower_anon_const(count);\n-                hir::ExprRepeat(expr, count)\n+                hir::ExprKind::Repeat(expr, count)\n             }\n             ExprKind::Tup(ref elts) => {\n-                hir::ExprTup(elts.iter().map(|x| self.lower_expr(x)).collect())\n+                hir::ExprKind::Tup(elts.iter().map(|x| self.lower_expr(x)).collect())\n             }\n             ExprKind::Call(ref f, ref args) => {\n                 let f = P(self.lower_expr(f));\n-                hir::ExprCall(f, args.iter().map(|x| self.lower_expr(x)).collect())\n+                hir::ExprKind::Call(f, args.iter().map(|x| self.lower_expr(x)).collect())\n             }\n             ExprKind::MethodCall(ref seg, ref args) => {\n                 let hir_seg = self.lower_path_segment(\n@@ -3498,32 +3498,32 @@ impl<'a> LoweringContext<'a> {\n                     ImplTraitContext::Disallowed,\n                 );\n                 let args = args.iter().map(|x| self.lower_expr(x)).collect();\n-                hir::ExprMethodCall(hir_seg, seg.ident.span, args)\n+                hir::ExprKind::MethodCall(hir_seg, seg.ident.span, args)\n             }\n             ExprKind::Binary(binop, ref lhs, ref rhs) => {\n                 let binop = self.lower_binop(binop);\n                 let lhs = P(self.lower_expr(lhs));\n                 let rhs = P(self.lower_expr(rhs));\n-                hir::ExprBinary(binop, lhs, rhs)\n+                hir::ExprKind::Binary(binop, lhs, rhs)\n             }\n             ExprKind::Unary(op, ref ohs) => {\n                 let op = self.lower_unop(op);\n                 let ohs = P(self.lower_expr(ohs));\n-                hir::ExprUnary(op, ohs)\n+                hir::ExprKind::Unary(op, ohs)\n             }\n-            ExprKind::Lit(ref l) => hir::ExprLit(P((**l).clone())),\n+            ExprKind::Lit(ref l) => hir::ExprKind::Lit(P((**l).clone())),\n             ExprKind::Cast(ref expr, ref ty) => {\n                 let expr = P(self.lower_expr(expr));\n-                hir::ExprCast(expr, self.lower_ty(ty, ImplTraitContext::Disallowed))\n+                hir::ExprKind::Cast(expr, self.lower_ty(ty, ImplTraitContext::Disallowed))\n             }\n             ExprKind::Type(ref expr, ref ty) => {\n                 let expr = P(self.lower_expr(expr));\n-                hir::ExprType(expr, self.lower_ty(ty, ImplTraitContext::Disallowed))\n+                hir::ExprKind::Type(expr, self.lower_ty(ty, ImplTraitContext::Disallowed))\n             }\n             ExprKind::AddrOf(m, ref ohs) => {\n                 let m = self.lower_mutability(m);\n                 let ohs = P(self.lower_expr(ohs));\n-                hir::ExprAddrOf(m, ohs)\n+                hir::ExprKind::AddrOf(m, ohs)\n             }\n             // More complicated than you might expect because the else branch\n             // might be `if let`.\n@@ -3554,17 +3554,17 @@ impl<'a> LoweringContext<'a> {\n                 let then_blk = self.lower_block(blk, false);\n                 let then_expr = self.expr_block(then_blk, ThinVec::new());\n \n-                hir::ExprIf(P(self.lower_expr(cond)), P(then_expr), else_opt)\n+                hir::ExprKind::If(P(self.lower_expr(cond)), P(then_expr), else_opt)\n             }\n             ExprKind::While(ref cond, ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n-                hir::ExprWhile(\n+                hir::ExprKind::While(\n                     this.with_loop_condition_scope(|this| P(this.lower_expr(cond))),\n                     this.lower_block(body, false),\n                     this.lower_label(opt_label),\n                 )\n             }),\n             ExprKind::Loop(ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n-                hir::ExprLoop(\n+                hir::ExprKind::Loop(\n                     this.lower_block(body, false),\n                     this.lower_label(opt_label),\n                     hir::LoopSource::Loop,\n@@ -3582,7 +3582,7 @@ impl<'a> LoweringContext<'a> {\n                             hir::Expr {\n                                 id: node_id,\n                                 span,\n-                                node: hir::ExprTup(hir_vec![]),\n+                                node: hir::ExprKind::Tup(hir_vec![]),\n                                 attrs: ThinVec::new(),\n                                 hir_id,\n                             }\n@@ -3591,10 +3591,10 @@ impl<'a> LoweringContext<'a> {\n                     );\n                     block.expr = Some(this.wrap_in_try_constructor(\n                         \"from_ok\", tail, unstable_span));\n-                    hir::ExprBlock(P(block), None)\n+                    hir::ExprKind::Block(P(block), None)\n                 })\n             }\n-            ExprKind::Match(ref expr, ref arms) => hir::ExprMatch(\n+            ExprKind::Match(ref expr, ref arms) => hir::ExprKind::Match(\n                 P(self.lower_expr(expr)),\n                 arms.iter().map(|x| self.lower_arm(x)).collect(),\n                 hir::MatchSource::Normal,\n@@ -3652,7 +3652,7 @@ impl<'a> LoweringContext<'a> {\n                                 });\n                             this.expr(fn_decl_span, async_body, ThinVec::new())\n                         });\n-                        hir::ExprClosure(\n+                        hir::ExprKind::Closure(\n                             this.lower_capture_clause(capture_clause),\n                             fn_decl,\n                             body_id,\n@@ -3696,7 +3696,7 @@ impl<'a> LoweringContext<'a> {\n                             }\n                             None\n                         };\n-                        hir::ExprClosure(\n+                        hir::ExprKind::Closure(\n                             this.lower_capture_clause(capture_clause),\n                             fn_decl,\n                             body_id,\n@@ -3707,21 +3707,21 @@ impl<'a> LoweringContext<'a> {\n                 }\n             }\n             ExprKind::Block(ref blk, opt_label) => {\n-                hir::ExprBlock(self.lower_block(blk,\n+                hir::ExprKind::Block(self.lower_block(blk,\n                                                 opt_label.is_some()),\n                                                 self.lower_label(opt_label))\n             }\n             ExprKind::Assign(ref el, ref er) => {\n-                hir::ExprAssign(P(self.lower_expr(el)), P(self.lower_expr(er)))\n+                hir::ExprKind::Assign(P(self.lower_expr(el)), P(self.lower_expr(er)))\n             }\n-            ExprKind::AssignOp(op, ref el, ref er) => hir::ExprAssignOp(\n+            ExprKind::AssignOp(op, ref el, ref er) => hir::ExprKind::AssignOp(\n                 self.lower_binop(op),\n                 P(self.lower_expr(el)),\n                 P(self.lower_expr(er)),\n             ),\n-            ExprKind::Field(ref el, ident) => hir::ExprField(P(self.lower_expr(el)), ident),\n+            ExprKind::Field(ref el, ident) => hir::ExprKind::Field(P(self.lower_expr(el)), ident),\n             ExprKind::Index(ref el, ref er) => {\n-                hir::ExprIndex(P(self.lower_expr(el)), P(self.lower_expr(er)))\n+                hir::ExprKind::Index(P(self.lower_expr(el)), P(self.lower_expr(er)))\n             }\n             // Desugar `<start>..=<end>` to `std::ops::RangeInclusive::new(<start>, <end>)`\n             ExprKind::Range(Some(ref e1), Some(ref e2), RangeLimits::Closed) => {\n@@ -3734,8 +3734,8 @@ impl<'a> LoweringContext<'a> {\n                 let ty = P(self.ty_path(id, span, hir::QPath::Resolved(None, ty_path)));\n                 let new_seg = P(hir::PathSegment::from_ident(Ident::from_str(\"new\")));\n                 let new_path = hir::QPath::TypeRelative(ty, new_seg);\n-                let new = P(self.expr(span, hir::ExprPath(new_path), ThinVec::new()));\n-                hir::ExprCall(new, hir_vec![e1, e2])\n+                let new = P(self.expr(span, hir::ExprKind::Path(new_path), ThinVec::new()));\n+                hir::ExprKind::Call(new, hir_vec![e1, e2])\n             }\n             ExprKind::Range(ref e1, ref e2, lims) => {\n                 use syntax::ast::RangeLimits::*;\n@@ -3779,15 +3779,15 @@ impl<'a> LoweringContext<'a> {\n                     id: node_id,\n                     hir_id,\n                     node: if is_unit {\n-                        hir::ExprPath(struct_path)\n+                        hir::ExprKind::Path(struct_path)\n                     } else {\n-                        hir::ExprStruct(struct_path, fields, None)\n+                        hir::ExprKind::Struct(struct_path, fields, None)\n                     },\n                     span: unstable_span,\n                     attrs: e.attrs.clone(),\n                 };\n             }\n-            ExprKind::Path(ref qself, ref path) => hir::ExprPath(self.lower_qpath(\n+            ExprKind::Path(ref qself, ref path) => hir::ExprKind::Path(self.lower_qpath(\n                 e.id,\n                 qself,\n                 path,\n@@ -3803,13 +3803,13 @@ impl<'a> LoweringContext<'a> {\n                 } else {\n                     self.lower_loop_destination(opt_label.map(|label| (e.id, label)))\n                 };\n-                hir::ExprBreak(\n+                hir::ExprKind::Break(\n                     destination,\n                     opt_expr.as_ref().map(|x| P(self.lower_expr(x))),\n                 )\n             }\n             ExprKind::Continue(opt_label) => {\n-                hir::ExprContinue(if self.is_in_loop_condition && opt_label.is_none() {\n+                hir::ExprKind::Continue(if self.is_in_loop_condition && opt_label.is_none() {\n                     hir::Destination {\n                         label: None,\n                         target_id: Err(hir::LoopIdError::UnlabeledCfInWhileCondition).into(),\n@@ -3818,7 +3818,7 @@ impl<'a> LoweringContext<'a> {\n                     self.lower_loop_destination(opt_label.map(|label| (e.id, label)))\n                 })\n             }\n-            ExprKind::Ret(ref e) => hir::ExprRet(e.as_ref().map(|x| P(self.lower_expr(x)))),\n+            ExprKind::Ret(ref e) => hir::ExprKind::Ret(e.as_ref().map(|x| P(self.lower_expr(x)))),\n             ExprKind::InlineAsm(ref asm) => {\n                 let hir_asm = hir::InlineAsm {\n                     inputs: asm.inputs.iter().map(|&(ref c, _)| c.clone()).collect(),\n@@ -3846,9 +3846,9 @@ impl<'a> LoweringContext<'a> {\n                     .iter()\n                     .map(|&(_, ref input)| self.lower_expr(input))\n                     .collect();\n-                hir::ExprInlineAsm(P(hir_asm), outputs, inputs)\n+                hir::ExprKind::InlineAsm(P(hir_asm), outputs, inputs)\n             }\n-            ExprKind::Struct(ref path, ref fields, ref maybe_expr) => hir::ExprStruct(\n+            ExprKind::Struct(ref path, ref fields, ref maybe_expr) => hir::ExprKind::Struct(\n                 self.lower_qpath(\n                     e.id,\n                     &None,\n@@ -3877,8 +3877,8 @@ impl<'a> LoweringContext<'a> {\n                 let expr = opt_expr\n                     .as_ref()\n                     .map(|x| self.lower_expr(x))\n-                    .unwrap_or_else(|| self.expr(e.span, hir::ExprTup(hir_vec![]), ThinVec::new()));\n-                hir::ExprYield(P(expr))\n+                    .unwrap_or_else(|| self.expr(e.span, hir::ExprKind::Tup(hir_vec![]), ThinVec::new()));\n+                hir::ExprKind::Yield(P(expr))\n             }\n \n             // Desugar ExprIfLet\n@@ -3917,7 +3917,7 @@ impl<'a> LoweringContext<'a> {\n \n                 let sub_expr = P(self.lower_expr(sub_expr));\n \n-                hir::ExprMatch(\n+                hir::ExprKind::Match(\n                     sub_expr,\n                     arms.into(),\n                     hir::MatchSource::IfLetDesugar {\n@@ -3965,13 +3965,13 @@ impl<'a> LoweringContext<'a> {\n                 let arms = hir_vec![pat_arm, break_arm];\n                 let match_expr = self.expr(\n                     sub_expr.span,\n-                    hir::ExprMatch(sub_expr, arms, hir::MatchSource::WhileLetDesugar),\n+                    hir::ExprKind::Match(sub_expr, arms, hir::MatchSource::WhileLetDesugar),\n                     ThinVec::new(),\n                 );\n \n                 // `[opt_ident]: loop { ... }`\n                 let loop_block = P(self.block_expr(P(match_expr)));\n-                let loop_expr = hir::ExprLoop(\n+                let loop_expr = hir::ExprKind::Loop(\n                     loop_block,\n                     self.lower_label(opt_label),\n                     hir::LoopSource::WhileLet,\n@@ -4023,7 +4023,7 @@ impl<'a> LoweringContext<'a> {\n                     let next_expr = P(self.expr_ident(pat.span, next_ident, next_pat.id));\n                     let assign = P(self.expr(\n                         pat.span,\n-                        hir::ExprAssign(next_expr, val_expr),\n+                        hir::ExprKind::Assign(next_expr, val_expr),\n                         ThinVec::new(),\n                     ));\n                     let some_pat = self.pat_some(pat.span, val_pat);\n@@ -4053,7 +4053,7 @@ impl<'a> LoweringContext<'a> {\n \n                     P(self.expr(\n                         head_sp,\n-                        hir::ExprMatch(next_expr, arms, hir::MatchSource::ForLoopDesugar),\n+                        hir::ExprKind::Match(next_expr, arms, hir::MatchSource::ForLoopDesugar),\n                         ThinVec::new(),\n                     ))\n                 };\n@@ -4085,7 +4085,7 @@ impl<'a> LoweringContext<'a> {\n                 ));\n \n                 // `[opt_ident]: loop { ... }`\n-                let loop_expr = hir::ExprLoop(\n+                let loop_expr = hir::ExprKind::Loop(\n                     loop_block,\n                     self.lower_label(opt_label),\n                     hir::LoopSource::ForLoop,\n@@ -4205,7 +4205,7 @@ impl<'a> LoweringContext<'a> {\n                     let ret_expr = if let Some(catch_node) = catch_scope {\n                         P(self.expr(\n                             e.span,\n-                            hir::ExprBreak(\n+                            hir::ExprKind::Break(\n                                 hir::Destination {\n                                     label: None,\n                                     target_id: Ok(catch_node),\n@@ -4215,14 +4215,14 @@ impl<'a> LoweringContext<'a> {\n                             thin_attrs,\n                         ))\n                     } else {\n-                        P(self.expr(e.span, hir::Expr_::ExprRet(Some(from_err_expr)), thin_attrs))\n+                        P(self.expr(e.span, hir::ExprKind::Ret(Some(from_err_expr)), thin_attrs))\n                     };\n \n                     let err_pat = self.pat_err(e.span, err_local);\n                     self.arm(hir_vec![err_pat], ret_expr)\n                 };\n \n-                hir::ExprMatch(\n+                hir::ExprKind::Match(\n                     discr,\n                     hir_vec![err_arm, ok_arm],\n                     hir::MatchSource::TryDesugar,\n@@ -4390,7 +4390,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn expr_break(&mut self, span: Span, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n-        let expr_break = hir::ExprBreak(self.lower_loop_destination(None), None);\n+        let expr_break = hir::ExprKind::Break(self.lower_loop_destination(None), None);\n         P(self.expr(span, expr_break, attrs))\n     }\n \n@@ -4400,7 +4400,7 @@ impl<'a> LoweringContext<'a> {\n         e: P<hir::Expr>,\n         args: hir::HirVec<hir::Expr>,\n     ) -> hir::Expr {\n-        self.expr(span, hir::ExprCall(e, args), ThinVec::new())\n+        self.expr(span, hir::ExprKind::Call(e, args), ThinVec::new())\n     }\n \n     fn expr_ident(&mut self, span: Span, ident: Ident, binding: NodeId) -> hir::Expr {\n@@ -4414,7 +4414,7 @@ impl<'a> LoweringContext<'a> {\n         binding: NodeId,\n         attrs: ThinVec<Attribute>,\n     ) -> hir::Expr {\n-        let expr_path = hir::ExprPath(hir::QPath::Resolved(\n+        let expr_path = hir::ExprKind::Path(hir::QPath::Resolved(\n             None,\n             P(hir::Path {\n                 span,\n@@ -4427,7 +4427,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn expr_mut_addr_of(&mut self, span: Span, e: P<hir::Expr>) -> hir::Expr {\n-        self.expr(span, hir::ExprAddrOf(hir::MutMutable, e), ThinVec::new())\n+        self.expr(span, hir::ExprKind::AddrOf(hir::MutMutable, e), ThinVec::new())\n     }\n \n     fn expr_std_path(\n@@ -4440,7 +4440,7 @@ impl<'a> LoweringContext<'a> {\n         let path = self.std_path(span, components, params, true);\n         self.expr(\n             span,\n-            hir::ExprPath(hir::QPath::Resolved(None, P(path))),\n+            hir::ExprKind::Path(hir::QPath::Resolved(None, P(path))),\n             attrs,\n         )\n     }\n@@ -4452,18 +4452,18 @@ impl<'a> LoweringContext<'a> {\n         arms: hir::HirVec<hir::Arm>,\n         source: hir::MatchSource,\n     ) -> hir::Expr {\n-        self.expr(span, hir::ExprMatch(arg, arms, source), ThinVec::new())\n+        self.expr(span, hir::ExprKind::Match(arg, arms, source), ThinVec::new())\n     }\n \n     fn expr_block(&mut self, b: P<hir::Block>, attrs: ThinVec<Attribute>) -> hir::Expr {\n-        self.expr(b.span, hir::ExprBlock(b, None), attrs)\n+        self.expr(b.span, hir::ExprKind::Block(b, None), attrs)\n     }\n \n     fn expr_tuple(&mut self, sp: Span, exprs: hir::HirVec<hir::Expr>) -> P<hir::Expr> {\n-        P(self.expr(sp, hir::ExprTup(exprs), ThinVec::new()))\n+        P(self.expr(sp, hir::ExprKind::Tup(exprs), ThinVec::new()))\n     }\n \n-    fn expr(&mut self, span: Span, node: hir::Expr_, attrs: ThinVec<Attribute>) -> hir::Expr {\n+    fn expr(&mut self, span: Span, node: hir::ExprKind, attrs: ThinVec<Attribute>) -> hir::Expr {\n         let LoweredNodeId { node_id, hir_id } = self.next_id();\n         hir::Expr {\n             id: node_id,"}, {"sha": "6d4bff5a35282814367481602e6cb99e939f03de", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -34,7 +34,7 @@ use syntax_pos::Span;\n /// More specifically, it is one of either:\n ///\n ///   - A function item,\n-///   - A closure expr (i.e. an ExprClosure), or\n+///   - A closure expr (i.e. an ExprKind::Closure), or\n ///   - The default implementation for a trait method.\n ///\n /// To construct one, use the `Code::from_node` function.\n@@ -63,7 +63,7 @@ impl MaybeFnLike for ast::TraitItem {\n impl MaybeFnLike for ast::Expr {\n     fn is_fn_like(&self) -> bool {\n         match self.node {\n-            ast::ExprClosure(..) => true,\n+            ast::ExprKind::Closure(..) => true,\n             _ => false,\n         }\n     }\n@@ -260,7 +260,7 @@ impl<'a> FnLikeNode<'a> {\n                 }\n             },\n             map::NodeExpr(e) => match e.node {\n-                ast::ExprClosure(_, ref decl, block, _fn_decl_span, _gen) =>\n+                ast::ExprKind::Closure(_, ref decl, block, _fn_decl_span, _gen) =>\n                     closure(ClosureParts::new(&decl, block, e.id, e.span, &e.attrs)),\n                 _ => bug!(\"expr FnLikeNode that is not fn-like\"),\n             },"}, {"sha": "ae77f634d7918a9e6c6115204ed9931f68fd05af", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -195,7 +195,7 @@ impl<'hir> MapEntry<'hir> {\n \n             EntryExpr(_, _, ref expr) => {\n                 match expr.node {\n-                    ExprClosure(_, ref fn_decl, ..) => Some(&fn_decl),\n+                    ExprKind::Closure(_, ref fn_decl, ..) => Some(&fn_decl),\n                     _ => None,\n                 }\n             }\n@@ -235,7 +235,7 @@ impl<'hir> MapEntry<'hir> {\n \n             EntryExpr(_, _, expr) => {\n                 match expr.node {\n-                    ExprClosure(.., body, _, _) => Some(body),\n+                    ExprKind::Closure(.., body, _, _) => Some(body),\n                     _ => None,\n                 }\n             }\n@@ -734,7 +734,7 @@ impl<'hir> Map<'hir> {\n             Some(NodeImplItem(_)) => true,\n             Some(NodeExpr(e)) => {\n                 match e.node {\n-                    ExprClosure(..) => true,\n+                    ExprKind::Closure(..) => true,\n                     _ => false,\n                 }\n             }\n@@ -821,7 +821,7 @@ impl<'hir> Map<'hir> {\n             match *node {\n                 NodeExpr(ref expr) => {\n                     match expr.node {\n-                        ExprWhile(..) | ExprLoop(..) => true,\n+                        ExprKind::While(..) | ExprKind::Loop(..) => true,\n                         _ => false,\n                     }\n                 }"}, {"sha": "5a185b966fd1da06433c69f26d5516a99898c539", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 61, "deletions": 62, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -12,7 +12,6 @@\n \n pub use self::BlockCheckMode::*;\n pub use self::CaptureClause::*;\n-pub use self::ExprKind::*;\n pub use self::FunctionRetTy::*;\n pub use self::ForeignItem_::*;\n pub use self::Item_::*;\n@@ -1285,42 +1284,42 @@ pub struct AnonConst {\n pub struct Expr {\n     pub id: NodeId,\n     pub span: Span,\n-    pub node: Expr_,\n+    pub node: ExprKind,\n     pub attrs: ThinVec<Attribute>,\n     pub hir_id: HirId,\n }\n \n impl Expr {\n     pub fn precedence(&self) -> ExprPrecedence {\n         match self.node {\n-            ExprBox(_) => ExprPrecedence::Box,\n-            ExprArray(_) => ExprPrecedence::Array,\n-            ExprCall(..) => ExprPrecedence::Call,\n-            ExprMethodCall(..) => ExprPrecedence::MethodCall,\n-            ExprTup(_) => ExprPrecedence::Tup,\n-            ExprBinary(op, ..) => ExprPrecedence::Binary(op.node.into()),\n-            ExprUnary(..) => ExprPrecedence::Unary,\n-            ExprLit(_) => ExprPrecedence::Lit,\n-            ExprType(..) | ExprCast(..) => ExprPrecedence::Cast,\n-            ExprIf(..) => ExprPrecedence::If,\n-            ExprWhile(..) => ExprPrecedence::While,\n-            ExprLoop(..) => ExprPrecedence::Loop,\n-            ExprMatch(..) => ExprPrecedence::Match,\n-            ExprClosure(..) => ExprPrecedence::Closure,\n-            ExprBlock(..) => ExprPrecedence::Block,\n-            ExprAssign(..) => ExprPrecedence::Assign,\n-            ExprAssignOp(..) => ExprPrecedence::AssignOp,\n-            ExprField(..) => ExprPrecedence::Field,\n-            ExprIndex(..) => ExprPrecedence::Index,\n-            ExprPath(..) => ExprPrecedence::Path,\n-            ExprAddrOf(..) => ExprPrecedence::AddrOf,\n-            ExprBreak(..) => ExprPrecedence::Break,\n-            ExprContinue(..) => ExprPrecedence::Continue,\n-            ExprRet(..) => ExprPrecedence::Ret,\n-            ExprInlineAsm(..) => ExprPrecedence::InlineAsm,\n-            ExprStruct(..) => ExprPrecedence::Struct,\n-            ExprRepeat(..) => ExprPrecedence::Repeat,\n-            ExprYield(..) => ExprPrecedence::Yield,\n+            ExprKind::Box(_) => ExprPrecedence::Box,\n+            ExprKind::Array(_) => ExprPrecedence::Array,\n+            ExprKind::Call(..) => ExprPrecedence::Call,\n+            ExprKind::MethodCall(..) => ExprPrecedence::MethodCall,\n+            ExprKind::Tup(_) => ExprPrecedence::Tup,\n+            ExprKind::Binary(op, ..) => ExprPrecedence::Binary(op.node.into()),\n+            ExprKind::Unary(..) => ExprPrecedence::Unary,\n+            ExprKind::Lit(_) => ExprPrecedence::Lit,\n+            ExprKind::Type(..) | ExprKind::Cast(..) => ExprPrecedence::Cast,\n+            ExprKind::If(..) => ExprPrecedence::If,\n+            ExprKind::While(..) => ExprPrecedence::While,\n+            ExprKind::Loop(..) => ExprPrecedence::Loop,\n+            ExprKind::Match(..) => ExprPrecedence::Match,\n+            ExprKind::Closure(..) => ExprPrecedence::Closure,\n+            ExprKind::Block(..) => ExprPrecedence::Block,\n+            ExprKind::Assign(..) => ExprPrecedence::Assign,\n+            ExprKind::AssignOp(..) => ExprPrecedence::AssignOp,\n+            ExprKind::Field(..) => ExprPrecedence::Field,\n+            ExprKind::Index(..) => ExprPrecedence::Index,\n+            ExprKind::Path(..) => ExprPrecedence::Path,\n+            ExprKind::AddrOf(..) => ExprPrecedence::AddrOf,\n+            ExprKind::Break(..) => ExprPrecedence::Break,\n+            ExprKind::Continue(..) => ExprPrecedence::Continue,\n+            ExprKind::Ret(..) => ExprPrecedence::Ret,\n+            ExprKind::InlineAsm(..) => ExprPrecedence::InlineAsm,\n+            ExprKind::Struct(..) => ExprPrecedence::Struct,\n+            ExprKind::Repeat(..) => ExprPrecedence::Repeat,\n+            ExprKind::Yield(..) => ExprPrecedence::Yield,\n         }\n     }\n }\n@@ -1333,18 +1332,18 @@ impl fmt::Debug for Expr {\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub enum Expr_ {\n+pub enum ExprKind {\n     /// A `box x` expression.\n-    ExprBox(P<Expr>),\n+    Box(P<Expr>),\n     /// An array (`[a, b, c, d]`)\n-    ExprArray(HirVec<Expr>),\n+    Array(HirVec<Expr>),\n     /// A function call\n     ///\n-    /// The first field resolves to the function itself (usually an `ExprPath`),\n+    /// The first field resolves to the function itself (usually an `ExprKind::Path`),\n     /// and the second field is the list of arguments.\n     /// This also represents calling the constructor of\n     /// tuple-like ADTs such as tuple structs and enum variants.\n-    ExprCall(P<Expr>, HirVec<Expr>),\n+    Call(P<Expr>, HirVec<Expr>),\n     /// A method call (`x.foo::<'static, Bar, Baz>(a, b, c, d)`)\n     ///\n     /// The `PathSegment`/`Span` represent the method name and its generic arguments\n@@ -1354,83 +1353,83 @@ pub enum Expr_ {\n     /// and the remaining elements are the rest of the arguments.\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n     /// `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, [x, a, b, c, d])`.\n-    ExprMethodCall(PathSegment, Span, HirVec<Expr>),\n+    MethodCall(PathSegment, Span, HirVec<Expr>),\n     /// A tuple (`(a, b, c ,d)`)\n-    ExprTup(HirVec<Expr>),\n+    Tup(HirVec<Expr>),\n     /// A binary operation (For example: `a + b`, `a * b`)\n-    ExprBinary(BinOp, P<Expr>, P<Expr>),\n+    Binary(BinOp, P<Expr>, P<Expr>),\n     /// A unary operation (For example: `!x`, `*x`)\n-    ExprUnary(UnOp, P<Expr>),\n+    Unary(UnOp, P<Expr>),\n     /// A literal (For example: `1`, `\"foo\"`)\n-    ExprLit(P<Lit>),\n+    Lit(P<Lit>),\n     /// A cast (`foo as f64`)\n-    ExprCast(P<Expr>, P<Ty>),\n-    ExprType(P<Expr>, P<Ty>),\n+    Cast(P<Expr>, P<Ty>),\n+    Type(P<Expr>, P<Ty>),\n     /// An `if` block, with an optional else block\n     ///\n     /// `if expr { expr } else { expr }`\n-    ExprIf(P<Expr>, P<Expr>, Option<P<Expr>>),\n+    If(P<Expr>, P<Expr>, Option<P<Expr>>),\n     /// A while loop, with an optional label\n     ///\n     /// `'label: while expr { block }`\n-    ExprWhile(P<Expr>, P<Block>, Option<Label>),\n+    While(P<Expr>, P<Block>, Option<Label>),\n     /// Conditionless loop (can be exited with break, continue, or return)\n     ///\n     /// `'label: loop { block }`\n-    ExprLoop(P<Block>, Option<Label>, LoopSource),\n+    Loop(P<Block>, Option<Label>, LoopSource),\n     /// A `match` block, with a source that indicates whether or not it is\n     /// the result of a desugaring, and if so, which kind.\n-    ExprMatch(P<Expr>, HirVec<Arm>, MatchSource),\n+    Match(P<Expr>, HirVec<Arm>, MatchSource),\n     /// A closure (for example, `move |a, b, c| {a + b + c}`).\n     ///\n     /// The final span is the span of the argument block `|...|`\n     ///\n     /// This may also be a generator literal, indicated by the final boolean,\n     /// in that case there is an GeneratorClause.\n-    ExprClosure(CaptureClause, P<FnDecl>, BodyId, Span, Option<GeneratorMovability>),\n+    Closure(CaptureClause, P<FnDecl>, BodyId, Span, Option<GeneratorMovability>),\n     /// A block (`'label: { ... }`)\n-    ExprBlock(P<Block>, Option<Label>),\n+    Block(P<Block>, Option<Label>),\n \n     /// An assignment (`a = foo()`)\n-    ExprAssign(P<Expr>, P<Expr>),\n+    Assign(P<Expr>, P<Expr>),\n     /// An assignment with an operator\n     ///\n     /// For example, `a += 1`.\n-    ExprAssignOp(BinOp, P<Expr>, P<Expr>),\n+    AssignOp(BinOp, P<Expr>, P<Expr>),\n     /// Access of a named (`obj.foo`) or unnamed (`obj.0`) struct or tuple field\n-    ExprField(P<Expr>, Ident),\n+    Field(P<Expr>, Ident),\n     /// An indexing operation (`foo[2]`)\n-    ExprIndex(P<Expr>, P<Expr>),\n+    Index(P<Expr>, P<Expr>),\n \n     /// Path to a definition, possibly containing lifetime or type parameters.\n-    ExprPath(QPath),\n+    Path(QPath),\n \n     /// A referencing operation (`&a` or `&mut a`)\n-    ExprAddrOf(Mutability, P<Expr>),\n+    AddrOf(Mutability, P<Expr>),\n     /// A `break`, with an optional label to break\n-    ExprBreak(Destination, Option<P<Expr>>),\n+    Break(Destination, Option<P<Expr>>),\n     /// A `continue`, with an optional label\n-    ExprContinue(Destination),\n+    Continue(Destination),\n     /// A `return`, with an optional value to be returned\n-    ExprRet(Option<P<Expr>>),\n+    Ret(Option<P<Expr>>),\n \n     /// Inline assembly (from `asm!`), with its outputs and inputs.\n-    ExprInlineAsm(P<InlineAsm>, HirVec<Expr>, HirVec<Expr>),\n+    InlineAsm(P<InlineAsm>, HirVec<Expr>, HirVec<Expr>),\n \n     /// A struct or struct-like variant literal expression.\n     ///\n     /// For example, `Foo {x: 1, y: 2}`, or\n     /// `Foo {x: 1, .. base}`, where `base` is the `Option<Expr>`.\n-    ExprStruct(QPath, HirVec<Field>, Option<P<Expr>>),\n+    Struct(QPath, HirVec<Field>, Option<P<Expr>>),\n \n     /// An array literal constructed from one repeated element.\n     ///\n     /// For example, `[1; 5]`. The first expression is the element\n     /// to be repeated; the second is the number of times to repeat it.\n-    ExprRepeat(P<Expr>, AnonConst),\n+    Repeat(P<Expr>, AnonConst),\n \n     /// A suspension point for generators. This is `yield <expr>` in Rust.\n-    ExprYield(P<Expr>),\n+    Yield(P<Expr>),\n }\n \n /// Optionally `Self`-qualified value/type path or associated extension.\n@@ -1480,7 +1479,7 @@ pub enum MatchSource {\n     TryDesugar,\n }\n \n-/// The loop type that yielded an ExprLoop\n+/// The loop type that yielded an ExprKind::Loop\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum LoopSource {\n     /// A `loop { .. }` loop"}, {"sha": "1078a0bec34a3ba8e48840faa953689582b862b7", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -1080,7 +1080,7 @@ impl<'a> State<'a> {\n             Some(_else) => {\n                 match _else.node {\n                     // \"another else-if\"\n-                    hir::ExprIf(ref i, ref then, ref e) => {\n+                    hir::ExprKind::If(ref i, ref then, ref e) => {\n                         self.cbox(indent_unit - 1)?;\n                         self.ibox(0)?;\n                         self.s.word(\" else if \")?;\n@@ -1090,7 +1090,7 @@ impl<'a> State<'a> {\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n                     // \"final else\"\n-                    hir::ExprBlock(ref b, _) => {\n+                    hir::ExprKind::Block(ref b, _) => {\n                         self.cbox(indent_unit - 1)?;\n                         self.ibox(0)?;\n                         self.s.word(\" else \")?;\n@@ -1162,9 +1162,9 @@ impl<'a> State<'a> {\n         let needs_par = match expr.node {\n             // These cases need parens due to the parse error observed in #26461: `if return {}`\n             // parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n-            hir::ExprClosure(..) |\n-            hir::ExprRet(..) |\n-            hir::ExprBreak(..) => true,\n+            hir::ExprKind::Closure(..) |\n+            hir::ExprKind::Ret(..) |\n+            hir::ExprKind::Break(..) => true,\n \n             _ => contains_exterior_struct_lit(expr),\n         };\n@@ -1247,7 +1247,7 @@ impl<'a> State<'a> {\n     fn print_expr_call(&mut self, func: &hir::Expr, args: &[hir::Expr]) -> io::Result<()> {\n         let prec =\n             match func.node {\n-                hir::ExprField(..) => parser::PREC_FORCE_PAREN,\n+                hir::ExprKind::Field(..) => parser::PREC_FORCE_PAREN,\n                 _ => parser::PREC_POSTFIX,\n             };\n \n@@ -1292,8 +1292,8 @@ impl<'a> State<'a> {\n             // These cases need parens: `x as i32 < y` has the parser thinking that `i32 < y` is\n             // the beginning of a path type. It starts trying to parse `x as (i32 < y ...` instead\n             // of `(x as i32) < ...`. We need to convince it _not_ to do that.\n-            (&hir::ExprCast { .. }, hir::BinOpKind::Lt) |\n-            (&hir::ExprCast { .. }, hir::BinOpKind::Shl) => parser::PREC_FORCE_PAREN,\n+            (&hir::ExprKind::Cast { .. }, hir::BinOpKind::Lt) |\n+            (&hir::ExprKind::Cast { .. }, hir::BinOpKind::Shl) => parser::PREC_FORCE_PAREN,\n             _ => left_prec,\n         };\n \n@@ -1323,57 +1323,57 @@ impl<'a> State<'a> {\n         self.ibox(indent_unit)?;\n         self.ann.pre(self, NodeExpr(expr))?;\n         match expr.node {\n-            hir::ExprBox(ref expr) => {\n+            hir::ExprKind::Box(ref expr) => {\n                 self.word_space(\"box\")?;\n                 self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)?;\n             }\n-            hir::ExprArray(ref exprs) => {\n+            hir::ExprKind::Array(ref exprs) => {\n                 self.print_expr_vec(exprs)?;\n             }\n-            hir::ExprRepeat(ref element, ref count) => {\n+            hir::ExprKind::Repeat(ref element, ref count) => {\n                 self.print_expr_repeat(&element, count)?;\n             }\n-            hir::ExprStruct(ref qpath, ref fields, ref wth) => {\n+            hir::ExprKind::Struct(ref qpath, ref fields, ref wth) => {\n                 self.print_expr_struct(qpath, &fields[..], wth)?;\n             }\n-            hir::ExprTup(ref exprs) => {\n+            hir::ExprKind::Tup(ref exprs) => {\n                 self.print_expr_tup(exprs)?;\n             }\n-            hir::ExprCall(ref func, ref args) => {\n+            hir::ExprKind::Call(ref func, ref args) => {\n                 self.print_expr_call(&func, args)?;\n             }\n-            hir::ExprMethodCall(ref segment, _, ref args) => {\n+            hir::ExprKind::MethodCall(ref segment, _, ref args) => {\n                 self.print_expr_method_call(segment, args)?;\n             }\n-            hir::ExprBinary(op, ref lhs, ref rhs) => {\n+            hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n                 self.print_expr_binary(op, &lhs, &rhs)?;\n             }\n-            hir::ExprUnary(op, ref expr) => {\n+            hir::ExprKind::Unary(op, ref expr) => {\n                 self.print_expr_unary(op, &expr)?;\n             }\n-            hir::ExprAddrOf(m, ref expr) => {\n+            hir::ExprKind::AddrOf(m, ref expr) => {\n                 self.print_expr_addr_of(m, &expr)?;\n             }\n-            hir::ExprLit(ref lit) => {\n+            hir::ExprKind::Lit(ref lit) => {\n                 self.print_literal(&lit)?;\n             }\n-            hir::ExprCast(ref expr, ref ty) => {\n+            hir::ExprKind::Cast(ref expr, ref ty) => {\n                 let prec = AssocOp::As.precedence() as i8;\n                 self.print_expr_maybe_paren(&expr, prec)?;\n                 self.s.space()?;\n                 self.word_space(\"as\")?;\n                 self.print_type(&ty)?;\n             }\n-            hir::ExprType(ref expr, ref ty) => {\n+            hir::ExprKind::Type(ref expr, ref ty) => {\n                 let prec = AssocOp::Colon.precedence() as i8;\n                 self.print_expr_maybe_paren(&expr, prec)?;\n                 self.word_space(\":\")?;\n                 self.print_type(&ty)?;\n             }\n-            hir::ExprIf(ref test, ref blk, ref elseopt) => {\n+            hir::ExprKind::If(ref test, ref blk, ref elseopt) => {\n                 self.print_if(&test, &blk, elseopt.as_ref().map(|e| &**e))?;\n             }\n-            hir::ExprWhile(ref test, ref blk, opt_label) => {\n+            hir::ExprKind::While(ref test, ref blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident)?;\n                     self.word_space(\":\")?;\n@@ -1383,7 +1383,7 @@ impl<'a> State<'a> {\n                 self.s.space()?;\n                 self.print_block(&blk)?;\n             }\n-            hir::ExprLoop(ref blk, opt_label, _) => {\n+            hir::ExprKind::Loop(ref blk, opt_label, _) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident)?;\n                     self.word_space(\":\")?;\n@@ -1392,7 +1392,7 @@ impl<'a> State<'a> {\n                 self.s.space()?;\n                 self.print_block(&blk)?;\n             }\n-            hir::ExprMatch(ref expr, ref arms, _) => {\n+            hir::ExprKind::Match(ref expr, ref arms, _) => {\n                 self.cbox(indent_unit)?;\n                 self.ibox(4)?;\n                 self.word_nbsp(\"match\")?;\n@@ -1404,7 +1404,7 @@ impl<'a> State<'a> {\n                 }\n                 self.bclose_(expr.span, indent_unit)?;\n             }\n-            hir::ExprClosure(capture_clause, ref decl, body, _fn_decl_span, _gen) => {\n+            hir::ExprKind::Closure(capture_clause, ref decl, body, _fn_decl_span, _gen) => {\n                 self.print_capture_clause(capture_clause)?;\n \n                 self.print_closure_args(&decl, body)?;\n@@ -1419,7 +1419,7 @@ impl<'a> State<'a> {\n                 // empty box to satisfy the close.\n                 self.ibox(0)?;\n             }\n-            hir::ExprBlock(ref blk, opt_label) => {\n+            hir::ExprKind::Block(ref blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident)?;\n                     self.word_space(\":\")?;\n@@ -1430,36 +1430,36 @@ impl<'a> State<'a> {\n                 self.ibox(0)?;\n                 self.print_block(&blk)?;\n             }\n-            hir::ExprAssign(ref lhs, ref rhs) => {\n+            hir::ExprKind::Assign(ref lhs, ref rhs) => {\n                 let prec = AssocOp::Assign.precedence() as i8;\n                 self.print_expr_maybe_paren(&lhs, prec + 1)?;\n                 self.s.space()?;\n                 self.word_space(\"=\")?;\n                 self.print_expr_maybe_paren(&rhs, prec)?;\n             }\n-            hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n+            hir::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n                 let prec = AssocOp::Assign.precedence() as i8;\n                 self.print_expr_maybe_paren(&lhs, prec + 1)?;\n                 self.s.space()?;\n                 self.s.word(op.node.as_str())?;\n                 self.word_space(\"=\")?;\n                 self.print_expr_maybe_paren(&rhs, prec)?;\n             }\n-            hir::ExprField(ref expr, ident) => {\n+            hir::ExprKind::Field(ref expr, ident) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX)?;\n                 self.s.word(\".\")?;\n                 self.print_ident(ident)?;\n             }\n-            hir::ExprIndex(ref expr, ref index) => {\n+            hir::ExprKind::Index(ref expr, ref index) => {\n                 self.print_expr_maybe_paren(&expr, parser::PREC_POSTFIX)?;\n                 self.s.word(\"[\")?;\n                 self.print_expr(&index)?;\n                 self.s.word(\"]\")?;\n             }\n-            hir::ExprPath(ref qpath) => {\n+            hir::ExprKind::Path(ref qpath) => {\n                 self.print_qpath(qpath, true)?\n             }\n-            hir::ExprBreak(destination, ref opt_expr) => {\n+            hir::ExprKind::Break(destination, ref opt_expr) => {\n                 self.s.word(\"break\")?;\n                 self.s.space()?;\n                 if let Some(label) = destination.label {\n@@ -1471,15 +1471,15 @@ impl<'a> State<'a> {\n                     self.s.space()?;\n                 }\n             }\n-            hir::ExprContinue(destination) => {\n+            hir::ExprKind::Continue(destination) => {\n                 self.s.word(\"continue\")?;\n                 self.s.space()?;\n                 if let Some(label) = destination.label {\n                     self.print_ident(label.ident)?;\n                     self.s.space()?\n                 }\n             }\n-            hir::ExprRet(ref result) => {\n+            hir::ExprKind::Ret(ref result) => {\n                 self.s.word(\"return\")?;\n                 match *result {\n                     Some(ref expr) => {\n@@ -1489,7 +1489,7 @@ impl<'a> State<'a> {\n                     _ => (),\n                 }\n             }\n-            hir::ExprInlineAsm(ref a, ref outputs, ref inputs) => {\n+            hir::ExprKind::InlineAsm(ref a, ref outputs, ref inputs) => {\n                 self.s.word(\"asm!\")?;\n                 self.popen()?;\n                 self.print_string(&a.asm.as_str(), a.asm_str_style)?;\n@@ -1554,7 +1554,7 @@ impl<'a> State<'a> {\n \n                 self.pclose()?;\n             }\n-            hir::ExprYield(ref expr) => {\n+            hir::ExprKind::Yield(ref expr) => {\n                 self.word_space(\"yield\")?;\n                 self.print_expr_maybe_paren(&expr, parser::PREC_JUMP)?;\n             }\n@@ -1959,7 +1959,7 @@ impl<'a> State<'a> {\n         self.word_space(\"=>\")?;\n \n         match arm.body.node {\n-            hir::ExprBlock(ref blk, opt_label) => {\n+            hir::ExprKind::Block(ref blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident)?;\n                     self.word_space(\":\")?;\n@@ -2384,11 +2384,11 @@ impl<'a> State<'a> {\n /// isn't parsed as (if true {...} else {...} | x) | 5\n fn expr_requires_semi_to_be_stmt(e: &hir::Expr) -> bool {\n     match e.node {\n-        hir::ExprIf(..) |\n-        hir::ExprMatch(..) |\n-        hir::ExprBlock(..) |\n-        hir::ExprWhile(..) |\n-        hir::ExprLoop(..) => false,\n+        hir::ExprKind::If(..) |\n+        hir::ExprKind::Match(..) |\n+        hir::ExprKind::Block(..) |\n+        hir::ExprKind::While(..) |\n+        hir::ExprKind::Loop(..) => false,\n         _ => true,\n     }\n }\n@@ -2445,24 +2445,24 @@ fn bin_op_to_assoc_op(op: hir::BinOpKind) -> AssocOp {\n /// `X { y: 1 } == foo` all do, but `(X { y: 1 }) == foo` does not.\n fn contains_exterior_struct_lit(value: &hir::Expr) -> bool {\n     match value.node {\n-        hir::ExprStruct(..) => true,\n+        hir::ExprKind::Struct(..) => true,\n \n-        hir::ExprAssign(ref lhs, ref rhs) |\n-        hir::ExprAssignOp(_, ref lhs, ref rhs) |\n-        hir::ExprBinary(_, ref lhs, ref rhs) => {\n+        hir::ExprKind::Assign(ref lhs, ref rhs) |\n+        hir::ExprKind::AssignOp(_, ref lhs, ref rhs) |\n+        hir::ExprKind::Binary(_, ref lhs, ref rhs) => {\n             // X { y: 1 } + X { y: 2 }\n             contains_exterior_struct_lit(&lhs) || contains_exterior_struct_lit(&rhs)\n         }\n-        hir::ExprUnary(_, ref x) |\n-        hir::ExprCast(ref x, _) |\n-        hir::ExprType(ref x, _) |\n-        hir::ExprField(ref x, _) |\n-        hir::ExprIndex(ref x, _) => {\n+        hir::ExprKind::Unary(_, ref x) |\n+        hir::ExprKind::Cast(ref x, _) |\n+        hir::ExprKind::Type(ref x, _) |\n+        hir::ExprKind::Field(ref x, _) |\n+        hir::ExprKind::Index(ref x, _) => {\n             // &X { y: 1 }, X { y: 1 }.y\n             contains_exterior_struct_lit(&x)\n         }\n \n-        hir::ExprMethodCall(.., ref exprs) => {\n+        hir::ExprKind::MethodCall(.., ref exprs) => {\n             // X { y: 1 }.bar(...)\n             contains_exterior_struct_lit(&exprs[0])\n         }"}, {"sha": "e045ea64135a5939faf0d9cd1636157c58875eda", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -541,36 +541,36 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Expr {\n     }\n }\n \n-impl_stable_hash_for!(enum hir::Expr_ {\n-    ExprBox(sub),\n-    ExprArray(subs),\n-    ExprCall(callee, args),\n-    ExprMethodCall(segment, span, args),\n-    ExprTup(fields),\n-    ExprBinary(op, lhs, rhs),\n-    ExprUnary(op, operand),\n-    ExprLit(value),\n-    ExprCast(expr, t),\n-    ExprType(expr, t),\n-    ExprIf(cond, then, els),\n-    ExprWhile(cond, body, label),\n-    ExprLoop(body, label, loop_src),\n-    ExprMatch(matchee, arms, match_src),\n-    ExprClosure(capture_clause, decl, body_id, span, gen),\n-    ExprBlock(blk, label),\n-    ExprAssign(lhs, rhs),\n-    ExprAssignOp(op, lhs, rhs),\n-    ExprField(owner, ident),\n-    ExprIndex(lhs, rhs),\n-    ExprPath(path),\n-    ExprAddrOf(mutability, sub),\n-    ExprBreak(destination, sub),\n-    ExprContinue(destination),\n-    ExprRet(val),\n-    ExprInlineAsm(asm, inputs, outputs),\n-    ExprStruct(path, fields, base),\n-    ExprRepeat(val, times),\n-    ExprYield(val)\n+impl_stable_hash_for!(enum hir::ExprKind {\n+    Box(sub),\n+    Array(subs),\n+    Call(callee, args),\n+    MethodCall(segment, span, args),\n+    Tup(fields),\n+    Binary(op, lhs, rhs),\n+    Unary(op, operand),\n+    Lit(value),\n+    Cast(expr, t),\n+    Type(expr, t),\n+    If(cond, then, els),\n+    While(cond, body, label),\n+    Loop(body, label, loop_src),\n+    Match(matchee, arms, match_src),\n+    Closure(capture_clause, decl, body_id, span, gen),\n+    Block(blk, label),\n+    Assign(lhs, rhs),\n+    AssignOp(op, lhs, rhs),\n+    Field(owner, ident),\n+    Index(lhs, rhs),\n+    Path(path),\n+    AddrOf(mutability, sub),\n+    Break(destination, sub),\n+    Continue(destination),\n+    Ret(val),\n+    InlineAsm(asm, inputs, outputs),\n+    Struct(path, fields, base),\n+    Repeat(val, times),\n+    Yield(val)\n });\n \n impl_stable_hash_for!(enum hir::LocalSource {"}, {"sha": "680d1623742cf763f406d5ee973879862022503b", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -102,12 +102,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 let tag = match self.hir.find(scope.node_id(self, region_scope_tree)) {\n                     Some(hir_map::NodeBlock(_)) => \"block\",\n                     Some(hir_map::NodeExpr(expr)) => match expr.node {\n-                        hir::ExprCall(..) => \"call\",\n-                        hir::ExprMethodCall(..) => \"method call\",\n-                        hir::ExprMatch(.., hir::MatchSource::IfLetDesugar { .. }) => \"if let\",\n-                        hir::ExprMatch(.., hir::MatchSource::WhileLetDesugar) => \"while let\",\n-                        hir::ExprMatch(.., hir::MatchSource::ForLoopDesugar) => \"for\",\n-                        hir::ExprMatch(..) => \"match\",\n+                        hir::ExprKind::Call(..) => \"call\",\n+                        hir::ExprKind::MethodCall(..) => \"method call\",\n+                        hir::ExprKind::Match(.., hir::MatchSource::IfLetDesugar { .. }) => \"if let\",\n+                        hir::ExprKind::Match(.., hir::MatchSource::WhileLetDesugar) => \"while let\",\n+                        hir::ExprKind::Match(.., hir::MatchSource::ForLoopDesugar) => \"for\",\n+                        hir::ExprKind::Match(..) => \"match\",\n                         _ => \"expression\",\n                     },\n                     Some(hir_map::NodeStmt(_)) => \"statement\","}, {"sha": "f4ef197e5b4223c53e1ee9b1d9068159674f4a88", "filename": "src/librustc/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -14,7 +14,7 @@\n use infer::error_reporting::nice_region_error::NiceRegionError;\n use infer::SubregionOrigin;\n use ty::RegionKind;\n-use hir::{Expr, ExprClosure};\n+use hir::{Expr, ExprKind::Closure};\n use hir::map::NodeExpr;\n use util::common::ErrorReported;\n use infer::lexical_region_resolve::RegionResolutionError::SubSupConflict;\n@@ -60,7 +60,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n                 if let Some(node_id) = hir.as_local_node_id(free_region.scope) {\n                     match hir.get(node_id) {\n                         NodeExpr(Expr {\n-                            node: ExprClosure(_, _, _, closure_span, None),\n+                            node: Closure(_, _, _, closure_span, None),\n                             ..\n                         }) => {\n                             let sup_sp = sup_origin.span();"}, {"sha": "0e3ae7ca70f271cd0feb5329be7056374b58614e", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -225,17 +225,17 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n-            hir::ExprPath(ref qpath @ hir::QPath::TypeRelative(..)) => {\n+            hir::ExprKind::Path(ref qpath @ hir::QPath::TypeRelative(..)) => {\n                 let def = self.tables.qpath_def(qpath, expr.hir_id);\n                 self.handle_definition(def);\n             }\n-            hir::ExprMethodCall(..) => {\n+            hir::ExprKind::MethodCall(..) => {\n                 self.lookup_and_handle_method(expr.hir_id);\n             }\n-            hir::ExprField(ref lhs, ..) => {\n+            hir::ExprKind::Field(ref lhs, ..) => {\n                 self.handle_field_access(&lhs, expr.id);\n             }\n-            hir::ExprStruct(_, ref fields, _) => {\n+            hir::ExprKind::Struct(_, ref fields, _) => {\n                 if let ty::TypeVariants::TyAdt(ref adt, _) = self.tables.expr_ty(expr).sty {\n                     self.mark_as_used_if_union(adt, fields);\n                 }\n@@ -492,7 +492,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     //            `None` otherwise.\n     // If the item is a struct_ctor, then either its `id` or\n     // `ctor_id` (unwrapped) is in the live_symbols set. More specifically,\n-    // DefMap maps the ExprPath of a struct_ctor to the node referred by\n+    // DefMap maps the ExprKind::Path of a struct_ctor to the node referred by\n     // `ctor_id`. On the other hand, in a statement like\n     // `type <ident> <generics> = <ty>;` where <ty> refers to a struct_ctor,\n     // DefMap maps <ty> to `id` instead."}, {"sha": "5beafe2b601bf0749dcd7a84d933766a2d1ba9cf", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -392,51 +392,51 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         self.walk_adjustment(expr);\n \n         match expr.node {\n-            hir::ExprPath(_) => { }\n+            hir::ExprKind::Path(_) => { }\n \n-            hir::ExprType(ref subexpr, _) => {\n+            hir::ExprKind::Type(ref subexpr, _) => {\n                 self.walk_expr(&subexpr)\n             }\n \n-            hir::ExprUnary(hir::UnDeref, ref base) => {      // *base\n+            hir::ExprKind::Unary(hir::UnDeref, ref base) => {      // *base\n                 self.select_from_expr(&base);\n             }\n \n-            hir::ExprField(ref base, _) => {         // base.f\n+            hir::ExprKind::Field(ref base, _) => {         // base.f\n                 self.select_from_expr(&base);\n             }\n \n-            hir::ExprIndex(ref lhs, ref rhs) => {       // lhs[rhs]\n+            hir::ExprKind::Index(ref lhs, ref rhs) => {       // lhs[rhs]\n                 self.select_from_expr(&lhs);\n                 self.consume_expr(&rhs);\n             }\n \n-            hir::ExprCall(ref callee, ref args) => {    // callee(args)\n+            hir::ExprKind::Call(ref callee, ref args) => {    // callee(args)\n                 self.walk_callee(expr, &callee);\n                 self.consume_exprs(args);\n             }\n \n-            hir::ExprMethodCall(.., ref args) => { // callee.m(args)\n+            hir::ExprKind::MethodCall(.., ref args) => { // callee.m(args)\n                 self.consume_exprs(args);\n             }\n \n-            hir::ExprStruct(_, ref fields, ref opt_with) => {\n+            hir::ExprKind::Struct(_, ref fields, ref opt_with) => {\n                 self.walk_struct_expr(fields, opt_with);\n             }\n \n-            hir::ExprTup(ref exprs) => {\n+            hir::ExprKind::Tup(ref exprs) => {\n                 self.consume_exprs(exprs);\n             }\n \n-            hir::ExprIf(ref cond_expr, ref then_expr, ref opt_else_expr) => {\n+            hir::ExprKind::If(ref cond_expr, ref then_expr, ref opt_else_expr) => {\n                 self.consume_expr(&cond_expr);\n                 self.walk_expr(&then_expr);\n                 if let Some(ref else_expr) = *opt_else_expr {\n                     self.consume_expr(&else_expr);\n                 }\n             }\n \n-            hir::ExprMatch(ref discr, ref arms, _) => {\n+            hir::ExprKind::Match(ref discr, ref arms, _) => {\n                 let discr_cmt = Rc::new(return_if_err!(self.mc.cat_expr(&discr)));\n                 let r = self.tcx().types.re_empty;\n                 self.borrow_expr(&discr, r, ty::ImmBorrow, MatchDiscriminant);\n@@ -449,11 +449,11 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            hir::ExprArray(ref exprs) => {\n+            hir::ExprKind::Array(ref exprs) => {\n                 self.consume_exprs(exprs);\n             }\n \n-            hir::ExprAddrOf(m, ref base) => {   // &base\n+            hir::ExprKind::AddrOf(m, ref base) => {   // &base\n                 // make sure that the thing we are pointing out stays valid\n                 // for the lifetime `scope_r` of the resulting ptr:\n                 let expr_ty = return_if_err!(self.mc.expr_ty(expr));\n@@ -463,7 +463,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            hir::ExprInlineAsm(ref ia, ref outputs, ref inputs) => {\n+            hir::ExprKind::InlineAsm(ref ia, ref outputs, ref inputs) => {\n                 for (o, output) in ia.outputs.iter().zip(outputs) {\n                     if o.is_indirect {\n                         self.consume_expr(output);\n@@ -479,47 +479,47 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.consume_exprs(inputs);\n             }\n \n-            hir::ExprContinue(..) |\n-            hir::ExprLit(..) => {}\n+            hir::ExprKind::Continue(..) |\n+            hir::ExprKind::Lit(..) => {}\n \n-            hir::ExprLoop(ref blk, _, _) => {\n+            hir::ExprKind::Loop(ref blk, _, _) => {\n                 self.walk_block(&blk);\n             }\n \n-            hir::ExprWhile(ref cond_expr, ref blk, _) => {\n+            hir::ExprKind::While(ref cond_expr, ref blk, _) => {\n                 self.consume_expr(&cond_expr);\n                 self.walk_block(&blk);\n             }\n \n-            hir::ExprUnary(_, ref lhs) => {\n+            hir::ExprKind::Unary(_, ref lhs) => {\n                 self.consume_expr(&lhs);\n             }\n \n-            hir::ExprBinary(_, ref lhs, ref rhs) => {\n+            hir::ExprKind::Binary(_, ref lhs, ref rhs) => {\n                 self.consume_expr(&lhs);\n                 self.consume_expr(&rhs);\n             }\n \n-            hir::ExprBlock(ref blk, _) => {\n+            hir::ExprKind::Block(ref blk, _) => {\n                 self.walk_block(&blk);\n             }\n \n-            hir::ExprBreak(_, ref opt_expr) | hir::ExprRet(ref opt_expr) => {\n+            hir::ExprKind::Break(_, ref opt_expr) | hir::ExprKind::Ret(ref opt_expr) => {\n                 if let Some(ref expr) = *opt_expr {\n                     self.consume_expr(&expr);\n                 }\n             }\n \n-            hir::ExprAssign(ref lhs, ref rhs) => {\n+            hir::ExprKind::Assign(ref lhs, ref rhs) => {\n                 self.mutate_expr(expr, &lhs, MutateMode::JustWrite);\n                 self.consume_expr(&rhs);\n             }\n \n-            hir::ExprCast(ref base, _) => {\n+            hir::ExprKind::Cast(ref base, _) => {\n                 self.consume_expr(&base);\n             }\n \n-            hir::ExprAssignOp(_, ref lhs, ref rhs) => {\n+            hir::ExprKind::AssignOp(_, ref lhs, ref rhs) => {\n                 if self.mc.tables.is_method_call(expr) {\n                     self.consume_expr(lhs);\n                 } else {\n@@ -528,19 +528,19 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.consume_expr(&rhs);\n             }\n \n-            hir::ExprRepeat(ref base, _) => {\n+            hir::ExprKind::Repeat(ref base, _) => {\n                 self.consume_expr(&base);\n             }\n \n-            hir::ExprClosure(.., fn_decl_span, _) => {\n+            hir::ExprKind::Closure(.., fn_decl_span, _) => {\n                 self.walk_captures(expr, fn_decl_span)\n             }\n \n-            hir::ExprBox(ref base) => {\n+            hir::ExprKind::Box(ref base) => {\n                 self.consume_expr(&base);\n             }\n \n-            hir::ExprYield(ref value) => {\n+            hir::ExprKind::Yield(ref value) => {\n                 self.consume_expr(&value);\n             }\n         }"}, {"sha": "668bac1e4795b6671a693cd3fbb85732bf30d138", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -145,7 +145,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        let def = if let hir::ExprPath(ref qpath) = expr.node {\n+        let def = if let hir::ExprKind::Path(ref qpath) = expr.node {\n             self.tables.qpath_def(qpath, expr.hir_id)\n         } else {\n             Def::Err"}, {"sha": "dddb7a0c38f616e5e595d0e319e3c6715b499990", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -454,14 +454,14 @@ fn visit_arm<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, arm: &'tcx hir::Arm) {\n fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n-      hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+      hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n         debug!(\"expr {}: path that leads to {:?}\", expr.id, path.def);\n         if let Def::Local(..) = path.def {\n             ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n         }\n         intravisit::walk_expr(ir, expr);\n       }\n-      hir::ExprClosure(..) => {\n+      hir::ExprKind::Closure(..) => {\n         // Interesting control flow (for loops can contain labeled\n         // breaks or continues)\n         ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n@@ -486,25 +486,25 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n       }\n \n       // live nodes required for interesting control flow:\n-      hir::ExprIf(..) | hir::ExprMatch(..) | hir::ExprWhile(..) | hir::ExprLoop(..) => {\n+      hir::ExprKind::If(..) | hir::ExprKind::Match(..) | hir::ExprKind::While(..) | hir::ExprKind::Loop(..) => {\n         ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n         intravisit::walk_expr(ir, expr);\n       }\n-      hir::ExprBinary(op, ..) if op.node.is_lazy() => {\n+      hir::ExprKind::Binary(op, ..) if op.node.is_lazy() => {\n         ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n         intravisit::walk_expr(ir, expr);\n       }\n \n       // otherwise, live nodes are not required:\n-      hir::ExprIndex(..) | hir::ExprField(..) |\n-      hir::ExprArray(..) | hir::ExprCall(..) | hir::ExprMethodCall(..) |\n-      hir::ExprTup(..) | hir::ExprBinary(..) | hir::ExprAddrOf(..) |\n-      hir::ExprCast(..) | hir::ExprUnary(..) | hir::ExprBreak(..) |\n-      hir::ExprContinue(_) | hir::ExprLit(_) | hir::ExprRet(..) |\n-      hir::ExprBlock(..) | hir::ExprAssign(..) | hir::ExprAssignOp(..) |\n-      hir::ExprStruct(..) | hir::ExprRepeat(..) |\n-      hir::ExprInlineAsm(..) | hir::ExprBox(..) | hir::ExprYield(..) |\n-      hir::ExprType(..) | hir::ExprPath(hir::QPath::TypeRelative(..)) => {\n+      hir::ExprKind::Index(..) | hir::ExprKind::Field(..) |\n+      hir::ExprKind::Array(..) | hir::ExprKind::Call(..) | hir::ExprKind::MethodCall(..) |\n+      hir::ExprKind::Tup(..) | hir::ExprKind::Binary(..) | hir::ExprKind::AddrOf(..) |\n+      hir::ExprKind::Cast(..) | hir::ExprKind::Unary(..) | hir::ExprKind::Break(..) |\n+      hir::ExprKind::Continue(_) | hir::ExprKind::Lit(_) | hir::ExprKind::Ret(..) |\n+      hir::ExprKind::Block(..) | hir::ExprKind::Assign(..) | hir::ExprKind::AssignOp(..) |\n+      hir::ExprKind::Struct(..) | hir::ExprKind::Repeat(..) |\n+      hir::ExprKind::InlineAsm(..) | hir::ExprKind::Box(..) | hir::ExprKind::Yield(..) |\n+      hir::ExprKind::Type(..) | hir::ExprKind::Path(hir::QPath::TypeRelative(..)) => {\n           intravisit::walk_expr(ir, expr);\n       }\n     }\n@@ -920,16 +920,16 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         match expr.node {\n           // Interesting cases with control flow or which gen/kill\n-          hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+          hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n               self.access_path(expr.hir_id, path, succ, ACC_READ | ACC_USE)\n           }\n \n-          hir::ExprField(ref e, _) => {\n+          hir::ExprKind::Field(ref e, _) => {\n               self.propagate_through_expr(&e, succ)\n           }\n \n-          hir::ExprClosure(.., blk_id, _, _) => {\n-              debug!(\"{} is an ExprClosure\", self.ir.tcx.hir.node_to_pretty_string(expr.id));\n+          hir::ExprKind::Closure(.., blk_id, _, _) => {\n+              debug!(\"{} is an ExprKind::Closure\", self.ir.tcx.hir.node_to_pretty_string(expr.id));\n \n               // The next-node for a break is the successor of the entire\n               // loop. The next-node for a continue is the top of this loop.\n@@ -956,7 +956,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               })\n           }\n \n-          hir::ExprIf(ref cond, ref then, ref els) => {\n+          hir::ExprKind::If(ref cond, ref then, ref els) => {\n             //\n             //     (cond)\n             //       |\n@@ -978,17 +978,17 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&cond, ln)\n           }\n \n-          hir::ExprWhile(ref cond, ref blk, _) => {\n+          hir::ExprKind::While(ref cond, ref blk, _) => {\n             self.propagate_through_loop(expr, WhileLoop(&cond), &blk, succ)\n           }\n \n           // Note that labels have been resolved, so we don't need to look\n           // at the label ident\n-          hir::ExprLoop(ref blk, _, _) => {\n+          hir::ExprKind::Loop(ref blk, _, _) => {\n             self.propagate_through_loop(expr, LoopLoop, &blk, succ)\n           }\n \n-          hir::ExprMatch(ref e, ref arms, _) => {\n+          hir::ExprKind::Match(ref e, ref arms, _) => {\n             //\n             //      (e)\n             //       |\n@@ -1023,13 +1023,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&e, ln)\n           }\n \n-          hir::ExprRet(ref o_e) => {\n+          hir::ExprKind::Ret(ref o_e) => {\n             // ignore succ and subst exit_ln:\n             let exit_ln = self.s.exit_ln;\n             self.propagate_through_opt_expr(o_e.as_ref().map(|e| &**e), exit_ln)\n           }\n \n-          hir::ExprBreak(label, ref opt_expr) => {\n+          hir::ExprKind::Break(label, ref opt_expr) => {\n               // Find which label this break jumps to\n               let target = match label.target_id {\n                     Ok(node_id) => self.break_ln.get(&node_id),\n@@ -1045,7 +1045,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               }\n           }\n \n-          hir::ExprContinue(label) => {\n+          hir::ExprKind::Continue(label) => {\n               // Find which label this expr continues to\n               let sc = match label.target_id {\n                     Ok(node_id) => node_id,\n@@ -1061,15 +1061,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               }\n           }\n \n-          hir::ExprAssign(ref l, ref r) => {\n+          hir::ExprKind::Assign(ref l, ref r) => {\n             // see comment on places in\n             // propagate_through_place_components()\n             let succ = self.write_place(&l, succ, ACC_WRITE);\n             let succ = self.propagate_through_place_components(&l, succ);\n             self.propagate_through_expr(&r, succ)\n           }\n \n-          hir::ExprAssignOp(_, ref l, ref r) => {\n+          hir::ExprKind::AssignOp(_, ref l, ref r) => {\n             // an overloaded assign op is like a method call\n             if self.tables.is_method_call(expr) {\n                 let succ = self.propagate_through_expr(&l, succ);\n@@ -1085,18 +1085,18 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           // Uninteresting cases: just propagate in rev exec order\n \n-          hir::ExprArray(ref exprs) => {\n+          hir::ExprKind::Array(ref exprs) => {\n             self.propagate_through_exprs(exprs, succ)\n           }\n \n-          hir::ExprStruct(_, ref fields, ref with_expr) => {\n+          hir::ExprKind::Struct(_, ref fields, ref with_expr) => {\n             let succ = self.propagate_through_opt_expr(with_expr.as_ref().map(|e| &**e), succ);\n             fields.iter().rev().fold(succ, |succ, field| {\n                 self.propagate_through_expr(&field.expr, succ)\n             })\n           }\n \n-          hir::ExprCall(ref f, ref args) => {\n+          hir::ExprKind::Call(ref f, ref args) => {\n             // FIXME(canndrew): This is_never should really be an is_uninhabited\n             let succ = if self.tables.expr_ty(expr).is_never() {\n                 self.s.exit_ln\n@@ -1107,7 +1107,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&f, succ)\n           }\n \n-          hir::ExprMethodCall(.., ref args) => {\n+          hir::ExprKind::MethodCall(.., ref args) => {\n             // FIXME(canndrew): This is_never should really be an is_uninhabited\n             let succ = if self.tables.expr_ty(expr).is_never() {\n                 self.s.exit_ln\n@@ -1117,11 +1117,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_exprs(args, succ)\n           }\n \n-          hir::ExprTup(ref exprs) => {\n+          hir::ExprKind::Tup(ref exprs) => {\n             self.propagate_through_exprs(exprs, succ)\n           }\n \n-          hir::ExprBinary(op, ref l, ref r) if op.node.is_lazy() => {\n+          hir::ExprKind::Binary(op, ref l, ref r) if op.node.is_lazy() => {\n             let r_succ = self.propagate_through_expr(&r, succ);\n \n             let ln = self.live_node(expr.hir_id, expr.span);\n@@ -1131,23 +1131,23 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&l, ln)\n           }\n \n-          hir::ExprIndex(ref l, ref r) |\n-          hir::ExprBinary(_, ref l, ref r) => {\n+          hir::ExprKind::Index(ref l, ref r) |\n+          hir::ExprKind::Binary(_, ref l, ref r) => {\n             let r_succ = self.propagate_through_expr(&r, succ);\n             self.propagate_through_expr(&l, r_succ)\n           }\n \n-          hir::ExprBox(ref e) |\n-          hir::ExprAddrOf(_, ref e) |\n-          hir::ExprCast(ref e, _) |\n-          hir::ExprType(ref e, _) |\n-          hir::ExprUnary(_, ref e) |\n-          hir::ExprYield(ref e) |\n-          hir::ExprRepeat(ref e, _) => {\n+          hir::ExprKind::Box(ref e) |\n+          hir::ExprKind::AddrOf(_, ref e) |\n+          hir::ExprKind::Cast(ref e, _) |\n+          hir::ExprKind::Type(ref e, _) |\n+          hir::ExprKind::Unary(_, ref e) |\n+          hir::ExprKind::Yield(ref e) |\n+          hir::ExprKind::Repeat(ref e, _) => {\n             self.propagate_through_expr(&e, succ)\n           }\n \n-          hir::ExprInlineAsm(ref ia, ref outputs, ref inputs) => {\n+          hir::ExprKind::InlineAsm(ref ia, ref outputs, ref inputs) => {\n             let succ = ia.outputs.iter().zip(outputs).rev().fold(succ, |succ, (o, output)| {\n                 // see comment on places\n                 // in propagate_through_place_components()\n@@ -1164,13 +1164,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_exprs(inputs, succ)\n           }\n \n-          hir::ExprLit(..) | hir::ExprPath(hir::QPath::TypeRelative(..)) => {\n+          hir::ExprKind::Lit(..) | hir::ExprKind::Path(hir::QPath::TypeRelative(..)) => {\n             succ\n           }\n \n           // Note that labels have been resolved, so we don't need to look\n           // at the label ident\n-          hir::ExprBlock(ref blk, _) => {\n+          hir::ExprKind::Block(ref blk, _) => {\n             self.propagate_through_block(&blk, succ)\n           }\n         }\n@@ -1230,8 +1230,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // just ignore such cases and treat them as reads.\n \n         match expr.node {\n-            hir::ExprPath(_) => succ,\n-            hir::ExprField(ref e, _) => self.propagate_through_expr(&e, succ),\n+            hir::ExprKind::Path(_) => succ,\n+            hir::ExprKind::Field(ref e, _) => self.propagate_through_expr(&e, succ),\n             _ => self.propagate_through_expr(expr, succ)\n         }\n     }\n@@ -1240,7 +1240,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn write_place(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n                     -> LiveNode {\n         match expr.node {\n-          hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+          hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n               self.access_path(expr.hir_id, path, succ, acc)\n           }\n \n@@ -1393,21 +1393,21 @@ fn check_arm<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, arm: &'tcx hir::Arm) {\n \n fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n     match expr.node {\n-      hir::ExprAssign(ref l, _) => {\n+      hir::ExprKind::Assign(ref l, _) => {\n         this.check_place(&l);\n \n         intravisit::walk_expr(this, expr);\n       }\n \n-      hir::ExprAssignOp(_, ref l, _) => {\n+      hir::ExprKind::AssignOp(_, ref l, _) => {\n         if !this.tables.is_method_call(expr) {\n             this.check_place(&l);\n         }\n \n         intravisit::walk_expr(this, expr);\n       }\n \n-      hir::ExprInlineAsm(ref ia, ref outputs, ref inputs) => {\n+      hir::ExprKind::InlineAsm(ref ia, ref outputs, ref inputs) => {\n         for input in inputs {\n           this.visit_expr(input);\n         }\n@@ -1424,16 +1424,16 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n       }\n \n       // no correctness conditions related to liveness\n-      hir::ExprCall(..) | hir::ExprMethodCall(..) | hir::ExprIf(..) |\n-      hir::ExprMatch(..) | hir::ExprWhile(..) | hir::ExprLoop(..) |\n-      hir::ExprIndex(..) | hir::ExprField(..) |\n-      hir::ExprArray(..) | hir::ExprTup(..) | hir::ExprBinary(..) |\n-      hir::ExprCast(..) | hir::ExprUnary(..) | hir::ExprRet(..) |\n-      hir::ExprBreak(..) | hir::ExprContinue(..) | hir::ExprLit(_) |\n-      hir::ExprBlock(..) | hir::ExprAddrOf(..) |\n-      hir::ExprStruct(..) | hir::ExprRepeat(..) |\n-      hir::ExprClosure(..) | hir::ExprPath(_) | hir::ExprYield(..) |\n-      hir::ExprBox(..) | hir::ExprType(..) => {\n+      hir::ExprKind::Call(..) | hir::ExprKind::MethodCall(..) | hir::ExprKind::If(..) |\n+      hir::ExprKind::Match(..) | hir::ExprKind::While(..) | hir::ExprKind::Loop(..) |\n+      hir::ExprKind::Index(..) | hir::ExprKind::Field(..) |\n+      hir::ExprKind::Array(..) | hir::ExprKind::Tup(..) | hir::ExprKind::Binary(..) |\n+      hir::ExprKind::Cast(..) | hir::ExprKind::Unary(..) | hir::ExprKind::Ret(..) |\n+      hir::ExprKind::Break(..) | hir::ExprKind::Continue(..) | hir::ExprKind::Lit(_) |\n+      hir::ExprKind::Block(..) | hir::ExprKind::AddrOf(..) |\n+      hir::ExprKind::Struct(..) | hir::ExprKind::Repeat(..) |\n+      hir::ExprKind::Closure(..) | hir::ExprKind::Path(_) | hir::ExprKind::Yield(..) |\n+      hir::ExprKind::Box(..) | hir::ExprKind::Type(..) => {\n         intravisit::walk_expr(this, expr);\n       }\n     }\n@@ -1442,7 +1442,7 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn check_place(&mut self, expr: &'tcx Expr) {\n         match expr.node {\n-            hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+            hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n                 if let Def::Local(nid) = path.def {\n                     // Assignment to an immutable variable or argument: only legal\n                     // if there is no later assignment. If this local is actually"}, {"sha": "0602dc55c43d608629025a5121ad29be61a9c362", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -639,7 +639,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         let expr_ty = self.expr_ty(expr)?;\n         match expr.node {\n-          hir::ExprUnary(hir::UnDeref, ref e_base) => {\n+          hir::ExprKind::Unary(hir::UnDeref, ref e_base) => {\n             if self.tables.is_method_call(expr) {\n                 self.cat_overloaded_place(expr, e_base, NoteNone)\n             } else {\n@@ -648,7 +648,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n           }\n \n-          hir::ExprField(ref base, f_ident) => {\n+          hir::ExprKind::Field(ref base, f_ident) => {\n             let base_cmt = Rc::new(self.cat_expr(&base)?);\n             debug!(\"cat_expr(cat_field): id={} expr={:?} base={:?}\",\n                    expr.id,\n@@ -658,7 +658,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             Ok(self.cat_field(expr, base_cmt, f_index, f_ident, expr_ty))\n           }\n \n-          hir::ExprIndex(ref base, _) => {\n+          hir::ExprKind::Index(ref base, _) => {\n             if self.tables.is_method_call(expr) {\n                 // If this is an index implemented by a method call, then it\n                 // will include an implicit deref of the result.\n@@ -672,26 +672,26 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n           }\n \n-          hir::ExprPath(ref qpath) => {\n+          hir::ExprKind::Path(ref qpath) => {\n               let def = self.tables.qpath_def(qpath, expr.hir_id);\n               self.cat_def(expr.hir_id, expr.span, expr_ty, def)\n           }\n \n-          hir::ExprType(ref e, _) => {\n+          hir::ExprKind::Type(ref e, _) => {\n             self.cat_expr(&e)\n           }\n \n-          hir::ExprAddrOf(..) | hir::ExprCall(..) |\n-          hir::ExprAssign(..) | hir::ExprAssignOp(..) |\n-          hir::ExprClosure(..) | hir::ExprRet(..) |\n-          hir::ExprUnary(..) | hir::ExprYield(..) |\n-          hir::ExprMethodCall(..) | hir::ExprCast(..) |\n-          hir::ExprArray(..) | hir::ExprTup(..) | hir::ExprIf(..) |\n-          hir::ExprBinary(..) | hir::ExprWhile(..) |\n-          hir::ExprBlock(..) | hir::ExprLoop(..) | hir::ExprMatch(..) |\n-          hir::ExprLit(..) | hir::ExprBreak(..) |\n-          hir::ExprContinue(..) | hir::ExprStruct(..) | hir::ExprRepeat(..) |\n-          hir::ExprInlineAsm(..) | hir::ExprBox(..) => {\n+          hir::ExprKind::AddrOf(..) | hir::ExprKind::Call(..) |\n+          hir::ExprKind::Assign(..) | hir::ExprKind::AssignOp(..) |\n+          hir::ExprKind::Closure(..) | hir::ExprKind::Ret(..) |\n+          hir::ExprKind::Unary(..) | hir::ExprKind::Yield(..) |\n+          hir::ExprKind::MethodCall(..) | hir::ExprKind::Cast(..) |\n+          hir::ExprKind::Array(..) | hir::ExprKind::Tup(..) | hir::ExprKind::If(..) |\n+          hir::ExprKind::Binary(..) | hir::ExprKind::While(..) |\n+          hir::ExprKind::Block(..) | hir::ExprKind::Loop(..) | hir::ExprKind::Match(..) |\n+          hir::ExprKind::Lit(..) | hir::ExprKind::Break(..) |\n+          hir::ExprKind::Continue(..) | hir::ExprKind::Struct(..) | hir::ExprKind::Repeat(..) |\n+          hir::ExprKind::InlineAsm(..) | hir::ExprKind::Box(..) => {\n             Ok(self.cat_rvalue_node(expr.hir_id, expr.span, expr_ty))\n           }\n         }"}, {"sha": "5c1a896e9467c69f3990ea750fbedafc5958012d", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -116,10 +116,10 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         let def = match expr.node {\n-            hir::ExprPath(ref qpath) => {\n+            hir::ExprKind::Path(ref qpath) => {\n                 Some(self.tables.qpath_def(qpath, expr.hir_id))\n             }\n-            hir::ExprMethodCall(..) => {\n+            hir::ExprKind::MethodCall(..) => {\n                 self.tables.type_dependent_defs().get(expr.hir_id).cloned()\n             }\n             _ => None\n@@ -315,7 +315,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ImplItemKind::Type(_) => {}\n                 }\n             }\n-            hir_map::NodeExpr(&hir::Expr { node: hir::ExprClosure(.., body, _, _), .. }) => {\n+            hir_map::NodeExpr(&hir::Expr { node: hir::ExprKind::Closure(.., body, _, _), .. }) => {\n                 self.visit_nested_body(body);\n             }\n             // Nothing to recurse on for these"}, {"sha": "ebdc9c922b1dff3b300289e393bbf88e35276032", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -950,32 +950,32 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n                 terminating(r.hir_id.local_id);\n             }\n \n-            hir::ExprIf(ref expr, ref then, Some(ref otherwise)) => {\n+            hir::ExprKind::If(ref expr, ref then, Some(ref otherwise)) => {\n                 terminating(expr.hir_id.local_id);\n                 terminating(then.hir_id.local_id);\n                 terminating(otherwise.hir_id.local_id);\n             }\n \n-            hir::ExprIf(ref expr, ref then, None) => {\n+            hir::ExprKind::If(ref expr, ref then, None) => {\n                 terminating(expr.hir_id.local_id);\n                 terminating(then.hir_id.local_id);\n             }\n \n-            hir::ExprLoop(ref body, _, _) => {\n+            hir::ExprKind::Loop(ref body, _, _) => {\n                 terminating(body.hir_id.local_id);\n             }\n \n-            hir::ExprWhile(ref expr, ref body, _) => {\n+            hir::ExprKind::While(ref expr, ref body, _) => {\n                 terminating(expr.hir_id.local_id);\n                 terminating(body.hir_id.local_id);\n             }\n \n-            hir::ExprMatch(..) => {\n+            hir::ExprKind::Match(..) => {\n                 visitor.cx.var_parent = visitor.cx.parent;\n             }\n \n-            hir::ExprAssignOp(..) | hir::ExprIndex(..) |\n-            hir::ExprUnary(..) | hir::ExprCall(..) | hir::ExprMethodCall(..) => {\n+            hir::ExprKind::AssignOp(..) | hir::ExprKind::Index(..) |\n+            hir::ExprKind::Unary(..) | hir::ExprKind::Call(..) | hir::ExprKind::MethodCall(..) => {\n                 // FIXME(https://github.com/rust-lang/rfcs/issues/811) Nested method calls\n                 //\n                 // The lifetimes for a call or method call look as follows:\n@@ -1003,7 +1003,7 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n     match expr.node {\n         // Manually recurse over closures, because they are the only\n         // case of nested bodies that share the parent environment.\n-        hir::ExprClosure(.., body, _, _) => {\n+        hir::ExprKind::Closure(.., body, _, _) => {\n             let body = visitor.tcx.hir.body(body);\n             visitor.visit_body(body);\n         }\n@@ -1015,7 +1015,7 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n \n     debug!(\"resolve_expr post-increment {}, expr = {:?}\", visitor.expr_and_pat_count, expr);\n \n-    if let hir::ExprYield(..) = expr.node {\n+    if let hir::ExprKind::Yield(..) = expr.node {\n         // Mark this expr's scope and all parent scopes as containing `yield`.\n         let mut scope = Scope::Node(expr.hir_id.local_id);\n         loop {\n@@ -1193,27 +1193,27 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n         blk_id: Option<Scope>)\n     {\n         match expr.node {\n-            hir::ExprAddrOf(_, ref subexpr) => {\n+            hir::ExprKind::AddrOf(_, ref subexpr) => {\n                 record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n                 record_rvalue_scope(visitor, &subexpr, blk_id);\n             }\n-            hir::ExprStruct(_, ref fields, _) => {\n+            hir::ExprKind::Struct(_, ref fields, _) => {\n                 for field in fields {\n                     record_rvalue_scope_if_borrow_expr(\n                         visitor, &field.expr, blk_id);\n                 }\n             }\n-            hir::ExprArray(ref subexprs) |\n-            hir::ExprTup(ref subexprs) => {\n+            hir::ExprKind::Array(ref subexprs) |\n+            hir::ExprKind::Tup(ref subexprs) => {\n                 for subexpr in subexprs {\n                     record_rvalue_scope_if_borrow_expr(\n                         visitor, &subexpr, blk_id);\n                 }\n             }\n-            hir::ExprCast(ref subexpr, _) => {\n+            hir::ExprKind::Cast(ref subexpr, _) => {\n                 record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id)\n             }\n-            hir::ExprBlock(ref block, _) => {\n+            hir::ExprKind::Block(ref block, _) => {\n                 if let Some(ref subexpr) = block.expr {\n                     record_rvalue_scope_if_borrow_expr(\n                         visitor, &subexpr, blk_id);\n@@ -1251,10 +1251,10 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n             visitor.scope_tree.record_rvalue_scope(expr.hir_id.local_id, blk_scope);\n \n             match expr.node {\n-                hir::ExprAddrOf(_, ref subexpr) |\n-                hir::ExprUnary(hir::UnDeref, ref subexpr) |\n-                hir::ExprField(ref subexpr, _) |\n-                hir::ExprIndex(ref subexpr, _) => {\n+                hir::ExprKind::AddrOf(_, ref subexpr) |\n+                hir::ExprKind::Unary(hir::UnDeref, ref subexpr) |\n+                hir::ExprKind::Field(ref subexpr, _) |\n+                hir::ExprKind::Index(ref subexpr, _) => {\n                     expr = &subexpr;\n                 }\n                 _ => {"}, {"sha": "9fcb4420da154d270a76e2a8c253985d4b4d6726", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -1157,8 +1157,8 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n \n     fn expression_label(ex: &hir::Expr) -> Option<ast::Ident> {\n         match ex.node {\n-            hir::ExprWhile(.., Some(label)) |\n-            hir::ExprLoop(_, Some(label), _) => Some(label.ident),\n+            hir::ExprKind::While(.., Some(label)) |\n+            hir::ExprKind::Loop(_, Some(label), _) => Some(label.ident),\n             _ => None,\n         }\n     }"}, {"sha": "9f154a389f184e2dc739b0a17f6abe5eaf0efa2e", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -858,7 +858,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             let parent_node = self.tcx.hir.get_parent_node(node_id);\n             if let Some(hir::map::NodeLocal(ref local)) = self.tcx.hir.find(parent_node) {\n                 if let Some(ref expr) = local.init {\n-                    if let hir::ExprIndex(_, _) = expr.node {\n+                    if let hir::ExprKind::Index(_, _) = expr.node {\n                         if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n                             err.span_suggestion_with_applicability(\n                                 expr.span,\n@@ -927,7 +927,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn get_fn_like_arguments(&self, node: hir::map::Node) -> (Span, Vec<ArgKind>) {\n         match node {\n             hir::map::NodeExpr(&hir::Expr {\n-                node: hir::ExprClosure(_, ref _decl, id, span, _),\n+                node: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n                 ..\n             }) => {\n                 (self.tcx.sess.codemap().def_span(span), self.tcx.hir.body(id).arguments.iter()"}, {"sha": "c7bb90bfcb09065b36e3869ce3cec94175fe93fc", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -627,7 +627,7 @@ impl<'tcx> TypeckTables<'tcx> {\n     pub fn is_method_call(&self, expr: &hir::Expr) -> bool {\n         // Only paths and method calls/overloaded operators have\n         // entries in type_dependent_defs, ignore the former here.\n-        if let hir::ExprPath(_) = expr.node {\n+        if let hir::ExprKind::Path(_) = expr.node {\n             return false;\n         }\n "}, {"sha": "002e8697588fcdb113b5ea66ad85ff9dd81c0071", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -203,7 +203,7 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     let node_id = bccx.tcx.hir.as_local_node_id(def_id).unwrap();\n     let movable_generator = !match bccx.tcx.hir.get(node_id) {\n         hir::map::Node::NodeExpr(&hir::Expr {\n-            node: hir::ExprClosure(.., Some(hir::GeneratorMovability::Static)),\n+            node: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n             ..\n         }) => true,\n         _ => false,"}, {"sha": "7ce6863a7c986402d1abcd4eede1ef7bc253e931", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -63,7 +63,7 @@ fn get_pattern_source<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &Pat) -> Patte\n         NodeExpr(ref e) => {\n             // the enclosing expression must be a `match` or something else\n             assert!(match e.node {\n-                        ExprMatch(..) => true,\n+                        ExprKind::Match(..) => true,\n                         _ => return PatternSource::Other,\n                     });\n             PatternSource::MatchExpr(e)"}, {"sha": "19593b20c5aa217baf6bd46fe7920f198c63d52a", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -409,7 +409,7 @@ fn closure_to_block(closure_id: LocalDefId,\n     let closure_id = tcx.hir.local_def_id_to_node_id(closure_id);\n     match tcx.hir.get(closure_id) {\n         hir_map::NodeExpr(expr) => match expr.node {\n-            hir::ExprClosure(.., body_id, _, _) => {\n+            hir::ExprKind::Closure(.., body_id, _, _) => {\n                 body_id.node_id\n             }\n             _ => {\n@@ -722,7 +722,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n             move_data::Captured =>\n                 (match self.tcx.hir.expect_expr(node_id).node {\n-                    hir::ExprClosure(.., fn_decl_span, _) => fn_decl_span,\n+                    hir::ExprKind::Closure(.., fn_decl_span, _) => fn_decl_span,\n                     ref r => bug!(\"Captured({:?}) maps to non-closure: {:?}\",\n                                   the_move.id, r),\n                 }, \" (into closure)\"),"}, {"sha": "e22f980318924aa372095be0b3c15655f712c829", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -75,8 +75,8 @@ impl LintPass for WhileTrue {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for WhileTrue {\n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n-        if let hir::ExprWhile(ref cond, ..) = e.node {\n-            if let hir::ExprLit(ref lit) = cond.node {\n+        if let hir::ExprKind::While(ref cond, ..) = e.node {\n+            if let hir::ExprKind::Lit(ref lit) = cond.node {\n                 if let ast::LitKind::Bool(true) = lit.node {\n                     if lit.span.ctxt() == SyntaxContext::empty() {\n                         let msg = \"denote infinite loops with `loop { ... }`\";\n@@ -226,7 +226,7 @@ impl UnsafeCode {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnsafeCode {\n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n-        if let hir::ExprBlock(ref blk, _) = e.node {\n+        if let hir::ExprKind::Block(ref blk, _) = e.node {\n             // Don't warn about generated blocks, that'll just pollute the output.\n             if blk.rules == hir::UnsafeBlock(hir::UserProvided) {\n                 self.report_unsafe(cx, blk.span, \"usage of an `unsafe` block\");\n@@ -960,8 +960,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n \n         fn expr_refers_to_this_fn(cx: &LateContext, fn_id: ast::NodeId, id: ast::NodeId) -> bool {\n             match cx.tcx.hir.get(id) {\n-                hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n-                    let def = if let hir::ExprPath(ref qpath) = callee.node {\n+                hir_map::NodeExpr(&hir::Expr { node: hir::ExprKind::Call(ref callee, _), .. }) => {\n+                    let def = if let hir::ExprKind::Path(ref qpath) = callee.node {\n                         cx.tables.qpath_def(qpath, callee.hir_id)\n                     } else {\n                         return false;\n@@ -1018,8 +1018,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n \n             // Check for calls to methods via explicit paths (e.g. `T::method()`).\n             match expr.node {\n-                hir::ExprCall(ref callee, _) => {\n-                    let def = if let hir::ExprPath(ref qpath) = callee.node {\n+                hir::ExprKind::Call(ref callee, _) => {\n+                    let def = if let hir::ExprKind::Path(ref qpath) = callee.node {\n                         cx.tables.qpath_def(qpath, callee.hir_id)\n                     } else {\n                         return false;\n@@ -1300,7 +1300,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n             (cx: &LateContext<'a, 'tcx>,\n              expr: &hir::Expr)\n              -> Option<(&'tcx ty::TypeVariants<'tcx>, &'tcx ty::TypeVariants<'tcx>)> {\n-            let def = if let hir::ExprPath(ref qpath) = expr.node {\n+            let def = if let hir::ExprKind::Path(ref qpath) = expr.node {\n                 cx.tables.qpath_def(qpath, expr.hir_id)\n             } else {\n                 return None;"}, {"sha": "1b19853358234039564b2c3cf5643b2fc6f2d45b", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -68,20 +68,20 @@ impl LintPass for TypeLimits {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr) {\n         match e.node {\n-            hir::ExprUnary(hir::UnNeg, ref expr) => {\n+            hir::ExprKind::Unary(hir::UnNeg, ref expr) => {\n                 // propagate negation, if the negation itself isn't negated\n                 if self.negated_expr_id != e.id {\n                     self.negated_expr_id = expr.id;\n                 }\n             }\n-            hir::ExprBinary(binop, ref l, ref r) => {\n+            hir::ExprKind::Binary(binop, ref l, ref r) => {\n                 if is_comparison(binop) && !check_limits(cx, binop, &l, &r) {\n                     cx.span_lint(UNUSED_COMPARISONS,\n                                  e.span,\n                                  \"comparison is useless due to type limits\");\n                 }\n             }\n-            hir::ExprLit(ref lit) => {\n+            hir::ExprKind::Lit(ref lit) => {\n                 match cx.tables.node_id_to_type(e.hir_id).sty {\n                     ty::TyInt(t) => {\n                         match lit.node {\n@@ -137,7 +137,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                         if lit_val < min || lit_val > max {\n                             let parent_id = cx.tcx.hir.get_parent_node(e.id);\n                             if let hir_map::NodeExpr(parent_expr) = cx.tcx.hir.get(parent_id) {\n-                                if let hir::ExprCast(..) = parent_expr.node {\n+                                if let hir::ExprKind::Cast(..) = parent_expr.node {\n                                     if let ty::TyChar = cx.tables.expr_ty(parent_expr).sty {\n                                         let mut err = cx.struct_span_lint(\n                                                              OVERFLOWING_LITERALS,\n@@ -244,8 +244,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                         r: &hir::Expr)\n                         -> bool {\n             let (lit, expr, swap) = match (&l.node, &r.node) {\n-                (&hir::ExprLit(_), _) => (l, r, true),\n-                (_, &hir::ExprLit(_)) => (r, l, false),\n+                (&hir::ExprKind::Lit(_), _) => (l, r, true),\n+                (_, &hir::ExprKind::Lit(_)) => (r, l, false),\n                 _ => return true,\n             };\n             // Normalize the binop so that the literal is always on the RHS in\n@@ -255,7 +255,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 ty::TyInt(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i128 = match lit.node {\n-                        hir::ExprLit(ref li) => {\n+                        hir::ExprKind::Lit(ref li) => {\n                             match li.node {\n                                 ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n                                 ast::LitKind::Int(v, ast::LitIntType::Unsuffixed) => v as i128,\n@@ -269,7 +269,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 ty::TyUint(uint_ty) => {\n                     let (min, max) :(u128, u128) = uint_ty_range(uint_ty);\n                     let lit_val: u128 = match lit.node {\n-                        hir::ExprLit(ref li) => {\n+                        hir::ExprKind::Lit(ref li) => {\n                             match li.node {\n                                 ast::LitKind::Int(v, _) => v,\n                                 _ => return true"}, {"sha": "958f97d87cb89d8d87aa09743ca546cbd95482af", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -53,7 +53,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n             _ => return,\n         };\n \n-        if let hir::ExprRet(..) = expr.node {\n+        if let hir::ExprKind::Ret(..) = expr.node {\n             return;\n         }\n \n@@ -74,9 +74,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n         let mut fn_warned = false;\n         let mut op_warned = false;\n         let maybe_def = match expr.node {\n-            hir::ExprCall(ref callee, _) => {\n+            hir::ExprKind::Call(ref callee, _) => {\n                 match callee.node {\n-                    hir::ExprPath(ref qpath) => {\n+                    hir::ExprKind::Path(ref qpath) => {\n                         let def = cx.tables.qpath_def(qpath, callee.hir_id);\n                         if let Def::Fn(_) = def {\n                             Some(def)\n@@ -87,7 +87,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n                     _ => None\n                 }\n             },\n-            hir::ExprMethodCall(..) => {\n+            hir::ExprKind::MethodCall(..) => {\n                 cx.tables.type_dependent_defs().get(expr.hir_id).cloned()\n             },\n             _ => None\n@@ -100,7 +100,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n             // Hardcoding operators here seemed more expedient than the\n             // refactoring that would be needed to look up the `#[must_use]`\n             // attribute which does exist on the comparison trait methods\n-            hir::ExprBinary(bin_op, ..)  => {\n+            hir::ExprKind::Binary(bin_op, ..)  => {\n                 match bin_op.node {\n                     hir::BinOpKind::Eq | hir::BinOpKind::Lt | hir::BinOpKind::Le | hir::BinOpKind::Ne | hir::BinOpKind::Ge | hir::BinOpKind::Gt => {\n                         Some(\"comparison\")\n@@ -116,7 +116,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n                     },\n                 }\n             },\n-            hir::ExprUnary(..) => Some(\"unary operation\"),\n+            hir::ExprKind::Unary(..) => Some(\"unary operation\"),\n             _ => None\n         };\n \n@@ -447,7 +447,7 @@ impl LintPass for UnusedAllocation {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAllocation {\n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         match e.node {\n-            hir::ExprBox(_) => {}\n+            hir::ExprKind::Box(_) => {}\n             _ => return,\n         }\n "}, {"sha": "0237c3f08c19892c8045373b711b562e0d0b28c5", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -1688,7 +1688,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n \n     fn encode_info_for_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n-            hir::ExprClosure(..) => {\n+            hir::ExprKind::Closure(..) => {\n                 let def_id = self.tcx.hir.local_def_id(expr.id);\n                 self.record(def_id, IsolatedEncoder::encode_info_for_closure, def_id);\n             }"}, {"sha": "c481d1d325b32dbf0141ca3de3121cf11bd7846e", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -207,7 +207,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         maybe_closure_span: Span,\n         location: Location,\n     ) -> Option<(Span, Span)> {\n-        use rustc::hir::ExprClosure;\n+        use rustc::hir::ExprKind::Closure;\n         use rustc::mir::AggregateKind;\n \n         let local = match self.mir[location.block]\n@@ -231,7 +231,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     debug!(\"find_closure_span: found closure {:?}\", places);\n \n                     return if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n-                        let args_span = if let ExprClosure(_, _, _, span, _) =\n+                        let args_span = if let Closure(_, _, _, span, _) =\n                             self.tcx.hir.expect_expr(node_id).node\n                         {\n                             span"}, {"sha": "e7f00b577b39fa583503926129adcd0c36033960", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -232,7 +232,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n \n     let movable_generator = match tcx.hir.get(id) {\n         hir::map::Node::NodeExpr(&hir::Expr {\n-            node: hir::ExprClosure(.., Some(hir::GeneratorMovability::Static)),\n+            node: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n             ..\n         }) => false,\n         _ => true,"}, {"sha": "c281e1a482a2fdc3b5ec9557dec2d192c324e68e", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -200,7 +200,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n     let kind = match expr.node {\n         // Here comes the interesting stuff:\n-        hir::ExprMethodCall(.., ref args) => {\n+        hir::ExprKind::MethodCall(.., ref args) => {\n             // Rewrite a.b(c) into UFCS form like Trait::b(a, c)\n             let expr = method_callee(cx, expr, None);\n             let args = args.iter()\n@@ -213,7 +213,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprCall(ref fun, ref args) => {\n+        hir::ExprKind::Call(ref fun, ref args) => {\n             if cx.tables().is_method_call(expr) {\n                 // The callee is something implementing Fn, FnMut, or FnOnce.\n                 // Find the actual method implementation being called and\n@@ -238,8 +238,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     args: vec![fun.to_ref(), tupled_args.to_ref()],\n                 }\n             } else {\n-                let adt_data = if let hir::ExprPath(hir::QPath::Resolved(_, ref path)) = fun.node {\n-                    // Tuple-like ADTs are represented as ExprCall. We convert them here.\n+                let adt_data = if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = fun.node {\n+                    // Tuple-like ADTs are represented as ExprKind::Call. We convert them here.\n                     expr_ty.ty_adt_def().and_then(|adt_def| {\n                         match path.def {\n                             Def::VariantCtor(variant_id, CtorKind::Fn) => {\n@@ -280,7 +280,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprAddrOf(mutbl, ref expr) => {\n+        hir::ExprKind::AddrOf(mutbl, ref expr) => {\n             let region = match expr_ty.sty {\n                 ty::TyRef(r, _, _) => r,\n                 _ => span_bug!(expr.span, \"type of & not region\"),\n@@ -292,16 +292,16 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprBlock(ref blk, _) => ExprKind::Block { body: &blk },\n+        hir::ExprKind::Block(ref blk, _) => ExprKind::Block { body: &blk },\n \n-        hir::ExprAssign(ref lhs, ref rhs) => {\n+        hir::ExprKind::Assign(ref lhs, ref rhs) => {\n             ExprKind::Assign {\n                 lhs: lhs.to_ref(),\n                 rhs: rhs.to_ref(),\n             }\n         }\n \n-        hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n+        hir::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n             if cx.tables().is_method_call(expr) {\n                 overloaded_operator(cx, expr, vec![lhs.to_ref(), rhs.to_ref()])\n             } else {\n@@ -313,11 +313,11 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprLit(ref lit) => ExprKind::Literal {\n+        hir::ExprKind::Lit(ref lit) => ExprKind::Literal {\n             literal: cx.const_eval_literal(&lit.node, expr_ty, lit.span, false),\n         },\n \n-        hir::ExprBinary(op, ref lhs, ref rhs) => {\n+        hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n             if cx.tables().is_method_call(expr) {\n                 overloaded_operator(cx, expr, vec![lhs.to_ref(), rhs.to_ref()])\n             } else {\n@@ -367,7 +367,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprIndex(ref lhs, ref index) => {\n+        hir::ExprKind::Index(ref lhs, ref index) => {\n             if cx.tables().is_method_call(expr) {\n                 overloaded_place(cx, expr, expr_ty, None, vec![lhs.to_ref(), index.to_ref()])\n             } else {\n@@ -378,15 +378,15 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprUnary(hir::UnOp::UnDeref, ref arg) => {\n+        hir::ExprKind::Unary(hir::UnOp::UnDeref, ref arg) => {\n             if cx.tables().is_method_call(expr) {\n                 overloaded_place(cx, expr, expr_ty, None, vec![arg.to_ref()])\n             } else {\n                 ExprKind::Deref { arg: arg.to_ref() }\n             }\n         }\n \n-        hir::ExprUnary(hir::UnOp::UnNot, ref arg) => {\n+        hir::ExprKind::Unary(hir::UnOp::UnNot, ref arg) => {\n             if cx.tables().is_method_call(expr) {\n                 overloaded_operator(cx, expr, vec![arg.to_ref()])\n             } else {\n@@ -397,11 +397,11 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n+        hir::ExprKind::Unary(hir::UnOp::UnNeg, ref arg) => {\n             if cx.tables().is_method_call(expr) {\n                 overloaded_operator(cx, expr, vec![arg.to_ref()])\n             } else {\n-                if let hir::ExprLit(ref lit) = arg.node {\n+                if let hir::ExprKind::Lit(ref lit) = arg.node {\n                     ExprKind::Literal {\n                         literal: cx.const_eval_literal(&lit.node, expr_ty, lit.span, true),\n                     }\n@@ -414,7 +414,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprStruct(ref qpath, ref fields, ref base) => {\n+        hir::ExprKind::Struct(ref qpath, ref fields, ref base) => {\n             match expr_ty.sty {\n                 ty::TyAdt(adt, substs) => {\n                     match adt.adt_kind() {\n@@ -467,7 +467,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprClosure(..) => {\n+        hir::ExprKind::Closure(..) => {\n             let closure_ty = cx.tables().expr_ty(expr);\n             let (def_id, substs, movability) = match closure_ty.sty {\n                 ty::TyClosure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs), None),\n@@ -492,12 +492,12 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprPath(ref qpath) => {\n+        hir::ExprKind::Path(ref qpath) => {\n             let def = cx.tables().qpath_def(qpath, expr.hir_id);\n             convert_path_expr(cx, expr, def)\n         }\n \n-        hir::ExprInlineAsm(ref asm, ref outputs, ref inputs) => {\n+        hir::ExprKind::InlineAsm(ref asm, ref outputs, ref inputs) => {\n             ExprKind::InlineAsm {\n                 asm,\n                 outputs: outputs.to_ref(),\n@@ -506,7 +506,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         // Now comes the rote stuff:\n-        hir::ExprRepeat(ref v, ref count) => {\n+        hir::ExprKind::Repeat(ref v, ref count) => {\n             let def_id = cx.tcx.hir.local_def_id(count.id);\n             let substs = Substs::identity_for_item(cx.tcx.global_tcx(), def_id);\n             let instance = ty::Instance::resolve(\n@@ -533,8 +533,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 count,\n             }\n         }\n-        hir::ExprRet(ref v) => ExprKind::Return { value: v.to_ref() },\n-        hir::ExprBreak(dest, ref value) => {\n+        hir::ExprKind::Ret(ref v) => ExprKind::Return { value: v.to_ref() },\n+        hir::ExprKind::Break(dest, ref value) => {\n             match dest.target_id {\n                 Ok(target_id) => ExprKind::Break {\n                     label: region::Scope::Node(cx.tcx.hir.node_to_hir_id(target_id).local_id),\n@@ -543,46 +543,46 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 Err(err) => bug!(\"invalid loop id for break: {}\", err)\n             }\n         }\n-        hir::ExprContinue(dest) => {\n+        hir::ExprKind::Continue(dest) => {\n             match dest.target_id {\n                 Ok(loop_id) => ExprKind::Continue {\n                     label: region::Scope::Node(cx.tcx.hir.node_to_hir_id(loop_id).local_id),\n                 },\n                 Err(err) => bug!(\"invalid loop id for continue: {}\", err)\n             }\n         }\n-        hir::ExprMatch(ref discr, ref arms, _) => {\n+        hir::ExprKind::Match(ref discr, ref arms, _) => {\n             ExprKind::Match {\n                 discriminant: discr.to_ref(),\n                 arms: arms.iter().map(|a| convert_arm(cx, a)).collect(),\n             }\n         }\n-        hir::ExprIf(ref cond, ref then, ref otherwise) => {\n+        hir::ExprKind::If(ref cond, ref then, ref otherwise) => {\n             ExprKind::If {\n                 condition: cond.to_ref(),\n                 then: then.to_ref(),\n                 otherwise: otherwise.to_ref(),\n             }\n         }\n-        hir::ExprWhile(ref cond, ref body, _) => {\n+        hir::ExprKind::While(ref cond, ref body, _) => {\n             ExprKind::Loop {\n                 condition: Some(cond.to_ref()),\n                 body: block::to_expr_ref(cx, body),\n             }\n         }\n-        hir::ExprLoop(ref body, _, _) => {\n+        hir::ExprKind::Loop(ref body, _, _) => {\n             ExprKind::Loop {\n                 condition: None,\n                 body: block::to_expr_ref(cx, body),\n             }\n         }\n-        hir::ExprField(ref source, ..) => {\n+        hir::ExprKind::Field(ref source, ..) => {\n             ExprKind::Field {\n                 lhs: source.to_ref(),\n                 name: Field::new(cx.tcx.field_index(expr.id, cx.tables)),\n             }\n         }\n-        hir::ExprCast(ref source, _) => {\n+        hir::ExprKind::Cast(ref source, _) => {\n             // Check to see if this cast is a \"coercion cast\", where the cast is actually done\n             // using a coercion (or is a no-op).\n             if let Some(&TyCastKind::CoercionCast) = cx.tables()\n@@ -602,7 +602,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 // }\n                 // The correct solution would be to add symbolic computations to miri,\n                 // so we wouldn't have to compute and store the actual value\n-                let var = if let hir::ExprPath(ref qpath) = source.node {\n+                let var = if let hir::ExprKind::Path(ref qpath) = source.node {\n                     let def = cx.tables().qpath_def(qpath, source.hir_id);\n                     cx\n                         .tables()\n@@ -666,16 +666,16 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 ExprKind::Cast { source }\n             }\n         }\n-        hir::ExprType(ref source, _) => return source.make_mirror(cx),\n-        hir::ExprBox(ref value) => {\n+        hir::ExprKind::Type(ref source, _) => return source.make_mirror(cx),\n+        hir::ExprKind::Box(ref value) => {\n             ExprKind::Box {\n                 value: value.to_ref(),\n             }\n         }\n-        hir::ExprArray(ref fields) => ExprKind::Array { fields: fields.to_ref() },\n-        hir::ExprTup(ref fields) => ExprKind::Tuple { fields: fields.to_ref() },\n+        hir::ExprKind::Array(ref fields) => ExprKind::Array { fields: fields.to_ref() },\n+        hir::ExprKind::Tup(ref fields) => ExprKind::Tuple { fields: fields.to_ref() },\n \n-        hir::ExprYield(ref v) => ExprKind::Yield { value: v.to_ref() },\n+        hir::ExprKind::Yield(ref v) => ExprKind::Yield { value: v.to_ref() },\n     };\n \n     Expr {"}, {"sha": "35f9dcee99f82b684c1852f4e01065b8518e434d", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -98,7 +98,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {\n         intravisit::walk_expr(self, ex);\n \n         match ex.node {\n-            hir::ExprMatch(ref scrut, ref arms, source) => {\n+            hir::ExprKind::Match(ref scrut, ref arms, source) => {\n                 self.check_match(scrut, arms, source);\n             }\n             _ => {}"}, {"sha": "53511c1c127dd3a608813cf38a92c0f4cd58ed92", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -733,7 +733,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     /// afterwards.\n     fn lower_lit(&mut self, expr: &'tcx hir::Expr) -> PatternKind<'tcx> {\n         match expr.node {\n-            hir::ExprLit(ref lit) => {\n+            hir::ExprKind::Lit(ref lit) => {\n                 let ty = self.tables.expr_ty(expr);\n                 match lit_to_const(&lit.node, self.tcx, ty, false) {\n                     Ok(val) => {\n@@ -751,11 +751,11 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     },\n                 }\n             },\n-            hir::ExprPath(ref qpath) => *self.lower_path(qpath, expr.hir_id, expr.span).kind,\n-            hir::ExprUnary(hir::UnNeg, ref expr) => {\n+            hir::ExprKind::Path(ref qpath) => *self.lower_path(qpath, expr.hir_id, expr.span).kind,\n+            hir::ExprKind::Unary(hir::UnNeg, ref expr) => {\n                 let ty = self.tables.expr_ty(expr);\n                 let lit = match expr.node {\n-                    hir::ExprLit(ref lit) => lit,\n+                    hir::ExprKind::Lit(ref lit) => lit,\n                     _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n                 };\n                 match lit_to_const(&lit.node, self.tcx, ty, true) {"}, {"sha": "9c341b38e34f82b08d885e8614feb742662332a7", "filename": "src/librustc_mir/transform/add_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -141,7 +141,7 @@ fn fn_contains_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource) ->\n             }\n             // Check if this is an unsafe block, or an item\n             match node {\n-                Node::NodeExpr(&hir::Expr { node: hir::ExprBlock(ref block, _), ..}) => {\n+                Node::NodeExpr(&hir::Expr { node: hir::ExprKind::Block(ref block, _), ..}) => {\n                     if block_is_unsafe(&*block) {\n                         // Found an unsafe block, we can bail out here.\n                         return true;"}, {"sha": "8ef20126e035fdb48dc88d3584f0e18598d13600", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -78,23 +78,23 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n \n     fn visit_expr(&mut self, e: &'hir hir::Expr) {\n         match e.node {\n-            hir::ExprWhile(ref e, ref b, _) => {\n+            hir::ExprKind::While(ref e, ref b, _) => {\n                 self.with_context(Loop(LoopKind::WhileLoop), |v| {\n                     v.visit_expr(&e);\n                     v.visit_block(&b);\n                 });\n             }\n-            hir::ExprLoop(ref b, _, source) => {\n+            hir::ExprKind::Loop(ref b, _, source) => {\n                 self.with_context(Loop(LoopKind::Loop(source)), |v| v.visit_block(&b));\n             }\n-            hir::ExprClosure(_, ref function_decl, b, _, _) => {\n+            hir::ExprKind::Closure(_, ref function_decl, b, _, _) => {\n                 self.visit_fn_decl(&function_decl);\n                 self.with_context(Closure, |v| v.visit_nested_body(b));\n             }\n-            hir::ExprBlock(ref b, Some(_label)) => {\n+            hir::ExprKind::Block(ref b, Some(_label)) => {\n                 self.with_context(LabeledBlock, |v| v.visit_block(&b));\n             }\n-            hir::ExprBreak(label, ref opt_expr) => {\n+            hir::ExprKind::Break(label, ref opt_expr) => {\n                 opt_expr.as_ref().map(|e| self.visit_expr(e));\n \n                 if self.require_label_in_labeled_block(e.span, &label, \"break\") {\n@@ -125,8 +125,8 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                         None\n                     } else {\n                         Some(match self.hir_map.expect_expr(loop_id).node {\n-                            hir::ExprWhile(..) => LoopKind::WhileLoop,\n-                            hir::ExprLoop(_, _, source) => LoopKind::Loop(source),\n+                            hir::ExprKind::While(..) => LoopKind::WhileLoop,\n+                            hir::ExprKind::Loop(_, _, source) => LoopKind::Loop(source),\n                             ref r => span_bug!(e.span,\n                                                \"break label resolved to a non-loop: {:?}\", r),\n                         })\n@@ -153,7 +153,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n \n                 self.require_break_cx(\"break\", e.span);\n             }\n-            hir::ExprContinue(label) => {\n+            hir::ExprKind::Continue(label) => {\n                 self.require_label_in_labeled_block(e.span, &label, \"continue\");\n \n                 match label.target_id {"}, {"sha": "d223dc2a353356799375a9aa818905415b1c0879", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -334,11 +334,11 @@ fn check_expr_kind<'a, 'tcx>(\n     };\n \n     let node_result = match e.node {\n-        hir::ExprBox(ref expr) => {\n+        hir::ExprKind::Box(ref expr) => {\n             let _ = v.check_expr(&expr);\n             NotPromotable\n         }\n-        hir::ExprUnary(op, ref expr) => {\n+        hir::ExprKind::Unary(op, ref expr) => {\n             let expr_promotability = v.check_expr(expr);\n             if v.tables.is_method_call(e) {\n                 return NotPromotable;\n@@ -348,7 +348,7 @@ fn check_expr_kind<'a, 'tcx>(\n             }\n             expr_promotability\n         }\n-        hir::ExprBinary(op, ref lhs, ref rhs) => {\n+        hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n             let lefty = v.check_expr(lhs);\n             let righty = v.check_expr(rhs);\n             if v.tables.is_method_call(e) {\n@@ -365,7 +365,7 @@ fn check_expr_kind<'a, 'tcx>(\n                 _ => lefty & righty\n             }\n         }\n-        hir::ExprCast(ref from, _) => {\n+        hir::ExprKind::Cast(ref from, _) => {\n             let expr_promotability = v.check_expr(from);\n             debug!(\"Checking const cast(id={})\", from.id);\n             match v.tables.cast_kinds().get(from.hir_id) {\n@@ -379,7 +379,7 @@ fn check_expr_kind<'a, 'tcx>(\n                 _ => expr_promotability\n             }\n         }\n-        hir::ExprPath(ref qpath) => {\n+        hir::ExprKind::Path(ref qpath) => {\n             let def = v.tables.qpath_def(qpath, e.hir_id);\n             match def {\n                 Def::VariantCtor(..) | Def::StructCtor(..) |\n@@ -426,23 +426,23 @@ fn check_expr_kind<'a, 'tcx>(\n                 _ => NotPromotable\n             }\n         }\n-        hir::ExprCall(ref callee, ref hirvec) => {\n+        hir::ExprKind::Call(ref callee, ref hirvec) => {\n             let mut call_result = v.check_expr(callee);\n             for index in hirvec.iter() {\n                 call_result = call_result & v.check_expr(index);\n             }\n             let mut callee = &**callee;\n             loop {\n                 callee = match callee.node {\n-                    hir::ExprBlock(ref block, _) => match block.expr {\n+                    hir::ExprKind::Block(ref block, _) => match block.expr {\n                         Some(ref tail) => &tail,\n                         None => break\n                     },\n                     _ => break\n                 };\n             }\n             // The callee is an arbitrary expression, it doesn't necessarily have a definition.\n-            let def = if let hir::ExprPath(ref qpath) = callee.node {\n+            let def = if let hir::ExprKind::Path(ref qpath) = callee.node {\n                 v.tables.qpath_def(qpath, callee.hir_id)\n             } else {\n                 Def::Err\n@@ -465,7 +465,7 @@ fn check_expr_kind<'a, 'tcx>(\n             };\n             def_result & call_result\n         }\n-        hir::ExprMethodCall(ref _pathsegment, ref _span, ref hirvec) => {\n+        hir::ExprKind::MethodCall(ref _pathsegment, ref _span, ref hirvec) => {\n             let mut method_call_result = Promotable;\n             for index in hirvec.iter() {\n                 method_call_result = method_call_result & v.check_expr(index);\n@@ -484,7 +484,7 @@ fn check_expr_kind<'a, 'tcx>(\n             }\n             method_call_result\n         }\n-        hir::ExprStruct(ref _qpath, ref hirvec, ref option_expr) => {\n+        hir::ExprKind::Struct(ref _qpath, ref hirvec, ref option_expr) => {\n             let mut struct_result = Promotable;\n             for index in hirvec.iter() {\n                 struct_result = struct_result & v.check_expr(&index.expr);\n@@ -502,14 +502,14 @@ fn check_expr_kind<'a, 'tcx>(\n             struct_result\n         }\n \n-        hir::ExprLit(_) => Promotable,\n+        hir::ExprKind::Lit(_) => Promotable,\n \n-        hir::ExprAddrOf(_, ref expr) |\n-        hir::ExprRepeat(ref expr, _) => {\n+        hir::ExprKind::AddrOf(_, ref expr) |\n+        hir::ExprKind::Repeat(ref expr, _) => {\n             v.check_expr(&expr)\n         }\n \n-        hir::ExprClosure(_capture_clause, ref _box_fn_decl,\n+        hir::ExprKind::Closure(_capture_clause, ref _box_fn_decl,\n                          body_id, _span, _option_generator_movability) => {\n             let nested_body_promotable = v.check_nested_body(body_id);\n             // Paths in constant contexts cannot refer to local variables,\n@@ -521,7 +521,7 @@ fn check_expr_kind<'a, 'tcx>(\n             }\n         }\n \n-        hir::ExprField(ref expr, _ident) => {\n+        hir::ExprKind::Field(ref expr, _ident) => {\n             let expr_promotability = v.check_expr(&expr);\n             if let Some(def) = v.tables.expr_ty(expr).ty_adt_def() {\n                 if def.is_union() {\n@@ -531,11 +531,11 @@ fn check_expr_kind<'a, 'tcx>(\n             expr_promotability\n         }\n \n-        hir::ExprBlock(ref box_block, ref _option_label) => {\n+        hir::ExprKind::Block(ref box_block, ref _option_label) => {\n             v.check_block(box_block)\n         }\n \n-        hir::ExprIndex(ref lhs, ref rhs) => {\n+        hir::ExprKind::Index(ref lhs, ref rhs) => {\n             let lefty = v.check_expr(lhs);\n             let righty = v.check_expr(rhs);\n             if v.tables.is_method_call(e) {\n@@ -544,19 +544,19 @@ fn check_expr_kind<'a, 'tcx>(\n             lefty & righty\n         }\n \n-        hir::ExprArray(ref hirvec) => {\n+        hir::ExprKind::Array(ref hirvec) => {\n             let mut array_result = Promotable;\n             for index in hirvec.iter() {\n                 array_result = array_result & v.check_expr(index);\n             }\n             array_result\n         }\n \n-        hir::ExprType(ref expr, ref _ty) => {\n+        hir::ExprKind::Type(ref expr, ref _ty) => {\n             v.check_expr(&expr)\n         }\n \n-        hir::ExprTup(ref hirvec) => {\n+        hir::ExprKind::Tup(ref hirvec) => {\n             let mut tup_result = Promotable;\n             for index in hirvec.iter() {\n                 tup_result = tup_result & v.check_expr(index);\n@@ -566,7 +566,7 @@ fn check_expr_kind<'a, 'tcx>(\n \n \n         // Conditional control flow (possible to implement).\n-        hir::ExprMatch(ref expr, ref hirvec_arm, ref _match_source) => {\n+        hir::ExprKind::Match(ref expr, ref hirvec_arm, ref _match_source) => {\n             // Compute the most demanding borrow from all the arms'\n             // patterns and set that on the discriminator.\n             let mut mut_borrow = false;\n@@ -590,7 +590,7 @@ fn check_expr_kind<'a, 'tcx>(\n             NotPromotable\n         }\n \n-        hir::ExprIf(ref lhs, ref rhs, ref option_expr) => {\n+        hir::ExprKind::If(ref lhs, ref rhs, ref option_expr) => {\n             let _ = v.check_expr(lhs);\n             let _ = v.check_expr(rhs);\n             match option_expr {\n@@ -601,44 +601,44 @@ fn check_expr_kind<'a, 'tcx>(\n         }\n \n         // Loops (not very meaningful in constants).\n-        hir::ExprWhile(ref expr, ref box_block, ref _option_label) => {\n+        hir::ExprKind::While(ref expr, ref box_block, ref _option_label) => {\n             let _ = v.check_expr(expr);\n             let _ = v.check_block(box_block);\n             NotPromotable\n         }\n \n-        hir::ExprLoop(ref box_block, ref _option_label, ref _loop_source) => {\n+        hir::ExprKind::Loop(ref box_block, ref _option_label, ref _loop_source) => {\n             let _ = v.check_block(box_block);\n             NotPromotable\n         }\n \n         // More control flow (also not very meaningful).\n-        hir::ExprBreak(_, ref option_expr) | hir::ExprRet(ref option_expr) => {\n+        hir::ExprKind::Break(_, ref option_expr) | hir::ExprKind::Ret(ref option_expr) => {\n             match *option_expr {\n                 Some(ref expr) => { let _ = v.check_expr(&expr); },\n                 None => {},\n             }\n             NotPromotable\n         }\n \n-        hir::ExprContinue(_) => {\n+        hir::ExprKind::Continue(_) => {\n             NotPromotable\n         }\n \n         // Generator expressions\n-        hir::ExprYield(ref expr) => {\n+        hir::ExprKind::Yield(ref expr) => {\n             let _ = v.check_expr(&expr);\n             NotPromotable\n         }\n \n         // Expressions with side-effects.\n-        hir::ExprAssignOp(_, ref lhs, ref rhs) | hir::ExprAssign(ref lhs, ref rhs) => {\n+        hir::ExprKind::AssignOp(_, ref lhs, ref rhs) | hir::ExprKind::Assign(ref lhs, ref rhs) => {\n             let _ = v.check_expr(lhs);\n             let _ = v.check_expr(rhs);\n             NotPromotable\n         }\n \n-        hir::ExprInlineAsm(ref _inline_asm, ref hirvec_lhs, ref hirvec_rhs) => {\n+        hir::ExprKind::InlineAsm(ref _inline_asm, ref hirvec_lhs, ref hirvec_rhs) => {\n             for index in hirvec_lhs.iter() {\n                 let _ = v.check_expr(index);\n             }"}, {"sha": "1d39fedc22c0b51850af44b482c2927f9dd5b6e6", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -568,7 +568,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n-            hir::ExprStruct(ref qpath, ref fields, ref base) => {\n+            hir::ExprKind::Struct(ref qpath, ref fields, ref base) => {\n                 let def = self.tables.qpath_def(qpath, expr.hir_id);\n                 let adt = self.tables.expr_ty(expr).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(def);\n@@ -778,13 +778,13 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n             return;\n         }\n         match expr.node {\n-            hir::ExprAssign(.., ref rhs) | hir::ExprMatch(ref rhs, ..) => {\n+            hir::ExprKind::Assign(.., ref rhs) | hir::ExprKind::Match(ref rhs, ..) => {\n                 // Do not report duplicate errors for `x = y` and `match x { ... }`.\n                 if self.check_expr_pat_type(rhs.hir_id, rhs.span) {\n                     return;\n                 }\n             }\n-            hir::ExprMethodCall(_, span, _) => {\n+            hir::ExprKind::MethodCall(_, span, _) => {\n                 // Method calls have to be checked specially.\n                 self.span = span;\n                 if let Some(def) = self.tables.type_dependent_defs().get(expr.hir_id) {"}, {"sha": "dec5ea1d15399dd649829f18cddd63479f3addf7", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -637,11 +637,11 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 node: hir::VisibilityKind::Restricted { ref path, .. }, .. }) => path.def,\n \n             Node::NodeExpr(&hir::Expr {\n-                node: hir::ExprStruct(ref qpath, ..),\n+                node: hir::ExprKind::Struct(ref qpath, ..),\n                 ..\n             }) |\n             Node::NodeExpr(&hir::Expr {\n-                node: hir::ExprPath(ref qpath),\n+                node: hir::ExprKind::Path(ref qpath),\n                 ..\n             }) |\n             Node::NodePat(&hir::Pat {"}, {"sha": "c9f9cf4d5fe4acab72e374c4157a927f83382766", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -1180,7 +1180,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             }\n             hir::TyInfer => {\n                 // TyInfer also appears as the type of arguments or return\n-                // values in a ExprClosure, or as\n+                // values in a ExprKind::Closure, or as\n                 // the type of local variables. Both of these cases are\n                 // handled specially and will not descend into this routine.\n                 self.ty_infer(ast_ty.span)"}, {"sha": "c9b5fd525dd82277a8eb286763fc8c74cd4256a1", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -147,7 +147,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // Byte string patterns behave the same way as array patterns\n                 // They can denote both statically and dynamically sized byte arrays\n                 let mut pat_ty = ty;\n-                if let hir::ExprLit(ref lt) = lt.node {\n+                if let hir::ExprKind::Lit(ref lt) = lt.node {\n                     if let ast::LitKind::ByteStr(_) = lt.node {\n                         let expected_ty = self.structurally_resolved_type(pat.span, expected);\n                         if let ty::TyRef(_, r_ty, _) = expected_ty.sty {"}, {"sha": "ec127d26ab30763331f081eb1a87bc9ce9c76afa", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -214,7 +214,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let mut unit_variant = None;\n                 if let &ty::TyAdt(adt_def, ..) = t {\n                     if adt_def.is_enum() {\n-                        if let hir::ExprCall(ref expr, _) = call_expr.node {\n+                        if let hir::ExprKind::Call(ref expr, _) = call_expr.node {\n                             unit_variant = Some(self.tcx.hir.node_to_pretty_string(expr.id))\n                         }\n                     }\n@@ -240,8 +240,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                         path.to_string());\n                 }\n \n-                if let hir::ExprCall(ref expr, _) = call_expr.node {\n-                    let def = if let hir::ExprPath(ref qpath) = expr.node {\n+                if let hir::ExprKind::Call(ref expr, _) = call_expr.node {\n+                    let def = if let hir::ExprKind::Path(ref qpath) = expr.node {\n                         self.tables.borrow().qpath_def(qpath, expr.hir_id)\n                     } else {\n                         Def::Err"}, {"sha": "f7d4bfbeb0550122f69378c2a96110ba2d66b39f", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -196,17 +196,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// opt.map(|arg| { takes_ref(arg) });\n     /// ```\n     fn can_use_as_ref(&self, expr: &hir::Expr) -> Option<(Span, &'static str, String)> {\n-        if let hir::ExprPath(hir::QPath::Resolved(_, ref path)) = expr.node {\n+        if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = expr.node {\n             if let hir::def::Def::Local(id) = path.def {\n                 let parent = self.tcx.hir.get_parent_node(id);\n                 if let Some(NodeExpr(hir::Expr {\n                     id,\n-                    node: hir::ExprClosure(_, decl, ..),\n+                    node: hir::ExprKind::Closure(_, decl, ..),\n                     ..\n                 })) = self.tcx.hir.find(parent) {\n                     let parent = self.tcx.hir.get_parent_node(*id);\n                     if let (Some(NodeExpr(hir::Expr {\n-                        node: hir::ExprMethodCall(path, span, expr),\n+                        node: hir::ExprKind::MethodCall(path, span, expr),\n                         ..\n                     })), 1) = (self.tcx.hir.find(parent), decl.inputs.len()) {\n                         let self_ty = self.tables.borrow().node_id_to_type(expr[0].hir_id);\n@@ -262,7 +262,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             (&ty::TyRef(_, exp, _), &ty::TyRef(_, check, _)) => match (&exp.sty, &check.sty) {\n                 (&ty::TyStr, &ty::TyArray(arr, _)) |\n                 (&ty::TyStr, &ty::TySlice(arr)) if arr == self.tcx.types.u8 => {\n-                    if let hir::ExprLit(_) = expr.node {\n+                    if let hir::ExprKind::Lit(_) = expr.node {\n                         if let Ok(src) = cm.span_to_snippet(sp) {\n                             if src.starts_with(\"b\\\"\") {\n                                 return Some((sp,\n@@ -274,7 +274,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 },\n                 (&ty::TyArray(arr, _), &ty::TyStr) |\n                 (&ty::TySlice(arr), &ty::TyStr) if arr == self.tcx.types.u8 => {\n-                    if let hir::ExprLit(_) = expr.node {\n+                    if let hir::ExprKind::Lit(_) = expr.node {\n                         if let Ok(src) = cm.span_to_snippet(sp) {\n                             if src.starts_with(\"\\\"\") {\n                                 return Some((sp,\n@@ -306,7 +306,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if self.can_coerce(ref_ty, expected) {\n                     if let Ok(src) = cm.span_to_snippet(sp) {\n                         let sugg_expr = match expr.node { // parenthesize if needed (Issue #46756)\n-                            hir::ExprCast(_, _) | hir::ExprBinary(_, _, _) => format!(\"({})\", src),\n+                            hir::ExprKind::Cast(_, _) | hir::ExprKind::Binary(_, _, _) => format!(\"({})\", src),\n                             _ => src,\n                         };\n                         if let Some(sugg) = self.can_use_as_ref(expr) {\n@@ -336,7 +336,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                    sp.ctxt().outer().expn_info().is_none() {\n                     match expr.node {\n                         // Maybe remove `&`?\n-                        hir::ExprAddrOf(_, ref expr) => {\n+                        hir::ExprKind::AddrOf(_, ref expr) => {\n                             if !cm.span_to_filename(expr.span).is_real() {\n                                 return None;\n                             }"}, {"sha": "6c3e265619fea708e4766ee1f494971ab42d35d0", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -449,9 +449,9 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         loop {\n             let last = exprs[exprs.len() - 1];\n             match last.node {\n-                hir::ExprField(ref expr, _) |\n-                hir::ExprIndex(ref expr, _) |\n-                hir::ExprUnary(hir::UnDeref, ref expr) => exprs.push(&expr),\n+                hir::ExprKind::Field(ref expr, _) |\n+                hir::ExprKind::Index(ref expr, _) |\n+                hir::ExprKind::Unary(hir::UnDeref, ref expr) => exprs.push(&expr),\n                 _ => break,\n             }\n         }\n@@ -493,12 +493,12 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             }\n \n             match expr.node {\n-                hir::ExprIndex(ref base_expr, ref index_expr) => {\n+                hir::ExprKind::Index(ref base_expr, ref index_expr) => {\n                     let index_expr_ty = self.node_ty(index_expr.hir_id);\n                     self.convert_place_op_to_mutable(\n                         PlaceOp::Index, expr, base_expr, &[index_expr_ty]);\n                 }\n-                hir::ExprUnary(hir::UnDeref, ref base_expr) => {\n+                hir::ExprKind::Unary(hir::UnDeref, ref base_expr) => {\n                     self.convert_place_op_to_mutable(\n                         PlaceOp::Deref, expr, base_expr, &[]);\n                 }"}, {"sha": "bd3243e4f484e59897fed5c0533b96d79178f38c", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -245,7 +245,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             \"f32\"\n                         };\n                         match expr.node {\n-                            hir::ExprLit(ref lit) => {  // numeric literal\n+                            hir::ExprKind::Lit(ref lit) => {  // numeric literal\n                                 let snippet = tcx.sess.codemap().span_to_snippet(lit.span)\n                                     .unwrap_or(\"<numeric literal>\".to_string());\n \n@@ -257,7 +257,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                             snippet,\n                                                             concrete_type));\n                             }\n-                            hir::ExprPath(ref qpath) => {  // local binding\n+                            hir::ExprKind::Path(ref qpath) => {  // local binding\n                                 if let &hir::QPath::Resolved(_, ref path) = &qpath {\n                                     if let hir::def::Def::Local(node_id) = path.def {\n                                         let span = tcx.hir.span(node_id);\n@@ -389,7 +389,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if let Some(expr) = rcvr_expr {\n                         if let Ok(expr_string) = tcx.sess.codemap().span_to_snippet(expr.span) {\n                             report_function!(expr.span, expr_string);\n-                        } else if let hir::ExprPath(hir::QPath::Resolved(_, ref path)) = expr.node {\n+                        } else if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = expr.node {\n                             if let Some(segment) = path.segments.last() {\n                                 report_function!(expr.span, segment.ident);\n                             }"}, {"sha": "f1097e02f0821e2700afccf93de3635a35228b16", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 76, "deletions": 76, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -2347,52 +2347,52 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn is_place_expr(&self, expr: &hir::Expr) -> bool {\n          match expr.node {\n-            hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+            hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n                 match path.def {\n                     Def::Local(..) | Def::Upvar(..) | Def::Static(..) | Def::Err => true,\n                     _ => false,\n                 }\n             }\n \n-            hir::ExprType(ref e, _) => {\n+            hir::ExprKind::Type(ref e, _) => {\n                 self.is_place_expr(e)\n             }\n \n-            hir::ExprUnary(hir::UnDeref, _) |\n-            hir::ExprField(..) |\n-            hir::ExprIndex(..) => {\n+            hir::ExprKind::Unary(hir::UnDeref, _) |\n+            hir::ExprKind::Field(..) |\n+            hir::ExprKind::Index(..) => {\n                 true\n             }\n \n             // Partially qualified paths in expressions can only legally\n             // refer to associated items which are always rvalues.\n-            hir::ExprPath(hir::QPath::TypeRelative(..)) |\n-\n-            hir::ExprCall(..) |\n-            hir::ExprMethodCall(..) |\n-            hir::ExprStruct(..) |\n-            hir::ExprTup(..) |\n-            hir::ExprIf(..) |\n-            hir::ExprMatch(..) |\n-            hir::ExprClosure(..) |\n-            hir::ExprBlock(..) |\n-            hir::ExprRepeat(..) |\n-            hir::ExprArray(..) |\n-            hir::ExprBreak(..) |\n-            hir::ExprContinue(..) |\n-            hir::ExprRet(..) |\n-            hir::ExprWhile(..) |\n-            hir::ExprLoop(..) |\n-            hir::ExprAssign(..) |\n-            hir::ExprInlineAsm(..) |\n-            hir::ExprAssignOp(..) |\n-            hir::ExprLit(_) |\n-            hir::ExprUnary(..) |\n-            hir::ExprBox(..) |\n-            hir::ExprAddrOf(..) |\n-            hir::ExprBinary(..) |\n-            hir::ExprYield(..) |\n-            hir::ExprCast(..) => {\n+            hir::ExprKind::Path(hir::QPath::TypeRelative(..)) |\n+\n+            hir::ExprKind::Call(..) |\n+            hir::ExprKind::MethodCall(..) |\n+            hir::ExprKind::Struct(..) |\n+            hir::ExprKind::Tup(..) |\n+            hir::ExprKind::If(..) |\n+            hir::ExprKind::Match(..) |\n+            hir::ExprKind::Closure(..) |\n+            hir::ExprKind::Block(..) |\n+            hir::ExprKind::Repeat(..) |\n+            hir::ExprKind::Array(..) |\n+            hir::ExprKind::Break(..) |\n+            hir::ExprKind::Continue(..) |\n+            hir::ExprKind::Ret(..) |\n+            hir::ExprKind::While(..) |\n+            hir::ExprKind::Loop(..) |\n+            hir::ExprKind::Assign(..) |\n+            hir::ExprKind::InlineAsm(..) |\n+            hir::ExprKind::AssignOp(..) |\n+            hir::ExprKind::Lit(_) |\n+            hir::ExprKind::Unary(..) |\n+            hir::ExprKind::Box(..) |\n+            hir::ExprKind::AddrOf(..) |\n+            hir::ExprKind::Binary(..) |\n+            hir::ExprKind::Yield(..) |\n+            hir::ExprKind::Cast(..) => {\n                 false\n             }\n         }\n@@ -2763,7 +2763,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n                 let is_closure = match arg.node {\n-                    hir::ExprClosure(..) => true,\n+                    hir::ExprKind::Closure(..) => true,\n                     _ => false\n                 };\n \n@@ -2915,7 +2915,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n             // Add help to type error if this is an `if` condition with an assignment\n             match (expected, &expr.node) {\n-                (ExpectIfCondition, &hir::ExprAssign(ref lhs, ref rhs)) => {\n+                (ExpectIfCondition, &hir::ExprKind::Assign(ref lhs, ref rhs)) => {\n                     let msg = \"try comparing for equality\";\n                     if let (Ok(left), Ok(right)) = (\n                         self.tcx.sess.codemap().span_to_snippet(lhs.span),\n@@ -3625,9 +3625,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Warn for non-block expressions with diverging children.\n         match expr.node {\n-            hir::ExprBlock(..) |\n-            hir::ExprLoop(..) | hir::ExprWhile(..) |\n-            hir::ExprIf(..) | hir::ExprMatch(..) => {}\n+            hir::ExprKind::Block(..) |\n+            hir::ExprKind::Loop(..) | hir::ExprKind::While(..) |\n+            hir::ExprKind::If(..) | hir::ExprKind::Match(..) => {}\n \n             _ => self.warn_if_unreachable(expr.id, expr.span, \"expression\")\n         }\n@@ -3659,7 +3659,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let tcx = self.tcx;\n         let id = expr.id;\n         match expr.node {\n-            hir::ExprBox(ref subexpr) => {\n+            hir::ExprKind::Box(ref subexpr) => {\n                 let expected_inner = expected.to_option(self).map_or(NoExpectation, |ty| {\n                     match ty.sty {\n                         ty::TyAdt(def, _) if def.is_box()\n@@ -3671,16 +3671,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 tcx.mk_box(referent_ty)\n             }\n \n-            hir::ExprLit(ref lit) => {\n+            hir::ExprKind::Lit(ref lit) => {\n                 self.check_lit(&lit, expected)\n             }\n-            hir::ExprBinary(op, ref lhs, ref rhs) => {\n+            hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n                 self.check_binop(expr, op, lhs, rhs)\n             }\n-            hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n+            hir::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n                 self.check_binop_assign(expr, op, lhs, rhs)\n             }\n-            hir::ExprUnary(unop, ref oprnd) => {\n+            hir::ExprKind::Unary(unop, ref oprnd) => {\n                 let expected_inner = match unop {\n                     hir::UnNot | hir::UnNeg => {\n                         expected\n@@ -3748,7 +3748,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 oprnd_t\n             }\n-            hir::ExprAddrOf(mutbl, ref oprnd) => {\n+            hir::ExprKind::AddrOf(mutbl, ref oprnd) => {\n                 let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n                     match ty.sty {\n                         ty::TyRef(_, ty, _) | ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n@@ -3788,7 +3788,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     tcx.mk_ref(region, tm)\n                 }\n             }\n-            hir::ExprPath(ref qpath) => {\n+            hir::ExprKind::Path(ref qpath) => {\n                 let (def, opt_ty, segs) = self.resolve_ty_and_def_ufcs(qpath, expr.id, expr.span);\n                 let ty = if def != Def::Err {\n                     self.instantiate_value_path(segs, opt_ty, def, expr.span, id)\n@@ -3804,7 +3804,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 ty\n             }\n-            hir::ExprInlineAsm(_, ref outputs, ref inputs) => {\n+            hir::ExprKind::InlineAsm(_, ref outputs, ref inputs) => {\n                 for output in outputs {\n                     self.check_expr(output);\n                 }\n@@ -3813,7 +3813,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 tcx.mk_nil()\n             }\n-            hir::ExprBreak(destination, ref expr_opt) => {\n+            hir::ExprKind::Break(destination, ref expr_opt) => {\n                 if let Ok(target_id) = destination.target_id {\n                     let (e_ty, cause);\n                     if let Some(ref e) = *expr_opt {\n@@ -3886,7 +3886,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                         // ... except when we try to 'break rust;'.\n                         // ICE this expression in particular (see #43162).\n-                        if let hir::ExprPath(hir::QPath::Resolved(_, ref path)) = e.node {\n+                        if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = e.node {\n                             if path.segments.len() == 1 && path.segments[0].ident.name == \"rust\" {\n                                 fatally_break_rust(self.tcx.sess);\n                             }\n@@ -3897,15 +3897,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n             }\n-            hir::ExprContinue(destination) => {\n+            hir::ExprKind::Continue(destination) => {\n                 if let Ok(_) = destination.target_id {\n                     tcx.types.never\n                 } else {\n                     // There was an error, make typecheck fail\n                     tcx.types.err\n                 }\n             }\n-            hir::ExprRet(ref expr_opt) => {\n+            hir::ExprKind::Ret(ref expr_opt) => {\n                 if self.ret_coercion.is_none() {\n                     struct_span_err!(self.tcx.sess, expr.span, E0572,\n                                         \"return statement outside of function body\").emit();\n@@ -3918,7 +3918,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 tcx.types.never\n             }\n-            hir::ExprAssign(ref lhs, ref rhs) => {\n+            hir::ExprKind::Assign(ref lhs, ref rhs) => {\n                 let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n \n                 let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n@@ -3948,11 +3948,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     tcx.mk_nil()\n                 }\n             }\n-            hir::ExprIf(ref cond, ref then_expr, ref opt_else_expr) => {\n+            hir::ExprKind::If(ref cond, ref then_expr, ref opt_else_expr) => {\n                 self.check_then_else(&cond, then_expr, opt_else_expr.as_ref().map(|e| &**e),\n                                     expr.span, expected)\n             }\n-            hir::ExprWhile(ref cond, ref body, _) => {\n+            hir::ExprKind::While(ref cond, ref body, _) => {\n                 let ctxt = BreakableCtxt {\n                     // cannot use break with a value from a while loop\n                     coerce: None,\n@@ -3976,7 +3976,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 self.tcx.mk_nil()\n             }\n-            hir::ExprLoop(ref body, _, source) => {\n+            hir::ExprKind::Loop(ref body, _, source) => {\n                 let coerce = match source {\n                     // you can only use break with a value from a normal `loop { }`\n                     hir::LoopSource::Loop => {\n@@ -4016,22 +4016,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 ctxt.coerce.map(|c| c.complete(self)).unwrap_or(self.tcx.mk_nil())\n             }\n-            hir::ExprMatch(ref discrim, ref arms, match_src) => {\n+            hir::ExprKind::Match(ref discrim, ref arms, match_src) => {\n                 self.check_match(expr, &discrim, arms, expected, match_src)\n             }\n-            hir::ExprClosure(capture, ref decl, body_id, _, gen) => {\n+            hir::ExprKind::Closure(capture, ref decl, body_id, _, gen) => {\n                 self.check_expr_closure(expr, capture, &decl, body_id, gen, expected)\n             }\n-            hir::ExprBlock(ref body, _) => {\n+            hir::ExprKind::Block(ref body, _) => {\n                 self.check_block_with_expected(&body, expected)\n             }\n-            hir::ExprCall(ref callee, ref args) => {\n+            hir::ExprKind::Call(ref callee, ref args) => {\n                 self.check_call(expr, &callee, args, expected)\n             }\n-            hir::ExprMethodCall(ref segment, span, ref args) => {\n+            hir::ExprKind::MethodCall(ref segment, span, ref args) => {\n                 self.check_method_call(expr, segment, span, args, expected, needs)\n             }\n-            hir::ExprCast(ref e, ref t) => {\n+            hir::ExprKind::Cast(ref e, ref t) => {\n                 // Find the type of `e`. Supply hints based on the type we are casting to,\n                 // if appropriate.\n                 let t_cast = self.to_ty(t);\n@@ -4056,12 +4056,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ExprType(ref e, ref t) => {\n+            hir::ExprKind::Type(ref e, ref t) => {\n                 let ty = self.to_ty(&t);\n                 self.check_expr_eq_type(&e, ty);\n                 ty\n             }\n-            hir::ExprArray(ref args) => {\n+            hir::ExprKind::Array(ref args) => {\n                 let uty = expected.to_option(self).and_then(|uty| {\n                     match uty.sty {\n                         ty::TyArray(ty, _) | ty::TySlice(ty) => Some(ty),\n@@ -4085,7 +4085,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 };\n                 tcx.mk_array(element_ty, args.len() as u64)\n             }\n-            hir::ExprRepeat(ref element, ref count) => {\n+            hir::ExprKind::Repeat(ref element, ref count) => {\n                 let count_def_id = tcx.hir.local_def_id(count.id);\n                 let param_env = ty::ParamEnv::empty();\n                 let substs = Substs::identity_for_item(tcx.global_tcx(), count_def_id);\n@@ -4148,7 +4148,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     tcx.types.err\n                 }\n             }\n-            hir::ExprTup(ref elts) => {\n+            hir::ExprKind::Tup(ref elts) => {\n                 let flds = expected.only_has_type(self).and_then(|ty| {\n                     let ty = self.resolve_type_vars_with_obligations(ty);\n                     match ty.sty {\n@@ -4178,13 +4178,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     tuple\n                 }\n             }\n-            hir::ExprStruct(ref qpath, ref fields, ref base_expr) => {\n+            hir::ExprKind::Struct(ref qpath, ref fields, ref base_expr) => {\n                 self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n             }\n-            hir::ExprField(ref base, field) => {\n+            hir::ExprKind::Field(ref base, field) => {\n                 self.check_field(expr, needs, &base, field)\n             }\n-            hir::ExprIndex(ref base, ref idx) => {\n+            hir::ExprKind::Index(ref base, ref idx) => {\n                 let base_t = self.check_expr_with_needs(&base, needs);\n                 let idx_t = self.check_expr(&idx);\n \n@@ -4210,7 +4210,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 let mut needs_note = true;\n                                 // If the index is an integer, we can show the actual\n                                 // fixed expression:\n-                                if let hir::ExprLit(ref lit) = idx.node {\n+                                if let hir::ExprKind::Lit(ref lit) = idx.node {\n                                     if let ast::LitKind::Int(i,\n                                             ast::LitIntType::Unsuffixed) = lit.node {\n                                         let snip = tcx.sess.codemap().span_to_snippet(base.span);\n@@ -4233,7 +4233,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ExprYield(ref value) => {\n+            hir::ExprKind::Yield(ref value) => {\n                 match self.yield_ty {\n                     Some(ty) => {\n                         self.check_expr_coercable_to_type(&value, ty);\n@@ -4641,13 +4641,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // `BlockTailExpression` only relevant if the tail expr would be\n             // useful on its own.\n             match expression.node {\n-                hir::ExprCall(..) |\n-                hir::ExprMethodCall(..) |\n-                hir::ExprIf(..) |\n-                hir::ExprWhile(..) |\n-                hir::ExprLoop(..) |\n-                hir::ExprMatch(..) |\n-                hir::ExprBlock(..) => {\n+                hir::ExprKind::Call(..) |\n+                hir::ExprKind::MethodCall(..) |\n+                hir::ExprKind::If(..) |\n+                hir::ExprKind::While(..) |\n+                hir::ExprKind::Loop(..) |\n+                hir::ExprKind::Match(..) |\n+                hir::ExprKind::Block(..) => {\n                     let sp = self.tcx.sess.codemap().next_point(cause_span);\n                     err.span_suggestion(sp,\n                                         \"try adding a semicolon\",\n@@ -5048,7 +5048,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match self.tcx.hir.get(self.tcx.hir.get_parent_node(node_id)) {\n             Node::NodeExpr(expr) => {\n                 match expr.node {\n-                    hir::ExprCall(ref callee, ..) => {\n+                    hir::ExprKind::Call(ref callee, ..) => {\n                         if callee.id == node_id {\n                             return\n                         }"}, {"sha": "8aa5658d291db711a1b2bb60c0deaf26d3ceaf6b", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -495,9 +495,9 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         // provided as arguments outlive the call.\n         if is_method_call {\n             let origin = match expr.node {\n-                hir::ExprMethodCall(..) =>\n+                hir::ExprKind::MethodCall(..) =>\n                     infer::ParameterOrigin::MethodCall,\n-                hir::ExprUnary(op, _) if op == hir::UnDeref =>\n+                hir::ExprKind::Unary(op, _) if op == hir::UnDeref =>\n                     infer::ParameterOrigin::OverloadedDeref,\n                 _ =>\n                     infer::ParameterOrigin::OverloadedOperator\n@@ -525,13 +525,13 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"regionck::visit_expr(e={:?}, repeating_scope={}) - visiting subexprs\",\n                expr, self.repeating_scope);\n         match expr.node {\n-            hir::ExprPath(_) => {\n+            hir::ExprKind::Path(_) => {\n                 let substs = self.tables.borrow().node_substs(expr.hir_id);\n                 let origin = infer::ParameterOrigin::Path;\n                 self.substs_wf_in_scope(origin, substs, expr.span, expr_region);\n             }\n \n-            hir::ExprCall(ref callee, ref args) => {\n+            hir::ExprKind::Call(ref callee, ref args) => {\n                 if is_method_call {\n                     self.constrain_call(expr, Some(&callee), args.iter().map(|e| &*e));\n                 } else {\n@@ -542,34 +542,34 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprMethodCall(.., ref args) => {\n+            hir::ExprKind::MethodCall(.., ref args) => {\n                 self.constrain_call(expr, Some(&args[0]), args[1..].iter().map(|e| &*e));\n \n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprAssignOp(_, ref lhs, ref rhs) => {\n+            hir::ExprKind::AssignOp(_, ref lhs, ref rhs) => {\n                 if is_method_call {\n                     self.constrain_call(expr, Some(&lhs), Some(&**rhs).into_iter());\n                 }\n \n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprIndex(ref lhs, ref rhs) if is_method_call => {\n+            hir::ExprKind::Index(ref lhs, ref rhs) if is_method_call => {\n                 self.constrain_call(expr, Some(&lhs), Some(&**rhs).into_iter());\n \n                 intravisit::walk_expr(self, expr);\n             },\n \n-            hir::ExprBinary(_, ref lhs, ref rhs) if is_method_call => {\n-                // As `ExprMethodCall`, but the call is via an overloaded op.\n+            hir::ExprKind::Binary(_, ref lhs, ref rhs) if is_method_call => {\n+                // As `ExprKind::MethodCall`, but the call is via an overloaded op.\n                 self.constrain_call(expr, Some(&lhs), Some(&**rhs).into_iter());\n \n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprBinary(_, ref lhs, ref rhs) => {\n+            hir::ExprKind::Binary(_, ref lhs, ref rhs) => {\n                 // If you do `x OP y`, then the types of `x` and `y` must\n                 // outlive the operation you are performing.\n                 let lhs_ty = self.resolve_expr_type_adjusted(&lhs);\n@@ -581,7 +581,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprUnary(hir::UnDeref, ref base) => {\n+            hir::ExprKind::Unary(hir::UnDeref, ref base) => {\n                 // For *a, the lifetime of a must enclose the deref\n                 if is_method_call {\n                     self.constrain_call(expr, Some(base), None::<hir::Expr>.iter());\n@@ -596,30 +596,30 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprUnary(_, ref lhs) if is_method_call => {\n+            hir::ExprKind::Unary(_, ref lhs) if is_method_call => {\n                 // As above.\n                 self.constrain_call(expr, Some(&lhs), None::<hir::Expr>.iter());\n \n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprIndex(ref vec_expr, _) => {\n+            hir::ExprKind::Index(ref vec_expr, _) => {\n                 // For a[b], the lifetime of a must enclose the deref\n                 let vec_type = self.resolve_expr_type_adjusted(&vec_expr);\n                 self.constrain_index(expr, vec_type);\n \n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprCast(ref source, _) => {\n+            hir::ExprKind::Cast(ref source, _) => {\n                 // Determine if we are casting `source` to a trait\n                 // instance.  If so, we have to be sure that the type of\n                 // the source obeys the trait's region bound.\n                 self.constrain_cast(expr, &source);\n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprAddrOf(m, ref base) => {\n+            hir::ExprKind::AddrOf(m, ref base) => {\n                 self.link_addr_of(expr, m, &base);\n \n                 // Require that when you write a `&expr` expression, the\n@@ -635,23 +635,23 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprMatch(ref discr, ref arms, _) => {\n+            hir::ExprKind::Match(ref discr, ref arms, _) => {\n                 self.link_match(&discr, &arms[..]);\n \n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprClosure(.., body_id, _, _) => {\n+            hir::ExprKind::Closure(.., body_id, _, _) => {\n                 self.check_expr_fn_block(expr, body_id);\n             }\n \n-            hir::ExprLoop(ref body, _, _) => {\n+            hir::ExprKind::Loop(ref body, _, _) => {\n                 let repeating_scope = self.set_repeating_scope(body.id);\n                 intravisit::walk_expr(self, expr);\n                 self.set_repeating_scope(repeating_scope);\n             }\n \n-            hir::ExprWhile(ref cond, ref body, _) => {\n+            hir::ExprKind::While(ref cond, ref body, _) => {\n                 let repeating_scope = self.set_repeating_scope(cond.id);\n                 self.visit_expr(&cond);\n \n@@ -661,9 +661,9 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 self.set_repeating_scope(repeating_scope);\n             }\n \n-            hir::ExprRet(Some(ref ret_expr)) => {\n+            hir::ExprKind::Ret(Some(ref ret_expr)) => {\n                 let call_site_scope = self.call_site_scope;\n-                debug!(\"visit_expr ExprRet ret_expr.id {} call_site_scope: {:?}\",\n+                debug!(\"visit_expr ExprKind::Ret ret_expr.id {} call_site_scope: {:?}\",\n                        ret_expr.id, call_site_scope);\n                 let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope.unwrap()));\n                 self.type_of_node_must_outlive(infer::CallReturn(ret_expr.span),"}, {"sha": "61fe90be2177420c9567dfe5a5ff9e30d221dbe0", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for InferBorrowKindVisitor<'a, 'gcx, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n         match expr.node {\n-            hir::ExprClosure(cc, _, body_id, _, _) => {\n+            hir::ExprKind::Closure(cc, _, body_id, _, _) => {\n                 let body = self.fcx.tcx.hir.body(body_id);\n                 self.visit_body(body);\n                 self.fcx"}, {"sha": "61f8f571d6a474f84e0cc8e5cb8a8c3308b17c4a", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -117,7 +117,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     // operating on scalars, we clear the overload.\n     fn fix_scalar_builtin_expr(&mut self, e: &hir::Expr) {\n         match e.node {\n-            hir::ExprUnary(hir::UnNeg, ref inner) | hir::ExprUnary(hir::UnNot, ref inner) => {\n+            hir::ExprKind::Unary(hir::UnNeg, ref inner) | hir::ExprKind::Unary(hir::UnNot, ref inner) => {\n                 let inner_ty = self.fcx.node_ty(inner.hir_id);\n                 let inner_ty = self.fcx.resolve_type_vars_if_possible(&inner_ty);\n \n@@ -127,8 +127,8 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                     tables.node_substs_mut().remove(e.hir_id);\n                 }\n             }\n-            hir::ExprBinary(ref op, ref lhs, ref rhs)\n-            | hir::ExprAssignOp(ref op, ref lhs, ref rhs) => {\n+            hir::ExprKind::Binary(ref op, ref lhs, ref rhs)\n+            | hir::ExprKind::AssignOp(ref op, ref lhs, ref rhs) => {\n                 let lhs_ty = self.fcx.node_ty(lhs.hir_id);\n                 let lhs_ty = self.fcx.resolve_type_vars_if_possible(&lhs_ty);\n \n@@ -141,14 +141,14 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                     tables.node_substs_mut().remove(e.hir_id);\n \n                     match e.node {\n-                        hir::ExprBinary(..) => {\n+                        hir::ExprKind::Binary(..) => {\n                             if !op.node.is_by_value() {\n                                 let mut adjustments = tables.adjustments_mut();\n                                 adjustments.get_mut(lhs.hir_id).map(|a| a.pop());\n                                 adjustments.get_mut(rhs.hir_id).map(|a| a.pop());\n                             }\n                         }\n-                        hir::ExprAssignOp(..) => {\n+                        hir::ExprKind::AssignOp(..) => {\n                             tables\n                                 .adjustments_mut()\n                                 .get_mut(lhs.hir_id)\n@@ -167,7 +167,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     // to use builtin indexing because the index type is known to be\n     // usize-ish\n     fn fix_index_builtin_expr(&mut self, e: &hir::Expr) {\n-        if let hir::ExprIndex(ref base, ref index) = e.node {\n+        if let hir::ExprKind::Index(ref base, ref index) = e.node {\n             let mut tables = self.fcx.tables.borrow_mut();\n \n             match tables.expr_ty_adjusted(&base).sty {\n@@ -227,20 +227,20 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n         self.visit_node_id(e.span, e.hir_id);\n \n         match e.node {\n-            hir::ExprClosure(_, _, body, _, _) => {\n+            hir::ExprKind::Closure(_, _, body, _, _) => {\n                 let body = self.fcx.tcx.hir.body(body);\n                 for arg in &body.arguments {\n                     self.visit_node_id(e.span, arg.hir_id);\n                 }\n \n                 self.visit_body(body);\n             }\n-            hir::ExprStruct(_, ref fields, _) => {\n+            hir::ExprKind::Struct(_, ref fields, _) => {\n                 for field in fields {\n                     self.visit_field_id(field.id);\n                 }\n             }\n-            hir::ExprField(..) => {\n+            hir::ExprKind::Field(..) => {\n                 self.visit_field_id(e.id);\n             }\n             _ => {}"}, {"sha": "d956d86798b9bafb562df710197ecc69986450af", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -129,7 +129,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        if let hir::ExprClosure(..) = expr.node {\n+        if let hir::ExprKind::Closure(..) = expr.node {\n             let def_id = self.tcx.hir.local_def_id(expr.id);\n             self.tcx.generics_of(def_id);\n             self.tcx.type_of(def_id);\n@@ -805,7 +805,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let parent_id = tcx.hir.get_parent(node_id);\n             Some(tcx.hir.local_def_id(parent_id))\n         }\n-        NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n+        NodeExpr(&hir::Expr { node: hir::ExprKind::Closure(..), .. }) => {\n             Some(tcx.closure_base_def_id(def_id))\n         }\n         NodeItem(item) => {\n@@ -946,7 +946,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // provide junk type parameter defs - the only place that\n     // cares about anything but the length is instantiation,\n     // and we don't do that for closures.\n-    if let NodeExpr(&hir::Expr { node: hir::ExprClosure(.., gen), .. }) = node {\n+    if let NodeExpr(&hir::Expr { node: hir::ExprKind::Closure(.., gen), .. }) = node {\n         let dummy_args = if gen.is_some() {\n             &[\"<yield_ty>\", \"<return_ty>\", \"<witness>\"][..]\n         } else {\n@@ -1104,7 +1104,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         NodeField(field) => icx.to_ty(&field.ty),\n \n-        NodeExpr(&hir::Expr { node: hir::ExprClosure(.., gen), .. }) => {\n+        NodeExpr(&hir::Expr { node: hir::ExprKind::Closure(.., gen), .. }) => {\n             if gen.is_some() {\n                 let hir_id = tcx.hir.node_to_hir_id(node_id);\n                 return tcx.typeck_tables_of(def_id).node_id_to_type(hir_id);\n@@ -1120,7 +1120,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         NodeAnonConst(_) => match tcx.hir.get(tcx.hir.get_parent_node(node_id)) {\n             NodeTy(&hir::Ty { node: TyArray(_, ref constant), .. }) |\n             NodeTy(&hir::Ty { node: TyTypeof(ref constant), .. }) |\n-            NodeExpr(&hir::Expr { node: ExprRepeat(_, ref constant), .. })\n+            NodeExpr(&hir::Expr { node: ExprKind::Repeat(_, ref constant), .. })\n                 if constant.id == node_id => tcx.types.usize,\n \n             NodeVariant(&Spanned { node: VariantKind { disr_expr: Some(ref e), .. }, .. })\n@@ -1191,7 +1191,7 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             ))\n         }\n \n-        NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n+        NodeExpr(&hir::Expr { node: hir::ExprKind::Closure(..), .. }) => {\n             // Closure signatures are not like other function\n             // signatures and cannot be accessed through `fn_sig`. For\n             // example, a closure signature excludes the `self`"}, {"sha": "30752e8ddb1086018331e639f246697998710027", "filename": "src/test/compile-fail/borrowck/two-phase-nonrecv-autoref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a16b38198c68cf932d3f43a9663f7588d6a1a3b/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs?ref=6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "patch": "@@ -52,7 +52,7 @@ fn deref_coercion(x: &mut u32) {\n // - [x] coerce_unsized e.g. `&[T; n]`, `&mut [T; n] -> &[T]`,\n //                      `&mut [T; n] -> &mut [T]`, `&Concrete -> &Trait`\n // - [x] Method Call Receivers (the case we want to support!)\n-// - [x] ExprIndex and ExprUnary Deref; only need to handle coerce_index_op\n+// - [x] ExprKind::Index and ExprKind::Unary Deref; only need to handle coerce_index_op\n // - [x] overloaded_binops\n \n fn overloaded_call_traits() {"}]}