{"sha": "7589bc7ba92df64cbf3cab214724a6d500a0e2b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ODliYzdiYTkyZGY2NGNiZjNjYWIyMTQ3MjRhNmQ1MDBhMGUyYjM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-30T20:29:27Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-30T20:29:27Z"}, "message": "sync cleanup: mark infallible ops as such; consistent combine en/dequeue with (un)block; comments", "tree": {"sha": "07861857075e1c1a62f4d23c6647f55bedf77ec3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07861857075e1c1a62f4d23c6647f55bedf77ec3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7589bc7ba92df64cbf3cab214724a6d500a0e2b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7589bc7ba92df64cbf3cab214724a6d500a0e2b3", "html_url": "https://github.com/rust-lang/rust/commit/7589bc7ba92df64cbf3cab214724a6d500a0e2b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7589bc7ba92df64cbf3cab214724a6d500a0e2b3/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "508371ac5accf551672200c71b7d5c9fac80ef04", "url": "https://api.github.com/repos/rust-lang/rust/commits/508371ac5accf551672200c71b7d5c9fac80ef04", "html_url": "https://github.com/rust-lang/rust/commit/508371ac5accf551672200c71b7d5c9fac80ef04"}], "stats": {"total": 214, "additions": 110, "deletions": 104}, "files": [{"sha": "77f0c5b9fbd61fb67d0b080a84a138429a871311", "filename": "src/shims/foreign_items/posix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7589bc7ba92df64cbf3cab214724a6d500a0e2b3/src%2Fshims%2Fforeign_items%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7589bc7ba92df64cbf3cab214724a6d500a0e2b3/src%2Fshims%2Fforeign_items%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix.rs?ref=7589bc7ba92df64cbf3cab214724a6d500a0e2b3", "patch": "@@ -254,14 +254,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"pthread_getspecific\" => {\n                 let &[key] = check_arg_count(args)?;\n                 let key = this.force_bits(this.read_scalar(key)?.not_undef()?, key.layout.size)?;\n-                let active_thread = this.get_active_thread()?;\n+                let active_thread = this.get_active_thread();\n                 let ptr = this.machine.tls.load_tls(key, active_thread, this)?;\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"pthread_setspecific\" => {\n                 let &[key, new_ptr] = check_arg_count(args)?;\n                 let key = this.force_bits(this.read_scalar(key)?.not_undef()?, key.layout.size)?;\n-                let active_thread = this.get_active_thread()?;\n+                let active_thread = this.get_active_thread();\n                 let new_ptr = this.read_scalar(new_ptr)?.not_undef()?;\n                 this.machine.tls.store_tls(key, active_thread, this.test_null(new_ptr)?)?;\n "}, {"sha": "fb50e4d918173838ce3c50269b3f1f81c61b1ed6", "filename": "src/shims/foreign_items/posix/macos.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7589bc7ba92df64cbf3cab214724a6d500a0e2b3/src%2Fshims%2Fforeign_items%2Fposix%2Fmacos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7589bc7ba92df64cbf3cab214724a6d500a0e2b3/src%2Fshims%2Fforeign_items%2Fposix%2Fmacos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix%2Fmacos.rs?ref=7589bc7ba92df64cbf3cab214724a6d500a0e2b3", "patch": "@@ -98,7 +98,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let dtor = this.read_scalar(dtor)?.not_undef()?;\n                 let dtor = this.memory.get_fn(dtor)?.as_instance()?;\n                 let data = this.read_scalar(data)?.not_undef()?;\n-                let active_thread = this.get_active_thread()?;\n+                let active_thread = this.get_active_thread();\n                 this.machine.tls.set_macos_thread_dtor(active_thread, dtor, data)?;\n             }\n "}, {"sha": "2a30a23489970576bbea67681d8ac77bb3a0c1ce", "filename": "src/shims/foreign_items/windows.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7589bc7ba92df64cbf3cab214724a6d500a0e2b3/src%2Fshims%2Fforeign_items%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7589bc7ba92df64cbf3cab214724a6d500a0e2b3/src%2Fshims%2Fforeign_items%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fwindows.rs?ref=7589bc7ba92df64cbf3cab214724a6d500a0e2b3", "patch": "@@ -163,14 +163,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"TlsGetValue\" => {\n                 let &[key] = check_arg_count(args)?;\n                 let key = u128::from(this.read_scalar(key)?.to_u32()?);\n-                let active_thread = this.get_active_thread()?;\n+                let active_thread = this.get_active_thread();\n                 let ptr = this.machine.tls.load_tls(key, active_thread, this)?;\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"TlsSetValue\" => {\n                 let &[key, new_ptr] = check_arg_count(args)?;\n                 let key = u128::from(this.read_scalar(key)?.to_u32()?);\n-                let active_thread = this.get_active_thread()?;\n+                let active_thread = this.get_active_thread();\n                 let new_ptr = this.read_scalar(new_ptr)?.not_undef()?;\n                 this.machine.tls.store_tls(key, active_thread, this.test_null(new_ptr)?)?;\n \n@@ -291,7 +291,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n                 #[allow(non_snake_case)]\n                 let &[_lpCriticalSection] = check_arg_count(args)?;\n-                assert_eq!(this.get_total_thread_count()?, 1, \"concurrency on Windows not supported\");\n+                assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows not supported\");\n                 // Nothing to do, not even a return value.\n                 // (Windows locks are reentrant, and we have only 1 thread,\n                 // so not doing any futher checks here is at least not incorrect.)\n@@ -300,7 +300,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n                 #[allow(non_snake_case)]\n                 let &[_lpCriticalSection] = check_arg_count(args)?;\n-                assert_eq!(this.get_total_thread_count()?, 1, \"concurrency on Windows not supported\");\n+                assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows not supported\");\n                 // There is only one thread, so this always succeeds and returns TRUE\n                 this.write_scalar(Scalar::from_i32(1), dest)?;\n             }"}, {"sha": "01c7b4a1eb4fa158eff8e111df4690c84e58dd7b", "filename": "src/shims/sync.rs", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/7589bc7ba92df64cbf3cab214724a6d500a0e2b3/src%2Fshims%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7589bc7ba92df64cbf3cab214724a6d500a0e2b3/src%2Fshims%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fsync.rs?ref=7589bc7ba92df64cbf3cab214724a6d500a0e2b3", "patch": "@@ -284,15 +284,16 @@ fn reacquire_cond_mutex<'mir, 'tcx: 'mir>(\n     thread: ThreadId,\n     mutex: MutexId,\n ) -> InterpResult<'tcx> {\n+    ecx.unblock_thread(thread);\n     if ecx.mutex_is_locked(mutex) {\n-        ecx.mutex_enqueue(mutex, thread);\n+        ecx.mutex_enqueue_and_block(mutex, thread);\n     } else {\n         ecx.mutex_lock(mutex, thread);\n-        ecx.unblock_thread(thread)?;\n     }\n     Ok(())\n }\n \n+/// After a thread waiting on a condvar was signalled:\n /// Reacquire the conditional variable and remove the timeout callback if any\n /// was registered.\n fn post_cond_signal<'mir, 'tcx: 'mir>(\n@@ -303,12 +304,13 @@ fn post_cond_signal<'mir, 'tcx: 'mir>(\n     reacquire_cond_mutex(ecx, thread, mutex)?;\n     // Waiting for the mutex is not included in the waiting time because we need\n     // to acquire the mutex always even if we get a timeout.\n-    ecx.unregister_timeout_callback_if_exists(thread)\n+    ecx.unregister_timeout_callback_if_exists(thread);\n+    Ok(())\n }\n \n /// Release the mutex associated with the condition variable because we are\n /// entering the waiting state.\n-fn release_cond_mutex<'mir, 'tcx: 'mir>(\n+fn release_cond_mutex_and_block<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     active_thread: ThreadId,\n     mutex: MutexId,\n@@ -320,7 +322,7 @@ fn release_cond_mutex<'mir, 'tcx: 'mir>(\n     } else {\n         throw_ub_format!(\"awaiting on unlocked or owned by a different thread mutex\");\n     }\n-    ecx.block_thread(active_thread)?;\n+    ecx.block_thread(active_thread);\n     Ok(())\n }\n \n@@ -411,14 +413,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let kind = mutex_get_kind(this, mutex_op)?.not_undef()?;\n         let id = mutex_get_or_create_id(this, mutex_op)?;\n-        let active_thread = this.get_active_thread()?;\n+        let active_thread = this.get_active_thread();\n \n         if this.mutex_is_locked(id) {\n             let owner_thread = this.mutex_get_owner(id);\n             if owner_thread != active_thread {\n-                // Block the active thread.\n-                this.block_thread(active_thread)?;\n-                this.mutex_enqueue(id, active_thread);\n+                // Enqueue the active thread.\n+                this.mutex_enqueue_and_block(id, active_thread);\n                 Ok(0)\n             } else {\n                 // Trying to acquire the same mutex again.\n@@ -449,7 +450,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let kind = mutex_get_kind(this, mutex_op)?.not_undef()?;\n         let id = mutex_get_or_create_id(this, mutex_op)?;\n-        let active_thread = this.get_active_thread()?;\n+        let active_thread = this.get_active_thread();\n \n         if this.mutex_is_locked(id) {\n             let owner_thread = this.mutex_get_owner(id);\n@@ -482,7 +483,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let kind = mutex_get_kind(this, mutex_op)?.not_undef()?;\n         let id = mutex_get_or_create_id(this, mutex_op)?;\n-        let active_thread = this.get_active_thread()?;\n+        let active_thread = this.get_active_thread();\n \n         if let Some(_old_locked_count) = this.mutex_unlock(id, active_thread)? {\n             // The mutex was locked by the current thread.\n@@ -528,10 +529,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         let id = rwlock_get_or_create_id(this, rwlock_op)?;\n-        let active_thread = this.get_active_thread()?;\n+        let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n-            this.rwlock_enqueue_and_block_reader(id, active_thread)?;\n+            this.rwlock_enqueue_and_block_reader(id, active_thread);\n             Ok(0)\n         } else {\n             this.rwlock_reader_lock(id, active_thread);\n@@ -543,7 +544,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         let id = rwlock_get_or_create_id(this, rwlock_op)?;\n-        let active_thread = this.get_active_thread()?;\n+        let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n             this.eval_libc_i32(\"EBUSY\")\n@@ -557,22 +558,22 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         let id = rwlock_get_or_create_id(this, rwlock_op)?;\n-        let active_thread = this.get_active_thread()?;\n+        let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n             // Note: this will deadlock if the lock is already locked by this\n             // thread in any way.\n             //\n             // Relevant documentation:\n             // https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_rwlock_wrlock.html\n-            // An in depth discussion on this topic:\n+            // An in-depth discussion on this topic:\n             // https://github.com/rust-lang/rust/issues/53127\n             //\n             // FIXME: Detect and report the deadlock proactively. (We currently\n             // report the deadlock only when no thread can continue execution,\n             // but we could detect that this lock is already locked and report\n             // an error.)\n-            this.rwlock_enqueue_and_block_writer(id, active_thread)?;\n+            this.rwlock_enqueue_and_block_writer(id, active_thread);\n         } else {\n             this.rwlock_writer_lock(id, active_thread);\n         }\n@@ -584,7 +585,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         let id = rwlock_get_or_create_id(this, rwlock_op)?;\n-        let active_thread = this.get_active_thread()?;\n+        let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n             this.eval_libc_i32(\"EBUSY\")\n@@ -598,15 +599,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         let id = rwlock_get_or_create_id(this, rwlock_op)?;\n-        let active_thread = this.get_active_thread()?;\n+        let active_thread = this.get_active_thread();\n \n         if this.rwlock_reader_unlock(id, active_thread) {\n             // The thread was a reader.\n             if this.rwlock_is_locked(id) {\n                 // No more readers owning the lock. Give it to a writer if there\n                 // is any.\n-                if let Some(writer) = this.rwlock_dequeue_writer(id) {\n-                    this.unblock_thread(writer)?;\n+                if let Some(writer) = this.rwlock_dequeue_and_unblock_writer(id) {\n                     this.rwlock_writer_lock(id, writer);\n                 }\n             }\n@@ -617,14 +617,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // We are prioritizing writers here against the readers. As a\n             // result, not only readers can starve writers, but also writers can\n             // starve readers.\n-            if let Some(writer) = this.rwlock_dequeue_writer(id) {\n+            if let Some(writer) = this.rwlock_dequeue_and_unblock_writer(id) {\n                 // Give the lock to another writer.\n-                this.unblock_thread(writer)?;\n                 this.rwlock_writer_lock(id, writer);\n             } else {\n                 // Give the lock to all readers.\n-                while let Some(reader) = this.rwlock_dequeue_reader(id) {\n-                    this.unblock_thread(reader)?;\n+                while let Some(reader) = this.rwlock_dequeue_and_unblock_reader(id) {\n                     this.rwlock_reader_lock(id, reader);\n                 }\n             }\n@@ -753,9 +751,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let id = cond_get_or_create_id(this, cond_op)?;\n         let mutex_id = mutex_get_or_create_id(this, mutex_op)?;\n-        let active_thread = this.get_active_thread()?;\n+        let active_thread = this.get_active_thread();\n \n-        release_cond_mutex(this, active_thread, mutex_id)?;\n+        release_cond_mutex_and_block(this, active_thread, mutex_id)?;\n         this.condvar_wait(id, active_thread, mutex_id);\n \n         Ok(0)\n@@ -774,9 +772,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let id = cond_get_or_create_id(this, cond_op)?;\n         let mutex_id = mutex_get_or_create_id(this, mutex_op)?;\n-        let active_thread = this.get_active_thread()?;\n+        let active_thread = this.get_active_thread();\n \n-        release_cond_mutex(this, active_thread, mutex_id)?;\n+        release_cond_mutex_and_block(this, active_thread, mutex_id)?;\n         this.condvar_wait(id, active_thread, mutex_id);\n \n         // We return success for now and override it in the timeout callback.\n@@ -823,7 +821,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n                 Ok(())\n             }),\n-        )?;\n+        );\n \n         Ok(())\n     }\n@@ -833,7 +831,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let id = cond_get_or_create_id(this, cond_op)?;\n         if this.condvar_is_awaited(id) {\n-            throw_ub_format!(\"destroyed an awaited conditional variable\");\n+            throw_ub_format!(\"destroying an awaited conditional variable\");\n         }\n         cond_set_id(this, cond_op, ScalarMaybeUninit::Uninit)?;\n         cond_set_clock_id(this, cond_op, ScalarMaybeUninit::Uninit)?;"}, {"sha": "e5d3a9f0d6f8789f8b5d7bb4e1f11ab03d824f48", "filename": "src/shims/thread.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7589bc7ba92df64cbf3cab214724a6d500a0e2b3/src%2Fshims%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7589bc7ba92df64cbf3cab214724a6d500a0e2b3/src%2Fshims%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fthread.rs?ref=7589bc7ba92df64cbf3cab214724a6d500a0e2b3", "patch": "@@ -19,9 +19,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n              For example, Miri does not detect data races yet.\",\n         );\n \n-        let new_thread_id = this.create_thread()?;\n+        let new_thread_id = this.create_thread();\n         // Also switch to new thread so that we can push the first stackframe.\n-        let old_thread_id = this.set_active_thread(new_thread_id)?;\n+        let old_thread_id = this.set_active_thread(new_thread_id);\n \n         let thread_info_place = this.deref_operand(thread)?;\n         this.write_scalar(\n@@ -47,7 +47,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             StackPopCleanup::None { cleanup: true },\n         )?;\n \n-        this.set_active_thread(old_thread_id)?;\n+        this.set_active_thread(old_thread_id);\n \n         Ok(0)\n     }\n@@ -82,7 +82,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn pthread_self(&mut self, dest: PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n-        let thread_id = this.get_active_thread()?;\n+        let thread_id = this.get_active_thread();\n         this.write_scalar(Scalar::from_uint(thread_id.to_u32(), dest.layout.size), dest)\n     }\n \n@@ -105,10 +105,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // byte. Since `read_c_str` returns the string without the null\n             // byte, we need to truncate to 15.\n             name.truncate(15);\n-            this.set_active_thread_name(name)?;\n+            this.set_active_thread_name(name);\n         } else if option == this.eval_libc_i32(\"PR_GET_NAME\")? {\n             let address = this.read_scalar(arg2)?.not_undef()?;\n-            let mut name = this.get_active_thread_name()?.to_vec();\n+            let mut name = this.get_active_thread_name().to_vec();\n             name.push(0u8);\n             assert!(name.len() <= 16);\n             this.memory.write_bytes(address, name)?;\n@@ -127,15 +127,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.assert_target_os(\"macos\", \"pthread_setname_np\");\n \n         let name = this.memory.read_c_str(name)?.to_owned();\n-        this.set_active_thread_name(name)?;\n+        this.set_active_thread_name(name);\n \n         Ok(())\n     }\n \n     fn sched_yield(&mut self) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        this.yield_active_thread()?;\n+        this.yield_active_thread();\n \n         Ok(0)\n     }"}, {"sha": "695614633682a481351ceecd85fe0b74b781b9f6", "filename": "src/shims/tls.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7589bc7ba92df64cbf3cab214724a6d500a0e2b3/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7589bc7ba92df64cbf3cab214724a6d500a0e2b3/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=7589bc7ba92df64cbf3cab214724a6d500a0e2b3", "patch": "@@ -232,8 +232,8 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// yet.\n     fn schedule_windows_tls_dtors(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let active_thread = this.get_active_thread()?;\n-        assert_eq!(this.get_total_thread_count()?, 1, \"concurrency on Windows not supported\");\n+        let active_thread = this.get_active_thread();\n+        assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows not supported\");\n         // Windows has a special magic linker section that is run on certain events.\n         // Instead of searching for that section and supporting arbitrary hooks in there\n         // (that would be basically https://github.com/rust-lang/miri/issues/450),\n@@ -252,7 +252,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             StackPopCleanup::None { cleanup: true },\n         )?;\n \n-        this.enable_thread(active_thread)?;\n+        this.enable_thread(active_thread);\n         Ok(())\n     }\n \n@@ -262,7 +262,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// Note: It is safe to call this function also on other Unixes.\n     fn schedule_macos_tls_dtor(&mut self) -> InterpResult<'tcx, bool> {\n         let this = self.eval_context_mut();\n-        let thread_id = this.get_active_thread()?;\n+        let thread_id = this.get_active_thread();\n         if let Some((instance, data)) = this.machine.tls.macos_thread_dtors.remove(&thread_id) {\n             trace!(\"Running macos dtor {:?} on {:?} at {:?}\", instance, data, thread_id);\n \n@@ -278,7 +278,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // we just scheduled. Since we deleted the destructor, it is\n             // guaranteed that we will schedule it again. The `dtors_running`\n             // flag will prevent the code from adding the destructor again.\n-            this.enable_thread(thread_id)?;\n+            this.enable_thread(thread_id);\n             Ok(true)\n         } else {\n             Ok(false)\n@@ -289,9 +289,9 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// a destructor to schedule, and `false` otherwise.\n     fn schedule_next_pthread_tls_dtor(&mut self) -> InterpResult<'tcx, bool> {\n         let this = self.eval_context_mut();\n-        let active_thread = this.get_active_thread()?;\n+        let active_thread = this.get_active_thread();\n \n-        assert!(this.has_terminated(active_thread)?, \"running TLS dtors for non-terminated thread\");\n+        assert!(this.has_terminated(active_thread), \"running TLS dtors for non-terminated thread\");\n         // Fetch next dtor after `key`.\n         let last_key = this.machine.tls.dtors_running[&active_thread].last_dtor_key.clone();\n         let dtor = match this.machine.tls.fetch_tls_dtor(last_key, active_thread) {\n@@ -314,7 +314,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 StackPopCleanup::None { cleanup: true },\n             )?;\n \n-            this.enable_thread(active_thread)?;\n+            this.enable_thread(active_thread);\n             return Ok(true);\n         }\n         this.machine.tls.dtors_running.get_mut(&active_thread).unwrap().last_dtor_key = None;\n@@ -340,7 +340,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// https://github.com/rust-lang/rust/issues/28129.\n     fn schedule_next_tls_dtor_for_active_thread(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let active_thread = this.get_active_thread()?;\n+        let active_thread = this.get_active_thread();\n \n         if !this.machine.tls.set_dtors_running_for_thread(active_thread) {\n             // This is the first time we got asked to schedule a destructor. The"}, {"sha": "8418bd429515ef320a55a8e7c6e587ae5ac4ed73", "filename": "src/sync.rs", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7589bc7ba92df64cbf3cab214724a6d500a0e2b3/src%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7589bc7ba92df64cbf3cab214724a6d500a0e2b3/src%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsync.rs?ref=7589bc7ba92df64cbf3cab214724a6d500a0e2b3", "patch": "@@ -145,13 +145,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         mutex.lock_count = mutex.lock_count.checked_add(1).unwrap();\n     }\n \n-    /// Try unlocking by decreasing the lock count and returning the old owner\n-    /// and the old lock count. If the lock count reaches 0, release the lock\n-    /// and potentially give to a new owner. If the lock was not locked, return\n-    /// `None`.\n-    ///\n-    /// Note: It is the caller's responsibility to check that the thread that\n-    /// unlocked the lock actually is the same one, which owned it.\n+    /// Try unlocking by decreasing the lock count and returning the old lock\n+    /// count. If the lock count reaches 0, release the lock and potentially\n+    /// give to a new owner. If the lock was not locked by `expected_owner`,\n+    /// return `None`.\n     fn mutex_unlock(\n         &mut self,\n         id: MutexId,\n@@ -173,9 +170,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 mutex.owner = None;\n                 // The mutex is completely unlocked. Try transfering ownership\n                 // to another thread.\n-                if let Some(new_owner) = this.mutex_dequeue(id) {\n+                if let Some(new_owner) = this.mutex_dequeue_and_unblock(id) {\n                     this.mutex_lock(id, new_owner);\n-                    this.unblock_thread(new_owner)?;\n                 }\n             }\n             Ok(Some(old_lock_count))\n@@ -187,17 +183,23 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     #[inline]\n     /// Put the thread into the queue waiting for the lock.\n-    fn mutex_enqueue(&mut self, id: MutexId, thread: ThreadId) {\n+    fn mutex_enqueue_and_block(&mut self, id: MutexId, thread: ThreadId) {\n         let this = self.eval_context_mut();\n         assert!(this.mutex_is_locked(id), \"queing on unlocked mutex\");\n         this.machine.threads.sync.mutexes[id].queue.push_back(thread);\n+        this.block_thread(thread);\n     }\n \n     #[inline]\n     /// Take a thread out of the queue waiting for the lock.\n-    fn mutex_dequeue(&mut self, id: MutexId) -> Option<ThreadId> {\n+    fn mutex_dequeue_and_unblock(&mut self, id: MutexId) -> Option<ThreadId> {\n         let this = self.eval_context_mut();\n-        this.machine.threads.sync.mutexes[id].queue.pop_front()\n+        if let Some(thread) = this.machine.threads.sync.mutexes[id].queue.pop_front() {\n+            this.unblock_thread(thread);\n+            Some(thread)\n+        } else {\n+            None\n+        }\n     }\n \n     #[inline]\n@@ -255,25 +257,30 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         id: RwLockId,\n         reader: ThreadId,\n-    ) -> InterpResult<'tcx> {\n+    ) {\n         let this = self.eval_context_mut();\n         assert!(this.rwlock_is_write_locked(id), \"queueing on not write locked lock\");\n         this.machine.threads.sync.rwlocks[id].reader_queue.push_back(reader);\n-        this.block_thread(reader)\n+        this.block_thread(reader);\n     }\n \n     #[inline]\n     /// Take a reader out the queue waiting for the lock.\n-    fn rwlock_dequeue_reader(&mut self, id: RwLockId) -> Option<ThreadId> {\n+    fn rwlock_dequeue_and_unblock_reader(&mut self, id: RwLockId) -> Option<ThreadId> {\n         let this = self.eval_context_mut();\n-        this.machine.threads.sync.rwlocks[id].reader_queue.pop_front()\n+        if let Some(reader) = this.machine.threads.sync.rwlocks[id].reader_queue.pop_front() {\n+            this.unblock_thread(reader);\n+            Some(reader)\n+        } else {\n+            None\n+        }\n     }\n \n     #[inline]\n     /// Lock by setting the writer that owns the lock.\n     fn rwlock_writer_lock(&mut self, id: RwLockId, writer: ThreadId) {\n         let this = self.eval_context_mut();\n-        assert!(!this.rwlock_is_locked(id), \"the lock is already locked\");\n+        assert!(!this.rwlock_is_locked(id), \"the relock is already locked\");\n         this.machine.threads.sync.rwlocks[id].writer = Some(writer);\n     }\n \n@@ -290,18 +297,23 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         id: RwLockId,\n         writer: ThreadId,\n-    ) -> InterpResult<'tcx> {\n+    ) {\n         let this = self.eval_context_mut();\n         assert!(this.rwlock_is_locked(id), \"queueing on unlocked lock\");\n         this.machine.threads.sync.rwlocks[id].writer_queue.push_back(writer);\n-        this.block_thread(writer)\n+        this.block_thread(writer);\n     }\n \n     #[inline]\n     /// Take the writer out the queue waiting for the lock.\n-    fn rwlock_dequeue_writer(&mut self, id: RwLockId) -> Option<ThreadId> {\n+    fn rwlock_dequeue_and_unblock_writer(&mut self, id: RwLockId) -> Option<ThreadId> {\n         let this = self.eval_context_mut();\n-        this.machine.threads.sync.rwlocks[id].writer_queue.pop_front()\n+        if let Some(writer) = this.machine.threads.sync.rwlocks[id].writer_queue.pop_front() {\n+            this.unblock_thread(writer);\n+            Some(writer)\n+        } else {\n+            None\n+        }\n     }\n \n     #[inline]"}, {"sha": "246a383d178b072a148a2eff0a0f8d76855fc647", "filename": "src/thread.rs", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7589bc7ba92df64cbf3cab214724a6d500a0e2b3/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7589bc7ba92df64cbf3cab214724a6d500a0e2b3/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=7589bc7ba92df64cbf3cab214724a6d500a0e2b3", "patch": "@@ -581,9 +581,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[inline]\n-    fn create_thread(&mut self) -> InterpResult<'tcx, ThreadId> {\n+    fn create_thread(&mut self) -> ThreadId {\n         let this = self.eval_context_mut();\n-        Ok(this.machine.threads.create_thread())\n+        this.machine.threads.create_thread()\n     }\n \n     #[inline]\n@@ -599,34 +599,33 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[inline]\n-    fn set_active_thread(&mut self, thread_id: ThreadId) -> InterpResult<'tcx, ThreadId> {\n+    fn set_active_thread(&mut self, thread_id: ThreadId) -> ThreadId {\n         let this = self.eval_context_mut();\n-        Ok(this.machine.threads.set_active_thread_id(thread_id))\n+        this.machine.threads.set_active_thread_id(thread_id)\n     }\n \n     #[inline]\n-    fn get_active_thread(&self) -> InterpResult<'tcx, ThreadId> {\n+    fn get_active_thread(&self) -> ThreadId {\n         let this = self.eval_context_ref();\n-        Ok(this.machine.threads.get_active_thread_id())\n+        this.machine.threads.get_active_thread_id()\n     }\n \n     #[inline]\n-    fn get_total_thread_count(&self) -> InterpResult<'tcx, usize> {\n+    fn get_total_thread_count(&self) -> usize {\n         let this = self.eval_context_ref();\n-        Ok(this.machine.threads.get_total_thread_count())\n+        this.machine.threads.get_total_thread_count()\n     }\n \n     #[inline]\n-    fn has_terminated(&self, thread_id: ThreadId) -> InterpResult<'tcx, bool> {\n+    fn has_terminated(&self, thread_id: ThreadId) -> bool {\n         let this = self.eval_context_ref();\n-        Ok(this.machine.threads.has_terminated(thread_id))\n+        this.machine.threads.has_terminated(thread_id)\n     }\n \n     #[inline]\n-    fn enable_thread(&mut self, thread_id: ThreadId) -> InterpResult<'tcx> {\n+    fn enable_thread(&mut self, thread_id: ThreadId) {\n         let this = self.eval_context_mut();\n         this.machine.threads.enable_thread(thread_id);\n-        Ok(())\n     }\n \n     #[inline]\n@@ -642,37 +641,36 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[inline]\n-    fn set_active_thread_name(&mut self, new_thread_name: Vec<u8>) -> InterpResult<'tcx, ()> {\n+    fn set_active_thread_name(&mut self, new_thread_name: Vec<u8>) {\n         let this = self.eval_context_mut();\n-        Ok(this.machine.threads.set_thread_name(new_thread_name))\n+        this.machine.threads.set_thread_name(new_thread_name);\n     }\n \n     #[inline]\n-    fn get_active_thread_name<'c>(&'c self) -> InterpResult<'tcx, &'c [u8]>\n+    fn get_active_thread_name<'c>(&'c self) -> &'c [u8]\n     where\n         'mir: 'c,\n     {\n         let this = self.eval_context_ref();\n-        Ok(this.machine.threads.get_thread_name())\n+        this.machine.threads.get_thread_name()\n     }\n \n     #[inline]\n-    fn block_thread(&mut self, thread: ThreadId) -> InterpResult<'tcx> {\n+    fn block_thread(&mut self, thread: ThreadId) {\n         let this = self.eval_context_mut();\n-        Ok(this.machine.threads.block_thread(thread))\n+        this.machine.threads.block_thread(thread);\n     }\n \n     #[inline]\n-    fn unblock_thread(&mut self, thread: ThreadId) -> InterpResult<'tcx> {\n+    fn unblock_thread(&mut self, thread: ThreadId) {\n         let this = self.eval_context_mut();\n-        Ok(this.machine.threads.unblock_thread(thread))\n+        this.machine.threads.unblock_thread(thread);\n     }\n \n     #[inline]\n-    fn yield_active_thread(&mut self) -> InterpResult<'tcx> {\n+    fn yield_active_thread(&mut self) {\n         let this = self.eval_context_mut();\n         this.machine.threads.yield_active_thread();\n-        Ok(())\n     }\n \n     #[inline]\n@@ -681,17 +679,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         thread: ThreadId,\n         call_time: Time,\n         callback: TimeoutCallback<'mir, 'tcx>,\n-    ) -> InterpResult<'tcx> {\n+    ) {\n         let this = self.eval_context_mut();\n         this.machine.threads.register_timeout_callback(thread, call_time, callback);\n-        Ok(())\n     }\n \n     #[inline]\n-    fn unregister_timeout_callback_if_exists(&mut self, thread: ThreadId) -> InterpResult<'tcx> {\n+    fn unregister_timeout_callback_if_exists(&mut self, thread: ThreadId) {\n         let this = self.eval_context_mut();\n         this.machine.threads.unregister_timeout_callback_if_exists(thread);\n-        Ok(())\n     }\n \n     /// Execute a timeout callback on the callback's thread.\n@@ -706,9 +702,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         //    thread.\n         // 2. Make the scheduler the only place that can change the active\n         //    thread.\n-        let old_thread = this.set_active_thread(thread)?;\n+        let old_thread = this.set_active_thread(thread);\n         callback(this)?;\n-        this.set_active_thread(old_thread)?;\n+        this.set_active_thread(old_thread);\n         Ok(())\n     }\n "}]}