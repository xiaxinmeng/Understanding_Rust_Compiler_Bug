{"sha": "7d0db1efdb3aafcfcd1864654ea4d58024b579f2", "node_id": "C_kwDOAAsO6NoAKDdkMGRiMWVmZGIzYWFmY2ZjZDE4NjQ2NTRlYTRkNTgwMjRiNTc5ZjI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-26T13:02:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-26T13:02:15Z"}, "message": "Auto merge of #2647 - saethlin:current-span, r=RalfJung\n\nTrack local frames incrementally during execution\n\nhttps://github.com/rust-lang/miri/pull/2646 currently introduces a performance regression. This change removes that regression, and provides a minor perf improvement.\n\nThe existing lazy strategy for tracking the span we want to display is as efficient as it is only because we often create a `CurrentSpan` then never call `.get()`. Most of the calls to the `before_memory_read` and `before_memory_write` hooks do not create any event that we store in `AllocHistory`. But data races are totally different, any memory read or write may race, so every call to those hooks needs to access to the current local span.\n\nSo this changes to a strategy where we update some state in a `Thread` and `FrameExtra` incrementally, upon entering and existing each function call.\n\nBefore:\n```\nBenchmark 1: cargo +miri miri run --manifest-path /home/ben/miri/bench-cargo-miri/backtraces/Cargo.toml\n  Time (mean \u00b1 \u03c3):      5.532 s \u00b1  0.022 s    [User: 5.444 s, System: 0.073 s]\n  Range (min \u2026 max):    5.516 s \u2026  5.569 s    5 runs\n\nBenchmark 1: cargo +miri miri run --manifest-path /home/ben/miri/bench-cargo-miri/mse/Cargo.toml\n  Time (mean \u00b1 \u03c3):     831.4 ms \u00b1   3.0 ms    [User: 783.8 ms, System: 46.7 ms]\n  Range (min \u2026 max):   828.7 ms \u2026 836.1 ms    5 runs\n\nBenchmark 1: cargo +miri miri run --manifest-path /home/ben/miri/bench-cargo-miri/serde1/Cargo.toml\n  Time (mean \u00b1 \u03c3):      1.975 s \u00b1  0.021 s    [User: 1.914 s, System: 0.059 s]\n  Range (min \u2026 max):    1.939 s \u2026  1.990 s    5 runs\n\nBenchmark 1: cargo +miri miri run --manifest-path /home/ben/miri/bench-cargo-miri/serde2/Cargo.toml\n  Time (mean \u00b1 \u03c3):      4.060 s \u00b1  0.051 s    [User: 3.983 s, System: 0.071 s]\n  Range (min \u2026 max):    3.972 s \u2026  4.100 s    5 runs\n\nBenchmark 1: cargo +miri miri run --manifest-path /home/ben/miri/bench-cargo-miri/slice-get-unchecked/Cargo.toml\n  Time (mean \u00b1 \u03c3):     784.9 ms \u00b1   8.2 ms    [User: 746.5 ms, System: 37.7 ms]\n  Range (min \u2026 max):   772.9 ms \u2026 793.3 ms    5 runs\n\nBenchmark 1: cargo +miri miri run --manifest-path /home/ben/miri/bench-cargo-miri/unicode/Cargo.toml\n  Time (mean \u00b1 \u03c3):      1.679 s \u00b1  0.006 s    [User: 1.623 s, System: 0.055 s]\n  Range (min \u2026 max):    1.673 s \u2026  1.687 s    5 runs\n```\nAfter:\n```\nBenchmark 1: cargo +miri miri run --manifest-path /home/ben/miri/bench-cargo-miri/backtraces/Cargo.toml\n  Time (mean \u00b1 \u03c3):      5.330 s \u00b1  0.037 s    [User: 5.232 s, System: 0.084 s]\n  Range (min \u2026 max):    5.280 s \u2026  5.383 s    5 runs\n\nBenchmark 1: cargo +miri miri run --manifest-path /home/ben/miri/bench-cargo-miri/mse/Cargo.toml\n  Time (mean \u00b1 \u03c3):     818.9 ms \u00b1   3.7 ms    [User: 776.8 ms, System: 41.3 ms]\n  Range (min \u2026 max):   813.5 ms \u2026 822.5 ms    5 runs\n\nBenchmark 1: cargo +miri miri run --manifest-path /home/ben/miri/bench-cargo-miri/serde1/Cargo.toml\n  Time (mean \u00b1 \u03c3):      1.927 s \u00b1  0.011 s    [User: 1.864 s, System: 0.061 s]\n  Range (min \u2026 max):    1.917 s \u2026  1.945 s    5 runs\n\nBenchmark 1: cargo +miri miri run --manifest-path /home/ben/miri/bench-cargo-miri/serde2/Cargo.toml\n  Time (mean \u00b1 \u03c3):      3.974 s \u00b1  0.020 s    [User: 3.893 s, System: 0.076 s]\n  Range (min \u2026 max):    3.956 s \u2026  4.004 s    5 runs\n\nBenchmark 1: cargo +miri miri run --manifest-path /home/ben/miri/bench-cargo-miri/slice-get-unchecked/Cargo.toml\n  Time (mean \u00b1 \u03c3):     780.0 ms \u00b1   5.3 ms    [User: 740.3 ms, System: 39.0 ms]\n  Range (min \u2026 max):   771.2 ms \u2026 784.5 ms    5 runs\n\nBenchmark 1: cargo +miri miri run --manifest-path /home/ben/miri/bench-cargo-miri/unicode/Cargo.toml\n  Time (mean \u00b1 \u03c3):      1.643 s \u00b1  0.007 s    [User: 1.584 s, System: 0.058 s]\n  Range (min \u2026 max):    1.635 s \u2026  1.654 s    5 runs\n```\n(This change is marginal, but the point is that it avoids a much more significant regression)", "tree": {"sha": "a9fe3b955b3130fde9e13c5d1cf4c291fe50500c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9fe3b955b3130fde9e13c5d1cf4c291fe50500c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d0db1efdb3aafcfcd1864654ea4d58024b579f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d0db1efdb3aafcfcd1864654ea4d58024b579f2", "html_url": "https://github.com/rust-lang/rust/commit/7d0db1efdb3aafcfcd1864654ea4d58024b579f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d0db1efdb3aafcfcd1864654ea4d58024b579f2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe815229c344ef3ad4b67d91a0bbe2f1e0bb7f2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe815229c344ef3ad4b67d91a0bbe2f1e0bb7f2e", "html_url": "https://github.com/rust-lang/rust/commit/fe815229c344ef3ad4b67d91a0bbe2f1e0bb7f2e"}, {"sha": "726b9d09d420e8b94428170f3e8a637f54928f50", "url": "https://api.github.com/repos/rust-lang/rust/commits/726b9d09d420e8b94428170f3e8a637f54928f50", "html_url": "https://github.com/rust-lang/rust/commit/726b9d09d420e8b94428170f3e8a637f54928f50"}], "stats": {"total": 314, "additions": 153, "deletions": 161}, "files": [{"sha": "dacb3a9b88f8f660f67bb234c552f7fbf90960f3", "filename": "src/tools/miri/src/concurrency/thread.rs", "status": "modified", "additions": 52, "deletions": 3, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7d0db1efdb3aafcfcd1864654ea4d58024b579f2/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0db1efdb3aafcfcd1864654ea4d58024b579f2/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs?ref=7d0db1efdb3aafcfcd1864654ea4d58024b579f2", "patch": "@@ -118,6 +118,13 @@ pub struct Thread<'mir, 'tcx> {\n     /// The virtual call stack.\n     stack: Vec<Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>>,\n \n+    /// The index of the topmost user-relevant frame in `stack`. This field must contain\n+    /// the value produced by `get_top_user_relevant_frame`.\n+    /// The `None` state here represents\n+    /// This field is a cache to reduce how often we call that method. The cache is manually\n+    /// maintained inside `MiriMachine::after_stack_push` and `MiriMachine::after_stack_pop`.\n+    top_user_relevant_frame: Option<usize>,\n+\n     /// The join status.\n     join_status: ThreadJoinStatus,\n \n@@ -147,6 +154,40 @@ impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n     fn thread_name(&self) -> &[u8] {\n         if let Some(ref thread_name) = self.thread_name { thread_name } else { b\"<unnamed>\" }\n     }\n+\n+    /// Return the top user-relevant frame, if there is one.\n+    /// Note that the choice to return `None` here when there is no user-relevant frame is part of\n+    /// justifying the optimization that only pushes of user-relevant frames require updating the\n+    /// `top_user_relevant_frame` field.\n+    fn compute_top_user_relevant_frame(&self) -> Option<usize> {\n+        self.stack\n+            .iter()\n+            .enumerate()\n+            .rev()\n+            .find_map(|(idx, frame)| if frame.extra.is_user_relevant { Some(idx) } else { None })\n+    }\n+\n+    /// Re-compute the top user-relevant frame from scratch.\n+    pub fn recompute_top_user_relevant_frame(&mut self) {\n+        self.top_user_relevant_frame = self.compute_top_user_relevant_frame();\n+    }\n+\n+    /// Set the top user-relevant frame to the given value. Must be equal to what\n+    /// `get_top_user_relevant_frame` would return!\n+    pub fn set_top_user_relevant_frame(&mut self, frame_idx: usize) {\n+        debug_assert_eq!(Some(frame_idx), self.compute_top_user_relevant_frame());\n+        self.top_user_relevant_frame = Some(frame_idx);\n+    }\n+\n+    /// Returns the topmost frame that is considered user-relevant, or the\n+    /// top of the stack if there is no such frame, or `None` if the stack is empty.\n+    pub fn top_user_relevant_frame(&self) -> Option<usize> {\n+        debug_assert_eq!(self.top_user_relevant_frame, self.compute_top_user_relevant_frame());\n+        // This can be called upon creation of an allocation. We create allocations while setting up\n+        // parts of the Rust runtime when we do not have any stack frames yet, so we need to handle\n+        // empty stacks.\n+        self.top_user_relevant_frame.or_else(|| self.stack.len().checked_sub(1))\n+    }\n }\n \n impl<'mir, 'tcx> std::fmt::Debug for Thread<'mir, 'tcx> {\n@@ -167,6 +208,7 @@ impl<'mir, 'tcx> Default for Thread<'mir, 'tcx> {\n             state: ThreadState::Enabled,\n             thread_name: None,\n             stack: Vec::new(),\n+            top_user_relevant_frame: None,\n             join_status: ThreadJoinStatus::Joinable,\n             panic_payload: None,\n             last_error: None,\n@@ -184,8 +226,15 @@ impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n \n impl VisitTags for Thread<'_, '_> {\n     fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n-        let Thread { panic_payload, last_error, stack, state: _, thread_name: _, join_status: _ } =\n-            self;\n+        let Thread {\n+            panic_payload,\n+            last_error,\n+            stack,\n+            top_user_relevant_frame: _,\n+            state: _,\n+            thread_name: _,\n+            join_status: _,\n+        } = self;\n \n         panic_payload.visit_tags(visit);\n         last_error.visit_tags(visit);\n@@ -414,7 +463,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     }\n \n     /// Get a shared borrow of the currently active thread.\n-    fn active_thread_ref(&self) -> &Thread<'mir, 'tcx> {\n+    pub fn active_thread_ref(&self) -> &Thread<'mir, 'tcx> {\n         &self.threads[self.active_thread]\n     }\n "}, {"sha": "8c7bc9eff0016b1bb1d335190116df04739e882f", "filename": "src/tools/miri/src/helpers.rs", "status": "modified", "additions": 20, "deletions": 56, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/7d0db1efdb3aafcfcd1864654ea4d58024b579f2/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0db1efdb3aafcfcd1864654ea4d58024b579f2/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs?ref=7d0db1efdb3aafcfcd1864654ea4d58024b579f2", "patch": "@@ -936,78 +936,42 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n }\n \n impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n-    pub fn current_span(&self) -> CurrentSpan<'_, 'mir, 'tcx> {\n-        CurrentSpan { current_frame_idx: None, machine: self }\n-    }\n-}\n-\n-/// A `CurrentSpan` should be created infrequently (ideally once) per interpreter step. It does\n-/// nothing on creation, but when `CurrentSpan::get` is called, searches the current stack for the\n-/// topmost frame which corresponds to a local crate, and returns the current span in that frame.\n-/// The result of that search is cached so that later calls are approximately free.\n-#[derive(Clone)]\n-pub struct CurrentSpan<'a, 'mir, 'tcx> {\n-    current_frame_idx: Option<usize>,\n-    machine: &'a MiriMachine<'mir, 'tcx>,\n-}\n-\n-impl<'a, 'mir: 'a, 'tcx: 'a + 'mir> CurrentSpan<'a, 'mir, 'tcx> {\n-    pub fn machine(&self) -> &'a MiriMachine<'mir, 'tcx> {\n-        self.machine\n-    }\n-\n-    /// Get the current span, skipping non-local frames.\n+    /// Get the current span in the topmost function which is workspace-local and not\n+    /// `#[track_caller]`.\n     /// This function is backed by a cache, and can be assumed to be very fast.\n-    pub fn get(&mut self) -> Span {\n-        let idx = self.current_frame_idx();\n-        self.stack().get(idx).map(Frame::current_span).unwrap_or(rustc_span::DUMMY_SP)\n+    /// It will work even when the stack is empty.\n+    pub fn current_span(&self) -> Span {\n+        self.top_user_relevant_frame()\n+            .map(|frame_idx| self.stack()[frame_idx].current_span())\n+            .unwrap_or(rustc_span::DUMMY_SP)\n     }\n \n     /// Returns the span of the *caller* of the current operation, again\n     /// walking down the stack to find the closest frame in a local crate, if the caller of the\n     /// current operation is not in a local crate.\n     /// This is useful when we are processing something which occurs on function-entry and we want\n     /// to point at the call to the function, not the function definition generally.\n-    pub fn get_caller(&mut self) -> Span {\n+    pub fn caller_span(&self) -> Span {\n         // We need to go down at least to the caller (len - 2), or however\n-        // far we have to go to find a frame in a local crate.\n-        let local_frame_idx = self.current_frame_idx();\n-        let stack = self.stack();\n-        let idx = cmp::min(local_frame_idx, stack.len().saturating_sub(2));\n-        stack.get(idx).map(Frame::current_span).unwrap_or(rustc_span::DUMMY_SP)\n+        // far we have to go to find a frame in a local crate which is also not #[track_caller].\n+        let frame_idx = self.top_user_relevant_frame().unwrap();\n+        let frame_idx = cmp::min(frame_idx, self.stack().len().checked_sub(2).unwrap());\n+        self.stack()[frame_idx].current_span()\n     }\n \n     fn stack(&self) -> &[Frame<'mir, 'tcx, Provenance, machine::FrameData<'tcx>>] {\n-        self.machine.threads.active_thread_stack()\n+        self.threads.active_thread_stack()\n     }\n \n-    fn current_frame_idx(&mut self) -> usize {\n-        *self\n-            .current_frame_idx\n-            .get_or_insert_with(|| Self::compute_current_frame_index(self.machine))\n+    fn top_user_relevant_frame(&self) -> Option<usize> {\n+        self.threads.active_thread_ref().top_user_relevant_frame()\n     }\n \n-    // Find the position of the inner-most frame which is part of the crate being\n-    // compiled/executed, part of the Cargo workspace, and is also not #[track_caller].\n-    #[inline(never)]\n-    fn compute_current_frame_index(machine: &MiriMachine<'_, '_>) -> usize {\n-        machine\n-            .threads\n-            .active_thread_stack()\n-            .iter()\n-            .enumerate()\n-            .rev()\n-            .find_map(|(idx, frame)| {\n-                let def_id = frame.instance.def_id();\n-                if (def_id.is_local() || machine.local_crates.contains(&def_id.krate))\n-                    && !frame.instance.def.requires_caller_location(machine.tcx)\n-                {\n-                    Some(idx)\n-                } else {\n-                    None\n-                }\n-            })\n-            .unwrap_or(0)\n+    /// This is the source of truth for the `is_user_relevant` flag in our `FrameExtra`.\n+    pub fn is_user_relevant(&self, frame: &Frame<'mir, 'tcx, Provenance>) -> bool {\n+        let def_id = frame.instance.def_id();\n+        (def_id.is_local() || self.local_crates.contains(&def_id.krate))\n+            && !frame.instance.def.requires_caller_location(self.tcx)\n     }\n }\n "}, {"sha": "8913f8aa10fcdb962e927e93858cb5f6f21ae1b6", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0db1efdb3aafcfcd1864654ea4d58024b579f2/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0db1efdb3aafcfcd1864654ea4d58024b579f2/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=7d0db1efdb3aafcfcd1864654ea4d58024b579f2", "patch": "@@ -97,7 +97,7 @@ pub use crate::diagnostics::{\n pub use crate::eval::{\n     create_ecx, eval_entry, AlignmentCheck, BacktraceStyle, IsolatedOp, MiriConfig, RejectOpWith,\n };\n-pub use crate::helpers::{CurrentSpan, EvalContextExt as _};\n+pub use crate::helpers::EvalContextExt as _;\n pub use crate::intptrcast::ProvenanceMode;\n pub use crate::machine::{\n     AllocExtra, FrameData, MiriInterpCx, MiriInterpCxExt, MiriMachine, MiriMemoryKind,"}, {"sha": "b7f434b5557c6c2e17e92835d212dc9012140ea1", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7d0db1efdb3aafcfcd1864654ea4d58024b579f2/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0db1efdb3aafcfcd1864654ea4d58024b579f2/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=7d0db1efdb3aafcfcd1864654ea4d58024b579f2", "patch": "@@ -50,12 +50,18 @@ pub struct FrameData<'tcx> {\n     /// for the start of this frame. When we finish executing this frame,\n     /// we use this to register a completed event with `measureme`.\n     pub timing: Option<measureme::DetachedTiming>,\n+\n+    /// Indicates whether a `Frame` is part of a workspace-local crate and is also not\n+    /// `#[track_caller]`. We compute this once on creation and store the result, as an\n+    /// optimization.\n+    /// This is used by `MiriMachine::current_span` and `MiriMachine::caller_span`\n+    pub is_user_relevant: bool,\n }\n \n impl<'tcx> std::fmt::Debug for FrameData<'tcx> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         // Omitting `timing`, it does not support `Debug`.\n-        let FrameData { stacked_borrows, catch_unwind, timing: _ } = self;\n+        let FrameData { stacked_borrows, catch_unwind, timing: _, is_user_relevant: _ } = self;\n         f.debug_struct(\"FrameData\")\n             .field(\"stacked_borrows\", stacked_borrows)\n             .field(\"catch_unwind\", catch_unwind)\n@@ -65,7 +71,7 @@ impl<'tcx> std::fmt::Debug for FrameData<'tcx> {\n \n impl VisitTags for FrameData<'_> {\n     fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n-        let FrameData { catch_unwind, stacked_borrows, timing: _ } = self;\n+        let FrameData { catch_unwind, stacked_borrows, timing: _, is_user_relevant: _ } = self;\n \n         catch_unwind.visit_tags(visit);\n         stacked_borrows.visit_tags(visit);\n@@ -895,13 +901,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n \n         let alloc = alloc.into_owned();\n         let stacks = ecx.machine.stacked_borrows.as_ref().map(|stacked_borrows| {\n-            Stacks::new_allocation(\n-                id,\n-                alloc.size(),\n-                stacked_borrows,\n-                kind,\n-                ecx.machine.current_span(),\n-            )\n+            Stacks::new_allocation(id, alloc.size(), stacked_borrows, kind, &ecx.machine)\n         });\n         let race_alloc = ecx.machine.data_race.as_ref().map(|data_race| {\n             data_race::AllocExtra::new_allocation(\n@@ -1016,8 +1016,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n                 prov_extra,\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n-                machine.current_span(),\n-                &machine.threads,\n+                machine,\n             )?;\n         }\n         if let Some(weak_memory) = &alloc_extra.weak_memory {\n@@ -1048,8 +1047,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n                 prov_extra,\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n-                machine.current_span(),\n-                &machine.threads,\n+                machine,\n             )?;\n         }\n         if let Some(weak_memory) = &alloc_extra.weak_memory {\n@@ -1083,8 +1081,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n                 prove_extra,\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n-                machine.current_span(),\n-                &machine.threads,\n+                machine,\n             )\n         } else {\n             Ok(())\n@@ -1126,7 +1123,9 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n             stacked_borrows: stacked_borrows.map(|sb| sb.borrow_mut().new_frame(&ecx.machine)),\n             catch_unwind: None,\n             timing,\n+            is_user_relevant: ecx.machine.is_user_relevant(&frame),\n         };\n+\n         Ok(frame.with_extra(extra))\n     }\n \n@@ -1174,6 +1173,13 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn after_stack_push(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+        if ecx.frame().extra.is_user_relevant {\n+            // We just pushed a local frame, so we know that the topmost local frame is the topmost\n+            // frame. If we push a non-local frame, there's no need to do anything.\n+            let stack_len = ecx.active_thread_stack().len();\n+            ecx.active_thread_mut().set_top_user_relevant_frame(stack_len - 1);\n+        }\n+\n         if ecx.machine.stacked_borrows.is_some() { ecx.retag_return_place() } else { Ok(()) }\n     }\n \n@@ -1183,6 +1189,13 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         mut frame: Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>,\n         unwinding: bool,\n     ) -> InterpResult<'tcx, StackPopJump> {\n+        if frame.extra.is_user_relevant {\n+            // All that we store is whether or not the frame we just removed is local, so now we\n+            // have no idea where the next topmost local frame is. So we recompute it.\n+            // (If this ever becomes a bottleneck, we could have `push` store the previous\n+            // user-relevant frame and restore that here.)\n+            ecx.active_thread_mut().recompute_top_user_relevant_frame();\n+        }\n         let timing = frame.extra.timing.take();\n         if let Some(stacked_borrows) = &ecx.machine.stacked_borrows {\n             stacked_borrows.borrow_mut().end_call(&frame.extra);"}, {"sha": "662d8ada735eb92e792744b94f2834a6dc6f7620", "filename": "src/tools/miri/src/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 31, "deletions": 52, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/7d0db1efdb3aafcfcd1864654ea4d58024b579f2/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0db1efdb3aafcfcd1864654ea4d58024b579f2/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fdiagnostics.rs?ref=7d0db1efdb3aafcfcd1864654ea4d58024b579f2", "patch": "@@ -5,7 +5,6 @@ use rustc_middle::mir::interpret::{alloc_range, AllocId, AllocRange};\n use rustc_span::{Span, SpanData};\n use rustc_target::abi::Size;\n \n-use crate::helpers::CurrentSpan;\n use crate::stacked_borrows::{err_sb_ub, AccessKind, GlobalStateInner, Permission, ProtectorKind};\n use crate::*;\n \n@@ -110,42 +109,29 @@ pub struct TagHistory {\n     pub protected: Option<(String, SpanData)>,\n }\n \n-pub struct DiagnosticCxBuilder<'span, 'ecx, 'mir, 'tcx> {\n+pub struct DiagnosticCxBuilder<'ecx, 'mir, 'tcx> {\n     operation: Operation,\n-    // 'span cannot be merged with any other lifetime since they appear invariantly, under the\n-    // mutable ref.\n-    current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n-    threads: &'ecx ThreadManager<'mir, 'tcx>,\n+    machine: &'ecx MiriMachine<'mir, 'tcx>,\n }\n \n-pub struct DiagnosticCx<'span, 'history, 'ecx, 'mir, 'tcx> {\n+pub struct DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n     operation: Operation,\n-    // 'span and 'history cannot be merged, since when we call `unbuild` we need\n-    // to return the exact 'span that was used when calling `build`.\n-    current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n-    threads: &'ecx ThreadManager<'mir, 'tcx>,\n+    machine: &'ecx MiriMachine<'mir, 'tcx>,\n     history: &'history mut AllocHistory,\n     offset: Size,\n }\n \n-impl<'span, 'ecx, 'mir, 'tcx> DiagnosticCxBuilder<'span, 'ecx, 'mir, 'tcx> {\n+impl<'ecx, 'mir, 'tcx> DiagnosticCxBuilder<'ecx, 'mir, 'tcx> {\n     pub fn build<'history>(\n         self,\n         history: &'history mut AllocHistory,\n         offset: Size,\n-    ) -> DiagnosticCx<'span, 'history, 'ecx, 'mir, 'tcx> {\n-        DiagnosticCx {\n-            operation: self.operation,\n-            current_span: self.current_span,\n-            threads: self.threads,\n-            history,\n-            offset,\n-        }\n+    ) -> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n+        DiagnosticCx { operation: self.operation, machine: self.machine, history, offset }\n     }\n \n     pub fn retag(\n-        current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        machine: &'ecx MiriMachine<'mir, 'tcx>,\n         cause: RetagCause,\n         new_tag: SbTag,\n         orig_tag: ProvenanceExtra,\n@@ -154,46 +140,36 @@ impl<'span, 'ecx, 'mir, 'tcx> DiagnosticCxBuilder<'span, 'ecx, 'mir, 'tcx> {\n         let operation =\n             Operation::Retag(RetagOp { cause, new_tag, orig_tag, range, permission: None });\n \n-        DiagnosticCxBuilder { current_span, threads, operation }\n+        DiagnosticCxBuilder { machine, operation }\n     }\n \n     pub fn read(\n-        current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        machine: &'ecx MiriMachine<'mir, 'tcx>,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n     ) -> Self {\n         let operation = Operation::Access(AccessOp { kind: AccessKind::Read, tag, range });\n-        DiagnosticCxBuilder { current_span, threads, operation }\n+        DiagnosticCxBuilder { machine, operation }\n     }\n \n     pub fn write(\n-        current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        machine: &'ecx MiriMachine<'mir, 'tcx>,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n     ) -> Self {\n         let operation = Operation::Access(AccessOp { kind: AccessKind::Write, tag, range });\n-        DiagnosticCxBuilder { current_span, threads, operation }\n+        DiagnosticCxBuilder { machine, operation }\n     }\n \n-    pub fn dealloc(\n-        current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n-        tag: ProvenanceExtra,\n-    ) -> Self {\n+    pub fn dealloc(machine: &'ecx MiriMachine<'mir, 'tcx>, tag: ProvenanceExtra) -> Self {\n         let operation = Operation::Dealloc(DeallocOp { tag });\n-        DiagnosticCxBuilder { current_span, threads, operation }\n+        DiagnosticCxBuilder { machine, operation }\n     }\n }\n \n-impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir, 'tcx> {\n-    pub fn unbuild(self) -> DiagnosticCxBuilder<'span, 'ecx, 'mir, 'tcx> {\n-        DiagnosticCxBuilder {\n-            operation: self.operation,\n-            current_span: self.current_span,\n-            threads: self.threads,\n-        }\n+impl<'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n+    pub fn unbuild(self) -> DiagnosticCxBuilder<'ecx, 'mir, 'tcx> {\n+        DiagnosticCxBuilder { machine: self.machine, operation: self.operation }\n     }\n }\n \n@@ -234,18 +210,18 @@ struct DeallocOp {\n }\n \n impl AllocHistory {\n-    pub fn new(id: AllocId, item: Item, current_span: &mut CurrentSpan<'_, '_, '_>) -> Self {\n+    pub fn new(id: AllocId, item: Item, machine: &MiriMachine<'_, '_>) -> Self {\n         Self {\n             id,\n-            base: (item, current_span.get()),\n+            base: (item, machine.current_span()),\n             creations: SmallVec::new(),\n             invalidations: SmallVec::new(),\n             protectors: SmallVec::new(),\n         }\n     }\n }\n \n-impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir, 'tcx> {\n+impl<'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n     pub fn start_grant(&mut self, perm: Permission) {\n         let Operation::Retag(op) = &mut self.operation else {\n             unreachable!(\"start_grant must only be called during a retag, this is: {:?}\", self.operation)\n@@ -274,15 +250,17 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n         let Operation::Retag(op) = &self.operation else {\n             unreachable!(\"log_creation must only be called during a retag\")\n         };\n-        self.history.creations.push(Creation { retag: op.clone(), span: self.current_span.get() });\n+        self.history\n+            .creations\n+            .push(Creation { retag: op.clone(), span: self.machine.current_span() });\n     }\n \n     pub fn log_invalidation(&mut self, tag: SbTag) {\n-        let mut span = self.current_span.get();\n+        let mut span = self.machine.current_span();\n         let (range, cause) = match &self.operation {\n             Operation::Retag(RetagOp { cause, range, permission, .. }) => {\n                 if *cause == RetagCause::FnEntry {\n-                    span = self.current_span.get_caller();\n+                    span = self.machine.caller_span();\n                 }\n                 (*range, InvalidationCause::Retag(permission.unwrap(), *cause))\n             }\n@@ -301,7 +279,9 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n         let Operation::Retag(op) = &self.operation else {\n             unreachable!(\"Protectors can only be created during a retag\")\n         };\n-        self.history.protectors.push(Protection { tag: op.new_tag, span: self.current_span.get() });\n+        self.history\n+            .protectors\n+            .push(Protection { tag: op.new_tag, span: self.machine.current_span() });\n     }\n \n     pub fn get_logs_relevant_to(\n@@ -418,6 +398,7 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n             ProtectorKind::StrongProtector => \"strongly protected\",\n         };\n         let call_id = self\n+            .machine\n             .threads\n             .all_stacks()\n             .flatten()\n@@ -482,9 +463,7 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n                 Some((orig_tag, kind))\n             }\n         };\n-        self.current_span\n-            .machine()\n-            .emit_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(*item, summary));\n+        self.machine.emit_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(*item, summary));\n     }\n }\n "}, {"sha": "db4e19f91184b74819ff0a69cc0fffeabf81ac58", "filename": "src/tools/miri/src/stacked_borrows/mod.rs", "status": "modified", "additions": 21, "deletions": 34, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7d0db1efdb3aafcfcd1864654ea4d58024b579f2/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0db1efdb3aafcfcd1864654ea4d58024b579f2/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs?ref=7d0db1efdb3aafcfcd1864654ea4d58024b579f2", "patch": "@@ -340,7 +340,7 @@ impl<'tcx> Stack {\n     fn item_invalidated(\n         item: &Item,\n         global: &GlobalStateInner,\n-        dcx: &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n+        dcx: &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n         cause: ItemInvalidationCause,\n     ) -> InterpResult<'tcx> {\n         if !global.tracked_pointer_tags.is_empty() {\n@@ -385,7 +385,7 @@ impl<'tcx> Stack {\n         access: AccessKind,\n         tag: ProvenanceExtra,\n         global: &GlobalStateInner,\n-        dcx: &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n+        dcx: &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n         exposed_tags: &FxHashSet<SbTag>,\n     ) -> InterpResult<'tcx> {\n         // Two main steps: Find granting item, remove incompatible items above.\n@@ -471,7 +471,7 @@ impl<'tcx> Stack {\n         &mut self,\n         tag: ProvenanceExtra,\n         global: &GlobalStateInner,\n-        dcx: &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n+        dcx: &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n         exposed_tags: &FxHashSet<SbTag>,\n     ) -> InterpResult<'tcx> {\n         // Step 1: Make a write access.\n@@ -499,7 +499,7 @@ impl<'tcx> Stack {\n         derived_from: ProvenanceExtra,\n         new: Item,\n         global: &GlobalStateInner,\n-        dcx: &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n+        dcx: &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n         exposed_tags: &FxHashSet<SbTag>,\n     ) -> InterpResult<'tcx> {\n         dcx.start_grant(new.perm());\n@@ -590,14 +590,14 @@ impl<'tcx> Stacks {\n         perm: Permission,\n         tag: SbTag,\n         id: AllocId,\n-        current_span: &mut CurrentSpan<'_, '_, '_>,\n+        machine: &MiriMachine<'_, '_>,\n     ) -> Self {\n         let item = Item::new(tag, perm, false);\n         let stack = Stack::new(item);\n \n         Stacks {\n             stacks: RangeMap::new(size, stack),\n-            history: AllocHistory::new(id, item, current_span),\n+            history: AllocHistory::new(id, item, machine),\n             exposed_tags: FxHashSet::default(),\n             modified_since_last_gc: false,\n         }\n@@ -607,10 +607,10 @@ impl<'tcx> Stacks {\n     fn for_each(\n         &mut self,\n         range: AllocRange,\n-        mut dcx_builder: DiagnosticCxBuilder<'_, '_, '_, 'tcx>,\n+        mut dcx_builder: DiagnosticCxBuilder<'_, '_, 'tcx>,\n         mut f: impl FnMut(\n             &mut Stack,\n-            &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n+            &mut DiagnosticCx<'_, '_, '_, 'tcx>,\n             &mut FxHashSet<SbTag>,\n         ) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n@@ -631,7 +631,7 @@ impl Stacks {\n         size: Size,\n         state: &GlobalState,\n         kind: MemoryKind<MiriMemoryKind>,\n-        mut current_span: CurrentSpan<'_, '_, '_>,\n+        machine: &MiriMachine<'_, '_>,\n     ) -> Self {\n         let mut extra = state.borrow_mut();\n         let (base_tag, perm) = match kind {\n@@ -640,12 +640,11 @@ impl Stacks {\n             // not through a pointer). That is, whenever we directly write to a local, this will pop\n             // everything else off the stack, invalidating all previous pointers,\n             // and in particular, *all* raw pointers.\n-            MemoryKind::Stack =>\n-                (extra.base_ptr_tag(id, current_span.machine()), Permission::Unique),\n+            MemoryKind::Stack => (extra.base_ptr_tag(id, machine), Permission::Unique),\n             // Everything else is shared by default.\n-            _ => (extra.base_ptr_tag(id, current_span.machine()), Permission::SharedReadWrite),\n+            _ => (extra.base_ptr_tag(id, machine), Permission::SharedReadWrite),\n         };\n-        Stacks::new(size, perm, base_tag, id, &mut current_span)\n+        Stacks::new(size, perm, base_tag, id, machine)\n     }\n \n     #[inline(always)]\n@@ -655,8 +654,7 @@ impl Stacks {\n         tag: ProvenanceExtra,\n         range: AllocRange,\n         state: &GlobalState,\n-        mut current_span: CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        machine: &'ecx MiriMachine<'mir, 'tcx>,\n     ) -> InterpResult<'tcx>\n     where\n         'tcx: 'ecx,\n@@ -667,7 +665,7 @@ impl Stacks {\n             Pointer::new(alloc_id, range.start),\n             range.size.bytes()\n         );\n-        let dcx = DiagnosticCxBuilder::read(&mut current_span, threads, tag, range);\n+        let dcx = DiagnosticCxBuilder::read(machine, tag, range);\n         let state = state.borrow();\n         self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n             stack.access(AccessKind::Read, tag, &state, dcx, exposed_tags)\n@@ -681,16 +679,15 @@ impl Stacks {\n         tag: ProvenanceExtra,\n         range: AllocRange,\n         state: &GlobalState,\n-        mut current_span: CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        machine: &'ecx MiriMachine<'mir, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         trace!(\n             \"write access with tag {:?}: {:?}, size {}\",\n             tag,\n             Pointer::new(alloc_id, range.start),\n             range.size.bytes()\n         );\n-        let dcx = DiagnosticCxBuilder::write(&mut current_span, threads, tag, range);\n+        let dcx = DiagnosticCxBuilder::write(machine, tag, range);\n         let state = state.borrow();\n         self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n             stack.access(AccessKind::Write, tag, &state, dcx, exposed_tags)\n@@ -704,11 +701,10 @@ impl Stacks {\n         tag: ProvenanceExtra,\n         range: AllocRange,\n         state: &GlobalState,\n-        mut current_span: CurrentSpan<'ecx, 'mir, 'tcx>,\n-        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+        machine: &'ecx MiriMachine<'mir, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", tag, alloc_id, range.size.bytes());\n-        let dcx = DiagnosticCxBuilder::dealloc(&mut current_span, threads, tag);\n+        let dcx = DiagnosticCxBuilder::dealloc(machine, tag);\n         let state = state.borrow();\n         self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n             stack.dealloc(tag, &state, dcx, exposed_tags)\n@@ -773,7 +769,6 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n             let (_size, _align, alloc_kind) = this.get_alloc_info(alloc_id);\n             match alloc_kind {\n                 AllocKind::LiveData => {\n-                    let current_span = &mut this.machine.current_span();\n                     // This should have alloc_extra data, but `get_alloc_extra` can still fail\n                     // if converting this alloc_id from a global to a local one\n                     // uncovers a non-supported `extern static`.\n@@ -783,12 +778,10 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                         .as_ref()\n                         .expect(\"we should have Stacked Borrows data\")\n                         .borrow_mut();\n-                    let threads = &this.machine.threads;\n                     // Note that we create a *second* `DiagnosticCxBuilder` below for the actual retag.\n                     // FIXME: can this be done cleaner?\n                     let dcx = DiagnosticCxBuilder::retag(\n-                        current_span,\n-                        threads,\n+                        &this.machine,\n                         retag_cause,\n                         new_tag,\n                         orig_tag,\n@@ -895,8 +888,6 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                     .as_ref()\n                     .expect(\"we should have Stacked Borrows data\")\n                     .borrow_mut();\n-                // FIXME: can't share this with the current_span inside log_creation\n-                let mut current_span = this.machine.current_span();\n                 this.visit_freeze_sensitive(place, size, |mut range, frozen| {\n                     // Adjust range.\n                     range.start += base_offset;\n@@ -916,8 +907,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                     let item = Item::new(new_tag, perm, protected);\n                     let global = this.machine.stacked_borrows.as_ref().unwrap().borrow();\n                     let dcx = DiagnosticCxBuilder::retag(\n-                        &mut current_span, // FIXME avoid this `clone`\n-                        &this.machine.threads,\n+                        &this.machine,\n                         retag_cause,\n                         new_tag,\n                         orig_tag,\n@@ -943,11 +933,8 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         let item = Item::new(new_tag, perm, protect.is_some());\n         let range = alloc_range(base_offset, size);\n         let global = machine.stacked_borrows.as_ref().unwrap().borrow();\n-        // FIXME: can't share this with the current_span inside log_creation\n-        let current_span = &mut machine.current_span();\n         let dcx = DiagnosticCxBuilder::retag(\n-            current_span,\n-            &machine.threads,\n+            machine,\n             retag_cause,\n             new_tag,\n             orig_tag,"}]}