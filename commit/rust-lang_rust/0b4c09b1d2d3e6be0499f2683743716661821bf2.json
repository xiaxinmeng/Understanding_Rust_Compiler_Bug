{"sha": "0b4c09b1d2d3e6be0499f2683743716661821bf2", "node_id": "C_kwDOAAsO6NoAKDBiNGMwOWIxZDJkM2U2YmUwNDk5ZjI2ODM3NDM3MTY2NjE4MjFiZjI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-01T16:42:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-01T16:42:12Z"}, "message": "Auto merge of #14941 - Veykril:def-map, r=Veykril\n\nShrink `DefMap`, share crate level items with block def maps", "tree": {"sha": "2936a0726307cbb6ae1a773d40198bdea0fc895d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2936a0726307cbb6ae1a773d40198bdea0fc895d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b4c09b1d2d3e6be0499f2683743716661821bf2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b4c09b1d2d3e6be0499f2683743716661821bf2", "html_url": "https://github.com/rust-lang/rust/commit/0b4c09b1d2d3e6be0499f2683743716661821bf2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b4c09b1d2d3e6be0499f2683743716661821bf2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4458e7f1903ea84fdc74eada865f36186126c712", "url": "https://api.github.com/repos/rust-lang/rust/commits/4458e7f1903ea84fdc74eada865f36186126c712", "html_url": "https://github.com/rust-lang/rust/commit/4458e7f1903ea84fdc74eada865f36186126c712"}, {"sha": "11b937177bbad6afcffebefd7cd81934ae6b0baa", "url": "https://api.github.com/repos/rust-lang/rust/commits/11b937177bbad6afcffebefd7cd81934ae6b0baa", "html_url": "https://github.com/rust-lang/rust/commit/11b937177bbad6afcffebefd7cd81934ae6b0baa"}], "stats": {"total": 525, "additions": 294, "deletions": 231}, "files": [{"sha": "d8ecde71025a0f42ef8b2cf112c766e96a4f1e74", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=0b4c09b1d2d3e6be0499f2683743716661821bf2", "patch": "@@ -1075,7 +1075,7 @@ impl ExprCollector<'_> {\n             match block_id.map(|block_id| (self.db.block_def_map(block_id), block_id)) {\n                 Some((def_map, block_id)) => {\n                     self.body.block_scopes.push(block_id);\n-                    (def_map.module_id(def_map.root()), def_map)\n+                    (def_map.module_id(DefMap::ROOT), def_map)\n                 }\n                 None => (self.expander.module, self.def_map.clone()),\n             };"}, {"sha": "6e77744f21539f6e3d08c9c6149640b37261d14f", "filename": "crates/hir-def/src/body/tests/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Fbody%2Ftests%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Fbody%2Ftests%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Ftests%2Fblock.rs?ref=0b4c09b1d2d3e6be0499f2683743716661821bf2", "patch": "@@ -148,8 +148,8 @@ fn f() {\n }\n     \"#,\n         expect![[r#\"\n-            BlockId(1) in ModuleId { krate: Idx::<CrateData>(0), block: Some(BlockId(0)), local_id: Idx::<ModuleData>(1) }\n-            BlockId(0) in ModuleId { krate: Idx::<CrateData>(0), block: None, local_id: Idx::<ModuleData>(0) }\n+            BlockId(1) in BlockRelativeModuleId { block: Some(BlockId(0)), local_id: Idx::<ModuleData>(1) }\n+            BlockId(0) in BlockRelativeModuleId { block: None, local_id: Idx::<ModuleData>(0) }\n             crate scope\n         \"#]],\n     );"}, {"sha": "bb79e28f2673a0d1e50f9f050d4d70759e1608dc", "filename": "crates/hir-def/src/child_by_source.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fchild_by_source.rs?ref=0b4c09b1d2d3e6be0499f2683743716661821bf2", "patch": "@@ -12,6 +12,7 @@ use crate::{\n     db::DefDatabase,\n     dyn_map::{keys, DynMap},\n     item_scope::ItemScope,\n+    nameres::DefMap,\n     src::{HasChildSource, HasSource},\n     AdtId, AssocItemId, DefWithBodyId, EnumId, EnumVariantId, FieldId, ImplId, Lookup, MacroId,\n     ModuleDefId, ModuleId, TraitId, VariantId,\n@@ -205,7 +206,7 @@ impl ChildBySource for DefWithBodyId {\n         for (_, def_map) in body.blocks(db) {\n             // All block expressions are merged into the same map, because they logically all add\n             // inner items to the containing `DefWithBodyId`.\n-            def_map[def_map.root()].scope.child_by_source_to(db, res, file_id);\n+            def_map[DefMap::ROOT].scope.child_by_source_to(db, res, file_id);\n         }\n     }\n }"}, {"sha": "6d18e3f56cabc63215f52441a953eff1ccffda4a", "filename": "crates/hir-def/src/db.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdb.rs?ref=0b4c09b1d2d3e6be0499f2683743716661821bf2", "patch": "@@ -198,15 +198,14 @@ pub trait DefDatabase: InternDatabase + ExpandDatabase + Upcast<dyn ExpandDataba\n \n     // endregion:attrs\n \n-    #[salsa::invoke(LangItems::crate_lang_items_query)]\n-    fn crate_lang_items(&self, krate: CrateId) -> Arc<LangItems>;\n-\n     #[salsa::invoke(LangItems::lang_item_query)]\n     fn lang_item(&self, start_crate: CrateId, item: LangItem) -> Option<LangItemTarget>;\n \n     #[salsa::invoke(ImportMap::import_map_query)]\n     fn import_map(&self, krate: CrateId) -> Arc<ImportMap>;\n \n+    // region:visibilities\n+\n     #[salsa::invoke(visibility::field_visibilities_query)]\n     fn field_visibilities(&self, var: VariantId) -> Arc<ArenaMap<LocalFieldId, Visibility>>;\n \n@@ -217,8 +216,14 @@ pub trait DefDatabase: InternDatabase + ExpandDatabase + Upcast<dyn ExpandDataba\n     #[salsa::invoke(visibility::const_visibility_query)]\n     fn const_visibility(&self, def: ConstId) -> Visibility;\n \n+    // endregion:visibilities\n+\n+    #[salsa::invoke(LangItems::crate_lang_items_query)]\n+    fn crate_lang_items(&self, krate: CrateId) -> Arc<LangItems>;\n+\n     #[salsa::transparent]\n     fn crate_limits(&self, crate_id: CrateId) -> CrateLimits;\n+\n     #[salsa::transparent]\n     fn recursion_limit(&self, crate_id: CrateId) -> u32;\n "}, {"sha": "e8cc2eab4617ef5ac1d7d10c54abc27c62d8cf79", "filename": "crates/hir-def/src/find_path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Ffind_path.rs?ref=0b4c09b1d2d3e6be0499f2683743716661821bf2", "patch": "@@ -81,7 +81,7 @@ fn find_path_inner(\n     }\n \n     let def_map = from.def_map(db);\n-    let crate_root = def_map.crate_root(db);\n+    let crate_root = def_map.crate_root();\n     // - if the item is a module, jump straight to module search\n     if let ItemInNs::Types(ModuleDefId::ModuleId(module_id)) = item {\n         let mut visited_modules = FxHashSet::default();\n@@ -454,7 +454,7 @@ fn find_local_import_locations(\n         worklist.push(ancestor);\n     }\n \n-    let def_map = def_map.crate_root(db).def_map(db);\n+    let def_map = def_map.crate_root().def_map(db);\n \n     let mut seen: FxHashSet<_> = FxHashSet::default();\n "}, {"sha": "ec150dc0689c2fe8331c39bce0dc75c602d5682f", "filename": "crates/hir-def/src/import_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fimport_map.rs?ref=0b4c09b1d2d3e6be0499f2683743716661821bf2", "patch": "@@ -11,8 +11,8 @@ use rustc_hash::{FxHashSet, FxHasher};\n use triomphe::Arc;\n \n use crate::{\n-    db::DefDatabase, item_scope::ItemInNs, visibility::Visibility, AssocItemId, ModuleDefId,\n-    ModuleId, TraitId,\n+    db::DefDatabase, item_scope::ItemInNs, nameres::DefMap, visibility::Visibility, AssocItemId,\n+    ModuleDefId, ModuleId, TraitId,\n };\n \n type FxIndexMap<K, V> = IndexMap<K, V, BuildHasherDefault<FxHasher>>;\n@@ -183,7 +183,7 @@ fn collect_import_map(db: &dyn DefDatabase, krate: CrateId) -> ImportMap {\n \n     // We look only into modules that are public(ly reexported), starting with the crate root.\n     let empty = ImportPath { segments: vec![] };\n-    let root = def_map.module_id(def_map.root());\n+    let root = def_map.module_id(DefMap::ROOT);\n     let mut worklist = vec![(root, empty)];\n     while let Some((module, mod_path)) = worklist.pop() {\n         let ext_def_map;"}, {"sha": "4a62696df0810a354ce69a47d32919a4da4a80d8", "filename": "crates/hir-def/src/macro_expansion_tests/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmod.rs?ref=0b4c09b1d2d3e6be0499f2683743716661821bf2", "patch": "@@ -35,7 +35,7 @@ use tt::token_id::{Subtree, TokenId};\n use crate::{\n     db::DefDatabase,\n     macro_id_to_def_id,\n-    nameres::{MacroSubNs, ModuleSource},\n+    nameres::{DefMap, MacroSubNs, ModuleSource},\n     resolver::HasResolver,\n     src::HasSource,\n     test_db::TestDB,\n@@ -61,7 +61,7 @@ pub fn identity_when_valid(_attr: TokenStream, item: TokenStream) -> TokenStream\n     let db = TestDB::with_files_extra_proc_macros(ra_fixture, extra_proc_macros);\n     let krate = db.crate_graph().iter().next().unwrap();\n     let def_map = db.crate_def_map(krate);\n-    let local_id = def_map.root();\n+    let local_id = DefMap::ROOT;\n     let module = def_map.module_id(local_id);\n     let resolver = module.resolver(&db);\n     let source = def_map[local_id].definition_source(&db);"}, {"sha": "9b520bc3030f021f0e8d7365590c3199db17e58e", "filename": "crates/hir-def/src/nameres.rs", "status": "modified", "additions": 110, "deletions": 73, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres.rs?ref=0b4c09b1d2d3e6be0499f2683743716661821bf2", "patch": "@@ -94,7 +94,6 @@ use crate::{\n pub struct DefMap {\n     _c: Count<Self>,\n     block: Option<BlockInfo>,\n-    root: LocalModuleId,\n     modules: Arena<ModuleData>,\n     krate: CrateId,\n     /// The prelude module for this crate. This either comes from an import\n@@ -104,20 +103,29 @@ pub struct DefMap {\n     /// but that attribute is nightly and when used in a block, it affects resolution globally\n     /// so we aren't handling this correctly anyways).\n     prelude: Option<ModuleId>,\n-    /// The extern prelude is only populated for non-block DefMaps\n-    extern_prelude: FxHashMap<Name, ModuleId>,\n     /// `macro_use` prelude that contains macros from `#[macro_use]`'d external crates. Note that\n     /// this contains all kinds of macro, not just `macro_rules!` macro.\n     macro_use_prelude: FxHashMap<Name, MacroId>,\n \n+    /// Tracks which custom derives are in scope for an item, to allow resolution of derive helper\n+    /// attributes.\n+    derive_helpers_in_scope: FxHashMap<AstId<ast::Item>, Vec<(Name, MacroId, MacroCallId)>>,\n+\n+    diagnostics: Vec<DefDiagnostic>,\n+\n+    data: Arc<DefMapCrateData>,\n+}\n+\n+/// Data that belongs to a crate which is shared between a crate's def map and all its block def maps.\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+struct DefMapCrateData {\n+    extern_prelude: FxHashMap<Name, ModuleId>,\n+\n     /// Side table for resolving derive helpers.\n     exported_derives: FxHashMap<MacroDefId, Box<[Name]>>,\n     fn_proc_macro_mapping: FxHashMap<FunctionId, ProcMacroId>,\n     /// The error that occurred when failing to load the proc-macro dll.\n     proc_macro_loading_error: Option<Box<str>>,\n-    /// Tracks which custom derives are in scope for an item, to allow resolution of derive helper\n-    /// attributes.\n-    derive_helpers_in_scope: FxHashMap<AstId<ast::Item>, Vec<(Name, MacroId, MacroCallId)>>,\n \n     /// Custom attributes registered with `#![register_attr]`.\n     registered_attrs: Vec<SmolStr>,\n@@ -132,7 +140,31 @@ pub struct DefMap {\n \n     edition: Edition,\n     recursion_limit: Option<u32>,\n-    diagnostics: Vec<DefDiagnostic>,\n+}\n+\n+impl DefMapCrateData {\n+    fn shrink_to_fit(&mut self) {\n+        let Self {\n+            extern_prelude,\n+            exported_derives,\n+            fn_proc_macro_mapping,\n+            registered_attrs,\n+            registered_tools,\n+            unstable_features,\n+            proc_macro_loading_error: _,\n+            rustc_coherence_is_core: _,\n+            no_core: _,\n+            no_std: _,\n+            edition: _,\n+            recursion_limit: _,\n+        } = self;\n+        extern_prelude.shrink_to_fit();\n+        exported_derives.shrink_to_fit();\n+        fn_proc_macro_mapping.shrink_to_fit();\n+        registered_attrs.shrink_to_fit();\n+        registered_tools.shrink_to_fit();\n+        unstable_features.shrink_to_fit();\n+    }\n }\n \n /// For `DefMap`s computed for a block expression, this stores its location in the parent map.\n@@ -141,7 +173,23 @@ struct BlockInfo {\n     /// The `BlockId` this `DefMap` was created from.\n     block: BlockId,\n     /// The containing module.\n-    parent: ModuleId,\n+    parent: BlockRelativeModuleId,\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n+struct BlockRelativeModuleId {\n+    block: Option<BlockId>,\n+    local_id: LocalModuleId,\n+}\n+\n+impl BlockRelativeModuleId {\n+    fn def_map(self, db: &dyn DefDatabase, krate: CrateId) -> Arc<DefMap> {\n+        self.into_module(krate).def_map(db)\n+    }\n+\n+    fn into_module(self, krate: CrateId) -> ModuleId {\n+        ModuleId { krate, block: self.block, local_id: self.local_id }\n+    }\n }\n \n impl std::ops::Index<LocalModuleId> for DefMap {\n@@ -231,6 +279,8 @@ pub struct ModuleData {\n }\n \n impl DefMap {\n+    pub const ROOT: LocalModuleId = LocalModuleId::from_raw(la_arena::RawIdx::from_u32(0));\n+\n     pub(crate) fn crate_def_map_query(db: &dyn DefDatabase, krate: CrateId) -> Arc<DefMap> {\n         let _p = profile::span(\"crate_def_map_query\").detail(|| {\n             db.crate_graph()[krate].display_name.as_deref().unwrap_or_default().to_string()\n@@ -265,8 +315,15 @@ impl DefMap {\n         let module_data =\n             ModuleData::new(ModuleOrigin::BlockExpr { block: block.ast_id }, visibility);\n \n-        let mut def_map = DefMap::empty(krate, parent_map.edition, module_data);\n-        def_map.block = Some(BlockInfo { block: block_id, parent: block.module });\n+        let mut def_map = DefMap::empty(krate, parent_map.data.edition, module_data);\n+        def_map.data = parent_map.data.clone();\n+        def_map.block = Some(BlockInfo {\n+            block: block_id,\n+            parent: BlockRelativeModuleId {\n+                block: block.module.block,\n+                local_id: block.module.local_id,\n+            },\n+        });\n \n         let def_map = collector::collect_defs(db, def_map, tree_id);\n         Arc::new(def_map)\n@@ -275,29 +332,31 @@ impl DefMap {\n     fn empty(krate: CrateId, edition: Edition, module_data: ModuleData) -> DefMap {\n         let mut modules: Arena<ModuleData> = Arena::default();\n         let root = modules.alloc(module_data);\n+        assert_eq!(root, Self::ROOT);\n \n         DefMap {\n             _c: Count::new(),\n             block: None,\n+            modules,\n             krate,\n-            edition,\n-            recursion_limit: None,\n-            extern_prelude: FxHashMap::default(),\n+            prelude: None,\n             macro_use_prelude: FxHashMap::default(),\n-            exported_derives: FxHashMap::default(),\n-            fn_proc_macro_mapping: FxHashMap::default(),\n-            proc_macro_loading_error: None,\n             derive_helpers_in_scope: FxHashMap::default(),\n-            prelude: None,\n-            root,\n-            modules,\n-            registered_attrs: Vec::new(),\n-            registered_tools: Vec::new(),\n-            unstable_features: FxHashSet::default(),\n             diagnostics: Vec::new(),\n-            rustc_coherence_is_core: false,\n-            no_core: false,\n-            no_std: false,\n+            data: Arc::new(DefMapCrateData {\n+                extern_prelude: FxHashMap::default(),\n+                exported_derives: FxHashMap::default(),\n+                fn_proc_macro_mapping: FxHashMap::default(),\n+                proc_macro_loading_error: None,\n+                registered_attrs: Vec::new(),\n+                registered_tools: Vec::new(),\n+                unstable_features: FxHashSet::default(),\n+                rustc_coherence_is_core: false,\n+                no_core: false,\n+                no_std: false,\n+                edition,\n+                recursion_limit: None,\n+            }),\n         }\n     }\n \n@@ -320,35 +379,31 @@ impl DefMap {\n     }\n \n     pub fn registered_tools(&self) -> &[SmolStr] {\n-        &self.registered_tools\n+        &self.data.registered_tools\n     }\n \n     pub fn registered_attrs(&self) -> &[SmolStr] {\n-        &self.registered_attrs\n+        &self.data.registered_attrs\n     }\n \n     pub fn is_unstable_feature_enabled(&self, feature: &str) -> bool {\n-        self.unstable_features.contains(feature)\n+        self.data.unstable_features.contains(feature)\n     }\n \n     pub fn is_rustc_coherence_is_core(&self) -> bool {\n-        self.rustc_coherence_is_core\n+        self.data.rustc_coherence_is_core\n     }\n \n     pub fn is_no_std(&self) -> bool {\n-        self.no_std || self.no_core\n-    }\n-\n-    pub fn root(&self) -> LocalModuleId {\n-        self.root\n+        self.data.no_std || self.data.no_core\n     }\n \n     pub fn fn_as_proc_macro(&self, id: FunctionId) -> Option<ProcMacroId> {\n-        self.fn_proc_macro_mapping.get(&id).copied()\n+        self.data.fn_proc_macro_mapping.get(&id).copied()\n     }\n \n     pub fn proc_macro_loading_error(&self) -> Option<&str> {\n-        self.proc_macro_loading_error.as_deref()\n+        self.data.proc_macro_loading_error.as_deref()\n     }\n \n     pub fn krate(&self) -> CrateId {\n@@ -364,7 +419,7 @@ impl DefMap {\n     }\n \n     pub(crate) fn extern_prelude(&self) -> impl Iterator<Item = (&Name, ModuleId)> + '_ {\n-        self.extern_prelude.iter().map(|(name, def)| (name, *def))\n+        self.data.extern_prelude.iter().map(|(name, def)| (name, *def))\n     }\n \n     pub(crate) fn macro_use_prelude(&self) -> impl Iterator<Item = (&Name, MacroId)> + '_ {\n@@ -376,15 +431,8 @@ impl DefMap {\n         ModuleId { krate: self.krate, local_id, block }\n     }\n \n-    pub(crate) fn crate_root(&self, db: &dyn DefDatabase) -> ModuleId {\n-        self.with_ancestor_maps(db, self.root, &mut |def_map, _module| {\n-            if def_map.block.is_none() {\n-                Some(def_map.module_id(def_map.root))\n-            } else {\n-                None\n-            }\n-        })\n-        .expect(\"DefMap chain without root\")\n+    pub(crate) fn crate_root(&self) -> ModuleId {\n+        ModuleId { krate: self.krate, block: None, local_id: DefMap::ROOT }\n     }\n \n     pub(crate) fn resolve_path(\n@@ -439,7 +487,7 @@ impl DefMap {\n         }\n         let mut block = self.block;\n         while let Some(block_info) = block {\n-            let parent = block_info.parent.def_map(db);\n+            let parent = block_info.parent.def_map(db, self.krate);\n             if let Some(it) = f(&parent, block_info.parent.local_id) {\n                 return Some(it);\n             }\n@@ -452,15 +500,22 @@ impl DefMap {\n     /// If this `DefMap` is for a block expression, returns the module containing the block (which\n     /// might again be a block, or a module inside a block).\n     pub fn parent(&self) -> Option<ModuleId> {\n-        Some(self.block?.parent)\n+        let BlockRelativeModuleId { block, local_id } = self.block?.parent;\n+        Some(ModuleId { krate: self.krate, block, local_id })\n     }\n \n     /// Returns the module containing `local_mod`, either the parent `mod`, or the module (or block) containing\n     /// the block, if `self` corresponds to a block expression.\n     pub fn containing_module(&self, local_mod: LocalModuleId) -> Option<ModuleId> {\n         match self[local_mod].parent {\n             Some(parent) => Some(self.module_id(parent)),\n-            None => self.block.map(|block| block.parent),\n+            None => {\n+                self.block.map(\n+                    |BlockInfo { parent: BlockRelativeModuleId { block, local_id }, .. }| {\n+                        ModuleId { krate: self.krate, block, local_id }\n+                    },\n+                )\n+            }\n         }\n     }\n \n@@ -471,12 +526,12 @@ impl DefMap {\n         let mut arc;\n         let mut current_map = self;\n         while let Some(block) = current_map.block {\n-            go(&mut buf, db, current_map, \"block scope\", current_map.root);\n+            go(&mut buf, db, current_map, \"block scope\", Self::ROOT);\n             buf.push('\\n');\n-            arc = block.parent.def_map(db);\n+            arc = block.parent.def_map(db, self.krate);\n             current_map = &arc;\n         }\n-        go(&mut buf, db, current_map, \"crate\", current_map.root);\n+        go(&mut buf, db, current_map, \"crate\", Self::ROOT);\n         return buf;\n \n         fn go(\n@@ -506,7 +561,7 @@ impl DefMap {\n         let mut current_map = self;\n         while let Some(block) = current_map.block {\n             format_to!(buf, \"{:?} in {:?}\\n\", block.block, block.parent);\n-            arc = block.parent.def_map(db);\n+            arc = block.parent.def_map(db, self.krate);\n             current_map = &arc;\n         }\n \n@@ -518,38 +573,20 @@ impl DefMap {\n         // Exhaustive match to require handling new fields.\n         let Self {\n             _c: _,\n-            exported_derives,\n-            extern_prelude,\n             macro_use_prelude,\n             diagnostics,\n             modules,\n-            registered_attrs,\n-            registered_tools,\n-            fn_proc_macro_mapping,\n             derive_helpers_in_scope,\n-            unstable_features,\n-            proc_macro_loading_error: _,\n             block: _,\n-            edition: _,\n-            recursion_limit: _,\n             krate: _,\n             prelude: _,\n-            root: _,\n-            rustc_coherence_is_core: _,\n-            no_core: _,\n-            no_std: _,\n+            data: _,\n         } = self;\n \n-        extern_prelude.shrink_to_fit();\n         macro_use_prelude.shrink_to_fit();\n-        exported_derives.shrink_to_fit();\n         diagnostics.shrink_to_fit();\n         modules.shrink_to_fit();\n-        registered_attrs.shrink_to_fit();\n-        registered_tools.shrink_to_fit();\n-        fn_proc_macro_mapping.shrink_to_fit();\n         derive_helpers_in_scope.shrink_to_fit();\n-        unstable_features.shrink_to_fit();\n         for (_, module) in modules.iter_mut() {\n             module.children.shrink_to_fit();\n             module.scope.shrink_to_fit();\n@@ -562,7 +599,7 @@ impl DefMap {\n     }\n \n     pub fn recursion_limit(&self) -> Option<u32> {\n-        self.recursion_limit\n+        self.data.recursion_limit\n     }\n }\n "}, {"sha": "a7abf445918aa4147965f1039b7a873f7823ac94", "filename": "crates/hir-def/src/nameres/attr_resolution.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs?ref=0b4c09b1d2d3e6be0499f2683743716661821bf2", "patch": "@@ -78,15 +78,15 @@ impl DefMap {\n             let name = name.to_smol_str();\n             let pred = |n: &_| *n == name;\n \n-            let registered = self.registered_tools.iter().map(SmolStr::as_str);\n+            let registered = self.data.registered_tools.iter().map(SmolStr::as_str);\n             let is_tool = TOOL_MODULES.iter().copied().chain(registered).any(pred);\n             // FIXME: tool modules can be shadowed by actual modules\n             if is_tool {\n                 return true;\n             }\n \n             if segments.len() == 1 {\n-                let mut registered = self.registered_attrs.iter().map(SmolStr::as_str);\n+                let mut registered = self.data.registered_attrs.iter().map(SmolStr::as_str);\n                 let is_inert = find_builtin_attr_idx(&name).is_some() || registered.any(pred);\n                 return is_inert;\n             }"}, {"sha": "06542b4b1e99960c472fd7e053a50f1332af35d4", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 80, "deletions": 77, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=0b4c09b1d2d3e6be0499f2683743716661821bf2", "patch": "@@ -5,7 +5,7 @@\n \n use std::{iter, mem};\n \n-use base_db::{CrateId, Edition, FileId};\n+use base_db::{CrateId, Dependency, Edition, FileId};\n use cfg::{CfgExpr, CfgOptions};\n use either::Either;\n use hir_expand::{\n@@ -62,22 +62,16 @@ static GLOB_RECURSION_LIMIT: Limit = Limit::new(100);\n static EXPANSION_DEPTH_LIMIT: Limit = Limit::new(128);\n static FIXED_POINT_LIMIT: Limit = Limit::new(8192);\n \n-pub(super) fn collect_defs(db: &dyn DefDatabase, mut def_map: DefMap, tree_id: TreeId) -> DefMap {\n+pub(super) fn collect_defs(db: &dyn DefDatabase, def_map: DefMap, tree_id: TreeId) -> DefMap {\n     let crate_graph = db.crate_graph();\n \n     let mut deps = FxHashMap::default();\n     // populate external prelude and dependency list\n     let krate = &crate_graph[def_map.krate];\n     for dep in &krate.dependencies {\n         tracing::debug!(\"crate dep {:?} -> {:?}\", dep.name, dep.crate_id);\n-        let dep_def_map = db.crate_def_map(dep.crate_id);\n-        let dep_root = dep_def_map.module_id(dep_def_map.root);\n \n-        deps.insert(dep.as_name(), dep_root);\n-\n-        if dep.is_prelude() && !tree_id.is_block() {\n-            def_map.extern_prelude.insert(dep.as_name(), dep_root);\n-        }\n+        deps.insert(dep.as_name(), dep.clone());\n     }\n \n     let cfg_options = &krate.cfg_options;\n@@ -86,7 +80,7 @@ pub(super) fn collect_defs(db: &dyn DefDatabase, mut def_map: DefMap, tree_id: T\n     let proc_macros = if is_proc_macro {\n         match db.proc_macros().get(&def_map.krate) {\n             Some(Ok(proc_macros)) => {\n-                proc_macros\n+                Ok(proc_macros\n                     .iter()\n                     .enumerate()\n                     .map(|(idx, it)| {\n@@ -95,20 +89,13 @@ pub(super) fn collect_defs(db: &dyn DefDatabase, mut def_map: DefMap, tree_id: T\n                             tt::Ident { text: it.name.clone(), span: tt::TokenId::unspecified() };\n                         (name.as_name(), ProcMacroExpander::new(base_db::ProcMacroId(idx as u32)))\n                     })\n-                    .collect()\n-            }\n-            Some(Err(e)) => {\n-                def_map.proc_macro_loading_error = Some(e.clone().into_boxed_str());\n-                Vec::new()\n-            }\n-            None => {\n-                def_map.proc_macro_loading_error =\n-                    Some(\"No proc-macros present for crate\".to_owned().into_boxed_str());\n-                Vec::new()\n+                    .collect())\n             }\n+            Some(Err(e)) => Err(e.clone().into_boxed_str()),\n+            None => Err(\"No proc-macros present for crate\".to_owned().into_boxed_str()),\n         }\n     } else {\n-        vec![]\n+        Ok(vec![])\n     };\n \n     let mut collector = DefCollector {\n@@ -252,7 +239,7 @@ enum MacroDirectiveKind {\n struct DefCollector<'a> {\n     db: &'a dyn DefDatabase,\n     def_map: DefMap,\n-    deps: FxHashMap<Name, ModuleId>,\n+    deps: FxHashMap<Name, Dependency>,\n     glob_imports: FxHashMap<LocalModuleId, Vec<(LocalModuleId, Visibility)>>,\n     unresolved_imports: Vec<ImportDirective>,\n     indeterminate_imports: Vec<ImportDirective>,\n@@ -263,7 +250,7 @@ struct DefCollector<'a> {\n     /// built by the build system, and is the list of proc. macros we can actually expand. It is\n     /// empty when proc. macro support is disabled (in which case we still do name resolution for\n     /// them).\n-    proc_macros: Vec<(Name, ProcMacroExpander)>,\n+    proc_macros: Result<Vec<(Name, ProcMacroExpander)>, Box<str>>,\n     is_proc_macro: bool,\n     from_glob_import: PerNsGlobImports,\n     /// If we fail to resolve an attribute on a `ModItem`, we fall back to ignoring the attribute.\n@@ -287,9 +274,23 @@ impl DefCollector<'_> {\n \n         let file_id = self.db.crate_graph()[self.def_map.krate].root_file_id;\n         let item_tree = self.db.file_item_tree(file_id.into());\n-        let module_id = self.def_map.root;\n+        let module_id = DefMap::ROOT;\n \n         let attrs = item_tree.top_level_attrs(self.db, self.def_map.krate);\n+        let crate_data = Arc::get_mut(&mut self.def_map.data).unwrap();\n+\n+        if let Err(e) = &self.proc_macros {\n+            crate_data.proc_macro_loading_error = Some(e.clone());\n+        }\n+\n+        for (name, dep) in &self.deps {\n+            if dep.is_prelude() {\n+                crate_data.extern_prelude.insert(\n+                    name.clone(),\n+                    ModuleId { krate: dep.crate_id, block: None, local_id: DefMap::ROOT },\n+                );\n+            }\n+        }\n \n         // Process other crate-level attributes.\n         for attr in &*attrs {\n@@ -306,7 +307,7 @@ impl DefCollector<'_> {\n             if *attr_name == hir_expand::name![recursion_limit] {\n                 if let Some(limit) = attr.string_value() {\n                     if let Ok(limit) = limit.parse() {\n-                        self.def_map.recursion_limit = Some(limit);\n+                        crate_data.recursion_limit = Some(limit);\n                     }\n                 }\n                 continue;\n@@ -320,17 +321,17 @@ impl DefCollector<'_> {\n             }\n \n             if *attr_name == hir_expand::name![no_core] {\n-                self.def_map.no_core = true;\n+                crate_data.no_core = true;\n                 continue;\n             }\n \n             if *attr_name == hir_expand::name![no_std] {\n-                self.def_map.no_std = true;\n+                crate_data.no_std = true;\n                 continue;\n             }\n \n             if attr_name.as_text().as_deref() == Some(\"rustc_coherence_is_core\") {\n-                self.def_map.rustc_coherence_is_core = true;\n+                crate_data.rustc_coherence_is_core = true;\n                 continue;\n             }\n \n@@ -344,7 +345,7 @@ impl DefCollector<'_> {\n                         [name] => Some(name.to_smol_str()),\n                         _ => None,\n                     });\n-                self.def_map.unstable_features.extend(features);\n+                crate_data.unstable_features.extend(features);\n             }\n \n             let attr_is_register_like = *attr_name == hir_expand::name![register_attr]\n@@ -359,14 +360,15 @@ impl DefCollector<'_> {\n             };\n \n             if *attr_name == hir_expand::name![register_attr] {\n-                self.def_map.registered_attrs.push(registered_name.to_smol_str());\n+                crate_data.registered_attrs.push(registered_name.to_smol_str());\n                 cov_mark::hit!(register_attr);\n             } else {\n-                self.def_map.registered_tools.push(registered_name.to_smol_str());\n+                crate_data.registered_tools.push(registered_name.to_smol_str());\n                 cov_mark::hit!(register_tool);\n             }\n         }\n \n+        crate_data.shrink_to_fit();\n         self.inject_prelude();\n \n         ModCollector {\n@@ -382,7 +384,7 @@ impl DefCollector<'_> {\n \n     fn seed_with_inner(&mut self, tree_id: TreeId) {\n         let item_tree = tree_id.item_tree(self.db);\n-        let module_id = self.def_map.root;\n+        let module_id = DefMap::ROOT;\n \n         let is_cfg_enabled = item_tree\n             .top_level_attrs(self.db, self.def_map.krate)\n@@ -464,7 +466,7 @@ impl DefCollector<'_> {\n             // Additionally, while the proc macro entry points must be `pub`, they are not publicly\n             // exported in type/value namespace. This function reduces the visibility of all items\n             // in the crate root that aren't proc macros.\n-            let root = self.def_map.root;\n+            let root = DefMap::ROOT;\n             let module_id = self.def_map.module_id(root);\n             let root = &mut self.def_map.modules[root];\n             root.scope.censor_non_proc_macros(module_id);\n@@ -530,12 +532,12 @@ impl DefCollector<'_> {\n     fn inject_prelude(&mut self) {\n         // See compiler/rustc_builtin_macros/src/standard_library_imports.rs\n \n-        if self.def_map.no_core {\n+        if self.def_map.data.no_core {\n             // libcore does not get a prelude.\n             return;\n         }\n \n-        let krate = if self.def_map.no_std {\n+        let krate = if self.def_map.data.no_std {\n             name![core]\n         } else {\n             let std = name![std];\n@@ -548,25 +550,20 @@ impl DefCollector<'_> {\n             }\n         };\n \n-        let edition = match self.def_map.edition {\n+        let edition = match self.def_map.data.edition {\n             Edition::Edition2015 => name![rust_2015],\n             Edition::Edition2018 => name![rust_2018],\n             Edition::Edition2021 => name![rust_2021],\n         };\n \n-        let path_kind = match self.def_map.edition {\n+        let path_kind = match self.def_map.data.edition {\n             Edition::Edition2015 => PathKind::Plain,\n             _ => PathKind::Abs,\n         };\n         let path = ModPath::from_segments(path_kind, [krate, name![prelude], edition]);\n \n-        let (per_ns, _) = self.def_map.resolve_path(\n-            self.db,\n-            self.def_map.root,\n-            &path,\n-            BuiltinShadowMode::Other,\n-            None,\n-        );\n+        let (per_ns, _) =\n+            self.def_map.resolve_path(self.db, DefMap::ROOT, &path, BuiltinShadowMode::Other, None);\n \n         match per_ns.types {\n             Some((ModuleDefId::ModuleId(m), _)) => {\n@@ -603,23 +600,29 @@ impl DefCollector<'_> {\n         def: ProcMacroDef,\n         id: ItemTreeId<item_tree::Function>,\n         fn_id: FunctionId,\n-        module_id: ModuleId,\n     ) {\n+        if self.def_map.block.is_some() {\n+            return;\n+        }\n+        let crate_root = self.def_map.module_id(DefMap::ROOT);\n+\n         let kind = def.kind.to_basedb_kind();\n-        let (expander, kind) = match self.proc_macros.iter().find(|(n, _)| n == &def.name) {\n-            Some(&(_, expander)) => (expander, kind),\n-            None => (ProcMacroExpander::dummy(), kind),\n-        };\n+        let (expander, kind) =\n+            match self.proc_macros.as_ref().map(|it| it.iter().find(|(n, _)| n == &def.name)) {\n+                Ok(Some(&(_, expander))) => (expander, kind),\n+                _ => (ProcMacroExpander::dummy(), kind),\n+            };\n \n         let proc_macro_id =\n-            ProcMacroLoc { container: module_id, id, expander, kind }.intern(self.db);\n+            ProcMacroLoc { container: crate_root, id, expander, kind }.intern(self.db);\n         self.define_proc_macro(def.name.clone(), proc_macro_id);\n+        let crate_data = Arc::get_mut(&mut self.def_map.data).unwrap();\n         if let ProcMacroKind::CustomDerive { helpers } = def.kind {\n-            self.def_map\n+            crate_data\n                 .exported_derives\n                 .insert(macro_id_to_def_id(self.db, proc_macro_id.into()), helpers);\n         }\n-        self.def_map.fn_proc_macro_mapping.insert(fn_id, proc_macro_id);\n+        crate_data.fn_proc_macro_mapping.insert(fn_id, proc_macro_id);\n     }\n \n     /// Define a macro with `macro_rules`.\n@@ -661,7 +664,7 @@ impl DefCollector<'_> {\n         // In Rust, `#[macro_export]` macros are unconditionally visible at the\n         // crate root, even if the parent modules is **not** visible.\n         if export {\n-            let module_id = self.def_map.root;\n+            let module_id = DefMap::ROOT;\n             self.def_map.modules[module_id].scope.declare(macro_.into());\n             self.update(\n                 module_id,\n@@ -712,7 +715,7 @@ impl DefCollector<'_> {\n     /// A proc macro is similar to normal macro scope, but it would not visible in legacy textual scoped.\n     /// And unconditionally exported.\n     fn define_proc_macro(&mut self, name: Name, macro_: ProcMacroId) {\n-        let module_id = self.def_map.root;\n+        let module_id = DefMap::ROOT;\n         self.def_map.modules[module_id].scope.declare(macro_.into());\n         self.update(\n             module_id,\n@@ -732,7 +735,7 @@ impl DefCollector<'_> {\n         let def_map = self.db.crate_def_map(krate);\n         // `#[macro_use]` brings macros into macro_use prelude. Yes, even non-`macro_rules!`\n         // macros.\n-        let root_scope = &def_map[def_map.root].scope;\n+        let root_scope = &def_map[DefMap::ROOT].scope;\n         if let Some(names) = names {\n             for name in names {\n                 // FIXME: Report diagnostic on 404.\n@@ -778,7 +781,7 @@ impl DefCollector<'_> {\n     fn resolve_import(&self, module_id: LocalModuleId, import: &Import) -> PartialResolvedImport {\n         let _p = profile::span(\"resolve_import\")\n             .detail(|| format!(\"{}\", import.path.display(self.db.upcast())));\n-        tracing::debug!(\"resolving import: {:?} ({:?})\", import, self.def_map.edition);\n+        tracing::debug!(\"resolving import: {:?} ({:?})\", import, self.def_map.data.edition);\n         if import.is_extern_crate {\n             let name = import\n                 .path\n@@ -831,16 +834,13 @@ impl DefCollector<'_> {\n     fn resolve_extern_crate(&self, name: &Name) -> Option<ModuleId> {\n         if *name == name!(self) {\n             cov_mark::hit!(extern_crate_self_as);\n-            let root = match self.def_map.block {\n-                Some(_) => {\n-                    let def_map = self.def_map.crate_root(self.db).def_map(self.db);\n-                    def_map.module_id(def_map.root())\n-                }\n-                None => self.def_map.module_id(self.def_map.root()),\n-            };\n-            Some(root)\n+            Some(self.def_map.crate_root())\n         } else {\n-            self.deps.get(name).copied()\n+            self.deps.get(name).map(|dep| ModuleId {\n+                krate: dep.crate_id,\n+                block: None,\n+                local_id: DefMap::ROOT,\n+            })\n         }\n     }\n \n@@ -879,11 +879,14 @@ impl DefCollector<'_> {\n                 // extern crates in the crate root are special-cased to insert entries into the extern prelude: rust-lang/rust#54658\n                 if import.is_extern_crate\n                     && self.def_map.block.is_none()\n-                    && module_id == self.def_map.root\n+                    && module_id == DefMap::ROOT\n                 {\n                     if let (Some(ModuleDefId::ModuleId(def)), Some(name)) = (def.take_types(), name)\n                     {\n-                        self.def_map.extern_prelude.insert(name.clone(), def);\n+                        Arc::get_mut(&mut self.def_map.data)\n+                            .unwrap()\n+                            .extern_prelude\n+                            .insert(name.clone(), def);\n                     }\n                 }\n \n@@ -1158,7 +1161,7 @@ impl DefCollector<'_> {\n                         // Record its helper attributes.\n                         if def_id.krate != self.def_map.krate {\n                             let def_map = self.db.crate_def_map(def_id.krate);\n-                            if let Some(helpers) = def_map.exported_derives.get(&def_id) {\n+                            if let Some(helpers) = def_map.data.exported_derives.get(&def_id) {\n                                 self.def_map\n                                     .derive_helpers_in_scope\n                                     .entry(ast_id.ast_id.map(|it| it.upcast()))\n@@ -1525,7 +1528,7 @@ impl ModCollector<'_, '_> {\n \n     fn collect(&mut self, items: &[ModItem], container: ItemContainerId) {\n         let krate = self.def_collector.def_map.krate;\n-        let is_crate_root = self.module_id == self.def_collector.def_map.root;\n+        let is_crate_root = self.module_id == DefMap::ROOT;\n \n         // Note: don't assert that inserted value is fresh: it's simply not true\n         // for macros.\n@@ -1641,14 +1644,12 @@ impl ModCollector<'_, '_> {\n                         FunctionLoc { container, id: ItemTreeId::new(self.tree_id, id) }.intern(db);\n \n                     let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n-                    if self.def_collector.is_proc_macro && self.module_id == def_map.root {\n+                    if self.def_collector.is_proc_macro && self.module_id == DefMap::ROOT {\n                         if let Some(proc_macro) = attrs.parse_proc_macro_decl(&it.name) {\n-                            let crate_root = def_map.module_id(def_map.root);\n                             self.def_collector.export_proc_macro(\n                                 proc_macro,\n                                 ItemTreeId::new(self.tree_id, id),\n                                 fn_id,\n-                                crate_root,\n                             );\n                         }\n                     }\n@@ -2169,10 +2170,12 @@ impl ModCollector<'_, '_> {\n             &self.item_tree[mac.visibility],\n         );\n         if let Some(helpers) = helpers_opt {\n-            self.def_collector\n-                .def_map\n-                .exported_derives\n-                .insert(macro_id_to_def_id(self.def_collector.db, macro_id.into()), helpers);\n+            if self.def_collector.def_map.block.is_none() {\n+                Arc::get_mut(&mut self.def_collector.def_map.data)\n+                    .unwrap()\n+                    .exported_derives\n+                    .insert(macro_id_to_def_id(self.def_collector.db, macro_id.into()), helpers);\n+            }\n         }\n     }\n \n@@ -2280,7 +2283,7 @@ mod tests {\n             unresolved_macros: Vec::new(),\n             mod_dirs: FxHashMap::default(),\n             cfg_options: &CfgOptions::default(),\n-            proc_macros: Default::default(),\n+            proc_macros: Ok(vec![]),\n             from_glob_import: Default::default(),\n             skip_attrs: Default::default(),\n             is_proc_macro: false,"}, {"sha": "5f6163175a7268120097fcf81ba870b4f217d4a9", "filename": "crates/hir-def/src/nameres/path_resolution.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=0b4c09b1d2d3e6be0499f2683743716661821bf2", "patch": "@@ -20,7 +20,7 @@ use crate::{\n     path::{ModPath, PathKind},\n     per_ns::PerNs,\n     visibility::{RawVisibility, Visibility},\n-    AdtId, CrateId, EnumVariantId, LocalModuleId, ModuleDefId, ModuleId,\n+    AdtId, CrateId, EnumVariantId, LocalModuleId, ModuleDefId,\n };\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n@@ -74,17 +74,6 @@ impl PerNs {\n }\n \n impl DefMap {\n-    pub(super) fn resolve_name_in_extern_prelude(\n-        &self,\n-        db: &dyn DefDatabase,\n-        name: &Name,\n-    ) -> Option<ModuleId> {\n-        match self.block {\n-            Some(_) => self.crate_root(db).def_map(db).extern_prelude.get(name).copied(),\n-            None => self.extern_prelude.get(name).copied(),\n-        }\n-    }\n-\n     pub(crate) fn resolve_visibility(\n         &self,\n         db: &dyn DefDatabase,\n@@ -121,7 +110,7 @@ impl DefMap {\n             // ...unless we're resolving visibility for an associated item in an impl.\n             if self.block_id() != m.block && !within_impl {\n                 cov_mark::hit!(adjust_vis_in_block_def_map);\n-                vis = Visibility::Module(self.module_id(self.root()));\n+                vis = Visibility::Module(self.module_id(Self::ROOT));\n                 tracing::debug!(\"visibility {:?} points outside DefMap, adjusting to {:?}\", m, vis);\n             }\n         }\n@@ -173,7 +162,7 @@ impl DefMap {\n             match &current_map.block {\n                 Some(block) => {\n                     original_module = block.parent.local_id;\n-                    arc = block.parent.def_map(db);\n+                    arc = block.parent.def_map(db, current_map.krate);\n                     current_map = &*arc;\n                 }\n                 None => return result,\n@@ -204,21 +193,21 @@ impl DefMap {\n             PathKind::DollarCrate(krate) => {\n                 if krate == self.krate {\n                     cov_mark::hit!(macro_dollar_crate_self);\n-                    PerNs::types(self.crate_root(db).into(), Visibility::Public)\n+                    PerNs::types(self.crate_root().into(), Visibility::Public)\n                 } else {\n                     let def_map = db.crate_def_map(krate);\n-                    let module = def_map.module_id(def_map.root);\n+                    let module = def_map.module_id(Self::ROOT);\n                     cov_mark::hit!(macro_dollar_crate_other);\n                     PerNs::types(module.into(), Visibility::Public)\n                 }\n             }\n-            PathKind::Crate => PerNs::types(self.crate_root(db).into(), Visibility::Public),\n+            PathKind::Crate => PerNs::types(self.crate_root().into(), Visibility::Public),\n             // plain import or absolute path in 2015: crate-relative with\n             // fallback to extern prelude (with the simplification in\n             // rust-lang/rust#57745)\n             // FIXME there must be a nicer way to write this condition\n             PathKind::Plain | PathKind::Abs\n-                if self.edition == Edition::Edition2015\n+                if self.data.edition == Edition::Edition2015\n                     && (path.kind == PathKind::Abs || mode == ResolveMode::Import) =>\n             {\n                 let (_, segment) = match segments.next() {\n@@ -268,14 +257,17 @@ impl DefMap {\n                                     path.display(db.upcast()),\n                                     new_path.display(db.upcast())\n                                 );\n-                                return block.parent.def_map(db).resolve_path_fp_with_macro(\n-                                    db,\n-                                    mode,\n-                                    block.parent.local_id,\n-                                    &new_path,\n-                                    shadow,\n-                                    expected_macro_subns,\n-                                );\n+                                return block\n+                                    .parent\n+                                    .def_map(db, self.krate)\n+                                    .resolve_path_fp_with_macro(\n+                                        db,\n+                                        mode,\n+                                        block.parent.local_id,\n+                                        &new_path,\n+                                        shadow,\n+                                        expected_macro_subns,\n+                                    );\n                             }\n                             None => {\n                                 tracing::debug!(\"super path in root module\");\n@@ -301,7 +293,7 @@ impl DefMap {\n                     Some((_, segment)) => segment,\n                     None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n                 };\n-                if let Some(&def) = self.extern_prelude.get(segment) {\n+                if let Some(&def) = self.data.extern_prelude.get(segment) {\n                     tracing::debug!(\"absolute path {:?} resolved to crate {:?}\", path, def);\n                     PerNs::types(def.into(), Visibility::Public)\n                 } else {\n@@ -450,7 +442,12 @@ impl DefMap {\n         };\n \n         let extern_prelude = || {\n-            self.extern_prelude\n+            if self.block.is_some() {\n+                // Don't resolve extern prelude in block `DefMap`s.\n+                return PerNs::none();\n+            }\n+            self.data\n+                .extern_prelude\n                 .get(name)\n                 .map_or(PerNs::none(), |&it| PerNs::types(it.into(), Visibility::Public))\n         };\n@@ -475,13 +472,20 @@ impl DefMap {\n     ) -> PerNs {\n         let from_crate_root = match self.block {\n             Some(_) => {\n-                let def_map = self.crate_root(db).def_map(db);\n-                def_map[def_map.root].scope.get(name)\n+                let def_map = self.crate_root().def_map(db);\n+                def_map[Self::ROOT].scope.get(name)\n             }\n-            None => self[self.root].scope.get(name),\n+            None => self[Self::ROOT].scope.get(name),\n         };\n         let from_extern_prelude = || {\n-            self.resolve_name_in_extern_prelude(db, name)\n+            if self.block.is_some() {\n+                // Don't resolve extern prelude in block `DefMap`s.\n+                return PerNs::none();\n+            }\n+            self.data\n+                .extern_prelude\n+                .get(name)\n+                .copied()\n                 .map_or(PerNs::none(), |it| PerNs::types(it.into(), Visibility::Public))\n         };\n "}, {"sha": "f4cca8d68d0ac71ac3ddf7d7f21209b2be6c9367", "filename": "crates/hir-def/src/nameres/tests/macros.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=0b4c09b1d2d3e6be0499f2683743716661821bf2", "patch": "@@ -750,7 +750,7 @@ macro_rules! foo {\n pub use core::clone::Clone;\n \"#,\n     );\n-    assert_eq!(map.modules[map.root].scope.impls().len(), 1);\n+    assert_eq!(map.modules[DefMap::ROOT].scope.impls().len(), 1);\n }\n \n #[test]\n@@ -772,7 +772,7 @@ pub macro Copy {}\n pub macro Clone {}\n \"#,\n     );\n-    assert_eq!(map.modules[map.root].scope.impls().len(), 2);\n+    assert_eq!(map.modules[DefMap::ROOT].scope.impls().len(), 2);\n }\n \n #[test]\n@@ -815,7 +815,7 @@ pub macro derive($item:item) {}\n pub macro Clone {}\n \"#,\n     );\n-    assert_eq!(map.modules[map.root].scope.impls().len(), 1);\n+    assert_eq!(map.modules[DefMap::ROOT].scope.impls().len(), 1);\n }\n \n #[test]\n@@ -1094,8 +1094,8 @@ pub fn derive_macro_2(_item: TokenStream) -> TokenStream {\n     let krate = db.crate_graph().iter().next().unwrap();\n     let def_map = db.crate_def_map(krate);\n \n-    assert_eq!(def_map.exported_derives.len(), 1);\n-    match def_map.exported_derives.values().next() {\n+    assert_eq!(def_map.data.exported_derives.len(), 1);\n+    match def_map.data.exported_derives.values().next() {\n         Some(helpers) => match &**helpers {\n             [attr] => assert_eq!(attr.display(&db).to_string(), \"helper_attr\"),\n             _ => unreachable!(),\n@@ -1286,7 +1286,7 @@ fn proc_attr(a: TokenStream, b: TokenStream) -> TokenStream { a }\n     let krate = db.crate_graph().iter().next().unwrap();\n     let def_map = db.crate_def_map(krate);\n \n-    let root_module = &def_map[def_map.root()].scope;\n+    let root_module = &def_map[DefMap::ROOT].scope;\n     assert!(\n         root_module.legacy_macros().count() == 0,\n         \"`#[macro_use]` shouldn't bring macros into textual macro scope\",\n@@ -1392,7 +1392,7 @@ macro_rules! derive { () => {} }\n struct S;\n     \"#,\n     );\n-    assert_eq!(map.modules[map.root].scope.impls().len(), 1);\n+    assert_eq!(map.modules[DefMap::ROOT].scope.impls().len(), 1);\n }\n \n #[test]"}, {"sha": "06f5b2526a459a1c701efdd3abc7e4a7b16eb31f", "filename": "crates/hir-def/src/resolver.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=0b4c09b1d2d3e6be0499f2683743716661821bf2", "patch": "@@ -586,8 +586,9 @@ impl Resolver {\n             }));\n             if let Some(block) = expr_scopes.block(scope_id) {\n                 let def_map = db.block_def_map(block);\n-                let root = def_map.root();\n-                resolver.scopes.push(Scope::BlockScope(ModuleItemMap { def_map, module_id: root }));\n+                resolver\n+                    .scopes\n+                    .push(Scope::BlockScope(ModuleItemMap { def_map, module_id: DefMap::ROOT }));\n                 // FIXME: This adds as many module scopes as there are blocks, but resolving in each\n                 // already traverses all parents, so this is O(n\u00b2). I think we could only store the\n                 // innermost module scope instead?\n@@ -753,8 +754,7 @@ fn resolver_for_scope_(\n     for scope in scope_chain.into_iter().rev() {\n         if let Some(block) = scopes.block(scope) {\n             let def_map = db.block_def_map(block);\n-            let root = def_map.root();\n-            r = r.push_block_scope(def_map, root);\n+            r = r.push_block_scope(def_map, DefMap::ROOT);\n             // FIXME: This adds as many module scopes as there are blocks, but resolving in each\n             // already traverses all parents, so this is O(n\u00b2). I think we could only store the\n             // innermost module scope instead?"}, {"sha": "a6befc8a81a81bd59e1c8641b755ee46bba4ce23", "filename": "crates/hir-def/src/test_db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Ftest_db.rs?ref=0b4c09b1d2d3e6be0499f2683743716661821bf2", "patch": "@@ -110,7 +110,7 @@ impl TestDB {\n                 }\n                 _ => {\n                     // FIXME: handle `mod` inside block expression\n-                    return def_map.module_id(def_map.root());\n+                    return def_map.module_id(DefMap::ROOT);\n                 }\n             }\n         }\n@@ -119,7 +119,7 @@ impl TestDB {\n     /// Finds the smallest/innermost module in `def_map` containing `position`.\n     fn mod_at_position(&self, def_map: &DefMap, position: FilePosition) -> LocalModuleId {\n         let mut size = None;\n-        let mut res = def_map.root();\n+        let mut res = DefMap::ROOT;\n         for (module, data) in def_map.modules() {\n             let src = data.definition_source(self);\n             if src.file_id != position.file_id.into() {"}, {"sha": "32f50cb051dbcecf513a883e393c0cf8acb0bec1", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=0b4c09b1d2d3e6be0499f2683743716661821bf2", "patch": "@@ -13,6 +13,7 @@ use hir_def::{\n     generics::{TypeOrConstParamData, TypeParamProvenance},\n     item_scope::ItemInNs,\n     lang_item::{LangItem, LangItemTarget},\n+    nameres::DefMap,\n     path::{Path, PathKind},\n     type_ref::{TraitBoundModifier, TypeBound, TypeRef},\n     visibility::Visibility,\n@@ -1488,7 +1489,7 @@ pub fn write_visibility(\n         Visibility::Public => write!(f, \"pub \"),\n         Visibility::Module(vis_id) => {\n             let def_map = module_id.def_map(f.db.upcast());\n-            let root_module_id = def_map.module_id(def_map.root());\n+            let root_module_id = def_map.module_id(DefMap::ROOT);\n             if vis_id == module_id {\n                 // pub(self) or omitted\n                 Ok(())"}, {"sha": "9a2090ab79a2cf54b11cd2a13b7214860655905a", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=0b4c09b1d2d3e6be0499f2683743716661821bf2", "patch": "@@ -548,7 +548,7 @@ impl HirDisplay for Module {\n         // FIXME: Module doesn't have visibility saved in data.\n         match self.name(f.db) {\n             Some(name) => write!(f, \"mod {}\", name.display(f.db.upcast())),\n-            None if self.is_crate_root(f.db) => match self.krate(f.db).display_name(f.db) {\n+            None if self.is_crate_root() => match self.krate(f.db).display_name(f.db) {\n                 Some(name) => write!(f, \"extern crate {name}\"),\n                 None => f.write_str(\"extern crate {unknown}\"),\n             },"}, {"sha": "19709bb44ad458dfb4dfc13af7eab04f5f6b8c04", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=0b4c09b1d2d3e6be0499f2683743716661821bf2", "patch": "@@ -118,7 +118,7 @@ pub use {\n         find_path::PrefixKind,\n         import_map,\n         lang_item::LangItem,\n-        nameres::ModuleSource,\n+        nameres::{DefMap, ModuleSource},\n         path::{ModPath, PathKind},\n         type_ref::{Mutability, TypeRef},\n         visibility::Visibility,\n@@ -202,7 +202,7 @@ impl Crate {\n \n     pub fn root_module(self, db: &dyn HirDatabase) -> Module {\n         let def_map = db.crate_def_map(self.id);\n-        Module { id: def_map.module_id(def_map.root()) }\n+        Module { id: def_map.module_id(DefMap::ROOT) }\n     }\n \n     pub fn modules(self, db: &dyn HirDatabase) -> Vec<Module> {\n@@ -475,12 +475,11 @@ impl Module {\n     /// in the module tree of any target in `Cargo.toml`.\n     pub fn crate_root(self, db: &dyn HirDatabase) -> Module {\n         let def_map = db.crate_def_map(self.id.krate());\n-        Module { id: def_map.module_id(def_map.root()) }\n+        Module { id: def_map.module_id(DefMap::ROOT) }\n     }\n \n-    pub fn is_crate_root(self, db: &dyn HirDatabase) -> bool {\n-        let def_map = db.crate_def_map(self.id.krate());\n-        def_map.root() == self.id.local_id\n+    pub fn is_crate_root(self) -> bool {\n+        DefMap::ROOT == self.id.local_id\n     }\n \n     /// Iterates over all child modules."}, {"sha": "480cb77b4fd6a8020aa39680b638da3c17e52ca1", "filename": "crates/ide-completion/src/completions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=0b4c09b1d2d3e6be0499f2683743716661821bf2", "patch": "@@ -158,7 +158,7 @@ impl Completions {\n         path_ctx: &PathCompletionCtx,\n     ) {\n         ctx.process_all_names(&mut |name, res, doc_aliases| match res {\n-            ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) if m.is_crate_root(ctx.db) => {\n+            ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) if m.is_crate_root() => {\n                 self.add_module(ctx, path_ctx, m, name, doc_aliases);\n             }\n             _ => (),"}, {"sha": "eba9d8afc40abf19412f7199080a5cf36f9c9976", "filename": "crates/ide-db/src/helpers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fide-db%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fide-db%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fhelpers.rs?ref=0b4c09b1d2d3e6be0499f2683743716661821bf2", "patch": "@@ -77,7 +77,7 @@ pub fn visit_file_defs(\n     }\n     module.impl_defs(db).into_iter().for_each(|impl_| cb(impl_.into()));\n \n-    let is_root = module.is_crate_root(db);\n+    let is_root = module.is_crate_root();\n     module\n         .legacy_macros(db)\n         .into_iter()"}, {"sha": "52a23b4b8f3d2452244ae7534873d93a1503d7f2", "filename": "crates/ide-db/src/rename.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fide-db%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fide-db%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Frename.rs?ref=0b4c09b1d2d3e6be0499f2683743716661821bf2", "patch": "@@ -178,7 +178,7 @@ fn rename_mod(\n \n     let mut source_change = SourceChange::default();\n \n-    if module.is_crate_root(sema.db) {\n+    if module.is_crate_root() {\n         return Ok(source_change);\n     }\n "}, {"sha": "73cd5dcaf23fc84a33d5c4fd04af742ada022e1f", "filename": "crates/ide-db/src/search.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsearch.rs?ref=0b4c09b1d2d3e6be0499f2683743716661821bf2", "patch": "@@ -225,7 +225,7 @@ impl Definition {\n         // def is crate root\n         // FIXME: We don't do searches for crates currently, as a crate does not actually have a single name\n         if let &Definition::Module(module) = self {\n-            if module.is_crate_root(db) {\n+            if module.is_crate_root() {\n                 return SearchScope::reverse_dependencies(db, module.krate());\n             }\n         }\n@@ -392,7 +392,7 @@ impl<'a> FindUsages<'a> {\n \n         let name = match self.def {\n             // special case crate modules as these do not have a proper name\n-            Definition::Module(module) if module.is_crate_root(self.sema.db) => {\n+            Definition::Module(module) if module.is_crate_root() => {\n                 // FIXME: This assumes the crate name is always equal to its display name when it really isn't\n                 module\n                     .krate()\n@@ -500,7 +500,7 @@ impl<'a> FindUsages<'a> {\n             let scope =\n                 search_scope.intersection(&SearchScope::module_and_children(self.sema.db, module));\n \n-            let is_crate_root = module.is_crate_root(self.sema.db).then(|| Finder::new(\"crate\"));\n+            let is_crate_root = module.is_crate_root().then(|| Finder::new(\"crate\"));\n             let finder = &Finder::new(\"super\");\n \n             for (text, file_id, search_range) in scope_files(sema, &scope) {"}, {"sha": "271e7ce73bcdda3f84a3348dda11ed597a9d1a44", "filename": "crates/ide-diagnostics/src/handlers/unlinked_file.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs?ref=0b4c09b1d2d3e6be0499f2683743716661821bf2", "patch": "@@ -2,7 +2,7 @@\n \n use std::iter;\n \n-use hir::{db::DefDatabase, InFile, ModuleSource};\n+use hir::{db::DefDatabase, DefMap, InFile, ModuleSource};\n use ide_db::{\n     base_db::{FileId, FileLoader, SourceDatabase, SourceDatabaseExt},\n     source_change::SourceChange,\n@@ -74,7 +74,7 @@ fn fixes(ctx: &DiagnosticsContext<'_>, file_id: FileId) -> Option<Vec<Assist>> {\n     'crates: for &krate in &*ctx.sema.db.relevant_crates(file_id) {\n         let crate_def_map = ctx.sema.db.crate_def_map(krate);\n \n-        let root_module = &crate_def_map[crate_def_map.root()];\n+        let root_module = &crate_def_map[DefMap::ROOT];\n         let Some(root_file_id) = root_module.origin.file_id() else { continue };\n         let Some(crate_root_path) = source_root.path_for_file(&root_file_id) else { continue };\n         let Some(rel) = parent.strip_prefix(&crate_root_path.parent()?) else { continue };"}, {"sha": "d2c77e2dc797504ed34453ce57cfcb11381439f7", "filename": "crates/ide/src/status.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fide%2Fsrc%2Fstatus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fide%2Fsrc%2Fstatus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fstatus.rs?ref=0b4c09b1d2d3e6be0499f2683743716661821bf2", "patch": "@@ -1,7 +1,7 @@\n use std::{fmt, marker::PhantomData};\n \n use hir::{\n-    db::{AstIdMapQuery, AttrsQuery, ParseMacroExpansionQuery},\n+    db::{AstIdMapQuery, AttrsQuery, BlockDefMapQuery, ParseMacroExpansionQuery},\n     Attr, Attrs, ExpandResult, MacroFile, Module,\n };\n use ide_db::{\n@@ -51,6 +51,7 @@ pub(crate) fn status(db: &RootDatabase, file_id: Option<FileId>) -> String {\n     format_to!(buf, \"\\nDebug info:\\n\");\n     format_to!(buf, \"{}\\n\", collect_query(AttrsQuery.in_db(db)));\n     format_to!(buf, \"{} ast id maps\\n\", collect_query_count(AstIdMapQuery.in_db(db)));\n+    format_to!(buf, \"{} block def maps\\n\", collect_query_count(BlockDefMapQuery.in_db(db)));\n \n     if let Some(file_id) = file_id {\n         format_to!(buf, \"\\nFile info:\\n\");"}, {"sha": "3c40246a69d37310e3282118f17bcf7e31c6043a", "filename": "crates/ide/src/syntax_highlighting/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4c09b1d2d3e6be0499f2683743716661821bf2/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=0b4c09b1d2d3e6be0499f2683743716661821bf2", "patch": "@@ -340,7 +340,7 @@ fn highlight_def(\n         Definition::Field(_) => Highlight::new(HlTag::Symbol(SymbolKind::Field)),\n         Definition::Module(module) => {\n             let mut h = Highlight::new(HlTag::Symbol(SymbolKind::Module));\n-            if module.is_crate_root(db) {\n+            if module.is_crate_root() {\n                 h |= HlMod::CrateRoot;\n             }\n             h"}, {"sha": "5107f294394bc7573fb49878915bc45e28e00026", "filename": "lib/la-arena/src/lib.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0b4c09b1d2d3e6be0499f2683743716661821bf2/lib%2Fla-arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4c09b1d2d3e6be0499f2683743716661821bf2/lib%2Fla-arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Fla-arena%2Fsrc%2Flib.rs?ref=0b4c09b1d2d3e6be0499f2683743716661821bf2", "patch": "@@ -18,6 +18,18 @@ pub use map::{ArenaMap, Entry, OccupiedEntry, VacantEntry};\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct RawIdx(u32);\n \n+impl RawIdx {\n+    /// Constructs a [`RawIdx`] from a u32.\n+    pub const fn from_u32(u32: u32) -> Self {\n+        RawIdx(u32)\n+    }\n+\n+    /// Deconstructs a [`RawIdx`] into the underlying u32.\n+    pub const fn into_u32(self) -> u32 {\n+        self.0\n+    }\n+}\n+\n impl From<RawIdx> for u32 {\n     #[inline]\n     fn from(raw: RawIdx) -> u32 {\n@@ -94,12 +106,12 @@ impl<T> fmt::Debug for Idx<T> {\n \n impl<T> Idx<T> {\n     /// Creates a new index from a [`RawIdx`].\n-    pub fn from_raw(raw: RawIdx) -> Self {\n+    pub const fn from_raw(raw: RawIdx) -> Self {\n         Idx { raw, _ty: PhantomData }\n     }\n \n     /// Converts this index into the underlying [`RawIdx`].\n-    pub fn into_raw(self) -> RawIdx {\n+    pub const fn into_raw(self) -> RawIdx {\n         self.raw\n     }\n }"}]}