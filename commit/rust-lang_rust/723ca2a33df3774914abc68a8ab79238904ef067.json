{"sha": "723ca2a33df3774914abc68a8ab79238904ef067", "node_id": "C_kwDOAAsO6NoAKDcyM2NhMmEzM2RmMzc3NDkxNGFiYzY4YThhYjc5MjM4OTA0ZWYwNjc", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-05-04T03:10:22Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-05-04T03:52:14Z"}, "message": "Factor out more repeated code in `{write,read}_leb128!`.\n\nMake them generate the entire function, not just the function body.", "tree": {"sha": "bdacdd0967b118d02408f3200a630e8bfb424b41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdacdd0967b118d02408f3200a630e8bfb424b41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/723ca2a33df3774914abc68a8ab79238904ef067", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/723ca2a33df3774914abc68a8ab79238904ef067", "html_url": "https://github.com/rust-lang/rust/commit/723ca2a33df3774914abc68a8ab79238904ef067", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/723ca2a33df3774914abc68a8ab79238904ef067/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ac959a3c083dcd3c6536c26513b26ff891abfe6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ac959a3c083dcd3c6536c26513b26ff891abfe6", "html_url": "https://github.com/rust-lang/rust/commit/4ac959a3c083dcd3c6536c26513b26ff891abfe6"}], "stats": {"total": 139, "additions": 44, "deletions": 95}, "files": [{"sha": "6b559cb5b2f643ceb4c9fa901d83198e9578a1c1", "filename": "compiler/rustc_serialize/src/opaque.rs", "status": "modified", "additions": 44, "deletions": 95, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/723ca2a33df3774914abc68a8ab79238904ef067/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/723ca2a33df3774914abc68a8ab79238904ef067/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs?ref=723ca2a33df3774914abc68a8ab79238904ef067", "patch": "@@ -266,51 +266,40 @@ impl Drop for FileEncoder {\n }\n \n macro_rules! write_leb128 {\n-    ($enc:expr, $value:expr, $int_ty:ty, $fun:ident) => {{\n-        const MAX_ENCODED_LEN: usize = $crate::leb128::max_leb128_len::<$int_ty>();\n+    ($this_fn:ident, $int_ty:ty, $write_leb_fn:ident) => {\n+        #[inline]\n+        fn $this_fn(&mut self, v: $int_ty) {\n+            const MAX_ENCODED_LEN: usize = $crate::leb128::max_leb128_len::<$int_ty>();\n \n-        // We ensure this during `FileEncoder` construction.\n-        debug_assert!($enc.capacity() >= MAX_ENCODED_LEN);\n+            // We ensure this during `FileEncoder` construction.\n+            debug_assert!(self.capacity() >= MAX_ENCODED_LEN);\n \n-        let mut buffered = $enc.buffered;\n+            let mut buffered = self.buffered;\n \n-        // This can't overflow. See assertion in `FileEncoder::with_capacity`.\n-        if std::intrinsics::unlikely(buffered + MAX_ENCODED_LEN > $enc.capacity()) {\n-            $enc.flush();\n-            buffered = 0;\n-        }\n+            // This can't overflow. See assertion in `FileEncoder::with_capacity`.\n+            if std::intrinsics::unlikely(buffered + MAX_ENCODED_LEN > self.capacity()) {\n+                self.flush();\n+                buffered = 0;\n+            }\n \n-        // SAFETY: The above check and flush ensures that there is enough\n-        // room to write the encoded value to the buffer.\n-        let buf = unsafe {\n-            &mut *($enc.buf.as_mut_ptr().add(buffered) as *mut [MaybeUninit<u8>; MAX_ENCODED_LEN])\n-        };\n+            // SAFETY: The above check and flush ensures that there is enough\n+            // room to write the encoded value to the buffer.\n+            let buf = unsafe {\n+                &mut *(self.buf.as_mut_ptr().add(buffered)\n+                    as *mut [MaybeUninit<u8>; MAX_ENCODED_LEN])\n+            };\n \n-        let encoded = leb128::$fun(buf, $value);\n-        $enc.buffered = buffered + encoded.len();\n-    }};\n+            let encoded = leb128::$write_leb_fn(buf, v);\n+            self.buffered = buffered + encoded.len();\n+        }\n+    };\n }\n \n impl Encoder for FileEncoder {\n-    #[inline]\n-    fn emit_usize(&mut self, v: usize) {\n-        write_leb128!(self, v, usize, write_usize_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_u128(&mut self, v: u128) {\n-        write_leb128!(self, v, u128, write_u128_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_u64(&mut self, v: u64) {\n-        write_leb128!(self, v, u64, write_u64_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_u32(&mut self, v: u32) {\n-        write_leb128!(self, v, u32, write_u32_leb128)\n-    }\n+    write_leb128!(emit_usize, usize, write_usize_leb128);\n+    write_leb128!(emit_u128, u128, write_u128_leb128);\n+    write_leb128!(emit_u64, u64, write_u64_leb128);\n+    write_leb128!(emit_u32, u32, write_u32_leb128);\n \n     #[inline]\n     fn emit_u16(&mut self, v: u16) {\n@@ -322,25 +311,10 @@ impl Encoder for FileEncoder {\n         self.write_one(v);\n     }\n \n-    #[inline]\n-    fn emit_isize(&mut self, v: isize) {\n-        write_leb128!(self, v, isize, write_isize_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_i128(&mut self, v: i128) {\n-        write_leb128!(self, v, i128, write_i128_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_i64(&mut self, v: i64) {\n-        write_leb128!(self, v, i64, write_i64_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_i32(&mut self, v: i32) {\n-        write_leb128!(self, v, i32, write_i32_leb128)\n-    }\n+    write_leb128!(emit_isize, isize, write_isize_leb128);\n+    write_leb128!(emit_i128, i128, write_i128_leb128);\n+    write_leb128!(emit_i64, i64, write_i64_leb128);\n+    write_leb128!(emit_i32, i32, write_i32_leb128);\n \n     #[inline]\n     fn emit_i16(&mut self, v: i16) {\n@@ -437,29 +411,19 @@ impl<'a> MemDecoder<'a> {\n }\n \n macro_rules! read_leb128 {\n-    ($dec:expr, $fun:ident) => {{ leb128::$fun($dec) }};\n+    ($this_fn:ident, $int_ty:ty, $read_leb_fn:ident) => {\n+        #[inline]\n+        fn $this_fn(&mut self) -> $int_ty {\n+            leb128::$read_leb_fn(self)\n+        }\n+    };\n }\n \n impl<'a> Decoder for MemDecoder<'a> {\n-    #[inline]\n-    fn read_usize(&mut self) -> usize {\n-        read_leb128!(self, read_usize_leb128)\n-    }\n-\n-    #[inline]\n-    fn read_u128(&mut self) -> u128 {\n-        read_leb128!(self, read_u128_leb128)\n-    }\n-\n-    #[inline]\n-    fn read_u64(&mut self) -> u64 {\n-        read_leb128!(self, read_u64_leb128)\n-    }\n-\n-    #[inline]\n-    fn read_u32(&mut self) -> u32 {\n-        read_leb128!(self, read_u32_leb128)\n-    }\n+    read_leb128!(read_usize, usize, read_usize_leb128);\n+    read_leb128!(read_u128, u128, read_u128_leb128);\n+    read_leb128!(read_u64, u64, read_u64_leb128);\n+    read_leb128!(read_u32, u32, read_u32_leb128);\n \n     #[inline]\n     fn read_u16(&mut self) -> u16 {\n@@ -479,25 +443,10 @@ impl<'a> Decoder for MemDecoder<'a> {\n         }\n     }\n \n-    #[inline]\n-    fn read_isize(&mut self) -> isize {\n-        read_leb128!(self, read_isize_leb128)\n-    }\n-\n-    #[inline]\n-    fn read_i128(&mut self) -> i128 {\n-        read_leb128!(self, read_i128_leb128)\n-    }\n-\n-    #[inline]\n-    fn read_i64(&mut self) -> i64 {\n-        read_leb128!(self, read_i64_leb128)\n-    }\n-\n-    #[inline]\n-    fn read_i32(&mut self) -> i32 {\n-        read_leb128!(self, read_i32_leb128)\n-    }\n+    read_leb128!(read_isize, isize, read_isize_leb128);\n+    read_leb128!(read_i128, i128, read_i128_leb128);\n+    read_leb128!(read_i64, i64, read_i64_leb128);\n+    read_leb128!(read_i32, i32, read_i32_leb128);\n \n     #[inline]\n     fn read_i16(&mut self) -> i16 {"}]}