{"sha": "86753ce1cc520bfe50ae89f09ec47f313ce900eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2NzUzY2UxY2M1MjBiZmU1MGFlODlmMDllYzQ3ZjMxM2NlOTAwZWI=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-03T15:12:57Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-12T20:53:12Z"}, "message": "Use the GlobalAlloc trait for #[global_allocator]", "tree": {"sha": "5611452336d4e8dbf10c2f21b9516d46743092f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5611452336d4e8dbf10c2f21b9516d46743092f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86753ce1cc520bfe50ae89f09ec47f313ce900eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86753ce1cc520bfe50ae89f09ec47f313ce900eb", "html_url": "https://github.com/rust-lang/rust/commit/86753ce1cc520bfe50ae89f09ec47f313ce900eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86753ce1cc520bfe50ae89f09ec47f313ce900eb/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb69593f73be1e41d9e2ef065010a47478c14924", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb69593f73be1e41d9e2ef065010a47478c14924", "html_url": "https://github.com/rust-lang/rust/commit/eb69593f73be1e41d9e2ef065010a47478c14924"}], "stats": {"total": 875, "additions": 168, "deletions": 707}, "files": [{"sha": "2e969f4ec2bbcdd0313995473e1118e2b2eee1d0", "filename": "src/Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=86753ce1cc520bfe50ae89f09ec47f313ce900eb", "patch": "@@ -19,7 +19,6 @@ dependencies = [\n name = \"alloc_jemalloc\"\n version = \"0.0.0\"\n dependencies = [\n- \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n  \"cc 1.0.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"compiler_builtins 0.0.0\","}, {"sha": "6ce12ba684ddc82f24feeede25086975a945304e", "filename": "src/doc/unstable-book/src/language-features/global-allocator.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-allocator.md", "raw_url": "https://github.com/rust-lang/rust/raw/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-allocator.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-allocator.md?ref=86753ce1cc520bfe50ae89f09ec47f313ce900eb", "patch": "@@ -29,16 +29,16 @@ looks like:\n ```rust\n #![feature(global_allocator, allocator_api, heap_api)]\n \n-use std::heap::{Alloc, System, Layout, AllocErr};\n+use std::alloc::{GlobalAlloc, System, Layout, Void};\n \n struct MyAllocator;\n \n-unsafe impl<'a> Alloc for &'a MyAllocator {\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+unsafe impl GlobalAlloc for MyAllocator {\n+    unsafe fn alloc(&self, layout: Layout) -> *mut Void {\n         System.alloc(layout)\n     }\n \n-    unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n+    unsafe fn dealloc(&self, ptr: *mut Void, layout: Layout) {\n         System.dealloc(ptr, layout)\n     }\n }"}, {"sha": "73bc78eb8a2e84e894dacc98211616fe060b2cc0", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 40, "deletions": 148, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=86753ce1cc520bfe50ae89f09ec47f313ce900eb", "patch": "@@ -16,26 +16,19 @@\n             issue = \"32838\")]\n \n use core::intrinsics::{min_align_of_val, size_of_val};\n-use core::mem;\n use core::usize;\n \n #[doc(inline)]\n pub use core::alloc::*;\n \n+#[cfg(stage0)]\n extern \"Rust\" {\n     #[allocator]\n     #[rustc_allocator_nounwind]\n     fn __rust_alloc(size: usize, align: usize, err: *mut u8) -> *mut u8;\n-    #[cold]\n-    #[rustc_allocator_nounwind]\n-    fn __rust_oom(err: *const u8) -> !;\n     #[rustc_allocator_nounwind]\n     fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);\n     #[rustc_allocator_nounwind]\n-    fn __rust_usable_size(layout: *const u8,\n-                          min: *mut usize,\n-                          max: *mut usize);\n-    #[rustc_allocator_nounwind]\n     fn __rust_realloc(ptr: *mut u8,\n                       old_size: usize,\n                       old_align: usize,\n@@ -44,31 +37,22 @@ extern \"Rust\" {\n                       err: *mut u8) -> *mut u8;\n     #[rustc_allocator_nounwind]\n     fn __rust_alloc_zeroed(size: usize, align: usize, err: *mut u8) -> *mut u8;\n+}\n+\n+#[cfg(not(stage0))]\n+extern \"Rust\" {\n+    #[allocator]\n     #[rustc_allocator_nounwind]\n-    fn __rust_alloc_excess(size: usize,\n-                           align: usize,\n-                           excess: *mut usize,\n-                           err: *mut u8) -> *mut u8;\n+    fn __rust_alloc(size: usize, align: usize) -> *mut u8;\n     #[rustc_allocator_nounwind]\n-    fn __rust_realloc_excess(ptr: *mut u8,\n-                             old_size: usize,\n-                             old_align: usize,\n-                             new_size: usize,\n-                             new_align: usize,\n-                             excess: *mut usize,\n-                             err: *mut u8) -> *mut u8;\n+    fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);\n     #[rustc_allocator_nounwind]\n-    fn __rust_grow_in_place(ptr: *mut u8,\n-                            old_size: usize,\n-                            old_align: usize,\n-                            new_size: usize,\n-                            new_align: usize) -> u8;\n+    fn __rust_realloc(ptr: *mut u8,\n+                      old_size: usize,\n+                      align: usize,\n+                      new_size: usize) -> *mut u8;\n     #[rustc_allocator_nounwind]\n-    fn __rust_shrink_in_place(ptr: *mut u8,\n-                              old_size: usize,\n-                              old_align: usize,\n-                              new_size: usize,\n-                              new_align: usize) -> u8;\n+    fn __rust_alloc_zeroed(size: usize, align: usize) -> *mut u8;\n }\n \n #[derive(Copy, Clone, Default, Debug)]\n@@ -86,22 +70,15 @@ pub const Heap: Global = Global;\n unsafe impl Alloc for Global {\n     #[inline]\n     unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n-        let mut err = AllocErr;\n-        let ptr = __rust_alloc(layout.size(),\n-                               layout.align(),\n-                               &mut err as *mut AllocErr as *mut u8);\n-        if ptr.is_null() {\n-            Err(AllocErr)\n-        } else {\n-            Ok(ptr)\n-        }\n-    }\n+        #[cfg(not(stage0))]\n+        let ptr = __rust_alloc(layout.size(), layout.align());\n+        #[cfg(stage0)]\n+        let ptr = __rust_alloc(layout.size(), layout.align(), &mut 0);\n \n-    #[inline]\n-    #[cold]\n-    fn oom(&mut self, err: AllocErr) -> ! {\n-        unsafe {\n-            __rust_oom(&err as *const AllocErr as *const u8)\n+        if !ptr.is_null() {\n+            Ok(ptr)\n+        } else {\n+            Err(AllocErr)\n         }\n     }\n \n@@ -110,126 +87,41 @@ unsafe impl Alloc for Global {\n         __rust_dealloc(ptr, layout.size(), layout.align())\n     }\n \n-    #[inline]\n-    fn usable_size(&self, layout: &Layout) -> (usize, usize) {\n-        let mut min = 0;\n-        let mut max = 0;\n-        unsafe {\n-            __rust_usable_size(layout as *const Layout as *const u8,\n-                               &mut min,\n-                               &mut max);\n-        }\n-        (min, max)\n-    }\n-\n     #[inline]\n     unsafe fn realloc(&mut self,\n                       ptr: *mut u8,\n                       layout: Layout,\n                       new_layout: Layout)\n                       -> Result<*mut u8, AllocErr>\n     {\n-        let mut err = AllocErr;\n-        let ptr = __rust_realloc(ptr,\n-                                 layout.size(),\n-                                 layout.align(),\n-                                 new_layout.size(),\n-                                 new_layout.align(),\n-                                 &mut err as *mut AllocErr as *mut u8);\n-        if ptr.is_null() {\n-            Err(AllocErr)\n+        if layout.align() == new_layout.align() {\n+            #[cfg(not(stage0))]\n+            let ptr = __rust_realloc(ptr, layout.size(), layout.align(), new_layout.size());\n+            #[cfg(stage0)]\n+            let ptr = __rust_realloc(ptr, layout.size(), layout.align(),\n+                                     new_layout.size(), new_layout.align(), &mut 0);\n+\n+            if !ptr.is_null() {\n+                Ok(ptr)\n+            } else {\n+                Err(AllocErr)\n+            }\n         } else {\n-            mem::forget(err);\n-            Ok(ptr)\n+            Err(AllocErr)\n         }\n     }\n \n     #[inline]\n     unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n-        let mut err = AllocErr;\n-        let ptr = __rust_alloc_zeroed(layout.size(),\n-                                      layout.align(),\n-                                      &mut err as *mut AllocErr as *mut u8);\n-        if ptr.is_null() {\n-            Err(AllocErr)\n-        } else {\n-            Ok(ptr)\n-        }\n-    }\n+        #[cfg(not(stage0))]\n+        let ptr = __rust_alloc_zeroed(layout.size(), layout.align());\n+        #[cfg(stage0)]\n+        let ptr = __rust_alloc_zeroed(layout.size(), layout.align(), &mut 0);\n \n-    #[inline]\n-    unsafe fn alloc_excess(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n-        let mut err = AllocErr;\n-        let mut size = 0;\n-        let ptr = __rust_alloc_excess(layout.size(),\n-                                      layout.align(),\n-                                      &mut size,\n-                                      &mut err as *mut AllocErr as *mut u8);\n-        if ptr.is_null() {\n-            Err(AllocErr)\n+        if !ptr.is_null() {\n+            Ok(ptr)\n         } else {\n-            Ok(Excess(ptr, size))\n-        }\n-    }\n-\n-    #[inline]\n-    unsafe fn realloc_excess(&mut self,\n-                             ptr: *mut u8,\n-                             layout: Layout,\n-                             new_layout: Layout) -> Result<Excess, AllocErr> {\n-        let mut err = AllocErr;\n-        let mut size = 0;\n-        let ptr = __rust_realloc_excess(ptr,\n-                                        layout.size(),\n-                                        layout.align(),\n-                                        new_layout.size(),\n-                                        new_layout.align(),\n-                                        &mut size,\n-                                        &mut err as *mut AllocErr as *mut u8);\n-        if ptr.is_null() {\n             Err(AllocErr)\n-        } else {\n-            Ok(Excess(ptr, size))\n-        }\n-    }\n-\n-    #[inline]\n-    unsafe fn grow_in_place(&mut self,\n-                            ptr: *mut u8,\n-                            layout: Layout,\n-                            new_layout: Layout)\n-                            -> Result<(), CannotReallocInPlace>\n-    {\n-        debug_assert!(new_layout.size() >= layout.size());\n-        debug_assert!(new_layout.align() == layout.align());\n-        let ret = __rust_grow_in_place(ptr,\n-                                       layout.size(),\n-                                       layout.align(),\n-                                       new_layout.size(),\n-                                       new_layout.align());\n-        if ret != 0 {\n-            Ok(())\n-        } else {\n-            Err(CannotReallocInPlace)\n-        }\n-    }\n-\n-    #[inline]\n-    unsafe fn shrink_in_place(&mut self,\n-                              ptr: *mut u8,\n-                              layout: Layout,\n-                              new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n-        debug_assert!(new_layout.size() <= layout.size());\n-        debug_assert!(new_layout.align() == layout.align());\n-        let ret = __rust_shrink_in_place(ptr,\n-                                         layout.size(),\n-                                         layout.align(),\n-                                         new_layout.size(),\n-                                         new_layout.align());\n-        if ret != 0 {\n-            Ok(())\n-        } else {\n-            Err(CannotReallocInPlace)\n         }\n     }\n }"}, {"sha": "7986d5dd2eb54b69a12990dc83891ba320a7e838", "filename": "src/liballoc_jemalloc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Fliballoc_jemalloc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Fliballoc_jemalloc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2FCargo.toml?ref=86753ce1cc520bfe50ae89f09ec47f313ce900eb", "patch": "@@ -12,7 +12,6 @@ test = false\n doc = false\n \n [dependencies]\n-alloc_system = { path = \"../liballoc_system\" }\n core = { path = \"../libcore\" }\n libc = { path = \"../rustc/libc_shim\" }\n compiler_builtins = { path = \"../rustc/compiler_builtins_shim\" }"}, {"sha": "661d7ab78da01d54bf3809cc2c16918edd5c0f13", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 5, "deletions": 105, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=86753ce1cc520bfe50ae89f09ec47f313ce900eb", "patch": "@@ -14,7 +14,6 @@\n             reason = \"this library is unlikely to be stabilized in its current \\\n                       form or name\",\n             issue = \"27783\")]\n-#![feature(alloc_system)]\n #![feature(libc)]\n #![feature(linkage)]\n #![feature(staged_api)]\n@@ -23,15 +22,12 @@\n #![cfg_attr(not(dummy_jemalloc), feature(allocator_api))]\n #![rustc_alloc_kind = \"exe\"]\n \n-extern crate alloc_system;\n extern crate libc;\n \n #[cfg(not(dummy_jemalloc))]\n pub use contents::*;\n #[cfg(not(dummy_jemalloc))]\n mod contents {\n-    use core::alloc::{Alloc, AllocErr, Layout};\n-    use alloc_system::System;\n     use libc::{c_int, c_void, size_t};\n \n     // Note that the symbols here are prefixed by default on macOS and Windows (we\n@@ -50,18 +46,10 @@ mod contents {\n                        target_os = \"dragonfly\", target_os = \"windows\", target_env = \"musl\"),\n                    link_name = \"je_rallocx\")]\n         fn rallocx(ptr: *mut c_void, size: size_t, flags: c_int) -> *mut c_void;\n-        #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n-                       target_os = \"dragonfly\", target_os = \"windows\", target_env = \"musl\"),\n-                   link_name = \"je_xallocx\")]\n-        fn xallocx(ptr: *mut c_void, size: size_t, extra: size_t, flags: c_int) -> size_t;\n         #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n                        target_os = \"dragonfly\", target_os = \"windows\", target_env = \"musl\"),\n                    link_name = \"je_sdallocx\")]\n         fn sdallocx(ptr: *mut c_void, size: size_t, flags: c_int);\n-        #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n-                       target_os = \"dragonfly\", target_os = \"windows\", target_env = \"musl\"),\n-                   link_name = \"je_nallocx\")]\n-        fn nallocx(size: size_t, flags: c_int) -> size_t;\n     }\n \n     const MALLOCX_ZERO: c_int = 0x40;\n@@ -102,20 +90,12 @@ mod contents {\n \n     #[no_mangle]\n     #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rde_alloc(size: usize,\n-                                     align: usize,\n-                                     _err: *mut u8) -> *mut u8 {\n+    pub unsafe extern fn __rde_alloc(size: usize, align: usize) -> *mut u8 {\n         let flags = align_to_flags(align, size);\n         let ptr = mallocx(size as size_t, flags) as *mut u8;\n         ptr\n     }\n \n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rde_oom(err: *const u8) -> ! {\n-        System.oom((*(err as *const AllocErr)).clone())\n-    }\n-\n     #[no_mangle]\n     #[rustc_std_internal_symbol]\n     pub unsafe extern fn __rde_dealloc(ptr: *mut u8,\n@@ -125,44 +105,20 @@ mod contents {\n         sdallocx(ptr as *mut c_void, size, flags);\n     }\n \n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rde_usable_size(layout: *const u8,\n-                                           min: *mut usize,\n-                                           max: *mut usize) {\n-        let layout = &*(layout as *const Layout);\n-        let flags = align_to_flags(layout.align(), layout.size());\n-        let size = nallocx(layout.size(), flags) as usize;\n-        *min = layout.size();\n-        if size > 0 {\n-            *max = size;\n-        } else {\n-            *max = layout.size();\n-        }\n-    }\n-\n     #[no_mangle]\n     #[rustc_std_internal_symbol]\n     pub unsafe extern fn __rde_realloc(ptr: *mut u8,\n                                        _old_size: usize,\n-                                       old_align: usize,\n-                                       new_size: usize,\n-                                       new_align: usize,\n-                                       _err: *mut u8) -> *mut u8 {\n-        if new_align != old_align {\n-            return 0 as *mut u8\n-        }\n-\n-        let flags = align_to_flags(new_align, new_size);\n+                                       align: usize,\n+                                       new_size: usize) -> *mut u8 {\n+        let flags = align_to_flags(align, new_size);\n         let ptr = rallocx(ptr as *mut c_void, new_size, flags) as *mut u8;\n         ptr\n     }\n \n     #[no_mangle]\n     #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rde_alloc_zeroed(size: usize,\n-                                            align: usize,\n-                                            _err: *mut u8) -> *mut u8 {\n+    pub unsafe extern fn __rde_alloc_zeroed(size: usize, align: usize) -> *mut u8 {\n         let ptr = if align <= MIN_ALIGN && align <= size {\n             calloc(size as size_t, 1) as *mut u8\n         } else {\n@@ -171,60 +127,4 @@ mod contents {\n         };\n         ptr\n     }\n-\n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rde_alloc_excess(size: usize,\n-                                            align: usize,\n-                                            excess: *mut usize,\n-                                            err: *mut u8) -> *mut u8 {\n-        let p = __rde_alloc(size, align, err);\n-        if !p.is_null() {\n-            let flags = align_to_flags(align, size);\n-            *excess = nallocx(size, flags) as usize;\n-        }\n-        return p\n-    }\n-\n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rde_realloc_excess(ptr: *mut u8,\n-                                              old_size: usize,\n-                                              old_align: usize,\n-                                              new_size: usize,\n-                                              new_align: usize,\n-                                              excess: *mut usize,\n-                                              err: *mut u8) -> *mut u8 {\n-        let p = __rde_realloc(ptr, old_size, old_align, new_size, new_align, err);\n-        if !p.is_null() {\n-            let flags = align_to_flags(new_align, new_size);\n-            *excess = nallocx(new_size, flags) as usize;\n-        }\n-        p\n-    }\n-\n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rde_grow_in_place(ptr: *mut u8,\n-                                             old_size: usize,\n-                                             old_align: usize,\n-                                             new_size: usize,\n-                                             new_align: usize) -> u8 {\n-        __rde_shrink_in_place(ptr, old_size, old_align, new_size, new_align)\n-    }\n-\n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rde_shrink_in_place(ptr: *mut u8,\n-                                               _old_size: usize,\n-                                               old_align: usize,\n-                                               new_size: usize,\n-                                               new_align: usize) -> u8 {\n-        if old_align == new_align {\n-            let flags = align_to_flags(new_align, new_size);\n-            (xallocx(ptr as *mut c_void, new_size, 0, flags) == new_size) as u8\n-        } else {\n-            0\n-        }\n-    }\n }"}, {"sha": "ce41fe1f3bc9e0683db1f0805fef2425f55da414", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 31, "deletions": 252, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=86753ce1cc520bfe50ae89f09ec47f313ce900eb", "patch": "@@ -11,7 +11,7 @@\n use rustc::middle::allocator::AllocatorKind;\n use rustc_errors;\n use syntax::abi::Abi;\n-use syntax::ast::{Crate, Attribute, LitKind, StrStyle, ExprKind};\n+use syntax::ast::{Crate, Attribute, LitKind, StrStyle};\n use syntax::ast::{Unsafety, Constness, Generics, Mutability, Ty, Mac, Arg};\n use syntax::ast::{self, Ident, Item, ItemKind, TyKind, VisibilityKind, Expr};\n use syntax::attr;\n@@ -88,15 +88,15 @@ impl<'a> Folder for ExpandAllocatorDirectives<'a> {\n             span,\n             kind: AllocatorKind::Global,\n             global: item.ident,\n-            alloc: Ident::from_str(\"alloc\"),\n+            core: Ident::from_str(\"core\"),\n             cx: ExtCtxt::new(self.sess, ecfg, self.resolver),\n         };\n         let super_path = f.cx.path(f.span, vec![\n             Ident::from_str(\"super\"),\n             f.global,\n         ]);\n         let mut items = vec![\n-            f.cx.item_extern_crate(f.span, f.alloc),\n+            f.cx.item_extern_crate(f.span, f.core),\n             f.cx.item_use_simple(\n                 f.span,\n                 respan(f.span.shrink_to_lo(), VisibilityKind::Inherited),\n@@ -126,7 +126,7 @@ struct AllocFnFactory<'a> {\n     span: Span,\n     kind: AllocatorKind,\n     global: Ident,\n-    alloc: Ident,\n+    core: Ident,\n     cx: ExtCtxt<'a>,\n }\n \n@@ -143,8 +143,7 @@ impl<'a> AllocFnFactory<'a> {\n             self.arg_ty(ty, &mut abi_args, mk)\n         }).collect();\n         let result = self.call_allocator(method.name, args);\n-        let (output_ty, output_expr) =\n-            self.ret_ty(&method.output, &mut abi_args, mk, result);\n+        let (output_ty, output_expr) = self.ret_ty(&method.output, result);\n         let kind = ItemKind::Fn(self.cx.fn_decl(abi_args, ast::FunctionRetTy::Ty(output_ty)),\n                                 Unsafety::Unsafe,\n                                 dummy_spanned(Constness::NotConst),\n@@ -159,16 +158,15 @@ impl<'a> AllocFnFactory<'a> {\n \n     fn call_allocator(&self, method: &str, mut args: Vec<P<Expr>>) -> P<Expr> {\n         let method = self.cx.path(self.span, vec![\n-            self.alloc,\n-            Ident::from_str(\"heap\"),\n-            Ident::from_str(\"Alloc\"),\n+            self.core,\n+            Ident::from_str(\"alloc\"),\n+            Ident::from_str(\"GlobalAlloc\"),\n             Ident::from_str(method),\n         ]);\n         let method = self.cx.expr_path(method);\n         let allocator = self.cx.path_ident(self.span, self.global);\n         let allocator = self.cx.expr_path(allocator);\n         let allocator = self.cx.expr_addr_of(self.span, allocator);\n-        let allocator = self.cx.expr_mut_addr_of(self.span, allocator);\n         args.insert(0, allocator);\n \n         self.cx.expr_call(self.span, method, args)\n@@ -205,8 +203,8 @@ impl<'a> AllocFnFactory<'a> {\n                 args.push(self.cx.arg(self.span, align, ty_usize));\n \n                 let layout_new = self.cx.path(self.span, vec![\n-                    self.alloc,\n-                    Ident::from_str(\"heap\"),\n+                    self.core,\n+                    Ident::from_str(\"alloc\"),\n                     Ident::from_str(\"Layout\"),\n                     Ident::from_str(\"from_size_align_unchecked\"),\n                 ]);\n@@ -219,286 +217,67 @@ impl<'a> AllocFnFactory<'a> {\n                 layout\n             }\n \n-            AllocatorTy::LayoutRef => {\n-                let ident = ident();\n-                args.push(self.cx.arg(self.span, ident, self.ptr_u8()));\n-\n-                // Convert our `arg: *const u8` via:\n-                //\n-                //      &*(arg as *const Layout)\n-                let expr = self.cx.expr_ident(self.span, ident);\n-                let expr = self.cx.expr_cast(self.span, expr, self.layout_ptr());\n-                let expr = self.cx.expr_deref(self.span, expr);\n-                self.cx.expr_addr_of(self.span, expr)\n-            }\n-\n-            AllocatorTy::AllocErr => {\n-                // We're creating:\n-                //\n-                //      (*(arg as *const AllocErr)).clone()\n+            AllocatorTy::Ptr => {\n                 let ident = ident();\n                 args.push(self.cx.arg(self.span, ident, self.ptr_u8()));\n-                let expr = self.cx.expr_ident(self.span, ident);\n-                let expr = self.cx.expr_cast(self.span, expr, self.alloc_err_ptr());\n-                let expr = self.cx.expr_deref(self.span, expr);\n-                self.cx.expr_method_call(\n-                    self.span,\n-                    expr,\n-                    Ident::from_str(\"clone\"),\n-                    Vec::new()\n-                )\n+                let arg = self.cx.expr_ident(self.span, ident);\n+                self.cx.expr_cast(self.span, arg, self.ptr_void())\n             }\n \n-            AllocatorTy::Ptr => {\n+            AllocatorTy::Usize => {\n                 let ident = ident();\n-                args.push(self.cx.arg(self.span, ident, self.ptr_u8()));\n+                args.push(self.cx.arg(self.span, ident, self.usize()));\n                 self.cx.expr_ident(self.span, ident)\n             }\n \n             AllocatorTy::ResultPtr |\n-            AllocatorTy::ResultExcess |\n-            AllocatorTy::ResultUnit |\n-            AllocatorTy::Bang |\n-            AllocatorTy::UsizePair |\n             AllocatorTy::Unit => {\n                 panic!(\"can't convert AllocatorTy to an argument\")\n             }\n         }\n     }\n \n-    fn ret_ty(&self,\n-              ty: &AllocatorTy,\n-              args: &mut Vec<Arg>,\n-              ident: &mut FnMut() -> Ident,\n-              expr: P<Expr>) -> (P<Ty>, P<Expr>)\n-    {\n+    fn ret_ty(&self, ty: &AllocatorTy, expr: P<Expr>) -> (P<Ty>, P<Expr>) {\n         match *ty {\n-            AllocatorTy::UsizePair => {\n-                // We're creating:\n-                //\n-                //      let arg = #expr;\n-                //      *min = arg.0;\n-                //      *max = arg.1;\n-\n-                let min = ident();\n-                let max = ident();\n-\n-                args.push(self.cx.arg(self.span, min, self.ptr_usize()));\n-                args.push(self.cx.arg(self.span, max, self.ptr_usize()));\n-\n-                let ident = ident();\n-                let stmt = self.cx.stmt_let(self.span, false, ident, expr);\n-                let min = self.cx.expr_ident(self.span, min);\n-                let max = self.cx.expr_ident(self.span, max);\n-                let layout = self.cx.expr_ident(self.span, ident);\n-                let assign_min = self.cx.expr(self.span, ExprKind::Assign(\n-                    self.cx.expr_deref(self.span, min),\n-                    self.cx.expr_tup_field_access(self.span, layout.clone(), 0),\n-                ));\n-                let assign_min = self.cx.stmt_semi(assign_min);\n-                let assign_max = self.cx.expr(self.span, ExprKind::Assign(\n-                    self.cx.expr_deref(self.span, max),\n-                    self.cx.expr_tup_field_access(self.span, layout.clone(), 1),\n-                ));\n-                let assign_max = self.cx.stmt_semi(assign_max);\n-\n-                let stmts = vec![stmt, assign_min, assign_max];\n-                let block = self.cx.block(self.span, stmts);\n-                let ty_unit = self.cx.ty(self.span, TyKind::Tup(Vec::new()));\n-                (ty_unit, self.cx.expr_block(block))\n-            }\n-\n-            AllocatorTy::ResultExcess => {\n-                // We're creating:\n-                //\n-                //      match #expr {\n-                //          Ok(ptr) => {\n-                //              *excess = ptr.1;\n-                //              ptr.0\n-                //          }\n-                //          Err(e) => {\n-                //              ptr::write(err_ptr, e);\n-                //              0 as *mut u8\n-                //          }\n-                //      }\n-\n-                let excess_ptr = ident();\n-                args.push(self.cx.arg(self.span, excess_ptr, self.ptr_usize()));\n-                let excess_ptr = self.cx.expr_ident(self.span, excess_ptr);\n-\n-                let err_ptr = ident();\n-                args.push(self.cx.arg(self.span, err_ptr, self.ptr_u8()));\n-                let err_ptr = self.cx.expr_ident(self.span, err_ptr);\n-                let err_ptr = self.cx.expr_cast(self.span,\n-                                                err_ptr,\n-                                                self.alloc_err_ptr());\n-\n-                let name = ident();\n-                let ok_expr = {\n-                    let ptr = self.cx.expr_ident(self.span, name);\n-                    let write = self.cx.expr(self.span, ExprKind::Assign(\n-                        self.cx.expr_deref(self.span, excess_ptr),\n-                        self.cx.expr_tup_field_access(self.span, ptr.clone(), 1),\n-                    ));\n-                    let write = self.cx.stmt_semi(write);\n-                    let ret = self.cx.expr_tup_field_access(self.span,\n-                                                            ptr.clone(),\n-                                                            0);\n-                    let ret = self.cx.stmt_expr(ret);\n-                    let block = self.cx.block(self.span, vec![write, ret]);\n-                    self.cx.expr_block(block)\n-                };\n-                let pat = self.cx.pat_ident(self.span, name);\n-                let ok = self.cx.path_ident(self.span, Ident::from_str(\"Ok\"));\n-                let ok = self.cx.pat_tuple_struct(self.span, ok, vec![pat]);\n-                let ok = self.cx.arm(self.span, vec![ok], ok_expr);\n-\n-                let name = ident();\n-                let err_expr = {\n-                    let err = self.cx.expr_ident(self.span, name);\n-                    let write = self.cx.path(self.span, vec![\n-                        self.alloc,\n-                        Ident::from_str(\"heap\"),\n-                        Ident::from_str(\"__core\"),\n-                        Ident::from_str(\"ptr\"),\n-                        Ident::from_str(\"write\"),\n-                    ]);\n-                    let write = self.cx.expr_path(write);\n-                    let write = self.cx.expr_call(self.span, write,\n-                                                  vec![err_ptr, err]);\n-                    let write = self.cx.stmt_semi(write);\n-                    let null = self.cx.expr_usize(self.span, 0);\n-                    let null = self.cx.expr_cast(self.span, null, self.ptr_u8());\n-                    let null = self.cx.stmt_expr(null);\n-                    let block = self.cx.block(self.span, vec![write, null]);\n-                    self.cx.expr_block(block)\n-                };\n-                let pat = self.cx.pat_ident(self.span, name);\n-                let err = self.cx.path_ident(self.span, Ident::from_str(\"Err\"));\n-                let err = self.cx.pat_tuple_struct(self.span, err, vec![pat]);\n-                let err = self.cx.arm(self.span, vec![err], err_expr);\n-\n-                let expr = self.cx.expr_match(self.span, expr, vec![ok, err]);\n-                (self.ptr_u8(), expr)\n-            }\n-\n             AllocatorTy::ResultPtr => {\n                 // We're creating:\n                 //\n-                //      match #expr {\n-                //          Ok(ptr) => ptr,\n-                //          Err(e) => {\n-                //              ptr::write(err_ptr, e);\n-                //              0 as *mut u8\n-                //          }\n-                //      }\n-\n-                let err_ptr = ident();\n-                args.push(self.cx.arg(self.span, err_ptr, self.ptr_u8()));\n-                let err_ptr = self.cx.expr_ident(self.span, err_ptr);\n-                let err_ptr = self.cx.expr_cast(self.span,\n-                                                err_ptr,\n-                                                self.alloc_err_ptr());\n+                //      #expr as *mut u8\n \n-                let name = ident();\n-                let ok_expr = self.cx.expr_ident(self.span, name);\n-                let pat = self.cx.pat_ident(self.span, name);\n-                let ok = self.cx.path_ident(self.span, Ident::from_str(\"Ok\"));\n-                let ok = self.cx.pat_tuple_struct(self.span, ok, vec![pat]);\n-                let ok = self.cx.arm(self.span, vec![ok], ok_expr);\n-\n-                let name = ident();\n-                let err_expr = {\n-                    let err = self.cx.expr_ident(self.span, name);\n-                    let write = self.cx.path(self.span, vec![\n-                        self.alloc,\n-                        Ident::from_str(\"heap\"),\n-                        Ident::from_str(\"__core\"),\n-                        Ident::from_str(\"ptr\"),\n-                        Ident::from_str(\"write\"),\n-                    ]);\n-                    let write = self.cx.expr_path(write);\n-                    let write = self.cx.expr_call(self.span, write,\n-                                                  vec![err_ptr, err]);\n-                    let write = self.cx.stmt_semi(write);\n-                    let null = self.cx.expr_usize(self.span, 0);\n-                    let null = self.cx.expr_cast(self.span, null, self.ptr_u8());\n-                    let null = self.cx.stmt_expr(null);\n-                    let block = self.cx.block(self.span, vec![write, null]);\n-                    self.cx.expr_block(block)\n-                };\n-                let pat = self.cx.pat_ident(self.span, name);\n-                let err = self.cx.path_ident(self.span, Ident::from_str(\"Err\"));\n-                let err = self.cx.pat_tuple_struct(self.span, err, vec![pat]);\n-                let err = self.cx.arm(self.span, vec![err], err_expr);\n-\n-                let expr = self.cx.expr_match(self.span, expr, vec![ok, err]);\n+                let expr = self.cx.expr_cast(self.span, expr, self.ptr_u8());\n                 (self.ptr_u8(), expr)\n             }\n \n-            AllocatorTy::ResultUnit => {\n-                // We're creating:\n-                //\n-                //      #expr.is_ok() as u8\n-\n-                let cast = self.cx.expr_method_call(\n-                    self.span,\n-                    expr,\n-                    Ident::from_str(\"is_ok\"),\n-                    Vec::new()\n-                );\n-                let u8 = self.cx.path_ident(self.span, Ident::from_str(\"u8\"));\n-                let u8 = self.cx.ty_path(u8);\n-                let cast = self.cx.expr_cast(self.span, cast, u8.clone());\n-                (u8, cast)\n-            }\n-\n-            AllocatorTy::Bang => {\n-                (self.cx.ty(self.span, TyKind::Never), expr)\n-            }\n-\n             AllocatorTy::Unit => {\n                 (self.cx.ty(self.span, TyKind::Tup(Vec::new())), expr)\n             }\n \n-            AllocatorTy::AllocErr |\n             AllocatorTy::Layout |\n-            AllocatorTy::LayoutRef |\n+            AllocatorTy::Usize |\n             AllocatorTy::Ptr => {\n                 panic!(\"can't convert AllocatorTy to an output\")\n             }\n         }\n     }\n \n+    fn usize(&self) -> P<Ty> {\n+        let usize = self.cx.path_ident(self.span, Ident::from_str(\"usize\"));\n+        self.cx.ty_path(usize)\n+    }\n+\n     fn ptr_u8(&self) -> P<Ty> {\n         let u8 = self.cx.path_ident(self.span, Ident::from_str(\"u8\"));\n         let ty_u8 = self.cx.ty_path(u8);\n         self.cx.ty_ptr(self.span, ty_u8, Mutability::Mutable)\n     }\n \n-    fn ptr_usize(&self) -> P<Ty> {\n-        let usize = self.cx.path_ident(self.span, Ident::from_str(\"usize\"));\n-        let ty_usize = self.cx.ty_path(usize);\n-        self.cx.ty_ptr(self.span, ty_usize, Mutability::Mutable)\n-    }\n-\n-    fn layout_ptr(&self) -> P<Ty> {\n-        let layout = self.cx.path(self.span, vec![\n-            self.alloc,\n-            Ident::from_str(\"heap\"),\n-            Ident::from_str(\"Layout\"),\n-        ]);\n-        let layout = self.cx.ty_path(layout);\n-        self.cx.ty_ptr(self.span, layout, Mutability::Mutable)\n-    }\n-\n-    fn alloc_err_ptr(&self) -> P<Ty> {\n-        let err = self.cx.path(self.span, vec![\n-            self.alloc,\n-            Ident::from_str(\"heap\"),\n-            Ident::from_str(\"AllocErr\"),\n+    fn ptr_void(&self) -> P<Ty> {\n+        let void = self.cx.path(self.span, vec![\n+            self.core,\n+            Ident::from_str(\"alloc\"),\n+            Ident::from_str(\"Void\"),\n         ]);\n-        let err = self.cx.ty_path(err);\n-        self.cx.ty_ptr(self.span, err, Mutability::Mutable)\n+        let ty_void = self.cx.ty_path(void);\n+        self.cx.ty_ptr(self.span, ty_void, Mutability::Mutable)\n     }\n }"}, {"sha": "969086815ded4777c3cc6939d9e3be4fc58be6b0", "filename": "src/librustc_allocator/lib.rs", "status": "modified", "additions": 2, "deletions": 37, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Flibrustc_allocator%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Flibrustc_allocator%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Flib.rs?ref=86753ce1cc520bfe50ae89f09ec47f313ce900eb", "patch": "@@ -23,51 +23,21 @@ pub static ALLOCATOR_METHODS: &[AllocatorMethod] = &[\n         inputs: &[AllocatorTy::Layout],\n         output: AllocatorTy::ResultPtr,\n     },\n-    AllocatorMethod {\n-        name: \"oom\",\n-        inputs: &[AllocatorTy::AllocErr],\n-        output: AllocatorTy::Bang,\n-    },\n     AllocatorMethod {\n         name: \"dealloc\",\n         inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout],\n         output: AllocatorTy::Unit,\n     },\n-    AllocatorMethod {\n-        name: \"usable_size\",\n-        inputs: &[AllocatorTy::LayoutRef],\n-        output: AllocatorTy::UsizePair,\n-    },\n     AllocatorMethod {\n         name: \"realloc\",\n-        inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Layout],\n+        inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Usize],\n         output: AllocatorTy::ResultPtr,\n     },\n     AllocatorMethod {\n         name: \"alloc_zeroed\",\n         inputs: &[AllocatorTy::Layout],\n         output: AllocatorTy::ResultPtr,\n     },\n-    AllocatorMethod {\n-        name: \"alloc_excess\",\n-        inputs: &[AllocatorTy::Layout],\n-        output: AllocatorTy::ResultExcess,\n-    },\n-    AllocatorMethod {\n-        name: \"realloc_excess\",\n-        inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Layout],\n-        output: AllocatorTy::ResultExcess,\n-    },\n-    AllocatorMethod {\n-        name: \"grow_in_place\",\n-        inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Layout],\n-        output: AllocatorTy::ResultUnit,\n-    },\n-    AllocatorMethod {\n-        name: \"shrink_in_place\",\n-        inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Layout],\n-        output: AllocatorTy::ResultUnit,\n-    },\n ];\n \n pub struct AllocatorMethod {\n@@ -77,14 +47,9 @@ pub struct AllocatorMethod {\n }\n \n pub enum AllocatorTy {\n-    AllocErr,\n-    Bang,\n     Layout,\n-    LayoutRef,\n     Ptr,\n-    ResultExcess,\n     ResultPtr,\n-    ResultUnit,\n     Unit,\n-    UsizePair,\n+    Usize,\n }"}, {"sha": "ffebb959ebfde494abdd58d680e008da35f76f18", "filename": "src/librustc_trans/allocator.rs", "status": "modified", "additions": 3, "deletions": 25, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Flibrustc_trans%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Flibrustc_trans%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fallocator.rs?ref=86753ce1cc520bfe50ae89f09ec47f313ce900eb", "patch": "@@ -30,7 +30,6 @@ pub(crate) unsafe fn trans(tcx: TyCtxt, mods: &ModuleLlvm, kind: AllocatorKind)\n     };\n     let i8 = llvm::LLVMInt8TypeInContext(llcx);\n     let i8p = llvm::LLVMPointerType(i8, 0);\n-    let usizep = llvm::LLVMPointerType(usize, 0);\n     let void = llvm::LLVMVoidTypeInContext(llcx);\n \n     for method in ALLOCATOR_METHODS {\n@@ -41,40 +40,19 @@ pub(crate) unsafe fn trans(tcx: TyCtxt, mods: &ModuleLlvm, kind: AllocatorKind)\n                     args.push(usize); // size\n                     args.push(usize); // align\n                 }\n-                AllocatorTy::LayoutRef => args.push(i8p),\n                 AllocatorTy::Ptr => args.push(i8p),\n-                AllocatorTy::AllocErr => args.push(i8p),\n+                AllocatorTy::Usize => args.push(usize),\n \n-                AllocatorTy::Bang |\n-                AllocatorTy::ResultExcess |\n                 AllocatorTy::ResultPtr |\n-                AllocatorTy::ResultUnit |\n-                AllocatorTy::UsizePair |\n                 AllocatorTy::Unit => panic!(\"invalid allocator arg\"),\n             }\n         }\n         let output = match method.output {\n-            AllocatorTy::UsizePair => {\n-                args.push(usizep); // min\n-                args.push(usizep); // max\n-                None\n-            }\n-            AllocatorTy::Bang => None,\n-            AllocatorTy::ResultExcess => {\n-                args.push(i8p); // excess_ptr\n-                args.push(i8p); // err_ptr\n-                Some(i8p)\n-            }\n-            AllocatorTy::ResultPtr => {\n-                args.push(i8p); // err_ptr\n-                Some(i8p)\n-            }\n-            AllocatorTy::ResultUnit => Some(i8),\n+            AllocatorTy::ResultPtr => Some(i8p),\n             AllocatorTy::Unit => None,\n \n-            AllocatorTy::AllocErr |\n             AllocatorTy::Layout |\n-            AllocatorTy::LayoutRef |\n+            AllocatorTy::Usize |\n             AllocatorTy::Ptr => panic!(\"invalid allocator output\"),\n         };\n         let ty = llvm::LLVMFunctionType(output.unwrap_or(void),"}, {"sha": "335dc7e0412326f44a88ab99460af4b142792d9c", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 54, "deletions": 99, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=86753ce1cc520bfe50ae89f09ec47f313ce900eb", "patch": "@@ -21,7 +21,7 @@\n #[doc(hidden)]\n #[allow(unused_attributes)]\n pub mod __default_lib_allocator {\n-    use super::{System, Layout, Alloc, AllocErr, CannotReallocInPlace};\n+    use super::{System, Layout, GlobalAlloc, Void};\n     // for symbol names src/librustc/middle/allocator.rs\n     // for signatures src/librustc_allocator/lib.rs\n \n@@ -30,131 +30,86 @@ pub mod __default_lib_allocator {\n \n     #[no_mangle]\n     #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rdl_alloc(size: usize,\n-                                     align: usize,\n-                                     _err: *mut u8) -> *mut u8 {\n+    pub unsafe extern fn __rdl_alloc(size: usize, align: usize) -> *mut u8 {\n         let layout = Layout::from_size_align_unchecked(size, align);\n-        match System.alloc(layout) {\n-            Ok(p) => p,\n-            Err(AllocErr) => 0 as *mut u8,\n-        }\n-    }\n-\n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rdl_oom(err: *const u8) -> ! {\n-        System.oom((*(err as *const AllocErr)).clone())\n+        System.alloc(layout) as *mut u8\n     }\n \n     #[no_mangle]\n     #[rustc_std_internal_symbol]\n     pub unsafe extern fn __rdl_dealloc(ptr: *mut u8,\n                                        size: usize,\n                                        align: usize) {\n-        System.dealloc(ptr, Layout::from_size_align_unchecked(size, align))\n-    }\n-\n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rdl_usable_size(layout: *const u8,\n-                                           min: *mut usize,\n-                                           max: *mut usize) {\n-        let pair = System.usable_size(&*(layout as *const Layout));\n-        *min = pair.0;\n-        *max = pair.1;\n+        System.dealloc(ptr as *mut Void, Layout::from_size_align_unchecked(size, align))\n     }\n \n     #[no_mangle]\n     #[rustc_std_internal_symbol]\n     pub unsafe extern fn __rdl_realloc(ptr: *mut u8,\n                                        old_size: usize,\n-                                       old_align: usize,\n-                                       new_size: usize,\n-                                       new_align: usize,\n-                                       _err: *mut u8) -> *mut u8 {\n-        let old_layout = Layout::from_size_align_unchecked(old_size, old_align);\n-        let new_layout = Layout::from_size_align_unchecked(new_size, new_align);\n-        match System.realloc(ptr, old_layout, new_layout) {\n-            Ok(p) => p,\n-            Err(AllocErr) => 0 as *mut u8,\n-        }\n+                                       align: usize,\n+                                       new_size: usize) -> *mut u8 {\n+        let old_layout = Layout::from_size_align_unchecked(old_size, align);\n+        System.realloc(ptr as *mut Void, old_layout, new_size) as *mut u8\n     }\n \n     #[no_mangle]\n     #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rdl_alloc_zeroed(size: usize,\n-                                            align: usize,\n-                                            _err: *mut u8) -> *mut u8 {\n+    pub unsafe extern fn __rdl_alloc_zeroed(size: usize, align: usize) -> *mut u8 {\n         let layout = Layout::from_size_align_unchecked(size, align);\n-        match System.alloc_zeroed(layout) {\n-            Ok(p) => p,\n-            Err(AllocErr) => 0 as *mut u8,\n-        }\n+        System.alloc_zeroed(layout) as *mut u8\n     }\n \n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rdl_alloc_excess(size: usize,\n-                                            align: usize,\n-                                            excess: *mut usize,\n-                                            _err: *mut u8) -> *mut u8 {\n-        let layout = Layout::from_size_align_unchecked(size, align);\n-        match System.alloc_excess(layout) {\n-            Ok(p) => {\n-                *excess = p.1;\n-                p.0\n-            }\n-            Err(AllocErr) => 0 as *mut u8,\n+    #[cfg(stage0)]\n+    pub mod stage0 {\n+        #[no_mangle]\n+        #[rustc_std_internal_symbol]\n+        pub unsafe extern fn __rdl_usable_size(_layout: *const u8,\n+                                               _min: *mut usize,\n+                                               _max: *mut usize) {\n+            unimplemented!()\n         }\n-    }\n \n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rdl_realloc_excess(ptr: *mut u8,\n-                                              old_size: usize,\n-                                              old_align: usize,\n-                                              new_size: usize,\n-                                              new_align: usize,\n-                                              excess: *mut usize,\n-                                              _err: *mut u8) -> *mut u8 {\n-        let old_layout = Layout::from_size_align_unchecked(old_size, old_align);\n-        let new_layout = Layout::from_size_align_unchecked(new_size, new_align);\n-        match System.realloc_excess(ptr, old_layout, new_layout) {\n-            Ok(p) => {\n-                *excess = p.1;\n-                p.0\n-            }\n-            Err(AllocErr) => 0 as *mut u8,\n+        #[no_mangle]\n+        #[rustc_std_internal_symbol]\n+        pub unsafe extern fn __rdl_alloc_excess(_size: usize,\n+                                                _align: usize,\n+                                                _excess: *mut usize,\n+                                                _err: *mut u8) -> *mut u8 {\n+            unimplemented!()\n         }\n-    }\n \n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rdl_grow_in_place(ptr: *mut u8,\n-                                             old_size: usize,\n-                                             old_align: usize,\n-                                             new_size: usize,\n-                                             new_align: usize) -> u8 {\n-        let old_layout = Layout::from_size_align_unchecked(old_size, old_align);\n-        let new_layout = Layout::from_size_align_unchecked(new_size, new_align);\n-        match System.grow_in_place(ptr, old_layout, new_layout) {\n-            Ok(()) => 1,\n-            Err(CannotReallocInPlace) => 0,\n+        #[no_mangle]\n+        #[rustc_std_internal_symbol]\n+        pub unsafe extern fn __rdl_realloc_excess(_ptr: *mut u8,\n+                                                  _old_size: usize,\n+                                                  _old_align: usize,\n+                                                  _new_size: usize,\n+                                                  _new_align: usize,\n+                                                  _excess: *mut usize,\n+                                                  _err: *mut u8) -> *mut u8 {\n+            unimplemented!()\n         }\n-    }\n \n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rdl_shrink_in_place(ptr: *mut u8,\n-                                               old_size: usize,\n-                                               old_align: usize,\n-                                               new_size: usize,\n-                                               new_align: usize) -> u8 {\n-        let old_layout = Layout::from_size_align_unchecked(old_size, old_align);\n-        let new_layout = Layout::from_size_align_unchecked(new_size, new_align);\n-        match System.shrink_in_place(ptr, old_layout, new_layout) {\n-            Ok(()) => 1,\n-            Err(CannotReallocInPlace) => 0,\n+        #[no_mangle]\n+        #[rustc_std_internal_symbol]\n+        pub unsafe extern fn __rdl_grow_in_place(_ptr: *mut u8,\n+                                                 _old_size: usize,\n+                                                 _old_align: usize,\n+                                                 _new_size: usize,\n+                                                 _new_align: usize) -> u8 {\n+            unimplemented!()\n         }\n+\n+        #[no_mangle]\n+        #[rustc_std_internal_symbol]\n+        pub unsafe extern fn __rdl_shrink_in_place(_ptr: *mut u8,\n+                                                   _old_size: usize,\n+                                                   _old_align: usize,\n+                                                   _new_size: usize,\n+                                                   _new_align: usize) -> u8 {\n+            unimplemented!()\n+        }\n+\n     }\n }"}, {"sha": "7243155b1c3da0a980c868a87adebf00e0b33989", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=86753ce1cc520bfe50ae89f09ec47f313ce900eb", "patch": "@@ -1 +1 @@\n-Subproject commit 6ceaaa4b0176a200e4bbd347d6a991ab6c776ede\n+Subproject commit 7243155b1c3da0a980c868a87adebf00e0b33989"}, {"sha": "c3fc3e5452c4f97d76f8b0542d8b0278a43ad819", "filename": "src/rustllvm/llvm-rebuild-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Frustllvm%2Fllvm-rebuild-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Frustllvm%2Fllvm-rebuild-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-rebuild-trigger?ref=86753ce1cc520bfe50ae89f09ec47f313ce900eb", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be (optionally) cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2018-03-10\n+2018-04-05"}, {"sha": "140cad22f34e42ae52b5b94ffe1b071fd9c3ff41", "filename": "src/test/compile-fail/allocator/not-an-allocator.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Ftest%2Fcompile-fail%2Fallocator%2Fnot-an-allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Ftest%2Fcompile-fail%2Fallocator%2Fnot-an-allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fallocator%2Fnot-an-allocator.rs?ref=86753ce1cc520bfe50ae89f09ec47f313ce900eb", "patch": "@@ -12,15 +12,9 @@\n \n #[global_allocator]\n static A: usize = 0;\n-//~^ the trait bound `&usize:\n-//~| the trait bound `&usize:\n-//~| the trait bound `&usize:\n-//~| the trait bound `&usize:\n-//~| the trait bound `&usize:\n-//~| the trait bound `&usize:\n-//~| the trait bound `&usize:\n-//~| the trait bound `&usize:\n-//~| the trait bound `&usize:\n-//~| the trait bound `&usize:\n+//~^ the trait bound `usize:\n+//~| the trait bound `usize:\n+//~| the trait bound `usize:\n+//~| the trait bound `usize:\n \n fn main() {}"}, {"sha": "20b87028fd1b3d2f255c77069c252f9140d093b5", "filename": "src/test/run-make-fulldeps/std-core-cycle/bar.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Ftest%2Frun-make-fulldeps%2Fstd-core-cycle%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Ftest%2Frun-make-fulldeps%2Fstd-core-cycle%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fstd-core-cycle%2Fbar.rs?ref=86753ce1cc520bfe50ae89f09ec47f313ce900eb", "patch": "@@ -11,16 +11,16 @@\n #![feature(allocator_api)]\n #![crate_type = \"rlib\"]\n \n-use std::heap::*;\n+use std::alloc::*;\n \n pub struct A;\n \n-unsafe impl<'a> Alloc for &'a A {\n-    unsafe fn alloc(&mut self, _: Layout) -> Result<*mut u8, AllocErr> {\n+unsafe impl GlobalAlloc for A {\n+    unsafe fn alloc(&self, _: Layout) -> *mut Void {\n         loop {}\n     }\n \n-    unsafe fn dealloc(&mut self, _ptr: *mut u8, _: Layout) {\n+    unsafe fn dealloc(&self, _ptr: *mut Void, _: Layout) {\n         loop {}\n     }\n }"}, {"sha": "95096efc7ef681edf5e6f0f575a6fb4447b9d4a6", "filename": "src/test/run-pass/allocator/auxiliary/custom.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom.rs?ref=86753ce1cc520bfe50ae89f09ec47f313ce900eb", "patch": "@@ -13,18 +13,18 @@\n #![feature(heap_api, allocator_api)]\n #![crate_type = \"rlib\"]\n \n-use std::heap::{Alloc, System, AllocErr, Layout};\n+use std::heap::{GlobalAlloc, System, Layout, Void};\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n pub struct A(pub AtomicUsize);\n \n-unsafe impl<'a> Alloc for &'a A {\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+unsafe impl GlobalAlloc for A {\n+    unsafe fn alloc(&self, layout: Layout) -> *mut Void {\n         self.0.fetch_add(1, Ordering::SeqCst);\n         System.alloc(layout)\n     }\n \n-    unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n+    unsafe fn dealloc(&self, ptr: *mut Void, layout: Layout) {\n         self.0.fetch_add(1, Ordering::SeqCst);\n         System.dealloc(ptr, layout)\n     }"}, {"sha": "f7b2fd73c87b9c93fc1bcab2e3563bc41974a8f4", "filename": "src/test/run-pass/allocator/custom.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom.rs?ref=86753ce1cc520bfe50ae89f09ec47f313ce900eb", "patch": "@@ -15,20 +15,20 @@\n \n extern crate helper;\n \n-use std::heap::{Heap, Alloc, System, Layout, AllocErr};\n+use std::alloc::{self, Global, Alloc, System, Layout, Void};\n use std::sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n \n static HITS: AtomicUsize = ATOMIC_USIZE_INIT;\n \n struct A;\n \n-unsafe impl<'a> Alloc for &'a A {\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+unsafe impl alloc::GlobalAlloc for A {\n+    unsafe fn alloc(&self, layout: Layout) -> *mut Void {\n         HITS.fetch_add(1, Ordering::SeqCst);\n         System.alloc(layout)\n     }\n \n-    unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n+    unsafe fn dealloc(&self, ptr: *mut Void, layout: Layout) {\n         HITS.fetch_add(1, Ordering::SeqCst);\n         System.dealloc(ptr, layout)\n     }\n@@ -45,10 +45,10 @@ fn main() {\n     unsafe {\n         let layout = Layout::from_size_align(4, 2).unwrap();\n \n-        let ptr = Heap.alloc(layout.clone()).unwrap();\n+        let ptr = Global.alloc(layout.clone()).unwrap();\n         helper::work_with(&ptr);\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 1);\n-        Heap.dealloc(ptr, layout.clone());\n+        Global.dealloc(ptr, layout.clone());\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 2);\n \n         let s = String::with_capacity(10);"}, {"sha": "78d604a710857370e55107997ab1851bf46d8ea2", "filename": "src/test/run-pass/allocator/xcrate-use.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use.rs?ref=86753ce1cc520bfe50ae89f09ec47f313ce900eb", "patch": "@@ -17,7 +17,7 @@\n extern crate custom;\n extern crate helper;\n \n-use std::heap::{Heap, Alloc, System, Layout};\n+use std::alloc::{Global, Alloc, System, Layout};\n use std::sync::atomic::{Ordering, ATOMIC_USIZE_INIT};\n \n #[global_allocator]\n@@ -28,10 +28,10 @@ fn main() {\n         let n = GLOBAL.0.load(Ordering::SeqCst);\n         let layout = Layout::from_size_align(4, 2).unwrap();\n \n-        let ptr = Heap.alloc(layout.clone()).unwrap();\n+        let ptr = Global.alloc(layout.clone()).unwrap();\n         helper::work_with(&ptr);\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 1);\n-        Heap.dealloc(ptr, layout.clone());\n+        Global.dealloc(ptr, layout.clone());\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n \n         let ptr = System.alloc(layout.clone()).unwrap();"}, {"sha": "52eb963efdb744813692047aa3e99bcf55a19069", "filename": "src/test/run-pass/allocator/xcrate-use2.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86753ce1cc520bfe50ae89f09ec47f313ce900eb/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use2.rs?ref=86753ce1cc520bfe50ae89f09ec47f313ce900eb", "patch": "@@ -19,7 +19,7 @@ extern crate custom;\n extern crate custom_as_global;\n extern crate helper;\n \n-use std::heap::{Heap, Alloc, System, Layout};\n+use std::alloc::{Global, Alloc, GlobalAlloc, System, Layout};\n use std::sync::atomic::{Ordering, ATOMIC_USIZE_INIT};\n \n static GLOBAL: custom::A = custom::A(ATOMIC_USIZE_INIT);\n@@ -30,25 +30,25 @@ fn main() {\n         let layout = Layout::from_size_align(4, 2).unwrap();\n \n         // Global allocator routes to the `custom_as_global` global\n-        let ptr = Heap.alloc(layout.clone()).unwrap();\n+        let ptr = Global.alloc(layout.clone()).unwrap();\n         helper::work_with(&ptr);\n         assert_eq!(custom_as_global::get(), n + 1);\n-        Heap.dealloc(ptr, layout.clone());\n+        Global.dealloc(ptr, layout.clone());\n         assert_eq!(custom_as_global::get(), n + 2);\n \n         // Usage of the system allocator avoids all globals\n-        let ptr = System.alloc(layout.clone()).unwrap();\n+        let ptr = System.alloc(layout.clone());\n         helper::work_with(&ptr);\n         assert_eq!(custom_as_global::get(), n + 2);\n         System.dealloc(ptr, layout.clone());\n         assert_eq!(custom_as_global::get(), n + 2);\n \n         // Usage of our personal allocator doesn't affect other instances\n-        let ptr = (&GLOBAL).alloc(layout.clone()).unwrap();\n+        let ptr = GLOBAL.alloc(layout.clone());\n         helper::work_with(&ptr);\n         assert_eq!(custom_as_global::get(), n + 2);\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), 1);\n-        (&GLOBAL).dealloc(ptr, layout);\n+        GLOBAL.dealloc(ptr, layout);\n         assert_eq!(custom_as_global::get(), n + 2);\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), 2);\n     }"}]}