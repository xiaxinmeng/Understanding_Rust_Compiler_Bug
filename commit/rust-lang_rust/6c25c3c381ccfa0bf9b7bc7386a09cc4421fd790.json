{"sha": "6c25c3c381ccfa0bf9b7bc7386a09cc4421fd790", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjMjVjM2MzODFjY2ZhMGJmOWI3YmM3Mzg2YTA5Y2M0NDIxZmQ3OTA=", "commit": {"author": {"name": "Andy Weiss", "email": "dragonbear@google.com", "date": "2020-04-08T04:20:37Z"}, "committer": {"name": "Andy Weiss", "email": "dragonbear@google.com", "date": "2020-04-22T04:07:43Z"}, "message": "Lint for holding locks across await points\n\nFixes #4226\n\nThis introduces the lint await_holding_lock. For async functions, we iterate\nover all types in generator_interior_types and look for types named MutexGuard,\nRwLockReadGuard, or RwLockWriteGuard. If we find one then we emit a lint.", "tree": {"sha": "091199d964f148334f4460744a597cd2a7047625", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/091199d964f148334f4460744a597cd2a7047625"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c25c3c381ccfa0bf9b7bc7386a09cc4421fd790", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c25c3c381ccfa0bf9b7bc7386a09cc4421fd790", "html_url": "https://github.com/rust-lang/rust/commit/6c25c3c381ccfa0bf9b7bc7386a09cc4421fd790", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c25c3c381ccfa0bf9b7bc7386a09cc4421fd790/comments", "author": {"login": "rokob", "id": 831355, "node_id": "MDQ6VXNlcjgzMTM1NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/831355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rokob", "html_url": "https://github.com/rokob", "followers_url": "https://api.github.com/users/rokob/followers", "following_url": "https://api.github.com/users/rokob/following{/other_user}", "gists_url": "https://api.github.com/users/rokob/gists{/gist_id}", "starred_url": "https://api.github.com/users/rokob/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rokob/subscriptions", "organizations_url": "https://api.github.com/users/rokob/orgs", "repos_url": "https://api.github.com/users/rokob/repos", "events_url": "https://api.github.com/users/rokob/events{/privacy}", "received_events_url": "https://api.github.com/users/rokob/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rokob", "id": 831355, "node_id": "MDQ6VXNlcjgzMTM1NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/831355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rokob", "html_url": "https://github.com/rokob", "followers_url": "https://api.github.com/users/rokob/followers", "following_url": "https://api.github.com/users/rokob/following{/other_user}", "gists_url": "https://api.github.com/users/rokob/gists{/gist_id}", "starred_url": "https://api.github.com/users/rokob/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rokob/subscriptions", "organizations_url": "https://api.github.com/users/rokob/orgs", "repos_url": "https://api.github.com/users/rokob/repos", "events_url": "https://api.github.com/users/rokob/events{/privacy}", "received_events_url": "https://api.github.com/users/rokob/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3cb9b8376b79837ec525da017871ab1859292dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3cb9b8376b79837ec525da017871ab1859292dc", "html_url": "https://github.com/rust-lang/rust/commit/b3cb9b8376b79837ec525da017871ab1859292dc"}], "stats": {"total": 189, "additions": 189, "deletions": 0}, "files": [{"sha": "abd7167502b9c2ff3fa04d97debeaa0704642fbb", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c25c3c381ccfa0bf9b7bc7386a09cc4421fd790/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/6c25c3c381ccfa0bf9b7bc7386a09cc4421fd790/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=6c25c3c381ccfa0bf9b7bc7386a09cc4421fd790", "patch": "@@ -1188,6 +1188,7 @@ Released 2018-09-13\n [`assertions_on_constants`]: https://rust-lang.github.io/rust-clippy/master/index.html#assertions_on_constants\n [`assign_op_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#assign_op_pattern\n [`assign_ops`]: https://rust-lang.github.io/rust-clippy/master/index.html#assign_ops\n+[`await_holding_lock`]: https://rust-lang.github.io/rust-clippy/master/index.html#await_holding_lock\n [`bad_bit_mask`]: https://rust-lang.github.io/rust-clippy/master/index.html#bad_bit_mask\n [`blacklisted_name`]: https://rust-lang.github.io/rust-clippy/master/index.html#blacklisted_name\n [`block_in_if_condition_expr`]: https://rust-lang.github.io/rust-clippy/master/index.html#block_in_if_condition_expr"}, {"sha": "ae4c5bfc9f7cc9e0ad5a9465647906c336a5d033", "filename": "clippy_lints/src/await_holding_lock.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/6c25c3c381ccfa0bf9b7bc7386a09cc4421fd790/clippy_lints%2Fsrc%2Fawait_holding_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c25c3c381ccfa0bf9b7bc7386a09cc4421fd790/clippy_lints%2Fsrc%2Fawait_holding_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fawait_holding_lock.rs?ref=6c25c3c381ccfa0bf9b7bc7386a09cc4421fd790", "patch": "@@ -0,0 +1,100 @@\n+use crate::utils::span_lint_and_note;\n+use if_chain::if_chain;\n+use rustc_hir::intravisit::FnKind;\n+use rustc_hir::{Body, FnDecl, HirId, IsAsync};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{Span, Symbol};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to await while holding a MutexGuard.\n+    ///\n+    /// **Why is this bad?** This is almost certainly an error which can result\n+    /// in a deadlock because the reactor will invoke code not visible to the\n+    /// currently visible scope.\n+    ///\n+    /// **Known problems:** Detects only specifically named guard types:\n+    /// MutexGuard, RwLockReadGuard, and RwLockWriteGuard.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// use std::sync::Mutex;\n+    ///\n+    /// async fn foo(x: &Mutex<u32>) {\n+    ///   let guard = x.lock().unwrap();\n+    ///   *guard += 1;\n+    ///   bar.await;\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// use std::sync::Mutex;\n+    ///\n+    /// async fn foo(x: &Mutex<u32>) {\n+    ///   {\n+    ///     let guard = x.lock().unwrap();\n+    ///     *guard += 1;\n+    ///   }\n+    ///   bar.await;\n+    /// }\n+    /// ```\n+    pub AWAIT_HOLDING_LOCK,\n+    pedantic,\n+    \"Inside an async function, holding a MutexGuard while calling await\"\n+}\n+\n+const MUTEX_GUARD_TYPES: [&str; 3] = [\"MutexGuard\", \"RwLockReadGuard\", \"RwLockWriteGuard\"];\n+\n+declare_lint_pass!(AwaitHoldingLock => [AWAIT_HOLDING_LOCK]);\n+\n+impl LateLintPass<'_, '_> for AwaitHoldingLock {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'_, '_>,\n+        fn_kind: FnKind<'_>,\n+        _: &FnDecl<'_>,\n+        _: &Body<'_>,\n+        span: Span,\n+        _: HirId,\n+    ) {\n+        if !is_async_fn(fn_kind) {\n+            return;\n+        }\n+\n+        for ty_clause in &cx.tables.generator_interior_types {\n+            if_chain! {\n+              if let rustc_middle::ty::Adt(adt, _) = ty_clause.ty.kind;\n+              if let Some(&sym) = cx.get_def_path(adt.did).iter().last();\n+              if is_symbol_mutex_guard(sym);\n+              then {\n+                span_lint_and_note(\n+                      cx,\n+                      AWAIT_HOLDING_LOCK,\n+                      ty_clause.span,\n+                      \"this MutexGuard is held across an 'await' point\",\n+                      ty_clause.scope_span.unwrap_or(span),\n+                      \"these are all the await points this lock is held through\"\n+                    );\n+              }\n+            }\n+        }\n+    }\n+}\n+\n+fn is_async_fn(fn_kind: FnKind<'_>) -> bool {\n+    fn_kind.header().map_or(false, |h| match h.asyncness {\n+        IsAsync::Async => true,\n+        IsAsync::NotAsync => false,\n+    })\n+}\n+\n+fn is_symbol_mutex_guard(sym: Symbol) -> bool {\n+    let sym_str = sym.as_str();\n+    for ty in &MUTEX_GUARD_TYPES {\n+        if sym_str == *ty {\n+            return true;\n+        }\n+    }\n+    false\n+}"}, {"sha": "dee4188b75f38d840fc6345a0a5328a782139050", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c25c3c381ccfa0bf9b7bc7386a09cc4421fd790/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c25c3c381ccfa0bf9b7bc7386a09cc4421fd790/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=6c25c3c381ccfa0bf9b7bc7386a09cc4421fd790", "patch": "@@ -177,6 +177,7 @@ mod assertions_on_constants;\n mod assign_ops;\n mod atomic_ordering;\n mod attrs;\n+mod await_holding_lock;\n mod bit_mask;\n mod blacklisted_name;\n mod block_in_if_condition;\n@@ -497,6 +498,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &attrs::INLINE_ALWAYS,\n         &attrs::UNKNOWN_CLIPPY_LINTS,\n         &attrs::USELESS_ATTRIBUTE,\n+        &await_holding_lock::AWAIT_HOLDING_LOCK,\n         &bit_mask::BAD_BIT_MASK,\n         &bit_mask::INEFFECTIVE_BIT_MASK,\n         &bit_mask::VERBOSE_BIT_MASK,\n@@ -864,6 +866,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     ]);\n     // end register lints, do not remove this comment, it\u2019s used in `update_lints`\n \n+    store.register_late_pass(|| box await_holding_lock::AwaitHoldingLock);\n     store.register_late_pass(|| box serde_api::SerdeAPI);\n     store.register_late_pass(|| box utils::internal_lints::CompilerLintFunctions::new());\n     store.register_late_pass(|| box utils::internal_lints::LintWithoutLintPass::default());\n@@ -1102,6 +1105,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n \n     store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n         LintId::of(&attrs::INLINE_ALWAYS),\n+        LintId::of(&await_holding_lock::AWAIT_HOLDING_LOCK),\n         LintId::of(&checked_conversions::CHECKED_CONVERSIONS),\n         LintId::of(&copies::MATCH_SAME_ARMS),\n         LintId::of(&copies::SAME_FUNCTIONS_IN_IF_CONDITION),"}, {"sha": "2c466aa20c6753ed94fca3b8fba86fd7f5c780fc", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c25c3c381ccfa0bf9b7bc7386a09cc4421fd790/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c25c3c381ccfa0bf9b7bc7386a09cc4421fd790/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=6c25c3c381ccfa0bf9b7bc7386a09cc4421fd790", "patch": "@@ -52,6 +52,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"assign_ops\",\n     },\n+    Lint {\n+        name: \"await_holding_lock\",\n+        group: \"pedantic\",\n+        desc: \"Inside an async function, holding a MutexGuard while calling await\",\n+        deprecation: None,\n+        module: \"await_holding_lock\",\n+    },\n     Lint {\n         name: \"bad_bit_mask\",\n         group: \"correctness\","}, {"sha": "fab31f37ffcc0039b6c3951db7e34a13a9429f92", "filename": "tests/ui/await_holding_lock.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6c25c3c381ccfa0bf9b7bc7386a09cc4421fd790/tests%2Fui%2Fawait_holding_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c25c3c381ccfa0bf9b7bc7386a09cc4421fd790/tests%2Fui%2Fawait_holding_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_lock.rs?ref=6c25c3c381ccfa0bf9b7bc7386a09cc4421fd790", "patch": "@@ -0,0 +1,42 @@\n+// edition:2018\n+#![warn(clippy::await_holding_lock)]\n+\n+use std::sync::Mutex;\n+\n+async fn bad(x: &Mutex<u32>) -> u32 {\n+    let guard = x.lock().unwrap();\n+    baz().await\n+}\n+\n+async fn good(x: &Mutex<u32>) -> u32 {\n+    {\n+        let guard = x.lock().unwrap();\n+        let y = *guard + 1;\n+    }\n+    baz().await;\n+    let guard = x.lock().unwrap();\n+    47\n+}\n+\n+async fn baz() -> u32 {\n+    42\n+}\n+\n+async fn also_bad(x: &Mutex<u32>) -> u32 {\n+    let first = baz().await;\n+\n+    let guard = x.lock().unwrap();\n+\n+    let second = baz().await;\n+\n+    let third = baz().await;\n+\n+    first + second + third\n+}\n+\n+fn main() {\n+    let m = Mutex::new(100);\n+    good(&m);\n+    bad(&m);\n+    also_bad(&m);\n+}"}, {"sha": "8d4fd0c20a9c4faeacca33b151400a466934bbf1", "filename": "tests/ui/await_holding_lock.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6c25c3c381ccfa0bf9b7bc7386a09cc4421fd790/tests%2Fui%2Fawait_holding_lock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c25c3c381ccfa0bf9b7bc7386a09cc4421fd790/tests%2Fui%2Fawait_holding_lock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_lock.stderr?ref=6c25c3c381ccfa0bf9b7bc7386a09cc4421fd790", "patch": "@@ -0,0 +1,35 @@\n+error: this MutexGuard is held across an 'await' point\n+  --> $DIR/await_holding_lock.rs:7:9\n+   |\n+LL |     let guard = x.lock().unwrap();\n+   |         ^^^^^\n+   |\n+   = note: `-D clippy::await-holding-lock` implied by `-D warnings`\n+note: these are all the await points this lock is held through\n+  --> $DIR/await_holding_lock.rs:7:5\n+   |\n+LL | /     let guard = x.lock().unwrap();\n+LL | |     baz().await\n+LL | | }\n+   | |_^\n+\n+error: this MutexGuard is held across an 'await' point\n+  --> $DIR/await_holding_lock.rs:28:9\n+   |\n+LL |     let guard = x.lock().unwrap();\n+   |         ^^^^^\n+   |\n+note: these are all the await points this lock is held through\n+  --> $DIR/await_holding_lock.rs:28:5\n+   |\n+LL | /     let guard = x.lock().unwrap();\n+LL | |\n+LL | |     let second = baz().await;\n+LL | |\n+...  |\n+LL | |     first + second + third\n+LL | | }\n+   | |_^\n+\n+error: aborting due to 2 previous errors\n+"}]}