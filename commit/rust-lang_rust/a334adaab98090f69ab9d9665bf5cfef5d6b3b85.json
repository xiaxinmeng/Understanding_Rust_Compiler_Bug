{"sha": "a334adaab98090f69ab9d9665bf5cfef5d6b3b85", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzMzRhZGFhYjk4MDkwZjY5YWI5ZDk2NjViZjVjZmVmNWQ2YjNiODU=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-08-05T01:46:56Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-08-09T17:59:13Z"}, "message": "Thread \"self\" through the stack.  Backwarding!  Closes #702.", "tree": {"sha": "46c03182ab443486095b5e439977967b8906795a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46c03182ab443486095b5e439977967b8906795a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a334adaab98090f69ab9d9665bf5cfef5d6b3b85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a334adaab98090f69ab9d9665bf5cfef5d6b3b85", "html_url": "https://github.com/rust-lang/rust/commit/a334adaab98090f69ab9d9665bf5cfef5d6b3b85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a334adaab98090f69ab9d9665bf5cfef5d6b3b85/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2cac5afa36d55818f741f48029d350da35be511", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2cac5afa36d55818f741f48029d350da35be511", "html_url": "https://github.com/rust-lang/rust/commit/b2cac5afa36d55818f741f48029d350da35be511"}], "stats": {"total": 158, "additions": 87, "deletions": 71}, "files": [{"sha": "985d995121b04125d1f0e698b8090d93df7a22f0", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 78, "deletions": 20, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/a334adaab98090f69ab9d9665bf5cfef5d6b3b85/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a334adaab98090f69ab9d9665bf5cfef5d6b3b85/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=a334adaab98090f69ab9d9665bf5cfef5d6b3b85", "patch": "@@ -6464,6 +6464,44 @@ fn trans_fn(cx: @local_ctxt, sp: &span, f: &ast::_fn, llfndecl: ValueRef,\n     log_fn_time(cx.ccx, str::connect_ivec(cx.path, \"::\"), start, end);\n }\n \n+// Update a self-stack structure ([[wrapper_self_pair], self_pair*]) to\n+// [[backwarding_vtbl*, inner_obj_body*], outer_obj*].\n+//\n+// We do this when we're receiving the outer object in a forwarding function\n+// via the llenv argument, and we want the forwarding function to call a\n+// method on a \"self\" that's inner-obj-shaped, but we also want to hold onto\n+// the outer obj for potential use later by backwarding functions.\n+fn populate_self_stack(bcx: @block_ctxt,\n+                       self_stack: ValueRef, outer_obj: ValueRef,\n+                       backwarding_vtbl: ValueRef, inner_obj_body: ValueRef)\n+    -> ValueRef {\n+\n+    // Drop the outer obj into the second slot.\n+    let self_pair_ptr = bcx.build.GEP(self_stack,\n+                            ~[C_int(0),\n+                              C_int(1)]);\n+    bcx.build.Store(outer_obj, self_pair_ptr);\n+\n+    // Drop in the backwarding vtbl.\n+    let wrapper_pair = bcx.build.GEP(self_stack,\n+                                     ~[C_int(0),\n+                                       C_int(0)]);\n+    let wrapper_vtbl_ptr = bcx.build.GEP(wrapper_pair,\n+                                         ~[C_int(0),\n+                                           C_int(0)]);\n+    let backwarding_vtbl_cast =\n+        bcx.build.PointerCast(backwarding_vtbl, T_ptr(T_empty_struct()));\n+    bcx.build.Store(backwarding_vtbl_cast, wrapper_vtbl_ptr);\n+\n+    // Drop in the inner obj body.\n+    let wrapper_body_ptr = bcx.build.GEP(wrapper_pair,\n+                                         ~[C_int(0),\n+                                           C_int(1)]);\n+    bcx.build.Store(inner_obj_body, wrapper_body_ptr);\n+\n+    ret self_stack;\n+}\n+\n // process_bkwding_mthd: Create the backwarding function that appears in a\n // backwarding vtable slot.\n //\n@@ -6505,8 +6543,24 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     let lltop = bcx.llbb;\n \n     // The self-object will arrive in the backwarding function via the llenv\n-    // argument.\n-    let llself_obj_ptr = fcx.llenv;\n+    // argument, but we need to jump past the first item in the self-stack to\n+    // get to the one we really want.\n+\n+    // Cast to self-stack's type.\n+    let llenv = bcx.build.PointerCast(\n+        fcx.llenv,\n+        T_ptr(T_struct(~[cx.ccx.rust_object_type,\n+                         T_ptr(cx.ccx.rust_object_type)])));\n+\n+    let llself_obj_ptr = bcx.build.GEP(llenv,\n+                                       ~[C_int(0),\n+                                         C_int(1)]);\n+    llself_obj_ptr = bcx.build.Load(llself_obj_ptr);\n+\n+    // Cast it back to the type of fcx.llenv, tho, so LLVM won't complain.\n+    // TODO: could we just cast this to T_ptr(cx.ccx.rust_object_type)?\n+    llself_obj_ptr = bcx.build.PointerCast(llself_obj_ptr,\n+                                           val_ty(fcx.llenv));\n \n     // The 'llretptr' that will arrive in the backwarding function we're\n     // creating also needs to be the correct type.  Cast it to the method's\n@@ -6521,7 +6575,7 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // at it.\n     let llouter_obj_vtbl =\n         bcx.build.GEP(llself_obj_ptr,\n-                      ~[C_int(0), C_int(1)]);\n+                      ~[C_int(0), C_int(abi::obj_field_vtbl)]);\n     llouter_obj_vtbl = bcx.build.Load(llouter_obj_vtbl);\n \n     // Get the index of the method we want.\n@@ -6627,20 +6681,6 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // argument.\n     let llself_obj_ptr = fcx.llenv;\n \n-    // Grab the vtable out of the self-object and replace it with the\n-    // backwarding vtable.  FIXME (issue #702): Not quite ready to turn this\n-    // behavior on yet.\n-\n-    // let llself_obj_vtbl =\n-    //     bcx.build.GEP(llself_obj_ptr, ~[C_int(0),\n-    //                                     C_int(abi::obj_field_vtbl)]);\n-    // let llbv = bcx.build.PointerCast(backwarding_vtbl,\n-    //                                  T_ptr(T_empty_struct()));\n-    // bcx.build.Store(llbv, llself_obj_vtbl);\n-\n-    // NB: llself_obj is now a freakish combination of outer object body\n-    // and backwarding (inner-object) vtable.\n-\n     // The 'llretptr' that will arrive in the forwarding function we're\n     // creating also needs to be the correct type.  Cast it to the method's\n     // return type, if necessary.\n@@ -6710,6 +6750,11 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n                       ~[C_int(0), C_int(abi::obj_field_vtbl)]);\n     llinner_obj_vtbl = bcx.build.Load(llinner_obj_vtbl);\n \n+    let llinner_obj_body =\n+        bcx.build.GEP(llinner_obj.val,\n+                      ~[C_int(0), C_int(abi::obj_field_box)]);\n+    llinner_obj_body = bcx.build.Load(llinner_obj_body);\n+\n     // Get the index of the method we want.\n     let ix: uint = 0u;\n     alt ty::struct(bcx_tcx(bcx), inner_obj_ty) {\n@@ -6741,10 +6786,23 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n         bcx.build.PointerCast(llorig_mthd, T_ptr(T_ptr(llorig_mthd_ty)));\n     llorig_mthd = bcx.build.Load(llorig_mthd);\n \n+    // Set up the self-stack.\n+    let self_stack = alloca(bcx, T_struct(~[cx.ccx.rust_object_type,\n+                                            T_ptr(cx.ccx.rust_object_type)]));\n+    self_stack = populate_self_stack(bcx,\n+                                     self_stack,\n+                                     llself_obj_ptr,\n+                                     backwarding_vtbl,\n+                                     llinner_obj_body);\n+\n+    // Cast self_stack back to the type of fcx.llenv to make LLVM happy.\n+    // TODO: could we just cast this to T_ptr(cx.ccx.rust_object_type)?\n+    self_stack = bcx.build.PointerCast(self_stack,\n+                                       val_ty(fcx.llenv));\n+\n     // Set up the three implicit arguments to the original method we'll need\n     // to call.\n-    let self_arg = llself_obj_ptr;\n-    let llorig_mthd_args: ValueRef[] = ~[llretptr, fcx.lltaskptr, self_arg];\n+    let llorig_mthd_args: ValueRef[] = ~[llretptr, fcx.lltaskptr, self_stack];\n \n     // Copy the explicit arguments that are being passed into the forwarding\n     // function (they're in fcx.llargs) to llorig_mthd_args.\n@@ -6759,7 +6817,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n         a += 1u;\n     }\n \n-    // And, finally, call the original method.\n+    // And, finally, call the original (inner) method.\n     bcx.build.FastCall(llorig_mthd, llorig_mthd_args);\n \n     bcx.build.RetVoid();"}, {"sha": "5166e1acab9a4ef1de3ff5c8ea35c45f6b669bd4", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a334adaab98090f69ab9d9665bf5cfef5d6b3b85/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a334adaab98090f69ab9d9665bf5cfef5d6b3b85/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=a334adaab98090f69ab9d9665bf5cfef5d6b3b85", "patch": "@@ -536,6 +536,10 @@ fn set_struct_body(t: TypeRef, elts: &TypeRef[]) {\n \n fn T_empty_struct() -> TypeRef { ret T_struct(~[]); }\n \n+// NB: This will return something different every time it's called. If\n+// you need a generic object type that matches the type of your\n+// existing objects, use ccx.rust_object_type.  Calling\n+// T_rust_object() again will return a different one.\n fn T_rust_object() -> TypeRef {\n     let t = T_named_struct(\"rust_object\");\n     let e = T_ptr(T_empty_struct());"}, {"sha": "3a806a6e399d2496c32b431775ca0bce1a54d7df", "filename": "src/test/run-pass/anon-obj-backwarding-2.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a334adaab98090f69ab9d9665bf5cfef5d6b3b85/src%2Ftest%2Frun-pass%2Fanon-obj-backwarding-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a334adaab98090f69ab9d9665bf5cfef5d6b3b85/src%2Ftest%2Frun-pass%2Fanon-obj-backwarding-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fanon-obj-backwarding-2.rs?ref=a334adaab98090f69ab9d9665bf5cfef5d6b3b85", "patch": "@@ -1,6 +1,3 @@\n-//xfail-stage1\n-//xfail-stage2\n-//xfail-stage3\n use std;\n \n fn main() {\n@@ -17,18 +14,10 @@ fn main() {\n         with my_a\n     };\n \n-    // These should all be 2.\n-    log_err my_a.foo();\n-    log_err my_a.bar();\n-    log_err my_b.foo();\n-\n-    // This works fine.  It sends us to foo on my_b, which forwards to\n-    // foo on my_a.\n-    log_err my_b.baz();\n-\n-    // Currently segfaults.  It forwards us to bar on my_a, which\n-    // backwards us to foo on my_b, which forwards us to foo on my_a\n-    // -- or, at least, that's how it should work.\n-    log_err my_b.bar();\n+    assert my_a.foo() == 2;\n+    assert my_a.bar() == 2;\n+    assert my_b.foo() == 2;\n+    assert my_b.baz() == 2;\n+    assert my_b.bar() == 2;\n \n }"}, {"sha": "4b8664eed9300656b9d6158ca6470656b6822aff", "filename": "src/test/run-pass/anon-obj-backwarding.rs", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a334adaab98090f69ab9d9665bf5cfef5d6b3b85/src%2Ftest%2Frun-pass%2Fanon-obj-backwarding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a334adaab98090f69ab9d9665bf5cfef5d6b3b85/src%2Ftest%2Frun-pass%2Fanon-obj-backwarding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fanon-obj-backwarding.rs?ref=a334adaab98090f69ab9d9665bf5cfef5d6b3b85", "patch": "@@ -1,6 +1,3 @@\n-//xfail-stage1\n-//xfail-stage2\n-//xfail-stage3\n use std;\n \n fn main() {\n@@ -21,38 +18,6 @@ fn main() {\n             my_inner\n         };\n \n-    log_err my_inner.z();\n     assert (my_inner.z() == 3u);\n-    log_err my_outer.z();\n     assert (my_outer.z() == 3u);\n }\n-\n-/*\n-   Here, when we make the self-call to self.m() in inner, we're going\n-   back through the outer \"self\".  That outer \"self\" has 5 methods in\n-   its vtable: a, b, m, n, z.  But the method z has already been\n-   compiled, and at the time it was compiled, it expected \"self\" to\n-   only have three methods in its vtable: a, m, and z.  So, the method\n-   z thinks that \"self.m()\" means \"look up method #1 (indexing from 0)\n-   in my vtable and call it\".  That means that it'll call method #1 on\n-   the larger vtable that it thinks is \"self\", and method #1 at that\n-   point is b.\n-\n-   So, when we call my_inner.z(), we get 3, which is what we'd\n-   expect.  When we call my_outer.z(), we should also get 3, because\n-   at no point is z being overridden.\n-\n-   To fix this bug, we need to make the vtable slots on the inner\n-   object match whatever the object being passed in at runtime has.\n-   My first instinct was to change the vtable to match the runtime\n-   object, but vtables are already baked into RO memory.  So, instead,\n-   we're going to tweak the object being passed in at runtime to match\n-   the vtable that inner already has.  That is, it needs to only have\n-   a, m, and z slots in its vtable, and each one of those slots will\n-   forward to the *outer* object's a, m, and z slots, respectively.\n-   From there they will either head right back to inner, or they'll be\n-   overridden.\n-\n-   Adding support for this is issue #702.\n-\n-*/"}]}