{"sha": "45921648699a42fa1d257f6a54d2dbe9e46b0e20", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1OTIxNjQ4Njk5YTQyZmExZDI1N2Y2YTU0ZDJkYmU5ZTQ2YjBlMjA=", "commit": {"author": {"name": "root", "email": "root@localhost", "date": "2014-07-18T22:02:30Z"}, "committer": {"name": "root", "email": "root@localhost", "date": "2014-07-18T22:28:45Z"}, "message": "Write multibyte case for str Chars iterator in-line\n\nThanks to comments from @alexcrichton, write the next/next_back function\nbodies without nested functions in a more top-to-bottom flow style.\n\nAlso improve comment style and motivate the unsafe blocks with comments.", "tree": {"sha": "c40cb662c410793ed87444edcad3df2ce9aff53d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c40cb662c410793ed87444edcad3df2ce9aff53d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45921648699a42fa1d257f6a54d2dbe9e46b0e20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45921648699a42fa1d257f6a54d2dbe9e46b0e20", "html_url": "https://github.com/rust-lang/rust/commit/45921648699a42fa1d257f6a54d2dbe9e46b0e20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45921648699a42fa1d257f6a54d2dbe9e46b0e20/comments", "author": {"login": "invalid-email-address", "id": 148100, "node_id": "MDQ6VXNlcjE0ODEwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/148100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/invalid-email-address", "html_url": "https://github.com/invalid-email-address", "followers_url": "https://api.github.com/users/invalid-email-address/followers", "following_url": "https://api.github.com/users/invalid-email-address/following{/other_user}", "gists_url": "https://api.github.com/users/invalid-email-address/gists{/gist_id}", "starred_url": "https://api.github.com/users/invalid-email-address/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/invalid-email-address/subscriptions", "organizations_url": "https://api.github.com/users/invalid-email-address/orgs", "repos_url": "https://api.github.com/users/invalid-email-address/repos", "events_url": "https://api.github.com/users/invalid-email-address/events{/privacy}", "received_events_url": "https://api.github.com/users/invalid-email-address/received_events", "type": "User", "site_admin": false}, "committer": {"login": "invalid-email-address", "id": 148100, "node_id": "MDQ6VXNlcjE0ODEwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/148100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/invalid-email-address", "html_url": "https://github.com/invalid-email-address", "followers_url": "https://api.github.com/users/invalid-email-address/followers", "following_url": "https://api.github.com/users/invalid-email-address/following{/other_user}", "gists_url": "https://api.github.com/users/invalid-email-address/gists{/gist_id}", "starred_url": "https://api.github.com/users/invalid-email-address/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/invalid-email-address/subscriptions", "organizations_url": "https://api.github.com/users/invalid-email-address/orgs", "repos_url": "https://api.github.com/users/invalid-email-address/repos", "events_url": "https://api.github.com/users/invalid-email-address/events{/privacy}", "received_events_url": "https://api.github.com/users/invalid-email-address/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbb299ad9840d02c52eefbd9989b5b18b51a7b8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbb299ad9840d02c52eefbd9989b5b18b51a7b8d", "html_url": "https://github.com/rust-lang/rust/commit/bbb299ad9840d02c52eefbd9989b5b18b51a7b8d"}], "stats": {"total": 107, "additions": 48, "deletions": 59}, "files": [{"sha": "293c0118af1eaba8159ae09c2119b9528c66d17b", "filename": "src/libcore/str.rs", "status": "modified", "additions": 48, "deletions": 59, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/45921648699a42fa1d257f6a54d2dbe9e46b0e20/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45921648699a42fa1d257f6a54d2dbe9e46b0e20/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=45921648699a42fa1d257f6a54d2dbe9e46b0e20", "patch": "@@ -133,40 +133,35 @@ impl<'a> Iterator<char> for Chars<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<char> {\n         // Decode UTF-8, using the valid UTF-8 invariant\n-        #[inline]\n-        fn decode_multibyte<'a>(x: u8, it: &mut slice::Items<'a, u8>) -> char {\n-            // NOTE: Performance is very sensitive to the exact formulation here\n-            // Decode from a byte combination out of: [[[x y] z] w]\n-            let init = utf8_first_byte!(x, 2);\n-            let y = unwrap_or_0(it.next());\n-            let mut ch = utf8_acc_cont_byte!(init, y);\n-            if x >= 0xE0 {\n-                /* [[x y z] w] case\n-                 * 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid */\n-                let z = unwrap_or_0(it.next());\n-                let y_z = utf8_acc_cont_byte!((y & CONT_MASK) as u32, z);\n-                ch = init << 12 | y_z;\n-                if x >= 0xF0 {\n-                    /* [x y z w] case\n-                     * use only the lower 3 bits of `init` */\n-                    let w = unwrap_or_0(it.next());\n-                    ch = (init & 7) << 18 | utf8_acc_cont_byte!(y_z, w);\n-                }\n-            }\n-            unsafe {\n-                mem::transmute(ch)\n+        let x = match self.iter.next() {\n+            None => return None,\n+            Some(&next_byte) if next_byte < 128 => return Some(next_byte as char),\n+            Some(&next_byte) => next_byte,\n+        };\n+\n+        // Multibyte case follows\n+        // Decode from a byte combination out of: [[[x y] z] w]\n+        // NOTE: Performance is sensitive to the exact formulation here\n+        let init = utf8_first_byte!(x, 2);\n+        let y = unwrap_or_0(self.iter.next());\n+        let mut ch = utf8_acc_cont_byte!(init, y);\n+        if x >= 0xE0 {\n+            // [[x y z] w] case\n+            // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid\n+            let z = unwrap_or_0(self.iter.next());\n+            let y_z = utf8_acc_cont_byte!((y & CONT_MASK) as u32, z);\n+            ch = init << 12 | y_z;\n+            if x >= 0xF0 {\n+                // [x y z w] case\n+                // use only the lower 3 bits of `init`\n+                let w = unwrap_or_0(self.iter.next());\n+                ch = (init & 7) << 18 | utf8_acc_cont_byte!(y_z, w);\n             }\n         }\n \n-        match self.iter.next() {\n-            None => None,\n-            Some(&next_byte) => {\n-                if next_byte < 128 {\n-                    Some(next_byte as char)\n-                } else {\n-                    Some(decode_multibyte(next_byte, &mut self.iter))\n-                }\n-            }\n+        // str invariant says `ch` is a valid Unicode Scalar Value\n+        unsafe {\n+            Some(mem::transmute(ch))\n         }\n     }\n \n@@ -180,38 +175,32 @@ impl<'a> Iterator<char> for Chars<'a> {\n impl<'a> DoubleEndedIterator<char> for Chars<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<char> {\n-        #[inline]\n-        fn decode_multibyte_back<'a>(w: u8, it: &mut slice::Items<'a, u8>) -> char {\n-            // Decode from a byte combination out of: [x [y [z w]]]\n-            let mut ch;\n-            let z = unwrap_or_0(it.next_back());\n-            ch = utf8_first_byte!(z, 2);\n-            if utf8_is_cont_byte!(z) {\n-                let y = unwrap_or_0(it.next_back());\n-                ch = utf8_first_byte!(y, 3);\n-                if utf8_is_cont_byte!(y) {\n-                    let x = unwrap_or_0(it.next_back());\n-                    ch = utf8_first_byte!(x, 4);\n-                    ch = utf8_acc_cont_byte!(ch, y);\n-                }\n-                ch = utf8_acc_cont_byte!(ch, z);\n-            }\n-            ch = utf8_acc_cont_byte!(ch, w);\n+        let w = match self.iter.next_back() {\n+            None => return None,\n+            Some(&back_byte) if back_byte < 128 => return Some(back_byte as char),\n+            Some(&back_byte) => back_byte,\n+        };\n \n-            unsafe {\n-                mem::transmute(ch)\n+        // Multibyte case follows\n+        // Decode from a byte combination out of: [x [y [z w]]]\n+        let mut ch;\n+        let z = unwrap_or_0(self.iter.next_back());\n+        ch = utf8_first_byte!(z, 2);\n+        if utf8_is_cont_byte!(z) {\n+            let y = unwrap_or_0(self.iter.next_back());\n+            ch = utf8_first_byte!(y, 3);\n+            if utf8_is_cont_byte!(y) {\n+                let x = unwrap_or_0(self.iter.next_back());\n+                ch = utf8_first_byte!(x, 4);\n+                ch = utf8_acc_cont_byte!(ch, y);\n             }\n+            ch = utf8_acc_cont_byte!(ch, z);\n         }\n+        ch = utf8_acc_cont_byte!(ch, w);\n \n-        match self.iter.next_back() {\n-            None => None,\n-            Some(&back_byte) => {\n-                if back_byte < 128 {\n-                    Some(back_byte as char)\n-                } else {\n-                    Some(decode_multibyte_back(back_byte, &mut self.iter))\n-                }\n-            }\n+        // str invariant says `ch` is a valid Unicode Scalar Value\n+        unsafe {\n+            Some(mem::transmute(ch))\n         }\n     }\n }"}]}