{"sha": "d41058ed39fcd7e15ce9d0e7705643da85c94271", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0MTA1OGVkMzlmY2Q3ZTE1Y2U5ZDBlNzcwNTY0M2RhODVjOTQyNzE=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-05-24T08:12:22Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-06-18T19:06:46Z"}, "message": "Don't require mutable StringReader to emit lexer errors\n\nTeach StringReader how to emit errors for arbitrary spans, so we don't\nneed to modify peek_span. This allows for emitting errors without having\na &mut borrow of the StringReader.", "tree": {"sha": "61a682dd630799844d3252276ac2c37a25c241eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61a682dd630799844d3252276ac2c37a25c241eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d41058ed39fcd7e15ce9d0e7705643da85c94271", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d41058ed39fcd7e15ce9d0e7705643da85c94271", "html_url": "https://github.com/rust-lang/rust/commit/d41058ed39fcd7e15ce9d0e7705643da85c94271", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d41058ed39fcd7e15ce9d0e7705643da85c94271/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f481db211dd03b0d8aad4ce29e211f78de340d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f481db211dd03b0d8aad4ce29e211f78de340d4", "html_url": "https://github.com/rust-lang/rust/commit/0f481db211dd03b0d8aad4ce29e211f78de340d4"}], "stats": {"total": 94, "additions": 52, "deletions": 42}, "files": [{"sha": "348445149a4154e9822286117894fbdd38f3c283", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 52, "deletions": 42, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/d41058ed39fcd7e15ce9d0e7705643da85c94271/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d41058ed39fcd7e15ce9d0e7705643da85c94271/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=d41058ed39fcd7e15ce9d0e7705643da85c94271", "patch": "@@ -70,10 +70,10 @@ impl<'a> Reader for StringReader<'a> {\n         ret_val\n     }\n     fn fatal(&self, m: &str) -> ! {\n-        self.span_diagnostic.span_fatal(self.peek_span, m)\n+        self.fatal_span(self.peek_span, m)\n     }\n     fn err(&self, m: &str) {\n-        self.span_diagnostic.span_err(self.peek_span, m)\n+        self.err_span(self.peek_span, m)\n     }\n     fn peek(&self) -> TokenAndSpan {\n         // FIXME(pcwalton): Bad copy!\n@@ -137,43 +137,52 @@ impl<'a> StringReader<'a> {\n         self.curr == Some(c)\n     }\n \n-    /// Report a lexical error spanning [`from_pos`, `to_pos`)\n-    fn fatal_span(&mut self, from_pos: BytePos, to_pos: BytePos, m: &str) -> ! {\n-        self.peek_span = codemap::mk_sp(from_pos, to_pos);\n-        self.fatal(m);\n+    /// Report a fatal lexical error with a given span.\n+    pub fn fatal_span(&self, sp: Span, m: &str) -> ! {\n+        self.span_diagnostic.span_fatal(sp, m)\n     }\n \n-    fn err_span(&mut self, from_pos: BytePos, to_pos: BytePos, m: &str) {\n-        self.peek_span = codemap::mk_sp(from_pos, to_pos);\n-        self.err(m);\n+    /// Report a lexical error with a given span.\n+    pub fn err_span(&self, sp: Span, m: &str) {\n+        self.span_diagnostic.span_err(sp, m)\n+    }\n+\n+    /// Report a fatal error spanning [`from_pos`, `to_pos`).\n+    fn fatal_span_(&self, from_pos: BytePos, to_pos: BytePos, m: &str) -> ! {\n+        self.fatal_span(codemap::mk_sp(from_pos, to_pos), m)\n+    }\n+\n+    /// Report a lexical error spanning [`from_pos`, `to_pos`).\n+    fn err_span_(&self, from_pos: BytePos, to_pos: BytePos, m: &str) {\n+        self.err_span(codemap::mk_sp(from_pos, to_pos), m)\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending an\n     /// escaped character to the error message\n-    fn fatal_span_char(&mut self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) -> ! {\n+    fn fatal_span_char(&self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) -> ! {\n         let mut m = m.to_string();\n         m.push_str(\": \");\n         char::escape_default(c, |c| m.push_char(c));\n-        self.fatal_span(from_pos, to_pos, m.as_slice());\n+        self.fatal_span_(from_pos, to_pos, m.as_slice());\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending an\n     /// escaped character to the error message\n-    fn err_span_char(&mut self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) {\n+    fn err_span_char(&self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) {\n         let mut m = m.to_string();\n         m.push_str(\": \");\n         char::escape_default(c, |c| m.push_char(c));\n-        self.err_span(from_pos, to_pos, m.as_slice());\n+        self.err_span_(from_pos, to_pos, m.as_slice());\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending the\n     /// offending string to the error message\n-    fn fatal_span_verbose(&mut self, from_pos: BytePos, to_pos: BytePos, mut m: String) -> ! {\n+    fn fatal_span_verbose(&self, from_pos: BytePos, to_pos: BytePos, mut m: String) -> ! {\n         m.push_str(\": \");\n         let from = self.byte_offset(from_pos).to_uint();\n         let to = self.byte_offset(to_pos).to_uint();\n         m.push_str(self.filemap.src.as_slice().slice(from, to));\n-        self.fatal_span(from_pos, to_pos, m.as_slice());\n+        self.fatal_span_(from_pos, to_pos, m.as_slice());\n     }\n \n     /// Advance peek_tok and peek_span to refer to the next token, and\n@@ -369,7 +378,7 @@ impl<'a> StringReader<'a> {\n                     \"unterminated block comment\"\n                 };\n                 let last_bpos = self.last_pos;\n-                self.fatal_span(start_bpos, last_bpos, msg);\n+                self.fatal_span_(start_bpos, last_bpos, msg);\n             } else if self.curr_is('/') && self.nextch_is('*') {\n                 level += 1;\n                 self.bump();\n@@ -421,7 +430,7 @@ impl<'a> StringReader<'a> {\n                 return Some(rslt);\n             } else {\n                 let last_bpos = self.last_pos;\n-                self.err_span(start_bpos, last_bpos, \"scan_exponent: bad fp literal\");\n+                self.err_span_(start_bpos, last_bpos, \"scan_exponent: bad fp literal\");\n                 rslt.push_str(\"1\"); // arbitrary placeholder exponent\n                 return Some(rslt);\n             }\n@@ -447,9 +456,10 @@ impl<'a> StringReader<'a> {\n \n     fn check_float_base(&mut self, start_bpos: BytePos, last_bpos: BytePos, base: uint) {\n         match base {\n-          16u => self.err_span(start_bpos, last_bpos, \"hexadecimal float literal is not supported\"),\n-          8u => self.err_span(start_bpos, last_bpos, \"octal float literal is not supported\"),\n-          2u => self.err_span(start_bpos, last_bpos, \"binary float literal is not supported\"),\n+          16u => self.err_span_(start_bpos, last_bpos,\n+                                \"hexadecimal float literal is not supported\"),\n+          8u => self.err_span_(start_bpos, last_bpos, \"octal float literal is not supported\"),\n+          2u => self.err_span_(start_bpos, last_bpos, \"binary float literal is not supported\"),\n           _ => ()\n         }\n     }\n@@ -509,15 +519,15 @@ impl<'a> StringReader<'a> {\n             }\n             if num_str.len() == 0u {\n                 let last_bpos = self.last_pos;\n-                self.err_span(start_bpos, last_bpos, \"no valid digits found for number\");\n+                self.err_span_(start_bpos, last_bpos, \"no valid digits found for number\");\n                 num_str = \"1\".to_string();\n             }\n             let parsed = match from_str_radix::<u64>(num_str.as_slice(),\n                                                      base as uint) {\n                 Some(p) => p,\n                 None => {\n                     let last_bpos = self.last_pos;\n-                    self.err_span(start_bpos, last_bpos, \"int literal is too large\");\n+                    self.err_span_(start_bpos, last_bpos, \"int literal is too large\");\n                     1\n                 }\n             };\n@@ -573,7 +583,7 @@ impl<'a> StringReader<'a> {\n                 return token::LIT_FLOAT(str_to_ident(num_str.as_slice()), ast::TyF128);\n             }\n             let last_bpos = self.last_pos;\n-            self.err_span(start_bpos, last_bpos, \"expected `f32`, `f64` or `f128` suffix\");\n+            self.err_span_(start_bpos, last_bpos, \"expected `f32`, `f64` or `f128` suffix\");\n         }\n         if is_float {\n             let last_bpos = self.last_pos;\n@@ -583,15 +593,15 @@ impl<'a> StringReader<'a> {\n         } else {\n             if num_str.len() == 0u {\n                 let last_bpos = self.last_pos;\n-                self.err_span(start_bpos, last_bpos, \"no valid digits found for number\");\n+                self.err_span_(start_bpos, last_bpos, \"no valid digits found for number\");\n                 num_str = \"1\".to_string();\n             }\n             let parsed = match from_str_radix::<u64>(num_str.as_slice(),\n                                                      base as uint) {\n                 Some(p) => p,\n                 None => {\n                     let last_bpos = self.last_pos;\n-                    self.err_span(start_bpos, last_bpos, \"int literal is too large\");\n+                    self.err_span_(start_bpos, last_bpos, \"int literal is too large\");\n                     1\n                 }\n             };\n@@ -609,11 +619,11 @@ impl<'a> StringReader<'a> {\n         for _ in range(0, n_hex_digits) {\n             if self.is_eof() {\n                 let last_bpos = self.last_pos;\n-                self.fatal_span(start_bpos, last_bpos, \"unterminated numeric character escape\");\n+                self.fatal_span_(start_bpos, last_bpos, \"unterminated numeric character escape\");\n             }\n             if self.curr_is(delim) {\n                 let last_bpos = self.last_pos;\n-                self.err_span(start_bpos, last_bpos, \"numeric character escape is too short\");\n+                self.err_span_(start_bpos, last_bpos, \"numeric character escape is too short\");\n                 break;\n             }\n             let c = self.curr.unwrap_or('\\x00');\n@@ -630,7 +640,7 @@ impl<'a> StringReader<'a> {\n             Some(x) => x,\n             None => {\n                 let last_bpos = self.last_pos;\n-                self.err_span(start_bpos, last_bpos, \"illegal numeric character escape\");\n+                self.err_span_(start_bpos, last_bpos, \"illegal numeric character escape\");\n                 '?'\n             }\n         }\n@@ -856,16 +866,16 @@ impl<'a> StringReader<'a> {\n                 let last_bpos = self.last_pos;\n                 if token::is_keyword(token::keywords::Self,\n                                      keyword_checking_token) {\n-                    self.err_span(start,\n-                                  last_bpos,\n-                                  \"invalid lifetime name: 'self \\\n-                                   is no longer a special lifetime\");\n+                    self.err_span_(start,\n+                                   last_bpos,\n+                                   \"invalid lifetime name: 'self \\\n+                                    is no longer a special lifetime\");\n                 } else if token::is_any_keyword(keyword_checking_token) &&\n                     !token::is_keyword(token::keywords::Static,\n                                        keyword_checking_token) {\n-                    self.err_span(start,\n-                                  last_bpos,\n-                                  \"invalid lifetime name\");\n+                    self.err_span_(start,\n+                                   last_bpos,\n+                                   \"invalid lifetime name\");\n                 }\n                 return token::LIFETIME(ident);\n             }\n@@ -922,8 +932,8 @@ impl<'a> StringReader<'a> {\n                 while !self_.curr_is('\"') {\n                     if self_.is_eof() {\n                         let last_pos = self_.last_pos;\n-                        self_.fatal_span(start, last_pos,\n-                                         \"unterminated double quote byte string\");\n+                        self_.fatal_span_(start, last_pos,\n+                                          \"unterminated double quote byte string\");\n                     }\n \n                     let ch_start = self_.last_pos;\n@@ -947,7 +957,7 @@ impl<'a> StringReader<'a> {\n \n                 if self_.is_eof() {\n                     let last_pos = self_.last_pos;\n-                    self_.fatal_span(start_bpos, last_pos, \"unterminated raw string\");\n+                    self_.fatal_span_(start_bpos, last_pos, \"unterminated raw string\");\n                 } else if !self_.curr_is('\"') {\n                     let last_pos = self_.last_pos;\n                     let ch = self_.curr.unwrap();\n@@ -963,7 +973,7 @@ impl<'a> StringReader<'a> {\n                     match self_.curr {\n                         None => {\n                             let last_pos = self_.last_pos;\n-                            self_.fatal_span(start_bpos, last_pos, \"unterminated raw string\")\n+                            self_.fatal_span_(start_bpos, last_pos, \"unterminated raw string\")\n                         },\n                         Some('\"') => {\n                             content_end_bpos = self_.last_pos;\n@@ -997,7 +1007,7 @@ impl<'a> StringReader<'a> {\n             while !self.curr_is('\"') {\n                 if self.is_eof() {\n                     let last_bpos = self.last_pos;\n-                    self.fatal_span(start_bpos, last_bpos, \"unterminated double quote string\");\n+                    self.fatal_span_(start_bpos, last_bpos, \"unterminated double quote string\");\n                 }\n \n                 let ch_start = self.last_pos;\n@@ -1020,7 +1030,7 @@ impl<'a> StringReader<'a> {\n \n             if self.is_eof() {\n                 let last_bpos = self.last_pos;\n-                self.fatal_span(start_bpos, last_bpos, \"unterminated raw string\");\n+                self.fatal_span_(start_bpos, last_bpos, \"unterminated raw string\");\n             } else if !self.curr_is('\"') {\n                 let last_bpos = self.last_pos;\n                 let curr_char = self.curr.unwrap();\n@@ -1035,7 +1045,7 @@ impl<'a> StringReader<'a> {\n             'outer: loop {\n                 if self.is_eof() {\n                     let last_bpos = self.last_pos;\n-                    self.fatal_span(start_bpos, last_bpos, \"unterminated raw string\");\n+                    self.fatal_span_(start_bpos, last_bpos, \"unterminated raw string\");\n                 }\n                 if self.curr_is('\"') {\n                     content_end_bpos = self.last_pos;"}]}