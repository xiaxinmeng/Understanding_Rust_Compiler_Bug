{"sha": "cd50b4e0b14b698e2217947727b4ae9f39e758b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkNTBiNGUwYjE0YjY5OGUyMjE3OTQ3NzI3YjRhZTlmMzllNzU4Yjg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-03T13:01:13Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-04T20:06:33Z"}, "message": "Generalize the code so we can handle multiple supertraits.\nFixes #10596. Fixes #22279.", "tree": {"sha": "78e4af9ae38933eceefd62a07c4df2a35b9a21e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78e4af9ae38933eceefd62a07c4df2a35b9a21e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd50b4e0b14b698e2217947727b4ae9f39e758b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd50b4e0b14b698e2217947727b4ae9f39e758b8", "html_url": "https://github.com/rust-lang/rust/commit/cd50b4e0b14b698e2217947727b4ae9f39e758b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd50b4e0b14b698e2217947727b4ae9f39e758b8/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc9ae36dba3bcacdec98af1495d99593bfc59cac", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc9ae36dba3bcacdec98af1495d99593bfc59cac", "html_url": "https://github.com/rust-lang/rust/commit/bc9ae36dba3bcacdec98af1495d99593bfc59cac"}], "stats": {"total": 282, "additions": 178, "deletions": 104}, "files": [{"sha": "f46cac308287ba769d34378ddc19421d5aee3233", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd50b4e0b14b698e2217947727b4ae9f39e758b8/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd50b4e0b14b698e2217947727b4ae9f39e758b8/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=cd50b4e0b14b698e2217947727b4ae9f39e758b8", "patch": "@@ -280,7 +280,11 @@ pub struct VtableBuiltinData<N> {\n /// for the object type `Foo`.\n #[derive(PartialEq,Eq,Clone)]\n pub struct VtableObjectData<'tcx> {\n+    /// the object type `Foo`.\n     pub object_ty: Ty<'tcx>,\n+\n+    /// `Foo` upcast to the obligation trait. This will be some supertrait of `Foo`.\n+    pub upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n }\n \n /// Creates predicate obligations from the generic bounds."}, {"sha": "a4aa685c090209481d39cc1181b41b8261a13fab", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 36, "deletions": 27, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/cd50b4e0b14b698e2217947727b4ae9f39e758b8/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd50b4e0b14b698e2217947727b4ae9f39e758b8/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=cd50b4e0b14b698e2217947727b4ae9f39e758b8", "patch": "@@ -1260,19 +1260,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                poly_trait_ref.repr(self.tcx()));\n \n         // see whether the object trait can be upcast to the trait we are looking for\n-        let obligation_def_id = obligation.predicate.def_id();\n-        let upcast_trait_ref = match util::upcast(self.tcx(), poly_trait_ref, obligation_def_id) {\n-            Some(r) => r,\n-            None => { return; }\n-        };\n-\n-        debug!(\"assemble_candidates_from_object_ty: upcast_trait_ref={}\",\n-               upcast_trait_ref.repr(self.tcx()));\n-\n-        // check whether the upcast version of the trait-ref matches what we are looking for\n-        if let Ok(()) = self.infcx.probe(|_| self.match_poly_trait_ref(obligation,\n-                                                                       upcast_trait_ref.clone())) {\n-            debug!(\"assemble_candidates_from_object_ty: matched, pushing candidate\");\n+        let upcast_trait_refs = self.upcast(poly_trait_ref, obligation);\n+        if upcast_trait_refs.len() > 1 {\n+            // can be upcast in many ways; need more type information\n+            candidates.ambiguous = true;\n+        } else if upcast_trait_refs.len() == 1 {\n             candidates.vec.push(ObjectCandidate);\n         }\n     }\n@@ -2063,28 +2055,24 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n         };\n \n-        let obligation_def_id = obligation.predicate.def_id();\n-        let upcast_trait_ref = match util::upcast(self.tcx(),\n-                                                  poly_trait_ref.clone(),\n-                                                  obligation_def_id) {\n-            Some(r) => r,\n-            None => {\n-                self.tcx().sess.span_bug(obligation.cause.span,\n-                                         &format!(\"unable to upcast from {} to {}\",\n-                                                  poly_trait_ref.repr(self.tcx()),\n-                                                  obligation_def_id.repr(self.tcx())));\n-            }\n-        };\n+        // Upcast the object type to the obligation type. There must\n+        // be exactly one applicable trait-reference; if this were not\n+        // the case, we would have reported an ambiguity error rather\n+        // than successfully selecting one of the candidates.\n+        let upcast_trait_refs = self.upcast(poly_trait_ref.clone(), obligation);\n+        assert_eq!(upcast_trait_refs.len(), 1);\n+        let upcast_trait_ref = upcast_trait_refs.into_iter().next().unwrap();\n \n-        match self.match_poly_trait_ref(obligation, upcast_trait_ref) {\n+        match self.match_poly_trait_ref(obligation, upcast_trait_ref.clone()) {\n             Ok(()) => { }\n             Err(()) => {\n                 self.tcx().sess.span_bug(obligation.cause.span,\n                                          \"failed to match trait refs\");\n             }\n         }\n \n-        VtableObjectData { object_ty: self_ty }\n+        VtableObjectData { object_ty: self_ty,\n+                           upcast_trait_ref: upcast_trait_ref }\n     }\n \n     fn confirm_fn_pointer_candidate(&mut self,\n@@ -2501,6 +2489,27 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             obligation.cause.clone()\n         }\n     }\n+\n+    /// Upcasts an object trait-reference into those that match the obligation.\n+    fn upcast(&mut self, obj_trait_ref: ty::PolyTraitRef<'tcx>, obligation: &TraitObligation<'tcx>)\n+              -> Vec<ty::PolyTraitRef<'tcx>>\n+    {\n+        debug!(\"upcast(obj_trait_ref={}, obligation={})\",\n+               obj_trait_ref.repr(self.tcx()),\n+               obligation.repr(self.tcx()));\n+\n+        let obligation_def_id = obligation.predicate.def_id();\n+        let mut upcast_trait_refs = util::upcast(self.tcx(), obj_trait_ref, obligation_def_id);\n+\n+        // retain only those upcast versions that match the trait-ref we are looking for\n+        upcast_trait_refs.retain(|upcast_trait_ref| {\n+            let upcast_trait_ref = upcast_trait_ref.clone();\n+            self.infcx.probe(|_| self.match_poly_trait_ref(obligation, upcast_trait_ref)).is_ok()\n+        });\n+\n+        debug!(\"upcast: upcast_trait_refs={}\", upcast_trait_refs.repr(self.tcx()));\n+        upcast_trait_refs\n+    }\n }\n \n impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {"}, {"sha": "d6dc57c5def4ad57a484552dcec2c830c2fa0d1a", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd50b4e0b14b698e2217947727b4ae9f39e758b8/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd50b4e0b14b698e2217947727b4ae9f39e758b8/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=cd50b4e0b14b698e2217947727b4ae9f39e758b8", "patch": "@@ -359,19 +359,15 @@ pub fn predicate_for_builtin_bound<'tcx>(\n pub fn upcast<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     source_trait_ref: ty::PolyTraitRef<'tcx>,\n                     target_trait_def_id: ast::DefId)\n-                    -> Option<ty::PolyTraitRef<'tcx>>\n+                    -> Vec<ty::PolyTraitRef<'tcx>>\n {\n     if source_trait_ref.def_id() == target_trait_def_id {\n-        return Some(source_trait_ref); // shorcut the most common case\n+        return vec![source_trait_ref]; // shorcut the most common case\n     }\n \n-    for super_trait_ref in supertraits(tcx, source_trait_ref) {\n-        if super_trait_ref.def_id() == target_trait_def_id {\n-            return Some(super_trait_ref);\n-        }\n-    }\n-\n-    None\n+    supertraits(tcx, source_trait_ref)\n+        .filter(|r| r.def_id() == target_trait_def_id)\n+        .collect()\n }\n \n /// Given an object of type `object_trait_ref`, returns the index of"}, {"sha": "f3a7c1ee6a0c8fe673dd306120041a47c8e8798b", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cd50b4e0b14b698e2217947727b4ae9f39e758b8/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd50b4e0b14b698e2217947727b4ae9f39e758b8/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=cd50b4e0b14b698e2217947727b4ae9f39e758b8", "patch": "@@ -544,7 +544,8 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N>\n impl<'tcx> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx> {\n     fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableObjectData<'tcx> {\n         traits::VtableObjectData {\n-            object_ty: self.object_ty.fold_with(folder)\n+            object_ty: self.object_ty.fold_with(folder),\n+            upcast_trait_ref: self.upcast_trait_ref.fold_with(folder),\n         }\n     }\n }"}, {"sha": "7b4e3956cbd22866e2dda828c2ffc7cac5f5ba93", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd50b4e0b14b698e2217947727b4ae9f39e758b8/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd50b4e0b14b698e2217947727b4ae9f39e758b8/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=cd50b4e0b14b698e2217947727b4ae9f39e758b8", "patch": "@@ -300,7 +300,8 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                   .position(|item| item.def_id() == method_id)\n                                   .unwrap();\n             let (llfn, ty) =\n-                trans_object_shim(ccx, data.object_ty, trait_id, method_offset_in_trait);\n+                trans_object_shim(ccx, data.object_ty, data.upcast_trait_ref.clone(),\n+                                  method_offset_in_trait);\n             immediate_rvalue(llfn, ty)\n         }\n         _ => {\n@@ -386,7 +387,8 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             Callee { bcx: bcx, data: Fn(llfn) }\n         }\n         traits::VtableObject(ref data) => {\n-            let (llfn, _) = trans_object_shim(bcx.ccx(), data.object_ty, trait_id, n_method);\n+            let (llfn, _) = trans_object_shim(bcx.ccx(), data.object_ty,\n+                                              data.upcast_trait_ref.clone(), n_method);\n             Callee { bcx: bcx, data: Fn(llfn) }\n         }\n         traits::VtableBuiltin(..) |\n@@ -551,16 +553,17 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn trans_object_shim<'a, 'tcx>(\n     ccx: &'a CrateContext<'a, 'tcx>,\n     object_ty: Ty<'tcx>,\n-    trait_id: ast::DefId,\n+    upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n     method_offset_in_trait: uint)\n     -> (ValueRef, Ty<'tcx>)\n {\n     let _icx = push_ctxt(\"trans_object_shim\");\n     let tcx = ccx.tcx();\n+    let trait_id = upcast_trait_ref.def_id();\n \n-    debug!(\"trans_object_shim(object_ty={}, trait_id={}, method_offset_in_trait={})\",\n+    debug!(\"trans_object_shim(object_ty={}, upcast_trait_ref={}, method_offset_in_trait={})\",\n            object_ty.repr(tcx),\n-           trait_id.repr(tcx),\n+           upcast_trait_ref.repr(tcx),\n            method_offset_in_trait);\n \n     let object_trait_ref =\n@@ -575,7 +578,6 @@ pub fn trans_object_shim<'a, 'tcx>(\n         };\n \n     // Upcast to the trait in question and extract out the substitutions.\n-    let upcast_trait_ref = traits::upcast(ccx.tcx(), object_trait_ref.clone(), trait_id).unwrap();\n     let upcast_trait_ref = ty::erase_late_bound_regions(tcx, &upcast_trait_ref);\n     let object_substs = upcast_trait_ref.substs.clone().erase_regions();\n     debug!(\"trans_object_shim: object_substs={}\", object_substs.repr(tcx));"}, {"sha": "6ef6953f707fb2d6ef310eb97df5770cc0ae6ccc", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cd50b4e0b14b698e2217947727b4ae9f39e758b8/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd50b4e0b14b698e2217947727b4ae9f39e758b8/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=cd50b4e0b14b698e2217947727b4ae9f39e758b8", "patch": "@@ -634,16 +634,21 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n               target_trait_def_id: ast::DefId)\n               -> ty::PolyTraitRef<'tcx>\n     {\n-        match traits::upcast(self.tcx(), source_trait_ref.clone(), target_trait_def_id) {\n-            Some(super_trait_ref) => super_trait_ref,\n-            None => {\n-                self.tcx().sess.span_bug(\n-                    self.span,\n-                    &format!(\"cannot upcast `{}` to `{}`\",\n-                             source_trait_ref.repr(self.tcx()),\n-                             target_trait_def_id.repr(self.tcx())));\n-            }\n+        let upcast_trait_refs = traits::upcast(self.tcx(),\n+                                               source_trait_ref.clone(),\n+                                               target_trait_def_id);\n+\n+        // must be exactly one trait ref or we'd get an ambig error etc\n+        if upcast_trait_refs.len() != 1 {\n+            self.tcx().sess.span_bug(\n+                self.span,\n+                &format!(\"cannot uniquely upcast `{}` to `{}`: `{}`\",\n+                         source_trait_ref.repr(self.tcx()),\n+                         target_trait_def_id.repr(self.tcx()),\n+                         upcast_trait_refs.repr(self.tcx())));\n         }\n+\n+        upcast_trait_refs.into_iter().next().unwrap()\n     }\n \n     fn replace_late_bound_regions_with_fresh_var<T>(&self, value: &ty::Binder<T>) -> T"}, {"sha": "678a7806e7ab687080ad2711899710cec9234c4d", "filename": "src/test/compile-fail/issue-3953.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Ftest%2Fcompile-fail%2Fissue-3953.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Ftest%2Fcompile-fail%2Fissue-3953.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3953.rs?ref=bc9ae36dba3bcacdec98af1495d99593bfc59cac", "patch": "@@ -1,33 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-tidy-linelength\n-\n-use std::cmp::PartialEq;\n-\n-trait Hahaha: PartialEq + PartialEq {\n-}\n-\n-struct Lol(isize);\n-\n-impl Hahaha for Lol { }\n-\n-impl PartialEq for Lol {\n-    fn eq(&self, other: &Lol) -> bool { loop { } }\n-    fn ne(&self, other: &Lol) -> bool { loop { } }\n-}\n-\n-fn main() {\n-    if Lol(2) == Lol(4) {\n-        println!(\"2 == 4\");\n-    } else {\n-        println!(\"2 != 4\");\n-    }\n-}"}, {"sha": "d61ac6f08d99d603a0136e10e5a0c545dee0e75b", "filename": "src/test/compile-fail/traits-repeated-supertrait-ambig.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/cd50b4e0b14b698e2217947727b4ae9f39e758b8/src%2Ftest%2Fcompile-fail%2Ftraits-repeated-supertrait-ambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd50b4e0b14b698e2217947727b4ae9f39e758b8/src%2Ftest%2Fcompile-fail%2Ftraits-repeated-supertrait-ambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftraits-repeated-supertrait-ambig.rs?ref=cd50b4e0b14b698e2217947727b4ae9f39e758b8", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a case of a trait which extends the same supertrait twice, but\n+// with difference type parameters. Test then that when we don't give\n+// enough information to pick between these, no selection is made. In\n+// this particular case, the two choices are i64/u64 -- so when we use\n+// an integer literal, we wind up falling this literal back to i32.\n+// See also `run-pass/trait-repeated-supertrait.rs`.\n+\n+trait CompareTo<T> {\n+    fn same_as(&self, t: T) -> bool;\n+}\n+\n+trait CompareToInts : CompareTo<i64> + CompareTo<u64> {\n+}\n+\n+impl CompareTo<i64> for i64 {\n+    fn same_as(&self, t: i64) -> bool { *self == t }\n+}\n+\n+impl CompareTo<u64> for i64 {\n+    fn same_as(&self, t: u64) -> bool { *self == (t as i64) }\n+}\n+\n+impl CompareToInts for i64 { }\n+\n+fn with_obj(c: &CompareToInts) -> bool {\n+    c.same_as(22) //~ ERROR `CompareTo<i32>` is not implemented\n+}\n+\n+fn with_trait<C:CompareToInts>(c: &C) -> bool {\n+    c.same_as(22) //~ ERROR `CompareTo<i32>` is not implemented\n+}\n+\n+fn with_ufcs1<C:CompareToInts>(c: &C) -> bool {\n+    CompareToInts::same_as(c, 22) //~ ERROR `CompareTo<i32>` is not implemented\n+}\n+\n+fn with_ufcs2<C:CompareToInts>(c: &C) -> bool {\n+    CompareTo::same_as(c, 22) //~ ERROR `CompareTo<i32>` is not implemented\n+}\n+\n+fn main() {\n+    assert_eq!(22_i64.same_as(22), true); //~ ERROR `CompareTo<i32>` is not implemented\n+}"}, {"sha": "f8b8ad2bf2efa4ee0b749ec7393599ba57e032c7", "filename": "src/test/compile-fail/unsized4.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Ftest%2Fcompile-fail%2Funsized4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc9ae36dba3bcacdec98af1495d99593bfc59cac/src%2Ftest%2Fcompile-fail%2Funsized4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized4.rs?ref=bc9ae36dba3bcacdec98af1495d99593bfc59cac", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that bounds are sized-compatible.\n-\n-trait T : Sized {}\n-fn f<Y: ?Sized + T>() {\n-//~^ERROR incompatible bounds on `Y`, bound `T` does not allow unsized type\n-}\n-\n-pub fn main() {\n-}"}, {"sha": "fdaa8d6f4d6efdb2cf6b1ab6060f6e4eb556d12b", "filename": "src/test/run-pass/traits-repeated-supertrait.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/cd50b4e0b14b698e2217947727b4ae9f39e758b8/src%2Ftest%2Frun-pass%2Ftraits-repeated-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd50b4e0b14b698e2217947727b4ae9f39e758b8/src%2Ftest%2Frun-pass%2Ftraits-repeated-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits-repeated-supertrait.rs?ref=cd50b4e0b14b698e2217947727b4ae9f39e758b8", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a case of a trait which extends the same supertrait twice, but\n+// with difference type parameters. Test that we can invoke the\n+// various methods in various ways successfully.\n+// See also `compile-fail/trait-repeated-supertrait-ambig.rs`.\n+\n+trait CompareTo<T> {\n+    fn same_as(&self, t: T) -> bool;\n+}\n+\n+trait CompareToInts : CompareTo<i64> + CompareTo<u64> {\n+}\n+\n+impl CompareTo<i64> for i64 {\n+    fn same_as(&self, t: i64) -> bool { *self == t }\n+}\n+\n+impl CompareTo<u64> for i64 {\n+    fn same_as(&self, t: u64) -> bool { *self == (t as i64) }\n+}\n+\n+impl CompareToInts for i64 { }\n+\n+fn with_obj(c: &CompareToInts) -> bool {\n+    c.same_as(22_i64) && c.same_as(22_u64)\n+}\n+\n+fn with_trait<C:CompareToInts>(c: &C) -> bool {\n+    c.same_as(22_i64) && c.same_as(22_u64)\n+}\n+\n+fn with_ufcs1<C:CompareToInts>(c: &C) -> bool {\n+    CompareToInts::same_as(c, 22_i64) && CompareToInts::same_as(c, 22_u64)\n+}\n+\n+fn with_ufcs2<C:CompareToInts>(c: &C) -> bool {\n+    CompareTo::same_as(c, 22_i64) && CompareTo::same_as(c, 22_u64)\n+}\n+\n+fn main() {\n+    assert_eq!(22_i64.same_as(22_i64), true);\n+    assert_eq!(22_i64.same_as(22_u64), true);\n+    assert_eq!(with_trait(&22), true);\n+    assert_eq!(with_obj(&22), true);\n+    assert_eq!(with_ufcs1(&22), true);\n+    assert_eq!(with_ufcs2(&22), true);\n+}"}]}