{"sha": "b7d0feb90cc1466fd0e419b6513b0617b2f3c695", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3ZDBmZWI5MGNjMTQ2NmZkMGU0MTliNjUxM2IwNjE3YjJmM2M2OTU=", "commit": {"author": {"name": "Wendell Smith", "email": "wendell.smith@yale.edu", "date": "2014-04-25T20:19:53Z"}, "committer": {"name": "Wendell Smith", "email": "wendell.smith@yale.edu", "date": "2014-04-27T02:27:36Z"}, "message": "Fixing permutation of small lists, such that [], [x] -> [[]], [[x]], and updating size_hints.\nFixes #13734 and #13759.", "tree": {"sha": "873eee7da1c660a1a0615ff005d5e0d153c7015f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/873eee7da1c660a1a0615ff005d5e0d153c7015f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7d0feb90cc1466fd0e419b6513b0617b2f3c695", "comment_count": 13, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7d0feb90cc1466fd0e419b6513b0617b2f3c695", "html_url": "https://github.com/rust-lang/rust/commit/b7d0feb90cc1466fd0e419b6513b0617b2f3c695", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7d0feb90cc1466fd0e419b6513b0617b2f3c695/comments", "author": {"login": "wackywendell", "id": 245071, "node_id": "MDQ6VXNlcjI0NTA3MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/245071?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wackywendell", "html_url": "https://github.com/wackywendell", "followers_url": "https://api.github.com/users/wackywendell/followers", "following_url": "https://api.github.com/users/wackywendell/following{/other_user}", "gists_url": "https://api.github.com/users/wackywendell/gists{/gist_id}", "starred_url": "https://api.github.com/users/wackywendell/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wackywendell/subscriptions", "organizations_url": "https://api.github.com/users/wackywendell/orgs", "repos_url": "https://api.github.com/users/wackywendell/repos", "events_url": "https://api.github.com/users/wackywendell/events{/privacy}", "received_events_url": "https://api.github.com/users/wackywendell/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wackywendell", "id": 245071, "node_id": "MDQ6VXNlcjI0NTA3MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/245071?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wackywendell", "html_url": "https://github.com/wackywendell", "followers_url": "https://api.github.com/users/wackywendell/followers", "following_url": "https://api.github.com/users/wackywendell/following{/other_user}", "gists_url": "https://api.github.com/users/wackywendell/gists{/gist_id}", "starred_url": "https://api.github.com/users/wackywendell/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wackywendell/subscriptions", "organizations_url": "https://api.github.com/users/wackywendell/orgs", "repos_url": "https://api.github.com/users/wackywendell/repos", "events_url": "https://api.github.com/users/wackywendell/events{/privacy}", "received_events_url": "https://api.github.com/users/wackywendell/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ade02bb5349b9ea5ad47cf8cdd61ad91057148d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ade02bb5349b9ea5ad47cf8cdd61ad91057148d1", "html_url": "https://github.com/rust-lang/rust/commit/ade02bb5349b9ea5ad47cf8cdd61ad91057148d1"}], "stats": {"total": 55, "additions": 48, "deletions": 7}, "files": [{"sha": "f5e064942e68bcbfe553bee6991d6de8cb56832e", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 48, "deletions": 7, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b7d0feb90cc1466fd0e419b6513b0617b2f3c695/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d0feb90cc1466fd0e419b6513b0617b2f3c695/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=b7d0feb90cc1466fd0e419b6513b0617b2f3c695", "patch": "@@ -307,6 +307,7 @@ pub struct ElementSwaps {\n     sdir: ~[SizeDirection],\n     /// If true, emit the last swap that returns the sequence to initial state\n     emit_reset: bool,\n+    swaps_made : uint,\n }\n \n impl ElementSwaps {\n@@ -319,7 +320,8 @@ impl ElementSwaps {\n             emit_reset: true,\n             sdir: range(0, length)\n                     .map(|i| SizeDirection{ size: i, dir: Neg })\n-                    .collect::<~[_]>()\n+                    .collect::<~[_]>(),\n+            swaps_made: 0\n         }\n     }\n }\n@@ -358,16 +360,30 @@ impl Iterator<(uint, uint)> for ElementSwaps {\n                         x.dir = match x.dir { Pos => Neg, Neg => Pos };\n                     }\n                 }\n+                self.swaps_made += 1;\n                 Some((i, j))\n             },\n-            None => if self.emit_reset && self.sdir.len() > 1 {\n+            None => if self.emit_reset {\n                 self.emit_reset = false;\n-                Some((0, 1))\n-            } else {\n-                None\n-            }\n+                if self.sdir.len() > 1 {\n+                    // The last swap\n+                    self.swaps_made += 1;\n+                    Some((0, 1))\n+                } else {\n+                    // Vector is of the form [] or [x], and the only permutation is itself\n+                    self.swaps_made += 1;\n+                    Some((0,0))\n+                }\n+            } else { None }\n         }\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        // For a vector of size n, there are exactly n! permutations.\n+        let n = range(2, self.sdir.len() + 1).product();\n+        (n - self.swaps_made, Some(n - self.swaps_made))\n+    }\n }\n \n /// An Iterator that uses `ElementSwaps` to iterate through\n@@ -388,13 +404,19 @@ impl<T: Clone> Iterator<~[T]> for Permutations<T> {\n     fn next(&mut self) -> Option<~[T]> {\n         match self.swaps.next() {\n             None => None,\n+            Some((0,0)) => Some(self.v.clone()),\n             Some((a, b)) => {\n                 let elt = self.v.clone();\n                 self.v.swap(a, b);\n                 Some(elt)\n             }\n         }\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        self.swaps.size_hint()\n+    }\n }\n \n /// An iterator over the (overlapping) slices of length `size` within\n@@ -2767,19 +2789,33 @@ mod tests {\n         {\n             let v: [int, ..0] = [];\n             let mut it = v.permutations();\n+            let (min_size, max_opt) = it.size_hint();\n+            assert_eq!(min_size, 1);\n+            assert_eq!(max_opt.unwrap(), 1);\n+            assert_eq!(it.next(), Some(v.as_slice().to_owned()));\n             assert_eq!(it.next(), None);\n         }\n         {\n             let v = [\"Hello\".to_owned()];\n             let mut it = v.permutations();\n+            let (min_size, max_opt) = it.size_hint();\n+            assert_eq!(min_size, 1);\n+            assert_eq!(max_opt.unwrap(), 1);\n+            assert_eq!(it.next(), Some(v.as_slice().to_owned()));\n             assert_eq!(it.next(), None);\n         }\n         {\n             let v = [1, 2, 3];\n             let mut it = v.permutations();\n+            let (min_size, max_opt) = it.size_hint();\n+            assert_eq!(min_size, 3*2);\n+            assert_eq!(max_opt.unwrap(), 3*2);\n             assert_eq!(it.next(), Some(~[1,2,3]));\n             assert_eq!(it.next(), Some(~[1,3,2]));\n             assert_eq!(it.next(), Some(~[3,1,2]));\n+            let (min_size, max_opt) = it.size_hint();\n+            assert_eq!(min_size, 3);\n+            assert_eq!(max_opt.unwrap(), 3);\n             assert_eq!(it.next(), Some(~[3,2,1]));\n             assert_eq!(it.next(), Some(~[2,3,1]));\n             assert_eq!(it.next(), Some(~[2,1,3]));\n@@ -2789,10 +2825,15 @@ mod tests {\n             // check that we have N! permutations\n             let v = ['A', 'B', 'C', 'D', 'E', 'F'];\n             let mut amt = 0;\n-            for _perm in v.permutations() {\n+            let mut it = v.permutations();\n+            let (min_size, max_opt) = it.size_hint();\n+            for _perm in it {\n                 amt += 1;\n             }\n+            assert_eq!(amt, it.swaps.swaps_made);\n+            assert_eq!(amt, min_size);\n             assert_eq!(amt, 2 * 3 * 4 * 5 * 6);\n+            assert_eq!(amt, max_opt.unwrap());\n         }\n     }\n "}]}