{"sha": "01418bd1aa71a38567b9fea737d74379133d28c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxNDE4YmQxYWE3MWEzODU2N2I5ZmVhNzM3ZDc0Mzc5MTMzZDI4YzA=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-18T01:13:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-18T01:13:39Z"}, "message": "Rollup merge of #72414 - KodrAus:feat/stdlazy, r=Mark-Simulacrum\n\n Add lazy initialization primitives to std\n\nFollow-up to #68198\n\nCurrent RFC: https://github.com/rust-lang/rfcs/pull/2788\n\nRebased and fixed up a few of the dangling comments. Some notes carried over from the previous PR:\n\n- [ ] Naming. I'm ok to just roll with the `Sync` prefix like `SyncLazy` for now, but [have a personal preference for `Atomic`](https://github.com/rust-lang/rfcs/pull/2788#issuecomment-574466983) like `AtomicLazy`.\n- [x] [Poisoning](https://github.com/rust-lang/rfcs/pull/2788#discussion_r366725768). It seems like there's [some regret around poisoning in other `std::sync` types that we might want to just avoid upfront for `std::lazy`, especially if that would align with a future `std::mutex` that doesn't poison](https://rust-lang.zulipchat.com/#narrow/stream/219381-t-libs/topic/parking_lot.3A.3AMutex.20in.20std/near/190331199). Personally, if we're adding these types to `std::lazy` instead of `std::sync`, I'd be on-board with not worrying about poisoning in `std::lazy`, and potentially deprecating `std::sync::Once` and `lazy_static` in favour of `std::lazy` down the track if it's possible, rather than attempting to replicate their behavior. cc @Amanieu @sfackler.\n- [ ] [Consider making`SyncOnceCell::get` blocking](https://github.com/matklad/once_cell/pull/92). There doesn't seem to be consensus in the linked PR on whether or not that's strictly better than the non-blocking variant.\n\nIn general, none of these seem to be really blocking an initial unstable merge, so we could possibly kick off a FCP if y'all are happy?\n\ncc @matklad @pitdicker have I missed anything, or were there any other considerations that have come up since we last looked at this?", "tree": {"sha": "6a20f2af3588da12b1bdb32706866616caf43597", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a20f2af3588da12b1bdb32706866616caf43597"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01418bd1aa71a38567b9fea737d74379133d28c0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfEkzDCRBK7hj4Ov3rIwAAdHIIAC5i/o7kh2BXuSTHbhe0L8rU\ne6nXZCOwDNp9WDRO2tWAop8w5e9QUEeTEqp7+SvmydpZqxMXRGZK63SPWDCJT6wG\nZPL7nxiDXfZlPdDl4Wi8H1T7xt4r+UER3TedH44qih6nQQoEWXwfHvNlbU+sxO56\n5YgpcadbWUKrKEYZPJssc4Cx1IbjnVL8mOOvLGPEe9ygknbFqc+TA3SDEZkgN6A5\nEY8u18hurVHIZTSiqVw3zE8bVotg5pcibieIwD7ymV7hGrCNyBm7VNzwy3nUDdHF\nb4WMPYvXMvJsUNgY0N320OGN+FjhkSpHFD2qJpKdFCjo7ufHi+uMxXE8l6a4r7M=\n=RmYH\n-----END PGP SIGNATURE-----\n", "payload": "tree 6a20f2af3588da12b1bdb32706866616caf43597\nparent d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02\nparent fe639057086fa7bef1e964bf3a211517b04bc328\nauthor Manish Goregaokar <manishsmail@gmail.com> 1595034819 -0700\ncommitter GitHub <noreply@github.com> 1595034819 -0700\n\nRollup merge of #72414 - KodrAus:feat/stdlazy, r=Mark-Simulacrum\n\n Add lazy initialization primitives to std\n\nFollow-up to #68198\n\nCurrent RFC: https://github.com/rust-lang/rfcs/pull/2788\n\nRebased and fixed up a few of the dangling comments. Some notes carried over from the previous PR:\n\n- [ ] Naming. I'm ok to just roll with the `Sync` prefix like `SyncLazy` for now, but [have a personal preference for `Atomic`](https://github.com/rust-lang/rfcs/pull/2788#issuecomment-574466983) like `AtomicLazy`.\n- [x] [Poisoning](https://github.com/rust-lang/rfcs/pull/2788#discussion_r366725768). It seems like there's [some regret around poisoning in other `std::sync` types that we might want to just avoid upfront for `std::lazy`, especially if that would align with a future `std::mutex` that doesn't poison](https://rust-lang.zulipchat.com/#narrow/stream/219381-t-libs/topic/parking_lot.3A.3AMutex.20in.20std/near/190331199). Personally, if we're adding these types to `std::lazy` instead of `std::sync`, I'd be on-board with not worrying about poisoning in `std::lazy`, and potentially deprecating `std::sync::Once` and `lazy_static` in favour of `std::lazy` down the track if it's possible, rather than attempting to replicate their behavior. cc @Amanieu @sfackler.\n- [ ] [Consider making`SyncOnceCell::get` blocking](https://github.com/matklad/once_cell/pull/92). There doesn't seem to be consensus in the linked PR on whether or not that's strictly better than the non-blocking variant.\n\nIn general, none of these seem to be really blocking an initial unstable merge, so we could possibly kick off a FCP if y'all are happy?\n\ncc @matklad @pitdicker have I missed anything, or were there any other considerations that have come up since we last looked at this?\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01418bd1aa71a38567b9fea737d74379133d28c0", "html_url": "https://github.com/rust-lang/rust/commit/01418bd1aa71a38567b9fea737d74379133d28c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01418bd1aa71a38567b9fea737d74379133d28c0/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02", "html_url": "https://github.com/rust-lang/rust/commit/d3df8512d2c2afc6d2e7d8b5b951dd7f2ad77b02"}, {"sha": "fe639057086fa7bef1e964bf3a211517b04bc328", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe639057086fa7bef1e964bf3a211517b04bc328", "html_url": "https://github.com/rust-lang/rust/commit/fe639057086fa7bef1e964bf3a211517b04bc328"}], "stats": {"total": 1377, "additions": 1373, "deletions": 4}, "files": [{"sha": "5cf7217ef11e81724f0c34482f1f9b18a780a063", "filename": "src/libcore/lazy.rs", "status": "added", "additions": 379, "deletions": 0, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/01418bd1aa71a38567b9fea737d74379133d28c0/src%2Flibcore%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01418bd1aa71a38567b9fea737d74379133d28c0/src%2Flibcore%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flazy.rs?ref=01418bd1aa71a38567b9fea737d74379133d28c0", "patch": "@@ -0,0 +1,379 @@\n+//! Lazy values and one-time initialization of static data.\n+\n+use crate::cell::{Cell, UnsafeCell};\n+use crate::fmt;\n+use crate::mem;\n+use crate::ops::Deref;\n+\n+/// A cell which can be written to only once.\n+///\n+/// Unlike `RefCell`, a `OnceCell` only provides shared `&T` references to its value.\n+/// Unlike `Cell`, a `OnceCell` doesn't require copying or replacing the value to access it.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(once_cell)]\n+///\n+/// use std::lazy::OnceCell;\n+///\n+/// let cell = OnceCell::new();\n+/// assert!(cell.get().is_none());\n+///\n+/// let value: &String = cell.get_or_init(|| {\n+///     \"Hello, World!\".to_string()\n+/// });\n+/// assert_eq!(value, \"Hello, World!\");\n+/// assert!(cell.get().is_some());\n+/// ```\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+pub struct OnceCell<T> {\n+    // Invariant: written to at most once.\n+    inner: UnsafeCell<Option<T>>,\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T> Default for OnceCell<T> {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: fmt::Debug> fmt::Debug for OnceCell<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.get() {\n+            Some(v) => f.debug_tuple(\"OnceCell\").field(v).finish(),\n+            None => f.write_str(\"OnceCell(Uninit)\"),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: Clone> Clone for OnceCell<T> {\n+    fn clone(&self) -> OnceCell<T> {\n+        let res = OnceCell::new();\n+        if let Some(value) = self.get() {\n+            match res.set(value.clone()) {\n+                Ok(()) => (),\n+                Err(_) => unreachable!(),\n+            }\n+        }\n+        res\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: PartialEq> PartialEq for OnceCell<T> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.get() == other.get()\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: Eq> Eq for OnceCell<T> {}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T> From<T> for OnceCell<T> {\n+    fn from(value: T) -> Self {\n+        OnceCell { inner: UnsafeCell::new(Some(value)) }\n+    }\n+}\n+\n+impl<T> OnceCell<T> {\n+    /// Creates a new empty cell.\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub const fn new() -> OnceCell<T> {\n+        OnceCell { inner: UnsafeCell::new(None) }\n+    }\n+\n+    /// Gets the reference to the underlying value.\n+    ///\n+    /// Returns `None` if the cell is empty.\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get(&self) -> Option<&T> {\n+        // Safety: Safe due to `inner`'s invariant\n+        unsafe { &*self.inner.get() }.as_ref()\n+    }\n+\n+    /// Gets the mutable reference to the underlying value.\n+    ///\n+    /// Returns `None` if the cell is empty.\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get_mut(&mut self) -> Option<&mut T> {\n+        // Safety: Safe because we have unique access\n+        unsafe { &mut *self.inner.get() }.as_mut()\n+    }\n+\n+    /// Sets the contents of the cell to `value`.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This method returns `Ok(())` if the cell was empty and `Err(value)` if\n+    /// it was full.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::OnceCell;\n+    ///\n+    /// let cell = OnceCell::new();\n+    /// assert!(cell.get().is_none());\n+    ///\n+    /// assert_eq!(cell.set(92), Ok(()));\n+    /// assert_eq!(cell.set(62), Err(62));\n+    ///\n+    /// assert!(cell.get().is_some());\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn set(&self, value: T) -> Result<(), T> {\n+        // Safety: Safe because we cannot have overlapping mutable borrows\n+        let slot = unsafe { &*self.inner.get() };\n+        if slot.is_some() {\n+            return Err(value);\n+        }\n+\n+        // Safety: This is the only place where we set the slot, no races\n+        // due to reentrancy/concurrency are possible, and we've\n+        // checked that slot is currently `None`, so this write\n+        // maintains the `inner`'s invariant.\n+        let slot = unsafe { &mut *self.inner.get() };\n+        *slot = Some(value);\n+        Ok(())\n+    }\n+\n+    /// Gets the contents of the cell, initializing it with `f`\n+    /// if the cell was empty.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `f` panics, the panic is propagated to the caller, and the cell\n+    /// remains uninitialized.\n+    ///\n+    /// It is an error to reentrantly initialize the cell from `f`. Doing\n+    /// so results in a panic.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::OnceCell;\n+    ///\n+    /// let cell = OnceCell::new();\n+    /// let value = cell.get_or_init(|| 92);\n+    /// assert_eq!(value, &92);\n+    /// let value = cell.get_or_init(|| unreachable!());\n+    /// assert_eq!(value, &92);\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get_or_init<F>(&self, f: F) -> &T\n+    where\n+        F: FnOnce() -> T,\n+    {\n+        match self.get_or_try_init(|| Ok::<T, !>(f())) {\n+            Ok(val) => val,\n+        }\n+    }\n+\n+    /// Gets the contents of the cell, initializing it with `f` if\n+    /// the cell was empty. If the cell was empty and `f` failed, an\n+    /// error is returned.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `f` panics, the panic is propagated to the caller, and the cell\n+    /// remains uninitialized.\n+    ///\n+    /// It is an error to reentrantly initialize the cell from `f`. Doing\n+    /// so results in a panic.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::OnceCell;\n+    ///\n+    /// let cell = OnceCell::new();\n+    /// assert_eq!(cell.get_or_try_init(|| Err(())), Err(()));\n+    /// assert!(cell.get().is_none());\n+    /// let value = cell.get_or_try_init(|| -> Result<i32, ()> {\n+    ///     Ok(92)\n+    /// });\n+    /// assert_eq!(value, Ok(&92));\n+    /// assert_eq!(cell.get(), Some(&92))\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get_or_try_init<F, E>(&self, f: F) -> Result<&T, E>\n+    where\n+        F: FnOnce() -> Result<T, E>,\n+    {\n+        if let Some(val) = self.get() {\n+            return Ok(val);\n+        }\n+        let val = f()?;\n+        // Note that *some* forms of reentrant initialization might lead to\n+        // UB (see `reentrant_init` test). I believe that just removing this\n+        // `assert`, while keeping `set/get` would be sound, but it seems\n+        // better to panic, rather than to silently use an old value.\n+        assert!(self.set(val).is_ok(), \"reentrant init\");\n+        Ok(self.get().unwrap())\n+    }\n+\n+    /// Consumes the cell, returning the wrapped value.\n+    ///\n+    /// Returns `None` if the cell was empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::OnceCell;\n+    ///\n+    /// let cell: OnceCell<String> = OnceCell::new();\n+    /// assert_eq!(cell.into_inner(), None);\n+    ///\n+    /// let cell = OnceCell::new();\n+    /// cell.set(\"hello\".to_string()).unwrap();\n+    /// assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn into_inner(self) -> Option<T> {\n+        // Because `into_inner` takes `self` by value, the compiler statically verifies\n+        // that it is not currently borrowed. So it is safe to move out `Option<T>`.\n+        self.inner.into_inner()\n+    }\n+\n+    /// Takes the value out of this `OnceCell`, moving it back to an uninitialized state.\n+    ///\n+    /// Has no effect and returns `None` if the `OnceCell` hasn't been initialized.\n+    ///\n+    /// Safety is guaranteed by requiring a mutable reference.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::OnceCell;\n+    ///\n+    /// let mut cell: OnceCell<String> = OnceCell::new();\n+    /// assert_eq!(cell.take(), None);\n+    ///\n+    /// let mut cell = OnceCell::new();\n+    /// cell.set(\"hello\".to_string()).unwrap();\n+    /// assert_eq!(cell.take(), Some(\"hello\".to_string()));\n+    /// assert_eq!(cell.get(), None);\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn take(&mut self) -> Option<T> {\n+        mem::take(self).into_inner()\n+    }\n+}\n+\n+/// A value which is initialized on the first access.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(once_cell)]\n+///\n+/// use std::lazy::Lazy;\n+///\n+/// let lazy: Lazy<i32> = Lazy::new(|| {\n+///     println!(\"initializing\");\n+///     92\n+/// });\n+/// println!(\"ready\");\n+/// println!(\"{}\", *lazy);\n+/// println!(\"{}\", *lazy);\n+///\n+/// // Prints:\n+/// //   ready\n+/// //   initializing\n+/// //   92\n+/// //   92\n+/// ```\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+pub struct Lazy<T, F = fn() -> T> {\n+    cell: OnceCell<T>,\n+    init: Cell<Option<F>>,\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: fmt::Debug, F> fmt::Debug for Lazy<T, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Lazy\").field(\"cell\", &self.cell).field(\"init\", &\"..\").finish()\n+    }\n+}\n+\n+impl<T, F> Lazy<T, F> {\n+    /// Creates a new lazy value with the given initializing function.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// # fn main() {\n+    /// use std::lazy::Lazy;\n+    ///\n+    /// let hello = \"Hello, World!\".to_string();\n+    ///\n+    /// let lazy = Lazy::new(|| hello.to_uppercase());\n+    ///\n+    /// assert_eq!(&*lazy, \"HELLO, WORLD!\");\n+    /// # }\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub const fn new(init: F) -> Lazy<T, F> {\n+        Lazy { cell: OnceCell::new(), init: Cell::new(Some(init)) }\n+    }\n+}\n+\n+impl<T, F: FnOnce() -> T> Lazy<T, F> {\n+    /// Forces the evaluation of this lazy value and returns a reference to\n+    /// the result.\n+    ///\n+    /// This is equivalent to the `Deref` impl, but is explicit.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::Lazy;\n+    ///\n+    /// let lazy = Lazy::new(|| 92);\n+    ///\n+    /// assert_eq!(Lazy::force(&lazy), &92);\n+    /// assert_eq!(&*lazy, &92);\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn force(this: &Lazy<T, F>) -> &T {\n+        this.cell.get_or_init(|| match this.init.take() {\n+            Some(f) => f(),\n+            None => panic!(\"`Lazy` instance has previously been poisoned\"),\n+        })\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T, F: FnOnce() -> T> Deref for Lazy<T, F> {\n+    type Target = T;\n+    fn deref(&self) -> &T {\n+        Lazy::force(self)\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: Default> Default for Lazy<T> {\n+    /// Creates a new lazy value using `Default` as the initializing function.\n+    fn default() -> Lazy<T> {\n+        Lazy::new(T::default)\n+    }\n+}"}, {"sha": "1621cf79751665fe32d70efda4bea36a44f8afed", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01418bd1aa71a38567b9fea737d74379133d28c0/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01418bd1aa71a38567b9fea737d74379133d28c0/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=01418bd1aa71a38567b9fea737d74379133d28c0", "patch": "@@ -239,6 +239,8 @@ pub mod char;\n pub mod ffi;\n #[cfg(not(test))] // See #65860\n pub mod iter;\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+pub mod lazy;\n pub mod option;\n pub mod panic;\n pub mod panicking;"}, {"sha": "1c0bddb9aef624c4671ae98aa201f4ed10c02dae", "filename": "src/libcore/tests/lazy.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/01418bd1aa71a38567b9fea737d74379133d28c0/src%2Flibcore%2Ftests%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01418bd1aa71a38567b9fea737d74379133d28c0/src%2Flibcore%2Ftests%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flazy.rs?ref=01418bd1aa71a38567b9fea737d74379133d28c0", "patch": "@@ -0,0 +1,124 @@\n+use core::{\n+    cell::Cell,\n+    lazy::{Lazy, OnceCell},\n+    sync::atomic::{AtomicUsize, Ordering::SeqCst},\n+};\n+\n+#[test]\n+fn once_cell() {\n+    let c = OnceCell::new();\n+    assert!(c.get().is_none());\n+    c.get_or_init(|| 92);\n+    assert_eq!(c.get(), Some(&92));\n+\n+    c.get_or_init(|| panic!(\"Kabom!\"));\n+    assert_eq!(c.get(), Some(&92));\n+}\n+\n+#[test]\n+fn once_cell_get_mut() {\n+    let mut c = OnceCell::new();\n+    assert!(c.get_mut().is_none());\n+    c.set(90).unwrap();\n+    *c.get_mut().unwrap() += 2;\n+    assert_eq!(c.get_mut(), Some(&mut 92));\n+}\n+\n+#[test]\n+fn once_cell_drop() {\n+    static DROP_CNT: AtomicUsize = AtomicUsize::new(0);\n+    struct Dropper;\n+    impl Drop for Dropper {\n+        fn drop(&mut self) {\n+            DROP_CNT.fetch_add(1, SeqCst);\n+        }\n+    }\n+\n+    let x = OnceCell::new();\n+    x.get_or_init(|| Dropper);\n+    assert_eq!(DROP_CNT.load(SeqCst), 0);\n+    drop(x);\n+    assert_eq!(DROP_CNT.load(SeqCst), 1);\n+}\n+\n+#[test]\n+fn unsync_once_cell_drop_empty() {\n+    let x = OnceCell::<&'static str>::new();\n+    drop(x);\n+}\n+\n+#[test]\n+fn clone() {\n+    let s = OnceCell::new();\n+    let c = s.clone();\n+    assert!(c.get().is_none());\n+\n+    s.set(\"hello\").unwrap();\n+    let c = s.clone();\n+    assert_eq!(c.get().map(|c| *c), Some(\"hello\"));\n+}\n+\n+#[test]\n+fn from_impl() {\n+    assert_eq!(OnceCell::from(\"value\").get(), Some(&\"value\"));\n+    assert_ne!(OnceCell::from(\"foo\").get(), Some(&\"bar\"));\n+}\n+\n+#[test]\n+fn partialeq_impl() {\n+    assert!(OnceCell::from(\"value\") == OnceCell::from(\"value\"));\n+    assert!(OnceCell::from(\"foo\") != OnceCell::from(\"bar\"));\n+\n+    assert!(OnceCell::<&'static str>::new() == OnceCell::new());\n+    assert!(OnceCell::<&'static str>::new() != OnceCell::from(\"value\"));\n+}\n+\n+#[test]\n+fn into_inner() {\n+    let cell: OnceCell<&'static str> = OnceCell::new();\n+    assert_eq!(cell.into_inner(), None);\n+    let cell = OnceCell::new();\n+    cell.set(\"hello\").unwrap();\n+    assert_eq!(cell.into_inner(), Some(\"hello\"));\n+}\n+\n+#[test]\n+fn lazy_new() {\n+    let called = Cell::new(0);\n+    let x = Lazy::new(|| {\n+        called.set(called.get() + 1);\n+        92\n+    });\n+\n+    assert_eq!(called.get(), 0);\n+\n+    let y = *x - 30;\n+    assert_eq!(y, 62);\n+    assert_eq!(called.get(), 1);\n+\n+    let y = *x - 30;\n+    assert_eq!(y, 62);\n+    assert_eq!(called.get(), 1);\n+}\n+\n+#[test]\n+fn aliasing_in_get() {\n+    let x = OnceCell::new();\n+    x.set(42).unwrap();\n+    let at_x = x.get().unwrap(); // --- (shared) borrow of inner `Option<T>` --+\n+    let _ = x.set(27); // <-- temporary (unique) borrow of inner `Option<T>`   |\n+    println!(\"{}\", at_x); // <------- up until here ---------------------------+\n+}\n+\n+#[test]\n+#[should_panic(expected = \"reentrant init\")]\n+fn reentrant_init() {\n+    let x: OnceCell<Box<i32>> = OnceCell::new();\n+    let dangling_ref: Cell<Option<&i32>> = Cell::new(None);\n+    x.get_or_init(|| {\n+        let r = x.get_or_init(|| Box::new(92));\n+        dangling_ref.set(Some(r));\n+        Box::new(62)\n+    });\n+    eprintln!(\"use after free: {:?}\", dangling_ref.get().unwrap());\n+}"}, {"sha": "47ed6db6c677b17428d423aa2cd40379df8e3645", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01418bd1aa71a38567b9fea737d74379133d28c0/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01418bd1aa71a38567b9fea737d74379133d28c0/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=01418bd1aa71a38567b9fea737d74379133d28c0", "patch": "@@ -43,6 +43,7 @@\n #![feature(option_unwrap_none)]\n #![feature(peekable_next_if)]\n #![feature(partition_point)]\n+#![feature(once_cell)]\n #![feature(unsafe_block_in_unsafe_fn)]\n #![deny(unsafe_op_in_unsafe_fn)]\n \n@@ -62,6 +63,7 @@ mod fmt;\n mod hash;\n mod intrinsics;\n mod iter;\n+mod lazy;\n mod manually_drop;\n mod mem;\n mod nonzero;"}, {"sha": "86e1cfae582e87bcc14e2e1ac69f19a4652438e3", "filename": "src/libstd/lazy.rs", "status": "added", "additions": 844, "deletions": 0, "changes": 844, "blob_url": "https://github.com/rust-lang/rust/blob/01418bd1aa71a38567b9fea737d74379133d28c0/src%2Flibstd%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01418bd1aa71a38567b9fea737d74379133d28c0/src%2Flibstd%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flazy.rs?ref=01418bd1aa71a38567b9fea737d74379133d28c0", "patch": "@@ -0,0 +1,844 @@\n+//! Lazy values and one-time initialization of static data.\n+\n+use crate::{\n+    cell::{Cell, UnsafeCell},\n+    fmt,\n+    mem::{self, MaybeUninit},\n+    ops::{Deref, Drop},\n+    panic::{RefUnwindSafe, UnwindSafe},\n+    sync::Once,\n+};\n+\n+#[doc(inline)]\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+pub use core::lazy::*;\n+\n+/// A synchronization primitive which can be written to only once.\n+///\n+/// This type is a thread-safe `OnceCell`.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(once_cell)]\n+///\n+/// use std::lazy::SyncOnceCell;\n+///\n+/// static CELL: SyncOnceCell<String> = SyncOnceCell::new();\n+/// assert!(CELL.get().is_none());\n+///\n+/// std::thread::spawn(|| {\n+///     let value: &String = CELL.get_or_init(|| {\n+///         \"Hello, World!\".to_string()\n+///     });\n+///     assert_eq!(value, \"Hello, World!\");\n+/// }).join().unwrap();\n+///\n+/// let value: Option<&String> = CELL.get();\n+/// assert!(value.is_some());\n+/// assert_eq!(value.unwrap().as_str(), \"Hello, World!\");\n+/// ```\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+pub struct SyncOnceCell<T> {\n+    once: Once,\n+    // Whether or not the value is initialized is tracked by `state_and_queue`.\n+    value: UnsafeCell<MaybeUninit<T>>,\n+}\n+\n+// Why do we need `T: Send`?\n+// Thread A creates a `SyncOnceCell` and shares it with\n+// scoped thread B, which fills the cell, which is\n+// then destroyed by A. That is, destructor observes\n+// a sent value.\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+unsafe impl<T: Sync + Send> Sync for SyncOnceCell<T> {}\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+unsafe impl<T: Send> Send for SyncOnceCell<T> {}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: RefUnwindSafe + UnwindSafe> RefUnwindSafe for SyncOnceCell<T> {}\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: UnwindSafe> UnwindSafe for SyncOnceCell<T> {}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T> Default for SyncOnceCell<T> {\n+    fn default() -> SyncOnceCell<T> {\n+        SyncOnceCell::new()\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: fmt::Debug> fmt::Debug for SyncOnceCell<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.get() {\n+            Some(v) => f.debug_tuple(\"Once\").field(v).finish(),\n+            None => f.write_str(\"Once(Uninit)\"),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: Clone> Clone for SyncOnceCell<T> {\n+    fn clone(&self) -> SyncOnceCell<T> {\n+        let cell = Self::new();\n+        if let Some(value) = self.get() {\n+            match cell.set(value.clone()) {\n+                Ok(()) => (),\n+                Err(_) => unreachable!(),\n+            }\n+        }\n+        cell\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T> From<T> for SyncOnceCell<T> {\n+    fn from(value: T) -> Self {\n+        let cell = Self::new();\n+        match cell.set(value) {\n+            Ok(()) => cell,\n+            Err(_) => unreachable!(),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: PartialEq> PartialEq for SyncOnceCell<T> {\n+    fn eq(&self, other: &SyncOnceCell<T>) -> bool {\n+        self.get() == other.get()\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: Eq> Eq for SyncOnceCell<T> {}\n+\n+impl<T> SyncOnceCell<T> {\n+    /// Creates a new empty cell.\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub const fn new() -> SyncOnceCell<T> {\n+        SyncOnceCell { once: Once::new(), value: UnsafeCell::new(MaybeUninit::uninit()) }\n+    }\n+\n+    /// Gets the reference to the underlying value.\n+    ///\n+    /// Returns `None` if the cell is empty, or being initialized. This\n+    /// method never blocks.\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get(&self) -> Option<&T> {\n+        if self.is_initialized() {\n+            // Safe b/c checked is_initialized\n+            Some(unsafe { self.get_unchecked() })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Gets the mutable reference to the underlying value.\n+    ///\n+    /// Returns `None` if the cell is empty. This method never blocks.\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get_mut(&mut self) -> Option<&mut T> {\n+        if self.is_initialized() {\n+            // Safe b/c checked is_initialized and we have a unique access\n+            Some(unsafe { self.get_unchecked_mut() })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Sets the contents of this cell to `value`.\n+    ///\n+    /// Returns `Ok(())` if the cell's value was updated.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::SyncOnceCell;\n+    ///\n+    /// static CELL: SyncOnceCell<i32> = SyncOnceCell::new();\n+    ///\n+    /// fn main() {\n+    ///     assert!(CELL.get().is_none());\n+    ///\n+    ///     std::thread::spawn(|| {\n+    ///         assert_eq!(CELL.set(92), Ok(()));\n+    ///     }).join().unwrap();\n+    ///\n+    ///     assert_eq!(CELL.set(62), Err(62));\n+    ///     assert_eq!(CELL.get(), Some(&92));\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn set(&self, value: T) -> Result<(), T> {\n+        let mut value = Some(value);\n+        self.get_or_init(|| value.take().unwrap());\n+        match value {\n+            None => Ok(()),\n+            Some(value) => Err(value),\n+        }\n+    }\n+\n+    /// Gets the contents of the cell, initializing it with `f` if the cell\n+    /// was empty.\n+    ///\n+    /// Many threads may call `get_or_init` concurrently with different\n+    /// initializing functions, but it is guaranteed that only one function\n+    /// will be executed.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `f` panics, the panic is propagated to the caller, and the cell\n+    /// remains uninitialized.\n+    ///\n+    /// It is an error to reentrantly initialize the cell from `f`. The\n+    /// exact outcome is unspecified. Current implementation deadlocks, but\n+    /// this may be changed to a panic in the future.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::SyncOnceCell;\n+    ///\n+    /// let cell = SyncOnceCell::new();\n+    /// let value = cell.get_or_init(|| 92);\n+    /// assert_eq!(value, &92);\n+    /// let value = cell.get_or_init(|| unreachable!());\n+    /// assert_eq!(value, &92);\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get_or_init<F>(&self, f: F) -> &T\n+    where\n+        F: FnOnce() -> T,\n+    {\n+        match self.get_or_try_init(|| Ok::<T, !>(f())) {\n+            Ok(val) => val,\n+        }\n+    }\n+\n+    /// Gets the contents of the cell, initializing it with `f` if\n+    /// the cell was empty. If the cell was empty and `f` failed, an\n+    /// error is returned.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `f` panics, the panic is propagated to the caller, and\n+    /// the cell remains uninitialized.\n+    ///\n+    /// It is an error to reentrantly initialize the cell from `f`.\n+    /// The exact outcome is unspecified. Current implementation\n+    /// deadlocks, but this may be changed to a panic in the future.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::SyncOnceCell;\n+    ///\n+    /// let cell = SyncOnceCell::new();\n+    /// assert_eq!(cell.get_or_try_init(|| Err(())), Err(()));\n+    /// assert!(cell.get().is_none());\n+    /// let value = cell.get_or_try_init(|| -> Result<i32, ()> {\n+    ///     Ok(92)\n+    /// });\n+    /// assert_eq!(value, Ok(&92));\n+    /// assert_eq!(cell.get(), Some(&92))\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get_or_try_init<F, E>(&self, f: F) -> Result<&T, E>\n+    where\n+        F: FnOnce() -> Result<T, E>,\n+    {\n+        // Fast path check\n+        // NOTE: We need to perform an acquire on the state in this method\n+        // in order to correctly synchronize `SyncLazy::force`. This is\n+        // currently done by calling `self.get()`, which in turn calls\n+        // `self.is_initialized()`, which in turn performs the acquire.\n+        if let Some(value) = self.get() {\n+            return Ok(value);\n+        }\n+        self.initialize(f)?;\n+\n+        debug_assert!(self.is_initialized());\n+\n+        // Safety: The inner value has been initialized\n+        Ok(unsafe { self.get_unchecked() })\n+    }\n+\n+    /// Consumes the `SyncOnceCell`, returning the wrapped value. Returns\n+    /// `None` if the cell was empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::SyncOnceCell;\n+    ///\n+    /// let cell: SyncOnceCell<String> = SyncOnceCell::new();\n+    /// assert_eq!(cell.into_inner(), None);\n+    ///\n+    /// let cell = SyncOnceCell::new();\n+    /// cell.set(\"hello\".to_string()).unwrap();\n+    /// assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn into_inner(mut self) -> Option<T> {\n+        // Safety: Safe because we immediately free `self` without dropping\n+        let inner = unsafe { self.take_inner() };\n+\n+        // Don't drop this `SyncOnceCell`. We just moved out one of the fields, but didn't set\n+        // the state to uninitialized.\n+        mem::ManuallyDrop::new(self);\n+        inner\n+    }\n+\n+    /// Takes the value out of this `SyncOnceCell`, moving it back to an uninitialized state.\n+    ///\n+    /// Has no effect and returns `None` if the `SyncOnceCell` hasn't been initialized.\n+    ///\n+    /// Safety is guaranteed by requiring a mutable reference.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::SyncOnceCell;\n+    ///\n+    /// let mut cell: SyncOnceCell<String> = SyncOnceCell::new();\n+    /// assert_eq!(cell.take(), None);\n+    ///\n+    /// let mut cell = SyncOnceCell::new();\n+    /// cell.set(\"hello\".to_string()).unwrap();\n+    /// assert_eq!(cell.take(), Some(\"hello\".to_string()));\n+    /// assert_eq!(cell.get(), None);\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn take(&mut self) -> Option<T> {\n+        mem::take(self).into_inner()\n+    }\n+\n+    /// Takes the wrapped value out of a `SyncOnceCell`.\n+    /// Afterwards the cell is no longer initialized.\n+    ///\n+    /// Safety: The cell must now be free'd WITHOUT dropping. No other usages of the cell\n+    /// are valid. Only used by `into_inner` and `drop`.\n+    unsafe fn take_inner(&mut self) -> Option<T> {\n+        // The mutable reference guarantees there are no other threads that can observe us\n+        // taking out the wrapped value.\n+        // Right after this function `self` is supposed to be freed, so it makes little sense\n+        // to atomically set the state to uninitialized.\n+        if self.is_initialized() {\n+            let value = mem::replace(&mut self.value, UnsafeCell::new(MaybeUninit::uninit()));\n+            Some(value.into_inner().assume_init())\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_initialized(&self) -> bool {\n+        self.once.is_completed()\n+    }\n+\n+    #[cold]\n+    fn initialize<F, E>(&self, f: F) -> Result<(), E>\n+    where\n+        F: FnOnce() -> Result<T, E>,\n+    {\n+        let mut res: Result<(), E> = Ok(());\n+        let slot = &self.value;\n+\n+        // Ignore poisoning from other threads\n+        // If another thread panics, then we'll be able to run our closure\n+        self.once.call_once_force(|p| {\n+            match f() {\n+                Ok(value) => {\n+                    unsafe { (&mut *slot.get()).write(value) };\n+                }\n+                Err(e) => {\n+                    res = Err(e);\n+\n+                    // Treat the underlying `Once` as poisoned since we\n+                    // failed to initialize our value. Calls\n+                    p.poison();\n+                }\n+            }\n+        });\n+        res\n+    }\n+\n+    /// Safety: The value must be initialized\n+    unsafe fn get_unchecked(&self) -> &T {\n+        debug_assert!(self.is_initialized());\n+        (&*self.value.get()).get_ref()\n+    }\n+\n+    /// Safety: The value must be initialized\n+    unsafe fn get_unchecked_mut(&mut self) -> &mut T {\n+        debug_assert!(self.is_initialized());\n+        (&mut *self.value.get()).get_mut()\n+    }\n+}\n+\n+impl<T> Drop for SyncOnceCell<T> {\n+    fn drop(&mut self) {\n+        // Safety: The cell is being dropped, so it can't be accessed again\n+        unsafe { self.take_inner() };\n+    }\n+}\n+\n+/// A value which is initialized on the first access.\n+///\n+/// This type is a thread-safe `Lazy`, and can be used in statics.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(once_cell)]\n+///\n+/// use std::collections::HashMap;\n+///\n+/// use std::lazy::SyncLazy;\n+///\n+/// static HASHMAP: SyncLazy<HashMap<i32, String>> = SyncLazy::new(|| {\n+///     println!(\"initializing\");\n+///     let mut m = HashMap::new();\n+///     m.insert(13, \"Spica\".to_string());\n+///     m.insert(74, \"Hoyten\".to_string());\n+///     m\n+/// });\n+///\n+/// fn main() {\n+///     println!(\"ready\");\n+///     std::thread::spawn(|| {\n+///         println!(\"{:?}\", HASHMAP.get(&13));\n+///     }).join().unwrap();\n+///     println!(\"{:?}\", HASHMAP.get(&74));\n+///\n+///     // Prints:\n+///     //   ready\n+///     //   initializing\n+///     //   Some(\"Spica\")\n+///     //   Some(\"Hoyten\")\n+/// }\n+/// ```\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+pub struct SyncLazy<T, F = fn() -> T> {\n+    cell: SyncOnceCell<T>,\n+    init: Cell<Option<F>>,\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: fmt::Debug, F> fmt::Debug for SyncLazy<T, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Lazy\").field(\"cell\", &self.cell).field(\"init\", &\"..\").finish()\n+    }\n+}\n+\n+// We never create a `&F` from a `&SyncLazy<T, F>` so it is fine\n+// to not impl `Sync` for `F`\n+// we do create a `&mut Option<F>` in `force`, but this is\n+// properly synchronized, so it only happens once\n+// so it also does not contribute to this impl.\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+unsafe impl<T, F: Send> Sync for SyncLazy<T, F> where SyncOnceCell<T>: Sync {}\n+// auto-derived `Send` impl is OK.\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T, F: RefUnwindSafe> RefUnwindSafe for SyncLazy<T, F> where SyncOnceCell<T>: RefUnwindSafe {}\n+\n+impl<T, F> SyncLazy<T, F> {\n+    /// Creates a new lazy value with the given initializing\n+    /// function.\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub const fn new(f: F) -> SyncLazy<T, F> {\n+        SyncLazy { cell: SyncOnceCell::new(), init: Cell::new(Some(f)) }\n+    }\n+}\n+\n+impl<T, F: FnOnce() -> T> SyncLazy<T, F> {\n+    /// Forces the evaluation of this lazy value and\n+    /// returns a reference to result. This is equivalent\n+    /// to the `Deref` impl, but is explicit.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::lazy::SyncLazy;\n+    ///\n+    /// let lazy = SyncLazy::new(|| 92);\n+    ///\n+    /// assert_eq!(SyncLazy::force(&lazy), &92);\n+    /// assert_eq!(&*lazy, &92);\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn force(this: &SyncLazy<T, F>) -> &T {\n+        this.cell.get_or_init(|| match this.init.take() {\n+            Some(f) => f(),\n+            None => panic!(\"Lazy instance has previously been poisoned\"),\n+        })\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T, F: FnOnce() -> T> Deref for SyncLazy<T, F> {\n+    type Target = T;\n+    fn deref(&self) -> &T {\n+        SyncLazy::force(self)\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: Default> Default for SyncLazy<T> {\n+    /// Creates a new lazy value using `Default` as the initializing function.\n+    fn default() -> SyncLazy<T> {\n+        SyncLazy::new(T::default)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::{\n+        lazy::{Lazy, SyncLazy, SyncOnceCell},\n+        panic,\n+        sync::{\n+            atomic::{AtomicUsize, Ordering::SeqCst},\n+            mpsc::channel,\n+            Mutex,\n+        },\n+    };\n+\n+    #[test]\n+    fn lazy_default() {\n+        static CALLED: AtomicUsize = AtomicUsize::new(0);\n+\n+        struct Foo(u8);\n+        impl Default for Foo {\n+            fn default() -> Self {\n+                CALLED.fetch_add(1, SeqCst);\n+                Foo(42)\n+            }\n+        }\n+\n+        let lazy: Lazy<Mutex<Foo>> = <_>::default();\n+\n+        assert_eq!(CALLED.load(SeqCst), 0);\n+\n+        assert_eq!(lazy.lock().unwrap().0, 42);\n+        assert_eq!(CALLED.load(SeqCst), 1);\n+\n+        lazy.lock().unwrap().0 = 21;\n+\n+        assert_eq!(lazy.lock().unwrap().0, 21);\n+        assert_eq!(CALLED.load(SeqCst), 1);\n+    }\n+\n+    #[test]\n+    fn lazy_poisoning() {\n+        let x: Lazy<String> = Lazy::new(|| panic!(\"kaboom\"));\n+        for _ in 0..2 {\n+            let res = panic::catch_unwind(panic::AssertUnwindSafe(|| x.len()));\n+            assert!(res.is_err());\n+        }\n+    }\n+\n+    // miri doesn't support threads\n+    #[cfg(not(miri))]\n+    fn spawn_and_wait<R: Send + 'static>(f: impl FnOnce() -> R + Send + 'static) -> R {\n+        crate::thread::spawn(f).join().unwrap()\n+    }\n+\n+    #[cfg(not(miri))]\n+    fn spawn(f: impl FnOnce() + Send + 'static) {\n+        let _ = crate::thread::spawn(f);\n+    }\n+\n+    // \"stub threads\" for Miri\n+    #[cfg(miri)]\n+    fn spawn_and_wait<R: Send + 'static>(f: impl FnOnce() -> R + Send + 'static) -> R {\n+        f(())\n+    }\n+\n+    #[cfg(miri)]\n+    fn spawn(f: impl FnOnce() + Send + 'static) {\n+        f(())\n+    }\n+\n+    #[test]\n+    fn sync_once_cell() {\n+        static ONCE_CELL: SyncOnceCell<i32> = SyncOnceCell::new();\n+\n+        assert!(ONCE_CELL.get().is_none());\n+\n+        spawn_and_wait(|| {\n+            ONCE_CELL.get_or_init(|| 92);\n+            assert_eq!(ONCE_CELL.get(), Some(&92));\n+        });\n+\n+        ONCE_CELL.get_or_init(|| panic!(\"Kabom!\"));\n+        assert_eq!(ONCE_CELL.get(), Some(&92));\n+    }\n+\n+    #[test]\n+    fn sync_once_cell_get_mut() {\n+        let mut c = SyncOnceCell::new();\n+        assert!(c.get_mut().is_none());\n+        c.set(90).unwrap();\n+        *c.get_mut().unwrap() += 2;\n+        assert_eq!(c.get_mut(), Some(&mut 92));\n+    }\n+\n+    #[test]\n+    fn sync_once_cell_get_unchecked() {\n+        let c = SyncOnceCell::new();\n+        c.set(92).unwrap();\n+        unsafe {\n+            assert_eq!(c.get_unchecked(), &92);\n+        }\n+    }\n+\n+    #[test]\n+    fn sync_once_cell_drop() {\n+        static DROP_CNT: AtomicUsize = AtomicUsize::new(0);\n+        struct Dropper;\n+        impl Drop for Dropper {\n+            fn drop(&mut self) {\n+                DROP_CNT.fetch_add(1, SeqCst);\n+            }\n+        }\n+\n+        let x = SyncOnceCell::new();\n+        spawn_and_wait(move || {\n+            x.get_or_init(|| Dropper);\n+            assert_eq!(DROP_CNT.load(SeqCst), 0);\n+            drop(x);\n+        });\n+\n+        assert_eq!(DROP_CNT.load(SeqCst), 1);\n+    }\n+\n+    #[test]\n+    fn sync_once_cell_drop_empty() {\n+        let x = SyncOnceCell::<String>::new();\n+        drop(x);\n+    }\n+\n+    #[test]\n+    fn clone() {\n+        let s = SyncOnceCell::new();\n+        let c = s.clone();\n+        assert!(c.get().is_none());\n+\n+        s.set(\"hello\".to_string()).unwrap();\n+        let c = s.clone();\n+        assert_eq!(c.get().map(String::as_str), Some(\"hello\"));\n+    }\n+\n+    #[test]\n+    fn get_or_try_init() {\n+        let cell: SyncOnceCell<String> = SyncOnceCell::new();\n+        assert!(cell.get().is_none());\n+\n+        let res = panic::catch_unwind(|| cell.get_or_try_init(|| -> Result<_, ()> { panic!() }));\n+        assert!(res.is_err());\n+        assert!(!cell.is_initialized());\n+        assert!(cell.get().is_none());\n+\n+        assert_eq!(cell.get_or_try_init(|| Err(())), Err(()));\n+\n+        assert_eq!(\n+            cell.get_or_try_init(|| Ok::<_, ()>(\"hello\".to_string())),\n+            Ok(&\"hello\".to_string())\n+        );\n+        assert_eq!(cell.get(), Some(&\"hello\".to_string()));\n+    }\n+\n+    #[test]\n+    fn from_impl() {\n+        assert_eq!(SyncOnceCell::from(\"value\").get(), Some(&\"value\"));\n+        assert_ne!(SyncOnceCell::from(\"foo\").get(), Some(&\"bar\"));\n+    }\n+\n+    #[test]\n+    fn partialeq_impl() {\n+        assert!(SyncOnceCell::from(\"value\") == SyncOnceCell::from(\"value\"));\n+        assert!(SyncOnceCell::from(\"foo\") != SyncOnceCell::from(\"bar\"));\n+\n+        assert!(SyncOnceCell::<String>::new() == SyncOnceCell::new());\n+        assert!(SyncOnceCell::<String>::new() != SyncOnceCell::from(\"value\".to_owned()));\n+    }\n+\n+    #[test]\n+    fn into_inner() {\n+        let cell: SyncOnceCell<String> = SyncOnceCell::new();\n+        assert_eq!(cell.into_inner(), None);\n+        let cell = SyncOnceCell::new();\n+        cell.set(\"hello\".to_string()).unwrap();\n+        assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n+    }\n+\n+    #[test]\n+    fn sync_lazy_new() {\n+        static CALLED: AtomicUsize = AtomicUsize::new(0);\n+        static SYNC_LAZY: SyncLazy<i32> = SyncLazy::new(|| {\n+            CALLED.fetch_add(1, SeqCst);\n+            92\n+        });\n+\n+        assert_eq!(CALLED.load(SeqCst), 0);\n+\n+        spawn_and_wait(|| {\n+            let y = *SYNC_LAZY - 30;\n+            assert_eq!(y, 62);\n+            assert_eq!(CALLED.load(SeqCst), 1);\n+        });\n+\n+        let y = *SYNC_LAZY - 30;\n+        assert_eq!(y, 62);\n+        assert_eq!(CALLED.load(SeqCst), 1);\n+    }\n+\n+    #[test]\n+    fn sync_lazy_default() {\n+        static CALLED: AtomicUsize = AtomicUsize::new(0);\n+\n+        struct Foo(u8);\n+        impl Default for Foo {\n+            fn default() -> Self {\n+                CALLED.fetch_add(1, SeqCst);\n+                Foo(42)\n+            }\n+        }\n+\n+        let lazy: SyncLazy<Mutex<Foo>> = <_>::default();\n+\n+        assert_eq!(CALLED.load(SeqCst), 0);\n+\n+        assert_eq!(lazy.lock().unwrap().0, 42);\n+        assert_eq!(CALLED.load(SeqCst), 1);\n+\n+        lazy.lock().unwrap().0 = 21;\n+\n+        assert_eq!(lazy.lock().unwrap().0, 21);\n+        assert_eq!(CALLED.load(SeqCst), 1);\n+    }\n+\n+    #[test]\n+    #[cfg_attr(miri, ignore)] // leaks memory\n+    fn static_sync_lazy() {\n+        static XS: SyncLazy<Vec<i32>> = SyncLazy::new(|| {\n+            let mut xs = Vec::new();\n+            xs.push(1);\n+            xs.push(2);\n+            xs.push(3);\n+            xs\n+        });\n+\n+        spawn_and_wait(|| {\n+            assert_eq!(&*XS, &vec![1, 2, 3]);\n+        });\n+\n+        assert_eq!(&*XS, &vec![1, 2, 3]);\n+    }\n+\n+    #[test]\n+    #[cfg_attr(miri, ignore)] // leaks memory\n+    fn static_sync_lazy_via_fn() {\n+        fn xs() -> &'static Vec<i32> {\n+            static XS: SyncOnceCell<Vec<i32>> = SyncOnceCell::new();\n+            XS.get_or_init(|| {\n+                let mut xs = Vec::new();\n+                xs.push(1);\n+                xs.push(2);\n+                xs.push(3);\n+                xs\n+            })\n+        }\n+        assert_eq!(xs(), &vec![1, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn sync_lazy_poisoning() {\n+        let x: SyncLazy<String> = SyncLazy::new(|| panic!(\"kaboom\"));\n+        for _ in 0..2 {\n+            let res = panic::catch_unwind(|| x.len());\n+            assert!(res.is_err());\n+        }\n+    }\n+\n+    #[test]\n+    fn is_sync_send() {\n+        fn assert_traits<T: Send + Sync>() {}\n+        assert_traits::<SyncOnceCell<String>>();\n+        assert_traits::<SyncLazy<String>>();\n+    }\n+\n+    #[test]\n+    fn eval_once_macro() {\n+        macro_rules! eval_once {\n+            (|| -> $ty:ty {\n+                $($body:tt)*\n+            }) => {{\n+                static ONCE_CELL: SyncOnceCell<$ty> = SyncOnceCell::new();\n+                fn init() -> $ty {\n+                    $($body)*\n+                }\n+                ONCE_CELL.get_or_init(init)\n+            }};\n+        }\n+\n+        let fib: &'static Vec<i32> = eval_once! {\n+            || -> Vec<i32> {\n+                let mut res = vec![1, 1];\n+                for i in 0..10 {\n+                    let next = res[i] + res[i + 1];\n+                    res.push(next);\n+                }\n+                res\n+            }\n+        };\n+        assert_eq!(fib[5], 8)\n+    }\n+\n+    #[test]\n+    #[cfg_attr(miri, ignore)] // deadlocks without real threads\n+    fn sync_once_cell_does_not_leak_partially_constructed_boxes() {\n+        static ONCE_CELL: SyncOnceCell<String> = SyncOnceCell::new();\n+\n+        let n_readers = 10;\n+        let n_writers = 3;\n+        const MSG: &str = \"Hello, World\";\n+\n+        let (tx, rx) = channel();\n+\n+        for _ in 0..n_readers {\n+            let tx = tx.clone();\n+            spawn(move || {\n+                loop {\n+                    if let Some(msg) = ONCE_CELL.get() {\n+                        tx.send(msg).unwrap();\n+                        break;\n+                    }\n+                }\n+            });\n+        }\n+        for _ in 0..n_writers {\n+            spawn(move || {\n+                let _ = ONCE_CELL.set(MSG.to_owned());\n+            });\n+        }\n+\n+        for _ in 0..n_readers {\n+            let msg = rx.recv().unwrap();\n+            assert_eq!(msg, MSG);\n+        }\n+    }\n+}"}, {"sha": "be8d9f7a7c9cd2d914c444bc33c62f184b5b4a21", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/01418bd1aa71a38567b9fea737d74379133d28c0/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01418bd1aa71a38567b9fea737d74379133d28c0/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=01418bd1aa71a38567b9fea737d74379133d28c0", "patch": "@@ -287,13 +287,15 @@\n #![feature(linkage)]\n #![feature(llvm_asm)]\n #![feature(log_syntax)]\n+#![feature(maybe_uninit_extra)]\n #![feature(maybe_uninit_ref)]\n #![feature(maybe_uninit_slice)]\n #![feature(min_specialization)]\n #![feature(needs_panic_runtime)]\n #![feature(negative_impls)]\n #![feature(never_type)]\n #![feature(nll)]\n+#![feature(once_cell)]\n #![feature(optin_builtin_traits)]\n #![feature(or_patterns)]\n #![feature(panic_info_message)]\n@@ -477,6 +479,9 @@ pub mod process;\n pub mod sync;\n pub mod time;\n \n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+pub mod lazy;\n+\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub mod task {\n     //! Types and Traits for working with asynchronous tasks."}, {"sha": "64260990824b86fdc9e51afeed8aeca6dea34ff9", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/01418bd1aa71a38567b9fea737d74379133d28c0/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01418bd1aa71a38567b9fea737d74379133d28c0/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=01418bd1aa71a38567b9fea737d74379133d28c0", "patch": "@@ -132,6 +132,7 @@ unsafe impl Send for Once {}\n #[derive(Debug)]\n pub struct OnceState {\n     poisoned: bool,\n+    set_state_on_drop_to: Cell<usize>,\n }\n \n /// Initialization value for static [`Once`] values.\n@@ -321,7 +322,7 @@ impl Once {\n         }\n \n         let mut f = Some(f);\n-        self.call_inner(true, &mut |p| f.take().unwrap()(&OnceState { poisoned: p }));\n+        self.call_inner(true, &mut |p| f.take().unwrap()(p));\n     }\n \n     /// Returns `true` if some `call_once` call has completed\n@@ -385,7 +386,7 @@ impl Once {\n     // currently no way to take an `FnOnce` and call it via virtual dispatch\n     // without some allocation overhead.\n     #[cold]\n-    fn call_inner(&self, ignore_poisoning: bool, init: &mut dyn FnMut(bool)) {\n+    fn call_inner(&self, ignore_poisoning: bool, init: &mut dyn FnMut(&OnceState)) {\n         let mut state_and_queue = self.state_and_queue.load(Ordering::Acquire);\n         loop {\n             match state_and_queue {\n@@ -413,8 +414,12 @@ impl Once {\n                     };\n                     // Run the initialization function, letting it know if we're\n                     // poisoned or not.\n-                    init(state_and_queue == POISONED);\n-                    waiter_queue.set_state_on_drop_to = COMPLETE;\n+                    let init_state = OnceState {\n+                        poisoned: state_and_queue == POISONED,\n+                        set_state_on_drop_to: Cell::new(COMPLETE),\n+                    };\n+                    init(&init_state);\n+                    waiter_queue.set_state_on_drop_to = init_state.set_state_on_drop_to.get();\n                     break;\n                 }\n                 _ => {\n@@ -554,6 +559,14 @@ impl OnceState {\n     pub fn poisoned(&self) -> bool {\n         self.poisoned\n     }\n+\n+    /// Poison the associated [`Once`] without explicitly panicking.\n+    ///\n+    /// [`Once`]: struct.Once.html\n+    // NOTE: This is currently only exposed for the `lazy` module\n+    pub(crate) fn poison(&self) {\n+        self.set_state_on_drop_to.set(POISONED);\n+    }\n }\n \n #[cfg(all(test, not(target_os = \"emscripten\")))]"}]}