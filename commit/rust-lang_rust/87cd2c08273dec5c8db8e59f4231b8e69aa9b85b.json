{"sha": "87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3Y2QyYzA4MjczZGVjNWM4ZGI4ZTU5ZjQyMzFiOGU2OWFhOWI4NWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-10T00:39:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-10T00:39:29Z"}, "message": "Auto merge of #28861 - pnkfelix:fsk-nonparam-dropck-issue28498, r=arielb1\n\nimplement RFC 1238: nonparametric dropck.\r\n\r\ncc #28498 \r\n\r\ncc @nikomatsakis", "tree": {"sha": "24c7c70c06fbcd88be686bcf4e11d5ffc10aa27c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24c7c70c06fbcd88be686bcf4e11d5ffc10aa27c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "html_url": "https://github.com/rust-lang/rust/commit/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "439311d9382abd5d22c9068f3f158d3b9ef6d1c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/439311d9382abd5d22c9068f3f158d3b9ef6d1c9", "html_url": "https://github.com/rust-lang/rust/commit/439311d9382abd5d22c9068f3f158d3b9ef6d1c9"}, {"sha": "a445f234a64cdbbf946af012b94dccf91447b5ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/a445f234a64cdbbf946af012b94dccf91447b5ff", "html_url": "https://github.com/rust-lang/rust/commit/a445f234a64cdbbf946af012b94dccf91447b5ff"}], "stats": {"total": 873, "additions": 770, "deletions": 103}, "files": [{"sha": "7c097c9126679515e49ee24bb61c3ccad4b212c5", "filename": "src/doc/nomicon/dropck.md", "status": "modified", "additions": 154, "deletions": 5, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Fdoc%2Fnomicon%2Fdropck.md", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Fdoc%2Fnomicon%2Fdropck.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fdropck.md?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -115,13 +115,162 @@ section:\n **For a generic type to soundly implement drop, its generics arguments must\n strictly outlive it.**\n \n-This rule is sufficient but not necessary to satisfy the drop checker. That is,\n-if your type obeys this rule then it's definitely sound to drop. However\n-there are special cases where you can fail to satisfy this, but still\n-successfully pass the borrow checker. These are the precise rules that are\n-currently up in the air.\n+Obeying this rule is (usually) necessary to satisfy the borrow\n+checker; obeying it is sufficient but not necessary to be\n+sound. That is, if your type obeys this rule then it's definitely\n+sound to drop.\n+\n+The reason that it is not always necessary to satisfy the above rule\n+is that some Drop implementations will not access borrowed data even\n+though their type gives them the capability for such access.\n+\n+For example, this variant of the above `Inspector` example will never\n+accessed borrowed data:\n+\n+```rust,ignore\n+struct Inspector<'a>(&'a u8, &'static str);\n+\n+impl<'a> Drop for Inspector<'a> {\n+    fn drop(&mut self) {\n+        println!(\"Inspector(_, {}) knows when *not* to inspect.\", self.1);\n+    }\n+}\n+\n+fn main() {\n+    let (inspector, days);\n+    days = Box::new(1);\n+    inspector = Inspector(&days, \"gadget\");\n+    // Let's say `days` happens to get dropped first.\n+    // Even when Inspector is dropped, its destructor will not access the\n+    // borrowed `days`.\n+}\n+```\n+\n+Likewise, this variant will also never access borrowed data:\n+\n+```rust,ignore\n+use std::fmt;\n+\n+struct Inspector<T: fmt::Display>(T, &'static str);\n+\n+impl<T: fmt::Display> Drop for Inspector<T> {\n+    fn drop(&mut self) {\n+        println!(\"Inspector(_, {}) knows when *not* to inspect.\", self.1);\n+    }\n+}\n+\n+fn main() {\n+    let (inspector, days): (Inspector<&u8>, Box<u8>);\n+    days = Box::new(1);\n+    inspector = Inspector(&days, \"gadget\");\n+    // Let's say `days` happens to get dropped first.\n+    // Even when Inspector is dropped, its destructor will not access the\n+    // borrowed `days`.\n+}\n+```\n+\n+However, *both* of the above variants are rejected by the borrow\n+checker during the analysis of `fn main`, saying that `days` does not\n+live long enough.\n+\n+The reason is that the borrow checking analysis of `main` does not\n+know about the internals of each Inspector's Drop implementation.  As\n+far as the borrow checker knows while it is analyzing `main`, the body\n+of an inspector's destructor might access that borrowed data.\n+\n+Therefore, the drop checker forces all borrowed data in a value to\n+strictly outlive that value.\n+\n+# An Escape Hatch\n+\n+The precise rules that govern drop checking may be less restrictive in\n+the future.\n+\n+The current analysis is deliberately conservative and trivial; it forces all\n+borrowed data in a value to outlive that value, which is certainly sound.\n+\n+Future versions of the language may make the analysis more precise, to\n+reduce the number of cases where sound code is rejected as unsafe.\n+This would help address cases such as the two Inspectors above that\n+know not to inspect during destruction.\n+\n+In the meantime, there is an unstable attribute that one can use to\n+assert (unsafely) that a generic type's destructor is *guaranteed* to\n+not access any expired data, even if its type gives it the capability\n+to do so.\n+\n+That attribute is called `unsafe_destructor_blind_to_params`.\n+To deploy it on the Inspector example from above, we would write:\n+\n+```rust,ignore\n+struct Inspector<'a>(&'a u8, &'static str);\n+\n+impl<'a> Drop for Inspector<'a> {\n+    #[unsafe_destructor_blind_to_params]\n+    fn drop(&mut self) {\n+        println!(\"Inspector(_, {}) knows when *not* to inspect.\", self.1);\n+    }\n+}\n+```\n+\n+This attribute has the word `unsafe` in it because the compiler is not\n+checking the implicit assertion that no potentially expired data\n+(e.g. `self.0` above) is accessed.\n+\n+It is sometimes obvious that no such access can occur, like the case above.\n+However, when dealing with a generic type parameter, such access can\n+occur indirectly. Examples of such indirect access are:\n+ * invoking a callback,\n+ * via a trait method call.\n+\n+(Future changes to the language, such as impl specialization, may add\n+other avenues for such indirect access.)\n+\n+Here is an example of invoking a callback:\n+\n+```rust,ignore\n+struct Inspector<T>(T, &'static str, Box<for <'r> fn(&'r T) -> String>);\n+\n+impl<T> Drop for Inspector<T> {\n+    fn drop(&mut self) {\n+        // The `self.2` call could access a borrow e.g. if `T` is `&'a _`.\n+        println!(\"Inspector({}, {}) unwittingly inspects expired data.\",\n+                 (self.2)(&self.0), self.1);\n+    }\n+}\n+```\n+\n+Here is an example of a trait method call:\n+\n+```rust,ignore\n+use std::fmt;\n+\n+struct Inspector<T: fmt::Display>(T, &'static str);\n+\n+impl<T: fmt::Display> Drop for Inspector<T> {\n+    fn drop(&mut self) {\n+        // There is a hidden call to `<T as Display>::fmt` below, which\n+        // could access a borrow e.g. if `T` is `&'a _`\n+        println!(\"Inspector({}, {}) unwittingly inspects expired data.\",\n+                 self.0, self.1);\n+    }\n+}\n+```\n+\n+And of course, all of these accesses could be further hidden within\n+some other method invoked by the destructor, rather than being written\n+directly within it.\n+\n+In all of the above cases where the `&'a u8` is accessed in the\n+destructor, adding the `#[unsafe_destructor_blind_to_params]`\n+attribute makes the type vulnerable to misuse that the borrower\n+checker will not catch, inviting havoc. It is better to avoid adding\n+the attribute.\n+\n+# Is that all about drop checker?\n \n It turns out that when writing unsafe code, we generally don't need to\n worry at all about doing the right thing for the drop checker. However there\n is one special case that you need to worry about, which we will look at in\n the next section.\n+"}, {"sha": "ac0fbea8ad8a5c480e7e17df29f567090d094935", "filename": "src/doc/reference.md", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -1929,6 +1929,20 @@ macro scope.\n - `simd` - on certain tuple structs, derive the arithmetic operators, which\n   lower to the target's SIMD instructions, if any; the `simd` feature gate\n   is necessary to use this attribute.\n+- `unsafe_destructor_blind_to_params` - on `Drop::drop` method, asserts that the\n+  destructor code (and all potential specializations of that code) will\n+  never attempt to read from nor write to any references with lifetimes\n+  that come in via generic parameters. This is a constraint we cannot\n+  currently express via the type system, and therefore we rely on the\n+  programmer to assert that it holds. Adding this to a Drop impl causes\n+  the associated destructor to be considered \"uninteresting\" by the\n+  Drop-Check rule, and thus it can help sidestep data ordering\n+  constraints that would otherwise be introduced by the Drop-Check\n+  rule. Such sidestepping of the constraints, if done incorrectly, can\n+  lead to undefined behavior (in the form of reading or writing to data\n+  outside of its dynamic extent), and thus this attribute has the word\n+  \"unsafe\" in its name. To use this, the\n+  `unsafe_destructor_blind_to_params` feature gate must be enabled.\n - `unsafe_no_drop_flag` - on structs, remove the flag that prevents\n   destructors from being run twice. Destructors might be run multiple times on\n   the same object with this attribute. To use this, the `unsafe_no_drop_flag` feature"}, {"sha": "36989c2daad21807aef847f46ca4b4d45626a1ed", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -550,6 +550,7 @@ impl<T: ?Sized> Drop for Arc<T> {\n     ///\n     /// } // implicit drop\n     /// ```\n+    #[unsafe_destructor_blind_to_params]\n     #[inline]\n     fn drop(&mut self) {\n         // This structure has #[unsafe_no_drop_flag], so this drop glue may run"}, {"sha": "8ecc78a231e338c8f682ca5da974e9f61ac6267e", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -94,6 +94,11 @@\n #![feature(unboxed_closures)]\n #![feature(unique)]\n #![feature(unsafe_no_drop_flag, filling_drop)]\n+// SNAP 1af31d4\n+#![allow(unused_features)]\n+// SNAP 1af31d4\n+#![allow(unused_attributes)]\n+#![feature(dropck_parametricity)]\n #![feature(unsize)]\n #![feature(core_slice_ext)]\n #![feature(core_str_ext)]"}, {"sha": "49d37698154fd1bd14b4b9516ec711630fb7f5fc", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -445,6 +445,7 @@ impl<T> RawVec<T> {\n }\n \n impl<T> Drop for RawVec<T> {\n+    #[unsafe_destructor_blind_to_params]\n     /// Frees the memory owned by the RawVec *without* trying to Drop its contents.\n     fn drop(&mut self) {\n         let elem_size = mem::size_of::<T>();"}, {"sha": "06d03161ca1c5219b66c6f7e8eefde5c04278a26", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -451,6 +451,7 @@ impl<T: ?Sized> Drop for Rc<T> {\n     ///\n     /// } // implicit drop\n     /// ```\n+    #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n         unsafe {\n             let ptr = *self._ptr;"}, {"sha": "62463ecabbf5539d7a650b03c641540e5b950dae", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -38,8 +38,14 @@\n #![feature(ptr_as_ref)]\n #![feature(raw)]\n #![feature(staged_api)]\n+#![feature(dropck_parametricity)]\n #![cfg_attr(test, feature(test))]\n \n+// SNAP 1af31d4\n+#![allow(unused_features)]\n+// SNAP 1af31d4\n+#![allow(unused_attributes)]\n+\n extern crate alloc;\n \n use std::cell::{Cell, RefCell};\n@@ -510,6 +516,7 @@ impl<T> TypedArena<T> {\n }\n \n impl<T> Drop for TypedArena<T> {\n+    #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n         unsafe {\n             // Determine how much was filled."}, {"sha": "bde0d0e6b5f81438ea1330a255765349f94e6724", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -275,12 +275,14 @@ impl<T> DoubleEndedIterator for RawItems<T> {\n }\n \n impl<T> Drop for RawItems<T> {\n+    #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n         for _ in self {}\n     }\n }\n \n impl<K, V> Drop for Node<K, V> {\n+    #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n         if self.keys.is_null() ||\n             (unsafe { self.keys.get() as *const K as usize == mem::POST_DROP_USIZE })\n@@ -1419,6 +1421,7 @@ impl<K, V> TraversalImpl for MoveTraversalImpl<K, V> {\n }\n \n impl<K, V> Drop for MoveTraversalImpl<K, V> {\n+    #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n         // We need to cleanup the stored values manually, as the RawItems destructor would run\n         // after our deallocation."}, {"sha": "4292c200fbe2f0b6ad4d80432e3f1d4d81f26028", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -32,6 +32,11 @@\n #![allow(trivial_casts)]\n #![cfg_attr(test, allow(deprecated))] // rand\n \n+// SNAP 1af31d4\n+#![allow(unused_features)]\n+// SNAP 1af31d4\n+#![allow(unused_attributes)]\n+\n #![feature(alloc)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n@@ -59,6 +64,7 @@\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(unique)]\n+#![feature(dropck_parametricity)]\n #![feature(unsafe_no_drop_flag, filling_drop)]\n #![feature(decode_utf16)]\n #![feature(utf8_error)]"}, {"sha": "fca7d3b26fc2e538d98fadaeae14a276dca3d8d7", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -655,6 +655,7 @@ impl<T> LinkedList<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for LinkedList<T> {\n+    #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n         // Dissolve the linked_list in a loop.\n         // Just dropping the list_head can lead to stack exhaustion"}, {"sha": "d374c0959f3572ea6f483b23a9f0830032723e04", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -1385,6 +1385,7 @@ impl<T: Ord> Ord for Vec<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Vec<T> {\n+    #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n         // NOTE: this is currently abusing the fact that ZSTs can't impl Drop.\n         // Or rather, that impl'ing Drop makes them not zero-sized. This is"}, {"sha": "d438c27a96fa0621228dfcce5b961cdc891ee00e", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -64,6 +64,7 @@ impl<T: Clone> Clone for VecDeque<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for VecDeque<T> {\n+    #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n         self.clear();\n         // RawVec handles deallocation"}, {"sha": "a8f7a4db1338de9ab3adeb94275147c04166d323", "filename": "src/librustc/middle/ty/util.rs", "status": "modified", "additions": 22, "deletions": 72, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -566,84 +566,34 @@ impl<'tcx> ty::ctxt<'tcx> {\n         }\n     }\n \n-    /// Returns true if this ADT is a dtorck type, i.e. whether it being\n-    /// safe for destruction requires it to be alive\n+    /// Returns true if this ADT is a dtorck type.\n+    ///\n+    /// Invoking the destructor of a dtorck type during usual cleanup\n+    /// (e.g. the glue emitted for stack unwinding) requires all\n+    /// lifetimes in the type-structure of `adt` to strictly outlive\n+    /// the adt value itself.\n+    ///\n+    /// If `adt` is not dtorck, then the adt's destructor can be\n+    /// invoked even when there are lifetimes in the type-structure of\n+    /// `adt` that do not strictly outlive the adt value itself.\n+    /// (This allows programs to make cyclic structures without\n+    /// resorting to unasfe means; see RFCs 769 and 1238).\n     pub fn is_adt_dtorck(&self, adt: ty::AdtDef<'tcx>) -> bool {\n         let dtor_method = match adt.destructor() {\n             Some(dtor) => dtor,\n             None => return false\n         };\n-        let impl_did = self.impl_of_method(dtor_method).unwrap_or_else(|| {\n-            self.sess.bug(&format!(\"no Drop impl for the dtor of `{:?}`\", adt))\n-        });\n-        let generics = adt.type_scheme(self).generics;\n-\n-        // In `impl<'a> Drop ...`, we automatically assume\n-        // `'a` is meaningful and thus represents a bound\n-        // through which we could reach borrowed data.\n-        //\n-        // FIXME (pnkfelix): In the future it would be good to\n-        // extend the language to allow the user to express,\n-        // in the impl signature, that a lifetime is not\n-        // actually used (something like `where 'a: ?Live`).\n-        if generics.has_region_params(subst::TypeSpace) {\n-            debug!(\"typ: {:?} has interesting dtor due to region params\",\n-                   adt);\n-            return true;\n-        }\n-\n-        let mut seen_items = Vec::new();\n-        let mut items_to_inspect = vec![impl_did];\n-        while let Some(item_def_id) = items_to_inspect.pop() {\n-            if seen_items.contains(&item_def_id) {\n-                continue;\n-            }\n-\n-            for pred in self.lookup_predicates(item_def_id).predicates {\n-                let result = match pred {\n-                    ty::Predicate::Equate(..) |\n-                    ty::Predicate::RegionOutlives(..) |\n-                    ty::Predicate::TypeOutlives(..) |\n-                    ty::Predicate::WellFormed(..) |\n-                    ty::Predicate::ObjectSafe(..) |\n-                    ty::Predicate::Projection(..) => {\n-                        // For now, assume all these where-clauses\n-                        // may give drop implementation capabilty\n-                        // to access borrowed data.\n-                        true\n-                    }\n \n-                    ty::Predicate::Trait(ty::Binder(ref t_pred)) => {\n-                        let def_id = t_pred.trait_ref.def_id;\n-                        if self.trait_items(def_id).len() != 0 {\n-                            // If trait has items, assume it adds\n-                            // capability to access borrowed data.\n-                            true\n-                        } else {\n-                            // Trait without items is itself\n-                            // uninteresting from POV of dropck.\n-                            //\n-                            // However, may have parent w/ items;\n-                            // so schedule checking of predicates,\n-                            items_to_inspect.push(def_id);\n-                            // and say \"no capability found\" for now.\n-                            false\n-                        }\n-                    }\n-                };\n-\n-                if result {\n-                    debug!(\"typ: {:?} has interesting dtor due to generic preds, e.g. {:?}\",\n-                           adt, pred);\n-                    return true;\n-                }\n-            }\n-\n-            seen_items.push(item_def_id);\n-        }\n-\n-        debug!(\"typ: {:?} is dtorck-safe\", adt);\n-        false\n+        // RFC 1238: if the destructor method is tagged with the\n+        // attribute `unsafe_destructor_blind_to_params`, then the\n+        // compiler is being instructed to *assume* that the\n+        // destructor will not access borrowed data,\n+        // even if such data is otherwise reachable.\n+        //\n+        // Such access can be in plain sight (e.g. dereferencing\n+        // `*foo.0` of `Foo<'a>(&'a u32)`) or indirectly hidden\n+        // (e.g. calling `foo.0.clone()` of `Foo<T:Clone>`).\n+        return !self.has_attr(dtor_method, \"unsafe_destructor_blind_to_params\");\n     }\n }\n "}, {"sha": "d68959b99be0fee092346608b85510357499050e", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 46, "deletions": 25, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -217,26 +217,52 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n ///\n /// ----\n ///\n-/// The Drop Check Rule is the following:\n+/// The simplified (*) Drop Check Rule is the following:\n ///\n /// Let `v` be some value (either temporary or named) and 'a be some\n /// lifetime (scope). If the type of `v` owns data of type `D`, where\n ///\n-/// * (1.) `D` has a lifetime- or type-parametric Drop implementation, and\n-/// * (2.) the structure of `D` can reach a reference of type `&'a _`, and\n-/// * (3.) either:\n-///   * (A.) the Drop impl for `D` instantiates `D` at 'a directly,\n-///          i.e. `D<'a>`, or,\n-///   * (B.) the Drop impl for `D` has some type parameter with a\n-///          trait bound `T` where `T` is a trait that has at least\n-///          one method,\n+/// * (1.) `D` has a lifetime- or type-parametric Drop implementation,\n+///        (where that `Drop` implementation does not opt-out of\n+///         this check via the `unsafe_destructor_blind_to_params`\n+///         attribute), and\n+/// * (2.) the structure of `D` can reach a reference of type `&'a _`,\n ///\n /// then 'a must strictly outlive the scope of v.\n ///\n /// ----\n ///\n /// This function is meant to by applied to the type for every\n /// expression in the program.\n+///\n+/// ----\n+///\n+/// (*) The qualifier \"simplified\" is attached to the above\n+/// definition of the Drop Check Rule, because it is a simplification\n+/// of the original Drop Check rule, which attempted to prove that\n+/// some `Drop` implementations could not possibly access data even if\n+/// it was technically reachable, due to parametricity.\n+///\n+/// However, (1.) parametricity on its own turned out to be a\n+/// necessary but insufficient condition, and (2.)  future changes to\n+/// the language are expected to make it impossible to ensure that a\n+/// `Drop` implementation is actually parametric with respect to any\n+/// particular type parameter. (In particular, impl specialization is\n+/// expected to break the needed parametricity property beyond\n+/// repair.)\n+///\n+/// Therefore we have scaled back Drop-Check to a more conservative\n+/// rule that does not attempt to deduce whether a `Drop`\n+/// implementation could not possible access data of a given lifetime;\n+/// instead Drop-Check now simply assumes that if a destructor has\n+/// access (direct or indirect) to a lifetime parameter, then that\n+/// lifetime must be forced to outlive that destructor's dynamic\n+/// extent. We then provide the `unsafe_destructor_blind_to_params`\n+/// attribute as a way for destructor implementations to opt-out of\n+/// this conservative assumption (and thus assume the obligation of\n+/// ensuring that they do not access data nor invoke methods of\n+/// values that have been previously dropped).\n+///\n pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                                          typ: ty::Ty<'tcx>,\n                                                          span: Span,\n@@ -356,30 +382,25 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n     // borrowed data reachable via `typ` must outlive the parent\n     // of `scope`. This is handled below.\n     //\n-    // However, there is an important special case: by\n-    // parametricity, any generic type parameters have *no* trait\n-    // bounds in the Drop impl can not be used in any way (apart\n-    // from being dropped), and thus we can treat data borrowed\n-    // via such type parameters remains unreachable.\n+    // However, there is an important special case: for any Drop\n+    // impl that is tagged as \"blind\" to their parameters,\n+    // we assume that data borrowed via such type parameters\n+    // remains unreachable via that Drop impl.\n+    //\n+    // For example, consider:\n+    //\n+    // ```rust\n+    // #[unsafe_destructor_blind_to_params]\n+    // impl<T> Drop for Vec<T> { ... }\n+    // ```\n     //\n-    // For example, consider `impl<T> Drop for Vec<T> { ... }`,\n     // which does have to be able to drop instances of `T`, but\n     // otherwise cannot read data from `T`.\n     //\n     // Of course, for the type expression passed in for any such\n     // unbounded type parameter `T`, we must resume the recursive\n     // analysis on `T` (since it would be ignored by\n     // type_must_outlive).\n-    //\n-    // FIXME (pnkfelix): Long term, we could be smart and actually\n-    // feed which generic parameters can be ignored *into* `fn\n-    // type_must_outlive` (or some generalization thereof). But\n-    // for the short term, it probably covers most cases of\n-    // interest to just special case Drop impls where: (1.) there\n-    // are no generic lifetime parameters and (2.)  *all* generic\n-    // type parameters are unbounded.  If both conditions hold, we\n-    // simply skip the `type_must_outlive` call entirely (but\n-    // resume the recursive checking of the type-substructure).\n     if has_dtor_of_interest(tcx, ty) {\n         debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n                 {}ty: {} - is a dtorck type!\","}, {"sha": "e8796dd10b4f866cbf3b87e69bd23104430fe663", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -999,6 +999,7 @@ impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n }\n \n impl<K, V> Drop for RawTable<K, V> {\n+    #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n         if self.capacity == 0 || self.capacity == mem::POST_DROP_USIZE {\n             return;"}, {"sha": "9af766ad2af3595452a21801f8e9794ba255f1f3", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -199,6 +199,11 @@\n        test(no_crate_inject, attr(deny(warnings))),\n        test(attr(allow(dead_code, deprecated, unused_variables, unused_mut))))]\n \n+// SNAP 1af31d4\n+#![allow(unused_features)]\n+// SNAP 1af31d4\n+#![allow(unused_attributes)]\n+\n #![feature(alloc)]\n #![feature(allow_internal_unstable)]\n #![feature(associated_consts)]\n@@ -241,6 +246,7 @@\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(unique)]\n+#![feature(dropck_parametricity)]\n #![feature(unsafe_no_drop_flag, filling_drop)]\n #![feature(decode_utf16)]\n #![feature(unwind_attributes)]"}, {"sha": "1d545268e57d760965cd7ef7995a89a167353feb", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -136,6 +136,10 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Option<u32>, Status\n     // switch to Accepted; see RFC 320)\n     (\"unsafe_no_drop_flag\", \"1.0.0\", None, Active),\n \n+    // Allows using the unsafe_destructor_blind_to_params attribute;\n+    // RFC 1238\n+    (\"dropck_parametricity\", \"1.3.0\", Some(28498), Active),\n+\n     // Allows the use of custom attributes; RFC 572\n     (\"custom_attribute\", \"1.0.0\", None, Active),\n \n@@ -339,6 +343,11 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n     (\"unsafe_no_drop_flag\", Whitelisted, Gated(\"unsafe_no_drop_flag\",\n                                                \"unsafe_no_drop_flag has unstable semantics \\\n                                                 and may be removed in the future\")),\n+    (\"unsafe_destructor_blind_to_params\",\n+     Normal,\n+     Gated(\"dropck_parametricity\",\n+           \"unsafe_destructor_blind_to_params has unstable semantics \\\n+            and may be removed in the future\")),\n     (\"unwind\", Whitelisted, Gated(\"unwind_attributes\", \"#[unwind] is experimental\")),\n \n     // used in resolve"}, {"sha": "aa479a987a35b0fa5aa1557ef431a51ffa3466c1", "filename": "src/test/compile-fail/feature-gate-dropck-ugeh.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Ftest%2Fcompile-fail%2Ffeature-gate-dropck-ugeh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Ftest%2Fcompile-fail%2Ffeature-gate-dropck-ugeh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-dropck-ugeh.rs?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Ensure that attempts to use the unsafe attribute are feature-gated.\n+\n+// Example adapted from RFC 1238 text (just left out the feature gate).\n+\n+// https://github.com/rust-lang/rfcs/blob/master/text/1238-nonparametric-dropck.md\n+//     #example-of-the-unguarded-escape-hatch\n+\n+// #![feature(dropck_parametricity)]\n+\n+use std::cell::Cell;\n+\n+struct Concrete<'a>(u32, Cell<Option<&'a Concrete<'a>>>);\n+\n+struct Foo<T> { data: Vec<T> }\n+\n+impl<T> Drop for Foo<T> {\n+    #[unsafe_destructor_blind_to_params] // This is the UGEH attribute\n+    //~^ ERROR unsafe_destructor_blind_to_params has unstable semantics\n+    fn drop(&mut self) { }\n+}\n+\n+fn main() {\n+    let mut foo = Foo {  data: Vec::new() };\n+    foo.data.push(Concrete(0, Cell::new(None)));\n+    foo.data.push(Concrete(0, Cell::new(None)));\n+\n+    foo.data[0].1.set(Some(&foo.data[1]));\n+    foo.data[1].1.set(Some(&foo.data[0]));\n+}\n+"}, {"sha": "cee7c57c2019fea29004764a1dab7b5be30eb87b", "filename": "src/test/compile-fail/issue28498-reject-ex1.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Ftest%2Fcompile-fail%2Fissue28498-reject-ex1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Ftest%2Fcompile-fail%2Fissue28498-reject-ex1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue28498-reject-ex1.rs?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Example taken from RFC 1238 text\n+\n+// https://github.com/rust-lang/rfcs/blob/master/text/1238-nonparametric-dropck.md\n+//     #examples-of-code-that-will-start-to-be-rejected\n+\n+// Compare against test/run-pass/issue28498-must-work-ex2.rs\n+\n+use std::cell::Cell;\n+\n+struct Concrete<'a>(u32, Cell<Option<&'a Concrete<'a>>>);\n+\n+struct Foo<T> { data: Vec<T> }\n+\n+fn potentially_specialized_wrt_t<T>(t: &T) {\n+    // Hypothetical code that does one thing for generic T and then is\n+    // specialized for T == Concrete (and the specialized form can\n+    // then access a reference held in concrete tuple).\n+    //\n+    // (We don't have specialization yet, but we want to allow for it\n+    // in the future.)\n+}\n+\n+impl<T> Drop for Foo<T> {\n+    fn drop(&mut self) {\n+        potentially_specialized_wrt_t(&self.data[0])\n+    }\n+}\n+\n+fn main() {\n+    let mut foo = Foo {  data: Vec::new() };\n+    foo.data.push(Concrete(0, Cell::new(None)));\n+    foo.data.push(Concrete(0, Cell::new(None)));\n+\n+    foo.data[0].1.set(Some(&foo.data[1]));\n+    //~^ ERROR `foo.data` does not live long enough\n+    foo.data[1].1.set(Some(&foo.data[0]));\n+    //~^ ERROR `foo.data` does not live long enough\n+}"}, {"sha": "92028c7a818c206742cac8837509603e2df5f220", "filename": "src/test/compile-fail/issue28498-reject-lifetime-param.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Ftest%2Fcompile-fail%2Fissue28498-reject-lifetime-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Ftest%2Fcompile-fail%2Fissue28498-reject-lifetime-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue28498-reject-lifetime-param.rs?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Demonstrate that having a lifetime param causes dropck to reject code\n+// that might indirectly access previously dropped value.\n+//\n+// Compare with run-pass/issue28498-ugeh-with-lifetime-param.rs\n+\n+#[derive(Debug)]\n+struct ScribbleOnDrop(String);\n+\n+impl Drop for ScribbleOnDrop {\n+    fn drop(&mut self) {\n+        self.0 = format!(\"DROPPED\");\n+    }\n+}\n+\n+struct Foo<'a>(u32, &'a ScribbleOnDrop);\n+\n+impl<'a> Drop for Foo<'a> {\n+    fn drop(&mut self) {\n+        // Use of `unsafe_destructor_blind_to_params` is unsound,\n+        // because destructor accesses borrowed data in `self.1`\n+        // and we must force that to strictly outlive `self`.\n+        println!(\"Dropping Foo({}, {:?})\", self.0, self.1);\n+    }\n+}\n+\n+fn main() {\n+    let (last_dropped, foo0);\n+    let (foo1, first_dropped);\n+\n+    last_dropped = ScribbleOnDrop(format!(\"last\"));\n+    first_dropped = ScribbleOnDrop(format!(\"first\"));\n+    foo0 = Foo(0, &last_dropped);\n+    //~^ ERROR `last_dropped` does not live long enough\n+    foo1 = Foo(1, &first_dropped);\n+    //~^ ERROR `first_dropped` does not live long enough\n+\n+    println!(\"foo0.1: {:?} foo1.1: {:?}\", foo0.1, foo1.1);\n+}"}, {"sha": "27378b1e0bec04da1b783a44be7adebd5b8692ea", "filename": "src/test/compile-fail/issue28498-reject-passed-to-fn.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Ftest%2Fcompile-fail%2Fissue28498-reject-passed-to-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Ftest%2Fcompile-fail%2Fissue28498-reject-passed-to-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue28498-reject-passed-to-fn.rs?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Demonstrate that a type param in negative position causes dropck to reject code\n+// that might indirectly access previously dropped value.\n+//\n+// Compare with run-pass/issue28498-ugeh-with-passed-to-fn.rs\n+\n+#[derive(Debug)]\n+struct ScribbleOnDrop(String);\n+\n+impl Drop for ScribbleOnDrop {\n+    fn drop(&mut self) {\n+        self.0 = format!(\"DROPPED\");\n+    }\n+}\n+\n+struct Foo<T>(u32, T, Box<for <'r> fn(&'r T) -> String>);\n+\n+impl<T> Drop for Foo<T> {\n+    fn drop(&mut self) {\n+        // Use of `unsafe_destructor_blind_to_params` is unsound,\n+        // because we pass `T` to the callback in `self.2`\n+        // below, and thus potentially read from borrowed data.\n+        println!(\"Dropping Foo({}, {})\", self.0, (self.2)(&self.1));\n+    }\n+}\n+\n+fn callback(s: & &ScribbleOnDrop) -> String { format!(\"{:?}\", s) }\n+\n+fn main() {\n+    let (last_dropped, foo0);\n+    let (foo1, first_dropped);\n+\n+    last_dropped = ScribbleOnDrop(format!(\"last\"));\n+    first_dropped = ScribbleOnDrop(format!(\"first\"));\n+    foo0 = Foo(0, &last_dropped, Box::new(callback));\n+    //~^ ERROR `last_dropped` does not live long enough\n+    foo1 = Foo(1, &first_dropped, Box::new(callback));\n+    //~^ ERROR `first_dropped` does not live long enough\n+\n+    println!(\"foo0.1: {:?} foo1.1: {:?}\", foo0.1, foo1.1);\n+}"}, {"sha": "3904d68ba19dbd18d4e180c06bacf883bbce608f", "filename": "src/test/compile-fail/issue28498-reject-trait-bound.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Ftest%2Fcompile-fail%2Fissue28498-reject-trait-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Ftest%2Fcompile-fail%2Fissue28498-reject-trait-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue28498-reject-trait-bound.rs?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Demonstrate that having a trait bound causes dropck to reject code\n+// that might indirectly access previously dropped value.\n+//\n+// Compare with run-pass/issue28498-ugeh-with-trait-bound.rs\n+\n+use std::fmt;\n+\n+#[derive(Debug)]\n+struct ScribbleOnDrop(String);\n+\n+impl Drop for ScribbleOnDrop {\n+    fn drop(&mut self) {\n+        self.0 = format!(\"DROPPED\");\n+    }\n+}\n+\n+struct Foo<T:fmt::Debug>(u32, T);\n+\n+impl<T:fmt::Debug> Drop for Foo<T> {\n+    fn drop(&mut self) {\n+        // Use of `unsafe_destructor_blind_to_params` is unsound,\n+        // because we access `T` fmt method when we pass `self.1`\n+        // below, and thus potentially read from borrowed data.\n+        println!(\"Dropping Foo({}, {:?})\", self.0, self.1);\n+    }\n+}\n+\n+fn main() {\n+    let (last_dropped, foo0);\n+    let (foo1, first_dropped);\n+\n+    last_dropped = ScribbleOnDrop(format!(\"last\"));\n+    first_dropped = ScribbleOnDrop(format!(\"first\"));\n+    foo0 = Foo(0, &last_dropped);\n+    //~^ ERROR `last_dropped` does not live long enough\n+    foo1 = Foo(1, &first_dropped);\n+    //~^ ERROR `first_dropped` does not live long enough\n+\n+    println!(\"foo0.1: {:?} foo1.1: {:?}\", foo0.1, foo1.1);\n+}"}, {"sha": "9fa482022982b719aa3494fccc85c9cfa6a24ad9", "filename": "src/test/run-pass/issue-24805-dropck-itemless.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Ftest%2Frun-pass%2Fissue-24805-dropck-itemless.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Ftest%2Frun-pass%2Fissue-24805-dropck-itemless.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-24805-dropck-itemless.rs?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -13,6 +13,8 @@\n \n #![allow(non_camel_case_types)]\n \n+#![feature(dropck_parametricity)]\n+\n trait UserDefined { }\n \n impl UserDefined for i32 { }\n@@ -26,7 +28,10 @@ impl<'a, T> UserDefined for &'a T { }\n macro_rules! impl_drop {\n     ($Bound:ident, $Id:ident) => {\n         struct $Id<T:$Bound>(T);\n-        impl <T:$Bound> Drop for $Id<T> { fn drop(&mut self) { } }\n+        impl <T:$Bound> Drop for $Id<T> {\n+            #[unsafe_destructor_blind_to_params]\n+            fn drop(&mut self) { }\n+        }\n     }\n }\n "}, {"sha": "83a978d57b955a3ae7b2d1295f01310c25725d2a", "filename": "src/test/run-pass/issue28498-must-work-ex1.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Ftest%2Frun-pass%2Fissue28498-must-work-ex1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Ftest%2Frun-pass%2Fissue28498-must-work-ex1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue28498-must-work-ex1.rs?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Example taken from RFC 1238 text\n+\n+// https://github.com/rust-lang/rfcs/blob/master/text/1238-nonparametric-dropck.md\n+//     #examples-of-code-that-must-continue-to-work\n+\n+use std::cell::Cell;\n+\n+struct Concrete<'a>(u32, Cell<Option<&'a Concrete<'a>>>);\n+\n+fn main() {\n+    let mut data = Vec::new();\n+    data.push(Concrete(0, Cell::new(None)));\n+    data.push(Concrete(0, Cell::new(None)));\n+\n+    data[0].1.set(Some(&data[1]));\n+    data[1].1.set(Some(&data[0]));\n+}"}, {"sha": "93652a1b612ccdc05484cc81c99c247cfb25df31", "filename": "src/test/run-pass/issue28498-must-work-ex2.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Ftest%2Frun-pass%2Fissue28498-must-work-ex2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Ftest%2Frun-pass%2Fissue28498-must-work-ex2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue28498-must-work-ex2.rs?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Example taken from RFC 1238 text\n+\n+// https://github.com/rust-lang/rfcs/blob/master/text/1238-nonparametric-dropck.md\n+//     #examples-of-code-that-must-continue-to-work\n+\n+use std::cell::Cell;\n+\n+struct Concrete<'a>(u32, Cell<Option<&'a Concrete<'a>>>);\n+\n+struct Foo<T> { data: Vec<T> }\n+\n+fn main() {\n+    let mut foo = Foo {  data: Vec::new() };\n+    foo.data.push(Concrete(0, Cell::new(None)));\n+    foo.data.push(Concrete(0, Cell::new(None)));\n+\n+    foo.data[0].1.set(Some(&foo.data[1]));\n+    foo.data[1].1.set(Some(&foo.data[0]));\n+}\n+"}, {"sha": "b07831f552c6a0d789d178696578de84beae2b8f", "filename": "src/test/run-pass/issue28498-ugeh-ex1.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Ftest%2Frun-pass%2Fissue28498-ugeh-ex1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Ftest%2Frun-pass%2Fissue28498-ugeh-ex1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue28498-ugeh-ex1.rs?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Example taken from RFC 1238 text\n+\n+// https://github.com/rust-lang/rfcs/blob/master/text/1238-nonparametric-dropck.md\n+//     #example-of-the-unguarded-escape-hatch\n+\n+#![feature(dropck_parametricity)]\n+use std::cell::Cell;\n+\n+struct Concrete<'a>(u32, Cell<Option<&'a Concrete<'a>>>);\n+\n+struct Foo<T> { data: Vec<T> }\n+\n+impl<T> Drop for Foo<T> {\n+    // Below is the UGEH attribute\n+    #[unsafe_destructor_blind_to_params]\n+    fn drop(&mut self) { }\n+}\n+\n+fn main() {\n+    let mut foo = Foo {  data: Vec::new() };\n+    foo.data.push(Concrete(0, Cell::new(None)));\n+    foo.data.push(Concrete(0, Cell::new(None)));\n+\n+    foo.data[0].1.set(Some(&foo.data[1]));\n+    foo.data[1].1.set(Some(&foo.data[0]));\n+}\n+"}, {"sha": "19be2568e4ff24147251cd4b032deaa0fb088583", "filename": "src/test/run-pass/issue28498-ugeh-with-lifetime-param.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Ftest%2Frun-pass%2Fissue28498-ugeh-with-lifetime-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Ftest%2Frun-pass%2Fissue28498-ugeh-with-lifetime-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue28498-ugeh-with-lifetime-param.rs?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Demonstrate the use of the unguarded escape hatch with a lifetime param\n+// to assert that destructor will not access any dead data.\n+//\n+// Compare with compile-fail/issue28498-reject-lifetime-param.rs\n+\n+#![feature(dropck_parametricity)]\n+\n+#[derive(Debug)]\n+struct ScribbleOnDrop(String);\n+\n+impl Drop for ScribbleOnDrop {\n+    fn drop(&mut self) {\n+        self.0 = format!(\"DROPPED\");\n+    }\n+}\n+\n+struct Foo<'a>(u32, &'a ScribbleOnDrop);\n+\n+impl<'a> Drop for Foo<'a> {\n+    #[unsafe_destructor_blind_to_params]\n+    fn drop(&mut self) {\n+        // Use of `unsafe_destructor_blind_to_params` is sound,\n+        // because destructor never accesses `self.1`.\n+        println!(\"Dropping Foo({}, _)\", self.0);\n+    }\n+}\n+\n+fn main() {\n+    let (last_dropped, foo0);\n+    let (foo1, first_dropped);\n+\n+    last_dropped = ScribbleOnDrop(format!(\"last\"));\n+    first_dropped = ScribbleOnDrop(format!(\"first\"));\n+    foo0 = Foo(0, &last_dropped);\n+    foo1 = Foo(1, &first_dropped);\n+\n+    println!(\"foo0.1: {:?} foo1.1: {:?}\", foo0.1, foo1.1);\n+}"}, {"sha": "bb430ea3e33a8f11f674f23cd9b2ccd5cefb3d15", "filename": "src/test/run-pass/issue28498-ugeh-with-passed-to-fn.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Ftest%2Frun-pass%2Fissue28498-ugeh-with-passed-to-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Ftest%2Frun-pass%2Fissue28498-ugeh-with-passed-to-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue28498-ugeh-with-passed-to-fn.rs?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Demonstrate the use of the unguarded escape hatch with a type param in negative position\n+// to assert that destructor will not access any dead data.\n+//\n+// Compare with compile-fail/issue28498-reject-lifetime-param.rs\n+\n+// Demonstrate that a type param in negative position causes dropck to reject code\n+// that might indirectly access previously dropped value.\n+//\n+// Compare with run-pass/issue28498-ugeh-with-passed-to-fn.rs\n+\n+#![feature(dropck_parametricity)]\n+\n+#[derive(Debug)]\n+struct ScribbleOnDrop(String);\n+\n+impl Drop for ScribbleOnDrop {\n+    fn drop(&mut self) {\n+        self.0 = format!(\"DROPPED\");\n+    }\n+}\n+\n+struct Foo<T>(u32, T, Box<for <'r> fn(&'r T) -> String>);\n+\n+impl<T> Drop for Foo<T> {\n+    #[unsafe_destructor_blind_to_params]\n+    fn drop(&mut self) {\n+        // Use of `unsafe_destructor_blind_to_params` is sound,\n+        // because destructor never passes a `self.1` to the callback\n+        // (in `self.2`) despite having it available.\n+        println!(\"Dropping Foo({}, _)\", self.0);\n+    }\n+}\n+\n+fn callback(s: & &ScribbleOnDrop) -> String { format!(\"{:?}\", s) }\n+\n+fn main() {\n+    let (last_dropped, foo0);\n+    let (foo1, first_dropped);\n+\n+    last_dropped = ScribbleOnDrop(format!(\"last\"));\n+    first_dropped = ScribbleOnDrop(format!(\"first\"));\n+    foo0 = Foo(0, &last_dropped, Box::new(callback));\n+    foo1 = Foo(1, &first_dropped, Box::new(callback));\n+\n+    println!(\"foo0.1: {:?} foo1.1: {:?}\", foo0.1, foo1.1);\n+}"}, {"sha": "2e9633b3a214862e3ba83ec0bb3b8acac559ba0b", "filename": "src/test/run-pass/issue28498-ugeh-with-trait-bound.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Ftest%2Frun-pass%2Fissue28498-ugeh-with-trait-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87cd2c08273dec5c8db8e59f4231b8e69aa9b85b/src%2Ftest%2Frun-pass%2Fissue28498-ugeh-with-trait-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue28498-ugeh-with-trait-bound.rs?ref=87cd2c08273dec5c8db8e59f4231b8e69aa9b85b", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Demonstrate the use of the unguarded escape hatch with a trait bound\n+// to assert that destructor will not access any dead data.\n+//\n+// Compare with compile-fail/issue28498-reject-trait-bound.rs\n+\n+#![feature(dropck_parametricity)]\n+\n+use std::fmt;\n+\n+#[derive(Debug)]\n+struct ScribbleOnDrop(String);\n+\n+impl Drop for ScribbleOnDrop {\n+    fn drop(&mut self) {\n+        self.0 = format!(\"DROPPED\");\n+    }\n+}\n+\n+struct Foo<T:fmt::Debug>(u32, T);\n+\n+impl<T:fmt::Debug> Drop for Foo<T> {\n+    #[unsafe_destructor_blind_to_params]\n+    fn drop(&mut self) {\n+        // Use of `unsafe_destructor_blind_to_params` is sound,\n+        // because destructor never accesses the `Debug::fmt` method\n+        // of `T`, despite having it available.\n+        println!(\"Dropping Foo({}, _)\", self.0);\n+    }\n+}\n+\n+fn main() {\n+    let (last_dropped, foo0);\n+    let (foo1, first_dropped);\n+\n+    last_dropped = ScribbleOnDrop(format!(\"last\"));\n+    first_dropped = ScribbleOnDrop(format!(\"first\"));\n+    foo0 = Foo(0, &last_dropped);\n+    foo1 = Foo(1, &first_dropped);\n+\n+    println!(\"foo0.1: {:?} foo1.1: {:?}\", foo0.1, foo1.1);\n+}"}]}