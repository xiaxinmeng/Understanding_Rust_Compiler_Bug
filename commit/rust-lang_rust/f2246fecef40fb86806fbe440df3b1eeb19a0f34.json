{"sha": "f2246fecef40fb86806fbe440df3b1eeb19a0f34", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyMjQ2ZmVjZWY0MGZiODY4MDZmYmU0NDBkZjNiMWVlYjE5YTBmMzQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-10T11:24:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-10T11:24:08Z"}, "message": "Merge #9837\n\n9837: feat: Implement `bool_then_to_if` assist r=Veykril a=Veykril\n\nOther half of https://github.com/rust-analyzer/rust-analyzer/issues/8413\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "0c3b7c1be219e1cec3c3fd05e6e294d358f200ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c3b7c1be219e1cec3c3fd05e6e294d358f200ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2246fecef40fb86806fbe440df3b1eeb19a0f34", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhEmHYCRBK7hj4Ov3rIwAAAgQIAGSGz9xkj/W7lVmfRSbOjuog\nK5f9poiQTl68GfUwsoWq74NwNtctn+Ke0yfdLlbXNL+KMxTVED5539MXTrSflfAr\nhDAvfx67axubIONLOt0c88DDgM9U34j9mcE1DfZKKyzGJnKhx0obVd4s6hGwOHZC\njszeJwzAlZ/t5aaut7iCdCmQc+Wgj+rVpjOYkMxid0vG6KwkZKj4tUgpONXwU+XI\nxDvSlFeJFoAjJFn6j94gqld+vV087mCvZAmGBl/kFNnVKWUtmFWKu57PbXs06+IY\nTXhZbsEp6kKTSDdT37tSeezQc/Qs1aQ3jesG2j+iYnqRFQpofp45XgN1gkTlHKg=\n=BsYk\n-----END PGP SIGNATURE-----\n", "payload": "tree 0c3b7c1be219e1cec3c3fd05e6e294d358f200ee\nparent c5942c5284e7371704d82ec84a6cd160a48327d2\nparent b7d7dd616395c7c1901de86e2f744a1c1534de2b\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1628594648 +0000\ncommitter GitHub <noreply@github.com> 1628594648 +0000\n\nMerge #9837\n\n9837: feat: Implement `bool_then_to_if` assist r=Veykril a=Veykril\n\nOther half of https://github.com/rust-analyzer/rust-analyzer/issues/8413\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2246fecef40fb86806fbe440df3b1eeb19a0f34", "html_url": "https://github.com/rust-lang/rust/commit/f2246fecef40fb86806fbe440df3b1eeb19a0f34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2246fecef40fb86806fbe440df3b1eeb19a0f34/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5942c5284e7371704d82ec84a6cd160a48327d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5942c5284e7371704d82ec84a6cd160a48327d2", "html_url": "https://github.com/rust-lang/rust/commit/c5942c5284e7371704d82ec84a6cd160a48327d2"}, {"sha": "b7d7dd616395c7c1901de86e2f744a1c1534de2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7d7dd616395c7c1901de86e2f744a1c1534de2b", "html_url": "https://github.com/rust-lang/rust/commit/b7d7dd616395c7c1901de86e2f744a1c1534de2b"}], "stats": {"total": 244, "additions": 241, "deletions": 3}, "files": [{"sha": "3bb78fe0f290b2c09851c0e43c56bf262f914090", "filename": "crates/ide_assists/src/handlers/convert_bool_then.rs", "status": "modified", "additions": 202, "deletions": 3, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/f2246fecef40fb86806fbe440df3b1eeb19a0f34/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_bool_then.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2246fecef40fb86806fbe440df3b1eeb19a0f34/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_bool_then.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_bool_then.rs?ref=f2246fecef40fb86806fbe440df3b1eeb19a0f34", "patch": "@@ -1,10 +1,11 @@\n-use hir::{known, Semantics};\n+use hir::{known, AsAssocItem, Semantics};\n use ide_db::{\n     helpers::{for_each_tail_expr, FamousDefs},\n     RootDatabase,\n };\n+use itertools::Itertools;\n use syntax::{\n-    ast::{self, make, ArgListOwner},\n+    ast::{self, edit::AstNodeEdit, make, ArgListOwner},\n     ted, AstNode, SyntaxNode,\n };\n \n@@ -75,6 +76,7 @@ pub(crate) fn convert_if_to_bool_then(acc: &mut Assists, ctx: &AssistContext) ->\n         |builder| {\n             let closure_body = closure_body.clone_for_update();\n             // Rewrite all `Some(e)` in tail position to `e`\n+            let mut replacements = Vec::new();\n             for_each_tail_expr(&closure_body, &mut |e| {\n                 let e = match e {\n                     ast::Expr::BreakExpr(e) => e.expr(),\n@@ -84,11 +86,12 @@ pub(crate) fn convert_if_to_bool_then(acc: &mut Assists, ctx: &AssistContext) ->\n                 if let Some(ast::Expr::CallExpr(call)) = e {\n                     if let Some(arg_list) = call.arg_list() {\n                         if let Some(arg) = arg_list.args().next() {\n-                            ted::replace(call.syntax(), arg.syntax());\n+                            replacements.push((call.syntax().clone(), arg.syntax().clone()));\n                         }\n                     }\n                 }\n             });\n+            replacements.into_iter().for_each(|(old, new)| ted::replace(old, new));\n             let closure_body = match closure_body {\n                 ast::Expr::BlockExpr(block) => unwrap_trivial_block(block),\n                 e => e,\n@@ -102,6 +105,95 @@ pub(crate) fn convert_if_to_bool_then(acc: &mut Assists, ctx: &AssistContext) ->\n     )\n }\n \n+// Assist: convert_bool_then_to_if\n+//\n+// Converts a `bool::then` method call to an equivalent if expression.\n+//\n+// ```\n+// # //- minicore: bool_impl\n+// fn main() {\n+//     (0 == 0).then$0(|| val)\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     if 0 == 0 {\n+//         Some(val)\n+//     } else {\n+//         None\n+//     }\n+// }\n+// ```\n+pub(crate) fn convert_bool_then_to_if(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let name_ref = ctx.find_node_at_offset::<ast::NameRef>()?;\n+    let mcall = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast)?;\n+    let receiver = mcall.receiver()?;\n+    let closure_body = mcall.arg_list()?.args().exactly_one().ok()?;\n+    let closure_body = match closure_body {\n+        ast::Expr::ClosureExpr(expr) => expr.body()?,\n+        _ => return None,\n+    };\n+    // Verify this is `bool::then` that is being called.\n+    let func = ctx.sema.resolve_method_call(&mcall)?;\n+    if func.name(ctx.sema.db).to_string() != \"then\" {\n+        return None;\n+    }\n+    let assoc = func.as_assoc_item(ctx.sema.db)?;\n+    match assoc.container(ctx.sema.db) {\n+        hir::AssocItemContainer::Impl(impl_) if impl_.self_ty(ctx.sema.db).is_bool() => {}\n+        _ => return None,\n+    }\n+\n+    let target = mcall.syntax().text_range();\n+    acc.add(\n+        AssistId(\"convert_bool_then_to_if\", AssistKind::RefactorRewrite),\n+        \"Convert `bool::then` call to `if`\",\n+        target,\n+        |builder| {\n+            let closure_body = match closure_body {\n+                ast::Expr::BlockExpr(block) => block,\n+                e => make::block_expr(None, Some(e)),\n+            };\n+\n+            let closure_body = closure_body.clone_for_update();\n+            // Wrap all tails in `Some(...)`\n+            let none_path = make::expr_path(make::ext::ident_path(\"None\"));\n+            let some_path = make::expr_path(make::ext::ident_path(\"Some\"));\n+            let mut replacements = Vec::new();\n+            for_each_tail_expr(&ast::Expr::BlockExpr(closure_body.clone()), &mut |e| {\n+                let e = match e {\n+                    ast::Expr::BreakExpr(e) => e.expr(),\n+                    ast::Expr::ReturnExpr(e) => e.expr(),\n+                    _ => Some(e.clone()),\n+                };\n+                if let Some(expr) = e {\n+                    replacements.push((\n+                        expr.syntax().clone(),\n+                        make::expr_call(some_path.clone(), make::arg_list(Some(expr)))\n+                            .syntax()\n+                            .clone_for_update(),\n+                    ));\n+                }\n+            });\n+            replacements.into_iter().for_each(|(old, new)| ted::replace(old, new));\n+\n+            let cond = match &receiver {\n+                ast::Expr::ParenExpr(expr) => expr.expr().unwrap_or(receiver),\n+                _ => receiver,\n+            };\n+            let if_expr = make::expr_if(\n+                make::condition(cond, None),\n+                closure_body.reset_indent(),\n+                Some(ast::ElseBranch::Block(make::block_expr(None, Some(none_path)))),\n+            )\n+            .indent(mcall.indent_level());\n+\n+            builder.replace(target, if_expr.to_string());\n+        },\n+    )\n+}\n+\n fn option_variants(\n     sema: &Semantics<RootDatabase>,\n     expr: &SyntaxNode,\n@@ -346,6 +438,113 @@ fn main() {\n         None\n     }\n }\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_bool_then_to_if_inapplicable() {\n+        check_assist_not_applicable(\n+            convert_bool_then_to_if,\n+            r\"\n+//- minicore:bool_impl\n+fn main() {\n+    0.t$0hen(|| 15);\n+}\n+\",\n+        );\n+        check_assist_not_applicable(\n+            convert_bool_then_to_if,\n+            r\"\n+//- minicore:bool_impl\n+fn main() {\n+    true.t$0hen(15);\n+}\n+\",\n+        );\n+        check_assist_not_applicable(\n+            convert_bool_then_to_if,\n+            r\"\n+//- minicore:bool_impl\n+fn main() {\n+    true.t$0hen(|| 15, 15);\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_bool_then_to_if_simple() {\n+        check_assist(\n+            convert_bool_then_to_if,\n+            r\"\n+//- minicore:bool_impl\n+fn main() {\n+    true.t$0hen(|| 15)\n+}\n+\",\n+            r\"\n+fn main() {\n+    if true {\n+        Some(15)\n+    } else {\n+        None\n+    }\n+}\n+\",\n+        );\n+        check_assist(\n+            convert_bool_then_to_if,\n+            r\"\n+//- minicore:bool_impl\n+fn main() {\n+    true.t$0hen(|| {\n+        15\n+    })\n+}\n+\",\n+            r\"\n+fn main() {\n+    if true {\n+        Some(15)\n+    } else {\n+        None\n+    }\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_bool_then_to_if_tails() {\n+        check_assist(\n+            convert_bool_then_to_if,\n+            r\"\n+//- minicore:bool_impl\n+fn main() {\n+    true.t$0hen(|| {\n+        loop {\n+            if false {\n+                break 0;\n+            }\n+            break 15;\n+        }\n+    })\n+}\n+\",\n+            r\"\n+fn main() {\n+    if true {\n+        loop {\n+            if false {\n+                break Some(0);\n+            }\n+            break Some(15);\n+        }\n+    } else {\n+        None\n+    }\n+}\n \",\n         );\n     }"}, {"sha": "21e2524276ae76bade2be61b9e70a5235081e1a0", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2246fecef40fb86806fbe440df3b1eeb19a0f34/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2246fecef40fb86806fbe440df3b1eeb19a0f34/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=f2246fecef40fb86806fbe440df3b1eeb19a0f34", "patch": "@@ -127,6 +127,7 @@ mod handlers {\n             auto_import::auto_import,\n             change_visibility::change_visibility,\n             convert_bool_then::convert_if_to_bool_then,\n+            convert_bool_then::convert_bool_then_to_if,\n             convert_comment_block::convert_comment_block,\n             convert_integer_literal::convert_integer_literal,\n             convert_into_to_from::convert_into_to_from,"}, {"sha": "c4df6aec9fc56f4d331d10528be4acbc838a0801", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f2246fecef40fb86806fbe440df3b1eeb19a0f34/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2246fecef40fb86806fbe440df3b1eeb19a0f34/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=f2246fecef40fb86806fbe440df3b1eeb19a0f34", "patch": "@@ -191,6 +191,28 @@ pub(crate) fn frobnicate() {}\n     )\n }\n \n+#[test]\n+fn doctest_convert_bool_then_to_if() {\n+    check_doc_test(\n+        \"convert_bool_then_to_if\",\n+        r#####\"\n+//- minicore: bool_impl\n+fn main() {\n+    (0 == 0).then$0(|| val)\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+    if 0 == 0 {\n+        Some(val)\n+    } else {\n+        None\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_convert_if_to_bool_then() {\n     check_doc_test("}, {"sha": "2433d8e918e40e4dc7ddb3fb629b4a236f22fe63", "filename": "crates/ide_db/src/helpers.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2246fecef40fb86806fbe440df3b1eeb19a0f34/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2246fecef40fb86806fbe440df3b1eeb19a0f34/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers.rs?ref=f2246fecef40fb86806fbe440df3b1eeb19a0f34", "patch": "@@ -247,6 +247,8 @@ impl SnippetCap {\n \n /// Calls `cb` on each expression inside `expr` that is at \"tail position\".\n /// Does not walk into `break` or `return` expressions.\n+/// Note that modifying the tree while iterating it will cause undefined iteration which might\n+/// potentially results in an out of bounds panic.\n pub fn for_each_tail_expr(expr: &ast::Expr, cb: &mut dyn FnMut(&ast::Expr)) {\n     match expr {\n         ast::Expr::BlockExpr(b) => {"}, {"sha": "e4ae1f970fc9984724448c669e823d8bd61d2ee2", "filename": "crates/test_utils/src/minicore.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f2246fecef40fb86806fbe440df3b1eeb19a0f34/crates%2Ftest_utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2246fecef40fb86806fbe440df3b1eeb19a0f34/crates%2Ftest_utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Fminicore.rs?ref=f2246fecef40fb86806fbe440df3b1eeb19a0f34", "patch": "@@ -33,6 +33,7 @@\n //!     ord: eq, option\n //!     derive:\n //!     fmt: result\n+//!     bool_impl: option, fn\n \n pub mod marker {\n     // region:sized\n@@ -568,6 +569,19 @@ mod macros {\n }\n // endregion:derive\n \n+// region:bool_impl\n+#[lang = \"bool\"]\n+impl bool {\n+    pub fn then<T, F: FnOnce() -> T>(self, f: F) -> Option<T> {\n+        if self {\n+            Some(f())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+// endregion:bool_impl\n+\n pub mod prelude {\n     pub mod v1 {\n         pub use crate::{"}]}