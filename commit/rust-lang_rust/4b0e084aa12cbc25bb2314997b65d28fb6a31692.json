{"sha": "4b0e084aa12cbc25bb2314997b65d28fb6a31692", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiMGUwODRhYTEyY2JjMjViYjIzMTQ5OTdiNjVkMjhmYjZhMzE2OTI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-02T17:19:45Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-02T17:19:45Z"}, "message": "rollup merge of #20354: alexcrichton/second-pass-thread_local\n\nConflicts:\n\tsrc/libstd/sys/common/thread_info.rs", "tree": {"sha": "6f7cceb6ca531145c124d6fd2c092c192ac05d71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f7cceb6ca531145c124d6fd2c092c192ac05d71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b0e084aa12cbc25bb2314997b65d28fb6a31692", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b0e084aa12cbc25bb2314997b65d28fb6a31692", "html_url": "https://github.com/rust-lang/rust/commit/4b0e084aa12cbc25bb2314997b65d28fb6a31692", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b0e084aa12cbc25bb2314997b65d28fb6a31692/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "url": "https://api.github.com/repos/rust-lang/rust/commits/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf", "html_url": "https://github.com/rust-lang/rust/commit/009ec5d2b0c4ab0e7dc7ab2f6b15754b4da14caf"}, {"sha": "be11aa6d70c90185db715328ef2b24a3621cb969", "url": "https://api.github.com/repos/rust-lang/rust/commits/be11aa6d70c90185db715328ef2b24a3621cb969", "html_url": "https://github.com/rust-lang/rust/commit/be11aa6d70c90185db715328ef2b24a3621cb969"}], "stats": {"total": 189, "additions": 145, "deletions": 44}, "files": [{"sha": "92b936e74f6542a611a05a0a2bff6de29c780976", "filename": "src/libstd/sys/common/thread_info.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4b0e084aa12cbc25bb2314997b65d28fb6a31692/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b0e084aa12cbc25bb2314997b65d28fb6a31692/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs?ref=4b0e084aa12cbc25bb2314997b65d28fb6a31692", "patch": "@@ -10,9 +10,10 @@\n \n use core::prelude::*;\n \n-use thread::Thread;\n use cell::RefCell;\n use string::String;\n+use thread::Thread;\n+use thread_local::State;\n \n struct ThreadInfo {\n     // This field holds the known bounds of the stack in (lo, hi)\n@@ -27,7 +28,7 @@ thread_local! { static THREAD_INFO: RefCell<Option<ThreadInfo>> = RefCell::new(N\n \n impl ThreadInfo {\n     fn with<R, F>(f: F) -> R where F: FnOnce(&mut ThreadInfo) -> R {\n-        if THREAD_INFO.destroyed() {\n+        if THREAD_INFO.state() == State::Destroyed {\n             panic!(\"Use of std::thread::Thread::current() is not possible after \\\n                     the thread's local data has been destroyed\");\n         }"}, {"sha": "75e5ac59685b55d0553df7054ae1358c13395d99", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 127, "deletions": 32, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/4b0e084aa12cbc25bb2314997b65d28fb6a31692/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b0e084aa12cbc25bb2314997b65d28fb6a31692/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=4b0e084aa12cbc25bb2314997b65d28fb6a31692", "patch": "@@ -35,20 +35,23 @@\n //! `Cell` or `RefCell` types.\n \n #![macro_escape]\n-#![experimental]\n+#![stable]\n \n use prelude::v1::*;\n \n use cell::UnsafeCell;\n \n-// Sure wish we had macro hygiene, no?\n-#[doc(hidden)] pub use self::imp::Key as KeyInner;\n-#[doc(hidden)] pub use self::imp::destroy_value;\n-#[doc(hidden)] pub use sys_common::thread_local::INIT_INNER as OS_INIT_INNER;\n-#[doc(hidden)] pub use sys_common::thread_local::StaticKey as OsStaticKey;\n-\n pub mod scoped;\n \n+// Sure wish we had macro hygiene, no?\n+#[doc(hidden)]\n+pub mod __impl {\n+    pub use super::imp::Key as KeyInner;\n+    pub use super::imp::destroy_value;\n+    pub use sys_common::thread_local::INIT_INNER as OS_INIT_INNER;\n+    pub use sys_common::thread_local::StaticKey as OsStaticKey;\n+}\n+\n /// A thread local storage key which owns its contents.\n ///\n /// This key uses the fastest possible implementation available to it for the\n@@ -90,6 +93,7 @@ pub mod scoped;\n ///     assert_eq!(*f.borrow(), 2);\n /// });\n /// ```\n+#[stable]\n pub struct Key<T> {\n     // The key itself may be tagged with #[thread_local], and this `Key` is\n     // stored as a `static`, and it's not valid for a static to reference the\n@@ -100,7 +104,7 @@ pub struct Key<T> {\n     // This is trivially devirtualizable by LLVM because we never store anything\n     // to this field and rustc can declare the `static` as constant as well.\n     #[doc(hidden)]\n-    pub inner: fn() -> &'static KeyInner<UnsafeCell<Option<T>>>,\n+    pub inner: fn() -> &'static __impl::KeyInner<UnsafeCell<Option<T>>>,\n \n     // initialization routine to invoke to create a value\n     #[doc(hidden)]\n@@ -109,12 +113,12 @@ pub struct Key<T> {\n \n /// Declare a new thread local storage key of type `std::thread_local::Key`.\n #[macro_export]\n-#[doc(hidden)]\n+#[stable]\n macro_rules! thread_local {\n     (static $name:ident: $t:ty = $init:expr) => (\n         static $name: ::std::thread_local::Key<$t> = {\n             use std::cell::UnsafeCell as __UnsafeCell;\n-            use std::thread_local::KeyInner as __KeyInner;\n+            use std::thread_local::__impl::KeyInner as __KeyInner;\n             use std::option::Option as __Option;\n             use std::option::Option::None as __None;\n \n@@ -131,7 +135,7 @@ macro_rules! thread_local {\n     (pub static $name:ident: $t:ty = $init:expr) => (\n         pub static $name: ::std::thread_local::Key<$t> = {\n             use std::cell::UnsafeCell as __UnsafeCell;\n-            use std::thread_local::KeyInner as __KeyInner;\n+            use std::thread_local::__impl::KeyInner as __KeyInner;\n             use std::option::Option as __Option;\n             use std::option::Option::None as __None;\n \n@@ -168,46 +172,77 @@ macro_rules! thread_local {\n // itself. Woohoo.\n \n #[macro_export]\n+#[doc(hidden)]\n macro_rules! __thread_local_inner {\n     (static $name:ident: $t:ty = $init:expr) => (\n         #[cfg_attr(any(target_os = \"macos\", target_os = \"linux\"), thread_local)]\n-        static $name: ::std::thread_local::KeyInner<$t> =\n+        static $name: ::std::thread_local::__impl::KeyInner<$t> =\n             __thread_local_inner!($init, $t);\n     );\n     (pub static $name:ident: $t:ty = $init:expr) => (\n         #[cfg_attr(any(target_os = \"macos\", target_os = \"linux\"), thread_local)]\n-        pub static $name: ::std::thread_local::KeyInner<$t> =\n+        pub static $name: ::std::thread_local::__impl::KeyInner<$t> =\n             __thread_local_inner!($init, $t);\n     );\n     ($init:expr, $t:ty) => ({\n         #[cfg(any(target_os = \"macos\", target_os = \"linux\"))]\n-        const INIT: ::std::thread_local::KeyInner<$t> = {\n-            ::std::thread_local::KeyInner {\n+        const _INIT: ::std::thread_local::__impl::KeyInner<$t> = {\n+            ::std::thread_local::__impl::KeyInner {\n                 inner: ::std::cell::UnsafeCell { value: $init },\n                 dtor_registered: ::std::cell::UnsafeCell { value: false },\n                 dtor_running: ::std::cell::UnsafeCell { value: false },\n             }\n         };\n \n         #[cfg(all(not(any(target_os = \"macos\", target_os = \"linux\"))))]\n-        const INIT: ::std::thread_local::KeyInner<$t> = {\n+        const _INIT: ::std::thread_local::__impl::KeyInner<$t> = {\n             unsafe extern fn __destroy(ptr: *mut u8) {\n-                ::std::thread_local::destroy_value::<$t>(ptr);\n+                ::std::thread_local::__impl::destroy_value::<$t>(ptr);\n             }\n \n-            ::std::thread_local::KeyInner {\n+            ::std::thread_local::__impl::KeyInner {\n                 inner: ::std::cell::UnsafeCell { value: $init },\n-                os: ::std::thread_local::OsStaticKey {\n-                    inner: ::std::thread_local::OS_INIT_INNER,\n+                os: ::std::thread_local::__impl::OsStaticKey {\n+                    inner: ::std::thread_local::__impl::OS_INIT_INNER,\n                     dtor: ::std::option::Option::Some(__destroy as unsafe extern fn(*mut u8)),\n                 },\n             }\n         };\n \n-        INIT\n+        _INIT\n     });\n }\n \n+/// Indicator of the state of a thread local storage key.\n+#[unstable = \"state querying was recently added\"]\n+#[deriving(Eq, PartialEq, Copy)]\n+pub enum State {\n+    /// All keys are in this state whenever a thread starts. Keys will\n+    /// transition to the `Valid` state once the first call to `with` happens\n+    /// and the initialization expression succeeds.\n+    ///\n+    /// Keys in the `Uninitialized` state will yield a reference to the closure\n+    /// passed to `with` so long as the initialization routine does not panic.\n+    Uninitialized,\n+\n+    /// Once a key has been accessed successfully, it will enter the `Valid`\n+    /// state. Keys in the `Valid` state will remain so until the thread exits,\n+    /// at which point the destructor will be run and the key will enter the\n+    /// `Destroyed` state.\n+    ///\n+    /// Keys in the `Valid` state will be guaranteed to yield a reference to the\n+    /// closure passed to `with`.\n+    Valid,\n+\n+    /// When a thread exits, the destructors for keys will be run (if\n+    /// necessary). While a destructor is running, and possibly after a\n+    /// destructor has run, a key is in the `Destroyed` state.\n+    ///\n+    /// Keys in the `Destroyed` states will trigger a panic when accessed via\n+    /// `with`.\n+    Destroyed,\n+}\n+\n impl<T: 'static> Key<T> {\n     /// Acquire a reference to the value in this TLS key.\n     ///\n@@ -219,6 +254,7 @@ impl<T: 'static> Key<T> {\n     /// This function will `panic!()` if the key currently has its\n     /// destructor running, and it **may** panic if the destructor has\n     /// previously been run for this thread.\n+    #[stable]\n     pub fn with<F, R>(&'static self, f: F) -> R\n                       where F: FnOnce(&T) -> R {\n         let slot = (self.inner)();\n@@ -233,17 +269,52 @@ impl<T: 'static> Key<T> {\n     }\n \n     unsafe fn init(&self, slot: &UnsafeCell<Option<T>>) -> &T {\n-        *slot.get() = Some((self.init)());\n-        (*slot.get()).as_ref().unwrap()\n+        // Execute the initialization up front, *then* move it into our slot,\n+        // just in case initialization fails.\n+        let value = (self.init)();\n+        let ptr = slot.get();\n+        *ptr = Some(value);\n+        (*ptr).as_ref().unwrap()\n     }\n \n-    /// Test this TLS key to determine whether its value has been destroyed for\n-    /// the current thread or not.\n+    /// Query the current state of this key.\n+    ///\n+    /// A key is initially in the `Uninitialized` state whenever a thread\n+    /// starts. It will remain in this state up until the first call to `with`\n+    /// within a thread has run the initialization expression successfully.\n+    ///\n+    /// Once the initialization expression succeeds, the key transitions to the\n+    /// `Valid` state which will guarantee that future calls to `with` will\n+    /// succeed within the thread.\n+    ///\n+    /// When a thread exits, each key will be destroyed in turn, and as keys are\n+    /// destroyed they will enter the `Destroyed` state just before the\n+    /// destructor starts to run. Keys may remain in the `Destroyed` state after\n+    /// destruction has completed. Keys without destructors (e.g. with types\n+    /// that are `Copy`), may never enter the `Destroyed` state.\n     ///\n-    /// This will not initialize the key if it is not already initialized.\n-    pub fn destroyed(&'static self) -> bool {\n-        unsafe { (self.inner)().get().is_none() }\n+    /// Keys in the `Uninitialized` can be accessed so long as the\n+    /// initialization does not panic. Keys in the `Valid` state are guaranteed\n+    /// to be able to be accessed. Keys in the `Destroyed` state will panic on\n+    /// any call to `with`.\n+    #[unstable = \"state querying was recently added\"]\n+    pub fn state(&'static self) -> State {\n+        unsafe {\n+            match (self.inner)().get() {\n+                Some(cell) => {\n+                    match *cell.get() {\n+                        Some(..) => State::Valid,\n+                        None => State::Uninitialized,\n+                    }\n+                }\n+                None => State::Destroyed,\n+            }\n+        }\n     }\n+\n+    /// Deprecated\n+    #[deprecated = \"function renamed to state() and returns more info\"]\n+    pub fn destroyed(&'static self) -> bool { self.state() == State::Destroyed }\n }\n \n #[cfg(any(target_os = \"macos\", target_os = \"linux\"))]\n@@ -457,6 +528,7 @@ mod tests {\n \n     use sync::mpsc::{channel, Sender};\n     use cell::UnsafeCell;\n+    use super::State;\n     use thread::Thread;\n \n     struct Foo(Sender<()>);\n@@ -490,6 +562,29 @@ mod tests {\n         });\n     }\n \n+    #[test]\n+    fn states() {\n+        struct Foo;\n+        impl Drop for Foo {\n+            fn drop(&mut self) {\n+                assert!(FOO.state() == State::Destroyed);\n+            }\n+        }\n+        fn foo() -> Foo {\n+            assert!(FOO.state() == State::Uninitialized);\n+            Foo\n+        }\n+        thread_local!(static FOO: Foo = foo());\n+\n+        Thread::spawn(|| {\n+            assert!(FOO.state() == State::Uninitialized);\n+            FOO.with(|_| {\n+                assert!(FOO.state() == State::Valid);\n+            });\n+            assert!(FOO.state() == State::Valid);\n+        }).join().ok().unwrap();\n+    }\n+\n     #[test]\n     fn smoke_dtor() {\n         thread_local!(static FOO: UnsafeCell<Option<Foo>> = UnsafeCell {\n@@ -522,7 +617,7 @@ mod tests {\n             fn drop(&mut self) {\n                 unsafe {\n                     HITS += 1;\n-                    if K2.destroyed() {\n+                    if K2.state() == State::Destroyed {\n                         assert_eq!(HITS, 3);\n                     } else {\n                         if HITS == 1 {\n@@ -538,7 +633,7 @@ mod tests {\n             fn drop(&mut self) {\n                 unsafe {\n                     HITS += 1;\n-                    assert!(!K1.destroyed());\n+                    assert!(K1.state() != State::Destroyed);\n                     assert_eq!(HITS, 2);\n                     K1.with(|s| *s.get() = Some(S1));\n                 }\n@@ -559,7 +654,7 @@ mod tests {\n \n         impl Drop for S1 {\n             fn drop(&mut self) {\n-                assert!(K1.destroyed());\n+                assert!(K1.state() == State::Destroyed);\n             }\n         }\n \n@@ -582,7 +677,7 @@ mod tests {\n             fn drop(&mut self) {\n                 let S1(ref tx) = *self;\n                 unsafe {\n-                    if !K2.destroyed() {\n+                    if K2.state() != State::Destroyed {\n                         K2.with(|s| *s.get() = Some(Foo(tx.clone())));\n                     }\n                 }"}, {"sha": "c53d393f1eb709c9fcc32989384036ae9b354d1e", "filename": "src/libstd/thread_local/scoped.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4b0e084aa12cbc25bb2314997b65d28fb6a31692/src%2Flibstd%2Fthread_local%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b0e084aa12cbc25bb2314997b65d28fb6a31692/src%2Flibstd%2Fthread_local%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fscoped.rs?ref=4b0e084aa12cbc25bb2314997b65d28fb6a31692", "patch": "@@ -39,12 +39,17 @@\n //! ```\n \n #![macro_escape]\n+#![unstable = \"scoped TLS has yet to have wide enough use to fully consider \\\n+               stabilizing its interface\"]\n \n use prelude::v1::*;\n \n // macro hygiene sure would be nice, wouldn't it?\n-#[doc(hidden)] pub use self::imp::KeyInner;\n-#[doc(hidden)] pub use sys_common::thread_local::INIT as OS_INIT;\n+#[doc(hidden)]\n+pub mod __impl {\n+    pub use super::imp::KeyInner;\n+    pub use sys_common::thread_local::INIT as OS_INIT;\n+}\n \n /// Type representing a thread local storage key corresponding to a reference\n /// to the type parameter `T`.\n@@ -53,7 +58,7 @@ use prelude::v1::*;\n /// type `T` scoped to a particular lifetime. Keys provides two methods, `set`\n /// and `with`, both of which currently use closures to control the scope of\n /// their contents.\n-pub struct Key<T> { #[doc(hidden)] pub inner: KeyInner<T> }\n+pub struct Key<T> { #[doc(hidden)] pub inner: __impl::KeyInner<T> }\n \n /// Declare a new scoped thread local storage key.\n ///\n@@ -88,21 +93,21 @@ macro_rules! __scoped_thread_local_inner {\n         use std::thread_local::scoped::Key as __Key;\n \n         #[cfg(not(any(windows, target_os = \"android\", target_os = \"ios\")))]\n-        const INIT: __Key<$t> = __Key {\n-            inner: ::std::thread_local::scoped::KeyInner {\n+        const _INIT: __Key<$t> = __Key {\n+            inner: ::std::thread_local::scoped::__impl::KeyInner {\n                 inner: ::std::cell::UnsafeCell { value: 0 as *mut _ },\n             }\n         };\n \n         #[cfg(any(windows, target_os = \"android\", target_os = \"ios\"))]\n-        const INIT: __Key<$t> = __Key {\n-            inner: ::std::thread_local::scoped::KeyInner {\n-                inner: ::std::thread_local::scoped::OS_INIT,\n+        const _INIT: __Key<$t> = __Key {\n+            inner: ::std::thread_local::scoped::__impl::KeyInner {\n+                inner: ::std::thread_local::scoped::__impl::OS_INIT,\n                 marker: ::std::kinds::marker::InvariantType,\n             }\n         };\n \n-        INIT\n+        _INIT\n     })\n }\n \n@@ -139,7 +144,7 @@ impl<T> Key<T> {\n         F: FnOnce() -> R,\n     {\n         struct Reset<'a, T: 'a> {\n-            key: &'a KeyInner<T>,\n+            key: &'a __impl::KeyInner<T>,\n             val: *mut T,\n         }\n         #[unsafe_destructor]"}]}