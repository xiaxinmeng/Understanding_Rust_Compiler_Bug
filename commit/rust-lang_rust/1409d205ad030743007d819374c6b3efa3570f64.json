{"sha": "1409d205ad030743007d819374c6b3efa3570f64", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0MDlkMjA1YWQwMzA3NDMwMDdkODE5Mzc0YzZiM2VmYTM1NzBmNjQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-07-28T18:10:06Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-08-02T00:45:03Z"}, "message": "rustc_apfloat: complete the IEEE & PPC implementations.", "tree": {"sha": "b23650bc9c41d3e1e287e979d00c2d2786f8b1d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b23650bc9c41d3e1e287e979d00c2d2786f8b1d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1409d205ad030743007d819374c6b3efa3570f64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1409d205ad030743007d819374c6b3efa3570f64", "html_url": "https://github.com/rust-lang/rust/commit/1409d205ad030743007d819374c6b3efa3570f64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1409d205ad030743007d819374c6b3efa3570f64/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a5fccf33159f381468317b38889ddb11deff357", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a5fccf33159f381468317b38889ddb11deff357", "html_url": "https://github.com/rust-lang/rust/commit/7a5fccf33159f381468317b38889ddb11deff357"}], "stats": {"total": 2924, "additions": 2834, "deletions": 90}, "files": [{"sha": "3545a77c75de64cde2e5573409b254c6b0bf9734", "filename": "src/librustc_apfloat/ieee.rs", "status": "modified", "additions": 2523, "deletions": 55, "changes": 2578, "blob_url": "https://github.com/rust-lang/rust/blob/1409d205ad030743007d819374c6b3efa3570f64/src%2Flibrustc_apfloat%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1409d205ad030743007d819374c6b3efa3570f64/src%2Flibrustc_apfloat%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fieee.rs?ref=1409d205ad030743007d819374c6b3efa3570f64", "patch": "@@ -8,19 +8,55 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use {Category, ExpInt};\n-use {Float, FloatConvert, ParseError, Round, StatusAnd};\n+use {Category, ExpInt, IEK_INF, IEK_NAN, IEK_ZERO};\n+use {Float, FloatConvert, ParseError, Round, Status, StatusAnd};\n \n-use std::cmp::Ordering;\n-use std::fmt;\n+use std::cmp::{self, Ordering};\n+use std::convert::TryFrom;\n+use std::fmt::{self, Write};\n use std::marker::PhantomData;\n+use std::mem;\n use std::ops::Neg;\n \n #[must_use]\n pub struct IeeeFloat<S> {\n+    /// Absolute significand value (including the integer bit).\n+    sig: [Limb; 1],\n+\n+    /// The signed unbiased exponent of the value.\n+    exp: ExpInt,\n+\n+    /// What kind of floating point number this is.\n+    category: Category,\n+\n+    /// Sign bit of the number.\n+    sign: bool,\n+\n     marker: PhantomData<S>,\n }\n \n+/// Fundamental unit of big integer arithmetic, but also\n+/// large to store the largest significands by itself.\n+type Limb = u128;\n+const LIMB_BITS: usize = 128;\n+fn limbs_for_bits(bits: usize) -> usize {\n+    (bits + LIMB_BITS - 1) / LIMB_BITS\n+}\n+\n+/// Enum that represents what fraction of the LSB truncated bits of an fp number\n+/// represent.\n+///\n+/// This essentially combines the roles of guard and sticky bits.\n+#[must_use]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum Loss {\n+    // Example of truncated bits:\n+    ExactlyZero, // 000000\n+    LessThanHalf, // 0xxxxx  x's not all zero\n+    ExactlyHalf, // 100000\n+    MoreThanHalf, // 1xxxxx  x's not all zero\n+}\n+\n /// Represents floating point arithmetic semantics.\n pub trait Semantics: Sized {\n     /// Total number of bits in the in-memory format.\n@@ -36,6 +72,84 @@ pub trait Semantics: Sized {\n     /// The smallest E such that 2^E is a normalized number; this\n     /// matches the definition of IEEE 754.\n     const MIN_EXP: ExpInt = -Self::MAX_EXP + 1;\n+\n+    /// The significand bit that marks NaN as quiet.\n+    const QNAN_BIT: usize = Self::PRECISION - 2;\n+\n+    /// The significand bitpattern to mark a NaN as quiet.\n+    /// NOTE: for X87DoubleExtended we need to set two bits instead of 2.\n+    const QNAN_SIGNIFICAND: Limb = 1 << Self::QNAN_BIT;\n+\n+    fn from_bits(bits: u128) -> IeeeFloat<Self> {\n+        assert!(Self::BITS > Self::PRECISION);\n+\n+        let sign = bits & (1 << (Self::BITS - 1));\n+        let exponent = (bits & !sign) >> (Self::PRECISION - 1);\n+        let mut r = IeeeFloat {\n+            sig: [bits & ((1 << (Self::PRECISION - 1)) - 1)],\n+            // Convert the exponent from its bias representation to a signed integer.\n+            exp: (exponent as ExpInt) - Self::MAX_EXP,\n+            category: Category::Zero,\n+            sign: sign != 0,\n+            marker: PhantomData,\n+        };\n+\n+        if r.exp == Self::MIN_EXP - 1 && r.sig == [0] {\n+            // Exponent, significand meaningless.\n+            r.category = Category::Zero;\n+        } else if r.exp == Self::MAX_EXP + 1 && r.sig == [0] {\n+            // Exponent, significand meaningless.\n+            r.category = Category::Infinity;\n+        } else if r.exp == Self::MAX_EXP + 1 && r.sig != [0] {\n+            // Sign, exponent, significand meaningless.\n+            r.category = Category::NaN;\n+        } else {\n+            r.category = Category::Normal;\n+            if r.exp == Self::MIN_EXP - 1 {\n+                // Denormal.\n+                r.exp = Self::MIN_EXP;\n+            } else {\n+                // Set integer bit.\n+                sig::set_bit(&mut r.sig, Self::PRECISION - 1);\n+            }\n+        }\n+\n+        r\n+    }\n+\n+    fn to_bits(x: IeeeFloat<Self>) -> u128 {\n+        assert!(Self::BITS > Self::PRECISION);\n+\n+        // Split integer bit from significand.\n+        let integer_bit = sig::get_bit(&x.sig, Self::PRECISION - 1);\n+        let mut significand = x.sig[0] & ((1 << (Self::PRECISION - 1)) - 1);\n+        let exponent = match x.category {\n+            Category::Normal => {\n+                if x.exp == Self::MIN_EXP && !integer_bit {\n+                    // Denormal.\n+                    Self::MIN_EXP - 1\n+                } else {\n+                    x.exp\n+                }\n+            }\n+            Category::Zero => {\n+                // FIXME(eddyb) Maybe we should guarantee an invariant instead?\n+                significand = 0;\n+                Self::MIN_EXP - 1\n+            }\n+            Category::Infinity => {\n+                // FIXME(eddyb) Maybe we should guarantee an invariant instead?\n+                significand = 0;\n+                Self::MAX_EXP + 1\n+            }\n+            Category::NaN => Self::MAX_EXP + 1,\n+        };\n+\n+        // Convert the exponent from a signed integer to its bias representation.\n+        let exponent = (exponent + Self::MAX_EXP) as u128;\n+\n+        ((x.sign as u128) << (Self::BITS - 1)) | (exponent << (Self::PRECISION - 1)) | significand\n+    }\n }\n \n impl<S> Copy for IeeeFloat<S> {}\n@@ -70,6 +184,82 @@ impl Semantics for X87DoubleExtendedS {\n     const BITS: usize = 80;\n     const PRECISION: usize = 64;\n     const MAX_EXP: ExpInt = (1 << (15 - 1)) - 1;\n+\n+    /// For x87 extended precision, we want to make a NaN, not a\n+    /// pseudo-NaN. Maybe we should expose the ability to make\n+    /// pseudo-NaNs?\n+    const QNAN_SIGNIFICAND: Limb = 0b11 << Self::QNAN_BIT;\n+\n+    /// Integer bit is explicit in this format. Intel hardware (387 and later)\n+    /// does not support these bit patterns:\n+    ///  exponent = all 1's, integer bit 0, significand 0 (\"pseudoinfinity\")\n+    ///  exponent = all 1's, integer bit 0, significand nonzero (\"pseudoNaN\")\n+    ///  exponent = 0, integer bit 1 (\"pseudodenormal\")\n+    ///  exponent!=0 nor all 1's, integer bit 0 (\"unnormal\")\n+    /// At the moment, the first two are treated as NaNs, the second two as Normal.\n+    fn from_bits(bits: u128) -> IeeeFloat<Self> {\n+        let sign = bits & (1 << (Self::BITS - 1));\n+        let exponent = (bits & !sign) >> Self::PRECISION;\n+        let mut r = IeeeFloat {\n+            sig: [bits & ((1 << (Self::PRECISION - 1)) - 1)],\n+            // Convert the exponent from its bias representation to a signed integer.\n+            exp: (exponent as ExpInt) - Self::MAX_EXP,\n+            category: Category::Zero,\n+            sign: sign != 0,\n+            marker: PhantomData,\n+        };\n+\n+        if r.exp == Self::MIN_EXP - 1 && r.sig == [0] {\n+            // Exponent, significand meaningless.\n+            r.category = Category::Zero;\n+        } else if r.exp == Self::MAX_EXP + 1 && r.sig == [1 << (Self::PRECISION - 1)] {\n+            // Exponent, significand meaningless.\n+            r.category = Category::Infinity;\n+        } else if r.exp == Self::MAX_EXP + 1 && r.sig != [1 << (Self::PRECISION - 1)] {\n+            // Sign, exponent, significand meaningless.\n+            r.category = Category::NaN;\n+        } else {\n+            r.category = Category::Normal;\n+            if r.exp == Self::MIN_EXP - 1 {\n+                // Denormal.\n+                r.exp = Self::MIN_EXP;\n+            }\n+        }\n+\n+        r\n+    }\n+\n+    fn to_bits(x: IeeeFloat<Self>) -> u128 {\n+        // Get integer bit from significand.\n+        let integer_bit = sig::get_bit(&x.sig, Self::PRECISION - 1);\n+        let mut significand = x.sig[0] & ((1 << Self::PRECISION) - 1);\n+        let exponent = match x.category {\n+            Category::Normal => {\n+                if x.exp == Self::MIN_EXP && !integer_bit {\n+                    // Denormal.\n+                    Self::MIN_EXP - 1\n+                } else {\n+                    x.exp\n+                }\n+            }\n+            Category::Zero => {\n+                // FIXME(eddyb) Maybe we should guarantee an invariant instead?\n+                significand = 0;\n+                Self::MIN_EXP - 1\n+            }\n+            Category::Infinity => {\n+                // FIXME(eddyb) Maybe we should guarantee an invariant instead?\n+                significand = 1 << (Self::PRECISION - 1);\n+                Self::MAX_EXP + 1\n+            }\n+            Category::NaN => Self::MAX_EXP + 1,\n+        };\n+\n+        // Convert the exponent from a signed integer to its bias representation.\n+        let exponent = (exponent + Self::MAX_EXP) as u128;\n+\n+        ((x.sign as u128) << (Self::BITS - 1)) | (exponent << Self::PRECISION) | significand\n+    }\n }\n \n float_common_impls!(IeeeFloat<S>);\n@@ -80,17 +270,40 @@ impl<S: Semantics> PartialEq for IeeeFloat<S> {\n     }\n }\n \n-#[allow(unused)]\n impl<S: Semantics> PartialOrd for IeeeFloat<S> {\n     fn partial_cmp(&self, rhs: &Self) -> Option<Ordering> {\n-        panic!(\"NYI PartialOrd::partial_cmp\");\n+        match (self.category, rhs.category) {\n+            (Category::NaN, _) |\n+            (_, Category::NaN) => None,\n+\n+            (Category::Infinity, Category::Infinity) => Some((!self.sign).cmp(&(!rhs.sign))),\n+\n+            (Category::Zero, Category::Zero) => Some(Ordering::Equal),\n+\n+            (Category::Infinity, _) |\n+            (Category::Normal, Category::Zero) => Some((!self.sign).cmp(&self.sign)),\n+\n+            (_, Category::Infinity) |\n+            (Category::Zero, Category::Normal) => Some(rhs.sign.cmp(&(!rhs.sign))),\n+\n+            (Category::Normal, Category::Normal) => {\n+                // Two normal numbers. Do they have the same sign?\n+                Some((!self.sign).cmp(&(!rhs.sign)).then_with(|| {\n+                    // Compare absolute values; invert result if negative.\n+                    let result = self.cmp_abs_normal(*rhs);\n+\n+                    if self.sign { result.reverse() } else { result }\n+                }))\n+            }\n+        }\n     }\n }\n \n impl<S> Neg for IeeeFloat<S> {\n     type Output = Self;\n-    fn neg(self) -> Self {\n-        panic!(\"NYI Neg::neg\");\n+    fn neg(mut self) -> Self {\n+        self.sign = !self.sign;\n+        self\n     }\n }\n \n@@ -120,146 +333,2401 @@ impl<S> Neg for IeeeFloat<S> {\n /// 1.01E-2              5        2       0.0101\n /// 1.01E-2              4        2       0.0101\n /// 1.01E-2              4        1       1.01E-2\n-#[allow(unused)]\n impl<S: Semantics> fmt::Display for IeeeFloat<S> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let frac_digits = f.precision().unwrap_or(0);\n         let width = f.width().unwrap_or(3);\n         let alternate = f.alternate();\n-        panic!(\"NYI Display::fmt\");\n+\n+        match self.category {\n+            Category::Infinity => {\n+                if self.sign {\n+                    return f.write_str(\"-Inf\");\n+                } else {\n+                    return f.write_str(\"+Inf\");\n+                }\n+            }\n+\n+            Category::NaN => return f.write_str(\"NaN\"),\n+\n+            Category::Zero => {\n+                if self.sign {\n+                    f.write_char('-')?;\n+                }\n+\n+                if width == 0 {\n+                    if alternate {\n+                        f.write_str(\"0.0\")?;\n+                        if let Some(n) = f.precision() {\n+                            for _ in 1..n {\n+                                f.write_char('0')?;\n+                            }\n+                        }\n+                        f.write_str(\"e+00\")?;\n+                    } else {\n+                        f.write_str(\"0.0E+0\")?;\n+                    }\n+                } else {\n+                    f.write_char('0')?;\n+                }\n+                return Ok(());\n+            }\n+\n+            Category::Normal => {}\n+        }\n+\n+        if self.sign {\n+            f.write_char('-')?;\n+        }\n+\n+        // We use enough digits so the number can be round-tripped back to an\n+        // APFloat. The formula comes from \"How to Print Floating-Point Numbers\n+        // Accurately\" by Steele and White.\n+        // FIXME: Using a formula based purely on the precision is conservative;\n+        // we can print fewer digits depending on the actual value being printed.\n+\n+        // precision = 2 + floor(S::PRECISION / lg_2(10))\n+        let precision = f.precision().unwrap_or(2 + S::PRECISION * 59 / 196);\n+\n+        // Decompose the number into an APInt and an exponent.\n+        let mut exp = self.exp - (S::PRECISION as ExpInt - 1);\n+        let mut sig = vec![self.sig[0]];\n+\n+        // Ignore trailing binary zeros.\n+        let trailing_zeros = sig[0].trailing_zeros();\n+        let _: Loss = sig::shift_right(&mut sig, &mut exp, trailing_zeros as usize);\n+\n+        // Change the exponent from 2^e to 10^e.\n+        if exp == 0 {\n+            // Nothing to do.\n+        } else if exp > 0 {\n+            // Just shift left.\n+            let shift = exp as usize;\n+            sig.resize(limbs_for_bits(S::PRECISION + shift), 0);\n+            sig::shift_left(&mut sig, &mut exp, shift);\n+        } else {\n+            // exp < 0\n+            let mut texp = -exp as usize;\n+\n+            // We transform this using the identity:\n+            //   (N)(2^-e) == (N)(5^e)(10^-e)\n+\n+            // Multiply significand by 5^e.\n+            //   N * 5^0101 == N * 5^(1*1) * 5^(0*2) * 5^(1*4) * 5^(0*8)\n+            let mut sig_scratch = vec![];\n+            let mut p5 = vec![];\n+            let mut p5_scratch = vec![];\n+            while texp != 0 {\n+                if p5.is_empty() {\n+                    p5.push(5);\n+                } else {\n+                    p5_scratch.resize(p5.len() * 2, 0);\n+                    let _: Loss =\n+                        sig::mul(&mut p5_scratch, &mut 0, &p5, &p5, p5.len() * 2 * LIMB_BITS);\n+                    while p5_scratch.last() == Some(&0) {\n+                        p5_scratch.pop();\n+                    }\n+                    mem::swap(&mut p5, &mut p5_scratch);\n+                }\n+                if texp & 1 != 0 {\n+                    sig_scratch.resize(sig.len() + p5.len(), 0);\n+                    let _: Loss = sig::mul(\n+                        &mut sig_scratch,\n+                        &mut 0,\n+                        &sig,\n+                        &p5,\n+                        (sig.len() + p5.len()) * LIMB_BITS,\n+                    );\n+                    while sig_scratch.last() == Some(&0) {\n+                        sig_scratch.pop();\n+                    }\n+                    mem::swap(&mut sig, &mut sig_scratch);\n+                }\n+                texp >>= 1;\n+            }\n+        }\n+\n+        // Fill the buffer.\n+        let mut buffer = vec![];\n+\n+        // Ignore digits from the significand until it is no more\n+        // precise than is required for the desired precision.\n+        // 196/59 is a very slight overestimate of lg_2(10).\n+        let required = (precision * 196 + 58) / 59;\n+        let mut discard_digits = sig::omsb(&sig).saturating_sub(required) * 59 / 196;\n+        let mut in_trail = true;\n+        while !sig.is_empty() {\n+            // Perform short division by 10 to extract the rightmost digit.\n+            // rem <- sig % 10\n+            // sig <- sig / 10\n+            let mut rem = 0;\n+            for limb in sig.iter_mut().rev() {\n+                // We don't have an integer doubly wide than Limb,\n+                // so we have to split the divrem on two halves.\n+                const HALF_BITS: usize = LIMB_BITS / 2;\n+                let mut halves = [*limb & ((1 << HALF_BITS) - 1), *limb >> HALF_BITS];\n+                for half in halves.iter_mut().rev() {\n+                    *half |= rem << HALF_BITS;\n+                    rem = *half % 10;\n+                    *half /= 10;\n+                }\n+                *limb = halves[0] | (halves[1] << HALF_BITS);\n+            }\n+            // Reduce the sigificand to avoid wasting time dividing 0's.\n+            while sig.last() == Some(&0) {\n+                sig.pop();\n+            }\n+\n+            let digit = rem;\n+\n+            // Ignore digits we don't need.\n+            if discard_digits > 0 {\n+                discard_digits -= 1;\n+                exp += 1;\n+                continue;\n+            }\n+\n+            // Drop trailing zeros.\n+            if in_trail && digit == 0 {\n+                exp += 1;\n+            } else {\n+                in_trail = false;\n+                buffer.push(b'0' + digit as u8);\n+            }\n+        }\n+\n+        assert!(!buffer.is_empty(), \"no characters in buffer!\");\n+\n+        // Drop down to precision.\n+        // FIXME: don't do more precise calculations above than are required.\n+        if buffer.len() > precision {\n+            // The most significant figures are the last ones in the buffer.\n+            let mut first_sig = buffer.len() - precision;\n+\n+            // Round.\n+            // FIXME: this probably shouldn't use 'round half up'.\n+\n+            // Rounding down is just a truncation, except we also want to drop\n+            // trailing zeros from the new result.\n+            if buffer[first_sig - 1] < b'5' {\n+                while first_sig < buffer.len() && buffer[first_sig] == b'0' {\n+                    first_sig += 1;\n+                }\n+            } else {\n+                // Rounding up requires a decimal add-with-carry. If we continue\n+                // the carry, the newly-introduced zeros will just be truncated.\n+                for x in &mut buffer[first_sig..] {\n+                    if *x == b'9' {\n+                        first_sig += 1;\n+                    } else {\n+                        *x += 1;\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            exp += first_sig as ExpInt;\n+            buffer.drain(..first_sig);\n+\n+            // If we carried through, we have exactly one digit of precision.\n+            if buffer.is_empty() {\n+                buffer.push(b'1');\n+            }\n+        }\n+\n+        let digits = buffer.len();\n+\n+        // Check whether we should use scientific notation.\n+        let scientific = if width == 0 {\n+            true\n+        } else {\n+            if exp >= 0 {\n+                // 765e3 --> 765000\n+                //              ^^^\n+                // But we shouldn't make the number look more precise than it is.\n+                exp as usize > width || digits + exp as usize > precision\n+            } else {\n+                // Power of the most significant digit.\n+                let msd = exp + (digits - 1) as ExpInt;\n+                if msd >= 0 {\n+                    // 765e-2 == 7.65\n+                    false\n+                } else {\n+                    // 765e-5 == 0.00765\n+                    //           ^ ^^\n+                    -msd as usize > width\n+                }\n+            }\n+        };\n+\n+        // Scientific formatting is pretty straightforward.\n+        if scientific {\n+            exp += digits as ExpInt - 1;\n+\n+            f.write_char(buffer[digits - 1] as char)?;\n+            f.write_char('.')?;\n+            let truncate_zero = !alternate;\n+            if digits == 1 && truncate_zero {\n+                f.write_char('0')?;\n+            } else {\n+                for &d in buffer[..digits - 1].iter().rev() {\n+                    f.write_char(d as char)?;\n+                }\n+            }\n+            // Fill with zeros up to precision.\n+            if !truncate_zero && precision > digits - 1 {\n+                for _ in 0..precision - digits + 1 {\n+                    f.write_char('0')?;\n+                }\n+            }\n+            // For alternate we use lower 'e'.\n+            f.write_char(if alternate { 'e' } else { 'E' })?;\n+\n+            // Exponent always at least two digits if we do not truncate zeros.\n+            if truncate_zero {\n+                write!(f, \"{:+}\", exp)?;\n+            } else {\n+                write!(f, \"{:+03}\", exp)?;\n+            }\n+\n+            return Ok(());\n+        }\n+\n+        // Non-scientific, positive exponents.\n+        if exp >= 0 {\n+            for &d in buffer.iter().rev() {\n+                f.write_char(d as char)?;\n+            }\n+            for _ in 0..exp {\n+                f.write_char('0')?;\n+            }\n+            return Ok(());\n+        }\n+\n+        // Non-scientific, negative exponents.\n+        let unit_place = -exp as usize;\n+        if unit_place < digits {\n+            for &d in buffer[unit_place..].iter().rev() {\n+                f.write_char(d as char)?;\n+            }\n+            f.write_char('.')?;\n+            for &d in buffer[..unit_place].iter().rev() {\n+                f.write_char(d as char)?;\n+            }\n+        } else {\n+            f.write_str(\"0.\")?;\n+            for _ in digits..unit_place {\n+                f.write_char('0')?;\n+            }\n+            for &d in buffer.iter().rev() {\n+                f.write_char(d as char)?;\n+            }\n+        }\n+\n+        Ok(())\n     }\n }\n \n impl<S: Semantics> fmt::Debug for IeeeFloat<S> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self)\n+        write!(f, \"{}({:?} | {}{:?} * 2^{})\",\n+               self, self.category,\n+               if self.sign { \"-\" } else { \"+\" },\n+               self.sig,\n+               self.exp)\n     }\n }\n \n-#[allow(unused)]\n impl<S: Semantics> Float for IeeeFloat<S> {\n     const BITS: usize = S::BITS;\n     const PRECISION: usize = S::PRECISION;\n     const MAX_EXP: ExpInt = S::MAX_EXP;\n     const MIN_EXP: ExpInt = S::MIN_EXP;\n \n-    const ZERO: Self = IeeeFloat { marker: PhantomData };\n+    const ZERO: Self = IeeeFloat {\n+        sig: [0],\n+        exp: S::MIN_EXP - 1,\n+        category: Category::Zero,\n+        sign: false,\n+        marker: PhantomData,\n+    };\n \n-    const INFINITY: Self = IeeeFloat { marker: PhantomData };\n+    const INFINITY: Self = IeeeFloat {\n+        sig: [0],\n+        exp: S::MAX_EXP + 1,\n+        category: Category::Infinity,\n+        sign: false,\n+        marker: PhantomData,\n+    };\n \n     // FIXME(eddyb) remove when qnan becomes const fn.\n-    const NAN: Self = IeeeFloat { marker: PhantomData };\n+    const NAN: Self = IeeeFloat {\n+        sig: [S::QNAN_SIGNIFICAND],\n+        exp: S::MAX_EXP + 1,\n+        category: Category::NaN,\n+        sign: false,\n+        marker: PhantomData,\n+    };\n \n     fn qnan(payload: Option<u128>) -> Self {\n-        panic!(\"NYI qnan\")\n+        IeeeFloat {\n+            sig: [\n+                S::QNAN_SIGNIFICAND |\n+                    payload.map_or(0, |payload| {\n+                        // Zero out the excess bits of the significand.\n+                        payload & ((1 << S::QNAN_BIT) - 1)\n+                    }),\n+            ],\n+            exp: S::MAX_EXP + 1,\n+            category: Category::NaN,\n+            sign: false,\n+            marker: PhantomData,\n+        }\n     }\n \n     fn snan(payload: Option<u128>) -> Self {\n-        panic!(\"NYI snan\")\n+        let mut snan = Self::qnan(payload);\n+\n+        // We always have to clear the QNaN bit to make it an SNaN.\n+        sig::clear_bit(&mut snan.sig, S::QNAN_BIT);\n+\n+        // If there are no bits set in the payload, we have to set\n+        // *something* to make it a NaN instead of an infinity;\n+        // conventionally, this is the next bit down from the QNaN bit.\n+        if snan.sig[0] & !S::QNAN_SIGNIFICAND == 0 {\n+            sig::set_bit(&mut snan.sig, S::QNAN_BIT - 1);\n+        }\n+\n+        snan\n     }\n \n     fn largest() -> Self {\n-        panic!(\"NYI largest\")\n+        // We want (in interchange format):\n+        //   exponent = 1..10\n+        //   significand = 1..1\n+        IeeeFloat {\n+            sig: [!0 & ((1 << S::PRECISION) - 1)],\n+            exp: S::MAX_EXP,\n+            category: Category::Normal,\n+            sign: false,\n+            marker: PhantomData,\n+        }\n     }\n \n-    const SMALLEST: Self = IeeeFloat { marker: PhantomData };\n+    // We want (in interchange format):\n+    //   exponent = 0..0\n+    //   significand = 0..01\n+    const SMALLEST: Self = IeeeFloat {\n+        sig: [1],\n+        exp: S::MIN_EXP,\n+        category: Category::Normal,\n+        sign: false,\n+        marker: PhantomData,\n+    };\n \n     fn smallest_normalized() -> Self {\n-        panic!(\"NYI smallest_normalized\")\n+        // We want (in interchange format):\n+        //   exponent = 0..0\n+        //   significand = 10..0\n+        IeeeFloat {\n+            sig: [1 << (S::PRECISION - 1)],\n+            exp: S::MIN_EXP,\n+            category: Category::Normal,\n+            sign: false,\n+            marker: PhantomData,\n+        }\n     }\n \n-    fn add_r(self, rhs: Self, round: Round) -> StatusAnd<Self> {\n-        panic!(\"NYI add_r\")\n+    fn add_r(mut self, rhs: Self, round: Round) -> StatusAnd<Self> {\n+        let status = match (self.category, rhs.category) {\n+            (Category::Infinity, Category::Infinity) => {\n+                // Differently signed infinities can only be validly\n+                // subtracted.\n+                if self.sign != rhs.sign {\n+                    self = Self::NAN;\n+                    Status::INVALID_OP\n+                } else {\n+                    Status::OK\n+                }\n+            }\n+\n+            // Sign may depend on rounding mode; handled below.\n+            (_, Category::Zero) |\n+            (Category::NaN, _) |\n+            (Category::Infinity, Category::Normal) => Status::OK,\n+\n+            (Category::Zero, _) |\n+            (_, Category::NaN) |\n+            (_, Category::Infinity) => {\n+                self = rhs;\n+                Status::OK\n+            }\n+\n+            // This return code means it was not a simple case.\n+            (Category::Normal, Category::Normal) => {\n+                let loss = sig::add_or_sub(\n+                    &mut self.sig,\n+                    &mut self.exp,\n+                    &mut self.sign,\n+                    &mut [rhs.sig[0]],\n+                    rhs.exp,\n+                    rhs.sign,\n+                );\n+                let status;\n+                self = unpack!(status=, self.normalize(round, loss));\n+\n+                // Can only be zero if we lost no fraction.\n+                assert!(self.category != Category::Zero || loss == Loss::ExactlyZero);\n+\n+                status\n+            }\n+        };\n+\n+        // If two numbers add (exactly) to zero, IEEE 754 decrees it is a\n+        // positive zero unless rounding to minus infinity, except that\n+        // adding two like-signed zeroes gives that zero.\n+        if self.category == Category::Zero &&\n+            (rhs.category != Category::Zero || self.sign != rhs.sign)\n+        {\n+            self.sign = round == Round::TowardNegative;\n+        }\n+\n+        status.and(self)\n     }\n \n-    fn mul_r(self, rhs: Self, round: Round) -> StatusAnd<Self> {\n-        panic!(\"NYI mul_r\")\n+    fn mul_r(mut self, rhs: Self, round: Round) -> StatusAnd<Self> {\n+        self.sign ^= rhs.sign;\n+\n+        match (self.category, rhs.category) {\n+            (Category::NaN, _) => {\n+                self.sign = false;\n+                Status::OK.and(self)\n+            }\n+\n+            (_, Category::NaN) => {\n+                self.sign = false;\n+                self.category = Category::NaN;\n+                self.sig = rhs.sig;\n+                Status::OK.and(self)\n+            }\n+\n+            (Category::Zero, Category::Infinity) |\n+            (Category::Infinity, Category::Zero) => Status::INVALID_OP.and(Self::NAN),\n+\n+            (_, Category::Infinity) |\n+            (Category::Infinity, _) => {\n+                self.category = Category::Infinity;\n+                Status::OK.and(self)\n+            }\n+\n+            (Category::Zero, _) |\n+            (_, Category::Zero) => {\n+                self.category = Category::Zero;\n+                Status::OK.and(self)\n+            }\n+\n+            (Category::Normal, Category::Normal) => {\n+                self.exp += rhs.exp;\n+                let mut wide_sig = [0; 2];\n+                let loss = sig::mul(\n+                    &mut wide_sig,\n+                    &mut self.exp,\n+                    &self.sig,\n+                    &rhs.sig,\n+                    S::PRECISION,\n+                );\n+                self.sig = [wide_sig[0]];\n+                let mut status;\n+                self = unpack!(status=, self.normalize(round, loss));\n+                if loss != Loss::ExactlyZero {\n+                    status |= Status::INEXACT;\n+                }\n+                status.and(self)\n+            }\n+        }\n     }\n \n-    fn mul_add_r(self, multiplicand: Self, addend: Self, round: Round) -> StatusAnd<Self> {\n-        panic!(\"NYI mul_add_r\")\n+    fn mul_add_r(mut self, multiplicand: Self, addend: Self, round: Round) -> StatusAnd<Self> {\n+        // If and only if all arguments are normal do we need to do an\n+        // extended-precision calculation.\n+        if !self.is_finite_non_zero() || !multiplicand.is_finite_non_zero() || !addend.is_finite() {\n+            let mut status;\n+            self = unpack!(status=, self.mul_r(multiplicand, round));\n+\n+            // FS can only be Status::OK or Status::INVALID_OP. There is no more work\n+            // to do in the latter case. The IEEE-754R standard says it is\n+            // implementation-defined in this case whether, if ADDEND is a\n+            // quiet NaN, we raise invalid op; this implementation does so.\n+            //\n+            // If we need to do the addition we can do so with normal\n+            // precision.\n+            if status == Status::OK {\n+                self = unpack!(status=, self.add_r(addend, round));\n+            }\n+            return status.and(self);\n+        }\n+\n+        // Post-multiplication sign, before addition.\n+        self.sign ^= multiplicand.sign;\n+\n+        // Allocate space for twice as many bits as the original significand, plus one\n+        // extra bit for the addition to overflow into.\n+        assert!(limbs_for_bits(S::PRECISION * 2 + 1) <= 2);\n+        let mut wide_sig = sig::widening_mul(self.sig[0], multiplicand.sig[0]);\n+\n+        let mut loss = Loss::ExactlyZero;\n+        let mut omsb = sig::omsb(&wide_sig);\n+        self.exp += multiplicand.exp;\n+\n+        // Assume the operands involved in the multiplication are single-precision\n+        // FP, and the two multiplicants are:\n+        //     lhs = a23 . a22 ... a0 * 2^e1\n+        //     rhs = b23 . b22 ... b0 * 2^e2\n+        // the result of multiplication is:\n+        //     lhs = c48 c47 c46 . c45 ... c0 * 2^(e1+e2)\n+        // Note that there are three significant bits at the left-hand side of the\n+        // radix point: two for the multiplication, and an overflow bit for the\n+        // addition (that will always be zero at this point). Move the radix point\n+        // toward left by two bits, and adjust exponent accordingly.\n+        self.exp += 2;\n+\n+        if addend.is_non_zero() {\n+            // Normalize our MSB to one below the top bit to allow for overflow.\n+            let ext_precision = 2 * S::PRECISION + 1;\n+            if omsb != ext_precision - 1 {\n+                assert!(ext_precision > omsb);\n+                sig::shift_left(&mut wide_sig, &mut self.exp, (ext_precision - 1) - omsb);\n+            }\n+\n+            // The intermediate result of the multiplication has \"2 * S::PRECISION\"\n+            // signicant bit; adjust the addend to be consistent with mul result.\n+            let mut ext_addend_sig = [addend.sig[0], 0];\n+\n+            // Extend the addend significand to ext_precision - 1. This guarantees\n+            // that the high bit of the significand is zero (same as wide_sig),\n+            // so the addition will overflow (if it does overflow at all) into the top bit.\n+            sig::shift_left(\n+                &mut ext_addend_sig,\n+                &mut 0,\n+                ext_precision - 1 - S::PRECISION,\n+            );\n+            loss = sig::add_or_sub(\n+                &mut wide_sig,\n+                &mut self.exp,\n+                &mut self.sign,\n+                &mut ext_addend_sig,\n+                addend.exp + 1,\n+                addend.sign,\n+            );\n+\n+            omsb = sig::omsb(&wide_sig);\n+        }\n+\n+        // Convert the result having \"2 * S::PRECISION\" significant-bits back to the one\n+        // having \"S::PRECISION\" significant-bits. First, move the radix point from\n+        // poision \"2*S::PRECISION - 1\" to \"S::PRECISION - 1\". The exponent need to be\n+        // adjusted by \"2*S::PRECISION - 1\" - \"S::PRECISION - 1\" = \"S::PRECISION\".\n+        self.exp -= S::PRECISION as ExpInt + 1;\n+\n+        // In case MSB resides at the left-hand side of radix point, shift the\n+        // mantissa right by some amount to make sure the MSB reside right before\n+        // the radix point (i.e. \"MSB . rest-significant-bits\").\n+        if omsb > S::PRECISION {\n+            let bits = omsb - S::PRECISION;\n+            loss = sig::shift_right(&mut wide_sig, &mut self.exp, bits).combine(loss);\n+        }\n+\n+        self.sig[0] = wide_sig[0];\n+\n+        let mut status;\n+        self = unpack!(status=, self.normalize(round, loss));\n+        if loss != Loss::ExactlyZero {\n+            status |= Status::INEXACT;\n+        }\n+\n+        // If two numbers add (exactly) to zero, IEEE 754 decrees it is a\n+        // positive zero unless rounding to minus infinity, except that\n+        // adding two like-signed zeroes gives that zero.\n+        if self.category == Category::Zero && !status.intersects(Status::UNDERFLOW) &&\n+            self.sign != addend.sign\n+        {\n+            self.sign = round == Round::TowardNegative;\n+        }\n+\n+        status.and(self)\n     }\n \n-    fn div_r(self, rhs: Self, round: Round) -> StatusAnd<Self> {\n-        panic!(\"NYI div_r\")\n+    fn div_r(mut self, rhs: Self, round: Round) -> StatusAnd<Self> {\n+        self.sign ^= rhs.sign;\n+\n+        match (self.category, rhs.category) {\n+            (Category::NaN, _) => {\n+                self.sign = false;\n+                Status::OK.and(self)\n+            }\n+\n+            (_, Category::NaN) => {\n+                self.category = Category::NaN;\n+                self.sig = rhs.sig;\n+                self.sign = false;\n+                Status::OK.and(self)\n+            }\n+\n+            (Category::Infinity, Category::Infinity) |\n+            (Category::Zero, Category::Zero) => Status::INVALID_OP.and(Self::NAN),\n+\n+            (Category::Infinity, _) |\n+            (Category::Zero, _) => Status::OK.and(self),\n+\n+            (Category::Normal, Category::Infinity) => {\n+                self.category = Category::Zero;\n+                Status::OK.and(self)\n+            }\n+\n+            (Category::Normal, Category::Zero) => {\n+                self.category = Category::Infinity;\n+                Status::DIV_BY_ZERO.and(self)\n+            }\n+\n+            (Category::Normal, Category::Normal) => {\n+                self.exp -= rhs.exp;\n+                let dividend = self.sig[0];\n+                let loss = sig::div(\n+                    &mut self.sig,\n+                    &mut self.exp,\n+                    &mut [dividend],\n+                    &mut [rhs.sig[0]],\n+                    S::PRECISION,\n+                );\n+                let mut status;\n+                self = unpack!(status=, self.normalize(round, loss));\n+                if loss != Loss::ExactlyZero {\n+                    status |= Status::INEXACT;\n+                }\n+                status.and(self)\n+            }\n+        }\n     }\n \n-    fn c_fmod(self, rhs: Self) -> StatusAnd<Self> {\n-        panic!(\"NYI c_fmod\")\n+    fn c_fmod(mut self, rhs: Self) -> StatusAnd<Self> {\n+        match (self.category, rhs.category) {\n+            (Category::NaN, _) |\n+            (Category::Zero, Category::Infinity) |\n+            (Category::Zero, Category::Normal) |\n+            (Category::Normal, Category::Infinity) => Status::OK.and(self),\n+\n+            (_, Category::NaN) => {\n+                self.sign = false;\n+                self.category = Category::NaN;\n+                self.sig = rhs.sig;\n+                Status::OK.and(self)\n+            }\n+\n+            (Category::Infinity, _) |\n+            (_, Category::Zero) => Status::INVALID_OP.and(Self::NAN),\n+\n+            (Category::Normal, Category::Normal) => {\n+                while self.is_finite_non_zero() && rhs.is_finite_non_zero() &&\n+                    self.cmp_abs_normal(rhs) != Ordering::Less\n+                {\n+                    let mut v = rhs.scalbn(self.ilogb() - rhs.ilogb());\n+                    if self.cmp_abs_normal(v) == Ordering::Less {\n+                        v = v.scalbn(-1);\n+                    }\n+                    v.sign = self.sign;\n+\n+                    let status;\n+                    self = unpack!(status=, self - v);\n+                    assert_eq!(status, Status::OK);\n+                }\n+                Status::OK.and(self)\n+            }\n+        }\n     }\n \n     fn round_to_integral(self, round: Round) -> StatusAnd<Self> {\n-        panic!(\"NYI round_to_integral\")\n+        // If the exponent is large enough, we know that this value is already\n+        // integral, and the arithmetic below would potentially cause it to saturate\n+        // to +/-Inf. Bail out early instead.\n+        if self.is_finite_non_zero() && self.exp + 1 >= S::PRECISION as ExpInt {\n+            return Status::OK.and(self);\n+        }\n+\n+        // The algorithm here is quite simple: we add 2^(p-1), where p is the\n+        // precision of our format, and then subtract it back off again. The choice\n+        // of rounding modes for the addition/subtraction determines the rounding mode\n+        // for our integral rounding as well.\n+        // NOTE: When the input value is negative, we do subtraction followed by\n+        // addition instead.\n+        assert!(S::PRECISION <= 128);\n+        let mut status;\n+        let magic_const = unpack!(status=, Self::from_u128(1 << (S::PRECISION - 1)));\n+        let magic_const = magic_const.copy_sign(self);\n+\n+        if status != Status::OK {\n+            return status.and(self);\n+        }\n+\n+        let mut r = self;\n+        r = unpack!(status=, r.add_r(magic_const, round));\n+        if status != Status::OK && status != Status::INEXACT {\n+            return status.and(self);\n+        }\n+\n+        // Restore the input sign to handle 0.0/-0.0 cases correctly.\n+        r.sub_r(magic_const, round).map(|r| r.copy_sign(self))\n     }\n \n-    fn next_up(self) -> StatusAnd<Self> {\n-        panic!(\"NYI next_up\")\n+    fn next_up(mut self) -> StatusAnd<Self> {\n+        // Compute nextUp(x), handling each float category separately.\n+        match self.category {\n+            Category::Infinity => {\n+                if self.sign {\n+                    // nextUp(-inf) = -largest\n+                    Status::OK.and(-Self::largest())\n+                } else {\n+                    // nextUp(+inf) = +inf\n+                    Status::OK.and(self)\n+                }\n+            }\n+            Category::NaN => {\n+                // IEEE-754R 2008 6.2 Par 2: nextUp(sNaN) = qNaN. Set Invalid flag.\n+                // IEEE-754R 2008 6.2: nextUp(qNaN) = qNaN. Must be identity so we do not\n+                //                     change the payload.\n+                if self.is_signaling() {\n+                    // For consistency, propagate the sign of the sNaN to the qNaN.\n+                    Status::INVALID_OP.and(Self::NAN.copy_sign(self))\n+                } else {\n+                    Status::OK.and(self)\n+                }\n+            }\n+            Category::Zero => {\n+                // nextUp(pm 0) = +smallest\n+                Status::OK.and(Self::SMALLEST)\n+            }\n+            Category::Normal => {\n+                // nextUp(-smallest) = -0\n+                if self.is_smallest() && self.sign {\n+                    return Status::OK.and(-Self::ZERO);\n+                }\n+\n+                // nextUp(largest) == INFINITY\n+                if self.is_largest() && !self.sign {\n+                    return Status::OK.and(Self::INFINITY);\n+                }\n+\n+                // Excluding the integral bit. This allows us to test for binade boundaries.\n+                let sig_mask = (1 << (S::PRECISION - 1)) - 1;\n+\n+                // nextUp(normal) == normal + inc.\n+                if self.sign {\n+                    // If we are negative, we need to decrement the significand.\n+\n+                    // We only cross a binade boundary that requires adjusting the exponent\n+                    // if:\n+                    //   1. exponent != S::MIN_EXP. This implies we are not in the\n+                    //   smallest binade or are dealing with denormals.\n+                    //   2. Our significand excluding the integral bit is all zeros.\n+                    let crossing_binade_boundary = self.exp != S::MIN_EXP &&\n+                        self.sig[0] & sig_mask == 0;\n+\n+                    // Decrement the significand.\n+                    //\n+                    // We always do this since:\n+                    //   1. If we are dealing with a non-binade decrement, by definition we\n+                    //   just decrement the significand.\n+                    //   2. If we are dealing with a normal -> normal binade decrement, since\n+                    //   we have an explicit integral bit the fact that all bits but the\n+                    //   integral bit are zero implies that subtracting one will yield a\n+                    //   significand with 0 integral bit and 1 in all other spots. Thus we\n+                    //   must just adjust the exponent and set the integral bit to 1.\n+                    //   3. If we are dealing with a normal -> denormal binade decrement,\n+                    //   since we set the integral bit to 0 when we represent denormals, we\n+                    //   just decrement the significand.\n+                    sig::decrement(&mut self.sig);\n+\n+                    if crossing_binade_boundary {\n+                        // Our result is a normal number. Do the following:\n+                        // 1. Set the integral bit to 1.\n+                        // 2. Decrement the exponent.\n+                        sig::set_bit(&mut self.sig, S::PRECISION - 1);\n+                        self.exp -= 1;\n+                    }\n+                } else {\n+                    // If we are positive, we need to increment the significand.\n+\n+                    // We only cross a binade boundary that requires adjusting the exponent if\n+                    // the input is not a denormal and all of said input's significand bits\n+                    // are set. If all of said conditions are true: clear the significand, set\n+                    // the integral bit to 1, and increment the exponent. If we have a\n+                    // denormal always increment since moving denormals and the numbers in the\n+                    // smallest normal binade have the same exponent in our representation.\n+                    let crossing_binade_boundary = !self.is_denormal() &&\n+                        self.sig[0] & sig_mask == sig_mask;\n+\n+                    if crossing_binade_boundary {\n+                        self.sig = [0];\n+                        sig::set_bit(&mut self.sig, S::PRECISION - 1);\n+                        assert_ne!(\n+                            self.exp,\n+                            S::MAX_EXP,\n+                            \"We can not increment an exponent beyond the MAX_EXP \\\n+                             allowed by the given floating point semantics.\"\n+                        );\n+                        self.exp += 1;\n+                    } else {\n+                        sig::increment(&mut self.sig);\n+                    }\n+                }\n+                Status::OK.and(self)\n+            }\n+        }\n     }\n \n     fn from_bits(input: u128) -> Self {\n-        panic!(\"NYI from_bits\")\n+        // Dispatch to semantics.\n+        S::from_bits(input)\n     }\n \n     fn from_u128_r(input: u128, round: Round) -> StatusAnd<Self> {\n-        panic!(\"NYI from_u128_r\")\n+        IeeeFloat {\n+            sig: [input],\n+            exp: S::PRECISION as ExpInt - 1,\n+            category: Category::Normal,\n+            sign: false,\n+            marker: PhantomData,\n+        }.normalize(round, Loss::ExactlyZero)\n     }\n \n-    fn from_str_r(s: &str, round: Round) -> Result<StatusAnd<Self>, ParseError> {\n-        panic!(\"NYI from_str_r\")\n+    fn from_str_r(mut s: &str, mut round: Round) -> Result<StatusAnd<Self>, ParseError> {\n+        if s.is_empty() {\n+            return Err(ParseError(\"Invalid string length\"));\n+        }\n+\n+        // Handle special cases.\n+        match s {\n+            \"inf\" | \"INFINITY\" => return Ok(Status::OK.and(Self::INFINITY)),\n+            \"-inf\" | \"-INFINITY\" => return Ok(Status::OK.and(-Self::INFINITY)),\n+            \"nan\" | \"NaN\" => return Ok(Status::OK.and(Self::NAN)),\n+            \"-nan\" | \"-NaN\" => return Ok(Status::OK.and(-Self::NAN)),\n+            _ => {}\n+        }\n+\n+        // Handle a leading minus sign.\n+        let minus = s.starts_with(\"-\");\n+        if minus || s.starts_with(\"+\") {\n+            s = &s[1..];\n+            if s.is_empty() {\n+                return Err(ParseError(\"String has no digits\"));\n+            }\n+        }\n+\n+        // Adjust the rounding mode for the absolute value below.\n+        if minus {\n+            round = -round;\n+        }\n+\n+        let r = if s.starts_with(\"0x\") || s.starts_with(\"0X\") {\n+            s = &s[2..];\n+            if s.is_empty() {\n+                return Err(ParseError(\"Invalid string\"));\n+            }\n+            Self::from_hexadecimal_string(s, round)?\n+        } else {\n+            Self::from_decimal_string(s, round)?\n+        };\n+\n+        Ok(r.map(|r| if minus { -r } else { r }))\n     }\n \n     fn to_bits(self) -> u128 {\n-        panic!(\"NYI to_bits\")\n+        // Dispatch to semantics.\n+        S::to_bits(self)\n     }\n \n     fn to_u128_r(self, width: usize, round: Round, is_exact: &mut bool) -> StatusAnd<u128> {\n-        panic!(\"NYI to_u128_r\");\n+        // The result of trying to convert a number too large.\n+        let overflow = if self.sign {\n+            // Negative numbers cannot be represented as unsigned.\n+            0\n+        } else {\n+            // Largest unsigned integer of the given width.\n+            !0 >> (128 - width)\n+        };\n+\n+        *is_exact = false;\n+\n+        match self.category {\n+            Category::NaN => Status::INVALID_OP.and(0),\n+\n+            Category::Infinity => Status::INVALID_OP.and(overflow),\n+\n+            Category::Zero => {\n+                // Negative zero can't be represented as an int.\n+                *is_exact = !self.sign;\n+                Status::OK.and(0)\n+            }\n+\n+            Category::Normal => {\n+                let mut r = 0;\n+\n+                // Step 1: place our absolute value, with any fraction truncated, in\n+                // the destination.\n+                let truncated_bits = if self.exp < 0 {\n+                    // Our absolute value is less than one; truncate everything.\n+                    // For exponent -1 the integer bit represents .5, look at that.\n+                    // For smaller exponents leftmost truncated bit is 0.\n+                    S::PRECISION - 1 + (-self.exp) as usize\n+                } else {\n+                    // We want the most significant (exponent + 1) bits; the rest are\n+                    // truncated.\n+                    let bits = self.exp as usize + 1;\n+\n+                    // Hopelessly large in magnitude?\n+                    if bits > width {\n+                        return Status::INVALID_OP.and(overflow);\n+                    }\n+\n+                    if bits < S::PRECISION {\n+                        // We truncate (S::PRECISION - bits) bits.\n+                        r = self.sig[0] >> (S::PRECISION - bits);\n+                        S::PRECISION - bits\n+                    } else {\n+                        // We want at least as many bits as are available.\n+                        r = self.sig[0] << (bits - S::PRECISION);\n+                        0\n+                    }\n+                };\n+\n+                // Step 2: work out any lost fraction, and increment the absolute\n+                // value if we would round away from zero.\n+                let mut loss = Loss::ExactlyZero;\n+                if truncated_bits > 0 {\n+                    loss = Loss::through_truncation(&self.sig, truncated_bits);\n+                    if loss != Loss::ExactlyZero &&\n+                        self.round_away_from_zero(round, loss, truncated_bits)\n+                    {\n+                        r = r.wrapping_add(1);\n+                        if r == 0 {\n+                            return Status::INVALID_OP.and(overflow); // Overflow.\n+                        }\n+                    }\n+                }\n+\n+                // Step 3: check if we fit in the destination.\n+                if r > overflow {\n+                    return Status::INVALID_OP.and(overflow);\n+                }\n+\n+                if loss == Loss::ExactlyZero {\n+                    *is_exact = true;\n+                    Status::OK.and(r)\n+                } else {\n+                    Status::INEXACT.and(r)\n+                }\n+            }\n+        }\n     }\n \n     fn cmp_abs_normal(self, rhs: Self) -> Ordering {\n-        panic!(\"NYI cmp_abs_normal\")\n+        assert!(self.is_finite_non_zero());\n+        assert!(rhs.is_finite_non_zero());\n+\n+        // If exponents are equal, do an unsigned comparison of the significands.\n+        self.exp.cmp(&rhs.exp).then_with(\n+            || sig::cmp(&self.sig, &rhs.sig),\n+        )\n     }\n \n     fn bitwise_eq(self, rhs: Self) -> bool {\n-        panic!(\"NYI bitwise_eq\")\n+        if self.category != rhs.category || self.sign != rhs.sign {\n+            return false;\n+        }\n+\n+        if self.category == Category::Zero || self.category == Category::Infinity {\n+            return true;\n+        }\n+\n+        if self.is_finite_non_zero() && self.exp != rhs.exp {\n+            return false;\n+        }\n+\n+        self.sig == rhs.sig\n     }\n \n     fn is_negative(self) -> bool {\n-        panic!(\"NYI is_negative\")\n+        self.sign\n     }\n \n     fn is_denormal(self) -> bool {\n-        panic!(\"NYI is_denormal\")\n+        self.is_finite_non_zero() && self.exp == S::MIN_EXP &&\n+            !sig::get_bit(&self.sig, S::PRECISION - 1)\n     }\n \n     fn is_signaling(self) -> bool {\n-        panic!(\"NYI is_signaling\")\n+        // IEEE-754R 2008 6.2.1: A signaling NaN bit string should be encoded with the\n+        // first bit of the trailing significand being 0.\n+        self.is_nan() && !sig::get_bit(&self.sig, S::QNAN_BIT)\n     }\n \n     fn category(self) -> Category {\n-        panic!(\"NYI category\")\n+        self.category\n     }\n \n     fn get_exact_inverse(self) -> Option<Self> {\n-        panic!(\"NYI get_exact_inverse\")\n+        // Special floats and denormals have no exact inverse.\n+        if !self.is_finite_non_zero() {\n+            return None;\n+        }\n+\n+        // Check that the number is a power of two by making sure that only the\n+        // integer bit is set in the significand.\n+        if self.sig != [1 << (S::PRECISION - 1)] {\n+            return None;\n+        }\n+\n+        // Get the inverse.\n+        let mut reciprocal = Self::from_u128(1).value;\n+        let status;\n+        reciprocal = unpack!(status=, reciprocal / self);\n+        if status != Status::OK {\n+            return None;\n+        }\n+\n+        // Avoid multiplication with a denormal, it is not safe on all platforms and\n+        // may be slower than a normal division.\n+        if reciprocal.is_denormal() {\n+            return None;\n+        }\n+\n+        assert!(reciprocal.is_finite_non_zero());\n+        assert_eq!(reciprocal.sig, [1 << (S::PRECISION - 1)]);\n+\n+        Some(reciprocal)\n     }\n \n-    fn ilogb(self) -> ExpInt {\n-        panic!(\"NYI ilogb\")\n+    fn ilogb(mut self) -> ExpInt {\n+        if self.is_nan() {\n+            return IEK_NAN;\n+        }\n+        if self.is_zero() {\n+            return IEK_ZERO;\n+        }\n+        if self.is_infinite() {\n+            return IEK_INF;\n+        }\n+        if !self.is_denormal() {\n+            return self.exp;\n+        }\n+\n+        let sig_bits = (S::PRECISION - 1) as ExpInt;\n+        self.exp += sig_bits;\n+        self = self.normalize(Round::NearestTiesToEven, Loss::ExactlyZero)\n+            .value;\n+        self.exp - sig_bits\n     }\n \n-    fn scalbn_r(self, exp: ExpInt, round: Round) -> Self {\n-        panic!(\"NYI scalbn\")\n+    fn scalbn_r(mut self, exp: ExpInt, round: Round) -> Self {\n+        // If exp is wildly out-of-scale, simply adding it to self.exp will\n+        // overflow; clamp it to a safe range before adding, but ensure that the range\n+        // is large enough that the clamp does not change the result. The range we\n+        // need to support is the difference between the largest possible exponent and\n+        // the normalized exponent of half the smallest denormal.\n+\n+        let sig_bits = (S::PRECISION - 1) as i32;\n+        let max_change = S::MAX_EXP as i32 - (S::MIN_EXP as i32 - sig_bits) + 1;\n+\n+        // Clamp to one past the range ends to let normalize handle overflow.\n+        let exp_change = cmp::min(cmp::max(exp as i32, (-max_change - 1)), max_change);\n+        self.exp = self.exp.saturating_add(exp_change as ExpInt);\n+        self = self.normalize(round, Loss::ExactlyZero).value;\n+        if self.is_nan() {\n+            sig::set_bit(&mut self.sig, S::QNAN_BIT);\n+        }\n+        self\n     }\n \n-    fn frexp_r(self, exp: &mut ExpInt, round: Round) -> Self {\n-        panic!(\"NYI frexp\")\n+    fn frexp_r(mut self, exp: &mut ExpInt, round: Round) -> Self {\n+        *exp = self.ilogb();\n+\n+        // Quiet signalling nans.\n+        if *exp == IEK_NAN {\n+            sig::set_bit(&mut self.sig, S::QNAN_BIT);\n+            return self;\n+        }\n+\n+        if *exp == IEK_INF {\n+            return self;\n+        }\n+\n+        // 1 is added because frexp is defined to return a normalized fraction in\n+        // +/-[0.5, 1.0), rather than the usual +/-[1.0, 2.0).\n+        if *exp == IEK_ZERO {\n+            *exp = 0;\n+        } else {\n+            *exp += 1;\n+        }\n+        self.scalbn_r(-*exp, round)\n     }\n }\n \n-#[allow(unused)]\n impl<S: Semantics, T: Semantics> FloatConvert<IeeeFloat<T>> for IeeeFloat<S> {\n     fn convert_r(self, round: Round, loses_info: &mut bool) -> StatusAnd<IeeeFloat<T>> {\n-        panic!(\"NYI convert_r\");\n+        let mut r = IeeeFloat {\n+            sig: self.sig,\n+            exp: self.exp,\n+            category: self.category,\n+            sign: self.sign,\n+            marker: PhantomData,\n+        };\n+\n+        // x86 has some unusual NaNs which cannot be represented in any other\n+        // format; note them here.\n+        fn is_x87_double_extended<S: Semantics>() -> bool {\n+            S::QNAN_SIGNIFICAND == X87DoubleExtendedS::QNAN_SIGNIFICAND\n+        }\n+        let x87_special_nan = is_x87_double_extended::<S>() && !is_x87_double_extended::<T>() &&\n+            r.category == Category::NaN &&\n+            (r.sig[0] & S::QNAN_SIGNIFICAND) != S::QNAN_SIGNIFICAND;\n+\n+        // If this is a truncation of a denormal number, and the target semantics\n+        // has larger exponent range than the source semantics (this can happen\n+        // when truncating from PowerPC double-double to double format), the\n+        // right shift could lose result mantissa bits. Adjust exponent instead\n+        // of performing excessive shift.\n+        let mut shift = T::PRECISION as ExpInt - S::PRECISION as ExpInt;\n+        if shift < 0 && r.is_finite_non_zero() {\n+            let mut exp_change = sig::omsb(&r.sig) as ExpInt - S::PRECISION as ExpInt;\n+            if r.exp + exp_change < T::MIN_EXP {\n+                exp_change = T::MIN_EXP - r.exp;\n+            }\n+            if exp_change < shift {\n+                exp_change = shift;\n+            }\n+            if exp_change < 0 {\n+                shift -= exp_change;\n+                r.exp += exp_change;\n+            }\n+        }\n+\n+        // If this is a truncation, perform the shift.\n+        let mut loss = Loss::ExactlyZero;\n+        if shift < 0 && (r.is_finite_non_zero() || r.category == Category::NaN) {\n+            loss = sig::shift_right(&mut r.sig, &mut 0, -shift as usize);\n+        }\n+\n+        // If this is an extension, perform the shift.\n+        if shift > 0 && (r.is_finite_non_zero() || r.category == Category::NaN) {\n+            sig::shift_left(&mut r.sig, &mut 0, shift as usize);\n+        }\n+\n+        let status;\n+        if r.is_finite_non_zero() {\n+            r = unpack!(status=, r.normalize(round, loss));\n+            *loses_info = status != Status::OK;\n+        } else if r.category == Category::NaN {\n+            *loses_info = loss != Loss::ExactlyZero || x87_special_nan;\n+\n+            // For x87 extended precision, we want to make a NaN, not a special NaN if\n+            // the input wasn't special either.\n+            if !x87_special_nan && is_x87_double_extended::<T>() {\n+                sig::set_bit(&mut r.sig, T::PRECISION - 1);\n+            }\n+\n+            // gcc forces the Quiet bit on, which means (float)(double)(float_sNan)\n+            // does not give you back the same bits. This is dubious, and we\n+            // don't currently do it. You're really supposed to get\n+            // an invalid operation signal at runtime, but nobody does that.\n+            status = Status::OK;\n+        } else {\n+            *loses_info = false;\n+            status = Status::OK;\n+        }\n+\n+        status.and(r)\n+    }\n+}\n+\n+impl<S: Semantics> IeeeFloat<S> {\n+    /// Handle positive overflow. We either return infinity or\n+    /// the largest finite number. For negative overflow,\n+    /// negate the `round` argument before calling.\n+    fn overflow_result(round: Round) -> StatusAnd<Self> {\n+        match round {\n+            // Infinity?\n+            Round::NearestTiesToEven | Round::NearestTiesToAway | Round::TowardPositive => {\n+                (Status::OVERFLOW | Status::INEXACT).and(Self::INFINITY)\n+            }\n+            // Otherwise we become the largest finite number.\n+            Round::TowardNegative | Round::TowardZero => Status::INEXACT.and(Self::largest()),\n+        }\n+    }\n+\n+    /// Returns TRUE if, when truncating the current number, with BIT the\n+    /// new LSB, with the given lost fraction and rounding mode, the result\n+    /// would need to be rounded away from zero (i.e., by increasing the\n+    /// signficand). This routine must work for Category::Zero of both signs, and\n+    /// Category::Normal numbers.\n+    fn round_away_from_zero(&self, round: Round, loss: Loss, bit: usize) -> bool {\n+        // NaNs and infinities should not have lost fractions.\n+        assert!(self.is_finite_non_zero() || self.is_zero());\n+\n+        // Current callers never pass this so we don't handle it.\n+        assert_ne!(loss, Loss::ExactlyZero);\n+\n+        match round {\n+            Round::NearestTiesToAway => loss == Loss::ExactlyHalf || loss == Loss::MoreThanHalf,\n+            Round::NearestTiesToEven => {\n+                if loss == Loss::MoreThanHalf {\n+                    return true;\n+                }\n+\n+                // Our zeros don't have a significand to test.\n+                if loss == Loss::ExactlyHalf && self.category != Category::Zero {\n+                    return sig::get_bit(&self.sig, bit);\n+                }\n+\n+                false\n+            }\n+            Round::TowardZero => false,\n+            Round::TowardPositive => !self.sign,\n+            Round::TowardNegative => self.sign,\n+        }\n+    }\n+\n+    fn normalize(mut self, round: Round, mut loss: Loss) -> StatusAnd<Self> {\n+        if !self.is_finite_non_zero() {\n+            return Status::OK.and(self);\n+        }\n+\n+        // Before rounding normalize the exponent of Category::Normal numbers.\n+        let mut omsb = sig::omsb(&self.sig);\n+\n+        if omsb > 0 {\n+            // OMSB is numbered from 1. We want to place it in the integer\n+            // bit numbered PRECISION if possible, with a compensating change in\n+            // the exponent.\n+            let mut final_exp = self.exp.saturating_add(\n+                omsb as ExpInt - S::PRECISION as ExpInt,\n+            );\n+\n+            // If the resulting exponent is too high, overflow according to\n+            // the rounding mode.\n+            if final_exp > S::MAX_EXP {\n+                let round = if self.sign { -round } else { round };\n+                return Self::overflow_result(round).map(|r| r.copy_sign(self));\n+            }\n+\n+            // Subnormal numbers have exponent MIN_EXP, and their MSB\n+            // is forced based on that.\n+            if final_exp < S::MIN_EXP {\n+                final_exp = S::MIN_EXP;\n+            }\n+\n+            // Shifting left is easy as we don't lose precision.\n+            if final_exp < self.exp {\n+                assert_eq!(loss, Loss::ExactlyZero);\n+\n+                let exp_change = (self.exp - final_exp) as usize;\n+                sig::shift_left(&mut self.sig, &mut self.exp, exp_change);\n+\n+                return Status::OK.and(self);\n+            }\n+\n+            // Shift right and capture any new lost fraction.\n+            if final_exp > self.exp {\n+                let exp_change = (final_exp - self.exp) as usize;\n+                loss = sig::shift_right(&mut self.sig, &mut self.exp, exp_change).combine(loss);\n+\n+                // Keep OMSB up-to-date.\n+                omsb = omsb.saturating_sub(exp_change);\n+            }\n+        }\n+\n+        // Now round the number according to round given the lost\n+        // fraction.\n+\n+        // As specified in IEEE 754, since we do not trap we do not report\n+        // underflow for exact results.\n+        if loss == Loss::ExactlyZero {\n+            // Canonicalize zeros.\n+            if omsb == 0 {\n+                self.category = Category::Zero;\n+            }\n+\n+            return Status::OK.and(self);\n+        }\n+\n+        // Increment the significand if we're rounding away from zero.\n+        if self.round_away_from_zero(round, loss, 0) {\n+            if omsb == 0 {\n+                self.exp = S::MIN_EXP;\n+            }\n+\n+            // We should never overflow.\n+            assert_eq!(sig::increment(&mut self.sig), 0);\n+            omsb = sig::omsb(&self.sig);\n+\n+            // Did the significand increment overflow?\n+            if omsb == S::PRECISION + 1 {\n+                // Renormalize by incrementing the exponent and shifting our\n+                // significand right one. However if we already have the\n+                // maximum exponent we overflow to infinity.\n+                if self.exp == S::MAX_EXP {\n+                    self.category = Category::Infinity;\n+\n+                    return (Status::OVERFLOW | Status::INEXACT).and(self);\n+                }\n+\n+                let _: Loss = sig::shift_right(&mut self.sig, &mut self.exp, 1);\n+\n+                return Status::INEXACT.and(self);\n+            }\n+        }\n+\n+        // The normal case - we were and are not denormal, and any\n+        // significand increment above didn't overflow.\n+        if omsb == S::PRECISION {\n+            return Status::INEXACT.and(self);\n+        }\n+\n+        // We have a non-zero denormal.\n+        assert!(omsb < S::PRECISION);\n+\n+        // Canonicalize zeros.\n+        if omsb == 0 {\n+            self.category = Category::Zero;\n+        }\n+\n+        // The Category::Zero case is a denormal that underflowed to zero.\n+        (Status::UNDERFLOW | Status::INEXACT).and(self)\n+    }\n+\n+    fn from_hexadecimal_string(s: &str, round: Round) -> Result<StatusAnd<Self>, ParseError> {\n+        let mut r = IeeeFloat {\n+            sig: [0],\n+            exp: 0,\n+            category: Category::Normal,\n+            sign: false,\n+            marker: PhantomData,\n+        };\n+\n+        let mut any_digits = false;\n+        let mut has_exp = false;\n+        let mut bit_pos = LIMB_BITS as isize;\n+        let mut loss = None;\n+\n+        // Without leading or trailing zeros, irrespective of the dot.\n+        let mut first_sig_digit = None;\n+        let mut dot = s.len();\n+\n+        for (p, c) in s.char_indices() {\n+            // Skip leading zeros and any (hexa)decimal point.\n+            if c == '.' {\n+                if dot != s.len() {\n+                    return Err(ParseError(\"String contains multiple dots\"));\n+                }\n+                dot = p;\n+            } else if let Some(hex_value) = c.to_digit(16) {\n+                any_digits = true;\n+\n+                if first_sig_digit.is_none() {\n+                    if hex_value == 0 {\n+                        continue;\n+                    }\n+                    first_sig_digit = Some(p);\n+                }\n+\n+                // Store the number while we have space.\n+                bit_pos -= 4;\n+                if bit_pos >= 0 {\n+                    r.sig[0] |= (hex_value as Limb) << bit_pos;\n+                } else {\n+                    // If zero or one-half (the hexadecimal digit 8) are followed\n+                    // by non-zero, they're a little more than zero or one-half.\n+                    if let Some(ref mut loss) = loss {\n+                        if hex_value != 0 {\n+                            if *loss == Loss::ExactlyZero {\n+                                *loss = Loss::LessThanHalf;\n+                            }\n+                            if *loss == Loss::ExactlyHalf {\n+                                *loss = Loss::MoreThanHalf;\n+                            }\n+                        }\n+                    } else {\n+                        loss = Some(match hex_value {\n+                            0 => Loss::ExactlyZero,\n+                            1...7 => Loss::LessThanHalf,\n+                            8 => Loss::ExactlyHalf,\n+                            9...15 => Loss::MoreThanHalf,\n+                            _ => unreachable!(),\n+                        });\n+                    }\n+                }\n+            } else if c == 'p' || c == 'P' {\n+                if !any_digits {\n+                    return Err(ParseError(\"Significand has no digits\"));\n+                }\n+\n+                if dot == s.len() {\n+                    dot = p;\n+                }\n+\n+                let mut chars = s[p + 1..].chars().peekable();\n+\n+                // Adjust for the given exponent.\n+                let exp_minus = chars.peek() == Some(&'-');\n+                if exp_minus || chars.peek() == Some(&'+') {\n+                    chars.next();\n+                }\n+\n+                for c in chars {\n+                    if let Some(value) = c.to_digit(10) {\n+                        has_exp = true;\n+                        r.exp = r.exp.saturating_mul(10).saturating_add(value as ExpInt);\n+                    } else {\n+                        return Err(ParseError(\"Invalid character in exponent\"));\n+                    }\n+                }\n+                if !has_exp {\n+                    return Err(ParseError(\"Exponent has no digits\"));\n+                }\n+\n+                if exp_minus {\n+                    r.exp = -r.exp;\n+                }\n+\n+                break;\n+            } else {\n+                return Err(ParseError(\"Invalid character in significand\"));\n+            }\n+        }\n+        if !any_digits {\n+            return Err(ParseError(\"Significand has no digits\"));\n+        }\n+\n+        // Hex floats require an exponent but not a hexadecimal point.\n+        if !has_exp {\n+            return Err(ParseError(\"Hex strings require an exponent\"));\n+        }\n+\n+        // Ignore the exponent if we are zero.\n+        let first_sig_digit = match first_sig_digit {\n+            Some(p) => p,\n+            None => return Ok(Status::OK.and(Self::ZERO)),\n+        };\n+\n+        // Calculate the exponent adjustment implicit in the number of\n+        // significant digits and adjust for writing the significand starting\n+        // at the most significant nibble.\n+        let exp_adjustment = if dot > first_sig_digit {\n+            ExpInt::try_from(dot - first_sig_digit).unwrap()\n+        } else {\n+            -ExpInt::try_from(first_sig_digit - dot - 1).unwrap()\n+        };\n+        let exp_adjustment = exp_adjustment\n+            .saturating_mul(4)\n+            .saturating_sub(1)\n+            .saturating_add(S::PRECISION as ExpInt)\n+            .saturating_sub(LIMB_BITS as ExpInt);\n+        r.exp = r.exp.saturating_add(exp_adjustment);\n+\n+        Ok(r.normalize(round, loss.unwrap_or(Loss::ExactlyZero)))\n+    }\n+\n+    fn from_decimal_string(s: &str, round: Round) -> Result<StatusAnd<Self>, ParseError> {\n+        // Given a normal decimal floating point number of the form\n+        //\n+        //   dddd.dddd[eE][+-]ddd\n+        //\n+        // where the decimal point and exponent are optional, fill out the\n+        // variables below. Exponent is appropriate if the significand is\n+        // treated as an integer, and normalized_exp if the significand\n+        // is taken to have the decimal point after a single leading\n+        // non-zero digit.\n+        //\n+        // If the value is zero, first_sig_digit is None.\n+\n+        let mut any_digits = false;\n+        let mut dec_exp = 0i32;\n+\n+        // Without leading or trailing zeros, irrespective of the dot.\n+        let mut first_sig_digit = None;\n+        let mut last_sig_digit = 0;\n+        let mut dot = s.len();\n+\n+        for (p, c) in s.char_indices() {\n+            if c == '.' {\n+                if dot != s.len() {\n+                    return Err(ParseError(\"String contains multiple dots\"));\n+                }\n+                dot = p;\n+            } else if let Some(dec_value) = c.to_digit(10) {\n+                any_digits = true;\n+\n+                if dec_value != 0 {\n+                    if first_sig_digit.is_none() {\n+                        first_sig_digit = Some(p);\n+                    }\n+                    last_sig_digit = p;\n+                }\n+            } else if c == 'e' || c == 'E' {\n+                if !any_digits {\n+                    return Err(ParseError(\"Significand has no digits\"));\n+                }\n+\n+                if dot == s.len() {\n+                    dot = p;\n+                }\n+\n+                let mut chars = s[p + 1..].chars().peekable();\n+\n+                // Adjust for the given exponent.\n+                let exp_minus = chars.peek() == Some(&'-');\n+                if exp_minus || chars.peek() == Some(&'+') {\n+                    chars.next();\n+                }\n+\n+                any_digits = false;\n+                for c in chars {\n+                    if let Some(value) = c.to_digit(10) {\n+                        any_digits = true;\n+                        dec_exp = dec_exp.saturating_mul(10).saturating_add(value as i32);\n+                    } else {\n+                        return Err(ParseError(\"Invalid character in exponent\"));\n+                    }\n+                }\n+                if !any_digits {\n+                    return Err(ParseError(\"Exponent has no digits\"));\n+                }\n+\n+                if exp_minus {\n+                    dec_exp = -dec_exp;\n+                }\n+\n+                break;\n+            } else {\n+                return Err(ParseError(\"Invalid character in significand\"));\n+            }\n+        }\n+        if !any_digits {\n+            return Err(ParseError(\"Significand has no digits\"));\n+        }\n+\n+        // Test if we have a zero number allowing for non-zero exponents.\n+        let first_sig_digit = match first_sig_digit {\n+            Some(p) => p,\n+            None => return Ok(Status::OK.and(Self::ZERO)),\n+        };\n+\n+        // Adjust the exponents for any decimal point.\n+        if dot > last_sig_digit {\n+            dec_exp = dec_exp.saturating_add((dot - last_sig_digit - 1) as i32);\n+        } else {\n+            dec_exp = dec_exp.saturating_sub((last_sig_digit - dot) as i32);\n+        }\n+        let significand_digits = last_sig_digit - first_sig_digit + 1 -\n+            (dot > first_sig_digit && dot < last_sig_digit) as usize;\n+        let normalized_exp = dec_exp.saturating_add(significand_digits as i32 - 1);\n+\n+        // Handle the cases where exponents are obviously too large or too\n+        // small. Writing L for log 10 / log 2, a number d.ddddd*10^dec_exp\n+        // definitely overflows if\n+        //\n+        //       (dec_exp - 1) * L >= MAX_EXP\n+        //\n+        // and definitely underflows to zero where\n+        //\n+        //       (dec_exp + 1) * L <= MIN_EXP - PRECISION\n+        //\n+        // With integer arithmetic the tightest bounds for L are\n+        //\n+        //       93/28 < L < 196/59            [ numerator <= 256 ]\n+        //       42039/12655 < L < 28738/8651  [ numerator <= 65536 ]\n+\n+        // Check for MAX_EXP.\n+        if normalized_exp.saturating_sub(1).saturating_mul(42039) >= 12655 * S::MAX_EXP as i32 {\n+            // Overflow and round.\n+            return Ok(Self::overflow_result(round));\n+        }\n+\n+        // Check for MIN_EXP.\n+        if normalized_exp.saturating_add(1).saturating_mul(28738) <=\n+            8651 * (S::MIN_EXP as i32 - S::PRECISION as i32)\n+        {\n+            // Underflow to zero and round.\n+            let r = if round == Round::TowardPositive {\n+                IeeeFloat::SMALLEST\n+            } else {\n+                IeeeFloat::ZERO\n+            };\n+            return Ok((Status::UNDERFLOW | Status::INEXACT).and(r));\n+        }\n+\n+        // A tight upper bound on number of bits required to hold an\n+        // N-digit decimal integer is N * 196 / 59. Allocate enough space\n+        // to hold the full significand, and an extra limb required by\n+        // tcMultiplyPart.\n+        let max_limbs = limbs_for_bits(1 + 196 * significand_digits / 59);\n+        let mut dec_sig = Vec::with_capacity(max_limbs);\n+\n+        // Convert to binary efficiently - we do almost all multiplication\n+        // in a Limb. When this would overflow do we do a single\n+        // bignum multiplication, and then revert again to multiplication\n+        // in a Limb.\n+        let mut chars = s[first_sig_digit..last_sig_digit + 1].chars();\n+        loop {\n+            let mut val = 0;\n+            let mut multiplier = 1;\n+\n+            loop {\n+                let dec_value = match chars.next() {\n+                    Some('.') => continue,\n+                    Some(c) => c.to_digit(10).unwrap(),\n+                    None => break,\n+                };\n+\n+                multiplier *= 10;\n+                val = val * 10 + dec_value as Limb;\n+\n+                // The maximum number that can be multiplied by ten with any\n+                // digit added without overflowing a Limb.\n+                if multiplier > (!0 - 9) / 10 {\n+                    break;\n+                }\n+            }\n+\n+            // If we've consumed no digits, we're done.\n+            if multiplier == 1 {\n+                break;\n+            }\n+\n+            // Multiply out the current limb.\n+            let mut carry = val;\n+            for x in &mut dec_sig {\n+                let [low, mut high] = sig::widening_mul(*x, multiplier);\n+\n+                // Now add carry.\n+                let (low, overflow) = low.overflowing_add(carry);\n+                high += overflow as Limb;\n+\n+                *x = low;\n+                carry = high;\n+            }\n+\n+            // If we had carry, we need another limb (likely but not guaranteed).\n+            if carry > 0 {\n+                dec_sig.push(carry);\n+            }\n+        }\n+\n+        // Calculate pow(5, abs(dec_exp)) into `pow5_full`.\n+        // The *_calc Vec's are reused scratch space, as an optimization.\n+        let (pow5_full, mut pow5_calc, mut sig_calc, mut sig_scratch_calc) = {\n+            let mut power = dec_exp.abs() as usize;\n+\n+            const FIRST_EIGHT_POWERS: [Limb; 8] = [1, 5, 25, 125, 625, 3125, 15625, 78125];\n+\n+            let mut p5_scratch = vec![];\n+            let mut p5 = vec![FIRST_EIGHT_POWERS[4]];\n+\n+            let mut r_scratch = vec![];\n+            let mut r = vec![FIRST_EIGHT_POWERS[power & 7]];\n+            power >>= 3;\n+\n+            while power > 0 {\n+                // Calculate pow(5,pow(2,n+3)).\n+                p5_scratch.resize(p5.len() * 2, 0);\n+                let _: Loss = sig::mul(&mut p5_scratch, &mut 0, &p5, &p5, p5.len() * 2 * LIMB_BITS);\n+                while p5_scratch.last() == Some(&0) {\n+                    p5_scratch.pop();\n+                }\n+                mem::swap(&mut p5, &mut p5_scratch);\n+\n+                if power & 1 != 0 {\n+                    r_scratch.resize(r.len() + p5.len(), 0);\n+                    let _: Loss = sig::mul(\n+                        &mut r_scratch,\n+                        &mut 0,\n+                        &r,\n+                        &p5,\n+                        (r.len() + p5.len()) * LIMB_BITS,\n+                    );\n+                    while r_scratch.last() == Some(&0) {\n+                        r_scratch.pop();\n+                    }\n+                    mem::swap(&mut r, &mut r_scratch);\n+                }\n+\n+                power >>= 1;\n+            }\n+\n+            (r, r_scratch, p5, p5_scratch)\n+        };\n+\n+        // Attempt dec_sig * 10^dec_exp with increasing precision.\n+        let mut attempt = 1;\n+        loop {\n+            let calc_precision = (LIMB_BITS << attempt) - 1;\n+            attempt += 1;\n+\n+            let calc_normal_from_limbs = |sig: &mut Vec<Limb>,\n+                                          limbs: &[Limb]|\n+             -> StatusAnd<ExpInt> {\n+                sig.resize(limbs_for_bits(calc_precision), 0);\n+                let (mut loss, mut exp) = sig::from_limbs(sig, limbs, calc_precision);\n+\n+                // Before rounding normalize the exponent of Category::Normal numbers.\n+                let mut omsb = sig::omsb(sig);\n+\n+                assert_ne!(omsb, 0);\n+\n+                // OMSB is numbered from 1. We want to place it in the integer\n+                // bit numbered PRECISION if possible, with a compensating change in\n+                // the exponent.\n+                let final_exp = exp.saturating_add(omsb as ExpInt - calc_precision as ExpInt);\n+\n+                // Shifting left is easy as we don't lose precision.\n+                if final_exp < exp {\n+                    assert_eq!(loss, Loss::ExactlyZero);\n+\n+                    let exp_change = (exp - final_exp) as usize;\n+                    sig::shift_left(sig, &mut exp, exp_change);\n+\n+                    return Status::OK.and(exp);\n+                }\n+\n+                // Shift right and capture any new lost fraction.\n+                if final_exp > exp {\n+                    let exp_change = (final_exp - exp) as usize;\n+                    loss = sig::shift_right(sig, &mut exp, exp_change).combine(loss);\n+\n+                    // Keep OMSB up-to-date.\n+                    omsb = omsb.saturating_sub(exp_change);\n+                }\n+\n+                assert_eq!(omsb, calc_precision);\n+\n+                // Now round the number according to round given the lost\n+                // fraction.\n+\n+                // As specified in IEEE 754, since we do not trap we do not report\n+                // underflow for exact results.\n+                if loss == Loss::ExactlyZero {\n+                    return Status::OK.and(exp);\n+                }\n+\n+                // Increment the significand if we're rounding away from zero.\n+                if loss == Loss::MoreThanHalf || loss == Loss::ExactlyHalf && sig::get_bit(sig, 0) {\n+                    // We should never overflow.\n+                    assert_eq!(sig::increment(sig), 0);\n+                    omsb = sig::omsb(sig);\n+\n+                    // Did the significand increment overflow?\n+                    if omsb == calc_precision + 1 {\n+                        let _: Loss = sig::shift_right(sig, &mut exp, 1);\n+\n+                        return Status::INEXACT.and(exp);\n+                    }\n+                }\n+\n+                // The normal case - we were and are not denormal, and any\n+                // significand increment above didn't overflow.\n+                Status::INEXACT.and(exp)\n+            };\n+\n+            let status;\n+            let mut exp = unpack!(status=,\n+                calc_normal_from_limbs(&mut sig_calc, &dec_sig));\n+            let pow5_status;\n+            let pow5_exp = unpack!(pow5_status=,\n+                calc_normal_from_limbs(&mut pow5_calc, &pow5_full));\n+\n+            // Add dec_exp, as 10^n = 5^n * 2^n.\n+            exp += dec_exp as ExpInt;\n+\n+            let mut used_bits = S::PRECISION;\n+            let mut truncated_bits = calc_precision - used_bits;\n+\n+            let half_ulp_err1 = (status != Status::OK) as Limb;\n+            let (calc_loss, half_ulp_err2);\n+            if dec_exp >= 0 {\n+                exp += pow5_exp;\n+\n+                sig_scratch_calc.resize(sig_calc.len() + pow5_calc.len(), 0);\n+                calc_loss = sig::mul(\n+                    &mut sig_scratch_calc,\n+                    &mut exp,\n+                    &sig_calc,\n+                    &pow5_calc,\n+                    calc_precision,\n+                );\n+                mem::swap(&mut sig_calc, &mut sig_scratch_calc);\n+\n+                half_ulp_err2 = (pow5_status != Status::OK) as Limb;\n+            } else {\n+                exp -= pow5_exp;\n+\n+                sig_scratch_calc.resize(sig_calc.len(), 0);\n+                calc_loss = sig::div(\n+                    &mut sig_scratch_calc,\n+                    &mut exp,\n+                    &mut sig_calc,\n+                    &mut pow5_calc,\n+                    calc_precision,\n+                );\n+                mem::swap(&mut sig_calc, &mut sig_scratch_calc);\n+\n+                // Denormal numbers have less precision.\n+                if exp < S::MIN_EXP {\n+                    truncated_bits += (S::MIN_EXP - exp) as usize;\n+                    used_bits = calc_precision.saturating_sub(truncated_bits);\n+                }\n+                // Extra half-ulp lost in reciprocal of exponent.\n+                half_ulp_err2 = 2 *\n+                    (pow5_status != Status::OK || calc_loss != Loss::ExactlyZero) as Limb;\n+            }\n+\n+            // Both sig::mul and sig::div return the\n+            // result with the integer bit set.\n+            assert!(sig::get_bit(&sig_calc, calc_precision - 1));\n+\n+            // The error from the true value, in half-ulps, on multiplying two\n+            // floating point numbers, which differ from the value they\n+            // approximate by at most half_ulp_err1 and half_ulp_err2 half-ulps, is strictly less\n+            // than the returned value.\n+            //\n+            // See \"How to Read Floating Point Numbers Accurately\" by William D Clinger.\n+            assert!(\n+                half_ulp_err1 < 2 || half_ulp_err2 < 2 || (half_ulp_err1 + half_ulp_err2 < 8)\n+            );\n+\n+            let inexact = (calc_loss != Loss::ExactlyZero) as Limb;\n+            let half_ulp_err = if half_ulp_err1 + half_ulp_err2 == 0 {\n+                inexact * 2 // <= inexact half-ulps.\n+            } else {\n+                inexact + 2 * (half_ulp_err1 + half_ulp_err2)\n+            };\n+\n+            let ulps_from_boundary = {\n+                let bits = calc_precision - used_bits - 1;\n+\n+                let i = bits / LIMB_BITS;\n+                let limb = sig_calc[i] & (!0 >> (LIMB_BITS - 1 - bits % LIMB_BITS));\n+                let boundary = match round {\n+                    Round::NearestTiesToEven | Round::NearestTiesToAway => 1 << (bits % LIMB_BITS),\n+                    _ => 0,\n+                };\n+                if i == 0 {\n+                    let delta = limb.wrapping_sub(boundary);\n+                    cmp::min(delta, delta.wrapping_neg())\n+                } else if limb == boundary {\n+                    if !sig::is_all_zeros(&sig_calc[1..i]) {\n+                        !0 // A lot.\n+                    } else {\n+                        sig_calc[0]\n+                    }\n+                } else if limb == boundary.wrapping_sub(1) {\n+                    if sig_calc[1..i].iter().any(|&x| x.wrapping_neg() != 1) {\n+                        !0 // A lot.\n+                    } else {\n+                        sig_calc[0].wrapping_neg()\n+                    }\n+                } else {\n+                    !0 // A lot.\n+                }\n+            };\n+\n+            // Are we guaranteed to round correctly if we truncate?\n+            if ulps_from_boundary.saturating_mul(2) >= half_ulp_err {\n+                let mut r = IeeeFloat {\n+                    sig: [0],\n+                    exp,\n+                    category: Category::Normal,\n+                    sign: false,\n+                    marker: PhantomData,\n+                };\n+                sig::extract(&mut r.sig, &sig_calc, used_bits, calc_precision - used_bits);\n+                // If we extracted less bits above we must adjust our exponent\n+                // to compensate for the implicit right shift.\n+                r.exp += (S::PRECISION - used_bits) as ExpInt;\n+                let loss = Loss::through_truncation(&sig_calc, truncated_bits);\n+                return Ok(r.normalize(round, loss));\n+            }\n+        }\n+    }\n+}\n+\n+impl Loss {\n+    /// Combine the effect of two lost fractions.\n+    fn combine(self, less_significant: Loss) -> Loss {\n+        let mut more_significant = self;\n+        if less_significant != Loss::ExactlyZero {\n+            if more_significant == Loss::ExactlyZero {\n+                more_significant = Loss::LessThanHalf;\n+            } else if more_significant == Loss::ExactlyHalf {\n+                more_significant = Loss::MoreThanHalf;\n+            }\n+        }\n+\n+        more_significant\n+    }\n+\n+    /// Return the fraction lost were a bignum truncated losing the least\n+    /// significant `bits` bits.\n+    fn through_truncation(limbs: &[Limb], bits: usize) -> Loss {\n+        if bits == 0 {\n+            return Loss::ExactlyZero;\n+        }\n+\n+        let half_bit = bits - 1;\n+        let half_limb = half_bit / LIMB_BITS;\n+        let (half_limb, rest) = if half_limb < limbs.len() {\n+            (limbs[half_limb], &limbs[..half_limb])\n+        } else {\n+            (0, limbs)\n+        };\n+        let half = 1 << (half_bit % LIMB_BITS);\n+        let has_half = half_limb & half != 0;\n+        let has_rest = half_limb & (half - 1) != 0 || !sig::is_all_zeros(rest);\n+\n+        match (has_half, has_rest) {\n+            (false, false) => Loss::ExactlyZero,\n+            (false, true) => Loss::LessThanHalf,\n+            (true, false) => Loss::ExactlyHalf,\n+            (true, true) => Loss::MoreThanHalf,\n+        }\n+    }\n+}\n+\n+/// Implementation details of IeeeFloat significands, such as big integer arithmetic.\n+/// As a rule of thumb, no functions in this module should dynamically allocate.\n+mod sig {\n+    use std::cmp::Ordering;\n+    use std::mem;\n+    use super::{ExpInt, Limb, LIMB_BITS, limbs_for_bits, Loss};\n+\n+    pub(super) fn is_all_zeros(limbs: &[Limb]) -> bool {\n+        limbs.iter().all(|&l| l == 0)\n+    }\n+\n+    /// One, not zero, based MSB. That is, returns 0 for a zeroed significand.\n+    pub(super) fn omsb(limbs: &[Limb]) -> usize {\n+        for i in (0..limbs.len()).rev() {\n+            if limbs[i] != 0 {\n+                return (i + 1) * LIMB_BITS - limbs[i].leading_zeros() as usize;\n+            }\n+        }\n+\n+        0\n+    }\n+\n+    /// Comparison (unsigned) of two significands.\n+    pub(super) fn cmp(a: &[Limb], b: &[Limb]) -> Ordering {\n+        assert_eq!(a.len(), b.len());\n+        for (a, b) in a.iter().zip(b).rev() {\n+            match a.cmp(b) {\n+                Ordering::Equal => {}\n+                o => return o,\n+            }\n+        }\n+\n+        Ordering::Equal\n+    }\n+\n+    /// Extract the given bit.\n+    pub(super) fn get_bit(limbs: &[Limb], bit: usize) -> bool {\n+        limbs[bit / LIMB_BITS] & (1 << (bit % LIMB_BITS)) != 0\n+    }\n+\n+    /// Set the given bit.\n+    pub(super) fn set_bit(limbs: &mut [Limb], bit: usize) {\n+        limbs[bit / LIMB_BITS] |= 1 << (bit % LIMB_BITS);\n+    }\n+\n+    /// Clear the given bit.\n+    pub(super) fn clear_bit(limbs: &mut [Limb], bit: usize) {\n+        limbs[bit / LIMB_BITS] &= !(1 << (bit % LIMB_BITS));\n+    }\n+\n+    /// Shift `dst` left `bits` bits, subtract `bits` from its exponent.\n+    pub(super) fn shift_left(dst: &mut [Limb], exp: &mut ExpInt, bits: usize) {\n+        if bits > 0 {\n+            // Our exponent should not underflow.\n+            *exp = exp.checked_sub(bits as ExpInt).unwrap();\n+\n+            // Jump is the inter-limb jump; shift is is intra-limb shift.\n+            let jump = bits / LIMB_BITS;\n+            let shift = bits % LIMB_BITS;\n+\n+            for i in (0..dst.len()).rev() {\n+                let mut limb;\n+\n+                if i < jump {\n+                    limb = 0;\n+                } else {\n+                    // dst[i] comes from the two limbs src[i - jump] and, if we have\n+                    // an intra-limb shift, src[i - jump - 1].\n+                    limb = dst[i - jump];\n+                    if shift > 0 {\n+                        limb <<= shift;\n+                        if i >= jump + 1 {\n+                            limb |= dst[i - jump - 1] >> (LIMB_BITS - shift);\n+                        }\n+                    }\n+                }\n+\n+                dst[i] = limb;\n+            }\n+        }\n+    }\n+\n+    /// Shift `dst` right `bits` bits noting lost fraction.\n+    pub(super) fn shift_right(dst: &mut [Limb], exp: &mut ExpInt, bits: usize) -> Loss {\n+        let loss = Loss::through_truncation(dst, bits);\n+\n+        if bits > 0 {\n+            // Our exponent should not overflow.\n+            *exp = exp.checked_add(bits as ExpInt).unwrap();\n+\n+            // Jump is the inter-limb jump; shift is is intra-limb shift.\n+            let jump = bits / LIMB_BITS;\n+            let shift = bits % LIMB_BITS;\n+\n+            // Perform the shift. This leaves the most significant `bits` bits\n+            // of the result at zero.\n+            for i in 0..dst.len() {\n+                let mut limb;\n+\n+                if i + jump >= dst.len() {\n+                    limb = 0;\n+                } else {\n+                    limb = dst[i + jump];\n+                    if shift > 0 {\n+                        limb >>= shift;\n+                        if i + jump + 1 < dst.len() {\n+                            limb |= dst[i + jump + 1] << (LIMB_BITS - shift);\n+                        }\n+                    }\n+                }\n+\n+                dst[i] = limb;\n+            }\n+        }\n+\n+        loss\n+    }\n+\n+    /// Copy the bit vector of width `src_bits` from `src`, starting at bit SRC_LSB,\n+    /// to `dst`, such that the bit SRC_LSB becomes the least significant bit of `dst`.\n+    /// All high bits above `src_bits` in `dst` are zero-filled.\n+    pub(super) fn extract(dst: &mut [Limb], src: &[Limb], src_bits: usize, src_lsb: usize) {\n+        if src_bits == 0 {\n+            return;\n+        }\n+\n+        let dst_limbs = limbs_for_bits(src_bits);\n+        assert!(dst_limbs <= dst.len());\n+\n+        let src = &src[src_lsb / LIMB_BITS..];\n+        dst[..dst_limbs].copy_from_slice(&src[..dst_limbs]);\n+\n+        let shift = src_lsb % LIMB_BITS;\n+        let _: Loss = shift_right(&mut dst[..dst_limbs], &mut 0, shift);\n+\n+        // We now have (dst_limbs * LIMB_BITS - shift) bits from `src`\n+        // in `dst`.  If this is less that src_bits, append the rest, else\n+        // clear the high bits.\n+        let n = dst_limbs * LIMB_BITS - shift;\n+        if n < src_bits {\n+            let mask = (1 << (src_bits - n)) - 1;\n+            dst[dst_limbs - 1] |= (src[dst_limbs] & mask) << n % LIMB_BITS;\n+        } else if n > src_bits && src_bits % LIMB_BITS > 0 {\n+            dst[dst_limbs - 1] &= (1 << (src_bits % LIMB_BITS)) - 1;\n+        }\n+\n+        // Clear high limbs.\n+        for x in &mut dst[dst_limbs..] {\n+            *x = 0;\n+        }\n+    }\n+\n+    /// We want the most significant PRECISION bits of `src`. There may not\n+    /// be that many; extract what we can.\n+    pub(super) fn from_limbs(dst: &mut [Limb], src: &[Limb], precision: usize) -> (Loss, ExpInt) {\n+        let omsb = omsb(src);\n+\n+        if precision <= omsb {\n+            extract(dst, src, precision, omsb - precision);\n+            (\n+                Loss::through_truncation(src, omsb - precision),\n+                omsb as ExpInt - 1,\n+            )\n+        } else {\n+            extract(dst, src, omsb, 0);\n+            (Loss::ExactlyZero, precision as ExpInt - 1)\n+        }\n+    }\n+\n+    /// Increment in-place, return the carry flag.\n+    pub(super) fn increment(dst: &mut [Limb]) -> Limb {\n+        for x in dst {\n+            *x = x.wrapping_add(1);\n+            if *x != 0 {\n+                return 0;\n+            }\n+        }\n+\n+        1\n+    }\n+\n+    /// Decrement in-place, return the borrow flag.\n+    pub(super) fn decrement(dst: &mut [Limb]) -> Limb {\n+        for x in dst {\n+            *x = x.wrapping_sub(1);\n+            if *x != !0 {\n+                return 0;\n+            }\n+        }\n+\n+        1\n+    }\n+\n+    /// `a += b + c` where `c` is zero or one. Returns the carry flag.\n+    pub(super) fn add(a: &mut [Limb], b: &[Limb], mut c: Limb) -> Limb {\n+        assert!(c <= 1);\n+\n+        for (a, &b) in a.iter_mut().zip(b) {\n+            let (r, overflow) = a.overflowing_add(b);\n+            let (r, overflow2) = r.overflowing_add(c);\n+            *a = r;\n+            c = (overflow | overflow2) as Limb;\n+        }\n+\n+        c\n+    }\n+\n+    /// `a -= b + c` where `c` is zero or one. Returns the borrow flag.\n+    pub(super) fn sub(a: &mut [Limb], b: &[Limb], mut c: Limb) -> Limb {\n+        assert!(c <= 1);\n+\n+        for (a, &b) in a.iter_mut().zip(b) {\n+            let (r, overflow) = a.overflowing_sub(b);\n+            let (r, overflow2) = r.overflowing_sub(c);\n+            *a = r;\n+            c = (overflow | overflow2) as Limb;\n+        }\n+\n+        c\n+    }\n+\n+    /// `a += b` or `a -= b`. Does not preserve `b`.\n+    pub(super) fn add_or_sub(\n+        a_sig: &mut [Limb],\n+        a_exp: &mut ExpInt,\n+        a_sign: &mut bool,\n+        b_sig: &mut [Limb],\n+        b_exp: ExpInt,\n+        b_sign: bool,\n+    ) -> Loss {\n+        // Are we bigger exponent-wise than the RHS?\n+        let bits = *a_exp - b_exp;\n+\n+        // Determine if the operation on the absolute values is effectively\n+        // an addition or subtraction.\n+        // Subtraction is more subtle than one might naively expect.\n+        if *a_sign ^ b_sign {\n+            let (reverse, loss);\n+\n+            if bits == 0 {\n+                reverse = cmp(a_sig, b_sig) == Ordering::Less;\n+                loss = Loss::ExactlyZero;\n+            } else if bits > 0 {\n+                loss = shift_right(b_sig, &mut 0, (bits - 1) as usize);\n+                shift_left(a_sig, a_exp, 1);\n+                reverse = false;\n+            } else {\n+                loss = shift_right(a_sig, a_exp, (-bits - 1) as usize);\n+                shift_left(b_sig, &mut 0, 1);\n+                reverse = true;\n+            }\n+\n+            let borrow = (loss != Loss::ExactlyZero) as Limb;\n+            if reverse {\n+                // The code above is intended to ensure that no borrow is necessary.\n+                assert_eq!(sub(b_sig, a_sig, borrow), 0);\n+                a_sig.copy_from_slice(b_sig);\n+                *a_sign = !*a_sign;\n+            } else {\n+                // The code above is intended to ensure that no borrow is necessary.\n+                assert_eq!(sub(a_sig, b_sig, borrow), 0);\n+            }\n+\n+            // Invert the lost fraction - it was on the RHS and subtracted.\n+            match loss {\n+                Loss::LessThanHalf => Loss::MoreThanHalf,\n+                Loss::MoreThanHalf => Loss::LessThanHalf,\n+                _ => loss,\n+            }\n+        } else {\n+            let loss = if bits > 0 {\n+                shift_right(b_sig, &mut 0, bits as usize)\n+            } else {\n+                shift_right(a_sig, a_exp, -bits as usize)\n+            };\n+            // We have a guard bit; generating a carry cannot happen.\n+            assert_eq!(add(a_sig, b_sig, 0), 0);\n+            loss\n+        }\n+    }\n+\n+    /// `[low, high] = a * b`.\n+    ///\n+    /// This cannot overflow, because\n+    ///\n+    /// `(n - 1) * (n - 1) + 2 * (n - 1) == (n - 1) * (n + 1)`\n+    ///\n+    /// which is less than n^2.\n+    pub(super) fn widening_mul(a: Limb, b: Limb) -> [Limb; 2] {\n+        let mut wide = [0, 0];\n+\n+        if a == 0 || b == 0 {\n+            return wide;\n+        }\n+\n+        const HALF_BITS: usize = LIMB_BITS / 2;\n+\n+        let select = |limb, i| (limb >> (i * HALF_BITS)) & ((1 << HALF_BITS) - 1);\n+        for i in 0..2 {\n+            for j in 0..2 {\n+                let mut x = [select(a, i) * select(b, j), 0];\n+                shift_left(&mut x, &mut 0, (i + j) * HALF_BITS);\n+                assert_eq!(add(&mut wide, &x, 0), 0);\n+            }\n+        }\n+\n+        wide\n+    }\n+\n+    /// `dst = a * b` (for normal `a` and `b`). Returns the lost fraction.\n+    pub(super) fn mul<'a>(\n+        dst: &mut [Limb],\n+        exp: &mut ExpInt,\n+        mut a: &'a [Limb],\n+        mut b: &'a [Limb],\n+        precision: usize,\n+    ) -> Loss {\n+        // Put the narrower number on the `a` for less loops below.\n+        if a.len() > b.len() {\n+            mem::swap(&mut a, &mut b);\n+        }\n+\n+        for x in &mut dst[..b.len()] {\n+            *x = 0;\n+        }\n+\n+        for i in 0..a.len() {\n+            let mut carry = 0;\n+            for j in 0..b.len() {\n+                let [low, mut high] = widening_mul(a[i], b[j]);\n+\n+                // Now add carry.\n+                let (low, overflow) = low.overflowing_add(carry);\n+                high += overflow as Limb;\n+\n+                // And now `dst[i + j]`, and store the new low part there.\n+                let (low, overflow) = low.overflowing_add(dst[i + j]);\n+                high += overflow as Limb;\n+\n+                dst[i + j] = low;\n+                carry = high;\n+            }\n+            dst[i + b.len()] = carry;\n+        }\n+\n+        // Assume the operands involved in the multiplication are single-precision\n+        // FP, and the two multiplicants are:\n+        //     a = a23 . a22 ... a0 * 2^e1\n+        //     b = b23 . b22 ... b0 * 2^e2\n+        // the result of multiplication is:\n+        //     dst = c48 c47 c46 . c45 ... c0 * 2^(e1+e2)\n+        // Note that there are three significant bits at the left-hand side of the\n+        // radix point: two for the multiplication, and an overflow bit for the\n+        // addition (that will always be zero at this point). Move the radix point\n+        // toward left by two bits, and adjust exponent accordingly.\n+        *exp += 2;\n+\n+        // Convert the result having \"2 * precision\" significant-bits back to the one\n+        // having \"precision\" significant-bits. First, move the radix point from\n+        // poision \"2*precision - 1\" to \"precision - 1\". The exponent need to be\n+        // adjusted by \"2*precision - 1\" - \"precision - 1\" = \"precision\".\n+        *exp -= precision as ExpInt + 1;\n+\n+        // In case MSB resides at the left-hand side of radix point, shift the\n+        // mantissa right by some amount to make sure the MSB reside right before\n+        // the radix point (i.e. \"MSB . rest-significant-bits\").\n+        //\n+        // Note that the result is not normalized when \"omsb < precision\". So, the\n+        // caller needs to call IeeeFloat::normalize() if normalized value is\n+        // expected.\n+        let omsb = omsb(dst);\n+        if omsb <= precision {\n+            Loss::ExactlyZero\n+        } else {\n+            shift_right(dst, exp, omsb - precision)\n+        }\n+    }\n+\n+    /// `quotient = dividend / divisor`. Returns the lost fraction.\n+    /// Does not preserve `dividend` or `divisor`.\n+    pub(super) fn div(\n+        quotient: &mut [Limb],\n+        exp: &mut ExpInt,\n+        dividend: &mut [Limb],\n+        divisor: &mut [Limb],\n+        precision: usize,\n+    ) -> Loss {\n+        // Zero the quotient before setting bits in it.\n+        for x in &mut quotient[..limbs_for_bits(precision)] {\n+            *x = 0;\n+        }\n+\n+        // Normalize the divisor.\n+        let bits = precision - omsb(divisor);\n+        shift_left(divisor, &mut 0, bits);\n+        *exp += bits as ExpInt;\n+\n+        // Normalize the dividend.\n+        let bits = precision - omsb(dividend);\n+        shift_left(dividend, exp, bits);\n+\n+        // Ensure the dividend >= divisor initially for the loop below.\n+        // Incidentally, this means that the division loop below is\n+        // guaranteed to set the integer bit to one.\n+        if cmp(dividend, divisor) == Ordering::Less {\n+            shift_left(dividend, exp, 1);\n+            assert_ne!(cmp(dividend, divisor), Ordering::Less)\n+        }\n+\n+        // Long division.\n+        for bit in (0..precision).rev() {\n+            if cmp(dividend, divisor) != Ordering::Less {\n+                sub(dividend, divisor, 0);\n+                set_bit(quotient, bit);\n+            }\n+            shift_left(dividend, &mut 0, 1);\n+        }\n+\n+        // Figure out the lost fraction.\n+        match cmp(dividend, divisor) {\n+            Ordering::Greater => Loss::MoreThanHalf,\n+            Ordering::Equal => Loss::ExactlyHalf,\n+            Ordering::Less => {\n+                if is_all_zeros(dividend) {\n+                    Loss::ExactlyZero\n+                } else {\n+                    Loss::LessThanHalf\n+                }\n+            }\n+        }\n     }\n }"}, {"sha": "d9dbf787856520f2d508c1fa870898f6f2093325", "filename": "src/librustc_apfloat/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1409d205ad030743007d819374c6b3efa3570f64/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1409d205ad030743007d819374c6b3efa3570f64/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=1409d205ad030743007d819374c6b3efa3570f64", "patch": "@@ -48,6 +48,8 @@\n \n #![feature(const_fn)]\n #![feature(i128_type)]\n+#![feature(slice_patterns)]\n+#![feature(try_from)]\n \n #[macro_use]\n extern crate rustc_bitflags;"}, {"sha": "dec88eb62cc60ef94eecf6a5517544c35951dd08", "filename": "src/librustc_apfloat/ppc.rs", "status": "modified", "additions": 309, "deletions": 35, "changes": 344, "blob_url": "https://github.com/rust-lang/rust/blob/1409d205ad030743007d819374c6b3efa3570f64/src%2Flibrustc_apfloat%2Fppc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1409d205ad030743007d819374c6b3efa3570f64/src%2Flibrustc_apfloat%2Fppc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fppc.rs?ref=1409d205ad030743007d819374c6b3efa3570f64", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use {ieee, Category, ExpInt, Float, Round, ParseError, StatusAnd};\n+use {Category, ExpInt, Float, FloatConvert, Round, ParseError, Status, StatusAnd};\n+use ieee;\n \n use std::cmp::Ordering;\n use std::fmt;\n@@ -49,24 +50,99 @@ impl<F: Float> ieee::Semantics for FallbackS<F> {\n     const MIN_EXP: ExpInt = F::MIN_EXP as ExpInt + F::PRECISION as ExpInt;\n }\n \n+// Convert number to F. To avoid spurious underflows, we re-\n+// normalize against the F exponent range first, and only *then*\n+// truncate the mantissa. The result of that second conversion\n+// may be inexact, but should never underflow.\n+// FIXME(eddyb) This shouldn't need to be `pub`, it's only used in bounds.\n+pub struct FallbackExtendedS<F>(F);\n+type FallbackExtended<F> = ieee::IeeeFloat<FallbackExtendedS<F>>;\n+impl<F: Float> ieee::Semantics for FallbackExtendedS<F> {\n+    // Forbid any conversion to/from bits.\n+    const BITS: usize = 0;\n+    const PRECISION: usize = Fallback::<F>::PRECISION;\n+    const MAX_EXP: ExpInt = F::MAX_EXP as ExpInt;\n+}\n+\n+impl<F: Float> From<Fallback<F>> for DoubleFloat<F>\n+where\n+    F: FloatConvert<FallbackExtended<F>>,\n+    FallbackExtended<F>: FloatConvert<F>,\n+{\n+    fn from(x: Fallback<F>) -> Self {\n+        let mut status;\n+        let mut loses_info = false;\n+\n+        let extended: FallbackExtended<F> = unpack!(status=, x.convert(&mut loses_info));\n+        assert_eq!((status, loses_info), (Status::OK, false));\n+\n+        let a = unpack!(status=, extended.convert(&mut loses_info));\n+        assert_eq!(status - Status::INEXACT, Status::OK);\n+\n+        // If conversion was exact or resulted in a special case, we're done;\n+        // just set the second double to zero. Otherwise, re-convert back to\n+        // the extended format and compute the difference. This now should\n+        // convert exactly to double.\n+        let b = if a.is_finite_non_zero() && loses_info {\n+            let u: FallbackExtended<F> = unpack!(status=, a.convert(&mut loses_info));\n+            assert_eq!((status, loses_info), (Status::OK, false));\n+            let v = unpack!(status=, extended - u);\n+            assert_eq!(status, Status::OK);\n+            let v = unpack!(status=, v.convert(&mut loses_info));\n+            assert_eq!((status, loses_info), (Status::OK, false));\n+            v\n+        } else {\n+            F::ZERO\n+        };\n+\n+        DoubleFloat(a, b)\n+    }\n+}\n+\n+impl<F: FloatConvert<Self>> From<DoubleFloat<F>> for Fallback<F> {\n+    fn from(DoubleFloat(a, b): DoubleFloat<F>) -> Self {\n+        let mut status;\n+        let mut loses_info = false;\n+\n+        // Get the first F and convert to our format.\n+        let a = unpack!(status=, a.convert(&mut loses_info));\n+        assert_eq!((status, loses_info), (Status::OK, false));\n+\n+        // Unless we have a special case, add in second F.\n+        if a.is_finite_non_zero() {\n+            let b = unpack!(status=, b.convert(&mut loses_info));\n+            assert_eq!((status, loses_info), (Status::OK, false));\n+\n+            (a + b).value\n+        } else {\n+            a\n+        }\n+    }\n+}\n+\n float_common_impls!(DoubleFloat<F>);\n \n impl<F: Float> Neg for DoubleFloat<F> {\n     type Output = Self;\n     fn neg(self) -> Self {\n-        panic!(\"NYI Neg::neg\");\n+        if self.1.is_finite_non_zero() {\n+            DoubleFloat(-self.0, -self.1)\n+        } else {\n+            DoubleFloat(-self.0, self.1)\n+        }\n     }\n }\n \n-#[allow(unused)]\n-impl<F: Float> fmt::Display for DoubleFloat<F> {\n+impl<F: FloatConvert<Fallback<F>>> fmt::Display for DoubleFloat<F> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        panic!(\"NYI Display::fmt\");\n+        fmt::Display::fmt(&Fallback::from(*self), f)\n     }\n }\n \n-#[allow(unused)]\n-impl<F: Float> Float for DoubleFloat<F> {\n+impl<F: FloatConvert<Fallback<F>>> Float for DoubleFloat<F>\n+where\n+    Self: From<Fallback<F>>,\n+{\n     const BITS: usize = F::BITS * 2;\n     const PRECISION: usize = Fallback::<F>::PRECISION;\n     const MAX_EXP: ExpInt = Fallback::<F>::MAX_EXP;\n@@ -80,108 +156,306 @@ impl<F: Float> Float for DoubleFloat<F> {\n     const NAN: Self = DoubleFloat(F::NAN, F::ZERO);\n \n     fn qnan(payload: Option<u128>) -> Self {\n-        panic!(\"NYI qnan\")\n+        DoubleFloat(F::qnan(payload), F::ZERO)\n     }\n \n     fn snan(payload: Option<u128>) -> Self {\n-        panic!(\"NYI snan\")\n+        DoubleFloat(F::snan(payload), F::ZERO)\n     }\n \n     fn largest() -> Self {\n-        panic!(\"NYI largest\")\n+        let status;\n+        let mut r = DoubleFloat(F::largest(), F::largest());\n+        r.1 = r.1.scalbn(-(F::PRECISION as ExpInt + 1));\n+        r.1 = unpack!(status=, r.1.next_down());\n+        assert_eq!(status, Status::OK);\n+        r\n     }\n \n     const SMALLEST: Self = DoubleFloat(F::SMALLEST, F::ZERO);\n \n     fn smallest_normalized() -> Self {\n-        panic!(\"NYI smallest_normalized\")\n+        DoubleFloat(\n+            F::smallest_normalized().scalbn(F::PRECISION as ExpInt),\n+            F::ZERO,\n+        )\n     }\n \n-    fn add_r(self, rhs: Self, round: Round) -> StatusAnd<Self> {\n-        panic!(\"NYI add_r\")\n+    // Implement addition, subtraction, multiplication and division based on:\n+    // \"Software for Doubled-Precision Floating-Point Computations\",\n+    // by Seppo Linnainmaa, ACM TOMS vol 7 no 3, September 1981, pages 272-283.\n+\n+    fn add_r(mut self, rhs: Self, round: Round) -> StatusAnd<Self> {\n+        match (self.category(), rhs.category()) {\n+            (Category::Infinity, Category::Infinity) => {\n+                if self.is_negative() != rhs.is_negative() {\n+                    Status::INVALID_OP.and(Self::NAN.copy_sign(self))\n+                } else {\n+                    Status::OK.and(self)\n+                }\n+            }\n+\n+            (_, Category::Zero) |\n+            (Category::NaN, _) |\n+            (Category::Infinity, Category::Normal) => Status::OK.and(self),\n+\n+            (Category::Zero, _) |\n+            (_, Category::NaN) |\n+            (_, Category::Infinity) => Status::OK.and(rhs),\n+\n+            (Category::Normal, Category::Normal) => {\n+                let mut status = Status::OK;\n+                let (a, aa, c, cc) = (self.0, self.1, rhs.0, rhs.1);\n+                let mut z = a;\n+                z = unpack!(status|=, z.add_r(c, round));\n+                if !z.is_finite() {\n+                    if !z.is_infinite() {\n+                        return status.and(DoubleFloat(z, F::ZERO));\n+                    }\n+                    status = Status::OK;\n+                    let a_cmp_c = a.cmp_abs_normal(c);\n+                    z = cc;\n+                    z = unpack!(status|=, z.add_r(aa, round));\n+                    if a_cmp_c == Ordering::Greater {\n+                        // z = cc + aa + c + a;\n+                        z = unpack!(status|=, z.add_r(c, round));\n+                        z = unpack!(status|=, z.add_r(a, round));\n+                    } else {\n+                        // z = cc + aa + a + c;\n+                        z = unpack!(status|=, z.add_r(a, round));\n+                        z = unpack!(status|=, z.add_r(c, round));\n+                    }\n+                    if !z.is_finite() {\n+                        return status.and(DoubleFloat(z, F::ZERO));\n+                    }\n+                    self.0 = z;\n+                    let mut zz = aa;\n+                    zz = unpack!(status|=, zz.add_r(cc, round));\n+                    if a_cmp_c == Ordering::Greater {\n+                        // self.1 = a - z + c + zz;\n+                        self.1 = a;\n+                        self.1 = unpack!(status|=, self.1.sub_r(z, round));\n+                        self.1 = unpack!(status|=, self.1.add_r(c, round));\n+                        self.1 = unpack!(status|=, self.1.add_r(zz, round));\n+                    } else {\n+                        // self.1 = c - z + a + zz;\n+                        self.1 = c;\n+                        self.1 = unpack!(status|=, self.1.sub_r(z, round));\n+                        self.1 = unpack!(status|=, self.1.add_r(a, round));\n+                        self.1 = unpack!(status|=, self.1.add_r(zz, round));\n+                    }\n+                } else {\n+                    // q = a - z;\n+                    let mut q = a;\n+                    q = unpack!(status|=, q.sub_r(z, round));\n+\n+                    // zz = q + c + (a - (q + z)) + aa + cc;\n+                    // Compute a - (q + z) as -((q + z) - a) to avoid temporary copies.\n+                    let mut zz = q;\n+                    zz = unpack!(status|=, zz.add_r(c, round));\n+                    q = unpack!(status|=, q.add_r(z, round));\n+                    q = unpack!(status|=, q.sub_r(a, round));\n+                    q = -q;\n+                    zz = unpack!(status|=, zz.add_r(q, round));\n+                    zz = unpack!(status|=, zz.add_r(aa, round));\n+                    zz = unpack!(status|=, zz.add_r(cc, round));\n+                    if zz.is_zero() && !zz.is_negative() {\n+                        return Status::OK.and(DoubleFloat(z, F::ZERO));\n+                    }\n+                    self.0 = z;\n+                    self.0 = unpack!(status|=, self.0.add_r(zz, round));\n+                    if !self.0.is_finite() {\n+                        self.1 = F::ZERO;\n+                        return status.and(self);\n+                    }\n+                    self.1 = z;\n+                    self.1 = unpack!(status|=, self.1.sub_r(self.0, round));\n+                    self.1 = unpack!(status|=, self.1.add_r(zz, round));\n+                }\n+                status.and(self)\n+            }\n+        }\n     }\n \n-    fn mul_r(self, rhs: Self, round: Round) -> StatusAnd<Self> {\n-        panic!(\"NYI mul_r\")\n+    fn mul_r(mut self, rhs: Self, round: Round) -> StatusAnd<Self> {\n+        // Interesting observation: For special categories, finding the lowest\n+        // common ancestor of the following layered graph gives the correct\n+        // return category:\n+        //\n+        //    NaN\n+        //   /   \\\n+        // Zero  Inf\n+        //   \\   /\n+        //   Normal\n+        //\n+        // e.g. NaN * NaN = NaN\n+        //      Zero * Inf = NaN\n+        //      Normal * Zero = Zero\n+        //      Normal * Inf = Inf\n+        match (self.category(), rhs.category()) {\n+            (Category::NaN, _) => Status::OK.and(self),\n+\n+            (_, Category::NaN) => Status::OK.and(rhs),\n+\n+            (Category::Zero, Category::Infinity) |\n+            (Category::Infinity, Category::Zero) => Status::OK.and(Self::NAN),\n+\n+            (Category::Zero, _) |\n+            (Category::Infinity, _) => Status::OK.and(self),\n+\n+            (_, Category::Zero) |\n+            (_, Category::Infinity) => Status::OK.and(rhs),\n+\n+            (Category::Normal, Category::Normal) => {\n+                let mut status = Status::OK;\n+                let (a, b, c, d) = (self.0, self.1, rhs.0, rhs.1);\n+                // t = a * c\n+                let mut t = a;\n+                t = unpack!(status|=, t.mul_r(c, round));\n+                if !t.is_finite_non_zero() {\n+                    return status.and(DoubleFloat(t, F::ZERO));\n+                }\n+\n+                // tau = fmsub(a, c, t), that is -fmadd(-a, c, t).\n+                let mut tau = a;\n+                tau = unpack!(status|=, tau.mul_add_r(c, -t, round));\n+                // v = a * d\n+                let mut v = a;\n+                v = unpack!(status|=, v.mul_r(d, round));\n+                // w = b * c\n+                let mut w = b;\n+                w = unpack!(status|=, w.mul_r(c, round));\n+                v = unpack!(status|=, v.add_r(w, round));\n+                // tau += v + w\n+                tau = unpack!(status|=, tau.add_r(v, round));\n+                // u = t + tau\n+                let mut u = t;\n+                u = unpack!(status|=, u.add_r(tau, round));\n+\n+                self.0 = u;\n+                if !u.is_finite() {\n+                    self.1 = F::ZERO;\n+                } else {\n+                    // self.1 = (t - u) + tau\n+                    t = unpack!(status|=, t.sub_r(u, round));\n+                    t = unpack!(status|=, t.add_r(tau, round));\n+                    self.1 = t;\n+                }\n+                status.and(self)\n+            }\n+        }\n     }\n \n     fn mul_add_r(self, multiplicand: Self, addend: Self, round: Round) -> StatusAnd<Self> {\n-        panic!(\"NYI mul_add_r\")\n+        Fallback::from(self)\n+            .mul_add_r(Fallback::from(multiplicand), Fallback::from(addend), round)\n+            .map(Self::from)\n     }\n \n     fn div_r(self, rhs: Self, round: Round) -> StatusAnd<Self> {\n-        panic!(\"NYI div_r\")\n+        Fallback::from(self).div_r(Fallback::from(rhs), round).map(\n+            Self::from,\n+        )\n     }\n \n     fn c_fmod(self, rhs: Self) -> StatusAnd<Self> {\n-        panic!(\"NYI c_fmod\")\n+        Fallback::from(self).c_fmod(Fallback::from(rhs)).map(\n+            Self::from,\n+        )\n     }\n \n     fn round_to_integral(self, round: Round) -> StatusAnd<Self> {\n-        panic!(\"NYI round_to_integral\")\n+        Fallback::from(self).round_to_integral(round).map(\n+            Self::from,\n+        )\n     }\n \n     fn next_up(self) -> StatusAnd<Self> {\n-        panic!(\"NYI next_up\")\n+        Fallback::from(self).next_up().map(Self::from)\n     }\n \n     fn from_bits(input: u128) -> Self {\n-        panic!(\"NYI from_bits\")\n+        let (a, b) = (input, input >> F::BITS);\n+        DoubleFloat(\n+            F::from_bits(a & ((1 << F::BITS) - 1)),\n+            F::from_bits(b & ((1 << F::BITS) - 1)),\n+        )\n     }\n \n     fn from_u128_r(input: u128, round: Round) -> StatusAnd<Self> {\n-        panic!(\"NYI from_u128_r\")\n+        Fallback::from_u128_r(input, round).map(Self::from)\n     }\n \n     fn from_str_r(s: &str, round: Round) -> Result<StatusAnd<Self>, ParseError> {\n-        panic!(\"NYI from_str_r\")\n+        Fallback::from_str_r(s, round).map(|r| r.map(Self::from))\n     }\n \n     fn to_bits(self) -> u128 {\n-        panic!(\"NYI to_bits\")\n+        self.0.to_bits() | (self.1.to_bits() << F::BITS)\n     }\n \n     fn to_u128_r(self, width: usize, round: Round, is_exact: &mut bool) -> StatusAnd<u128> {\n-        panic!(\"NYI to_u128_r\");\n+        Fallback::from(self).to_u128_r(width, round, is_exact)\n     }\n \n     fn cmp_abs_normal(self, rhs: Self) -> Ordering {\n-        panic!(\"NYI cmp_abs_normal\")\n+        self.0.cmp_abs_normal(rhs.0).then_with(|| {\n+            let result = self.1.cmp_abs_normal(rhs.1);\n+            if result != Ordering::Equal {\n+                let against = self.0.is_negative() ^ self.1.is_negative();\n+                let rhs_against = rhs.0.is_negative() ^ rhs.1.is_negative();\n+                (!against).cmp(&!rhs_against).then_with(|| if against {\n+                    result.reverse()\n+                } else {\n+                    result\n+                })\n+            } else {\n+                result\n+            }\n+        })\n     }\n \n     fn bitwise_eq(self, rhs: Self) -> bool {\n-        panic!(\"NYI bitwise_eq\")\n+        self.0.bitwise_eq(rhs.0) && self.1.bitwise_eq(rhs.1)\n     }\n \n     fn is_negative(self) -> bool {\n-        panic!(\"NYI is_negative\")\n+        self.0.is_negative()\n     }\n \n     fn is_denormal(self) -> bool {\n-        panic!(\"NYI is_denormal\")\n+        self.category() == Category::Normal &&\n+            (self.0.is_denormal() || self.0.is_denormal() ||\n+          // (double)(Hi + Lo) == Hi defines a normal number.\n+          !(self.0 + self.1).value.bitwise_eq(self.0))\n     }\n \n     fn is_signaling(self) -> bool {\n-        panic!(\"NYI is_signaling\")\n+        self.0.is_signaling()\n     }\n \n     fn category(self) -> Category {\n-        panic!(\"NYI category\")\n+        self.0.category()\n     }\n \n     fn get_exact_inverse(self) -> Option<Self> {\n-        panic!(\"NYI get_exact_inverse\")\n+        Fallback::from(self).get_exact_inverse().map(Self::from)\n     }\n \n     fn ilogb(self) -> ExpInt {\n-        panic!(\"NYI ilogb\")\n+        self.0.ilogb()\n     }\n \n     fn scalbn_r(self, exp: ExpInt, round: Round) -> Self {\n-        panic!(\"NYI scalbn\")\n+        DoubleFloat(self.0.scalbn_r(exp, round), self.1.scalbn_r(exp, round))\n     }\n \n     fn frexp_r(self, exp: &mut ExpInt, round: Round) -> Self {\n-        panic!(\"NYI frexp\")\n+        let a = self.0.frexp_r(exp, round);\n+        let mut b = self.1;\n+        if self.category() == Category::Normal {\n+            b = b.scalbn_r(-*exp, round);\n+        }\n+        DoubleFloat(a, b)\n     }\n }"}]}