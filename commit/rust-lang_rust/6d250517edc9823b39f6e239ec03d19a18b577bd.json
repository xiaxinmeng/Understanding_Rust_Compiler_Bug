{"sha": "6d250517edc9823b39f6e239ec03d19a18b577bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkMjUwNTE3ZWRjOTgyM2IzOWY2ZTIzOWVjMDNkMTlhMThiNTc3YmQ=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-11T04:06:22Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-11T04:06:22Z"}, "message": "Copyedit sections 9 and 10 of the tutorial", "tree": {"sha": "47351dca5df84cf2104ec25c838b6a65e7cd7a7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47351dca5df84cf2104ec25c838b6a65e7cd7a7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d250517edc9823b39f6e239ec03d19a18b577bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d250517edc9823b39f6e239ec03d19a18b577bd", "html_url": "https://github.com/rust-lang/rust/commit/6d250517edc9823b39f6e239ec03d19a18b577bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d250517edc9823b39f6e239ec03d19a18b577bd/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7582a482c68ab641764d39a0c3428d9b7ce39603", "url": "https://api.github.com/repos/rust-lang/rust/commits/7582a482c68ab641764d39a0c3428d9b7ce39603", "html_url": "https://github.com/rust-lang/rust/commit/7582a482c68ab641764d39a0c3428d9b7ce39603"}], "stats": {"total": 93, "additions": 48, "deletions": 45}, "files": [{"sha": "1103ba112a2e8b31dc0f1fcb436e6574ac79e730", "filename": "doc/tutorial.md", "status": "modified", "additions": 48, "deletions": 45, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/6d250517edc9823b39f6e239ec03d19a18b577bd/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/6d250517edc9823b39f6e239ec03d19a18b577bd/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=6d250517edc9823b39f6e239ec03d19a18b577bd", "patch": "@@ -1366,7 +1366,7 @@ The indexing operator (`[]`) also auto-dereferences.\n \n # Vectors and strings\n \n-Vectors are a contiguous section of memory containing zero or more\n+A vector is a contiguous section of memory containing zero or more\n values of the same type. Like other types in Rust, vectors can be\n stored on the stack, the local heap, or the exchange heap. Borrowed\n pointers to vectors are also called 'slices'.\n@@ -1411,10 +1411,10 @@ my_crayons += your_crayons;\n \n > ***Note:*** The above examples of vector addition use owned\n > vectors. Some operations on slices and stack vectors are\n-> not well supported yet, owned vectors are often the most\n+> not yet well-supported. Owned vectors are often the most\n > usable.\n \n-Indexing into vectors is done with square brackets:\n+Square brackets denote indexing into a vector:\n \n ~~~~\n # enum Crayon { Almond, AntiqueBrass, Apricot,\n@@ -1429,7 +1429,7 @@ match crayons[0] {\n ~~~~\n \n The elements of a vector _inherit the mutability of the vector_,\n-and as such individual elements may not be reassigned when the\n+and as such, individual elements may not be reassigned when the\n vector lives in an immutable slot.\n \n ~~~ {.xfail-test}\n@@ -1459,13 +1459,13 @@ mutable_crayons[0] = Apricot;\n This is a simple example of Rust's _dual-mode data structures_, also\n referred to as _freezing and thawing_.\n \n-Strings are implemented with vectors of `u8`, though they have a distinct\n-type. They support most of the same allocation options as\n-vectors, though the string literal without a storage sigil, e.g.\n-`\"foo\"` is treated differently than a comparable vector (`[foo]`).\n-Whereas plain vectors are stack-allocated fixed-length vectors,\n-plain strings are region pointers to read-only memory. Strings\n-are always immutable.\n+Strings are implemented with vectors of `u8`, though they have a\n+distinct type. They support most of the same allocation options as\n+vectors, though the string literal without a storage sigil (for\n+example, `\"foo\"`) is treated differently than a comparable vector\n+(`[foo]`).  Whereas plain vectors are stack-allocated fixed-length\n+vectors, plain strings are region pointers to read-only\n+memory. All strings are immutable.\n \n ~~~\n // A plain string is a slice to read-only (static) memory\n@@ -1528,8 +1528,9 @@ if favorite_crayon_name.len() > 5 {\n # Closures\n \n Named functions, like those we've seen so far, may not refer to local\n-variables declared outside the function - they do not \"close over\n-their environment\". For example, you couldn't write the following:\n+variables declared outside the function: they do not close over their\n+environment (sometimes referred to as \"capturing\" variables in their\n+environment). For example, you couldn't write the following:\n \n ~~~~ {.ignore}\n let foo = 10;\n@@ -1552,10 +1553,10 @@ let closure = |arg| println(fmt!(\"captured_var=%d, arg=%d\", captured_var, arg));\n call_closure_with_ten(closure);\n ~~~~\n \n-Closures begin with the argument list between bars and are followed by\n+Closures begin with the argument list between vertical bars and are followed by\n a single expression. The types of the arguments are generally omitted,\n as is the return type, because the compiler can almost always infer\n-them. In the rare case where the compiler needs assistance though, the\n+them. In the rare case where the compiler needs assistance, though, the\n arguments and return types may be annotated.\n \n ~~~~\n@@ -1575,9 +1576,10 @@ let mut max = 0;\n Stack closures are very efficient because their environment is\n allocated on the call stack and refers by pointer to captured\n locals. To ensure that stack closures never outlive the local\n-variables to which they refer, they can only be used in argument\n-position and cannot be stored in structures nor returned from\n-functions. Despite the limitations stack closures are used\n+variables to which they refer, stack closures are not\n+first-class. That is, they can only be used in argument position; they\n+cannot be stored in data structures or returned from\n+functions. Despite these limitations, stack closures are used\n pervasively in Rust code.\n \n ## Managed closures\n@@ -1586,12 +1588,12 @@ When you need to store a closure in a data structure, a stack closure\n will not do, since the compiler will refuse to let you store it. For\n this purpose, Rust provides a type of closure that has an arbitrary\n lifetime, written `fn@` (boxed closure, analogous to the `@` pointer\n-type described earlier).\n+type described earlier). This type of closure *is* first-class.\n \n A managed closure does not directly access its environment, but merely\n copies out the values that it closes over into a private data\n structure. This means that it can not assign to these variables, and\n-will not 'see' updates to them.\n+cannot observe updates to them.\n \n This code creates a closure that adds a given string to its argument,\n returns it from a function, and then calls it:\n@@ -1608,12 +1610,12 @@ fn main() {\n }\n ~~~~\n \n-This example uses the long closure syntax, `fn@(s: ~str) ...`,\n-making the fact that we are declaring a box closure explicit. In\n-practice boxed closures are usually defined with the short closure\n-syntax introduced earlier, in which case the compiler will infer\n-the type of closure. Thus our managed closure example could also\n-be written:\n+This example uses the long closure syntax, `fn@(s: ~str) ...`. Using\n+this syntax makes it explicit that we are declaring a boxed\n+closure. In practice, boxed closures are usually defined with the\n+short closure syntax introduced earlier, in which case the compiler\n+infers the type of closure. Thus our managed closure example could\n+also be written:\n \n ~~~~\n fn mk_appender(suffix: ~str) -> fn@(~str) -> ~str {\n@@ -1626,18 +1628,18 @@ fn mk_appender(suffix: ~str) -> fn@(~str) -> ~str {\n Owned closures, written `fn~` in analogy to the `~` pointer type,\n hold on to things that can safely be sent between\n processes. They copy the values they close over, much like managed\n-closures, but they also 'own' them\u2014meaning no other code can access\n+closures, but they also own them: that is, no other code can access\n them. Owned closures are used in concurrent code, particularly\n for spawning [tasks](#tasks).\n \n ## Closure compatibility\n \n-A nice property of Rust closures is that you can pass any kind of\n+Rust closures have a convenient subtyping property: you can pass any kind of\n closure (as long as the arguments and return types match) to functions\n that expect a `fn()`. Thus, when writing a higher-order function that\n-wants to do nothing with its function argument beyond calling it, you\n-should almost always specify the type of that argument as `fn()`, so\n-that callers have the flexibility to pass whatever they want.\n+only calls its function argument, and does nothing else with it, you\n+should almost always declare the type of that argument as `fn()`. That way,\n+callers may pass any kind of closure.\n \n ~~~~\n fn call_twice(f: fn()) { f(); f(); }\n@@ -1650,15 +1652,15 @@ call_twice(bare_function);\n ~~~~\n \n > ***Note:*** Both the syntax and the semantics will be changing\n-> in small ways. At the moment they can be unsound in multiple\n+> in small ways. At the moment they can be unsound in some\n > scenarios, particularly with non-copyable types.\n \n ## Do syntax\n \n The `do` expression provides a way to treat higher-order functions\n (functions that take closures as arguments) as control structures.\n \n-Consider this function which iterates over a vector of\n+Consider this function that iterates over a vector of\n integers, passing in a pointer to each integer in the vector:\n \n ~~~~\n@@ -1702,13 +1704,14 @@ do each(&[1, 2, 3]) |n| {\n ~~~~\n \n The call is prefixed with the keyword `do` and, instead of writing the\n-final closure inside the argument list it is moved outside of the\n-parenthesis where it looks visually more like a typical block of\n+final closure inside the argument list, it appears outside of the\n+parentheses, where it looks more like a typical block of\n code.\n \n-`do` is often used to create tasks with the `task::spawn` function.\n-`spawn` has the signature `spawn(fn: fn~())`. In other words, it\n-is a function that takes an owned closure that takes no arguments.\n+`do` is a convenient way to create tasks with the `task::spawn`\n+function.  `spawn` has the signature `spawn(fn: fn~())`. In other\n+words, it is a function that takes an owned closure that takes no\n+arguments.\n \n ~~~~\n use task::spawn;\n@@ -1731,10 +1734,10 @@ do spawn {\n \n ## For loops\n \n-Most iteration in Rust is done with `for` loops. Like `do`,\n-`for` is a nice syntax for doing control flow with closures.\n-Additionally, within a `for` loop, `break`, `loop`, and `return`\n-work just as they do with `while` and `loop`.\n+The most common way to express iteration in Rust is with a `for`\n+loop. Like `do`, `for` is a nice syntax for describing control flow\n+with closures.  Additionally, within a `for` loop, `break`, `loop`,\n+and `return` work just as they do with `while` and `loop`.\n \n Consider again our `each` function, this time improved to\n break early when the iteratee returns `false`:\n@@ -1765,7 +1768,7 @@ each(&[2, 4, 8, 5, 16], |n| {\n ~~~~\n \n With `for`, functions like `each` can be treated more\n-like builtin looping structures. When calling `each`\n+like built-in looping structures. When calling `each`\n in a `for` loop, instead of returning `false` to break\n out of the loop, you just write `break`. To skip ahead\n to the next iteration, write `loop`.\n@@ -1783,8 +1786,8 @@ for each(&[2, 4, 8, 5, 16]) |n| {\n \n As an added bonus, you can use the `return` keyword, which is not\n normally allowed in closures, in a block that appears as the body of a\n-`for` loop \u2014 this will cause a return to happen from the outer\n-function, not just the loop body.\n+`for` loop: the meaning of `return` in such a block is to return from\n+the enclosing function, not just the loop body.\n \n ~~~~\n # use each = vec::each;"}]}