{"sha": "87eafd6c1b844f4258a2bbd7563c16609c4606e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3ZWFmZDZjMWI4NDRmNDI1OGEyYmJkNzU2M2MxNjYwOWM0NjA2ZTY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-22T21:48:08Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-22T23:41:49Z"}, "message": "syntax: extract `check.rs`.", "tree": {"sha": "e5a90f3df726c70120afb9f340e18c918ea4155f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5a90f3df726c70120afb9f340e18c918ea4155f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87eafd6c1b844f4258a2bbd7563c16609c4606e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87eafd6c1b844f4258a2bbd7563c16609c4606e6", "html_url": "https://github.com/rust-lang/rust/commit/87eafd6c1b844f4258a2bbd7563c16609c4606e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87eafd6c1b844f4258a2bbd7563c16609c4606e6/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5aa2dd1ff73e3fc0a17a68938ffafe2d4ed0e8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5aa2dd1ff73e3fc0a17a68938ffafe2d4ed0e8c", "html_url": "https://github.com/rust-lang/rust/commit/e5aa2dd1ff73e3fc0a17a68938ffafe2d4ed0e8c"}], "stats": {"total": 1913, "additions": 960, "deletions": 953}, "files": [{"sha": "97793bca1f5891ad5520b5d8e00f76c99c4337cd", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 951, "changes": 958, "blob_url": "https://github.com/rust-lang/rust/blob/87eafd6c1b844f4258a2bbd7563c16609c4606e6/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87eafd6c1b844f4258a2bbd7563c16609c4606e6/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=87eafd6c1b844f4258a2bbd7563c16609c4606e6", "patch": "@@ -13,963 +13,19 @@\n //! becomes stable.\n \n mod accepted;\n-use accepted::ACCEPTED_FEATURES;\n mod removed;\n-use removed::{REMOVED_FEATURES, STABLE_REMOVED_FEATURES};\n mod active;\n-use active::{ACTIVE_FEATURES};\n-pub use active::{Features, INCOMPLETE_FEATURES};\n mod builtin_attrs;\n+mod check;\n+\n+pub use active::{Features, INCOMPLETE_FEATURES};\n pub use builtin_attrs::{\n     AttributeGate, AttributeType, GatedCfg,\n     BuiltinAttribute, BUILTIN_ATTRIBUTES, BUILTIN_ATTRIBUTE_MAP,\n     deprecated_attributes, is_builtin_attr,  is_builtin_attr_name,\n };\n-\n-use crate::ast::{\n-    self, AssocTyConstraint, AssocTyConstraintKind, NodeId, GenericParam, GenericParamKind,\n-    PatKind, RangeEnd,\n+pub use check::{\n+    check_attribute, check_crate, get_features, feature_err, emit_feature_err,\n+    Stability, GateIssue, UnstableFeatures,\n+    EXPLAIN_STMT_ATTR_SYNTAX, EXPLAIN_UNSIZED_TUPLE_COERCION,\n };\n-use crate::attr::{self, check_builtin_attribute};\n-use crate::source_map::Spanned;\n-use crate::edition::{ALL_EDITIONS, Edition};\n-use crate::visit::{self, FnKind, Visitor};\n-use crate::parse::{token, ParseSess};\n-use crate::parse::parser::Parser;\n-use crate::symbol::{Symbol, sym};\n-use crate::tokenstream::TokenTree;\n-\n-use errors::{Applicability, DiagnosticBuilder, Handler};\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_target::spec::abi::Abi;\n-use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n-use log::debug;\n-\n-use std::env;\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum Stability {\n-    Unstable,\n-    // First argument is tracking issue link; second argument is an optional\n-    // help message, which defaults to \"remove this attribute\"\n-    Deprecated(&'static str, Option<&'static str>),\n-}\n-\n-struct Context<'a> {\n-    features: &'a Features,\n-    parse_sess: &'a ParseSess,\n-    plugin_attributes: &'a [(Symbol, AttributeType)],\n-}\n-\n-macro_rules! gate_feature_fn {\n-    ($cx: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr, $level: expr) => {{\n-        let (cx, has_feature, span,\n-             name, explain, level) = ($cx, $has_feature, $span, $name, $explain, $level);\n-        let has_feature: bool = has_feature(&$cx.features);\n-        debug!(\"gate_feature(feature = {:?}, span = {:?}); has? {}\", name, span, has_feature);\n-        if !has_feature && !span.allows_unstable($name) {\n-            leveled_feature_err(cx.parse_sess, name, span, GateIssue::Language, explain, level)\n-                .emit();\n-        }\n-    }}\n-}\n-\n-macro_rules! gate_feature {\n-    ($cx: expr, $feature: ident, $span: expr, $explain: expr) => {\n-        gate_feature_fn!($cx, |x:&Features| x.$feature, $span,\n-                         sym::$feature, $explain, GateStrength::Hard)\n-    };\n-    ($cx: expr, $feature: ident, $span: expr, $explain: expr, $level: expr) => {\n-        gate_feature_fn!($cx, |x:&Features| x.$feature, $span,\n-                         sym::$feature, $explain, $level)\n-    };\n-}\n-\n-impl<'a> Context<'a> {\n-    fn check_attribute(\n-        &self,\n-        attr: &ast::Attribute,\n-        attr_info: Option<&BuiltinAttribute>,\n-        is_macro: bool\n-    ) {\n-        debug!(\"check_attribute(attr = {:?})\", attr);\n-        if let Some(&(name, ty, _template, ref gateage)) = attr_info {\n-            if let AttributeGate::Gated(_, name, desc, ref has_feature) = *gateage {\n-                if !attr.span.allows_unstable(name) {\n-                    gate_feature_fn!(\n-                        self, has_feature, attr.span, name, desc, GateStrength::Hard\n-                    );\n-                }\n-            } else if name == sym::doc {\n-                if let Some(content) = attr.meta_item_list() {\n-                    if content.iter().any(|c| c.check_name(sym::include)) {\n-                        gate_feature!(self, external_doc, attr.span,\n-                            \"`#[doc(include = \\\"...\\\")]` is experimental\"\n-                        );\n-                    }\n-                }\n-            }\n-            debug!(\"check_attribute: {:?} is builtin, {:?}, {:?}\", attr.path, ty, gateage);\n-            return;\n-        } else {\n-            for segment in &attr.path.segments {\n-                if segment.ident.as_str().starts_with(\"rustc\") {\n-                    let msg = \"attributes starting with `rustc` are \\\n-                               reserved for use by the `rustc` compiler\";\n-                    gate_feature!(self, rustc_attrs, segment.ident.span, msg);\n-                }\n-            }\n-        }\n-        for &(n, ty) in self.plugin_attributes {\n-            if attr.path == n {\n-                // Plugins can't gate attributes, so we don't check for it\n-                // unlike the code above; we only use this loop to\n-                // short-circuit to avoid the checks below.\n-                debug!(\"check_attribute: {:?} is registered by a plugin, {:?}\", attr.path, ty);\n-                return;\n-            }\n-        }\n-        if !is_macro && !attr::is_known(attr) {\n-            // Only run the custom attribute lint during regular feature gate\n-            // checking. Macro gating runs before the plugin attributes are\n-            // registered, so we skip this in that case.\n-            let msg = format!(\"the attribute `{}` is currently unknown to the compiler and \\\n-                               may have meaning added to it in the future\", attr.path);\n-            gate_feature!(self, custom_attribute, attr.span, &msg);\n-        }\n-    }\n-}\n-\n-pub fn check_attribute(attr: &ast::Attribute, parse_sess: &ParseSess, features: &Features) {\n-    let cx = Context { features, parse_sess, plugin_attributes: &[] };\n-    cx.check_attribute(\n-        attr,\n-        attr.ident().and_then(|ident| BUILTIN_ATTRIBUTE_MAP.get(&ident.name).map(|a| *a)),\n-        true\n-    );\n-}\n-\n-fn find_lang_feature_issue(feature: Symbol) -> Option<u32> {\n-    if let Some(info) = ACTIVE_FEATURES.iter().find(|t| t.0 == feature) {\n-        let issue = info.2;\n-        // FIXME (#28244): enforce that active features have issue numbers\n-        // assert!(issue.is_some())\n-        issue\n-    } else {\n-        // search in Accepted, Removed, or Stable Removed features\n-        let found = ACCEPTED_FEATURES.iter().chain(REMOVED_FEATURES).chain(STABLE_REMOVED_FEATURES)\n-            .find(|t| t.0 == feature);\n-        match found {\n-            Some(&(_, _, issue, _)) => issue,\n-            None => panic!(\"Feature `{}` is not declared anywhere\", feature),\n-        }\n-    }\n-}\n-\n-pub enum GateIssue {\n-    Language,\n-    Library(Option<u32>)\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq)]\n-pub enum GateStrength {\n-    /// A hard error. (Most feature gates should use this.)\n-    Hard,\n-    /// Only a warning. (Use this only as backwards-compatibility demands.)\n-    Soft,\n-}\n-\n-pub fn emit_feature_err(\n-    sess: &ParseSess,\n-    feature: Symbol,\n-    span: Span,\n-    issue: GateIssue,\n-    explain: &str,\n-) {\n-    feature_err(sess, feature, span, issue, explain).emit();\n-}\n-\n-pub fn feature_err<'a, S: Into<MultiSpan>>(\n-    sess: &'a ParseSess,\n-    feature: Symbol,\n-    span: S,\n-    issue: GateIssue,\n-    explain: &str,\n-) -> DiagnosticBuilder<'a> {\n-    leveled_feature_err(sess, feature, span, issue, explain, GateStrength::Hard)\n-}\n-\n-fn leveled_feature_err<'a, S: Into<MultiSpan>>(\n-    sess: &'a ParseSess,\n-    feature: Symbol,\n-    span: S,\n-    issue: GateIssue,\n-    explain: &str,\n-    level: GateStrength,\n-) -> DiagnosticBuilder<'a> {\n-    let diag = &sess.span_diagnostic;\n-\n-    let issue = match issue {\n-        GateIssue::Language => find_lang_feature_issue(feature),\n-        GateIssue::Library(lib) => lib,\n-    };\n-\n-    let mut err = match level {\n-        GateStrength::Hard => {\n-            diag.struct_span_err_with_code(span, explain, stringify_error_code!(E0658))\n-        }\n-        GateStrength::Soft => diag.struct_span_warn(span, explain),\n-    };\n-\n-    match issue {\n-        None | Some(0) => {}  // We still accept `0` as a stand-in for backwards compatibility\n-        Some(n) => {\n-            err.note(&format!(\n-                \"for more information, see https://github.com/rust-lang/rust/issues/{}\",\n-                n,\n-            ));\n-        }\n-    }\n-\n-    // #23973: do not suggest `#![feature(...)]` if we are in beta/stable\n-    if sess.unstable_features.is_nightly_build() {\n-        err.help(&format!(\"add `#![feature({})]` to the crate attributes to enable\", feature));\n-    }\n-\n-    // If we're on stable and only emitting a \"soft\" warning, add a note to\n-    // clarify that the feature isn't \"on\" (rather than being on but\n-    // warning-worthy).\n-    if !sess.unstable_features.is_nightly_build() && level == GateStrength::Soft {\n-        err.help(\"a nightly build of the compiler is required to enable this feature\");\n-    }\n-\n-    err\n-\n-}\n-\n-const EXPLAIN_BOX_SYNTAX: &str =\n-    \"box expression syntax is experimental; you can call `Box::new` instead\";\n-\n-pub const EXPLAIN_STMT_ATTR_SYNTAX: &str =\n-    \"attributes on expressions are experimental\";\n-\n-pub const EXPLAIN_ALLOW_INTERNAL_UNSTABLE: &str =\n-    \"allow_internal_unstable side-steps feature gating and stability checks\";\n-pub const EXPLAIN_ALLOW_INTERNAL_UNSAFE: &str =\n-    \"allow_internal_unsafe side-steps the unsafe_code lint\";\n-\n-pub const EXPLAIN_UNSIZED_TUPLE_COERCION: &str =\n-    \"unsized tuple coercion is not stable enough for use and is subject to change\";\n-\n-struct PostExpansionVisitor<'a> {\n-    context: &'a Context<'a>,\n-    builtin_attributes: &'static FxHashMap<Symbol, &'static BuiltinAttribute>,\n-}\n-\n-macro_rules! gate_feature_post {\n-    ($cx: expr, $feature: ident, $span: expr, $explain: expr) => {{\n-        let (cx, span) = ($cx, $span);\n-        if !span.allows_unstable(sym::$feature) {\n-            gate_feature!(cx.context, $feature, span, $explain)\n-        }\n-    }};\n-    ($cx: expr, $feature: ident, $span: expr, $explain: expr, $level: expr) => {{\n-        let (cx, span) = ($cx, $span);\n-        if !span.allows_unstable(sym::$feature) {\n-            gate_feature!(cx.context, $feature, span, $explain, $level)\n-        }\n-    }}\n-}\n-\n-impl<'a> PostExpansionVisitor<'a> {\n-    fn check_abi(&self, abi: Abi, span: Span) {\n-        match abi {\n-            Abi::RustIntrinsic => {\n-                gate_feature_post!(&self, intrinsics, span,\n-                                   \"intrinsics are subject to change\");\n-            },\n-            Abi::PlatformIntrinsic => {\n-                gate_feature_post!(&self, platform_intrinsics, span,\n-                                   \"platform intrinsics are experimental and possibly buggy\");\n-            },\n-            Abi::Vectorcall => {\n-                gate_feature_post!(&self, abi_vectorcall, span,\n-                                   \"vectorcall is experimental and subject to change\");\n-            },\n-            Abi::Thiscall => {\n-                gate_feature_post!(&self, abi_thiscall, span,\n-                                   \"thiscall is experimental and subject to change\");\n-            },\n-            Abi::RustCall => {\n-                gate_feature_post!(&self, unboxed_closures, span,\n-                                   \"rust-call ABI is subject to change\");\n-            },\n-            Abi::PtxKernel => {\n-                gate_feature_post!(&self, abi_ptx, span,\n-                                   \"PTX ABIs are experimental and subject to change\");\n-            },\n-            Abi::Unadjusted => {\n-                gate_feature_post!(&self, abi_unadjusted, span,\n-                                   \"unadjusted ABI is an implementation detail and perma-unstable\");\n-            },\n-            Abi::Msp430Interrupt => {\n-                gate_feature_post!(&self, abi_msp430_interrupt, span,\n-                                   \"msp430-interrupt ABI is experimental and subject to change\");\n-            },\n-            Abi::X86Interrupt => {\n-                gate_feature_post!(&self, abi_x86_interrupt, span,\n-                                   \"x86-interrupt ABI is experimental and subject to change\");\n-            },\n-            Abi::AmdGpuKernel => {\n-                gate_feature_post!(&self, abi_amdgpu_kernel, span,\n-                                   \"amdgpu-kernel ABI is experimental and subject to change\");\n-            },\n-            // Stable\n-            Abi::Cdecl |\n-            Abi::Stdcall |\n-            Abi::Fastcall |\n-            Abi::Aapcs |\n-            Abi::Win64 |\n-            Abi::SysV64 |\n-            Abi::Rust |\n-            Abi::C |\n-            Abi::System => {}\n-        }\n-    }\n-}\n-\n-impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n-    fn visit_attribute(&mut self, attr: &ast::Attribute) {\n-        let attr_info = attr.ident().and_then(|ident| {\n-            self.builtin_attributes.get(&ident.name).map(|a| *a)\n-        });\n-\n-        // Check for gated attributes.\n-        self.context.check_attribute(attr, attr_info, false);\n-\n-        if attr.check_name(sym::doc) {\n-            if let Some(content) = attr.meta_item_list() {\n-                if content.len() == 1 && content[0].check_name(sym::cfg) {\n-                    gate_feature_post!(&self, doc_cfg, attr.span,\n-                        \"`#[doc(cfg(...))]` is experimental\"\n-                    );\n-                } else if content.iter().any(|c| c.check_name(sym::masked)) {\n-                    gate_feature_post!(&self, doc_masked, attr.span,\n-                        \"`#[doc(masked)]` is experimental\"\n-                    );\n-                } else if content.iter().any(|c| c.check_name(sym::spotlight)) {\n-                    gate_feature_post!(&self, doc_spotlight, attr.span,\n-                        \"`#[doc(spotlight)]` is experimental\"\n-                    );\n-                } else if content.iter().any(|c| c.check_name(sym::alias)) {\n-                    gate_feature_post!(&self, doc_alias, attr.span,\n-                        \"`#[doc(alias = \\\"...\\\")]` is experimental\"\n-                    );\n-                } else if content.iter().any(|c| c.check_name(sym::keyword)) {\n-                    gate_feature_post!(&self, doc_keyword, attr.span,\n-                        \"`#[doc(keyword = \\\"...\\\")]` is experimental\"\n-                    );\n-                }\n-            }\n-        }\n-\n-        match attr_info {\n-            // `rustc_dummy` doesn't have any restrictions specific to built-in attributes.\n-            Some(&(name, _, template, _)) if name != sym::rustc_dummy =>\n-                check_builtin_attribute(self.context.parse_sess, attr, name, template),\n-            _ => if let Some(TokenTree::Token(token)) = attr.tokens.trees().next() {\n-                if token == token::Eq {\n-                    // All key-value attributes are restricted to meta-item syntax.\n-                    attr.parse_meta(self.context.parse_sess).map_err(|mut err| err.emit()).ok();\n-                }\n-            }\n-        }\n-    }\n-\n-    fn visit_name(&mut self, sp: Span, name: ast::Name) {\n-        if !name.as_str().is_ascii() {\n-            gate_feature_post!(\n-                &self,\n-                non_ascii_idents,\n-                self.context.parse_sess.source_map().def_span(sp),\n-                \"non-ascii idents are not fully supported\"\n-            );\n-        }\n-    }\n-\n-    fn visit_item(&mut self, i: &'a ast::Item) {\n-        match i.node {\n-            ast::ItemKind::ForeignMod(ref foreign_module) => {\n-                self.check_abi(foreign_module.abi, i.span);\n-            }\n-\n-            ast::ItemKind::Fn(..) => {\n-                if attr::contains_name(&i.attrs[..], sym::plugin_registrar) {\n-                    gate_feature_post!(&self, plugin_registrar, i.span,\n-                                       \"compiler plugins are experimental and possibly buggy\");\n-                }\n-                if attr::contains_name(&i.attrs[..], sym::start) {\n-                    gate_feature_post!(&self, start, i.span,\n-                                      \"a `#[start]` function is an experimental \\\n-                                       feature whose signature may change \\\n-                                       over time\");\n-                }\n-                if attr::contains_name(&i.attrs[..], sym::main) {\n-                    gate_feature_post!(&self, main, i.span,\n-                                       \"declaration of a non-standard `#[main]` \\\n-                                        function may change over time, for now \\\n-                                        a top-level `fn main()` is required\");\n-                }\n-            }\n-\n-            ast::ItemKind::Struct(..) => {\n-                for attr in attr::filter_by_name(&i.attrs[..], sym::repr) {\n-                    for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n-                        if item.check_name(sym::simd) {\n-                            gate_feature_post!(&self, repr_simd, attr.span,\n-                                               \"SIMD types are experimental and possibly buggy\");\n-                        }\n-                    }\n-                }\n-            }\n-\n-            ast::ItemKind::Enum(ast::EnumDef{ref variants, ..}, ..) => {\n-                for variant in variants {\n-                    match (&variant.data, &variant.disr_expr) {\n-                        (ast::VariantData::Unit(..), _) => {},\n-                        (_, Some(disr_expr)) =>\n-                            gate_feature_post!(\n-                                &self,\n-                                arbitrary_enum_discriminant,\n-                                disr_expr.value.span,\n-                                \"discriminants on non-unit variants are experimental\"),\n-                        _ => {},\n-                    }\n-                }\n-\n-                let has_feature = self.context.features.arbitrary_enum_discriminant;\n-                if !has_feature && !i.span.allows_unstable(sym::arbitrary_enum_discriminant) {\n-                    Parser::maybe_report_invalid_custom_discriminants(\n-                        self.context.parse_sess,\n-                        &variants,\n-                    );\n-                }\n-            }\n-\n-            ast::ItemKind::Impl(_, polarity, defaultness, _, _, _, _) => {\n-                if polarity == ast::ImplPolarity::Negative {\n-                    gate_feature_post!(&self, optin_builtin_traits,\n-                                       i.span,\n-                                       \"negative trait bounds are not yet fully implemented; \\\n-                                        use marker types for now\");\n-                }\n-\n-                if let ast::Defaultness::Default = defaultness {\n-                    gate_feature_post!(&self, specialization,\n-                                       i.span,\n-                                       \"specialization is unstable\");\n-                }\n-            }\n-\n-            ast::ItemKind::Trait(ast::IsAuto::Yes, ..) => {\n-                gate_feature_post!(&self, optin_builtin_traits,\n-                                   i.span,\n-                                   \"auto traits are experimental and possibly buggy\");\n-            }\n-\n-            ast::ItemKind::TraitAlias(..) => {\n-                gate_feature_post!(\n-                    &self,\n-                    trait_alias,\n-                    i.span,\n-                    \"trait aliases are experimental\"\n-                );\n-            }\n-\n-            ast::ItemKind::MacroDef(ast::MacroDef { legacy: false, .. }) => {\n-                let msg = \"`macro` is experimental\";\n-                gate_feature_post!(&self, decl_macro, i.span, msg);\n-            }\n-\n-            ast::ItemKind::OpaqueTy(..) => {\n-                gate_feature_post!(\n-                    &self,\n-                    type_alias_impl_trait,\n-                    i.span,\n-                    \"`impl Trait` in type aliases is unstable\"\n-                );\n-            }\n-\n-            _ => {}\n-        }\n-\n-        visit::walk_item(self, i);\n-    }\n-\n-    fn visit_foreign_item(&mut self, i: &'a ast::ForeignItem) {\n-        match i.node {\n-            ast::ForeignItemKind::Fn(..) |\n-            ast::ForeignItemKind::Static(..) => {\n-                let link_name = attr::first_attr_value_str_by_name(&i.attrs, sym::link_name);\n-                let links_to_llvm = match link_name {\n-                    Some(val) => val.as_str().starts_with(\"llvm.\"),\n-                    _ => false\n-                };\n-                if links_to_llvm {\n-                    gate_feature_post!(&self, link_llvm_intrinsics, i.span,\n-                                       \"linking to LLVM intrinsics is experimental\");\n-                }\n-            }\n-            ast::ForeignItemKind::Ty => {\n-                    gate_feature_post!(&self, extern_types, i.span,\n-                                       \"extern types are experimental\");\n-            }\n-            ast::ForeignItemKind::Macro(..) => {}\n-        }\n-\n-        visit::walk_foreign_item(self, i)\n-    }\n-\n-    fn visit_ty(&mut self, ty: &'a ast::Ty) {\n-        match ty.node {\n-            ast::TyKind::BareFn(ref bare_fn_ty) => {\n-                self.check_abi(bare_fn_ty.abi, ty.span);\n-            }\n-            ast::TyKind::Never => {\n-                gate_feature_post!(&self, never_type, ty.span,\n-                                   \"The `!` type is experimental\");\n-            }\n-            _ => {}\n-        }\n-        visit::walk_ty(self, ty)\n-    }\n-\n-    fn visit_fn_ret_ty(&mut self, ret_ty: &'a ast::FunctionRetTy) {\n-        if let ast::FunctionRetTy::Ty(ref output_ty) = *ret_ty {\n-            if let ast::TyKind::Never = output_ty.node {\n-                // Do nothing.\n-            } else {\n-                self.visit_ty(output_ty)\n-            }\n-        }\n-    }\n-\n-    fn visit_expr(&mut self, e: &'a ast::Expr) {\n-        match e.node {\n-            ast::ExprKind::Box(_) => {\n-                gate_feature_post!(&self, box_syntax, e.span, EXPLAIN_BOX_SYNTAX);\n-            }\n-            ast::ExprKind::Type(..) => {\n-                // To avoid noise about type ascription in common syntax errors, only emit if it\n-                // is the *only* error.\n-                if self.context.parse_sess.span_diagnostic.err_count() == 0 {\n-                    gate_feature_post!(&self, type_ascription, e.span,\n-                                       \"type ascription is experimental\");\n-                }\n-            }\n-            ast::ExprKind::TryBlock(_) => {\n-                gate_feature_post!(&self, try_blocks, e.span, \"`try` expression is experimental\");\n-            }\n-            ast::ExprKind::Block(_, opt_label) => {\n-                if let Some(label) = opt_label {\n-                    gate_feature_post!(&self, label_break_value, label.ident.span,\n-                                    \"labels on blocks are unstable\");\n-                }\n-            }\n-            _ => {}\n-        }\n-        visit::walk_expr(self, e)\n-    }\n-\n-    fn visit_arm(&mut self, arm: &'a ast::Arm) {\n-        visit::walk_arm(self, arm)\n-    }\n-\n-    fn visit_pat(&mut self, pattern: &'a ast::Pat) {\n-        match &pattern.node {\n-            PatKind::Slice(pats) => {\n-                for pat in &*pats {\n-                    let span = pat.span;\n-                    let inner_pat = match &pat.node {\n-                        PatKind::Ident(.., Some(pat)) => pat,\n-                        _ => pat,\n-                    };\n-                    if inner_pat.is_rest() {\n-                        gate_feature_post!(\n-                            &self,\n-                            slice_patterns,\n-                            span,\n-                            \"subslice patterns are unstable\"\n-                        );\n-                    }\n-                }\n-            }\n-            PatKind::Box(..) => {\n-                gate_feature_post!(&self, box_patterns,\n-                                  pattern.span,\n-                                  \"box pattern syntax is experimental\");\n-            }\n-            PatKind::Range(_, _, Spanned { node: RangeEnd::Excluded, .. }) => {\n-                gate_feature_post!(&self, exclusive_range_pattern, pattern.span,\n-                                   \"exclusive range pattern syntax is experimental\");\n-            }\n-            _ => {}\n-        }\n-        visit::walk_pat(self, pattern)\n-    }\n-\n-    fn visit_fn(&mut self,\n-                fn_kind: FnKind<'a>,\n-                fn_decl: &'a ast::FnDecl,\n-                span: Span,\n-                _node_id: NodeId) {\n-        if let Some(header) = fn_kind.header() {\n-            // Stability of const fn methods are covered in\n-            // `visit_trait_item` and `visit_impl_item` below; this is\n-            // because default methods don't pass through this point.\n-            self.check_abi(header.abi, span);\n-        }\n-\n-        if fn_decl.c_variadic {\n-            gate_feature_post!(&self, c_variadic, span, \"C-variadic functions are unstable\");\n-        }\n-\n-        visit::walk_fn(self, fn_kind, fn_decl, span)\n-    }\n-\n-    fn visit_generic_param(&mut self, param: &'a GenericParam) {\n-        match param.kind {\n-            GenericParamKind::Const { .. } =>\n-                gate_feature_post!(&self, const_generics, param.ident.span,\n-                    \"const generics are unstable\"),\n-            _ => {}\n-        }\n-        visit::walk_generic_param(self, param)\n-    }\n-\n-    fn visit_assoc_ty_constraint(&mut self, constraint: &'a AssocTyConstraint) {\n-        match constraint.kind {\n-            AssocTyConstraintKind::Bound { .. } =>\n-                gate_feature_post!(&self, associated_type_bounds, constraint.span,\n-                    \"associated type bounds are unstable\"),\n-            _ => {}\n-        }\n-        visit::walk_assoc_ty_constraint(self, constraint)\n-    }\n-\n-    fn visit_trait_item(&mut self, ti: &'a ast::TraitItem) {\n-        match ti.node {\n-            ast::TraitItemKind::Method(ref sig, ref block) => {\n-                if block.is_none() {\n-                    self.check_abi(sig.header.abi, ti.span);\n-                }\n-                if sig.decl.c_variadic {\n-                    gate_feature_post!(&self, c_variadic, ti.span,\n-                                       \"C-variadic functions are unstable\");\n-                }\n-                if sig.header.constness.node == ast::Constness::Const {\n-                    gate_feature_post!(&self, const_fn, ti.span, \"const fn is unstable\");\n-                }\n-            }\n-            ast::TraitItemKind::Type(_, ref default) => {\n-                // We use three if statements instead of something like match guards so that all\n-                // of these errors can be emitted if all cases apply.\n-                if default.is_some() {\n-                    gate_feature_post!(&self, associated_type_defaults, ti.span,\n-                                       \"associated type defaults are unstable\");\n-                }\n-                if !ti.generics.params.is_empty() {\n-                    gate_feature_post!(&self, generic_associated_types, ti.span,\n-                                       \"generic associated types are unstable\");\n-                }\n-                if !ti.generics.where_clause.predicates.is_empty() {\n-                    gate_feature_post!(&self, generic_associated_types, ti.span,\n-                                       \"where clauses on associated types are unstable\");\n-                }\n-            }\n-            _ => {}\n-        }\n-        visit::walk_trait_item(self, ti)\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'a ast::ImplItem) {\n-        if ii.defaultness == ast::Defaultness::Default {\n-            gate_feature_post!(&self, specialization,\n-                              ii.span,\n-                              \"specialization is unstable\");\n-        }\n-\n-        match ii.node {\n-            ast::ImplItemKind::Method(..) => {}\n-            ast::ImplItemKind::OpaqueTy(..) => {\n-                gate_feature_post!(\n-                    &self,\n-                    type_alias_impl_trait,\n-                    ii.span,\n-                    \"`impl Trait` in type aliases is unstable\"\n-                );\n-            }\n-            ast::ImplItemKind::TyAlias(_) => {\n-                if !ii.generics.params.is_empty() {\n-                    gate_feature_post!(&self, generic_associated_types, ii.span,\n-                                       \"generic associated types are unstable\");\n-                }\n-                if !ii.generics.where_clause.predicates.is_empty() {\n-                    gate_feature_post!(&self, generic_associated_types, ii.span,\n-                                       \"where clauses on associated types are unstable\");\n-                }\n-            }\n-            _ => {}\n-        }\n-        visit::walk_impl_item(self, ii)\n-    }\n-\n-    fn visit_vis(&mut self, vis: &'a ast::Visibility) {\n-        if let ast::VisibilityKind::Crate(ast::CrateSugar::JustCrate) = vis.node {\n-            gate_feature_post!(&self, crate_visibility_modifier, vis.span,\n-                               \"`crate` visibility modifier is experimental\");\n-        }\n-        visit::walk_vis(self, vis)\n-    }\n-}\n-\n-pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n-                    crate_edition: Edition, allow_features: &Option<Vec<String>>) -> Features {\n-    fn feature_removed(span_handler: &Handler, span: Span, reason: Option<&str>) {\n-        let mut err = struct_span_err!(span_handler, span, E0557, \"feature has been removed\");\n-        if let Some(reason) = reason {\n-            err.span_note(span, reason);\n-        } else {\n-            err.span_label(span, \"feature has been removed\");\n-        }\n-        err.emit();\n-    }\n-\n-    let mut features = Features::new();\n-    let mut edition_enabled_features = FxHashMap::default();\n-\n-    for &edition in ALL_EDITIONS {\n-        if edition <= crate_edition {\n-            // The `crate_edition` implies its respective umbrella feature-gate\n-            // (i.e., `#![feature(rust_20XX_preview)]` isn't needed on edition 20XX).\n-            edition_enabled_features.insert(edition.feature_name(), edition);\n-        }\n-    }\n-\n-    for &(name, .., f_edition, set) in ACTIVE_FEATURES {\n-        if let Some(f_edition) = f_edition {\n-            if f_edition <= crate_edition {\n-                set(&mut features, DUMMY_SP);\n-                edition_enabled_features.insert(name, crate_edition);\n-            }\n-        }\n-    }\n-\n-    // Process the edition umbrella feature-gates first, to ensure\n-    // `edition_enabled_features` is completed before it's queried.\n-    for attr in krate_attrs {\n-        if !attr.check_name(sym::feature) {\n-            continue\n-        }\n-\n-        let list = match attr.meta_item_list() {\n-            Some(list) => list,\n-            None => continue,\n-        };\n-\n-        for mi in list {\n-            if !mi.is_word() {\n-                continue;\n-            }\n-\n-            let name = mi.name_or_empty();\n-\n-            if let Some(edition) = ALL_EDITIONS.iter().find(|e| name == e.feature_name()) {\n-                if *edition <= crate_edition {\n-                    continue;\n-                }\n-\n-                for &(name, .., f_edition, set) in ACTIVE_FEATURES {\n-                    if let Some(f_edition) = f_edition {\n-                        if f_edition <= *edition {\n-                            // FIXME(Manishearth) there is currently no way to set\n-                            // lib features by edition\n-                            set(&mut features, DUMMY_SP);\n-                            edition_enabled_features.insert(name, *edition);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    for attr in krate_attrs {\n-        if !attr.check_name(sym::feature) {\n-            continue\n-        }\n-\n-        let list = match attr.meta_item_list() {\n-            Some(list) => list,\n-            None => continue,\n-        };\n-\n-        let bad_input = |span| {\n-            struct_span_err!(span_handler, span, E0556, \"malformed `feature` attribute input\")\n-        };\n-\n-        for mi in list {\n-            let name = match mi.ident() {\n-                Some(ident) if mi.is_word() => ident.name,\n-                Some(ident) => {\n-                    bad_input(mi.span()).span_suggestion(\n-                        mi.span(),\n-                        \"expected just one word\",\n-                        format!(\"{}\", ident.name),\n-                        Applicability::MaybeIncorrect,\n-                    ).emit();\n-                    continue\n-                }\n-                None => {\n-                    bad_input(mi.span()).span_label(mi.span(), \"expected just one word\").emit();\n-                    continue\n-                }\n-            };\n-\n-            if let Some(edition) = edition_enabled_features.get(&name) {\n-                struct_span_warn!(\n-                    span_handler,\n-                    mi.span(),\n-                    E0705,\n-                    \"the feature `{}` is included in the Rust {} edition\",\n-                    name,\n-                    edition,\n-                ).emit();\n-                continue;\n-            }\n-\n-            if ALL_EDITIONS.iter().any(|e| name == e.feature_name()) {\n-                // Handled in the separate loop above.\n-                continue;\n-            }\n-\n-            let removed = REMOVED_FEATURES.iter().find(|f| name == f.0);\n-            let stable_removed = STABLE_REMOVED_FEATURES.iter().find(|f| name == f.0);\n-            if let Some((.., reason)) = removed.or(stable_removed) {\n-                feature_removed(span_handler, mi.span(), *reason);\n-                continue;\n-            }\n-\n-            if let Some((_, since, ..)) = ACCEPTED_FEATURES.iter().find(|f| name == f.0) {\n-                let since = Some(Symbol::intern(since));\n-                features.declared_lang_features.push((name, mi.span(), since));\n-                continue;\n-            }\n-\n-            if let Some(allowed) = allow_features.as_ref() {\n-                if allowed.iter().find(|f| *f == name.as_str()).is_none() {\n-                    span_err!(span_handler, mi.span(), E0725,\n-                              \"the feature `{}` is not in the list of allowed features\",\n-                              name);\n-                    continue;\n-                }\n-            }\n-\n-            if let Some((.., set)) = ACTIVE_FEATURES.iter().find(|f| name == f.0) {\n-                set(&mut features, mi.span());\n-                features.declared_lang_features.push((name, mi.span(), None));\n-                continue;\n-            }\n-\n-            features.declared_lib_features.push((name, mi.span()));\n-        }\n-    }\n-\n-    features\n-}\n-\n-pub fn check_crate(krate: &ast::Crate,\n-                   sess: &ParseSess,\n-                   features: &Features,\n-                   plugin_attributes: &[(Symbol, AttributeType)],\n-                   unstable: UnstableFeatures) {\n-    maybe_stage_features(&sess.span_diagnostic, krate, unstable);\n-    let ctx = Context {\n-        features,\n-        parse_sess: sess,\n-        plugin_attributes,\n-    };\n-\n-    macro_rules! gate_all {\n-        ($gate:ident, $msg:literal) => { gate_all!($gate, $gate, $msg); };\n-        ($spans:ident, $gate:ident, $msg:literal) => {\n-            for span in &*sess.gated_spans.$spans.borrow() {\n-                gate_feature!(&ctx, $gate, *span, $msg);\n-            }\n-        }\n-    }\n-\n-    gate_all!(param_attrs, \"attributes on function parameters are unstable\");\n-    gate_all!(let_chains, \"`let` expressions in this position are experimental\");\n-    gate_all!(async_closure, \"async closures are unstable\");\n-    gate_all!(yields, generators, \"yield syntax is experimental\");\n-    gate_all!(or_patterns, \"or-patterns syntax is experimental\");\n-\n-    let visitor = &mut PostExpansionVisitor {\n-        context: &ctx,\n-        builtin_attributes: &*BUILTIN_ATTRIBUTE_MAP,\n-    };\n-    visit::walk_crate(visitor, krate);\n-}\n-\n-#[derive(Clone, Copy, Hash)]\n-pub enum UnstableFeatures {\n-    /// Hard errors for unstable features are active, as on beta/stable channels.\n-    Disallow,\n-    /// Allow features to be activated, as on nightly.\n-    Allow,\n-    /// Errors are bypassed for bootstrapping. This is required any time\n-    /// during the build that feature-related lints are set to warn or above\n-    /// because the build turns on warnings-as-errors and uses lots of unstable\n-    /// features. As a result, this is always required for building Rust itself.\n-    Cheat\n-}\n-\n-impl UnstableFeatures {\n-    pub fn from_environment() -> UnstableFeatures {\n-        // Whether this is a feature-staged build, i.e., on the beta or stable channel\n-        let disable_unstable_features = option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_some();\n-        // Whether we should enable unstable features for bootstrapping\n-        let bootstrap = env::var(\"RUSTC_BOOTSTRAP\").is_ok();\n-        match (disable_unstable_features, bootstrap) {\n-            (_, true) => UnstableFeatures::Cheat,\n-            (true, _) => UnstableFeatures::Disallow,\n-            (false, _) => UnstableFeatures::Allow\n-        }\n-    }\n-\n-    pub fn is_nightly_build(&self) -> bool {\n-        match *self {\n-            UnstableFeatures::Allow | UnstableFeatures::Cheat => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n-fn maybe_stage_features(span_handler: &Handler, krate: &ast::Crate,\n-                        unstable: UnstableFeatures) {\n-    let allow_features = match unstable {\n-        UnstableFeatures::Allow => true,\n-        UnstableFeatures::Disallow => false,\n-        UnstableFeatures::Cheat => true\n-    };\n-    if !allow_features {\n-        for attr in &krate.attrs {\n-            if attr.check_name(sym::feature) {\n-                let release_channel = option_env!(\"CFG_RELEASE_CHANNEL\").unwrap_or(\"(unknown)\");\n-                span_err!(span_handler, attr.span, E0554,\n-                          \"`#![feature]` may not be used on the {} release channel\",\n-                          release_channel);\n-            }\n-        }\n-    }\n-}"}, {"sha": "b934f2e7f64efef80dc9b46d4faedaa4a69f30b1", "filename": "src/libsyntax/feature_gate/builtin_attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87eafd6c1b844f4258a2bbd7563c16609c4606e6/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87eafd6c1b844f4258a2bbd7563c16609c4606e6/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs?ref=87eafd6c1b844f4258a2bbd7563c16609c4606e6", "patch": "@@ -3,8 +3,8 @@\n use AttributeType::*;\n use AttributeGate::*;\n \n-use super::{emit_feature_err, GateIssue};\n-use super::{Stability, EXPLAIN_ALLOW_INTERNAL_UNSAFE, EXPLAIN_ALLOW_INTERNAL_UNSTABLE};\n+use super::check::{emit_feature_err, GateIssue};\n+use super::check::{Stability, EXPLAIN_ALLOW_INTERNAL_UNSAFE, EXPLAIN_ALLOW_INTERNAL_UNSTABLE};\n use super::active::Features;\n \n use crate::ast;"}, {"sha": "d82b287b6fb05f693a66e3f58147fd4143b0bd3d", "filename": "src/libsyntax/feature_gate/check.rs", "status": "added", "additions": 951, "deletions": 0, "changes": 951, "blob_url": "https://github.com/rust-lang/rust/blob/87eafd6c1b844f4258a2bbd7563c16609c4606e6/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87eafd6c1b844f4258a2bbd7563c16609c4606e6/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs?ref=87eafd6c1b844f4258a2bbd7563c16609c4606e6", "patch": "@@ -0,0 +1,951 @@\n+use super::active::{ACTIVE_FEATURES, Features};\n+use super::accepted::ACCEPTED_FEATURES;\n+use super::removed::{REMOVED_FEATURES, STABLE_REMOVED_FEATURES};\n+use super::builtin_attrs::{AttributeGate, AttributeType, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n+\n+use crate::ast::{\n+    self, AssocTyConstraint, AssocTyConstraintKind, NodeId, GenericParam, GenericParamKind,\n+    PatKind, RangeEnd,\n+};\n+use crate::attr::{self, check_builtin_attribute};\n+use crate::source_map::Spanned;\n+use crate::edition::{ALL_EDITIONS, Edition};\n+use crate::visit::{self, FnKind, Visitor};\n+use crate::parse::{token, ParseSess};\n+use crate::parse::parser::Parser;\n+use crate::symbol::{Symbol, sym};\n+use crate::tokenstream::TokenTree;\n+\n+use errors::{Applicability, DiagnosticBuilder, Handler};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_target::spec::abi::Abi;\n+use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n+use log::debug;\n+\n+use std::env;\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum Stability {\n+    Unstable,\n+    // First argument is tracking issue link; second argument is an optional\n+    // help message, which defaults to \"remove this attribute\"\n+    Deprecated(&'static str, Option<&'static str>),\n+}\n+\n+struct Context<'a> {\n+    features: &'a Features,\n+    parse_sess: &'a ParseSess,\n+    plugin_attributes: &'a [(Symbol, AttributeType)],\n+}\n+\n+macro_rules! gate_feature_fn {\n+    ($cx: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr, $level: expr) => {{\n+        let (cx, has_feature, span,\n+             name, explain, level) = ($cx, $has_feature, $span, $name, $explain, $level);\n+        let has_feature: bool = has_feature(&$cx.features);\n+        debug!(\"gate_feature(feature = {:?}, span = {:?}); has? {}\", name, span, has_feature);\n+        if !has_feature && !span.allows_unstable($name) {\n+            leveled_feature_err(cx.parse_sess, name, span, GateIssue::Language, explain, level)\n+                .emit();\n+        }\n+    }}\n+}\n+\n+macro_rules! gate_feature {\n+    ($cx: expr, $feature: ident, $span: expr, $explain: expr) => {\n+        gate_feature_fn!($cx, |x:&Features| x.$feature, $span,\n+                         sym::$feature, $explain, GateStrength::Hard)\n+    };\n+    ($cx: expr, $feature: ident, $span: expr, $explain: expr, $level: expr) => {\n+        gate_feature_fn!($cx, |x:&Features| x.$feature, $span,\n+                         sym::$feature, $explain, $level)\n+    };\n+}\n+\n+impl<'a> Context<'a> {\n+    fn check_attribute(\n+        &self,\n+        attr: &ast::Attribute,\n+        attr_info: Option<&BuiltinAttribute>,\n+        is_macro: bool\n+    ) {\n+        debug!(\"check_attribute(attr = {:?})\", attr);\n+        if let Some(&(name, ty, _template, ref gateage)) = attr_info {\n+            if let AttributeGate::Gated(_, name, desc, ref has_feature) = *gateage {\n+                if !attr.span.allows_unstable(name) {\n+                    gate_feature_fn!(\n+                        self, has_feature, attr.span, name, desc, GateStrength::Hard\n+                    );\n+                }\n+            } else if name == sym::doc {\n+                if let Some(content) = attr.meta_item_list() {\n+                    if content.iter().any(|c| c.check_name(sym::include)) {\n+                        gate_feature!(self, external_doc, attr.span,\n+                            \"`#[doc(include = \\\"...\\\")]` is experimental\"\n+                        );\n+                    }\n+                }\n+            }\n+            debug!(\"check_attribute: {:?} is builtin, {:?}, {:?}\", attr.path, ty, gateage);\n+            return;\n+        } else {\n+            for segment in &attr.path.segments {\n+                if segment.ident.as_str().starts_with(\"rustc\") {\n+                    let msg = \"attributes starting with `rustc` are \\\n+                               reserved for use by the `rustc` compiler\";\n+                    gate_feature!(self, rustc_attrs, segment.ident.span, msg);\n+                }\n+            }\n+        }\n+        for &(n, ty) in self.plugin_attributes {\n+            if attr.path == n {\n+                // Plugins can't gate attributes, so we don't check for it\n+                // unlike the code above; we only use this loop to\n+                // short-circuit to avoid the checks below.\n+                debug!(\"check_attribute: {:?} is registered by a plugin, {:?}\", attr.path, ty);\n+                return;\n+            }\n+        }\n+        if !is_macro && !attr::is_known(attr) {\n+            // Only run the custom attribute lint during regular feature gate\n+            // checking. Macro gating runs before the plugin attributes are\n+            // registered, so we skip this in that case.\n+            let msg = format!(\"the attribute `{}` is currently unknown to the compiler and \\\n+                               may have meaning added to it in the future\", attr.path);\n+            gate_feature!(self, custom_attribute, attr.span, &msg);\n+        }\n+    }\n+}\n+\n+pub fn check_attribute(attr: &ast::Attribute, parse_sess: &ParseSess, features: &Features) {\n+    let cx = Context { features, parse_sess, plugin_attributes: &[] };\n+    cx.check_attribute(\n+        attr,\n+        attr.ident().and_then(|ident| BUILTIN_ATTRIBUTE_MAP.get(&ident.name).map(|a| *a)),\n+        true\n+    );\n+}\n+\n+fn find_lang_feature_issue(feature: Symbol) -> Option<u32> {\n+    if let Some(info) = ACTIVE_FEATURES.iter().find(|t| t.0 == feature) {\n+        let issue = info.2;\n+        // FIXME (#28244): enforce that active features have issue numbers\n+        // assert!(issue.is_some())\n+        issue\n+    } else {\n+        // search in Accepted, Removed, or Stable Removed features\n+        let found = ACCEPTED_FEATURES.iter().chain(REMOVED_FEATURES).chain(STABLE_REMOVED_FEATURES)\n+            .find(|t| t.0 == feature);\n+        match found {\n+            Some(&(_, _, issue, _)) => issue,\n+            None => panic!(\"Feature `{}` is not declared anywhere\", feature),\n+        }\n+    }\n+}\n+\n+pub enum GateIssue {\n+    Language,\n+    Library(Option<u32>)\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq)]\n+pub enum GateStrength {\n+    /// A hard error. (Most feature gates should use this.)\n+    Hard,\n+    /// Only a warning. (Use this only as backwards-compatibility demands.)\n+    Soft,\n+}\n+\n+pub fn emit_feature_err(\n+    sess: &ParseSess,\n+    feature: Symbol,\n+    span: Span,\n+    issue: GateIssue,\n+    explain: &str,\n+) {\n+    feature_err(sess, feature, span, issue, explain).emit();\n+}\n+\n+pub fn feature_err<'a, S: Into<MultiSpan>>(\n+    sess: &'a ParseSess,\n+    feature: Symbol,\n+    span: S,\n+    issue: GateIssue,\n+    explain: &str,\n+) -> DiagnosticBuilder<'a> {\n+    leveled_feature_err(sess, feature, span, issue, explain, GateStrength::Hard)\n+}\n+\n+fn leveled_feature_err<'a, S: Into<MultiSpan>>(\n+    sess: &'a ParseSess,\n+    feature: Symbol,\n+    span: S,\n+    issue: GateIssue,\n+    explain: &str,\n+    level: GateStrength,\n+) -> DiagnosticBuilder<'a> {\n+    let diag = &sess.span_diagnostic;\n+\n+    let issue = match issue {\n+        GateIssue::Language => find_lang_feature_issue(feature),\n+        GateIssue::Library(lib) => lib,\n+    };\n+\n+    let mut err = match level {\n+        GateStrength::Hard => {\n+            diag.struct_span_err_with_code(span, explain, stringify_error_code!(E0658))\n+        }\n+        GateStrength::Soft => diag.struct_span_warn(span, explain),\n+    };\n+\n+    match issue {\n+        None | Some(0) => {}  // We still accept `0` as a stand-in for backwards compatibility\n+        Some(n) => {\n+            err.note(&format!(\n+                \"for more information, see https://github.com/rust-lang/rust/issues/{}\",\n+                n,\n+            ));\n+        }\n+    }\n+\n+    // #23973: do not suggest `#![feature(...)]` if we are in beta/stable\n+    if sess.unstable_features.is_nightly_build() {\n+        err.help(&format!(\"add `#![feature({})]` to the crate attributes to enable\", feature));\n+    }\n+\n+    // If we're on stable and only emitting a \"soft\" warning, add a note to\n+    // clarify that the feature isn't \"on\" (rather than being on but\n+    // warning-worthy).\n+    if !sess.unstable_features.is_nightly_build() && level == GateStrength::Soft {\n+        err.help(\"a nightly build of the compiler is required to enable this feature\");\n+    }\n+\n+    err\n+\n+}\n+\n+const EXPLAIN_BOX_SYNTAX: &str =\n+    \"box expression syntax is experimental; you can call `Box::new` instead\";\n+\n+pub const EXPLAIN_STMT_ATTR_SYNTAX: &str =\n+    \"attributes on expressions are experimental\";\n+\n+pub const EXPLAIN_ALLOW_INTERNAL_UNSTABLE: &str =\n+    \"allow_internal_unstable side-steps feature gating and stability checks\";\n+pub const EXPLAIN_ALLOW_INTERNAL_UNSAFE: &str =\n+    \"allow_internal_unsafe side-steps the unsafe_code lint\";\n+\n+pub const EXPLAIN_UNSIZED_TUPLE_COERCION: &str =\n+    \"unsized tuple coercion is not stable enough for use and is subject to change\";\n+\n+struct PostExpansionVisitor<'a> {\n+    context: &'a Context<'a>,\n+    builtin_attributes: &'static FxHashMap<Symbol, &'static BuiltinAttribute>,\n+}\n+\n+macro_rules! gate_feature_post {\n+    ($cx: expr, $feature: ident, $span: expr, $explain: expr) => {{\n+        let (cx, span) = ($cx, $span);\n+        if !span.allows_unstable(sym::$feature) {\n+            gate_feature!(cx.context, $feature, span, $explain)\n+        }\n+    }};\n+    ($cx: expr, $feature: ident, $span: expr, $explain: expr, $level: expr) => {{\n+        let (cx, span) = ($cx, $span);\n+        if !span.allows_unstable(sym::$feature) {\n+            gate_feature!(cx.context, $feature, span, $explain, $level)\n+        }\n+    }}\n+}\n+\n+impl<'a> PostExpansionVisitor<'a> {\n+    fn check_abi(&self, abi: Abi, span: Span) {\n+        match abi {\n+            Abi::RustIntrinsic => {\n+                gate_feature_post!(&self, intrinsics, span,\n+                                   \"intrinsics are subject to change\");\n+            },\n+            Abi::PlatformIntrinsic => {\n+                gate_feature_post!(&self, platform_intrinsics, span,\n+                                   \"platform intrinsics are experimental and possibly buggy\");\n+            },\n+            Abi::Vectorcall => {\n+                gate_feature_post!(&self, abi_vectorcall, span,\n+                                   \"vectorcall is experimental and subject to change\");\n+            },\n+            Abi::Thiscall => {\n+                gate_feature_post!(&self, abi_thiscall, span,\n+                                   \"thiscall is experimental and subject to change\");\n+            },\n+            Abi::RustCall => {\n+                gate_feature_post!(&self, unboxed_closures, span,\n+                                   \"rust-call ABI is subject to change\");\n+            },\n+            Abi::PtxKernel => {\n+                gate_feature_post!(&self, abi_ptx, span,\n+                                   \"PTX ABIs are experimental and subject to change\");\n+            },\n+            Abi::Unadjusted => {\n+                gate_feature_post!(&self, abi_unadjusted, span,\n+                                   \"unadjusted ABI is an implementation detail and perma-unstable\");\n+            },\n+            Abi::Msp430Interrupt => {\n+                gate_feature_post!(&self, abi_msp430_interrupt, span,\n+                                   \"msp430-interrupt ABI is experimental and subject to change\");\n+            },\n+            Abi::X86Interrupt => {\n+                gate_feature_post!(&self, abi_x86_interrupt, span,\n+                                   \"x86-interrupt ABI is experimental and subject to change\");\n+            },\n+            Abi::AmdGpuKernel => {\n+                gate_feature_post!(&self, abi_amdgpu_kernel, span,\n+                                   \"amdgpu-kernel ABI is experimental and subject to change\");\n+            },\n+            // Stable\n+            Abi::Cdecl |\n+            Abi::Stdcall |\n+            Abi::Fastcall |\n+            Abi::Aapcs |\n+            Abi::Win64 |\n+            Abi::SysV64 |\n+            Abi::Rust |\n+            Abi::C |\n+            Abi::System => {}\n+        }\n+    }\n+}\n+\n+impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n+    fn visit_attribute(&mut self, attr: &ast::Attribute) {\n+        let attr_info = attr.ident().and_then(|ident| {\n+            self.builtin_attributes.get(&ident.name).map(|a| *a)\n+        });\n+\n+        // Check for gated attributes.\n+        self.context.check_attribute(attr, attr_info, false);\n+\n+        if attr.check_name(sym::doc) {\n+            if let Some(content) = attr.meta_item_list() {\n+                if content.len() == 1 && content[0].check_name(sym::cfg) {\n+                    gate_feature_post!(&self, doc_cfg, attr.span,\n+                        \"`#[doc(cfg(...))]` is experimental\"\n+                    );\n+                } else if content.iter().any(|c| c.check_name(sym::masked)) {\n+                    gate_feature_post!(&self, doc_masked, attr.span,\n+                        \"`#[doc(masked)]` is experimental\"\n+                    );\n+                } else if content.iter().any(|c| c.check_name(sym::spotlight)) {\n+                    gate_feature_post!(&self, doc_spotlight, attr.span,\n+                        \"`#[doc(spotlight)]` is experimental\"\n+                    );\n+                } else if content.iter().any(|c| c.check_name(sym::alias)) {\n+                    gate_feature_post!(&self, doc_alias, attr.span,\n+                        \"`#[doc(alias = \\\"...\\\")]` is experimental\"\n+                    );\n+                } else if content.iter().any(|c| c.check_name(sym::keyword)) {\n+                    gate_feature_post!(&self, doc_keyword, attr.span,\n+                        \"`#[doc(keyword = \\\"...\\\")]` is experimental\"\n+                    );\n+                }\n+            }\n+        }\n+\n+        match attr_info {\n+            // `rustc_dummy` doesn't have any restrictions specific to built-in attributes.\n+            Some(&(name, _, template, _)) if name != sym::rustc_dummy =>\n+                check_builtin_attribute(self.context.parse_sess, attr, name, template),\n+            _ => if let Some(TokenTree::Token(token)) = attr.tokens.trees().next() {\n+                if token == token::Eq {\n+                    // All key-value attributes are restricted to meta-item syntax.\n+                    attr.parse_meta(self.context.parse_sess).map_err(|mut err| err.emit()).ok();\n+                }\n+            }\n+        }\n+    }\n+\n+    fn visit_name(&mut self, sp: Span, name: ast::Name) {\n+        if !name.as_str().is_ascii() {\n+            gate_feature_post!(\n+                &self,\n+                non_ascii_idents,\n+                self.context.parse_sess.source_map().def_span(sp),\n+                \"non-ascii idents are not fully supported\"\n+            );\n+        }\n+    }\n+\n+    fn visit_item(&mut self, i: &'a ast::Item) {\n+        match i.node {\n+            ast::ItemKind::ForeignMod(ref foreign_module) => {\n+                self.check_abi(foreign_module.abi, i.span);\n+            }\n+\n+            ast::ItemKind::Fn(..) => {\n+                if attr::contains_name(&i.attrs[..], sym::plugin_registrar) {\n+                    gate_feature_post!(&self, plugin_registrar, i.span,\n+                                       \"compiler plugins are experimental and possibly buggy\");\n+                }\n+                if attr::contains_name(&i.attrs[..], sym::start) {\n+                    gate_feature_post!(&self, start, i.span,\n+                                      \"a `#[start]` function is an experimental \\\n+                                       feature whose signature may change \\\n+                                       over time\");\n+                }\n+                if attr::contains_name(&i.attrs[..], sym::main) {\n+                    gate_feature_post!(&self, main, i.span,\n+                                       \"declaration of a non-standard `#[main]` \\\n+                                        function may change over time, for now \\\n+                                        a top-level `fn main()` is required\");\n+                }\n+            }\n+\n+            ast::ItemKind::Struct(..) => {\n+                for attr in attr::filter_by_name(&i.attrs[..], sym::repr) {\n+                    for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n+                        if item.check_name(sym::simd) {\n+                            gate_feature_post!(&self, repr_simd, attr.span,\n+                                               \"SIMD types are experimental and possibly buggy\");\n+                        }\n+                    }\n+                }\n+            }\n+\n+            ast::ItemKind::Enum(ast::EnumDef{ref variants, ..}, ..) => {\n+                for variant in variants {\n+                    match (&variant.data, &variant.disr_expr) {\n+                        (ast::VariantData::Unit(..), _) => {},\n+                        (_, Some(disr_expr)) =>\n+                            gate_feature_post!(\n+                                &self,\n+                                arbitrary_enum_discriminant,\n+                                disr_expr.value.span,\n+                                \"discriminants on non-unit variants are experimental\"),\n+                        _ => {},\n+                    }\n+                }\n+\n+                let has_feature = self.context.features.arbitrary_enum_discriminant;\n+                if !has_feature && !i.span.allows_unstable(sym::arbitrary_enum_discriminant) {\n+                    Parser::maybe_report_invalid_custom_discriminants(\n+                        self.context.parse_sess,\n+                        &variants,\n+                    );\n+                }\n+            }\n+\n+            ast::ItemKind::Impl(_, polarity, defaultness, ..) => {\n+                if polarity == ast::ImplPolarity::Negative {\n+                    gate_feature_post!(&self, optin_builtin_traits,\n+                                       i.span,\n+                                       \"negative trait bounds are not yet fully implemented; \\\n+                                        use marker types for now\");\n+                }\n+\n+                if let ast::Defaultness::Default = defaultness {\n+                    gate_feature_post!(&self, specialization,\n+                                       i.span,\n+                                       \"specialization is unstable\");\n+                }\n+            }\n+\n+            ast::ItemKind::Trait(ast::IsAuto::Yes, ..) => {\n+                gate_feature_post!(&self, optin_builtin_traits,\n+                                   i.span,\n+                                   \"auto traits are experimental and possibly buggy\");\n+            }\n+\n+            ast::ItemKind::TraitAlias(..) => {\n+                gate_feature_post!(\n+                    &self,\n+                    trait_alias,\n+                    i.span,\n+                    \"trait aliases are experimental\"\n+                );\n+            }\n+\n+            ast::ItemKind::MacroDef(ast::MacroDef { legacy: false, .. }) => {\n+                let msg = \"`macro` is experimental\";\n+                gate_feature_post!(&self, decl_macro, i.span, msg);\n+            }\n+\n+            ast::ItemKind::OpaqueTy(..) => {\n+                gate_feature_post!(\n+                    &self,\n+                    type_alias_impl_trait,\n+                    i.span,\n+                    \"`impl Trait` in type aliases is unstable\"\n+                );\n+            }\n+\n+            _ => {}\n+        }\n+\n+        visit::walk_item(self, i);\n+    }\n+\n+    fn visit_foreign_item(&mut self, i: &'a ast::ForeignItem) {\n+        match i.node {\n+            ast::ForeignItemKind::Fn(..) |\n+            ast::ForeignItemKind::Static(..) => {\n+                let link_name = attr::first_attr_value_str_by_name(&i.attrs, sym::link_name);\n+                let links_to_llvm = match link_name {\n+                    Some(val) => val.as_str().starts_with(\"llvm.\"),\n+                    _ => false\n+                };\n+                if links_to_llvm {\n+                    gate_feature_post!(&self, link_llvm_intrinsics, i.span,\n+                                       \"linking to LLVM intrinsics is experimental\");\n+                }\n+            }\n+            ast::ForeignItemKind::Ty => {\n+                    gate_feature_post!(&self, extern_types, i.span,\n+                                       \"extern types are experimental\");\n+            }\n+            ast::ForeignItemKind::Macro(..) => {}\n+        }\n+\n+        visit::walk_foreign_item(self, i)\n+    }\n+\n+    fn visit_ty(&mut self, ty: &'a ast::Ty) {\n+        match ty.node {\n+            ast::TyKind::BareFn(ref bare_fn_ty) => {\n+                self.check_abi(bare_fn_ty.abi, ty.span);\n+            }\n+            ast::TyKind::Never => {\n+                gate_feature_post!(&self, never_type, ty.span,\n+                                   \"The `!` type is experimental\");\n+            }\n+            _ => {}\n+        }\n+        visit::walk_ty(self, ty)\n+    }\n+\n+    fn visit_fn_ret_ty(&mut self, ret_ty: &'a ast::FunctionRetTy) {\n+        if let ast::FunctionRetTy::Ty(ref output_ty) = *ret_ty {\n+            if let ast::TyKind::Never = output_ty.node {\n+                // Do nothing.\n+            } else {\n+                self.visit_ty(output_ty)\n+            }\n+        }\n+    }\n+\n+    fn visit_expr(&mut self, e: &'a ast::Expr) {\n+        match e.node {\n+            ast::ExprKind::Box(_) => {\n+                gate_feature_post!(&self, box_syntax, e.span, EXPLAIN_BOX_SYNTAX);\n+            }\n+            ast::ExprKind::Type(..) => {\n+                // To avoid noise about type ascription in common syntax errors, only emit if it\n+                // is the *only* error.\n+                if self.context.parse_sess.span_diagnostic.err_count() == 0 {\n+                    gate_feature_post!(&self, type_ascription, e.span,\n+                                       \"type ascription is experimental\");\n+                }\n+            }\n+            ast::ExprKind::TryBlock(_) => {\n+                gate_feature_post!(&self, try_blocks, e.span, \"`try` expression is experimental\");\n+            }\n+            ast::ExprKind::Block(_, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    gate_feature_post!(&self, label_break_value, label.ident.span,\n+                                    \"labels on blocks are unstable\");\n+                }\n+            }\n+            _ => {}\n+        }\n+        visit::walk_expr(self, e)\n+    }\n+\n+    fn visit_arm(&mut self, arm: &'a ast::Arm) {\n+        visit::walk_arm(self, arm)\n+    }\n+\n+    fn visit_pat(&mut self, pattern: &'a ast::Pat) {\n+        match &pattern.node {\n+            PatKind::Slice(pats) => {\n+                for pat in &*pats {\n+                    let span = pat.span;\n+                    let inner_pat = match &pat.node {\n+                        PatKind::Ident(.., Some(pat)) => pat,\n+                        _ => pat,\n+                    };\n+                    if inner_pat.is_rest() {\n+                        gate_feature_post!(\n+                            &self,\n+                            slice_patterns,\n+                            span,\n+                            \"subslice patterns are unstable\"\n+                        );\n+                    }\n+                }\n+            }\n+            PatKind::Box(..) => {\n+                gate_feature_post!(&self, box_patterns,\n+                                  pattern.span,\n+                                  \"box pattern syntax is experimental\");\n+            }\n+            PatKind::Range(_, _, Spanned { node: RangeEnd::Excluded, .. }) => {\n+                gate_feature_post!(&self, exclusive_range_pattern, pattern.span,\n+                                   \"exclusive range pattern syntax is experimental\");\n+            }\n+            _ => {}\n+        }\n+        visit::walk_pat(self, pattern)\n+    }\n+\n+    fn visit_fn(&mut self,\n+                fn_kind: FnKind<'a>,\n+                fn_decl: &'a ast::FnDecl,\n+                span: Span,\n+                _node_id: NodeId) {\n+        if let Some(header) = fn_kind.header() {\n+            // Stability of const fn methods are covered in\n+            // `visit_trait_item` and `visit_impl_item` below; this is\n+            // because default methods don't pass through this point.\n+            self.check_abi(header.abi, span);\n+        }\n+\n+        if fn_decl.c_variadic {\n+            gate_feature_post!(&self, c_variadic, span, \"C-variadic functions are unstable\");\n+        }\n+\n+        visit::walk_fn(self, fn_kind, fn_decl, span)\n+    }\n+\n+    fn visit_generic_param(&mut self, param: &'a GenericParam) {\n+        match param.kind {\n+            GenericParamKind::Const { .. } =>\n+                gate_feature_post!(&self, const_generics, param.ident.span,\n+                    \"const generics are unstable\"),\n+            _ => {}\n+        }\n+        visit::walk_generic_param(self, param)\n+    }\n+\n+    fn visit_assoc_ty_constraint(&mut self, constraint: &'a AssocTyConstraint) {\n+        match constraint.kind {\n+            AssocTyConstraintKind::Bound { .. } =>\n+                gate_feature_post!(&self, associated_type_bounds, constraint.span,\n+                    \"associated type bounds are unstable\"),\n+            _ => {}\n+        }\n+        visit::walk_assoc_ty_constraint(self, constraint)\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &'a ast::TraitItem) {\n+        match ti.node {\n+            ast::TraitItemKind::Method(ref sig, ref block) => {\n+                if block.is_none() {\n+                    self.check_abi(sig.header.abi, ti.span);\n+                }\n+                if sig.decl.c_variadic {\n+                    gate_feature_post!(&self, c_variadic, ti.span,\n+                                       \"C-variadic functions are unstable\");\n+                }\n+                if sig.header.constness.node == ast::Constness::Const {\n+                    gate_feature_post!(&self, const_fn, ti.span, \"const fn is unstable\");\n+                }\n+            }\n+            ast::TraitItemKind::Type(_, ref default) => {\n+                // We use three if statements instead of something like match guards so that all\n+                // of these errors can be emitted if all cases apply.\n+                if default.is_some() {\n+                    gate_feature_post!(&self, associated_type_defaults, ti.span,\n+                                       \"associated type defaults are unstable\");\n+                }\n+                if !ti.generics.params.is_empty() {\n+                    gate_feature_post!(&self, generic_associated_types, ti.span,\n+                                       \"generic associated types are unstable\");\n+                }\n+                if !ti.generics.where_clause.predicates.is_empty() {\n+                    gate_feature_post!(&self, generic_associated_types, ti.span,\n+                                       \"where clauses on associated types are unstable\");\n+                }\n+            }\n+            _ => {}\n+        }\n+        visit::walk_trait_item(self, ti)\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'a ast::ImplItem) {\n+        if ii.defaultness == ast::Defaultness::Default {\n+            gate_feature_post!(&self, specialization,\n+                              ii.span,\n+                              \"specialization is unstable\");\n+        }\n+\n+        match ii.node {\n+            ast::ImplItemKind::Method(..) => {}\n+            ast::ImplItemKind::OpaqueTy(..) => {\n+                gate_feature_post!(\n+                    &self,\n+                    type_alias_impl_trait,\n+                    ii.span,\n+                    \"`impl Trait` in type aliases is unstable\"\n+                );\n+            }\n+            ast::ImplItemKind::TyAlias(_) => {\n+                if !ii.generics.params.is_empty() {\n+                    gate_feature_post!(&self, generic_associated_types, ii.span,\n+                                       \"generic associated types are unstable\");\n+                }\n+                if !ii.generics.where_clause.predicates.is_empty() {\n+                    gate_feature_post!(&self, generic_associated_types, ii.span,\n+                                       \"where clauses on associated types are unstable\");\n+                }\n+            }\n+            _ => {}\n+        }\n+        visit::walk_impl_item(self, ii)\n+    }\n+\n+    fn visit_vis(&mut self, vis: &'a ast::Visibility) {\n+        if let ast::VisibilityKind::Crate(ast::CrateSugar::JustCrate) = vis.node {\n+            gate_feature_post!(&self, crate_visibility_modifier, vis.span,\n+                               \"`crate` visibility modifier is experimental\");\n+        }\n+        visit::walk_vis(self, vis)\n+    }\n+}\n+\n+pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n+                    crate_edition: Edition, allow_features: &Option<Vec<String>>) -> Features {\n+    fn feature_removed(span_handler: &Handler, span: Span, reason: Option<&str>) {\n+        let mut err = struct_span_err!(span_handler, span, E0557, \"feature has been removed\");\n+        if let Some(reason) = reason {\n+            err.span_note(span, reason);\n+        } else {\n+            err.span_label(span, \"feature has been removed\");\n+        }\n+        err.emit();\n+    }\n+\n+    let mut features = Features::new();\n+    let mut edition_enabled_features = FxHashMap::default();\n+\n+    for &edition in ALL_EDITIONS {\n+        if edition <= crate_edition {\n+            // The `crate_edition` implies its respective umbrella feature-gate\n+            // (i.e., `#![feature(rust_20XX_preview)]` isn't needed on edition 20XX).\n+            edition_enabled_features.insert(edition.feature_name(), edition);\n+        }\n+    }\n+\n+    for &(name, .., f_edition, set) in ACTIVE_FEATURES {\n+        if let Some(f_edition) = f_edition {\n+            if f_edition <= crate_edition {\n+                set(&mut features, DUMMY_SP);\n+                edition_enabled_features.insert(name, crate_edition);\n+            }\n+        }\n+    }\n+\n+    // Process the edition umbrella feature-gates first, to ensure\n+    // `edition_enabled_features` is completed before it's queried.\n+    for attr in krate_attrs {\n+        if !attr.check_name(sym::feature) {\n+            continue\n+        }\n+\n+        let list = match attr.meta_item_list() {\n+            Some(list) => list,\n+            None => continue,\n+        };\n+\n+        for mi in list {\n+            if !mi.is_word() {\n+                continue;\n+            }\n+\n+            let name = mi.name_or_empty();\n+\n+            if let Some(edition) = ALL_EDITIONS.iter().find(|e| name == e.feature_name()) {\n+                if *edition <= crate_edition {\n+                    continue;\n+                }\n+\n+                for &(name, .., f_edition, set) in ACTIVE_FEATURES {\n+                    if let Some(f_edition) = f_edition {\n+                        if f_edition <= *edition {\n+                            // FIXME(Manishearth) there is currently no way to set\n+                            // lib features by edition\n+                            set(&mut features, DUMMY_SP);\n+                            edition_enabled_features.insert(name, *edition);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    for attr in krate_attrs {\n+        if !attr.check_name(sym::feature) {\n+            continue\n+        }\n+\n+        let list = match attr.meta_item_list() {\n+            Some(list) => list,\n+            None => continue,\n+        };\n+\n+        let bad_input = |span| {\n+            struct_span_err!(span_handler, span, E0556, \"malformed `feature` attribute input\")\n+        };\n+\n+        for mi in list {\n+            let name = match mi.ident() {\n+                Some(ident) if mi.is_word() => ident.name,\n+                Some(ident) => {\n+                    bad_input(mi.span()).span_suggestion(\n+                        mi.span(),\n+                        \"expected just one word\",\n+                        format!(\"{}\", ident.name),\n+                        Applicability::MaybeIncorrect,\n+                    ).emit();\n+                    continue\n+                }\n+                None => {\n+                    bad_input(mi.span()).span_label(mi.span(), \"expected just one word\").emit();\n+                    continue\n+                }\n+            };\n+\n+            if let Some(edition) = edition_enabled_features.get(&name) {\n+                struct_span_warn!(\n+                    span_handler,\n+                    mi.span(),\n+                    E0705,\n+                    \"the feature `{}` is included in the Rust {} edition\",\n+                    name,\n+                    edition,\n+                ).emit();\n+                continue;\n+            }\n+\n+            if ALL_EDITIONS.iter().any(|e| name == e.feature_name()) {\n+                // Handled in the separate loop above.\n+                continue;\n+            }\n+\n+            let removed = REMOVED_FEATURES.iter().find(|f| name == f.0);\n+            let stable_removed = STABLE_REMOVED_FEATURES.iter().find(|f| name == f.0);\n+            if let Some((.., reason)) = removed.or(stable_removed) {\n+                feature_removed(span_handler, mi.span(), *reason);\n+                continue;\n+            }\n+\n+            if let Some((_, since, ..)) = ACCEPTED_FEATURES.iter().find(|f| name == f.0) {\n+                let since = Some(Symbol::intern(since));\n+                features.declared_lang_features.push((name, mi.span(), since));\n+                continue;\n+            }\n+\n+            if let Some(allowed) = allow_features.as_ref() {\n+                if allowed.iter().find(|f| *f == name.as_str()).is_none() {\n+                    span_err!(span_handler, mi.span(), E0725,\n+                              \"the feature `{}` is not in the list of allowed features\",\n+                              name);\n+                    continue;\n+                }\n+            }\n+\n+            if let Some((.., set)) = ACTIVE_FEATURES.iter().find(|f| name == f.0) {\n+                set(&mut features, mi.span());\n+                features.declared_lang_features.push((name, mi.span(), None));\n+                continue;\n+            }\n+\n+            features.declared_lib_features.push((name, mi.span()));\n+        }\n+    }\n+\n+    features\n+}\n+\n+pub fn check_crate(krate: &ast::Crate,\n+                   sess: &ParseSess,\n+                   features: &Features,\n+                   plugin_attributes: &[(Symbol, AttributeType)],\n+                   unstable: UnstableFeatures) {\n+    maybe_stage_features(&sess.span_diagnostic, krate, unstable);\n+    let ctx = Context {\n+        features,\n+        parse_sess: sess,\n+        plugin_attributes,\n+    };\n+\n+    macro_rules! gate_all {\n+        ($gate:ident, $msg:literal) => { gate_all!($gate, $gate, $msg); };\n+        ($spans:ident, $gate:ident, $msg:literal) => {\n+            for span in &*sess.gated_spans.$spans.borrow() {\n+                gate_feature!(&ctx, $gate, *span, $msg);\n+            }\n+        }\n+    }\n+\n+    gate_all!(param_attrs, \"attributes on function parameters are unstable\");\n+    gate_all!(let_chains, \"`let` expressions in this position are experimental\");\n+    gate_all!(async_closure, \"async closures are unstable\");\n+    gate_all!(yields, generators, \"yield syntax is experimental\");\n+    gate_all!(or_patterns, \"or-patterns syntax is experimental\");\n+\n+    let visitor = &mut PostExpansionVisitor {\n+        context: &ctx,\n+        builtin_attributes: &*BUILTIN_ATTRIBUTE_MAP,\n+    };\n+    visit::walk_crate(visitor, krate);\n+}\n+\n+#[derive(Clone, Copy, Hash)]\n+pub enum UnstableFeatures {\n+    /// Hard errors for unstable features are active, as on beta/stable channels.\n+    Disallow,\n+    /// Allow features to be activated, as on nightly.\n+    Allow,\n+    /// Errors are bypassed for bootstrapping. This is required any time\n+    /// during the build that feature-related lints are set to warn or above\n+    /// because the build turns on warnings-as-errors and uses lots of unstable\n+    /// features. As a result, this is always required for building Rust itself.\n+    Cheat\n+}\n+\n+impl UnstableFeatures {\n+    pub fn from_environment() -> UnstableFeatures {\n+        // Whether this is a feature-staged build, i.e., on the beta or stable channel\n+        let disable_unstable_features = option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_some();\n+        // Whether we should enable unstable features for bootstrapping\n+        let bootstrap = env::var(\"RUSTC_BOOTSTRAP\").is_ok();\n+        match (disable_unstable_features, bootstrap) {\n+            (_, true) => UnstableFeatures::Cheat,\n+            (true, _) => UnstableFeatures::Disallow,\n+            (false, _) => UnstableFeatures::Allow\n+        }\n+    }\n+\n+    pub fn is_nightly_build(&self) -> bool {\n+        match *self {\n+            UnstableFeatures::Allow | UnstableFeatures::Cheat => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+fn maybe_stage_features(span_handler: &Handler, krate: &ast::Crate, unstable: UnstableFeatures) {\n+    let allow_features = match unstable {\n+        UnstableFeatures::Allow => true,\n+        UnstableFeatures::Disallow => false,\n+        UnstableFeatures::Cheat => true\n+    };\n+    if !allow_features {\n+        for attr in &krate.attrs {\n+            if attr.check_name(sym::feature) {\n+                let release_channel = option_env!(\"CFG_RELEASE_CHANNEL\").unwrap_or(\"(unknown)\");\n+                span_err!(span_handler, attr.span, E0554,\n+                          \"`#![feature]` may not be used on the {} release channel\",\n+                          release_channel);\n+            }\n+        }\n+    }\n+}"}]}