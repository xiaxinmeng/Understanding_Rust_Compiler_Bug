{"sha": "ef884bcb932e78d7ed353d9c04b8261cf0c37fdb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmODg0YmNiOTMyZTc4ZDdlZDM1M2Q5YzA0YjgyNjFjZjBjMzdmZGI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-04-25T20:51:06Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-05-06T19:27:29Z"}, "message": "use methods for EarlyProps and TestProps", "tree": {"sha": "8fb529fde51f9f656464c4eba176e5e09d1f7d75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8fb529fde51f9f656464c4eba176e5e09d1f7d75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef884bcb932e78d7ed353d9c04b8261cf0c37fdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef884bcb932e78d7ed353d9c04b8261cf0c37fdb", "html_url": "https://github.com/rust-lang/rust/commit/ef884bcb932e78d7ed353d9c04b8261cf0c37fdb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef884bcb932e78d7ed353d9c04b8261cf0c37fdb/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "514b37e3d6810abcc511838a4f238afaa247e700", "url": "https://api.github.com/repos/rust-lang/rust/commits/514b37e3d6810abcc511838a4f238afaa247e700", "html_url": "https://github.com/rust-lang/rust/commit/514b37e3d6810abcc511838a4f238afaa247e700"}], "stats": {"total": 434, "additions": 220, "deletions": 214}, "files": [{"sha": "d75b3b71a99d6f17273db2356fda2d1febb98861", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 212, "deletions": 206, "changes": 418, "blob_url": "https://github.com/rust-lang/rust/blob/ef884bcb932e78d7ed353d9c04b8261cf0c37fdb/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef884bcb932e78d7ed353d9c04b8261cf0c37fdb/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=ef884bcb932e78d7ed353d9c04b8261cf0c37fdb", "patch": "@@ -18,6 +18,111 @@ use common::Config;\n use common;\n use util;\n \n+/// Properties which must be known very early, before actually running\n+/// the test.\n+pub struct EarlyProps {\n+    pub ignore: bool,\n+    pub should_fail: bool,\n+}\n+\n+impl EarlyProps {\n+    pub fn from_file(config: &Config, testfile: &Path) -> Self {\n+        let mut props = EarlyProps {\n+            ignore: false,\n+            should_fail: false,\n+        };\n+\n+        iter_header(testfile, None, &mut |ln| {\n+            props.ignore =\n+                props.ignore ||\n+                parse_name_directive(ln, \"ignore-test\") ||\n+                parse_name_directive(ln, &ignore_target(config)) ||\n+                parse_name_directive(ln, &ignore_architecture(config)) ||\n+                parse_name_directive(ln, &ignore_stage(config)) ||\n+                parse_name_directive(ln, &ignore_env(config)) ||\n+                (config.mode == common::Pretty &&\n+                 parse_name_directive(ln, \"ignore-pretty\")) ||\n+                (config.target != config.host &&\n+                 parse_name_directive(ln, \"ignore-cross-compile\")) ||\n+                ignore_gdb(config, ln) ||\n+                ignore_lldb(config, ln);\n+\n+            props.should_fail =\n+                props.should_fail ||\n+                parse_name_directive(ln, \"should-fail\");\n+        });\n+\n+        return props;\n+\n+        fn ignore_target(config: &Config) -> String {\n+            format!(\"ignore-{}\", util::get_os(&config.target))\n+        }\n+        fn ignore_architecture(config: &Config) -> String {\n+            format!(\"ignore-{}\", util::get_arch(&config.target))\n+        }\n+        fn ignore_stage(config: &Config) -> String {\n+            format!(\"ignore-{}\",\n+                    config.stage_id.split('-').next().unwrap())\n+        }\n+        fn ignore_env(config: &Config) -> String {\n+            format!(\"ignore-{}\", util::get_env(&config.target).unwrap_or(\"<unknown>\"))\n+        }\n+        fn ignore_gdb(config: &Config, line: &str) -> bool {\n+            if config.mode != common::DebugInfoGdb {\n+                return false;\n+            }\n+\n+            if parse_name_directive(line, \"ignore-gdb\") {\n+                return true;\n+            }\n+\n+            if let Some(ref actual_version) = config.gdb_version {\n+                if line.contains(\"min-gdb-version\") {\n+                    let min_version = line.trim()\n+                                          .split(' ')\n+                                          .last()\n+                                          .expect(\"Malformed GDB version directive\");\n+                    // Ignore if actual version is smaller the minimum required\n+                    // version\n+                    gdb_version_to_int(actual_version) <\n+                        gdb_version_to_int(min_version)\n+                } else {\n+                    false\n+                }\n+            } else {\n+                false\n+            }\n+        }\n+\n+        fn ignore_lldb(config: &Config, line: &str) -> bool {\n+            if config.mode != common::DebugInfoLldb {\n+                return false;\n+            }\n+\n+            if parse_name_directive(line, \"ignore-lldb\") {\n+                return true;\n+            }\n+\n+            if let Some(ref actual_version) = config.lldb_version {\n+                if line.contains(\"min-lldb-version\") {\n+                    let min_version = line.trim()\n+                                          .split(' ')\n+                                          .last()\n+                                          .expect(\"Malformed lldb version directive\");\n+                    // Ignore if actual version is smaller the minimum required\n+                    // version\n+                    lldb_version_to_int(actual_version) <\n+                        lldb_version_to_int(min_version)\n+                } else {\n+                    false\n+                }\n+            } else {\n+                false\n+            }\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n pub struct TestProps {\n     // Lines that should be expected, in order, on standard out\n@@ -57,233 +162,134 @@ pub struct TestProps {\n     pub revisions: Vec<String>,\n }\n \n-// Load any test directives embedded in the file\n-pub fn load_props(testfile: &Path) -> TestProps {\n-    let error_patterns = Vec::new();\n-    let aux_builds = Vec::new();\n-    let exec_env = Vec::new();\n-    let run_flags = None;\n-    let pp_exact = None;\n-    let check_lines = Vec::new();\n-    let build_aux_docs = false;\n-    let force_host = false;\n-    let check_stdout = false;\n-    let no_prefer_dynamic = false;\n-    let pretty_expanded = false;\n-    let pretty_compare_only = false;\n-    let forbid_output = Vec::new();\n-    let mut props = TestProps {\n-        error_patterns: error_patterns,\n-        compile_flags: vec![],\n-        run_flags: run_flags,\n-        pp_exact: pp_exact,\n-        aux_builds: aux_builds,\n-        revisions: vec![],\n-        rustc_env: vec![],\n-        exec_env: exec_env,\n-        check_lines: check_lines,\n-        build_aux_docs: build_aux_docs,\n-        force_host: force_host,\n-        check_stdout: check_stdout,\n-        no_prefer_dynamic: no_prefer_dynamic,\n-        pretty_expanded: pretty_expanded,\n-        pretty_mode: format!(\"normal\"),\n-        pretty_compare_only: pretty_compare_only,\n-        forbid_output: forbid_output,\n-    };\n-    load_props_into(&mut props, testfile, None);\n-    props\n-}\n-\n-/// Load properties from `testfile` into `props`. If a property is\n-/// tied to a particular revision `foo` (indicated by writing\n-/// `//[foo]`), then the property is ignored unless `cfg` is\n-/// `Some(\"foo\")`.\n-pub fn load_props_into(props: &mut TestProps, testfile: &Path, cfg: Option<&str>)  {\n-    iter_header(testfile, cfg, &mut |ln| {\n-        if let Some(ep) = parse_error_pattern(ln) {\n-            props.error_patterns.push(ep);\n-        }\n-\n-        if let Some(flags) = parse_compile_flags(ln) {\n-            props.compile_flags.extend(\n-                flags\n-                    .split_whitespace()\n-                    .map(|s| s.to_owned()));\n-        }\n-\n-        if let Some(r) = parse_revisions(ln) {\n-            props.revisions.extend(r);\n-        }\n-\n-        if props.run_flags.is_none() {\n-            props.run_flags = parse_run_flags(ln);\n-        }\n-\n-        if props.pp_exact.is_none() {\n-            props.pp_exact = parse_pp_exact(ln, testfile);\n-        }\n-\n-        if !props.build_aux_docs {\n-            props.build_aux_docs = parse_build_aux_docs(ln);\n+impl TestProps {\n+    pub fn new() -> Self {\n+        let error_patterns = Vec::new();\n+        let aux_builds = Vec::new();\n+        let exec_env = Vec::new();\n+        let run_flags = None;\n+        let pp_exact = None;\n+        let check_lines = Vec::new();\n+        let build_aux_docs = false;\n+        let force_host = false;\n+        let check_stdout = false;\n+        let no_prefer_dynamic = false;\n+        let pretty_expanded = false;\n+        let pretty_compare_only = false;\n+        let forbid_output = Vec::new();\n+        TestProps {\n+            error_patterns: error_patterns,\n+            compile_flags: vec![],\n+            run_flags: run_flags,\n+            pp_exact: pp_exact,\n+            aux_builds: aux_builds,\n+            revisions: vec![],\n+            rustc_env: vec![],\n+            exec_env: exec_env,\n+            check_lines: check_lines,\n+            build_aux_docs: build_aux_docs,\n+            force_host: force_host,\n+            check_stdout: check_stdout,\n+            no_prefer_dynamic: no_prefer_dynamic,\n+            pretty_expanded: pretty_expanded,\n+            pretty_mode: format!(\"normal\"),\n+            pretty_compare_only: pretty_compare_only,\n+            forbid_output: forbid_output,\n         }\n+    }\n \n-        if !props.force_host {\n-            props.force_host = parse_force_host(ln);\n-        }\n+    pub fn from_file(testfile: &Path) -> Self {\n+        let mut props = TestProps::new();\n+        props.load_from(testfile, None);\n+        props\n+    }\n \n-        if !props.check_stdout {\n-            props.check_stdout = parse_check_stdout(ln);\n-        }\n+    /// Load properties from `testfile` into `props`. If a property is\n+    /// tied to a particular revision `foo` (indicated by writing\n+    /// `//[foo]`), then the property is ignored unless `cfg` is\n+    /// `Some(\"foo\")`.\n+    pub fn load_from(&mut self, testfile: &Path, cfg: Option<&str>)  {\n+        iter_header(testfile, cfg, &mut |ln| {\n+            if let Some(ep) = parse_error_pattern(ln) {\n+                self.error_patterns.push(ep);\n+            }\n \n-        if !props.no_prefer_dynamic {\n-            props.no_prefer_dynamic = parse_no_prefer_dynamic(ln);\n-        }\n+            if let Some(flags) = parse_compile_flags(ln) {\n+                self.compile_flags.extend(\n+                    flags\n+                        .split_whitespace()\n+                        .map(|s| s.to_owned()));\n+            }\n \n-        if !props.pretty_expanded {\n-            props.pretty_expanded = parse_pretty_expanded(ln);\n-        }\n+            if let Some(r) = parse_revisions(ln) {\n+                self.revisions.extend(r);\n+            }\n \n-        if let Some(m) = parse_pretty_mode(ln) {\n-            props.pretty_mode = m;\n-        }\n+            if self.run_flags.is_none() {\n+                self.run_flags = parse_run_flags(ln);\n+            }\n \n-        if !props.pretty_compare_only {\n-            props.pretty_compare_only = parse_pretty_compare_only(ln);\n-        }\n+            if self.pp_exact.is_none() {\n+                self.pp_exact = parse_pp_exact(ln, testfile);\n+            }\n \n-        if let  Some(ab) = parse_aux_build(ln) {\n-            props.aux_builds.push(ab);\n-        }\n+            if !self.build_aux_docs {\n+                self.build_aux_docs = parse_build_aux_docs(ln);\n+            }\n \n-        if let Some(ee) = parse_env(ln, \"exec-env\") {\n-            props.exec_env.push(ee);\n-        }\n+            if !self.force_host {\n+                self.force_host = parse_force_host(ln);\n+            }\n \n-        if let Some(ee) = parse_env(ln, \"rustc-env\") {\n-            props.rustc_env.push(ee);\n-        }\n+            if !self.check_stdout {\n+                self.check_stdout = parse_check_stdout(ln);\n+            }\n \n-        if let Some(cl) =  parse_check_line(ln) {\n-            props.check_lines.push(cl);\n-        }\n+            if !self.no_prefer_dynamic {\n+                self.no_prefer_dynamic = parse_no_prefer_dynamic(ln);\n+            }\n \n-        if let Some(of) = parse_forbid_output(ln) {\n-            props.forbid_output.push(of);\n-        }\n-    });\n-\n-    for key in vec![\"RUST_TEST_NOCAPTURE\", \"RUST_TEST_THREADS\"] {\n-        match env::var(key) {\n-            Ok(val) =>\n-                if props.exec_env.iter().find(|&&(ref x, _)| *x == key).is_none() {\n-                    props.exec_env.push((key.to_owned(), val))\n-                },\n-            Err(..) => {}\n-        }\n-    }\n-}\n+            if !self.pretty_expanded {\n+                self.pretty_expanded = parse_pretty_expanded(ln);\n+            }\n \n-pub struct EarlyProps {\n-    pub ignore: bool,\n-    pub should_fail: bool,\n-}\n+            if let Some(m) = parse_pretty_mode(ln) {\n+                self.pretty_mode = m;\n+            }\n \n-// scan the file to detect whether the test should be ignored and\n-// whether it should panic; these are two things the test runner needs\n-// to know early, before actually running the test\n-pub fn early_props(config: &Config, testfile: &Path) -> EarlyProps {\n-    let mut props = EarlyProps {\n-        ignore: false,\n-        should_fail: false,\n-    };\n-\n-    iter_header(testfile, None, &mut |ln| {\n-        props.ignore =\n-            props.ignore ||\n-            parse_name_directive(ln, \"ignore-test\") ||\n-            parse_name_directive(ln, &ignore_target(config)) ||\n-            parse_name_directive(ln, &ignore_architecture(config)) ||\n-            parse_name_directive(ln, &ignore_stage(config)) ||\n-            parse_name_directive(ln, &ignore_env(config)) ||\n-            (config.mode == common::Pretty &&\n-             parse_name_directive(ln, \"ignore-pretty\")) ||\n-            (config.target != config.host &&\n-             parse_name_directive(ln, \"ignore-cross-compile\")) ||\n-            ignore_gdb(config, ln) ||\n-            ignore_lldb(config, ln);\n-\n-        props.should_fail =\n-            props.should_fail ||\n-            parse_name_directive(ln, \"should-fail\");\n-    });\n-\n-    return props;\n-\n-    fn ignore_target(config: &Config) -> String {\n-        format!(\"ignore-{}\", util::get_os(&config.target))\n-    }\n-    fn ignore_architecture(config: &Config) -> String {\n-        format!(\"ignore-{}\", util::get_arch(&config.target))\n-    }\n-    fn ignore_stage(config: &Config) -> String {\n-        format!(\"ignore-{}\",\n-                config.stage_id.split('-').next().unwrap())\n-    }\n-    fn ignore_env(config: &Config) -> String {\n-        format!(\"ignore-{}\", util::get_env(&config.target).unwrap_or(\"<unknown>\"))\n-    }\n-    fn ignore_gdb(config: &Config, line: &str) -> bool {\n-        if config.mode != common::DebugInfoGdb {\n-            return false;\n-        }\n+            if !self.pretty_compare_only {\n+                self.pretty_compare_only = parse_pretty_compare_only(ln);\n+            }\n \n-        if parse_name_directive(line, \"ignore-gdb\") {\n-            return true;\n-        }\n+            if let  Some(ab) = parse_aux_build(ln) {\n+                self.aux_builds.push(ab);\n+            }\n \n-        if let Some(ref actual_version) = config.gdb_version {\n-            if line.contains(\"min-gdb-version\") {\n-                let min_version = line.trim()\n-                                      .split(' ')\n-                                      .last()\n-                                      .expect(\"Malformed GDB version directive\");\n-                // Ignore if actual version is smaller the minimum required\n-                // version\n-                gdb_version_to_int(actual_version) <\n-                    gdb_version_to_int(min_version)\n-            } else {\n-                false\n+            if let Some(ee) = parse_env(ln, \"exec-env\") {\n+                self.exec_env.push(ee);\n             }\n-        } else {\n-            false\n-        }\n-    }\n \n-    fn ignore_lldb(config: &Config, line: &str) -> bool {\n-        if config.mode != common::DebugInfoLldb {\n-            return false;\n-        }\n+            if let Some(ee) = parse_env(ln, \"rustc-env\") {\n+                self.rustc_env.push(ee);\n+            }\n \n-        if parse_name_directive(line, \"ignore-lldb\") {\n-            return true;\n-        }\n+            if let Some(cl) =  parse_check_line(ln) {\n+                self.check_lines.push(cl);\n+            }\n \n-        if let Some(ref actual_version) = config.lldb_version {\n-            if line.contains(\"min-lldb-version\") {\n-                let min_version = line.trim()\n-                                      .split(' ')\n-                                      .last()\n-                                      .expect(\"Malformed lldb version directive\");\n-                // Ignore if actual version is smaller the minimum required\n-                // version\n-                lldb_version_to_int(actual_version) <\n-                    lldb_version_to_int(min_version)\n-            } else {\n-                false\n+            if let Some(of) = parse_forbid_output(ln) {\n+                self.forbid_output.push(of);\n+            }\n+        });\n+\n+        for key in vec![\"RUST_TEST_NOCAPTURE\", \"RUST_TEST_THREADS\"] {\n+            match env::var(key) {\n+                Ok(val) =>\n+                    if self.exec_env.iter().find(|&&(ref x, _)| *x == key).is_none() {\n+                        self.exec_env.push((key.to_owned(), val))\n+                    },\n+                Err(..) => {}\n             }\n-        } else {\n-            false\n         }\n     }\n }"}, {"sha": "45c69eec54251e100302cd7fc67153f5898851fe", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef884bcb932e78d7ed353d9c04b8261cf0c37fdb/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef884bcb932e78d7ed353d9c04b8261cf0c37fdb/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=ef884bcb932e78d7ed353d9c04b8261cf0c37fdb", "patch": "@@ -39,6 +39,8 @@ use common::{Pretty, DebugInfoGdb, DebugInfoLldb, Mode};\n use test::TestPaths;\n use util::logv;\n \n+use self::header::EarlyProps;\n+\n pub mod procsrv;\n pub mod util;\n mod json;\n@@ -394,7 +396,7 @@ pub fn is_test(config: &Config, testfile: &Path) -> bool {\n }\n \n pub fn make_test(config: &Config, testpaths: &TestPaths) -> test::TestDescAndFn {\n-    let early_props = header::early_props(config, &testpaths.file);\n+    let early_props = EarlyProps::from_file(config, &testpaths.file);\n \n     // The `should-fail` annotation doesn't apply to pretty tests,\n     // since we run the pretty printer across all tests by default."}, {"sha": "29a5fef43914c9a677675678c8f5264909ef07b9", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ef884bcb932e78d7ed353d9c04b8261cf0c37fdb/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef884bcb932e78d7ed353d9c04b8261cf0c37fdb/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=ef884bcb932e78d7ed353d9c04b8261cf0c37fdb", "patch": "@@ -47,7 +47,7 @@ pub fn run(config: Config, testpaths: &TestPaths) {\n         print!(\"\\n\\n\");\n     }\n     debug!(\"running {:?}\", testpaths.file.display());\n-    let props = header::load_props(&testpaths.file);\n+    let props = TestProps::from_file(&testpaths.file);\n     debug!(\"loaded props\");\n     match config.mode {\n         CompileFail => run_cfail_test(&config, &props, &testpaths),\n@@ -84,9 +84,7 @@ fn for_each_revision<OP>(config: &Config, props: &TestProps, testpaths: &TestPat\n     } else {\n         for revision in &props.revisions {\n             let mut revision_props = props.clone();\n-            header::load_props_into(&mut revision_props,\n-                                    &testpaths.file,\n-                                    Some(&revision));\n+            revision_props.load_from(&testpaths.file, Some(&revision));\n             revision_props.compile_flags.extend(vec![\n                 format!(\"--cfg\"),\n                 format!(\"{}\", revision),\n@@ -1174,7 +1172,7 @@ fn document(config: &Config,\n     if props.build_aux_docs {\n         for rel_ab in &props.aux_builds {\n             let aux_testpaths = compute_aux_test_paths(config, testpaths, rel_ab);\n-            let aux_props = header::load_props(&aux_testpaths.file);\n+            let aux_props = TestProps::from_file(&aux_testpaths.file);\n             let auxres = document(config, &aux_props, &aux_testpaths, out_dir);\n             if !auxres.status.success() {\n                 return auxres;\n@@ -1249,7 +1247,7 @@ fn compose_and_run_compiler(config: &Config, props: &TestProps,\n \n     for rel_ab in &props.aux_builds {\n         let aux_testpaths = compute_aux_test_paths(config, testpaths, rel_ab);\n-        let aux_props = header::load_props(&aux_testpaths.file);\n+        let aux_props = TestProps::from_file(&aux_testpaths.file);\n         let mut crate_type = if aux_props.no_prefer_dynamic {\n             Vec::new()\n         } else {\n@@ -2044,7 +2042,7 @@ fn run_incremental_test(config: &Config, props: &TestProps, testpaths: &TestPath\n \n     for revision in &props.revisions {\n         let mut revision_props = props.clone();\n-        header::load_props_into(&mut revision_props, &testpaths.file, Some(&revision));\n+        revision_props.load_from(&testpaths.file, Some(&revision));\n \n         revision_props.compile_flags.extend(vec![\n             format!(\"-Z\"),"}]}