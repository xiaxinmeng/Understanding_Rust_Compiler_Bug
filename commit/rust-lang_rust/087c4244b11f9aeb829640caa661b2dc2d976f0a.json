{"sha": "087c4244b11f9aeb829640caa661b2dc2d976f0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4N2M0MjQ0YjExZjlhZWI4Mjk2NDBjYWE2NjFiMmRjMmQ5NzZmMGE=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-06-27T22:59:04Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-29T22:41:56Z"}, "message": "std: adding some basic docs for net::ip::get_addr", "tree": {"sha": "a57f881f9075ef01e7c32b634c65fdfd7d7796dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a57f881f9075ef01e7c32b634c65fdfd7d7796dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/087c4244b11f9aeb829640caa661b2dc2d976f0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/087c4244b11f9aeb829640caa661b2dc2d976f0a", "html_url": "https://github.com/rust-lang/rust/commit/087c4244b11f9aeb829640caa661b2dc2d976f0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/087c4244b11f9aeb829640caa661b2dc2d976f0a/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a696193bab3f09e7c95173e10d1e98d18b8f1bb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a696193bab3f09e7c95173e10d1e98d18b8f1bb8", "html_url": "https://github.com/rust-lang/rust/commit/a696193bab3f09e7c95173e10d1e98d18b8f1bb8"}], "stats": {"total": 139, "additions": 76, "deletions": 63}, "files": [{"sha": "70003a224828de9ac6ce214802666350b0137e7b", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 76, "deletions": 63, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/087c4244b11f9aeb829640caa661b2dc2d976f0a/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/087c4244b11f9aeb829640caa661b2dc2d976f0a/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=087c4244b11f9aeb829640caa661b2dc2d976f0a", "patch": "@@ -72,76 +72,26 @@ fn format_addr(ip: ip_addr) -> str {\n     }\n }\n \n-type get_addr_data = {\n-    output_ch: comm::chan<result::result<[ip_addr]/~,ip_get_addr_err>>\n-};\n-\n-crust fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n-                     res: *addrinfo) unsafe {\n-    log(debug, \"in get_addr_cb\");\n-    let handle_data = get_data_for_req(handle) as\n-        *get_addr_data;\n-    if status == 0i32 {\n-        if res != (ptr::null::<addrinfo>()) {\n-            let mut out_vec = []/~;\n-            log(debug, #fmt(\"initial addrinfo: %?\", res));\n-            let mut curr_addr = res;\n-            loop {\n-                let new_ip_addr = if ll::is_ipv4_addrinfo(curr_addr) {\n-                    ipv4(copy((\n-                        *ll::addrinfo_as_sockaddr_in(curr_addr))))\n-                }\n-                else if ll::is_ipv6_addrinfo(curr_addr) {\n-                    ipv6(copy((\n-                        *ll::addrinfo_as_sockaddr_in6(curr_addr))))\n-                }\n-                else {\n-                    log(debug, \"curr_addr is not of family AF_INET or \"+\n-                        \"AF_INET6. Error.\");\n-                    (*handle_data).output_ch.send(\n-                        result::err(get_addr_unknown_error));\n-                    break;\n-                };\n-                out_vec += [new_ip_addr]/~;\n-\n-                let next_addr = ll::get_next_addrinfo(curr_addr);\n-                if next_addr == ptr::null::<addrinfo>() as *addrinfo {\n-                    log(debug, \"null next_addr encountered. no mas\");\n-                    break;\n-                }\n-                else {\n-                    curr_addr = next_addr;\n-                    log(debug, #fmt(\"next_addr addrinfo: %?\", curr_addr));\n-                }\n-            }\n-            log(debug, #fmt(\"successful process addrinfo result, len: %?\",\n-                            vec::len(out_vec)));\n-            (*handle_data).output_ch.send(result::ok(out_vec));\n-        }\n-        else {\n-            log(debug, \"addrinfo pointer is NULL\");\n-            (*handle_data).output_ch.send(\n-                result::err(get_addr_unknown_error));\n-        }\n-    }\n-    else {\n-        log(debug, \"status != 0 error in get_addr_cb\");\n-        (*handle_data).output_ch.send(\n-            result::err(get_addr_unknown_error));\n-    }\n-    if res != (ptr::null::<addrinfo>()) {\n-        uv_freeaddrinfo(res);\n-    }\n-    log(debug, \"leaving get_addr_cb\");\n-}\n-\n #[doc=\"\n+Represents errors returned from `net::ip::get_addr()`\n \"]\n enum ip_get_addr_err {\n     get_addr_unknown_error\n }\n \n #[doc=\"\n+Attempts name resolution on the provided `node` string\n+\n+# Arguments\n+\n+* `node` - a string representing some host address\n+* `iotask` - a `uv::iotask` used to interact with the underlying event loop\n+\n+# Returns\n+\n+A `result<[ip_addr]/~, ip_get_addr_err>` instance that will contain\n+a vector of `ip_addr` results, in the case of success, or an error\n+object in the case of failure\n \"]\n fn get_addr(++node: str, iotask: iotask)\n         -> result::result<[ip_addr]/~, ip_get_addr_err> unsafe {\n@@ -303,6 +253,69 @@ mod v6 {\n     }\n }\n \n+type get_addr_data = {\n+    output_ch: comm::chan<result::result<[ip_addr]/~,ip_get_addr_err>>\n+};\n+\n+crust fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n+                     res: *addrinfo) unsafe {\n+    log(debug, \"in get_addr_cb\");\n+    let handle_data = get_data_for_req(handle) as\n+        *get_addr_data;\n+    if status == 0i32 {\n+        if res != (ptr::null::<addrinfo>()) {\n+            let mut out_vec = []/~;\n+            log(debug, #fmt(\"initial addrinfo: %?\", res));\n+            let mut curr_addr = res;\n+            loop {\n+                let new_ip_addr = if ll::is_ipv4_addrinfo(curr_addr) {\n+                    ipv4(copy((\n+                        *ll::addrinfo_as_sockaddr_in(curr_addr))))\n+                }\n+                else if ll::is_ipv6_addrinfo(curr_addr) {\n+                    ipv6(copy((\n+                        *ll::addrinfo_as_sockaddr_in6(curr_addr))))\n+                }\n+                else {\n+                    log(debug, \"curr_addr is not of family AF_INET or \"+\n+                        \"AF_INET6. Error.\");\n+                    (*handle_data).output_ch.send(\n+                        result::err(get_addr_unknown_error));\n+                    break;\n+                };\n+                out_vec += [new_ip_addr]/~;\n+\n+                let next_addr = ll::get_next_addrinfo(curr_addr);\n+                if next_addr == ptr::null::<addrinfo>() as *addrinfo {\n+                    log(debug, \"null next_addr encountered. no mas\");\n+                    break;\n+                }\n+                else {\n+                    curr_addr = next_addr;\n+                    log(debug, #fmt(\"next_addr addrinfo: %?\", curr_addr));\n+                }\n+            }\n+            log(debug, #fmt(\"successful process addrinfo result, len: %?\",\n+                            vec::len(out_vec)));\n+            (*handle_data).output_ch.send(result::ok(out_vec));\n+        }\n+        else {\n+            log(debug, \"addrinfo pointer is NULL\");\n+            (*handle_data).output_ch.send(\n+                result::err(get_addr_unknown_error));\n+        }\n+    }\n+    else {\n+        log(debug, \"status != 0 error in get_addr_cb\");\n+        (*handle_data).output_ch.send(\n+            result::err(get_addr_unknown_error));\n+    }\n+    if res != (ptr::null::<addrinfo>()) {\n+        uv_freeaddrinfo(res);\n+    }\n+    log(debug, \"leaving get_addr_cb\");\n+}\n+\n #[cfg(test)]\n mod test {\n     #[test]"}]}