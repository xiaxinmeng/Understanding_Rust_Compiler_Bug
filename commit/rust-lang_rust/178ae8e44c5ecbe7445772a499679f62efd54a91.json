{"sha": "178ae8e44c5ecbe7445772a499679f62efd54a91", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3OGFlOGU0NGM1ZWNiZTc0NDU3NzJhNDk5Njc5ZjYyZWZkNTRhOTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-30T15:14:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-30T15:14:23Z"}, "message": "Auto merge of #1791 - Aaron1011:measureme, r=RalfJung\n\nAdd `measureme` integration for profiling the interpreted program\n\nThis PR uses the `measureme` crate to profile the call stack of the\nprogram being interpreted by Miri. This is accomplished by starting a\nmeasureme 'event' when we enter a function call, and ending the event\nwhen we exit the call. The `measureme` tooling can be used to produce a\ncall stack from the generated profile data.\n\nLimitations:\n* We currently record every single entry/exit. This might generate very\n  large profile outputs for programs with a large number of function\n  calls. In follow-up work, we might want to explore sampling (e.g. only\n  recording every N function calls).\n* This does not integrate very well with Miri's concurrency support.\n  Each event we record starts when we push a frame, and ends when we pop\n  a frame. As a result, the timing recorded for a particular frame will include all of the work Miri does before that frame completes, including executing another thread.\n\nThe `measureme` integration is off by default, and must be enabled via\n`-Zmiri-measureme=<output_name>`", "tree": {"sha": "1a22cb5ef29cc198b80531a5b3463979206ba4ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a22cb5ef29cc198b80531a5b3463979206ba4ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/178ae8e44c5ecbe7445772a499679f62efd54a91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/178ae8e44c5ecbe7445772a499679f62efd54a91", "html_url": "https://github.com/rust-lang/rust/commit/178ae8e44c5ecbe7445772a499679f62efd54a91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/178ae8e44c5ecbe7445772a499679f62efd54a91/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fa9363ebba236f7c29ae11180db6051d7d2ce3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fa9363ebba236f7c29ae11180db6051d7d2ce3b", "html_url": "https://github.com/rust-lang/rust/commit/4fa9363ebba236f7c29ae11180db6051d7d2ce3b"}, {"sha": "c89a5d62ee4100018d8422ebdcddb47ed6290fcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/c89a5d62ee4100018d8422ebdcddb47ed6290fcd", "html_url": "https://github.com/rust-lang/rust/commit/c89a5d62ee4100018d8422ebdcddb47ed6290fcd"}], "stats": {"total": 168, "additions": 156, "deletions": 12}, "files": [{"sha": "e728dc07b92860ecacd990267c4a73df05c93b87", "filename": "Cargo.lock", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/178ae8e44c5ecbe7445772a499679f62efd54a91/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/178ae8e44c5ecbe7445772a499679f62efd54a91/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=178ae8e44c5ecbe7445772a499679f62efd54a91", "patch": "@@ -167,6 +167,15 @@ version = \"2.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9a3a5bfb195931eeb336b2a7b4d761daec841b97f947d34394601737a7bba5e4\"\n \n+[[package]]\n+name = \"instant\"\n+version = \"0.1.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"61124eeebbd69b8190558df225adf7e4caafce0d743919e5d6b19652314ec5ec\"\n+dependencies = [\n+ \"cfg-if\",\n+]\n+\n [[package]]\n name = \"itoa\"\n version = \"0.4.7\"\n@@ -185,6 +194,15 @@ version = \"0.2.92\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"56d855069fafbb9b344c0f962150cd2c1187975cb1c22c1522c240d8c4986714\"\n \n+[[package]]\n+name = \"lock_api\"\n+version = \"0.4.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5a3c91c24eae6777794bb1997ad98bbb87daf92890acab859f7eaa4320333176\"\n+dependencies = [\n+ \"scopeguard\",\n+]\n+\n [[package]]\n name = \"log\"\n version = \"0.4.14\"\n@@ -194,12 +212,35 @@ dependencies = [\n  \"cfg-if\",\n ]\n \n+[[package]]\n+name = \"measureme\"\n+version = \"9.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"78f7a41bc6f856a2cf0e95094ad5121f82500e2d9a0f3c0171d98f6566d8117d\"\n+dependencies = [\n+ \"log\",\n+ \"memmap2\",\n+ \"parking_lot\",\n+ \"perf-event-open-sys\",\n+ \"rustc-hash\",\n+ \"smallvec\",\n+]\n+\n [[package]]\n name = \"memchr\"\n version = \"2.3.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"0ee1c47aaa256ecabcaea351eae4a9b01ef39ed810004e298d2511ed284b1525\"\n \n+[[package]]\n+name = \"memmap2\"\n+version = \"0.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"397d1a6d6d0563c0f5462bbdae662cf6c784edf5e828e40c7257f85d82bf56dd\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n [[package]]\n name = \"miow\"\n version = \"0.3.7\"\n@@ -220,6 +261,7 @@ dependencies = [\n  \"hex\",\n  \"libc\",\n  \"log\",\n+ \"measureme\",\n  \"rand\",\n  \"rustc-workspace-hack\",\n  \"rustc_version\",\n@@ -237,6 +279,40 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"parking_lot\"\n+version = \"0.11.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6d7744ac029df22dca6284efe4e898991d28e3085c706c972bcd7da4a27a15eb\"\n+dependencies = [\n+ \"instant\",\n+ \"lock_api\",\n+ \"parking_lot_core\",\n+]\n+\n+[[package]]\n+name = \"parking_lot_core\"\n+version = \"0.8.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fa7a782938e745763fe6907fc6ba86946d72f49fe7e21de074e08128a99fb018\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"instant\",\n+ \"libc\",\n+ \"redox_syscall\",\n+ \"smallvec\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"perf-event-open-sys\"\n+version = \"1.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ce9bedf5da2c234fdf2391ede2b90fabf585355f33100689bc364a3ea558561a\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n [[package]]\n name = \"pest\"\n version = \"2.1.3\"\n@@ -355,6 +431,12 @@ dependencies = [\n  \"winapi\",\n ]\n \n+[[package]]\n+name = \"rustc-hash\"\n+version = \"1.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2\"\n+\n [[package]]\n name = \"rustc-workspace-hack\"\n version = \"1.0.0\"\n@@ -394,6 +476,12 @@ version = \"1.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"71d301d4193d031abdd79ff7e3dd721168a9572ef3fe51a1517aba235bd8f86e\"\n \n+[[package]]\n+name = \"scopeguard\"\n+version = \"1.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd\"\n+\n [[package]]\n name = \"semver\"\n version = \"0.11.0\""}, {"sha": "7ee96f7e99e682604ca48c7da0d3863beec2ff1a", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/178ae8e44c5ecbe7445772a499679f62efd54a91/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/178ae8e44c5ecbe7445772a499679f62efd54a91/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=178ae8e44c5ecbe7445772a499679f62efd54a91", "patch": "@@ -30,6 +30,7 @@ smallvec = \"1.4.2\"\n # See the `src/tools/rustc-workspace-hack/README.md` file in `rust-lang/rust`\n # for more information.\n rustc-workspace-hack = \"1.0.0\"\n+measureme = \"9.1.2\"\n \n # Enable some feature flags that dev-dependencies need but dependencies\n # do not.  This makes `./miri install` after `./miri build` faster."}, {"sha": "b214ab6d09c1296ce747111d3738093b1680c129", "filename": "README.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/178ae8e44c5ecbe7445772a499679f62efd54a91/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/178ae8e44c5ecbe7445772a499679f62efd54a91/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=178ae8e44c5ecbe7445772a499679f62efd54a91", "patch": "@@ -222,6 +222,10 @@ environment variable:\n   times to exclude several variables.  On Windows, the `TERM` environment\n   variable is excluded by default.\n * `-Zmiri-ignore-leaks` disables the memory leak checker.\n+* `-Zmiri-measureme=<name>` enables `measureme` profiling for the interpreted program.\n+   This can be used to find which parts of your program are executing slowly under Miri.\n+   The profile is written out to a file with the prefix `<name>`, and can be processed\n+   using the tools in the repository https://github.com/rust-lang/measureme.\n * `-Zmiri-seed=<hex>` configures the seed of the RNG that Miri uses to resolve\n   non-determinism.  This RNG is used to pick base addresses for allocations.\n   When isolation is enabled (the default), this is also used to emulate system"}, {"sha": "47cde5c353e133ba708cdc447b1dd0b8b8872bd4", "filename": "src/bin/miri.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/178ae8e44c5ecbe7445772a499679f62efd54a91/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/178ae8e44c5ecbe7445772a499679f62efd54a91/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=178ae8e44c5ecbe7445772a499679f62efd54a91", "patch": "@@ -318,6 +318,10 @@ fn main() {\n                     };\n                     miri_config.cmpxchg_weak_failure_rate = rate;\n                 }\n+                arg if arg.starts_with(\"-Zmiri-measureme=\") => {\n+                    let measureme_out = arg.strip_prefix(\"-Zmiri-measureme=\").unwrap();\n+                    miri_config.measureme_out = Some(measureme_out.to_string());\n+                }\n                 _ => {\n                     // Forward to rustc.\n                     rustc_args.push(arg);"}, {"sha": "52e554f57d7e1a84f3e48ec3b8c30602a52bb55f", "filename": "src/eval.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/178ae8e44c5ecbe7445772a499679f62efd54a91/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/178ae8e44c5ecbe7445772a499679f62efd54a91/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=178ae8e44c5ecbe7445772a499679f62efd54a91", "patch": "@@ -54,6 +54,9 @@ pub struct MiriConfig {\n     /// Rate of spurious failures for compare_exchange_weak atomic operations,\n     /// between 0.0 and 1.0, defaulting to 0.8 (80% chance of failure).\n     pub cmpxchg_weak_failure_rate: f64,\n+    /// If `Some`, enable the `measureme` profiler, writing results to a file\n+    /// with the specified prefix.\n+    pub measureme_out: Option<String>,\n }\n \n impl Default for MiriConfig {\n@@ -73,6 +76,7 @@ impl Default for MiriConfig {\n             track_raw: false,\n             data_race_detector: true,\n             cmpxchg_weak_failure_rate: 0.8,\n+            measureme_out: None,\n         }\n     }\n }\n@@ -92,7 +96,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         tcx,\n         rustc_span::source_map::DUMMY_SP,\n         param_env,\n-        Evaluator::new(config.communicate, config.validate, layout_cx),\n+        Evaluator::new(&config, layout_cx),\n         MemoryExtra::new(&config),\n     );\n     // Complete initialization."}, {"sha": "4f643e7f509178a4c7d3af74065a850682e5750a", "filename": "src/machine.rs", "status": "modified", "additions": 54, "deletions": 11, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/178ae8e44c5ecbe7445772a499679f62efd54a91/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/178ae8e44c5ecbe7445772a499679f62efd54a91/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=178ae8e44c5ecbe7445772a499679f62efd54a91", "patch": "@@ -34,7 +34,6 @@ pub const STACK_SIZE: u64 = 16 * PAGE_SIZE; // whatever\n pub const NUM_CPUS: u64 = 1;\n \n /// Extra data stored with each stack frame\n-#[derive(Debug)]\n pub struct FrameData<'tcx> {\n     /// Extra data for Stacked Borrows.\n     pub call_id: stacked_borrows::CallId,\n@@ -43,6 +42,21 @@ pub struct FrameData<'tcx> {\n     /// called by `try`). When this frame is popped during unwinding a panic,\n     /// we stop unwinding, use the `CatchUnwindData` to handle catching.\n     pub catch_unwind: Option<CatchUnwindData<'tcx>>,\n+\n+    /// If `measureme` profiling is enabled, holds timing information\n+    /// for the start of this frame. When we finish executing this frame,\n+    /// we use this to register a completed event with `measureme`.\n+    pub timing: Option<measureme::DetachedTiming>,\n+}\n+\n+impl<'tcx> std::fmt::Debug for FrameData<'tcx> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        // Omitting `timing`, it does not support `Debug`.\n+        f.debug_struct(\"FrameData\")\n+            .field(\"call_id\", &self.call_id)\n+            .field(\"catch_unwind\", &self.catch_unwind)\n+            .finish()\n+    }\n }\n \n /// Extra memory kinds\n@@ -270,16 +284,22 @@ pub struct Evaluator<'mir, 'tcx> {\n \n     /// Allocations that are considered roots of static memory (that may leak).\n     pub(crate) static_roots: Vec<AllocId>,\n+\n+    /// The `measureme` profiler used to record timing information about\n+    /// the emulated program.\n+    profiler: Option<measureme::Profiler>,\n+    /// Used with `profiler` to cache the `StringId`s for event names\n+    /// uesd with `measureme`.\n+    string_cache: FxHashMap<String, measureme::StringId>,\n }\n \n impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n-    pub(crate) fn new(\n-        communicate: bool,\n-        validate: bool,\n-        layout_cx: LayoutCx<'tcx, TyCtxt<'tcx>>,\n-    ) -> Self {\n+    pub(crate) fn new(config: &MiriConfig, layout_cx: LayoutCx<'tcx, TyCtxt<'tcx>>) -> Self {\n         let layouts =\n             PrimitiveLayouts::new(layout_cx).expect(\"Couldn't get layouts of primitive types\");\n+        let profiler = config.measureme_out.as_ref().map(|out| {\n+            measureme::Profiler::new(out).expect(\"Couldn't create `measureme` profiler\")\n+        });\n         Evaluator {\n             // `env_vars` could be initialized properly here if `Memory` were available before\n             // calling this method.\n@@ -288,14 +308,16 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n             argv: None,\n             cmd_line: None,\n             tls: TlsData::default(),\n-            communicate,\n-            validate,\n+            communicate: config.communicate,\n+            validate: config.validate,\n             file_handler: Default::default(),\n             dir_handler: Default::default(),\n             time_anchor: Instant::now(),\n             layouts,\n             threads: ThreadManager::default(),\n             static_roots: Vec::new(),\n+            profiler,\n+            string_cache: Default::default(),\n         }\n     }\n }\n@@ -597,11 +619,27 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         frame: Frame<'mir, 'tcx, Tag>,\n     ) -> InterpResult<'tcx, Frame<'mir, 'tcx, Tag, FrameData<'tcx>>> {\n+        // Start recording our event before doing anything else\n+        let timing = if let Some(profiler) = ecx.machine.profiler.as_ref() {\n+            let fn_name = frame.instance.to_string();\n+            let entry = ecx.machine.string_cache.entry(fn_name.clone());\n+            let name = entry.or_insert_with(|| profiler.alloc_string(&*fn_name));\n+\n+            Some(profiler.start_recording_interval_event_detached(\n+                *name,\n+                measureme::EventId::from_label(*name),\n+                ecx.get_active_thread().to_u32(),\n+            ))\n+        } else {\n+            None\n+        };\n+\n         let stacked_borrows = ecx.memory.extra.stacked_borrows.as_ref();\n         let call_id = stacked_borrows.map_or(NonZeroU64::new(1).unwrap(), |stacked_borrows| {\n             stacked_borrows.borrow_mut().new_call()\n         });\n-        let extra = FrameData { call_id, catch_unwind: None };\n+\n+        let extra = FrameData { call_id, catch_unwind: None, timing };\n         Ok(frame.with_extra(extra))\n     }\n \n@@ -625,10 +663,15 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     #[inline(always)]\n     fn after_stack_pop(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        frame: Frame<'mir, 'tcx, Tag, FrameData<'tcx>>,\n+        mut frame: Frame<'mir, 'tcx, Tag, FrameData<'tcx>>,\n         unwinding: bool,\n     ) -> InterpResult<'tcx, StackPopJump> {\n-        ecx.handle_stack_pop(frame.extra, unwinding)\n+        let timing = frame.extra.timing.take();\n+        let res = ecx.handle_stack_pop(frame.extra, unwinding);\n+        if let Some(profiler) = ecx.machine.profiler.as_ref() {\n+            profiler.finish_recording_interval_event(timing.unwrap());\n+        }\n+        res\n     }\n \n     #[inline(always)]"}]}