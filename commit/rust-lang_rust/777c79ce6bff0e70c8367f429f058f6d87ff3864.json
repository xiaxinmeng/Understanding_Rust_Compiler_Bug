{"sha": "777c79ce6bff0e70c8367f429f058f6d87ff3864", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3N2M3OWNlNmJmZjBlNzBjODM2N2Y0MjlmMDU4ZjZkODdmZjM4NjQ=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-31T07:00:11Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-31T07:00:11Z"}, "message": "Merge #712\n\n712:  Fix #667 and improvements to introduce_variable r=matklad a=eulerdisk\n\nFix #667 (but not re-indenting currently), plus many other improvements.\r\n@matklad I'm not sure how to handle re-indenting here.\n\nCo-authored-by: Andrea Pretto <eulerdisk@gmail.com>", "tree": {"sha": "b1daaac6e059a679da654dbc2f7672ea605aedf0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1daaac6e059a679da654dbc2f7672ea605aedf0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/777c79ce6bff0e70c8367f429f058f6d87ff3864", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/777c79ce6bff0e70c8367f429f058f6d87ff3864", "html_url": "https://github.com/rust-lang/rust/commit/777c79ce6bff0e70c8367f429f058f6d87ff3864", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/777c79ce6bff0e70c8367f429f058f6d87ff3864/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "28fdb8d03caf1ab8b40ed0fcbe8e47451fe030d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/28fdb8d03caf1ab8b40ed0fcbe8e47451fe030d9", "html_url": "https://github.com/rust-lang/rust/commit/28fdb8d03caf1ab8b40ed0fcbe8e47451fe030d9"}, {"sha": "a5fe4a08fb9b6e5df4f9aa1481fb62f6938897af", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5fe4a08fb9b6e5df4f9aa1481fb62f6938897af", "html_url": "https://github.com/rust-lang/rust/commit/a5fe4a08fb9b6e5df4f9aa1481fb62f6938897af"}], "stats": {"total": 317, "additions": 302, "deletions": 15}, "files": [{"sha": "8905b041913ec2360318523ee476b780e7c3e10a", "filename": "crates/ra_ide_api_light/src/assists.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/777c79ce6bff0e70c8367f429f058f6d87ff3864/crates%2Fra_ide_api_light%2Fsrc%2Fassists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777c79ce6bff0e70c8367f429f058f6d87ff3864/crates%2Fra_ide_api_light%2Fsrc%2Fassists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Fassists.rs?ref=777c79ce6bff0e70c8367f429f058f6d87ff3864", "patch": "@@ -196,6 +196,14 @@ fn check_assist(assist: fn(AssistCtx) -> Option<Assist>, before: &str, after: &s\n     })\n }\n \n+#[cfg(test)]\n+fn check_assist_not_applicable(assist: fn(AssistCtx) -> Option<Assist>, text: &str) {\n+    crate::test_utils::check_action_not_applicable(text, |file, off| {\n+        let range = TextRange::offset_len(off, 0.into());\n+        AssistCtx::new(file, range).apply(assist)\n+    })\n+}\n+\n #[cfg(test)]\n fn check_assist_range(assist: fn(AssistCtx) -> Option<Assist>, before: &str, after: &str) {\n     crate::test_utils::check_action_range(before, after, |file, range| {"}, {"sha": "ed13bddc48eee1b3ea8eefa21326b4abdedd9ed7", "filename": "crates/ra_ide_api_light/src/assists/introduce_variable.rs", "status": "modified", "additions": 282, "deletions": 15, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/777c79ce6bff0e70c8367f429f058f6d87ff3864/crates%2Fra_ide_api_light%2Fsrc%2Fassists%2Fintroduce_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777c79ce6bff0e70c8367f429f058f6d87ff3864/crates%2Fra_ide_api_light%2Fsrc%2Fassists%2Fintroduce_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Fassists%2Fintroduce_variable.rs?ref=777c79ce6bff0e70c8367f429f058f6d87ff3864", "patch": "@@ -1,24 +1,34 @@\n use ra_syntax::{\n     ast::{self, AstNode},\n-    SyntaxKind::WHITESPACE,\n-    SyntaxNode, TextUnit,\n+    SyntaxKind::{\n+        WHITESPACE, MATCH_ARM, LAMBDA_EXPR, PATH_EXPR, BREAK_EXPR, LOOP_EXPR, RETURN_EXPR, COMMENT\n+    }, SyntaxNode, TextUnit,\n };\n \n use crate::assists::{AssistCtx, Assist};\n \n pub fn introduce_variable<'a>(ctx: AssistCtx) -> Option<Assist> {\n     let node = ctx.covering_node();\n-    let expr = node.ancestors().filter_map(ast::Expr::cast).next()?;\n-\n-    let anchor_stmt = anchor_stmt(expr)?;\n+    if !valid_covering_node(node) {\n+        return None;\n+    }\n+    let expr = node.ancestors().filter_map(valid_target_expr).next()?;\n+    let (anchor_stmt, wrap_in_block) = anchor_stmt(expr)?;\n     let indent = anchor_stmt.prev_sibling()?;\n     if indent.kind() != WHITESPACE {\n         return None;\n     }\n     ctx.build(\"introduce variable\", move |edit| {\n         let mut buf = String::new();\n \n-        buf.push_str(\"let var_name = \");\n+        let cursor_offset = if wrap_in_block {\n+            buf.push_str(\"{ let var_name = \");\n+            TextUnit::of_str(\"{ let \")\n+        } else {\n+            buf.push_str(\"let var_name = \");\n+            TextUnit::of_str(\"let \")\n+        };\n+\n         expr.syntax().text().push_to(&mut buf);\n         let full_stmt = ast::ExprStmt::cast(anchor_stmt);\n         let is_full_stmt = if let Some(expr_stmt) = full_stmt {\n@@ -36,35 +46,64 @@ pub fn introduce_variable<'a>(ctx: AssistCtx) -> Option<Assist> {\n             indent.text().push_to(&mut buf);\n             edit.replace(expr.syntax().range(), \"var_name\".to_string());\n             edit.insert(anchor_stmt.range().start(), buf);\n+            if wrap_in_block {\n+                edit.insert(anchor_stmt.range().end(), \" }\");\n+            }\n         }\n-        edit.set_cursor(anchor_stmt.range().start() + TextUnit::of_str(\"let \"));\n+        edit.set_cursor(anchor_stmt.range().start() + cursor_offset);\n     })\n }\n \n-/// Statement or last in the block expression, which will follow\n-/// the freshly introduced var.\n-fn anchor_stmt(expr: &ast::Expr) -> Option<&SyntaxNode> {\n-    expr.syntax().ancestors().find(|&node| {\n+fn valid_covering_node(node: &SyntaxNode) -> bool {\n+    node.kind() != COMMENT\n+}\n+/// Check wether the node is a valid expression which can be extracted to a variable.\n+/// In general that's true for any expression, but in some cases that would produce invalid code.\n+fn valid_target_expr(node: &SyntaxNode) -> Option<&ast::Expr> {\n+    return match node.kind() {\n+        PATH_EXPR => None,\n+        BREAK_EXPR => ast::BreakExpr::cast(node).and_then(|e| e.expr()),\n+        RETURN_EXPR => ast::ReturnExpr::cast(node).and_then(|e| e.expr()),\n+        LOOP_EXPR => ast::ReturnExpr::cast(node).and_then(|e| e.expr()),\n+        _ => ast::Expr::cast(node),\n+    };\n+}\n+\n+/// Returns the syntax node which will follow the freshly introduced var\n+/// and a boolean indicating whether we have to wrap it within a { } block\n+/// to produce correct code.\n+/// It can be a statement, the last in a block expression or a wanna be block\n+/// expression like a lamba or match arm.\n+fn anchor_stmt(expr: &ast::Expr) -> Option<(&SyntaxNode, bool)> {\n+    expr.syntax().ancestors().find_map(|node| {\n         if ast::Stmt::cast(node).is_some() {\n-            return true;\n+            return Some((node, false));\n         }\n+\n         if let Some(expr) = node\n             .parent()\n             .and_then(ast::Block::cast)\n             .and_then(|it| it.expr())\n         {\n             if expr.syntax() == node {\n-                return true;\n+                return Some((node, false));\n+            }\n+        }\n+\n+        if let Some(parent) = node.parent() {\n+            if parent.kind() == MATCH_ARM || parent.kind() == LAMBDA_EXPR {\n+                return Some((node, true));\n             }\n         }\n-        false\n+\n+        None\n     })\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::assists::check_assist_range;\n+    use crate::assists::{ check_assist, check_assist_not_applicable, check_assist_range };\n \n     #[test]\n     fn test_introduce_var_simple() {\n@@ -161,4 +200,232 @@ fn foo() {\n }\",\n         );\n     }\n+\n+    #[test]\n+    fn test_introduce_var_in_match_arm_no_block() {\n+        check_assist_range(\n+            introduce_variable,\n+            \"\n+fn main() {\n+    let x = true;\n+    let tuple = match x {\n+        true => (<|>2 + 2<|>, true)\n+        _ => (0, false)\n+    };\n+}\n+\",\n+            \"\n+fn main() {\n+    let x = true;\n+    let tuple = match x {\n+        true => { let <|>var_name = 2 + 2; (var_name, true) }\n+        _ => (0, false)\n+    };\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_introduce_var_in_match_arm_with_block() {\n+        check_assist_range(\n+            introduce_variable,\n+            \"\n+fn main() {\n+    let x = true;\n+    let tuple = match x {\n+        true => {\n+            let y = 1;\n+            (<|>2 + y<|>, true)\n+        }\n+        _ => (0, false)\n+    };\n+}\n+\",\n+            \"\n+fn main() {\n+    let x = true;\n+    let tuple = match x {\n+        true => {\n+            let y = 1;\n+            let <|>var_name = 2 + y;\n+            (var_name, true)\n+        }\n+        _ => (0, false)\n+    };\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_introduce_var_in_closure_no_block() {\n+        check_assist_range(\n+            introduce_variable,\n+            \"\n+fn main() {\n+    let lambda = |x: u32| <|>x * 2<|>;\n+}\n+\",\n+            \"\n+fn main() {\n+    let lambda = |x: u32| { let <|>var_name = x * 2; var_name };\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_introduce_var_in_closure_with_block() {\n+        check_assist_range(\n+            introduce_variable,\n+            \"\n+fn main() {\n+    let lambda = |x: u32| { <|>x * 2<|> };\n+}\n+\",\n+            \"\n+fn main() {\n+    let lambda = |x: u32| { let <|>var_name = x * 2; var_name };\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_introduce_var_path_simple() {\n+        check_assist(\n+            introduce_variable,\n+            \"\n+fn main() {\n+    let o = S<|>ome(true);\n+}\n+\",\n+            \"\n+fn main() {\n+    let <|>var_name = Some(true);\n+    let o = var_name;\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_introduce_var_path_method() {\n+        check_assist(\n+            introduce_variable,\n+            \"\n+fn main() {\n+    let v = b<|>ar.foo();\n+}\n+\",\n+            \"\n+fn main() {\n+    let <|>var_name = bar.foo();\n+    let v = var_name;\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_introduce_var_return() {\n+        check_assist(\n+            introduce_variable,\n+            \"\n+fn foo() -> u32 {\n+    r<|>eturn 2 + 2;\n+}\n+\",\n+            \"\n+fn foo() -> u32 {\n+    let <|>var_name = 2 + 2;\n+    return var_name;\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_introduce_var_break() {\n+        check_assist(\n+            introduce_variable,\n+            \"\n+fn main() {\n+    let result = loop {\n+        b<|>reak 2 + 2;\n+    };\n+}\n+\",\n+            \"\n+fn main() {\n+    let result = loop {\n+        let <|>var_name = 2 + 2;\n+        break var_name;\n+    };\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_introduce_var_for_cast() {\n+        check_assist(\n+            introduce_variable,\n+            \"\n+fn main() {\n+    let v = 0f32 a<|>s u32;\n+}\n+\",\n+            \"\n+fn main() {\n+    let <|>var_name = 0f32 as u32;\n+    let v = var_name;\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_introduce_var_for_return_not_applicable() {\n+        check_assist_not_applicable(\n+            introduce_variable,\n+            \"\n+fn foo() {\n+    r<|>eturn;\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_introduce_var_for_break_not_applicable() {\n+        check_assist_not_applicable(\n+            introduce_variable,\n+            \"\n+fn main() {\n+    loop {\n+        b<|>reak;\n+    };\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_introduce_var_in_comment_not_applicable() {\n+        check_assist_not_applicable(\n+            introduce_variable,\n+            \"\n+fn main() {\n+    let x = true;\n+    let tuple = match x {\n+        // c<|>omment\n+        true => (2 + 2, true)\n+        _ => (0, false)\n+    };\n+}\n+\",\n+        );\n+    }\n }"}, {"sha": "22ded243553b9a49bec97d4dbd260f4505a42313", "filename": "crates/ra_ide_api_light/src/test_utils.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/777c79ce6bff0e70c8367f429f058f6d87ff3864/crates%2Fra_ide_api_light%2Fsrc%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777c79ce6bff0e70c8367f429f058f6d87ff3864/crates%2Fra_ide_api_light%2Fsrc%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Ftest_utils.rs?ref=777c79ce6bff0e70c8367f429f058f6d87ff3864", "patch": "@@ -23,6 +23,18 @@ pub fn check_action<F: Fn(&SourceFile, TextUnit) -> Option<LocalEdit>>(\n     assert_eq_text!(after, &actual);\n }\n \n+pub fn check_action_not_applicable<F: Fn(&SourceFile, TextUnit) -> Option<LocalEdit>>(\n+    text: &str,\n+    f: F,\n+) {\n+    let (text_cursor_pos, text) = extract_offset(text);\n+    let file = SourceFile::parse(&text);\n+    assert!(\n+        f(&file, text_cursor_pos).is_none(),\n+        \"code action is applicable but it shouldn't\"\n+    );\n+}\n+\n pub fn check_action_range<F: Fn(&SourceFile, TextRange) -> Option<LocalEdit>>(\n     before: &str,\n     after: &str,"}]}