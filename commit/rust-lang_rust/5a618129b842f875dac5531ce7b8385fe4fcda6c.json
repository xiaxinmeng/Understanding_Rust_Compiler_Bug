{"sha": "5a618129b842f875dac5531ce7b8385fe4fcda6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhNjE4MTI5Yjg0MmY4NzVkYWM1NTMxY2U3YjgzODVmZTRmY2RhNmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-31T21:06:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-31T21:06:39Z"}, "message": "auto merge of #11832 : jfager/rust/r5900, r=alexcrichton\n\nI tried a couple of different ways to squash this, and still don't think this is ideal, but I wanted to get it out for feedback.\r\n\r\nCloses #5900\r\nCloses #9942\r\n\r\nThere are a few scenarios where the compiler tries to evaluate CastExprs without the corresponding types being available yet in the type context:  https://github.com/mozilla/rust/issues/10618, https://github.com/mozilla/rust/issues/5900, https://github.com/mozilla/rust/issues/9942\r\n\r\nThis PR takes the approach of having eval_const_expr_partial's CastExpr arm fall back to a limited ast_ty_to_ty call that only checks for (a subset of) valid const types, when the direct type lookup fails.  It's kind of hacky, so I understand if you don't want to take this as is.  I'd need a little mentoring to get this into better shape, as figuring out the proper fix has been a little daunting. I'm also happy if someone else wants to pick this up and run with it.\r\n\r\nThis closes 5900 and 9942, but only moves the goalposts a little on 10618, which now falls over in a later phase of the compiler.", "tree": {"sha": "f5e2224945382f98a42856b485c3b42b0fd227a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5e2224945382f98a42856b485c3b42b0fd227a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a618129b842f875dac5531ce7b8385fe4fcda6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a618129b842f875dac5531ce7b8385fe4fcda6c", "html_url": "https://github.com/rust-lang/rust/commit/5a618129b842f875dac5531ce7b8385fe4fcda6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a618129b842f875dac5531ce7b8385fe4fcda6c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f47879637f464b124875889c9a4822099c777cfb", "url": "https://api.github.com/repos/rust-lang/rust/commits/f47879637f464b124875889c9a4822099c777cfb", "html_url": "https://github.com/rust-lang/rust/commit/f47879637f464b124875889c9a4822099c777cfb"}, {"sha": "9b1865a7faafe16af9eb9f804e82065b5a6f1e24", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b1865a7faafe16af9eb9f804e82065b5a6f1e24", "html_url": "https://github.com/rust-lang/rust/commit/9b1865a7faafe16af9eb9f804e82065b5a6f1e24"}], "stats": {"total": 494, "additions": 285, "deletions": 209}, "files": [{"sha": "59057128555360068e3e791088dd671f56d3b11b", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5a618129b842f875dac5531ce7b8385fe4fcda6c/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a618129b842f875dac5531ce7b8385fe4fcda6c/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=5a618129b842f875dac5531ce7b8385fe4fcda6c", "patch": "@@ -11,7 +11,9 @@\n \n use metadata::csearch;\n use middle::astencode;\n+\n use middle::ty;\n+use middle::typeck::astconv;\n use middle;\n \n use syntax::{ast, ast_map, ast_util};\n@@ -445,8 +447,17 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n           _ => Err(~\"Bad operands for binary\")\n         }\n       }\n-      ExprCast(base, _) => {\n-        let ety = tcx.expr_ty(e);\n+      ExprCast(base, target_ty) => {\n+        // This tends to get called w/o the type actually having been\n+        // populated in the ctxt, which was causing things to blow up\n+        // (#5900). Fall back to doing a limited lookup to get past it.\n+        let ety = ty::expr_ty_opt(tcx.ty_ctxt(), e)\n+                .or_else(|| astconv::ast_ty_to_prim_ty(tcx.ty_ctxt(), target_ty))\n+                .unwrap_or_else(|| tcx.ty_ctxt().sess.span_fatal(\n+                    target_ty.span,\n+                    format!(\"Target type not found for const cast\")\n+                ));\n+\n         let base = eval_const_expr_partial(tcx, base);\n         match base {\n             Err(_) => base,"}, {"sha": "f216a1cc0a2556c7d81fdd5fb5f84f1524e80b1c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5a618129b842f875dac5531ce7b8385fe4fcda6c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a618129b842f875dac5531ce7b8385fe4fcda6c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5a618129b842f875dac5531ce7b8385fe4fcda6c", "patch": "@@ -2669,17 +2669,24 @@ pub fn node_id_to_trait_ref(cx: ctxt, id: ast::NodeId) -> @ty::TraitRef {\n }\n \n pub fn node_id_to_type(cx: ctxt, id: ast::NodeId) -> t {\n-    //printfln!(\"{:?}/{:?}\", id, cx.node_types.len());\n-    let node_types = cx.node_types.borrow();\n-    match node_types.get().find(&(id as uint)) {\n-       Some(&t) => t,\n+    match node_id_to_type_opt(cx, id) {\n+       Some(t) => t,\n        None => cx.sess.bug(\n            format!(\"node_id_to_type: no type for node `{}`\",\n                 ast_map::node_id_to_str(cx.items, id,\n                                         token::get_ident_interner())))\n     }\n }\n \n+pub fn node_id_to_type_opt(cx: ctxt, id: ast::NodeId) -> Option<t> {\n+    let node_types = cx.node_types.borrow();\n+    debug!(\"id: {:?}, node_types: {:?}\", id, node_types);\n+    match node_types.get().find(&(id as uint)) {\n+       Some(&t) => Some(t),\n+       None => None\n+    }\n+}\n+\n // FIXME(pcwalton): Makes a copy, bleh. Probably better to not do that.\n pub fn node_id_to_type_params(cx: ctxt, id: ast::NodeId) -> ~[t] {\n     let node_type_substs = cx.node_type_substs.borrow();\n@@ -2850,6 +2857,10 @@ pub fn expr_ty(cx: ctxt, expr: &ast::Expr) -> t {\n     return node_id_to_type(cx, expr.id);\n }\n \n+pub fn expr_ty_opt(cx: ctxt, expr: &ast::Expr) -> Option<t> {\n+    return node_id_to_type_opt(cx, expr.id);\n+}\n+\n pub fn expr_ty_adjusted(cx: ctxt, expr: &ast::Expr) -> t {\n     /*!\n      *"}, {"sha": "565ff4a734585804ce07e6718fe8380f644f8508", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 223, "deletions": 202, "changes": 425, "blob_url": "https://github.com/rust-lang/rust/blob/5a618129b842f875dac5531ce7b8385fe4fcda6c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a618129b842f875dac5531ce7b8385fe4fcda6c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=5a618129b842f875dac5531ce7b8385fe4fcda6c", "patch": "@@ -299,6 +299,74 @@ pub fn ast_path_to_ty<AC:AstConv,RS:RegionScope>(\n pub static NO_REGIONS: uint = 1;\n pub static NO_TPS: uint = 2;\n \n+fn check_path_args(tcx: ty::ctxt,\n+                   path: &ast::Path,\n+                   flags: uint) {\n+    if (flags & NO_TPS) != 0u {\n+        if !path.segments.iter().all(|s| s.types.is_empty()) {\n+            tcx.sess.span_err(\n+                path.span,\n+                \"type parameters are not allowed on this type\");\n+        }\n+    }\n+\n+    if (flags & NO_REGIONS) != 0u {\n+        if !path.segments.last().unwrap().lifetimes.is_empty() {\n+            tcx.sess.span_err(\n+                path.span,\n+                \"region parameters are not allowed on this type\");\n+        }\n+    }\n+}\n+\n+pub fn ast_ty_to_prim_ty(tcx: ty::ctxt, ast_ty: &ast::Ty) -> Option<ty::t> {\n+    match ast_ty.node {\n+        ast::TyPath(ref path, _, id) => {\n+            let def_map = tcx.def_map.borrow();\n+            let a_def = match def_map.get().find(&id) {\n+                None => tcx.sess.span_fatal(\n+                    ast_ty.span, format!(\"unbound path {}\",\n+                                         path_to_str(path, tcx.sess.intr()))),\n+                Some(&d) => d\n+            };\n+            match a_def {\n+                ast::DefPrimTy(nty) => {\n+                    match nty {\n+                        ast::TyBool => {\n+                            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+                            Some(ty::mk_bool())\n+                        }\n+                        ast::TyChar => {\n+                            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+                            Some(ty::mk_char())\n+                        }\n+                        ast::TyInt(it) => {\n+                            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+                            Some(ty::mk_mach_int(it))\n+                        }\n+                        ast::TyUint(uit) => {\n+                            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+                            Some(ty::mk_mach_uint(uit))\n+                        }\n+                        ast::TyFloat(ft) => {\n+                            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+                            Some(ty::mk_mach_float(ft))\n+                        }\n+                        ast::TyStr => {\n+                            tcx.sess.span_err(ast_ty.span,\n+                                              \"bare `str` is not a type\");\n+                            // return /something/ so they can at least get more errors\n+                            Some(ty::mk_str(tcx, ty::vstore_uniq))\n+                        }\n+                    }\n+                }\n+                _ => None\n+            }\n+        }\n+        _ => None\n+    }\n+}\n+\n // Parses the programmer's textual representation of a type into our\n // internal notion of a type.\n pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n@@ -384,26 +452,6 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n         return constr(seq_ty);\n     }\n \n-    fn check_path_args(tcx: ty::ctxt,\n-                       path: &ast::Path,\n-                       flags: uint) {\n-        if (flags & NO_TPS) != 0u {\n-            if !path.segments.iter().all(|s| s.types.is_empty()) {\n-                tcx.sess.span_err(\n-                    path.span,\n-                    \"type parameters are not allowed on this type\");\n-            }\n-        }\n-\n-        if (flags & NO_REGIONS) != 0u {\n-            if !path.segments.last().unwrap().lifetimes.is_empty() {\n-                tcx.sess.span_err(\n-                    path.span,\n-                    \"region parameters are not allowed on this type\");\n-            }\n-        }\n-    }\n-\n     let tcx = this.tcx();\n \n     {\n@@ -421,191 +469,164 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n         ast_ty_to_ty_cache.get().insert(ast_ty.id, ty::atttce_unresolved);\n     }\n \n-\n-    let typ = match ast_ty.node {\n-      ast::TyNil => ty::mk_nil(),\n-      ast::TyBot => ty::mk_bot(),\n-      ast::TyBox(ty) => {\n-        let mt = ast::MutTy { ty: ty, mutbl: ast::MutImmutable };\n-        mk_pointer(this, rscope, &mt, ty::vstore_box,\n-                   |tmt| ty::mk_box(tcx, tmt.ty))\n-      }\n-      ast::TyUniq(ty) => {\n-        let mt = ast::MutTy { ty: ty, mutbl: ast::MutImmutable };\n-        mk_pointer(this, rscope, &mt, ty::vstore_uniq,\n-                   |tmt| ty::mk_uniq(tcx, tmt.ty))\n-      }\n-      ast::TyVec(ty) => {\n-        tcx.sess.span_err(ast_ty.span, \"bare `[]` is not a type\");\n-        // return /something/ so they can at least get more errors\n-        ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, ty), ty::vstore_uniq)\n-      }\n-      ast::TyPtr(ref mt) => {\n-        ty::mk_ptr(tcx, ast_mt_to_mt(this, rscope, mt))\n-      }\n-      ast::TyRptr(ref region, ref mt) => {\n-        let r = opt_ast_region_to_region(this, rscope, ast_ty.span, region);\n-        debug!(\"ty_rptr r={}\", r.repr(this.tcx()));\n-        mk_pointer(this, rscope, mt, ty::vstore_slice(r),\n-                   |tmt| ty::mk_rptr(tcx, r, tmt))\n-      }\n-      ast::TyTup(ref fields) => {\n-        let flds = fields.map(|&t| ast_ty_to_ty(this, rscope, t));\n-        ty::mk_tup(tcx, flds)\n-      }\n-      ast::TyBareFn(ref bf) => {\n-          if bf.decl.variadic && !bf.abis.is_c() {\n-            tcx.sess.span_err(ast_ty.span, \"variadic function must have C calling convention\");\n-          }\n-          ty::mk_bare_fn(tcx, ty_of_bare_fn(this, ast_ty.id, bf.purity,\n-                                            bf.abis, bf.decl))\n-      }\n-      ast::TyClosure(ref f) => {\n-        if f.sigil == ast::ManagedSigil {\n-            tcx.sess.span_err(ast_ty.span,\n-                              \"managed closures are not supported\");\n-        }\n-\n-          let bounds = conv_builtin_bounds(this.tcx(), &f.bounds, match f.sigil {\n-              // Use corresponding trait store to figure out default bounds\n-              // if none were specified.\n-              ast::BorrowedSigil => ty::RegionTraitStore(ty::ReEmpty), // dummy region\n-              ast::OwnedSigil    => ty::UniqTraitStore,\n-              ast::ManagedSigil  => ty::BoxTraitStore,\n-          });\n-          let fn_decl = ty_of_closure(this,\n-                                      rscope,\n-                                      ast_ty.id,\n-                                      f.sigil,\n-                                      f.purity,\n-                                      f.onceness,\n-                                      bounds,\n-                                      &f.region,\n-                                      f.decl,\n-                                      None,\n-                                      ast_ty.span);\n-          ty::mk_closure(tcx, fn_decl)\n-      }\n-      ast::TyPath(ref path, ref bounds, id) => {\n-        let def_map = tcx.def_map.borrow();\n-        let a_def = match def_map.get().find(&id) {\n-          None => tcx.sess.span_fatal(\n-              ast_ty.span, format!(\"unbound path {}\",\n-                                path_to_str(path, tcx.sess.intr()))),\n-          Some(&d) => d\n-        };\n-        // Kind bounds on path types are only supported for traits.\n-        match a_def {\n-            // But don't emit the error if the user meant to do a trait anyway.\n-            ast::DefTrait(..) => { },\n-            _ if bounds.is_some() =>\n-                tcx.sess.span_err(ast_ty.span,\n-                    \"kind bounds can only be used on trait types\"),\n-            _ => { },\n-        }\n-        match a_def {\n-          ast::DefTrait(_) => {\n-              let path_str = path_to_str(path, tcx.sess.intr());\n-              tcx.sess.span_err(\n-                  ast_ty.span,\n-                  format!(\"reference to trait `{}` where a type is expected; \\\n-                        try `@{}`, `~{}`, or `&{}`\",\n-                       path_str, path_str, path_str, path_str));\n-              ty::mk_err()\n-          }\n-          ast::DefTy(did) | ast::DefStruct(did) => {\n-            ast_path_to_ty(this, rscope, did, path).ty\n-          }\n-          ast::DefPrimTy(nty) => {\n-            match nty {\n-              ast::TyBool => {\n-                check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                ty::mk_bool()\n-              }\n-              ast::TyChar => {\n-                check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                ty::mk_char()\n-              }\n-              ast::TyInt(it) => {\n-                check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                ty::mk_mach_int(it)\n-              }\n-              ast::TyUint(uit) => {\n-                check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                ty::mk_mach_uint(uit)\n-              }\n-              ast::TyFloat(ft) => {\n-                check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                ty::mk_mach_float(ft)\n-              }\n-              ast::TyStr => {\n-                tcx.sess.span_err(ast_ty.span,\n-                                  \"bare `str` is not a type\");\n+    let typ = ast_ty_to_prim_ty(tcx, ast_ty).unwrap_or_else(|| match ast_ty.node {\n+            ast::TyNil => ty::mk_nil(),\n+            ast::TyBot => ty::mk_bot(),\n+            ast::TyBox(ty) => {\n+                let mt = ast::MutTy { ty: ty, mutbl: ast::MutImmutable };\n+                mk_pointer(this, rscope, &mt, ty::vstore_box,\n+                           |tmt| ty::mk_box(tcx, tmt.ty))\n+            }\n+            ast::TyUniq(ty) => {\n+                let mt = ast::MutTy { ty: ty, mutbl: ast::MutImmutable };\n+                mk_pointer(this, rscope, &mt, ty::vstore_uniq,\n+                           |tmt| ty::mk_uniq(tcx, tmt.ty))\n+            }\n+            ast::TyVec(ty) => {\n+                tcx.sess.span_err(ast_ty.span, \"bare `[]` is not a type\");\n                 // return /something/ so they can at least get more errors\n-                ty::mk_str(tcx, ty::vstore_uniq)\n-              }\n+                ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, ty), ty::vstore_uniq)\n             }\n-          }\n-          ast::DefTyParam(id, n) => {\n-            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-            ty::mk_param(tcx, n, id)\n-          }\n-          ast::DefSelfTy(id) => {\n-            // n.b.: resolve guarantees that the this type only appears in a\n-            // trait, which we rely upon in various places when creating\n-            // substs\n-            check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-            let did = ast_util::local_def(id);\n-            ty::mk_self(tcx, did)\n-          }\n-          ast::DefMod(id) => {\n-            tcx.sess.span_fatal(ast_ty.span,\n-                                format!(\"found module name used as a type: {}\",\n-                                        ast_map::node_id_to_str(tcx.items, id.node,\n-                                        token::get_ident_interner())));\n-          }\n-          _ => {\n-            tcx.sess.span_fatal(ast_ty.span,\n-                                format!(\"found value name used as a type: {:?}\", a_def));\n-          }\n-        }\n-      }\n-      ast::TyFixedLengthVec(ty, e) => {\n-        match const_eval::eval_const_expr_partial(&tcx, e) {\n-          Ok(ref r) => {\n-            match *r {\n-              const_eval::const_int(i) =>\n-                ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, ty),\n-                           ty::vstore_fixed(i as uint)),\n-              const_eval::const_uint(i) =>\n-                ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, ty),\n-                           ty::vstore_fixed(i as uint)),\n-              _ => {\n-                tcx.sess.span_fatal(\n-                    ast_ty.span, \"expected constant expr for vector length\");\n-              }\n+            ast::TyPtr(ref mt) => {\n+                ty::mk_ptr(tcx, ast_mt_to_mt(this, rscope, mt))\n             }\n-          }\n-          Err(ref r) => {\n-            tcx.sess.span_fatal(\n-                ast_ty.span,\n-                format!(\"expected constant expr for vector length: {}\", *r));\n-          }\n-        }\n-      }\n-      ast::TyTypeof(_e) => {\n-          tcx.sess.span_bug(ast_ty.span, \"typeof is reserved but unimplemented\");\n-      }\n-      ast::TyInfer => {\n-        // ty_infer should only appear as the type of arguments or return\n-        // values in a fn_expr, or as the type of local variables.  Both of\n-        // these cases are handled specially and should not descend into this\n-        // routine.\n-        this.tcx().sess.span_bug(\n-            ast_ty.span,\n-            \"found `ty_infer` in unexpected place\");\n-      }\n-    };\n+            ast::TyRptr(ref region, ref mt) => {\n+                let r = opt_ast_region_to_region(this, rscope, ast_ty.span, region);\n+                debug!(\"ty_rptr r={}\", r.repr(this.tcx()));\n+                mk_pointer(this, rscope, mt, ty::vstore_slice(r),\n+                           |tmt| ty::mk_rptr(tcx, r, tmt))\n+            }\n+            ast::TyTup(ref fields) => {\n+                let flds = fields.map(|&t| ast_ty_to_ty(this, rscope, t));\n+                ty::mk_tup(tcx, flds)\n+            }\n+            ast::TyBareFn(ref bf) => {\n+                if bf.decl.variadic && !bf.abis.is_c() {\n+                    tcx.sess.span_err(ast_ty.span,\n+                                      \"variadic function must have C calling convention\");\n+                }\n+                ty::mk_bare_fn(tcx, ty_of_bare_fn(this, ast_ty.id, bf.purity,\n+                                                  bf.abis, bf.decl))\n+            }\n+            ast::TyClosure(ref f) => {\n+                if f.sigil == ast::ManagedSigil {\n+                    tcx.sess.span_err(ast_ty.span,\n+                                      \"managed closures are not supported\");\n+                }\n+\n+                let bounds = conv_builtin_bounds(this.tcx(), &f.bounds, match f.sigil {\n+                        // Use corresponding trait store to figure out default bounds\n+                        // if none were specified.\n+                        ast::BorrowedSigil => ty::RegionTraitStore(ty::ReEmpty), // dummy region\n+                        ast::OwnedSigil    => ty::UniqTraitStore,\n+                        ast::ManagedSigil  => ty::BoxTraitStore,\n+                    });\n+                let fn_decl = ty_of_closure(this,\n+                                            rscope,\n+                                            ast_ty.id,\n+                                            f.sigil,\n+                                            f.purity,\n+                                            f.onceness,\n+                                            bounds,\n+                                            &f.region,\n+                                            f.decl,\n+                                            None,\n+                                            ast_ty.span);\n+                ty::mk_closure(tcx, fn_decl)\n+            }\n+            ast::TyPath(ref path, ref bounds, id) => {\n+                let def_map = tcx.def_map.borrow();\n+                let a_def = match def_map.get().find(&id) {\n+                    None => tcx.sess.span_fatal(\n+                        ast_ty.span, format!(\"unbound path {}\",\n+                                             path_to_str(path, tcx.sess.intr()))),\n+                    Some(&d) => d\n+                };\n+                // Kind bounds on path types are only supported for traits.\n+                match a_def {\n+                    // But don't emit the error if the user meant to do a trait anyway.\n+                    ast::DefTrait(..) => { },\n+                    _ if bounds.is_some() =>\n+                        tcx.sess.span_err(ast_ty.span,\n+                                          \"kind bounds can only be used on trait types\"),\n+                    _ => { },\n+                }\n+                match a_def {\n+                    ast::DefTrait(_) => {\n+                        let path_str = path_to_str(path, tcx.sess.intr());\n+                        tcx.sess.span_err(\n+                            ast_ty.span,\n+                            format!(\"reference to trait `{}` where a type is expected; \\\n+                                    try `@{}`, `~{}`, or `&{}`\",\n+                                    path_str, path_str, path_str, path_str));\n+                        ty::mk_err()\n+                    }\n+                    ast::DefTy(did) | ast::DefStruct(did) => {\n+                        ast_path_to_ty(this, rscope, did, path).ty\n+                    }\n+                    ast::DefTyParam(id, n) => {\n+                        check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+                        ty::mk_param(tcx, n, id)\n+                    }\n+                    ast::DefSelfTy(id) => {\n+                        // n.b.: resolve guarantees that the this type only appears in a\n+                        // trait, which we rely upon in various places when creating\n+                        // substs\n+                        check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n+                        let did = ast_util::local_def(id);\n+                        ty::mk_self(tcx, did)\n+                    }\n+                    ast::DefMod(id) => {\n+                        tcx.sess.span_fatal(ast_ty.span,\n+                            format!(\"found module name used as a type: {}\",\n+                                    ast_map::node_id_to_str(tcx.items, id.node,\n+                                                            token::get_ident_interner())));\n+                    }\n+                    ast::DefPrimTy(_) => {\n+                        fail!(\"DefPrimTy arm missed in previous ast_ty_to_prim_ty call\");\n+                    }\n+                    _ => {\n+                        tcx.sess.span_fatal(ast_ty.span,\n+                            format!(\"found value name used as a type: {:?}\", a_def));\n+                    }\n+                }\n+            }\n+            ast::TyFixedLengthVec(ty, e) => {\n+                match const_eval::eval_const_expr_partial(&tcx, e) {\n+                    Ok(ref r) => {\n+                        match *r {\n+                            const_eval::const_int(i) =>\n+                                ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, ty),\n+                                           ty::vstore_fixed(i as uint)),\n+                            const_eval::const_uint(i) =>\n+                                ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, ty),\n+                                           ty::vstore_fixed(i as uint)),\n+                            _ => {\n+                                tcx.sess.span_fatal(\n+                                    ast_ty.span, \"expected constant expr for vector length\");\n+                            }\n+                        }\n+                    }\n+                    Err(ref r) => {\n+                        tcx.sess.span_fatal(\n+                            ast_ty.span,\n+                            format!(\"expected constant expr for vector length: {}\", *r));\n+                    }\n+                }\n+            }\n+            ast::TyTypeof(_e) => {\n+                tcx.sess.span_bug(ast_ty.span, \"typeof is reserved but unimplemented\");\n+            }\n+            ast::TyInfer => {\n+                // ty_infer should only appear as the type of arguments or return\n+                // values in a fn_expr, or as the type of local variables.  Both of\n+                // these cases are handled specially and should not descend into this\n+                // routine.\n+                this.tcx().sess.span_bug(\n+                    ast_ty.span,\n+                    \"found `ty_infer` in unexpected place\");\n+            }\n+        });\n \n     let mut ast_ty_to_ty_cache = tcx.ast_ty_to_ty_cache.borrow_mut();\n     ast_ty_to_ty_cache.get().insert(ast_ty.id, ty::atttce_resolved(typ));"}, {"sha": "31dc0063ad606b2587020a1d96bbe266d7564e12", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5a618129b842f875dac5531ce7b8385fe4fcda6c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a618129b842f875dac5531ce7b8385fe4fcda6c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=5a618129b842f875dac5531ce7b8385fe4fcda6c", "patch": "@@ -4314,4 +4314,3 @@ pub fn check_intrinsic_type(ccx: @CrateCtxt, it: &ast::ForeignItem) {\n                      ppaux::ty_to_str(ccx.tcx, fty)));\n     }\n }\n-"}, {"sha": "4518b503c0dc5a61172013c34e74e32ac7743d0d", "filename": "src/test/run-pass/issue-5900.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5a618129b842f875dac5531ce7b8385fe4fcda6c/src%2Ftest%2Frun-pass%2Fissue-5900.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a618129b842f875dac5531ce7b8385fe4fcda6c/src%2Ftest%2Frun-pass%2Fissue-5900.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5900.rs?ref=5a618129b842f875dac5531ce7b8385fe4fcda6c", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub mod foo {\n+    use super::Bar;\n+\n+    pub struct FooStruct { bar : Bar }\n+}\n+\n+pub enum Bar {\n+    Bar0 = 0 as int\n+}\n+\n+pub fn main() {}"}, {"sha": "7864f4fbdd66c70b38ce51ae375f83fb35e196e4", "filename": "src/test/run-pass/issue-9942.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5a618129b842f875dac5531ce7b8385fe4fcda6c/src%2Ftest%2Frun-pass%2Fissue-9942.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a618129b842f875dac5531ce7b8385fe4fcda6c/src%2Ftest%2Frun-pass%2Fissue-9942.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9942.rs?ref=5a618129b842f875dac5531ce7b8385fe4fcda6c", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn main() {\n+    static S: uint = 23 as uint; [0, ..S]; ()\n+}"}]}