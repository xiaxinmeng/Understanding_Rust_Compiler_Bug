{"sha": "f9417bcf49f531e0382afd405b9163f791f91c85", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5NDE3YmNmNDlmNTMxZTAzODJhZmQ0MDViOTE2M2Y3OTFmOTFjODU=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-06-15T17:16:02Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-06-24T14:52:37Z"}, "message": "Draw the rest of the owl", "tree": {"sha": "cd6874373c8b308062e422c74f6f53db6761c81c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd6874373c8b308062e422c74f6f53db6761c81c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9417bcf49f531e0382afd405b9163f791f91c85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9417bcf49f531e0382afd405b9163f791f91c85", "html_url": "https://github.com/rust-lang/rust/commit/f9417bcf49f531e0382afd405b9163f791f91c85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9417bcf49f531e0382afd405b9163f791f91c85/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e24de2007fe1850bb5c6c289ea48f7cb4424bb0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e24de2007fe1850bb5c6c289ea48f7cb4424bb0a", "html_url": "https://github.com/rust-lang/rust/commit/e24de2007fe1850bb5c6c289ea48f7cb4424bb0a"}], "stats": {"total": 135, "additions": 108, "deletions": 27}, "files": [{"sha": "71b4158024bf8f6c38d11ad08e30aaa95b797a4a", "filename": "crates/ra_hir_def/src/item_tree.rs", "status": "modified", "additions": 108, "deletions": 27, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/f9417bcf49f531e0382afd405b9163f791f91c85/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9417bcf49f531e0382afd405b9163f791f91c85/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs?ref=f9417bcf49f531e0382afd405b9163f791f91c85", "patch": "@@ -19,6 +19,7 @@ use crate::{\n };\n use ast::{AstNode, AttrsOwner, ModuleItemOwner, NameOwner, StructKind, TypeAscriptionOwner};\n use either::Either;\n+use rustc_hash::FxHashMap;\n use smallvec::SmallVec;\n use std::{\n     ops::{Index, Range},\n@@ -29,6 +30,10 @@ use std::{\n #[derive(Debug, Default, Eq, PartialEq)]\n pub struct ItemTree {\n     top_level: Vec<ModItem>,\n+    top_attrs: Attrs,\n+    attrs: FxHashMap<ModItem, Attrs>,\n+    empty_attrs: Attrs,\n+\n     imports: Arena<Import>,\n     functions: Arena<Function>,\n     structs: Arena<Struct>,\n@@ -48,12 +53,15 @@ pub struct ItemTree {\n \n impl ItemTree {\n     pub fn item_tree_query(db: &dyn DefDatabase, file_id: HirFileId) -> Arc<ItemTree> {\n+        let _p = ra_prof::profile(\"item_tree_query\");\n         let syntax = if let Some(node) = db.parse_or_expand(file_id) {\n             node\n         } else {\n             return Default::default();\n         };\n \n+        let hygiene = Hygiene::new(db.upcast(), file_id);\n+        let mut top_attrs = None;\n         let (macro_storage, file_storage);\n         let item_owner = match_ast! {\n             match syntax {\n@@ -62,6 +70,7 @@ impl ItemTree {\n                     &macro_storage as &dyn ModuleItemOwner\n                 },\n                 ast::SourceFile(file) => {\n+                    top_attrs = Some(Attrs::new(&file, &hygiene));\n                     file_storage = file;\n                     &file_storage\n                 },\n@@ -70,13 +79,14 @@ impl ItemTree {\n         };\n \n         let map = db.ast_id_map(file_id);\n-        let ctx = Ctx {\n+        let mut ctx = Ctx {\n             tree: ItemTree::default(),\n-            hygiene: Hygiene::new(db.upcast(), file_id),\n+            hygiene,\n             file: file_id,\n             source_ast_id_map: map,\n             body_ctx: crate::body::LowerCtx::new(db, file_id),\n         };\n+        ctx.tree.top_attrs = top_attrs.unwrap_or_default();\n         Arc::new(ctx.lower(item_owner))\n     }\n \n@@ -85,6 +95,15 @@ impl ItemTree {\n     pub fn top_level_items(&self) -> &[ModItem] {\n         &self.top_level\n     }\n+\n+    /// Returns the inner attributes of the source file.\n+    pub fn top_level_attrs(&self) -> &Attrs {\n+        &self.top_attrs\n+    }\n+\n+    pub fn attrs(&self, of: ModItem) -> &Attrs {\n+        self.attrs.get(&of).unwrap_or(&self.empty_attrs)\n+    }\n }\n \n macro_rules! impl_index {\n@@ -140,7 +159,7 @@ pub struct Function {\n     pub has_self_param: bool,\n     pub params: Vec<TypeRef>,\n     pub ret_type: TypeRef,\n-    pub ast: FileAstId<ast::FnDef>,\n+    pub ast_id: FileAstId<ast::FnDef>,\n     // FIXME inner items\n }\n \n@@ -151,7 +170,18 @@ pub struct Struct {\n     pub visibility: RawVisibility,\n     pub generic_params: generics::GenericParams,\n     pub fields: Fields,\n-    pub ast: FileAstId<ast::StructDef>,\n+    pub ast_id: FileAstId<ast::StructDef>,\n+    pub kind: StructDefKind,\n+}\n+\n+#[derive(Debug, Eq, PartialEq)]\n+pub enum StructDefKind {\n+    /// `struct S { ... }` - type namespace only.\n+    Record,\n+    /// `struct S(...);`\n+    Tuple,\n+    /// `struct S;`\n+    Unit,\n }\n \n #[derive(Debug, Eq, PartialEq)]\n@@ -161,6 +191,7 @@ pub struct Union {\n     pub visibility: RawVisibility,\n     pub generic_params: generics::GenericParams,\n     pub fields: Fields,\n+    pub ast_id: FileAstId<ast::UnionDef>,\n }\n \n #[derive(Debug, Eq, PartialEq)]\n@@ -170,6 +201,7 @@ pub struct Enum {\n     pub visibility: RawVisibility,\n     pub generic_params: generics::GenericParams,\n     pub variants: Range<Idx<Variant>>,\n+    pub ast_id: FileAstId<ast::EnumDef>,\n }\n \n #[derive(Debug, Eq, PartialEq)]\n@@ -178,13 +210,15 @@ pub struct Const {\n     pub name: Option<Name>,\n     pub visibility: RawVisibility,\n     pub type_ref: TypeRef,\n+    pub ast_id: FileAstId<ast::ConstDef>,\n }\n \n #[derive(Debug, Eq, PartialEq)]\n pub struct Static {\n     pub name: Name,\n     pub visibility: RawVisibility,\n     pub type_ref: TypeRef,\n+    pub ast_id: FileAstId<ast::StaticDef>,\n }\n \n #[derive(Debug, Eq, PartialEq)]\n@@ -194,6 +228,7 @@ pub struct Trait {\n     pub generic_params: generics::GenericParams,\n     pub auto: bool,\n     pub items: Vec<AssocItem>,\n+    pub ast_id: FileAstId<ast::TraitDef>,\n }\n \n #[derive(Debug, Eq, PartialEq)]\n@@ -203,6 +238,7 @@ pub struct Impl {\n     pub target_type: TypeRef,\n     pub is_negative: bool,\n     pub items: Vec<AssocItem>,\n+    pub ast_id: FileAstId<ast::ImplDef>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -211,24 +247,31 @@ pub struct TypeAlias {\n     pub visibility: RawVisibility,\n     pub generic_params: generics::GenericParams,\n     pub type_ref: Option<TypeRef>,\n+    pub ast_id: FileAstId<ast::TypeAliasDef>,\n }\n \n #[derive(Debug, Eq, PartialEq)]\n pub struct Mod {\n     pub name: Name,\n     pub visibility: RawVisibility,\n-    pub items: Vec<ModItem>,\n+    pub kind: ModKind,\n+    pub ast_id: FileAstId<ast::Module>,\n }\n \n+#[derive(Debug, Eq, PartialEq)]\n pub enum ModKind {\n+    /// `mod m { ... }`\n     Inline { items: Vec<ModItem> },\n \n+    /// `mod m;`\n     Outline {},\n }\n \n #[derive(Debug, Eq, PartialEq)]\n pub struct MacroCall {\n+    /// For `macro_rules!` declarations, this is the name of the declared macro.\n     pub name: Option<Name>,\n+    /// Path to the called macro.\n     pub path: ModPath,\n     /// Has `#[macro_export]`.\n     pub is_export: bool,\n@@ -256,7 +299,7 @@ macro_rules! impl_froms {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]\n pub enum ModItem {\n     Import(Idx<Import>),\n     Function(Idx<Function>),\n@@ -353,7 +396,8 @@ impl Ctx {\n     }\n \n     fn lower_mod_item(&mut self, item: &ast::ModuleItem) -> Option<ModItems> {\n-        match item {\n+        let attrs = Attrs::new(item, &self.hygiene);\n+        let items = match item {\n             ast::ModuleItem::StructDef(ast) => {\n                 self.lower_struct(ast).map(|data| self.tree.structs.alloc(data).into())\n             }\n@@ -406,7 +450,15 @@ impl Ctx {\n                     })\n                     .collect::<SmallVec<_>>(),\n             )),\n+        };\n+\n+        if !attrs.is_empty() {\n+            for item in items.iter().flat_map(|items| &items.0) {\n+                self.tree.attrs.insert(*item, attrs.clone());\n+            }\n         }\n+\n+        items\n     }\n \n     fn lower_assoc_item(&mut self, item: &ast::AssocItem) -> Option<AssocItem> {\n@@ -430,8 +482,13 @@ impl Ctx {\n         let name = strukt.name()?.as_name();\n         let generic_params = self.lower_generic_params(strukt);\n         let fields = self.lower_fields(&strukt.kind());\n-        let ast = self.source_ast_id_map.ast_id(strukt);\n-        let res = Struct { name, attrs, visibility, generic_params, fields, ast };\n+        let ast_id = self.source_ast_id_map.ast_id(strukt);\n+        let kind = match strukt.kind() {\n+            ast::StructKind::Record(_) => StructDefKind::Record,\n+            ast::StructKind::Tuple(_) => StructDefKind::Tuple,\n+            ast::StructKind::Unit => StructDefKind::Unit,\n+        };\n+        let res = Struct { name, attrs, visibility, generic_params, fields, ast_id, kind };\n         Some(res)\n     }\n \n@@ -498,7 +555,8 @@ impl Ctx {\n             }\n             None => Fields::Record(self.next_field_idx()..self.next_field_idx()),\n         };\n-        let res = Union { name, attrs, visibility, generic_params, fields };\n+        let ast_id = self.source_ast_id_map.ast_id(union);\n+        let res = Union { name, attrs, visibility, generic_params, fields, ast_id };\n         Some(res)\n     }\n \n@@ -511,7 +569,8 @@ impl Ctx {\n             Some(variant_list) => self.lower_variants(variant_list),\n             None => self.next_variant_idx()..self.next_variant_idx(),\n         };\n-        let res = Enum { name, attrs, visibility, generic_params, variants };\n+        let ast_id = self.source_ast_id_map.ast_id(enum_);\n+        let res = Enum { name, attrs, visibility, generic_params, variants, ast_id };\n         Some(res)\n     }\n \n@@ -578,7 +637,7 @@ impl Ctx {\n             ret_type\n         };\n \n-        let ast = self.source_ast_id_map.ast_id(func);\n+        let ast_id = self.source_ast_id_map.ast_id(func);\n         let res = Function {\n             name,\n             attrs,\n@@ -587,7 +646,7 @@ impl Ctx {\n             has_self_param,\n             params,\n             ret_type,\n-            ast,\n+            ast_id,\n         };\n         Some(res)\n     }\n@@ -597,47 +656,68 @@ impl Ctx {\n         let type_ref = type_alias.type_ref().map(|it| self.lower_type_ref(&it));\n         let visibility = self.lower_visibility(type_alias);\n         let generic_params = self.lower_generic_params(type_alias);\n-        let res = TypeAlias { name, visibility, generic_params, type_ref };\n+        let ast_id = self.source_ast_id_map.ast_id(type_alias);\n+        let res = TypeAlias { name, visibility, generic_params, type_ref, ast_id };\n         Some(res)\n     }\n \n     fn lower_static(&mut self, static_: &ast::StaticDef) -> Option<Static> {\n         let name = static_.name()?.as_name();\n         let type_ref = self.lower_type_ref_opt(static_.ascribed_type());\n         let visibility = self.lower_visibility(static_);\n-        let res = Static { name, visibility, type_ref };\n+        let ast_id = self.source_ast_id_map.ast_id(static_);\n+        let res = Static { name, visibility, type_ref, ast_id };\n         Some(res)\n     }\n \n     fn lower_const(&mut self, konst: &ast::ConstDef) -> Const {\n         let name = konst.name().map(|it| it.as_name());\n         let type_ref = self.lower_type_ref_opt(konst.ascribed_type());\n         let visibility = self.lower_visibility(konst);\n-        Const { name, visibility, type_ref }\n+        let ast_id = self.source_ast_id_map.ast_id(konst);\n+        Const { name, visibility, type_ref, ast_id }\n     }\n \n     fn lower_module(&mut self, module: &ast::Module) -> Option<Mod> {\n         let name = module.name()?.as_name();\n         let visibility = self.lower_visibility(module);\n-        let items = module.item_list().map(move |list| {\n-            list.items()\n-                .flat_map(move |item| self.lower_mod_item(&item))\n-                .flat_map(|items| items.0)\n-                .collect()\n-        });\n-        Some(Mod { name, visibility, items: items.unwrap_or_default() })\n+        let kind = if module.semicolon_token().is_some() {\n+            ModKind::Outline {}\n+        } else {\n+            ModKind::Inline {\n+                items: module\n+                    .item_list()\n+                    .map(|list| {\n+                        list.items()\n+                            .flat_map(|item| self.lower_mod_item(&item))\n+                            .flat_map(|items| items.0)\n+                            .collect()\n+                    })\n+                    .unwrap_or_default(),\n+            }\n+        };\n+        let ast_id = self.source_ast_id_map.ast_id(module);\n+        Some(Mod { name, visibility, kind, ast_id })\n     }\n \n     fn lower_trait(&mut self, trait_def: &ast::TraitDef) -> Option<Trait> {\n         let name = trait_def.name()?.as_name();\n         let visibility = self.lower_visibility(trait_def);\n         let generic_params = self.lower_generic_params(trait_def);\n         let auto = trait_def.auto_token().is_some();\n-        let items = trait_def.item_list().map(move |list| {\n+        let items = trait_def.item_list().map(|list| {\n             // FIXME: Does not handle macros\n-            list.assoc_items().flat_map(move |item| self.lower_assoc_item(&item)).collect()\n+            list.assoc_items().flat_map(|item| self.lower_assoc_item(&item)).collect()\n         });\n-        Some(Trait { name, visibility, generic_params, auto, items: items.unwrap_or_default() })\n+        let ast_id = self.source_ast_id_map.ast_id(trait_def);\n+        Some(Trait {\n+            name,\n+            visibility,\n+            generic_params,\n+            auto,\n+            items: items.unwrap_or_default(),\n+            ast_id,\n+        })\n     }\n \n     fn lower_impl(&mut self, impl_def: &ast::ImplDef) -> Option<Impl> {\n@@ -650,7 +730,8 @@ impl Ctx {\n             .assoc_items()\n             .filter_map(|item| self.lower_assoc_item(&item))\n             .collect();\n-        Some(Impl { generic_params, target_trait, target_type, is_negative, items })\n+        let ast_id = self.source_ast_id_map.ast_id(impl_def);\n+        Some(Impl { generic_params, target_trait, target_type, is_negative, items, ast_id })\n     }\n \n     fn lower_use(&mut self, use_item: &ast::UseItem) -> Vec<Import> {"}]}