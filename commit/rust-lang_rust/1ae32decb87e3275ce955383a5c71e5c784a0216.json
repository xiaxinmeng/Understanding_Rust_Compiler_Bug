{"sha": "1ae32decb87e3275ce955383a5c71e5c784a0216", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhZTMyZGVjYjg3ZTMyNzVjZTk1NTM4M2E1YzcxZTVjNzg0YTAyMTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-18T00:51:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-18T00:51:03Z"}, "message": "Auto merge of #23438 - nikomatsakis:issue-23435-default-methods-with-where-clauses, r=nrc\n\nFixes #23435", "tree": {"sha": "d78aff98f728be6c04f81ca7d37f982202d9b9b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d78aff98f728be6c04f81ca7d37f982202d9b9b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ae32decb87e3275ce955383a5c71e5c784a0216", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ae32decb87e3275ce955383a5c71e5c784a0216", "html_url": "https://github.com/rust-lang/rust/commit/1ae32decb87e3275ce955383a5c71e5c784a0216", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ae32decb87e3275ce955383a5c71e5c784a0216/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea8b82e90c450febb1f26a07862a1ec89c22addd", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea8b82e90c450febb1f26a07862a1ec89c22addd", "html_url": "https://github.com/rust-lang/rust/commit/ea8b82e90c450febb1f26a07862a1ec89c22addd"}, {"sha": "bd2096c497580da263c20e8231666a995722ac29", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd2096c497580da263c20e8231666a995722ac29", "html_url": "https://github.com/rust-lang/rust/commit/bd2096c497580da263c20e8231666a995722ac29"}], "stats": {"total": 222, "additions": 172, "deletions": 50}, "files": [{"sha": "60540a9cfa6605391f07bf41af9bcf56bfa08967", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1ae32decb87e3275ce955383a5c71e5c784a0216/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ae32decb87e3275ce955383a5c71e5c784a0216/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=1ae32decb87e3275ce955383a5c71e5c784a0216", "patch": "@@ -1053,10 +1053,11 @@ impl<'tcx> Repr<'tcx> for ty::Variance {\n \n impl<'tcx> Repr<'tcx> for ty::Method<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"method(name: {}, generics: {}, fty: {}, \\\n+        format!(\"method(name: {}, generics: {}, predicates: {}, fty: {}, \\\n                  explicit_self: {}, vis: {}, def_id: {})\",\n                 self.name.repr(tcx),\n                 self.generics.repr(tcx),\n+                self.predicates.repr(tcx),\n                 self.fty.repr(tcx),\n                 self.explicit_self.repr(tcx),\n                 self.vis.repr(tcx),"}, {"sha": "816605e379a5f0f2715208ece7320934eb31f78e", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 53, "deletions": 14, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/1ae32decb87e3275ce955383a5c71e5c784a0216/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ae32decb87e3275ce955383a5c71e5c784a0216/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=1ae32decb87e3275ce955383a5c71e5c784a0216", "patch": "@@ -46,6 +46,7 @@ use arena::TypedArena;\n use libc::{c_uint, c_char};\n use std::ffi::CString;\n use std::cell::{Cell, RefCell};\n+use std::result::Result as StdResult;\n use std::vec::Vec;\n use syntax::ast::Ident;\n use syntax::ast;\n@@ -997,9 +998,9 @@ pub fn expr_ty_adjusted<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, ex: &ast::Expr) ->\n /// do not (necessarily) resolve all nested obligations on the impl. Note that type check should\n /// guarantee to us that all nested obligations *could be* resolved if we wanted to.\n pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                span: Span,\n-                                trait_ref: ty::PolyTraitRef<'tcx>)\n-                                -> traits::Vtable<'tcx, ()>\n+                                    span: Span,\n+                                    trait_ref: ty::PolyTraitRef<'tcx>)\n+                                    -> traits::Vtable<'tcx, ()>\n {\n     let tcx = ccx.tcx();\n \n@@ -1058,7 +1059,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let vtable = selection.map_move_nested(|predicate| {\n         fulfill_cx.register_predicate_obligation(&infcx, predicate);\n     });\n-    let vtable = drain_fulfillment_cx(span, &infcx, &mut fulfill_cx, &vtable);\n+    let vtable = drain_fulfillment_cx_or_panic(span, &infcx, &mut fulfill_cx, &vtable);\n \n     info!(\"Cache miss: {}\", trait_ref.repr(ccx.tcx()));\n     ccx.trait_cache().borrow_mut().insert(trait_ref,\n@@ -1067,6 +1068,22 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     vtable\n }\n \n+pub fn predicates_hold<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                 predicates: Vec<ty::Predicate<'tcx>>)\n+                                 -> bool\n+{\n+    debug!(\"predicates_hold(predicates={})\",\n+           predicates.repr(ccx.tcx()));\n+\n+    let infcx = infer::new_infer_ctxt(ccx.tcx());\n+    let mut fulfill_cx = traits::FulfillmentContext::new();\n+    for predicate in predicates {\n+        let obligation = traits::Obligation::new(traits::ObligationCause::dummy(), predicate);\n+        fulfill_cx.register_predicate_obligation(&infcx, obligation);\n+    }\n+    drain_fulfillment_cx(DUMMY_SP, &infcx, &mut fulfill_cx, &()).is_ok()\n+}\n+\n pub struct NormalizingClosureTyper<'a,'tcx:'a> {\n     param_env: ty::ParameterEnvironment<'a, 'tcx>\n }\n@@ -1114,11 +1131,36 @@ impl<'a,'tcx> ty::ClosureTyper<'tcx> for NormalizingClosureTyper<'a,'tcx> {\n     }\n }\n \n+pub fn drain_fulfillment_cx_or_panic<'a,'tcx,T>(span: Span,\n+                                                infcx: &infer::InferCtxt<'a,'tcx>,\n+                                                fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n+                                                result: &T)\n+                                                -> T\n+    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+{\n+    match drain_fulfillment_cx(span, infcx, fulfill_cx, result) {\n+        Ok(v) => v,\n+        Err(errors) => {\n+            infcx.tcx.sess.span_bug(\n+                span,\n+                &format!(\"Encountered errors `{}` fulfilling during trans\",\n+                         errors.repr(infcx.tcx)));\n+        }\n+    }\n+}\n+\n+/// Finishes processes any obligations that remain in the fulfillment\n+/// context, and then \"freshens\" and returns `result`. This is\n+/// primarily used during normalization and other cases where\n+/// processing the obligations in `fulfill_cx` may cause type\n+/// inference variables that appear in `result` to be unified, and\n+/// hence we need to process those obligations to get the complete\n+/// picture of the type.\n pub fn drain_fulfillment_cx<'a,'tcx,T>(span: Span,\n-                                   infcx: &infer::InferCtxt<'a,'tcx>,\n-                                   fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n-                                   result: &T)\n-                                   -> T\n+                                       infcx: &infer::InferCtxt<'a,'tcx>,\n+                                       fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n+                                       result: &T)\n+                                       -> StdResult<T,Vec<traits::FulfillmentError<'tcx>>>\n     where T : TypeFoldable<'tcx> + Repr<'tcx>\n {\n     debug!(\"drain_fulfillment_cx(result={})\",\n@@ -1131,16 +1173,13 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(span: Span,\n     match fulfill_cx.select_all_or_error(infcx, &typer) {\n         Ok(()) => { }\n         Err(errors) => {\n+            // We always want to surface any overflow errors, no matter what.\n             if errors.iter().all(|e| e.is_overflow()) {\n-                // See Ok(None) case above.\n                 infcx.tcx.sess.span_fatal(\n                     span,\n                     \"reached the recursion limit during monomorphization\");\n             } else {\n-                infcx.tcx.sess.span_bug(\n-                    span,\n-                    &format!(\"Encountered errors `{}` fulfilling during trans\",\n-                            errors.repr(infcx.tcx)));\n+                return Err(errors);\n             }\n         }\n     }\n@@ -1150,7 +1189,7 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(span: Span,\n     // sort of overkill because we do not expect there to be any\n     // unbound type variables, hence no `TyFresh` types should ever be\n     // inserted.\n-    result.fold_with(&mut infcx.freshener())\n+    Ok(result.fold_with(&mut infcx.freshener()))\n }\n \n // Key used to lookup values supplied for type parameters in an expr."}, {"sha": "4da17972c55fb68e4eda4207eb20911b0c67374c", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 81, "deletions": 34, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/1ae32decb87e3275ce955383a5c71e5c784a0216/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ae32decb87e3275ce955383a5c71e5c784a0216/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=1ae32decb87e3275ce955383a5c71e5c784a0216", "patch": "@@ -765,9 +765,15 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                  impl_id: ast::DefId,\n                                  substs: subst::Substs<'tcx>,\n                                  param_substs: &'tcx subst::Substs<'tcx>)\n-                                 -> Vec<ValueRef> {\n+                                 -> Vec<ValueRef>\n+{\n     let tcx = ccx.tcx();\n \n+    debug!(\"emit_vtable_methods(impl_id={}, substs={}, param_substs={})\",\n+           impl_id.repr(tcx),\n+           substs.repr(tcx),\n+           param_substs.repr(tcx));\n+\n     let trt_id = match ty::impl_trait_ref(tcx, impl_id) {\n         Some(t_id) => t_id.def_id,\n         None       => ccx.sess().bug(\"make_impl_vtable: don't know how to \\\n@@ -777,41 +783,82 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     ty::populate_implementations_for_trait_if_necessary(tcx, trt_id);\n \n     let trait_item_def_ids = ty::trait_item_def_ids(tcx, trt_id);\n-    trait_item_def_ids.iter().flat_map(|method_def_id| {\n-        let method_def_id = method_def_id.def_id();\n-        let name = ty::impl_or_trait_item(tcx, method_def_id).name();\n-        // The substitutions we have are on the impl, so we grab\n-        // the method type from the impl to substitute into.\n-        let m_id = method_with_name(ccx, impl_id, name);\n-        let ti = ty::impl_or_trait_item(tcx, m_id);\n-        match ti {\n-            ty::MethodTraitItem(m) => {\n-                debug!(\"(making impl vtable) emitting method {} at subst {}\",\n-                       m.repr(tcx),\n-                       substs.repr(tcx));\n-                if m.generics.has_type_params(subst::FnSpace) ||\n-                    ty::type_has_self(ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(m.fty.clone())))\n-                {\n-                    debug!(\"(making impl vtable) method has self or type \\\n-                            params: {}\",\n-                           token::get_name(name));\n-                    Some(C_null(Type::nil(ccx).ptr_to())).into_iter()\n-                } else {\n-                    let fn_ref = trans_fn_ref_with_substs(\n-                        ccx,\n-                        m_id,\n-                        ExprId(0),\n-                        param_substs,\n-                        substs.clone()).val;\n-\n-                    Some(fn_ref).into_iter()\n-                }\n+    trait_item_def_ids\n+        .iter()\n+\n+        // Filter out the associated types.\n+        .filter_map(|item_def_id| {\n+            match *item_def_id {\n+                ty::MethodTraitItemId(def_id) => Some(def_id),\n+                ty::TypeTraitItemId(_) => None,\n+            }\n+        })\n+\n+        // Now produce pointers for each remaining method. If the\n+        // method could never be called from this object, just supply\n+        // null.\n+        .map(|trait_method_def_id| {\n+            debug!(\"emit_vtable_methods: trait_method_def_id={}\",\n+                   trait_method_def_id.repr(tcx));\n+\n+            let trait_method_type = match ty::impl_or_trait_item(tcx, trait_method_def_id) {\n+                ty::MethodTraitItem(m) => m,\n+                ty::TypeTraitItem(_) => ccx.sess().bug(\"should be a method, not assoc type\")\n+            };\n+            let name = trait_method_type.name;\n+\n+            debug!(\"emit_vtable_methods: trait_method_type={}\",\n+                   trait_method_type.repr(tcx));\n+\n+            // The substitutions we have are on the impl, so we grab\n+            // the method type from the impl to substitute into.\n+            let impl_method_def_id = method_with_name(ccx, impl_id, name);\n+            let impl_method_type = match ty::impl_or_trait_item(tcx, impl_method_def_id) {\n+                ty::MethodTraitItem(m) => m,\n+                ty::TypeTraitItem(_) => ccx.sess().bug(\"should be a method, not assoc type\")\n+            };\n+\n+            debug!(\"emit_vtable_methods: m={}\",\n+                   impl_method_type.repr(tcx));\n+\n+            let nullptr = C_null(Type::nil(ccx).ptr_to());\n+\n+            if impl_method_type.generics.has_type_params(subst::FnSpace) {\n+                debug!(\"emit_vtable_methods: generic\");\n+                return nullptr;\n             }\n-            ty::TypeTraitItem(_) => {\n-                None.into_iter()\n+\n+            let bare_fn_ty =\n+                ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(impl_method_type.fty.clone()));\n+            if ty::type_has_self(bare_fn_ty) {\n+                debug!(\"emit_vtable_methods: type_has_self {}\",\n+                       bare_fn_ty.repr(tcx));\n+                return nullptr;\n             }\n-        }\n-    }).collect()\n+\n+            // If this is a default method, it's possible that it\n+            // relies on where clauses that do not hold for this\n+            // particular set of type parameters. Note that this\n+            // method could then never be called, so we do not want to\n+            // try and trans it, in that case. Issue #23435.\n+            if ty::provided_source(tcx, impl_method_def_id).is_some() {\n+                let predicates =\n+                    monomorphize::apply_param_substs(tcx,\n+                                                     &substs,\n+                                                     &impl_method_type.predicates.predicates);\n+                if !predicates_hold(ccx, predicates.into_vec()) {\n+                    debug!(\"emit_vtable_methods: predicates do not hold\");\n+                    return nullptr;\n+                }\n+            }\n+\n+            trans_fn_ref_with_substs(ccx,\n+                                     impl_method_def_id,\n+                                     ExprId(0),\n+                                     param_substs,\n+                                     substs.clone()).val\n+        })\n+        .collect()\n }\n \n /// Generates the code to convert from a pointer (`Box<T>`, `&T`, etc) into an object"}, {"sha": "dcb21c5cd93b1459ba2a06d45b55088a8462e15d", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ae32decb87e3275ce955383a5c71e5c784a0216/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ae32decb87e3275ce955383a5c71e5c784a0216/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=1ae32decb87e3275ce955383a5c71e5c784a0216", "patch": "@@ -339,7 +339,7 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n     for obligation in obligations {\n         fulfill_cx.register_predicate_obligation(&infcx, obligation);\n     }\n-    let result = drain_fulfillment_cx(DUMMY_SP, &infcx, &mut fulfill_cx, &result);\n+    let result = drain_fulfillment_cx_or_panic(DUMMY_SP, &infcx, &mut fulfill_cx, &result);\n \n     result\n }"}, {"sha": "dad7d0675d62759589c85814fecd879de32ad380", "filename": "src/test/run-pass/issue-23435.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1ae32decb87e3275ce955383a5c71e5c784a0216/src%2Ftest%2Frun-pass%2Fissue-23435.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ae32decb87e3275ce955383a5c71e5c784a0216/src%2Ftest%2Frun-pass%2Fissue-23435.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23435.rs?ref=1ae32decb87e3275ce955383a5c71e5c784a0216", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we do not ICE when a default method implementation has\n+// requirements (in this case, `Self : Baz`) that do not hold for some\n+// specific impl (in this case, `Foo : Bar`). This causes problems\n+// only when building a vtable, because that goes along and\n+// instantiates all the methods, even those that could not otherwise\n+// be called.\n+\n+struct Foo {\n+    x: i32\n+}\n+\n+trait Bar {\n+    fn bar(&self) where Self : Baz { self.baz(); }\n+}\n+\n+trait Baz {\n+    fn baz(&self);\n+}\n+\n+impl Bar for Foo {\n+}\n+\n+fn main() {\n+    let x: &Bar = &Foo { x: 22 };\n+}"}]}