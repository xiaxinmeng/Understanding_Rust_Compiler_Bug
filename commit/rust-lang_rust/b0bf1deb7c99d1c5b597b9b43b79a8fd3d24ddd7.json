{"sha": "b0bf1deb7c99d1c5b597b9b43b79a8fd3d24ddd7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwYmYxZGViN2M5OWQxYzViNTk3YjliNDNiNzlhOGZkM2QyNGRkZDc=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-10-31T19:37:46Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-11-01T18:57:08Z"}, "message": "Refactor a bit", "tree": {"sha": "734c0148c2785bd407c4f2f2bcaffac34a53384d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/734c0148c2785bd407c4f2f2bcaffac34a53384d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0bf1deb7c99d1c5b597b9b43b79a8fd3d24ddd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0bf1deb7c99d1c5b597b9b43b79a8fd3d24ddd7", "html_url": "https://github.com/rust-lang/rust/commit/b0bf1deb7c99d1c5b597b9b43b79a8fd3d24ddd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0bf1deb7c99d1c5b597b9b43b79a8fd3d24ddd7/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4181deb0dd2cce2184df0057cf349628a70f2e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4181deb0dd2cce2184df0057cf349628a70f2e9", "html_url": "https://github.com/rust-lang/rust/commit/f4181deb0dd2cce2184df0057cf349628a70f2e9"}], "stats": {"total": 61, "additions": 25, "deletions": 36}, "files": [{"sha": "43b485ec077e8e3254cd8ad10f18e872e94c6fb5", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 25, "deletions": 36, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b0bf1deb7c99d1c5b597b9b43b79a8fd3d24ddd7/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0bf1deb7c99d1c5b597b9b43b79a8fd3d24ddd7/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=b0bf1deb7c99d1c5b597b9b43b79a8fd3d24ddd7", "patch": "@@ -269,25 +269,9 @@ fn iterate_trait_method_candidates<T>(\n         // iteration\n         let mut known_implemented = inherently_implemented;\n         for &item in data.items() {\n-            // TODO unify with the impl case\n-            match item {\n-                AssocItem::Function(m) => {\n-                    let data = m.data(db);\n-                    if !name.map_or(true, |name| data.name() == name)\n-                        || (!data.has_self_param() && mode != LookupMode::Path)\n-                    {\n-                        continue;\n-                    }\n-                }\n-                AssocItem::Const(c) => {\n-                    if !name.map_or(true, |name| Some(name) == c.name(db).as_ref())\n-                        || (mode != LookupMode::Path)\n-                    {\n-                        continue;\n-                    }\n-                }\n-                _ => {}\n-            };\n+            if !is_valid_candidate(db, name, mode, item) {\n+                continue;\n+            }\n             if !known_implemented {\n                 let goal = generic_implements_goal(db, env.clone(), t, ty.clone());\n                 if db.trait_solve(krate, goal).is_none() {\n@@ -316,23 +300,8 @@ fn iterate_inherent_methods<T>(\n \n         for impl_block in impls.lookup_impl_blocks(&ty.value) {\n             for item in impl_block.items(db) {\n-                match item {\n-                    AssocItem::Function(f) => {\n-                        let data = f.data(db);\n-                        if !name.map_or(true, |name| data.name() == name)\n-                            || (!data.has_self_param() && mode != LookupMode::Path)\n-                        {\n-                            continue;\n-                        }\n-                    }\n-                    AssocItem::Const(c) => {\n-                        if !name.map_or(true, |name| Some(name) == c.name(db).as_ref())\n-                            || (mode != LookupMode::Path)\n-                        {\n-                            continue;\n-                        }\n-                    }\n-                    _ => {}\n+                if !is_valid_candidate(db, name, mode, item) {\n+                    continue;\n                 }\n                 if let Some(result) = callback(&ty.value, item) {\n                     return Some(result);\n@@ -343,6 +312,26 @@ fn iterate_inherent_methods<T>(\n     None\n }\n \n+fn is_valid_candidate(\n+    db: &impl HirDatabase,\n+    name: Option<&Name>,\n+    mode: LookupMode,\n+    item: AssocItem,\n+) -> bool {\n+    match item {\n+        AssocItem::Function(m) => {\n+            let data = m.data(db);\n+            name.map_or(true, |name| data.name() == name)\n+                && (data.has_self_param() || mode == LookupMode::Path)\n+        }\n+        AssocItem::Const(c) => {\n+            name.map_or(true, |name| Some(name) == c.name(db).as_ref())\n+                && (mode == LookupMode::Path)\n+        }\n+        _ => false,\n+    }\n+}\n+\n pub(crate) fn implements_trait(\n     ty: &Canonical<Ty>,\n     db: &impl HirDatabase,"}]}