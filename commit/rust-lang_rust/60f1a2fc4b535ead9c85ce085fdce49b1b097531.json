{"sha": "60f1a2fc4b535ead9c85ce085fdce49b1b097531", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwZjFhMmZjNGI1MzVlYWQ5Yzg1Y2UwODVmZGNlNDliMWIwOTc1MzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-12T11:12:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-12T11:12:16Z"}, "message": "Auto merge of #86215 - FabianWolff:unnameable-types, r=jackh726\n\nDo not suggest to add type annotations for unnameable types\n\nConsider this example:\n```rust\nconst A = || 42;\n\nstruct S<T> { t: T }\nconst B: _ = S { t: || 42 };\n```\nThis currently produces the following output:\n```\nerror: missing type for `const` item\n --> src/lib.rs:1:7\n  |\n1 | const A = || 42;\n  |       ^ help: provide a type for the item: `A: [closure@src/lib.rs:1:11: 1:16]`\n\nerror[E0121]: the type placeholder `_` is not allowed within types on item signatures\n --> src/lib.rs:4:10\n  |\n4 | const B: _ = S { t: || 42 };\n  |          ^\n  |          |\n  |          not allowed in type signatures\n  |          help: replace `_` with the correct type: `S<[closure@src/lib.rs:4:21: 4:26]>`\n\nerror: aborting due to 2 previous errors\n```\nHowever, these suggestions are obviously useless, because the suggested types cannot be written down. With my changes, the suggestion is replaced with a note, because there is no simple fix:\n```\nerror: missing type for `const` item\n --> test.rs:1:7\n  |\n1 | const A = || 42;\n  |       ^\n  |\nnote: however, the inferred type `[closure@test.rs:1:11: 1:16]` cannot be named\n --> test.rs:1:11\n  |\n1 | const A = || 42;\n  |           ^^^^^\n\nerror[E0121]: the type placeholder `_` is not allowed within types on item signatures\n --> test.rs:4:10\n  |\n4 | const B: _ = S { t: || 42 };\n  |          ^ not allowed in type signatures\n  |\nnote: however, the inferred type `S<[closure@test.rs:4:21: 4:26]>` cannot be named\n --> test.rs:4:14\n  |\n4 | const B: _ = S { t: || 42 };\n  |              ^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n```", "tree": {"sha": "759d0461aad1a810641068a70fd73c18c17cce4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/759d0461aad1a810641068a70fd73c18c17cce4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60f1a2fc4b535ead9c85ce085fdce49b1b097531", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60f1a2fc4b535ead9c85ce085fdce49b1b097531", "html_url": "https://github.com/rust-lang/rust/commit/60f1a2fc4b535ead9c85ce085fdce49b1b097531", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60f1a2fc4b535ead9c85ce085fdce49b1b097531/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d59b80d588368cdcfcc1d54e119374a3d78169ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/d59b80d588368cdcfcc1d54e119374a3d78169ff", "html_url": "https://github.com/rust-lang/rust/commit/d59b80d588368cdcfcc1d54e119374a3d78169ff"}, {"sha": "79dc9a76a6272dc2e080237de27406b1456d7c2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/79dc9a76a6272dc2e080237de27406b1456d7c2c", "html_url": "https://github.com/rust-lang/rust/commit/79dc9a76a6272dc2e080237de27406b1456d7c2c"}], "stats": {"total": 190, "additions": 176, "deletions": 14}, "files": [{"sha": "abe5d69a3b3c1b313c71f02a28084f38167d5fb8", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 71, "deletions": 14, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/60f1a2fc4b535ead9c85ce085fdce49b1b097531/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1a2fc4b535ead9c85ce085fdce49b1b097531/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=60f1a2fc4b535ead9c85ce085fdce49b1b097531", "patch": "@@ -9,7 +9,7 @@ use rustc_hir::{HirId, Node};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::util::IntTypeExt;\n-use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt, TypeFoldable, TypeFolder};\n use rustc_span::symbol::Ident;\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -749,6 +749,40 @@ fn infer_placeholder_type(\n     span: Span,\n     item_ident: Ident,\n ) -> Ty<'_> {\n+    // Attempts to make the type nameable by turning FnDefs into FnPtrs.\n+    struct MakeNameable<'tcx> {\n+        success: bool,\n+        tcx: TyCtxt<'tcx>,\n+    }\n+\n+    impl<'tcx> MakeNameable<'tcx> {\n+        fn new(tcx: TyCtxt<'tcx>) -> Self {\n+            MakeNameable { success: true, tcx }\n+        }\n+    }\n+\n+    impl TypeFolder<'tcx> for MakeNameable<'tcx> {\n+        fn tcx(&self) -> TyCtxt<'tcx> {\n+            self.tcx\n+        }\n+\n+        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+            if !self.success {\n+                return ty;\n+            }\n+\n+            match ty.kind() {\n+                ty::FnDef(def_id, _) => self.tcx.mk_fn_ptr(self.tcx.fn_sig(*def_id)),\n+                // FIXME: non-capturing closures should also suggest a function pointer\n+                ty::Closure(..) | ty::Generator(..) => {\n+                    self.success = false;\n+                    ty\n+                }\n+                _ => ty.super_fold_with(self),\n+            }\n+        }\n+    }\n+\n     let ty = tcx.diagnostic_only_typeck(def_id).node_type(body_id.hir_id);\n \n     // If this came from a free `const` or `static mut?` item,\n@@ -760,24 +794,47 @@ fn infer_placeholder_type(\n             // The parser provided a sub-optimal `HasPlaceholders` suggestion for the type.\n             // We are typeck and have the real type, so remove that and suggest the actual type.\n             err.suggestions.clear();\n-            err.span_suggestion(\n-                span,\n-                \"provide a type for the item\",\n-                format!(\"{}: {}\", item_ident, ty),\n-                Applicability::MachineApplicable,\n-            )\n-            .emit_unless(ty.references_error());\n+\n+            // Suggesting unnameable types won't help.\n+            let mut mk_nameable = MakeNameable::new(tcx);\n+            let ty = mk_nameable.fold_ty(ty);\n+            let sugg_ty = if mk_nameable.success { Some(ty) } else { None };\n+            if let Some(sugg_ty) = sugg_ty {\n+                err.span_suggestion(\n+                    span,\n+                    \"provide a type for the item\",\n+                    format!(\"{}: {}\", item_ident, sugg_ty),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else {\n+                err.span_note(\n+                    tcx.hir().body(body_id).value.span,\n+                    &format!(\"however, the inferred type `{}` cannot be named\", ty.to_string()),\n+                );\n+            }\n+\n+            err.emit_unless(ty.references_error());\n         }\n         None => {\n             let mut diag = bad_placeholder_type(tcx, vec![span]);\n \n             if !ty.references_error() {\n-                diag.span_suggestion(\n-                    span,\n-                    \"replace with the correct type\",\n-                    ty.to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n+                let mut mk_nameable = MakeNameable::new(tcx);\n+                let ty = mk_nameable.fold_ty(ty);\n+                let sugg_ty = if mk_nameable.success { Some(ty) } else { None };\n+                if let Some(sugg_ty) = sugg_ty {\n+                    diag.span_suggestion(\n+                        span,\n+                        \"replace with the correct type\",\n+                        sugg_ty.to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                } else {\n+                    diag.span_note(\n+                        tcx.hir().body(body_id).value.span,\n+                        &format!(\"however, the inferred type `{}` cannot be named\", ty.to_string()),\n+                    );\n+                }\n             }\n \n             diag.emit();"}, {"sha": "5d0616443e5ac872252c6f47dd9ac4d4690b486d", "filename": "src/test/ui/suggestions/unnamable-types.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/60f1a2fc4b535ead9c85ce085fdce49b1b097531/src%2Ftest%2Fui%2Fsuggestions%2Funnamable-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60f1a2fc4b535ead9c85ce085fdce49b1b097531/src%2Ftest%2Fui%2Fsuggestions%2Funnamable-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Funnamable-types.rs?ref=60f1a2fc4b535ead9c85ce085fdce49b1b097531", "patch": "@@ -0,0 +1,39 @@\n+// Test that we do not suggest to add type annotations for unnamable types.\n+\n+#![crate_type=\"lib\"]\n+#![feature(generators)]\n+\n+const A = 5;\n+//~^ ERROR: missing type for `const` item\n+//~| HELP: provide a type for the item\n+\n+static B: _ = \"abc\";\n+//~^ ERROR: the type placeholder `_` is not allowed within types on item signatures\n+//~| NOTE: not allowed in type signatures\n+//~| HELP: replace with the correct type\n+\n+\n+// FIXME: this should also suggest a function pointer, as the closure is non-capturing\n+const C: _ = || 42;\n+//~^ ERROR: the type placeholder `_` is not allowed within types on item signatures\n+//~| NOTE: not allowed in type signatures\n+//~| NOTE: however, the inferred type\n+\n+struct S<T> { t: T }\n+const D = S { t: { let i = 0; move || -> i32 { i } } };\n+//~^ ERROR: missing type for `const` item\n+//~| NOTE: however, the inferred type\n+\n+\n+fn foo() -> i32 { 42 }\n+const E = foo;\n+//~^ ERROR: missing type for `const` item\n+//~| HELP: provide a type for the item\n+const F = S { t: foo };\n+//~^ ERROR: missing type for `const` item\n+//~| HELP: provide a type for the item\n+\n+\n+const G = || -> i32 { yield 0; return 1; };\n+//~^ ERROR: missing type for `const` item\n+//~| NOTE: however, the inferred type"}, {"sha": "2c8166781bfdc68aeae06f8a3485c01a85906e60", "filename": "src/test/ui/suggestions/unnamable-types.stderr", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/60f1a2fc4b535ead9c85ce085fdce49b1b097531/src%2Ftest%2Fui%2Fsuggestions%2Funnamable-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/60f1a2fc4b535ead9c85ce085fdce49b1b097531/src%2Ftest%2Fui%2Fsuggestions%2Funnamable-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Funnamable-types.stderr?ref=60f1a2fc4b535ead9c85ce085fdce49b1b097531", "patch": "@@ -0,0 +1,66 @@\n+error: missing type for `const` item\n+  --> $DIR/unnamable-types.rs:6:7\n+   |\n+LL | const A = 5;\n+   |       ^ help: provide a type for the item: `A: i32`\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/unnamable-types.rs:10:11\n+   |\n+LL | static B: _ = \"abc\";\n+   |           ^\n+   |           |\n+   |           not allowed in type signatures\n+   |           help: replace with the correct type: `&str`\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/unnamable-types.rs:17:10\n+   |\n+LL | const C: _ = || 42;\n+   |          ^ not allowed in type signatures\n+   |\n+note: however, the inferred type `[closure@$DIR/unnamable-types.rs:17:14: 17:19]` cannot be named\n+  --> $DIR/unnamable-types.rs:17:14\n+   |\n+LL | const C: _ = || 42;\n+   |              ^^^^^\n+\n+error: missing type for `const` item\n+  --> $DIR/unnamable-types.rs:23:7\n+   |\n+LL | const D = S { t: { let i = 0; move || -> i32 { i } } };\n+   |       ^\n+   |\n+note: however, the inferred type `S<[closure@$DIR/unnamable-types.rs:23:31: 23:51]>` cannot be named\n+  --> $DIR/unnamable-types.rs:23:11\n+   |\n+LL | const D = S { t: { let i = 0; move || -> i32 { i } } };\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: missing type for `const` item\n+  --> $DIR/unnamable-types.rs:29:7\n+   |\n+LL | const E = foo;\n+   |       ^ help: provide a type for the item: `E: fn() -> i32`\n+\n+error: missing type for `const` item\n+  --> $DIR/unnamable-types.rs:32:7\n+   |\n+LL | const F = S { t: foo };\n+   |       ^ help: provide a type for the item: `F: S<fn() -> i32>`\n+\n+error: missing type for `const` item\n+  --> $DIR/unnamable-types.rs:37:7\n+   |\n+LL | const G = || -> i32 { yield 0; return 1; };\n+   |       ^\n+   |\n+note: however, the inferred type `[generator@$DIR/unnamable-types.rs:37:11: 37:43 {i32, ()}]` cannot be named\n+  --> $DIR/unnamable-types.rs:37:11\n+   |\n+LL | const G = || -> i32 { yield 0; return 1; };\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 7 previous errors\n+\n+For more information about this error, try `rustc --explain E0121`."}]}