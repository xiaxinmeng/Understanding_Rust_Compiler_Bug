{"sha": "4a097ea53251e59063cf5bdc9901f0313664f90e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhMDk3ZWE1MzI1MWU1OTA2M2NmNWJkYzk5MDFmMDMxMzY2NGY5MGU=", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2018-03-25T03:37:31Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2018-03-25T03:37:31Z"}, "message": "Documentation and naming improvements", "tree": {"sha": "46ab2b262f3244d5f642acd02a7d05cc18a01066", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46ab2b262f3244d5f642acd02a7d05cc18a01066"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a097ea53251e59063cf5bdc9901f0313664f90e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a097ea53251e59063cf5bdc9901f0313664f90e", "html_url": "https://github.com/rust-lang/rust/commit/4a097ea53251e59063cf5bdc9901f0313664f90e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a097ea53251e59063cf5bdc9901f0313664f90e/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02b5851258c5a0db32d1c735d1c29e5e56f45ed1", "url": "https://api.github.com/repos/rust-lang/rust/commits/02b5851258c5a0db32d1c735d1c29e5e56f45ed1", "html_url": "https://github.com/rust-lang/rust/commit/02b5851258c5a0db32d1c735d1c29e5e56f45ed1"}], "stats": {"total": 48, "additions": 33, "deletions": 15}, "files": [{"sha": "3fc8421d3b04e75f24df77e7abf43e393229a5b1", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4a097ea53251e59063cf5bdc9901f0313664f90e/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a097ea53251e59063cf5bdc9901f0313664f90e/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=4a097ea53251e59063cf5bdc9901f0313664f90e", "patch": "@@ -669,7 +669,7 @@ impl<T: ?Sized> *const T {\n     /// `mem::size_of::<T>()` then the result of the division is rounded towards\n     /// zero.\n     ///\n-    /// This function returns `None` if `T` is a zero-sized typed.\n+    /// This function returns `None` if `T` is a zero-sized type.\n     ///\n     /// # Examples\n     ///\n@@ -719,7 +719,7 @@ impl<T: ?Sized> *const T {\n     /// * The distance between the pointers, **in bytes**, cannot overflow an `isize`.\n     ///\n     /// * The distance between the pointers, in bytes, must be an exact multiple\n-    ///   of the size of `T` and `T` must not be a Zero-Sized Type (\"ZST\").\n+    ///   of the size of `T`.\n     ///\n     /// * The distance being in bounds cannot rely on \"wrapping around\" the address space.\n     ///\n@@ -740,6 +740,10 @@ impl<T: ?Sized> *const T {\n     /// difficult to satisfy. The only advantage of this method is that it\n     /// enables more aggressive compiler optimizations.\n     ///\n+    /// # Panics\n+    ///\n+    /// This function panics if `T` is a Zero-Sized Type (\"ZST\").\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -759,12 +763,14 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n     #[inline]\n-    pub unsafe fn offset_from(self, other: *const T) -> isize where T: Sized {\n+    pub unsafe fn offset_from(self, origin: *const T) -> isize where T: Sized {\n         let pointee_size = mem::size_of::<T>();\n         assert!(0 < pointee_size && pointee_size <= isize::max_value() as usize);\n \n-        // FIXME: can this be nuw/nsw?\n-        let d = isize::wrapping_sub(self as _, other as _);\n+        // This is the same sequence that Clang emits for pointer subtraction.\n+        // It can be neither `nsw` nor `nuw` because the input is treated as\n+        // unsigned but then the output is treated as signed, so neither works.\n+        let d = isize::wrapping_sub(self as _, origin as _);\n         intrinsics::exact_div(d, pointee_size as _)\n     }\n \n@@ -775,9 +781,13 @@ impl<T: ?Sized> *const T {\n     /// `mem::size_of::<T>()` then the result of the division is rounded towards\n     /// zero.\n     ///\n+    /// Though this method is safe for any two pointers, note that its result\n+    /// will be mostly useless if the two pointers aren't into the same allocated\n+    /// object, for example if they point to two different local variables.\n+    ///\n     /// # Panics\n     ///\n-    /// This function panics if `T` is a zero-sized typed.\n+    /// This function panics if `T` is a zero-sized type.\n     ///\n     /// # Examples\n     ///\n@@ -800,11 +810,11 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[unstable(feature = \"ptr_wrapping_offset_from\", issue = \"41079\")]\n     #[inline]\n-    pub fn wrapping_offset_from(self, other: *const T) -> isize where T: Sized {\n+    pub fn wrapping_offset_from(self, origin: *const T) -> isize where T: Sized {\n         let pointee_size = mem::size_of::<T>();\n         assert!(0 < pointee_size && pointee_size <= isize::max_value() as usize);\n \n-        let d = isize::wrapping_sub(self as _, other as _);\n+        let d = isize::wrapping_sub(self as _, origin as _);\n         d.wrapping_div(pointee_size as _)\n     }\n \n@@ -1424,7 +1434,7 @@ impl<T: ?Sized> *mut T {\n     /// `mem::size_of::<T>()` then the result of the division is rounded towards\n     /// zero.\n     ///\n-    /// This function returns `None` if `T` is a zero-sized typed.\n+    /// This function returns `None` if `T` is a zero-sized type.\n     ///\n     /// # Examples\n     ///\n@@ -1474,7 +1484,7 @@ impl<T: ?Sized> *mut T {\n     /// * The distance between the pointers, **in bytes**, cannot overflow an `isize`.\n     ///\n     /// * The distance between the pointers, in bytes, must be an exact multiple\n-    ///   of the size of `T` and `T` must not be a Zero-Sized Type (\"ZST\").\n+    ///   of the size of `T`.\n     ///\n     /// * The distance being in bounds cannot rely on \"wrapping around\" the address space.\n     ///\n@@ -1495,6 +1505,10 @@ impl<T: ?Sized> *mut T {\n     /// difficult to satisfy. The only advantage of this method is that it\n     /// enables more aggressive compiler optimizations.\n     ///\n+    /// # Panics\n+    ///\n+    /// This function panics if `T` is a Zero-Sized Type (\"ZST\").\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1514,8 +1528,8 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n     #[inline]\n-    pub unsafe fn offset_from(self, other: *const T) -> isize where T: Sized {\n-        (self as *const T).offset_from(other)\n+    pub unsafe fn offset_from(self, origin: *const T) -> isize where T: Sized {\n+        (self as *const T).offset_from(origin)\n     }\n \n     /// Calculates the distance between two pointers. The returned value is in\n@@ -1525,9 +1539,13 @@ impl<T: ?Sized> *mut T {\n     /// `mem::size_of::<T>()` then the result of the division is rounded towards\n     /// zero.\n     ///\n+    /// Though this method is safe for any two pointers, note that its result\n+    /// will be mostly useless if the two pointers aren't into the same allocated\n+    /// object, for example if they point to two different local variables.\n+    ///\n     /// # Panics\n     ///\n-    /// This function panics if `T` is a zero-sized typed.\n+    /// This function panics if `T` is a zero-sized type.\n     ///\n     /// # Examples\n     ///\n@@ -1550,8 +1568,8 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[unstable(feature = \"ptr_wrapping_offset_from\", issue = \"41079\")]\n     #[inline]\n-    pub fn wrapping_offset_from(self, other: *const T) -> isize where T: Sized {\n-        (self as *const T).wrapping_offset_from(other)\n+    pub fn wrapping_offset_from(self, origin: *const T) -> isize where T: Sized {\n+        (self as *const T).wrapping_offset_from(origin)\n     }\n \n     /// Computes the byte offset that needs to be applied in order to"}]}