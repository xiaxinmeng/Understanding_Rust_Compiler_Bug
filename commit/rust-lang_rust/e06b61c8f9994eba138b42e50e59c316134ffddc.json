{"sha": "e06b61c8f9994eba138b42e50e59c316134ffddc", "node_id": "C_kwDOAAsO6NoAKGUwNmI2MWM4Zjk5OTRlYmExMzhiNDJlNTBlNTljMzE2MTM0ZmZkZGM", "commit": {"author": {"name": "Lukas Markeffsky", "email": "@", "date": "2022-11-25T15:13:52Z"}, "committer": {"name": "Lukas Markeffsky", "email": "@", "date": "2022-11-26T15:14:03Z"}, "message": "explain how to get the discriminant out of a `#[repr(T)] enum`", "tree": {"sha": "74830099b5b049cf7fce73369c5ad49fbc0d339c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74830099b5b049cf7fce73369c5ad49fbc0d339c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e06b61c8f9994eba138b42e50e59c316134ffddc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e06b61c8f9994eba138b42e50e59c316134ffddc", "html_url": "https://github.com/rust-lang/rust/commit/e06b61c8f9994eba138b42e50e59c316134ffddc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e06b61c8f9994eba138b42e50e59c316134ffddc/comments", "author": null, "committer": null, "parents": [{"sha": "8a75c5a9b5d9c48aa576b08faf735b926d0d9a71", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a75c5a9b5d9c48aa576b08faf735b926d0d9a71", "html_url": "https://github.com/rust-lang/rust/commit/8a75c5a9b5d9c48aa576b08faf735b926d0d9a71"}], "stats": {"total": 61, "additions": 60, "deletions": 1}, "files": [{"sha": "723988b33ab5c839011dc38b9fa849e098aecc72", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e06b61c8f9994eba138b42e50e59c316134ffddc/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e06b61c8f9994eba138b42e50e59c316134ffddc/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=e06b61c8f9994eba138b42e50e59c316134ffddc", "patch": "@@ -1113,7 +1113,10 @@ impl<T> fmt::Debug for Discriminant<T> {\n /// # Stability\n ///\n /// The discriminant of an enum variant may change if the enum definition changes. A discriminant\n-/// of some variant will not change between compilations with the same compiler.\n+/// of some variant will not change between compilations with the same compiler. See the [Reference]\n+/// for more information.\n+///\n+/// [Reference]: ../../reference/items/enumerations.html#discriminants\n ///\n /// # Examples\n ///\n@@ -1129,6 +1132,62 @@ impl<T> fmt::Debug for Discriminant<T> {\n /// assert_eq!(mem::discriminant(&Foo::B(1)), mem::discriminant(&Foo::B(2)));\n /// assert_ne!(mem::discriminant(&Foo::B(3)), mem::discriminant(&Foo::C(3)));\n /// ```\n+///\n+/// ## Accessing the numeric value of the discriminant\n+///\n+/// Note that it is *undefined behavior* to [`transmute`] from [`Discriminant`] to a primitive!\n+///\n+/// If an enum has only unit variants, then the numeric value of the discriminant can be accessed\n+/// with an [`as`] cast:\n+///\n+/// ```\n+/// enum Enum {\n+///     Foo,\n+///     Bar,\n+///     Baz,\n+/// }\n+///\n+/// assert_eq!(0, Enum::Foo as isize);\n+/// assert_eq!(1, Enum::Bar as isize);\n+/// assert_eq!(2, Enum::Baz as isize);\n+/// ```\n+///\n+/// If an enum has opted-in to having a [primitive representation] for its discriminant,\n+/// then it's possible to use pointers to read the memory location storing the discriminant.\n+/// That **cannot** be done for enums using the [default representation], however, as it's\n+/// undefined what layout the discriminant has and where it's stored \u2014 it might not even be\n+/// stored at all!\n+///\n+/// [`as`]: ../../std/keyword.as.html\n+/// [primitive representation]: ../../reference/type-layout.html#primitive-representations\n+/// [default representation]: ../../reference/type-layout.html#the-default-representation\n+/// ```\n+/// #[repr(u8)]\n+/// enum Enum {\n+///     Unit,\n+///     Tuple(bool),\n+///     Struct { a: bool },\n+/// }\n+///\n+/// impl Enum {\n+///     fn discriminant(&self) -> u8 {\n+///         // SAFETY: Because `Self` is marked `repr(u8)`, its layout is a `repr(C)` `union`\n+///         // between `repr(C)` structs, each of which has the `u8` discriminant as its first\n+///         // field, so we can read the discriminant without offsetting the pointer.\n+///         unsafe { *<*const _>::from(self).cast::<u8>() }\n+///     }\n+/// }\n+///\n+/// let unit_like = Enum::Unit;\n+/// let tuple_like = Enum::Tuple(true);\n+/// let struct_like = Enum::Struct { a: false };\n+/// assert_eq!(0, unit_like.discriminant());\n+/// assert_eq!(1, tuple_like.discriminant());\n+/// assert_eq!(2, struct_like.discriminant());\n+///\n+/// // \u26a0\ufe0f This is undefined behavior. Don't do this. \u26a0\ufe0f\n+/// // assert_eq!(0, unsafe { std::mem::transmute::<_, u8>(std::mem::discriminant(&unit_like)) });\n+/// ```\n #[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n #[rustc_const_unstable(feature = \"const_discriminant\", issue = \"69821\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"mem_discriminant\")]"}]}