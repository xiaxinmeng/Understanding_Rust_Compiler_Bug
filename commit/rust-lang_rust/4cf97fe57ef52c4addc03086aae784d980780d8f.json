{"sha": "4cf97fe57ef52c4addc03086aae784d980780d8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjZjk3ZmU1N2VmNTJjNGFkZGMwMzA4NmFhZTc4NGQ5ODA3ODBkOGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-07T15:39:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-07T15:39:36Z"}, "message": "Auto merge of #34677 - alexcrichton:no-more-build-directory, r=brson\n\nrustbuild: Remove the `build` directory\n\nThe organization in rustbuild was a little odd at the moment where the `lib.rs`\nwas quite small but the binary `main.rs` was much larger. Unfortunately as well\nthere was a `build/` directory with the implementation of the build system, but\nthis directory was ignored by GitHub on the file-search prompt which was a\nlittle annoying.\n\nThis commit reorganizes rustbuild slightly where all the library files (the\nbuild system) is located directly inside of `src/bootstrap` and all the binaries\nnow live in `src/bootstrap/bin` (they're small). Hopefully this should allow\nGitHub to index and allow navigating all the files while maintaining a\nrelatively similar layout to the other libraries in `src/`.", "tree": {"sha": "aaf02bf811556665d82aa669e1f80f6c46b495e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aaf02bf811556665d82aa669e1f80f6c46b495e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4cf97fe57ef52c4addc03086aae784d980780d8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4cf97fe57ef52c4addc03086aae784d980780d8f", "html_url": "https://github.com/rust-lang/rust/commit/4cf97fe57ef52c4addc03086aae784d980780d8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4cf97fe57ef52c4addc03086aae784d980780d8f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c1783a3a0bff2bdc4992769d2bb2f12bc728477", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c1783a3a0bff2bdc4992769d2bb2f12bc728477", "html_url": "https://github.com/rust-lang/rust/commit/9c1783a3a0bff2bdc4992769d2bb2f12bc728477"}, {"sha": "48a07bfb958a48da0c909f4607eb0cf9118fc902", "url": "https://api.github.com/repos/rust-lang/rust/commits/48a07bfb958a48da0c909f4607eb0cf9118fc902", "html_url": "https://github.com/rust-lang/rust/commit/48a07bfb958a48da0c909f4607eb0cf9118fc902"}], "stats": {"total": 1839, "additions": 909, "deletions": 930}, "files": [{"sha": "cde4a825be1fb81259d354b3cd266bfc47ab84d9", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=4cf97fe57ef52c4addc03086aae784d980780d8f", "patch": "@@ -9,15 +9,15 @@ path = \"lib.rs\"\n \n [[bin]]\n name = \"bootstrap\"\n-path = \"main.rs\"\n+path = \"bin/main.rs\"\n \n [[bin]]\n name = \"rustc\"\n-path = \"rustc.rs\"\n+path = \"bin/rustc.rs\"\n \n [[bin]]\n name = \"rustdoc\"\n-path = \"rustdoc.rs\"\n+path = \"bin/rustdoc.rs\"\n \n [dependencies]\n build_helper = { path = \"../build_helper\" }"}, {"sha": "c47f4fd8ec64b8f288855ae6638e56a3142bd68b", "filename": "src/bootstrap/bin/main.rs", "status": "renamed", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fmain.rs?ref=4cf97fe57ef52c4addc03086aae784d980780d8f", "patch": "@@ -18,22 +18,10 @@\n #![deny(warnings)]\n \n extern crate bootstrap;\n-extern crate build_helper;\n-extern crate cmake;\n-extern crate filetime;\n-extern crate gcc;\n-extern crate getopts;\n-extern crate libc;\n-extern crate num_cpus;\n-extern crate rustc_serialize;\n-extern crate toml;\n-extern crate md5;\n \n use std::env;\n \n-use build::{Flags, Config, Build};\n-\n-mod build;\n+use bootstrap::{Flags, Config, Build};\n \n fn main() {\n     let args = env::args().skip(1).collect::<Vec<_>>();", "previous_filename": "src/bootstrap/main.rs"}, {"sha": "c64cbb9a74e09573f698d6c295342d9376c40f3e", "filename": "src/bootstrap/bin/rustc.rs", "status": "renamed", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=4cf97fe57ef52c4addc03086aae784d980780d8f", "patch": "@@ -53,13 +53,14 @@ fn main() {\n \n     let rustc = env::var_os(rustc).unwrap();\n     let libdir = env::var_os(libdir).unwrap();\n-    let mut dylib_path = bootstrap::dylib_path();\n+    let mut dylib_path = bootstrap::util::dylib_path();\n     dylib_path.insert(0, PathBuf::from(libdir));\n \n     let mut cmd = Command::new(rustc);\n     cmd.args(&args)\n        .arg(\"--cfg\").arg(format!(\"stage{}\", stage))\n-       .env(bootstrap::dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n+       .env(bootstrap::util::dylib_path_var(),\n+            env::join_paths(&dylib_path).unwrap());\n \n     if let Some(target) = target {\n         // The stage0 compiler has a special sysroot distinct from what we", "previous_filename": "src/bootstrap/rustc.rs"}, {"sha": "79629bfd717118fc9e53f3167ae89d03f2dfab8a", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "renamed", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=4cf97fe57ef52c4addc03086aae784d980780d8f", "patch": "@@ -23,14 +23,15 @@ fn main() {\n     let rustdoc = env::var_os(\"RUSTDOC_REAL\").unwrap();\n     let libdir = env::var_os(\"RUSTC_LIBDIR\").unwrap();\n \n-    let mut dylib_path = bootstrap::dylib_path();\n+    let mut dylib_path = bootstrap::util::dylib_path();\n     dylib_path.insert(0, PathBuf::from(libdir));\n \n     let mut cmd = Command::new(rustdoc);\n     cmd.args(&args)\n        .arg(\"--cfg\").arg(format!(\"stage{}\", env::var(\"RUSTC_STAGE\").unwrap()))\n        .arg(\"--cfg\").arg(\"dox\")\n-       .env(bootstrap::dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n+       .env(bootstrap::util::dylib_path_var(),\n+            env::join_paths(&dylib_path).unwrap());\n     std::process::exit(match cmd.status() {\n         Ok(s) => s.code().unwrap_or(1),\n         Err(e) => panic!(\"\\n\\nfailed to run {:?}: {}\\n\\n\", cmd, e),", "previous_filename": "src/bootstrap/rustdoc.rs"}, {"sha": "195d1bc90c655fb191f832aeaa46c6bf8e3eb45a", "filename": "src/bootstrap/build/mod.rs", "status": "removed", "additions": 0, "deletions": 871, "changes": 871, "blob_url": "https://github.com/rust-lang/rust/blob/9c1783a3a0bff2bdc4992769d2bb2f12bc728477/src%2Fbootstrap%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1783a3a0bff2bdc4992769d2bb2f12bc728477/src%2Fbootstrap%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fmod.rs?ref=9c1783a3a0bff2bdc4992769d2bb2f12bc728477", "patch": "@@ -1,871 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Implementation of rustbuild, the Rust build system.\n-//!\n-//! This module, and its descendants, are the implementation of the Rust build\n-//! system. Most of this build system is backed by Cargo but the outer layer\n-//! here serves as the ability to orchestrate calling Cargo, sequencing Cargo\n-//! builds, building artifacts like LLVM, etc.\n-//!\n-//! More documentation can be found in each respective module below.\n-\n-use std::cell::RefCell;\n-use std::collections::HashMap;\n-use std::env;\n-use std::fs::{self, File};\n-use std::path::{PathBuf, Path};\n-use std::process::Command;\n-\n-use build_helper::{run_silent, output};\n-use gcc;\n-use num_cpus;\n-\n-use build::util::{exe, mtime, libdir, add_lib_path};\n-\n-/// A helper macro to `unwrap` a result except also print out details like:\n-///\n-/// * The file/line of the panic\n-/// * The expression that failed\n-/// * The error itself\n-///\n-/// This is currently used judiciously throughout the build system rather than\n-/// using a `Result` with `try!`, but this may change on day...\n-macro_rules! t {\n-    ($e:expr) => (match $e {\n-        Ok(e) => e,\n-        Err(e) => panic!(\"{} failed with {}\", stringify!($e), e),\n-    })\n-}\n-\n-mod cc;\n-mod channel;\n-mod check;\n-mod clean;\n-mod compile;\n-mod config;\n-mod dist;\n-mod doc;\n-mod flags;\n-mod native;\n-mod sanity;\n-mod step;\n-mod util;\n-\n-#[cfg(windows)]\n-mod job;\n-\n-#[cfg(not(windows))]\n-mod job {\n-    pub unsafe fn setup() {}\n-}\n-\n-pub use build::config::Config;\n-pub use build::flags::Flags;\n-\n-/// A structure representing a Rust compiler.\n-///\n-/// Each compiler has a `stage` that it is associated with and a `host` that\n-/// corresponds to the platform the compiler runs on. This structure is used as\n-/// a parameter to many methods below.\n-#[derive(Eq, PartialEq, Clone, Copy, Hash, Debug)]\n-pub struct Compiler<'a> {\n-    stage: u32,\n-    host: &'a str,\n-}\n-\n-/// Global configuration for the build system.\n-///\n-/// This structure transitively contains all configuration for the build system.\n-/// All filesystem-encoded configuration is in `config`, all flags are in\n-/// `flags`, and then parsed or probed information is listed in the keys below.\n-///\n-/// This structure is a parameter of almost all methods in the build system,\n-/// although most functions are implemented as free functions rather than\n-/// methods specifically on this structure itself (to make it easier to\n-/// organize).\n-pub struct Build {\n-    // User-specified configuration via config.toml\n-    config: Config,\n-\n-    // User-specified configuration via CLI flags\n-    flags: Flags,\n-\n-    // Derived properties from the above two configurations\n-    cargo: PathBuf,\n-    rustc: PathBuf,\n-    src: PathBuf,\n-    out: PathBuf,\n-    release: String,\n-    unstable_features: bool,\n-    ver_hash: Option<String>,\n-    short_ver_hash: Option<String>,\n-    ver_date: Option<String>,\n-    version: String,\n-    package_vers: String,\n-    bootstrap_key: String,\n-    bootstrap_key_stage0: String,\n-\n-    // Probed tools at runtime\n-    gdb_version: Option<String>,\n-    lldb_version: Option<String>,\n-    lldb_python_dir: Option<String>,\n-\n-    // Runtime state filled in later on\n-    cc: HashMap<String, (gcc::Tool, Option<PathBuf>)>,\n-    cxx: HashMap<String, gcc::Tool>,\n-    compiler_rt_built: RefCell<HashMap<String, PathBuf>>,\n-}\n-\n-/// The various \"modes\" of invoking Cargo.\n-///\n-/// These entries currently correspond to the various output directories of the\n-/// build system, with each mod generating output in a different directory.\n-#[derive(Clone, Copy)]\n-pub enum Mode {\n-    /// This cargo is going to build the standard library, placing output in the\n-    /// \"stageN-std\" directory.\n-    Libstd,\n-\n-    /// This cargo is going to build libtest, placing output in the\n-    /// \"stageN-test\" directory.\n-    Libtest,\n-\n-    /// This cargo is going to build librustc and compiler libraries, placing\n-    /// output in the \"stageN-rustc\" directory.\n-    Librustc,\n-\n-    /// This cargo is going to some build tool, placing output in the\n-    /// \"stageN-tools\" directory.\n-    Tool,\n-}\n-\n-impl Build {\n-    /// Creates a new set of build configuration from the `flags` on the command\n-    /// line and the filesystem `config`.\n-    ///\n-    /// By default all build output will be placed in the current directory.\n-    pub fn new(flags: Flags, config: Config) -> Build {\n-        let cwd = t!(env::current_dir());\n-        let src = flags.src.clone().unwrap_or(cwd.clone());\n-        let out = cwd.join(\"build\");\n-\n-        let stage0_root = out.join(&config.build).join(\"stage0/bin\");\n-        let rustc = match config.rustc {\n-            Some(ref s) => PathBuf::from(s),\n-            None => stage0_root.join(exe(\"rustc\", &config.build)),\n-        };\n-        let cargo = match config.cargo {\n-            Some(ref s) => PathBuf::from(s),\n-            None => stage0_root.join(exe(\"cargo\", &config.build)),\n-        };\n-\n-        Build {\n-            flags: flags,\n-            config: config,\n-            cargo: cargo,\n-            rustc: rustc,\n-            src: src,\n-            out: out,\n-\n-            release: String::new(),\n-            unstable_features: false,\n-            ver_hash: None,\n-            short_ver_hash: None,\n-            ver_date: None,\n-            version: String::new(),\n-            bootstrap_key: String::new(),\n-            bootstrap_key_stage0: String::new(),\n-            package_vers: String::new(),\n-            cc: HashMap::new(),\n-            cxx: HashMap::new(),\n-            compiler_rt_built: RefCell::new(HashMap::new()),\n-            gdb_version: None,\n-            lldb_version: None,\n-            lldb_python_dir: None,\n-        }\n-    }\n-\n-    /// Executes the entire build, as configured by the flags and configuration.\n-    pub fn build(&mut self) {\n-        use build::step::Source::*;\n-\n-        unsafe {\n-            job::setup();\n-        }\n-\n-        if self.flags.clean {\n-            return clean::clean(self);\n-        }\n-\n-        self.verbose(\"finding compilers\");\n-        cc::find(self);\n-        self.verbose(\"running sanity check\");\n-        sanity::check(self);\n-        self.verbose(\"collecting channel variables\");\n-        channel::collect(self);\n-        self.verbose(\"updating submodules\");\n-        self.update_submodules();\n-\n-        // The main loop of the build system.\n-        //\n-        // The `step::all` function returns a topographically sorted list of all\n-        // steps that need to be executed as part of this build. Each step has a\n-        // corresponding entry in `step.rs` and indicates some unit of work that\n-        // needs to be done as part of the build.\n-        //\n-        // Almost all of these are simple one-liners that shell out to the\n-        // corresponding functionality in the extra modules, where more\n-        // documentation can be found.\n-        for target in step::all(self) {\n-            let doc_out = self.out.join(&target.target).join(\"doc\");\n-            match target.src {\n-                Llvm { _dummy } => {\n-                    native::llvm(self, target.target);\n-                }\n-                CompilerRt { _dummy } => {\n-                    native::compiler_rt(self, target.target);\n-                }\n-                TestHelpers { _dummy } => {\n-                    native::test_helpers(self, target.target);\n-                }\n-                Libstd { compiler } => {\n-                    compile::std(self, target.target, &compiler);\n-                }\n-                Libtest { compiler } => {\n-                    compile::test(self, target.target, &compiler);\n-                }\n-                Librustc { compiler } => {\n-                    compile::rustc(self, target.target, &compiler);\n-                }\n-                LibstdLink { compiler, host } => {\n-                    compile::std_link(self, target.target, &compiler, host);\n-                }\n-                LibtestLink { compiler, host } => {\n-                    compile::test_link(self, target.target, &compiler, host);\n-                }\n-                LibrustcLink { compiler, host } => {\n-                    compile::rustc_link(self, target.target, &compiler, host);\n-                }\n-                Rustc { stage: 0 } => {\n-                    // nothing to do...\n-                }\n-                Rustc { stage } => {\n-                    compile::assemble_rustc(self, stage, target.target);\n-                }\n-                ToolLinkchecker { stage } => {\n-                    compile::tool(self, stage, target.target, \"linkchecker\");\n-                }\n-                ToolRustbook { stage } => {\n-                    compile::tool(self, stage, target.target, \"rustbook\");\n-                }\n-                ToolErrorIndex { stage } => {\n-                    compile::tool(self, stage, target.target,\n-                                  \"error_index_generator\");\n-                }\n-                ToolCargoTest { stage } => {\n-                    compile::tool(self, stage, target.target, \"cargotest\");\n-                }\n-                ToolTidy { stage } => {\n-                    compile::tool(self, stage, target.target, \"tidy\");\n-                }\n-                ToolCompiletest { stage } => {\n-                    compile::tool(self, stage, target.target, \"compiletest\");\n-                }\n-                DocBook { stage } => {\n-                    doc::rustbook(self, stage, target.target, \"book\", &doc_out);\n-                }\n-                DocNomicon { stage } => {\n-                    doc::rustbook(self, stage, target.target, \"nomicon\",\n-                                  &doc_out);\n-                }\n-                DocStyle { stage } => {\n-                    doc::rustbook(self, stage, target.target, \"style\",\n-                                  &doc_out);\n-                }\n-                DocStandalone { stage } => {\n-                    doc::standalone(self, stage, target.target, &doc_out);\n-                }\n-                DocStd { stage } => {\n-                    doc::std(self, stage, target.target, &doc_out);\n-                }\n-                DocTest { stage } => {\n-                    doc::test(self, stage, target.target, &doc_out);\n-                }\n-                DocRustc { stage } => {\n-                    doc::rustc(self, stage, target.target, &doc_out);\n-                }\n-                DocErrorIndex { stage } => {\n-                    doc::error_index(self, stage, target.target, &doc_out);\n-                }\n-\n-                CheckLinkcheck { stage } => {\n-                    check::linkcheck(self, stage, target.target);\n-                }\n-                CheckCargoTest { stage } => {\n-                    check::cargotest(self, stage, target.target);\n-                }\n-                CheckTidy { stage } => {\n-                    check::tidy(self, stage, target.target);\n-                }\n-                CheckRPass { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"run-pass\", \"run-pass\");\n-                }\n-                CheckRPassFull { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"run-pass\", \"run-pass-fulldeps\");\n-                }\n-                CheckCFail { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"compile-fail\", \"compile-fail\");\n-                }\n-                CheckCFailFull { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"compile-fail\", \"compile-fail-fulldeps\")\n-                }\n-                CheckPFail { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"parse-fail\", \"parse-fail\");\n-                }\n-                CheckRFail { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"run-fail\", \"run-fail\");\n-                }\n-                CheckRFailFull { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"run-fail\", \"run-fail-fulldeps\");\n-                }\n-                CheckPretty { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"pretty\", \"pretty\");\n-                }\n-                CheckPrettyRPass { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"pretty\", \"run-pass\");\n-                }\n-                CheckPrettyRPassFull { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"pretty\", \"run-pass-fulldeps\");\n-                }\n-                CheckPrettyRFail { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"pretty\", \"run-fail\");\n-                }\n-                CheckPrettyRFailFull { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"pretty\", \"run-fail-fulldeps\");\n-                }\n-                CheckPrettyRPassValgrind { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"pretty\", \"run-pass-valgrind\");\n-                }\n-                CheckCodegen { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"codegen\", \"codegen\");\n-                }\n-                CheckCodegenUnits { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"codegen-units\", \"codegen-units\");\n-                }\n-                CheckIncremental { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"incremental\", \"incremental\");\n-                }\n-                CheckUi { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"ui\", \"ui\");\n-                }\n-                CheckDebuginfo { compiler } => {\n-                    if target.target.contains(\"msvc\") {\n-                        // nothing to do\n-                    } else if target.target.contains(\"apple\") {\n-                        check::compiletest(self, &compiler, target.target,\n-                                           \"debuginfo-lldb\", \"debuginfo\");\n-                    } else {\n-                        check::compiletest(self, &compiler, target.target,\n-                                           \"debuginfo-gdb\", \"debuginfo\");\n-                    }\n-                }\n-                CheckRustdoc { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"rustdoc\", \"rustdoc\");\n-                }\n-                CheckRPassValgrind { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"run-pass-valgrind\", \"run-pass-valgrind\");\n-                }\n-                CheckDocs { compiler } => {\n-                    check::docs(self, &compiler);\n-                }\n-                CheckErrorIndex { compiler } => {\n-                    check::error_index(self, &compiler);\n-                }\n-                CheckRMake { compiler } => {\n-                    check::compiletest(self, &compiler, target.target,\n-                                       \"run-make\", \"run-make\")\n-                }\n-                CheckCrateStd { compiler } => {\n-                    check::krate(self, &compiler, target.target, Mode::Libstd)\n-                }\n-                CheckCrateTest { compiler } => {\n-                    check::krate(self, &compiler, target.target, Mode::Libtest)\n-                }\n-                CheckCrateRustc { compiler } => {\n-                    check::krate(self, &compiler, target.target, Mode::Librustc)\n-                }\n-\n-                DistDocs { stage } => dist::docs(self, stage, target.target),\n-                DistMingw { _dummy } => dist::mingw(self, target.target),\n-                DistRustc { stage } => dist::rustc(self, stage, target.target),\n-                DistStd { compiler } => dist::std(self, &compiler, target.target),\n-\n-                DebuggerScripts { stage } => {\n-                    let compiler = Compiler::new(stage, target.target);\n-                    dist::debugger_scripts(self,\n-                                           &self.sysroot(&compiler),\n-                                           target.target);\n-                }\n-\n-                AndroidCopyLibs { compiler } => {\n-                    check::android_copy_libs(self, &compiler, target.target);\n-                }\n-\n-                // pseudo-steps\n-                Dist { .. } |\n-                Doc { .. } |\n-                CheckTarget { .. } |\n-                Check { .. } => {}\n-            }\n-        }\n-    }\n-\n-    /// Updates all git submodules that we have.\n-    ///\n-    /// This will detect if any submodules are out of date an run the necessary\n-    /// commands to sync them all with upstream.\n-    fn update_submodules(&self) {\n-        if !self.config.submodules {\n-            return\n-        }\n-        if fs::metadata(self.src.join(\".git\")).is_err() {\n-            return\n-        }\n-        let git_submodule = || {\n-            let mut cmd = Command::new(\"git\");\n-            cmd.current_dir(&self.src).arg(\"submodule\");\n-            return cmd\n-        };\n-\n-        // FIXME: this takes a seriously long time to execute on Windows and a\n-        //        nontrivial amount of time on Unix, we should have a better way\n-        //        of detecting whether we need to run all the submodule commands\n-        //        below.\n-        let out = output(git_submodule().arg(\"status\"));\n-        if !out.lines().any(|l| l.starts_with(\"+\") || l.starts_with(\"-\")) {\n-            return\n-        }\n-\n-        self.run(git_submodule().arg(\"sync\"));\n-        self.run(git_submodule().arg(\"init\"));\n-        self.run(git_submodule().arg(\"update\"));\n-        self.run(git_submodule().arg(\"update\").arg(\"--recursive\"));\n-        self.run(git_submodule().arg(\"status\").arg(\"--recursive\"));\n-        self.run(git_submodule().arg(\"foreach\").arg(\"--recursive\")\n-                                .arg(\"git\").arg(\"clean\").arg(\"-fdx\"));\n-        self.run(git_submodule().arg(\"foreach\").arg(\"--recursive\")\n-                                .arg(\"git\").arg(\"checkout\").arg(\".\"));\n-    }\n-\n-    /// Clear out `dir` if `input` is newer.\n-    ///\n-    /// After this executes, it will also ensure that `dir` exists.\n-    fn clear_if_dirty(&self, dir: &Path, input: &Path) {\n-        let stamp = dir.join(\".stamp\");\n-        if mtime(&stamp) < mtime(input) {\n-            self.verbose(&format!(\"Dirty - {}\", dir.display()));\n-            let _ = fs::remove_dir_all(dir);\n-        }\n-        t!(fs::create_dir_all(dir));\n-        t!(File::create(stamp));\n-    }\n-\n-    /// Prepares an invocation of `cargo` to be run.\n-    ///\n-    /// This will create a `Command` that represents a pending execution of\n-    /// Cargo. This cargo will be configured to use `compiler` as the actual\n-    /// rustc compiler, its output will be scoped by `mode`'s output directory,\n-    /// it will pass the `--target` flag for the specified `target`, and will be\n-    /// executing the Cargo command `cmd`.\n-    fn cargo(&self,\n-             compiler: &Compiler,\n-             mode: Mode,\n-             target: &str,\n-             cmd: &str) -> Command {\n-        let mut cargo = Command::new(&self.cargo);\n-        let out_dir = self.stage_out(compiler, mode);\n-        cargo.env(\"CARGO_TARGET_DIR\", out_dir)\n-             .arg(cmd)\n-             .arg(\"-j\").arg(self.jobs().to_string())\n-             .arg(\"--target\").arg(target);\n-\n-        let stage;\n-        if compiler.stage == 0 && self.config.local_rebuild {\n-            // Assume the local-rebuild rustc already has stage1 features.\n-            stage = 1;\n-        } else {\n-            stage = compiler.stage;\n-        }\n-\n-        // Customize the compiler we're running. Specify the compiler to cargo\n-        // as our shim and then pass it some various options used to configure\n-        // how the actual compiler itself is called.\n-        //\n-        // These variables are primarily all read by\n-        // src/bootstrap/{rustc,rustdoc.rs}\n-        cargo.env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n-             .env(\"RUSTC_REAL\", self.compiler_path(compiler))\n-             .env(\"RUSTC_STAGE\", stage.to_string())\n-             .env(\"RUSTC_DEBUGINFO\", self.config.rust_debuginfo.to_string())\n-             .env(\"RUSTC_CODEGEN_UNITS\",\n-                  self.config.rust_codegen_units.to_string())\n-             .env(\"RUSTC_DEBUG_ASSERTIONS\",\n-                  self.config.rust_debug_assertions.to_string())\n-             .env(\"RUSTC_SNAPSHOT\", &self.rustc)\n-             .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n-             .env(\"RUSTC_LIBDIR\", self.rustc_libdir(compiler))\n-             .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_snapshot_libdir())\n-             .env(\"RUSTC_RPATH\", self.config.rust_rpath.to_string())\n-             .env(\"RUSTDOC\", self.out.join(\"bootstrap/debug/rustdoc\"))\n-             .env(\"RUSTDOC_REAL\", self.rustdoc(compiler))\n-             .env(\"RUSTC_FLAGS\", self.rustc_flags(target).join(\" \"));\n-\n-        self.add_bootstrap_key(compiler, &mut cargo);\n-\n-        // Specify some various options for build scripts used throughout\n-        // the build.\n-        //\n-        // FIXME: the guard against msvc shouldn't need to be here\n-        if !target.contains(\"msvc\") {\n-            cargo.env(format!(\"CC_{}\", target), self.cc(target))\n-                 .env(format!(\"AR_{}\", target), self.ar(target).unwrap()) // only msvc is None\n-                 .env(format!(\"CFLAGS_{}\", target), self.cflags(target).join(\" \"));\n-        }\n-\n-        // If we're building for OSX, inform the compiler and the linker that\n-        // we want to build a compiler runnable on 10.7\n-        if target.contains(\"apple-darwin\") {\n-            cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", \"10.7\");\n-        }\n-\n-        // Environment variables *required* needed throughout the build\n-        //\n-        // FIXME: should update code to not require this env var\n-        cargo.env(\"CFG_COMPILER_HOST_TRIPLE\", target);\n-\n-        if self.config.verbose || self.flags.verbose {\n-            cargo.arg(\"-v\");\n-        }\n-        if self.config.rust_optimize {\n-            cargo.arg(\"--release\");\n-        }\n-        return cargo\n-    }\n-\n-    /// Get a path to the compiler specified.\n-    fn compiler_path(&self, compiler: &Compiler) -> PathBuf {\n-        if compiler.is_snapshot(self) {\n-            self.rustc.clone()\n-        } else {\n-            self.sysroot(compiler).join(\"bin\").join(exe(\"rustc\", compiler.host))\n-        }\n-    }\n-\n-    /// Get the specified tool built by the specified compiler\n-    fn tool(&self, compiler: &Compiler, tool: &str) -> PathBuf {\n-        self.cargo_out(compiler, Mode::Tool, compiler.host)\n-            .join(exe(tool, compiler.host))\n-    }\n-\n-    /// Get the `rustdoc` executable next to the specified compiler\n-    fn rustdoc(&self, compiler: &Compiler) -> PathBuf {\n-        let mut rustdoc = self.compiler_path(compiler);\n-        rustdoc.pop();\n-        rustdoc.push(exe(\"rustdoc\", compiler.host));\n-        return rustdoc\n-    }\n-\n-    /// Get a `Command` which is ready to run `tool` in `stage` built for\n-    /// `host`.\n-    fn tool_cmd(&self, compiler: &Compiler, tool: &str) -> Command {\n-        let mut cmd = Command::new(self.tool(&compiler, tool));\n-        let host = compiler.host;\n-        let paths = vec![\n-            self.cargo_out(compiler, Mode::Libstd, host).join(\"deps\"),\n-            self.cargo_out(compiler, Mode::Libtest, host).join(\"deps\"),\n-            self.cargo_out(compiler, Mode::Librustc, host).join(\"deps\"),\n-            self.cargo_out(compiler, Mode::Tool, host).join(\"deps\"),\n-        ];\n-        add_lib_path(paths, &mut cmd);\n-        return cmd\n-    }\n-\n-    /// Get the space-separated set of activated features for the standard\n-    /// library.\n-    fn std_features(&self) -> String {\n-        let mut features = String::new();\n-        if self.config.debug_jemalloc {\n-            features.push_str(\" debug-jemalloc\");\n-        }\n-        if self.config.use_jemalloc {\n-            features.push_str(\" jemalloc\");\n-        }\n-        return features\n-    }\n-\n-    /// Get the space-separated set of activated features for the compiler.\n-    fn rustc_features(&self) -> String {\n-        let mut features = String::new();\n-        if self.config.use_jemalloc {\n-            features.push_str(\" jemalloc\");\n-        }\n-        return features\n-    }\n-\n-    /// Component directory that Cargo will produce output into (e.g.\n-    /// release/debug)\n-    fn cargo_dir(&self) -> &'static str {\n-        if self.config.rust_optimize {\"release\"} else {\"debug\"}\n-    }\n-\n-    /// Returns the sysroot for the `compiler` specified that *this build system\n-    /// generates*.\n-    ///\n-    /// That is, the sysroot for the stage0 compiler is not what the compiler\n-    /// thinks it is by default, but it's the same as the default for stages\n-    /// 1-3.\n-    fn sysroot(&self, compiler: &Compiler) -> PathBuf {\n-        if compiler.stage == 0 {\n-            self.out.join(compiler.host).join(\"stage0-sysroot\")\n-        } else {\n-            self.out.join(compiler.host).join(format!(\"stage{}\", compiler.stage))\n-        }\n-    }\n-\n-    /// Returns the libdir where the standard library and other artifacts are\n-    /// found for a compiler's sysroot.\n-    fn sysroot_libdir(&self, compiler: &Compiler, target: &str) -> PathBuf {\n-        self.sysroot(compiler).join(\"lib\").join(\"rustlib\")\n-            .join(target).join(\"lib\")\n-    }\n-\n-    /// Returns the root directory for all output generated in a particular\n-    /// stage when running with a particular host compiler.\n-    ///\n-    /// The mode indicates what the root directory is for.\n-    fn stage_out(&self, compiler: &Compiler, mode: Mode) -> PathBuf {\n-        let suffix = match mode {\n-            Mode::Libstd => \"-std\",\n-            Mode::Libtest => \"-test\",\n-            Mode::Tool => \"-tools\",\n-            Mode::Librustc => \"-rustc\",\n-        };\n-        self.out.join(compiler.host)\n-                .join(format!(\"stage{}{}\", compiler.stage, suffix))\n-    }\n-\n-    /// Returns the root output directory for all Cargo output in a given stage,\n-    /// running a particular comipler, wehther or not we're building the\n-    /// standard library, and targeting the specified architecture.\n-    fn cargo_out(&self,\n-                 compiler: &Compiler,\n-                 mode: Mode,\n-                 target: &str) -> PathBuf {\n-        self.stage_out(compiler, mode).join(target).join(self.cargo_dir())\n-    }\n-\n-    /// Root output directory for LLVM compiled for `target`\n-    ///\n-    /// Note that if LLVM is configured externally then the directory returned\n-    /// will likely be empty.\n-    fn llvm_out(&self, target: &str) -> PathBuf {\n-        self.out.join(target).join(\"llvm\")\n-    }\n-\n-    /// Returns the path to `llvm-config` for the specified target.\n-    ///\n-    /// If a custom `llvm-config` was specified for target then that's returned\n-    /// instead.\n-    fn llvm_config(&self, target: &str) -> PathBuf {\n-        let target_config = self.config.target_config.get(target);\n-        if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n-            s.clone()\n-        } else {\n-            self.llvm_out(&self.config.build).join(\"bin\")\n-                .join(exe(\"llvm-config\", target))\n-        }\n-    }\n-\n-    /// Returns the path to `FileCheck` binary for the specified target\n-    fn llvm_filecheck(&self, target: &str) -> PathBuf {\n-        let target_config = self.config.target_config.get(target);\n-        if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n-            s.parent().unwrap().join(exe(\"FileCheck\", target))\n-        } else {\n-            let base = self.llvm_out(&self.config.build).join(\"build\");\n-            let exe = exe(\"FileCheck\", target);\n-            if self.config.build.contains(\"msvc\") {\n-                base.join(\"Release/bin\").join(exe)\n-            } else {\n-                base.join(\"bin\").join(exe)\n-            }\n-        }\n-    }\n-\n-    /// Root output directory for compiler-rt compiled for `target`\n-    fn compiler_rt_out(&self, target: &str) -> PathBuf {\n-        self.out.join(target).join(\"compiler-rt\")\n-    }\n-\n-    /// Root output directory for rust_test_helpers library compiled for\n-    /// `target`\n-    fn test_helpers_out(&self, target: &str) -> PathBuf {\n-        self.out.join(target).join(\"rust-test-helpers\")\n-    }\n-\n-    /// Adds the compiler's directory of dynamic libraries to `cmd`'s dynamic\n-    /// library lookup path.\n-    fn add_rustc_lib_path(&self, compiler: &Compiler, cmd: &mut Command) {\n-        // Windows doesn't need dylib path munging because the dlls for the\n-        // compiler live next to the compiler and the system will find them\n-        // automatically.\n-        if cfg!(windows) {\n-            return\n-        }\n-\n-        add_lib_path(vec![self.rustc_libdir(compiler)], cmd);\n-    }\n-\n-    /// Adds the compiler's bootstrap key to the environment of `cmd`.\n-    fn add_bootstrap_key(&self, compiler: &Compiler, cmd: &mut Command) {\n-        // In stage0 we're using a previously released stable compiler, so we\n-        // use the stage0 bootstrap key. Otherwise we use our own build's\n-        // bootstrap key.\n-        let bootstrap_key = if compiler.is_snapshot(self) && !self.config.local_rebuild {\n-            &self.bootstrap_key_stage0\n-        } else {\n-            &self.bootstrap_key\n-        };\n-        cmd.env(\"RUSTC_BOOTSTRAP_KEY\", bootstrap_key);\n-    }\n-\n-    /// Returns the compiler's libdir where it stores the dynamic libraries that\n-    /// it itself links against.\n-    ///\n-    /// For example this returns `<sysroot>/lib` on Unix and `<sysroot>/bin` on\n-    /// Windows.\n-    fn rustc_libdir(&self, compiler: &Compiler) -> PathBuf {\n-        if compiler.is_snapshot(self) {\n-            self.rustc_snapshot_libdir()\n-        } else {\n-            self.sysroot(compiler).join(libdir(compiler.host))\n-        }\n-    }\n-\n-    /// Returns the libdir of the snapshot compiler.\n-    fn rustc_snapshot_libdir(&self) -> PathBuf {\n-        self.rustc.parent().unwrap().parent().unwrap()\n-            .join(libdir(&self.config.build))\n-    }\n-\n-    /// Runs a command, printing out nice contextual information if it fails.\n-    fn run(&self, cmd: &mut Command) {\n-        self.verbose(&format!(\"running: {:?}\", cmd));\n-        run_silent(cmd)\n-    }\n-\n-    /// Prints a message if this build is configured in verbose mode.\n-    fn verbose(&self, msg: &str) {\n-        if self.flags.verbose || self.config.verbose {\n-            println!(\"{}\", msg);\n-        }\n-    }\n-\n-    /// Returns the number of parallel jobs that have been configured for this\n-    /// build.\n-    fn jobs(&self) -> u32 {\n-        self.flags.jobs.unwrap_or(num_cpus::get() as u32)\n-    }\n-\n-    /// Returns the path to the C compiler for the target specified.\n-    fn cc(&self, target: &str) -> &Path {\n-        self.cc[target].0.path()\n-    }\n-\n-    /// Returns a list of flags to pass to the C compiler for the target\n-    /// specified.\n-    fn cflags(&self, target: &str) -> Vec<String> {\n-        // Filter out -O and /O (the optimization flags) that we picked up from\n-        // gcc-rs because the build scripts will determine that for themselves.\n-        let mut base = self.cc[target].0.args().iter()\n-                           .map(|s| s.to_string_lossy().into_owned())\n-                           .filter(|s| !s.starts_with(\"-O\") && !s.starts_with(\"/O\"))\n-                           .collect::<Vec<_>>();\n-\n-        // If we're compiling on OSX then we add a few unconditional flags\n-        // indicating that we want libc++ (more filled out than libstdc++) and\n-        // we want to compile for 10.7. This way we can ensure that\n-        // LLVM/jemalloc/etc are all properly compiled.\n-        if target.contains(\"apple-darwin\") {\n-            base.push(\"-stdlib=libc++\".into());\n-            base.push(\"-mmacosx-version-min=10.7\".into());\n-        }\n-        return base\n-    }\n-\n-    /// Returns the path to the `ar` archive utility for the target specified.\n-    fn ar(&self, target: &str) -> Option<&Path> {\n-        self.cc[target].1.as_ref().map(|p| &**p)\n-    }\n-\n-    /// Returns the path to the C++ compiler for the target specified, may panic\n-    /// if no C++ compiler was configured for the target.\n-    fn cxx(&self, target: &str) -> &Path {\n-        self.cxx[target].path()\n-    }\n-\n-    /// Returns flags to pass to the compiler to generate code for `target`.\n-    fn rustc_flags(&self, target: &str) -> Vec<String> {\n-        // New flags should be added here with great caution!\n-        //\n-        // It's quite unfortunate to **require** flags to generate code for a\n-        // target, so it should only be passed here if absolutely necessary!\n-        // Most default configuration should be done through target specs rather\n-        // than an entry here.\n-\n-        let mut base = Vec::new();\n-        if target != self.config.build && !target.contains(\"msvc\") {\n-            base.push(format!(\"-Clinker={}\", self.cc(target).display()));\n-        }\n-        return base\n-    }\n-}\n-\n-impl<'a> Compiler<'a> {\n-    /// Creates a new complier for the specified stage/host\n-    fn new(stage: u32, host: &'a str) -> Compiler<'a> {\n-        Compiler { stage: stage, host: host }\n-    }\n-\n-    /// Returns whether this is a snapshot compiler for `build`'s configuration\n-    fn is_snapshot(&self, build: &Build) -> bool {\n-        self.stage == 0 && self.host == build.config.build\n-    }\n-}"}, {"sha": "e2bde4a6586117410773977f4a3c085704ee2245", "filename": "src/bootstrap/cc.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc.rs?ref=4cf97fe57ef52c4addc03086aae784d980780d8f", "patch": "@@ -36,8 +36,8 @@ use std::process::Command;\n use build_helper::{cc2ar, output};\n use gcc;\n \n-use build::Build;\n-use build::config::Target;\n+use Build;\n+use config::Target;\n \n pub fn find(build: &mut Build) {\n     // For all targets we're going to need a C compiler for building some shims", "previous_filename": "src/bootstrap/build/cc.rs"}, {"sha": "879c383404a4cb3581563eb5923488a581bd6b5f", "filename": "src/bootstrap/channel.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=4cf97fe57ef52c4addc03086aae784d980780d8f", "patch": "@@ -22,7 +22,7 @@ use std::process::Command;\n use build_helper::output;\n use md5;\n \n-use build::Build;\n+use Build;\n \n pub fn collect(build: &mut Build) {\n     // Currently the canonical source for the release number (e.g. 1.10.0) and", "previous_filename": "src/bootstrap/build/channel.rs"}, {"sha": "3d8b1438125e6fda3aa20aea8bdfb6ca1a70f79b", "filename": "src/bootstrap/check.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=4cf97fe57ef52c4addc03086aae784d980780d8f", "patch": "@@ -20,10 +20,9 @@ use std::path::{PathBuf, Path};\n use std::process::Command;\n \n use build_helper::output;\n-use bootstrap::{dylib_path, dylib_path_var};\n \n-use build::{Build, Compiler, Mode};\n-use build::util;\n+use {Build, Compiler, Mode};\n+use util::{self, dylib_path, dylib_path_var};\n \n const ADB_TEST_DIR: &'static str = \"/data/tmp\";\n ", "previous_filename": "src/bootstrap/build/check.rs"}, {"sha": "a466e2e6897f86d3043adef4fa494a4f5edd1191", "filename": "src/bootstrap/clean.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fclean.rs?ref=4cf97fe57ef52c4addc03086aae784d980780d8f", "patch": "@@ -18,7 +18,7 @@\n use std::fs;\n use std::path::Path;\n \n-use build::Build;\n+use Build;\n \n pub fn clean(build: &Build) {\n     rm_rf(build, \"tmp\".as_ref());", "previous_filename": "src/bootstrap/build/clean.rs"}, {"sha": "8ec9c7f0109f3f18c5035008d4751dd955473a6b", "filename": "src/bootstrap/compile.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=4cf97fe57ef52c4addc03086aae784d980780d8f", "patch": "@@ -23,8 +23,8 @@ use std::process::Command;\n \n use build_helper::output;\n \n-use build::util::{exe, staticlib, libdir, mtime, is_dylib, copy};\n-use build::{Build, Compiler, Mode};\n+use util::{exe, staticlib, libdir, mtime, is_dylib, copy};\n+use {Build, Compiler, Mode};\n \n /// Build the standard library.\n ///", "previous_filename": "src/bootstrap/build/compile.rs"}, {"sha": "498196e9b6dfc12454274e75cd695c2ad2a04b65", "filename": "src/bootstrap/config.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=4cf97fe57ef52c4addc03086aae784d980780d8f", "previous_filename": "src/bootstrap/build/config.rs"}, {"sha": "1cf71c3aaecd6065c0eef218979327d577510c18", "filename": "src/bootstrap/dist.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=4cf97fe57ef52c4addc03086aae784d980780d8f", "patch": "@@ -23,8 +23,8 @@ use std::io::Write;\n use std::path::{PathBuf, Path};\n use std::process::Command;\n \n-use build::{Build, Compiler};\n-use build::util::{cp_r, libdir, is_dylib};\n+use {Build, Compiler};\n+use util::{cp_r, libdir, is_dylib};\n \n fn package_vers(build: &Build) -> &str {\n     match &build.config.channel[..] {", "previous_filename": "src/bootstrap/build/dist.rs"}, {"sha": "ac90ab547373b08abec0d3c4b0dc124be1442217", "filename": "src/bootstrap/doc.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=4cf97fe57ef52c4addc03086aae784d980780d8f", "patch": "@@ -22,8 +22,8 @@ use std::io::prelude::*;\n use std::path::Path;\n use std::process::Command;\n \n-use build::{Build, Compiler, Mode};\n-use build::util::{up_to_date, cp_r};\n+use {Build, Compiler, Mode};\n+use util::{up_to_date, cp_r};\n \n /// Invoke `rustbook` as compiled in `stage` for `target` for the doc book\n /// `name` into the `out` path.", "previous_filename": "src/bootstrap/build/doc.rs"}, {"sha": "d925997f36c214ae09c078b04ec31537da7e4b02", "filename": "src/bootstrap/flags.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=4cf97fe57ef52c4addc03086aae784d980780d8f", "previous_filename": "src/bootstrap/build/flags.rs"}, {"sha": "4558e6f049432dff4b0cdd8e690deeae4adb7603", "filename": "src/bootstrap/job.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fjob.rs?ref=4cf97fe57ef52c4addc03086aae784d980780d8f", "previous_filename": "src/bootstrap/build/job.rs"}, {"sha": "943271fc8a641665734531b3393b32d4f37d1e5e", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 862, "deletions": 20, "changes": 882, "blob_url": "https://github.com/rust-lang/rust/blob/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=4cf97fe57ef52c4addc03086aae784d980780d8f", "patch": "@@ -8,30 +8,872 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A small helper library shared between the build system's executables\n+//! Implementation of rustbuild, the Rust build system.\n //!\n-//! Currently this just has some simple utilities for modifying the dynamic\n-//! library lookup path.\n+//! This module, and its descendants, are the implementation of the Rust build\n+//! system. Most of this build system is backed by Cargo but the outer layer\n+//! here serves as the ability to orchestrate calling Cargo, sequencing Cargo\n+//! builds, building artifacts like LLVM, etc.\n+//!\n+//! More documentation can be found in each respective module below.\n+\n+extern crate build_helper;\n+extern crate cmake;\n+extern crate filetime;\n+extern crate gcc;\n+extern crate getopts;\n+extern crate md5;\n+extern crate num_cpus;\n+extern crate rustc_serialize;\n+extern crate toml;\n \n+use std::cell::RefCell;\n+use std::collections::HashMap;\n use std::env;\n-use std::ffi::OsString;\n-use std::path::PathBuf;\n-\n-/// Returns the environment variable which the dynamic library lookup path\n-/// resides in for this platform.\n-pub fn dylib_path_var() -> &'static str {\n-    if cfg!(target_os = \"windows\") {\n-        \"PATH\"\n-    } else if cfg!(target_os = \"macos\") {\n-        \"DYLD_LIBRARY_PATH\"\n-    } else {\n-        \"LD_LIBRARY_PATH\"\n+use std::fs::{self, File};\n+use std::path::{PathBuf, Path};\n+use std::process::Command;\n+\n+use build_helper::{run_silent, output};\n+\n+use util::{exe, mtime, libdir, add_lib_path};\n+\n+/// A helper macro to `unwrap` a result except also print out details like:\n+///\n+/// * The file/line of the panic\n+/// * The expression that failed\n+/// * The error itself\n+///\n+/// This is currently used judiciously throughout the build system rather than\n+/// using a `Result` with `try!`, but this may change on day...\n+macro_rules! t {\n+    ($e:expr) => (match $e {\n+        Ok(e) => e,\n+        Err(e) => panic!(\"{} failed with {}\", stringify!($e), e),\n+    })\n+}\n+\n+mod cc;\n+mod channel;\n+mod check;\n+mod clean;\n+mod compile;\n+mod config;\n+mod dist;\n+mod doc;\n+mod flags;\n+mod native;\n+mod sanity;\n+mod step;\n+pub mod util;\n+\n+#[cfg(windows)]\n+mod job;\n+\n+#[cfg(not(windows))]\n+mod job {\n+    pub unsafe fn setup() {}\n+}\n+\n+pub use config::Config;\n+pub use flags::Flags;\n+\n+/// A structure representing a Rust compiler.\n+///\n+/// Each compiler has a `stage` that it is associated with and a `host` that\n+/// corresponds to the platform the compiler runs on. This structure is used as\n+/// a parameter to many methods below.\n+#[derive(Eq, PartialEq, Clone, Copy, Hash, Debug)]\n+pub struct Compiler<'a> {\n+    stage: u32,\n+    host: &'a str,\n+}\n+\n+/// Global configuration for the build system.\n+///\n+/// This structure transitively contains all configuration for the build system.\n+/// All filesystem-encoded configuration is in `config`, all flags are in\n+/// `flags`, and then parsed or probed information is listed in the keys below.\n+///\n+/// This structure is a parameter of almost all methods in the build system,\n+/// although most functions are implemented as free functions rather than\n+/// methods specifically on this structure itself (to make it easier to\n+/// organize).\n+pub struct Build {\n+    // User-specified configuration via config.toml\n+    config: Config,\n+\n+    // User-specified configuration via CLI flags\n+    flags: Flags,\n+\n+    // Derived properties from the above two configurations\n+    cargo: PathBuf,\n+    rustc: PathBuf,\n+    src: PathBuf,\n+    out: PathBuf,\n+    release: String,\n+    unstable_features: bool,\n+    ver_hash: Option<String>,\n+    short_ver_hash: Option<String>,\n+    ver_date: Option<String>,\n+    version: String,\n+    package_vers: String,\n+    bootstrap_key: String,\n+    bootstrap_key_stage0: String,\n+\n+    // Probed tools at runtime\n+    gdb_version: Option<String>,\n+    lldb_version: Option<String>,\n+    lldb_python_dir: Option<String>,\n+\n+    // Runtime state filled in later on\n+    cc: HashMap<String, (gcc::Tool, Option<PathBuf>)>,\n+    cxx: HashMap<String, gcc::Tool>,\n+    compiler_rt_built: RefCell<HashMap<String, PathBuf>>,\n+}\n+\n+/// The various \"modes\" of invoking Cargo.\n+///\n+/// These entries currently correspond to the various output directories of the\n+/// build system, with each mod generating output in a different directory.\n+#[derive(Clone, Copy)]\n+pub enum Mode {\n+    /// This cargo is going to build the standard library, placing output in the\n+    /// \"stageN-std\" directory.\n+    Libstd,\n+\n+    /// This cargo is going to build libtest, placing output in the\n+    /// \"stageN-test\" directory.\n+    Libtest,\n+\n+    /// This cargo is going to build librustc and compiler libraries, placing\n+    /// output in the \"stageN-rustc\" directory.\n+    Librustc,\n+\n+    /// This cargo is going to some build tool, placing output in the\n+    /// \"stageN-tools\" directory.\n+    Tool,\n+}\n+\n+impl Build {\n+    /// Creates a new set of build configuration from the `flags` on the command\n+    /// line and the filesystem `config`.\n+    ///\n+    /// By default all build output will be placed in the current directory.\n+    pub fn new(flags: Flags, config: Config) -> Build {\n+        let cwd = t!(env::current_dir());\n+        let src = flags.src.clone().unwrap_or(cwd.clone());\n+        let out = cwd.join(\"build\");\n+\n+        let stage0_root = out.join(&config.build).join(\"stage0/bin\");\n+        let rustc = match config.rustc {\n+            Some(ref s) => PathBuf::from(s),\n+            None => stage0_root.join(exe(\"rustc\", &config.build)),\n+        };\n+        let cargo = match config.cargo {\n+            Some(ref s) => PathBuf::from(s),\n+            None => stage0_root.join(exe(\"cargo\", &config.build)),\n+        };\n+\n+        Build {\n+            flags: flags,\n+            config: config,\n+            cargo: cargo,\n+            rustc: rustc,\n+            src: src,\n+            out: out,\n+\n+            release: String::new(),\n+            unstable_features: false,\n+            ver_hash: None,\n+            short_ver_hash: None,\n+            ver_date: None,\n+            version: String::new(),\n+            bootstrap_key: String::new(),\n+            bootstrap_key_stage0: String::new(),\n+            package_vers: String::new(),\n+            cc: HashMap::new(),\n+            cxx: HashMap::new(),\n+            compiler_rt_built: RefCell::new(HashMap::new()),\n+            gdb_version: None,\n+            lldb_version: None,\n+            lldb_python_dir: None,\n+        }\n+    }\n+\n+    /// Executes the entire build, as configured by the flags and configuration.\n+    pub fn build(&mut self) {\n+        use step::Source::*;\n+\n+        unsafe {\n+            job::setup();\n+        }\n+\n+        if self.flags.clean {\n+            return clean::clean(self);\n+        }\n+\n+        self.verbose(\"finding compilers\");\n+        cc::find(self);\n+        self.verbose(\"running sanity check\");\n+        sanity::check(self);\n+        self.verbose(\"collecting channel variables\");\n+        channel::collect(self);\n+        self.verbose(\"updating submodules\");\n+        self.update_submodules();\n+\n+        // The main loop of the build system.\n+        //\n+        // The `step::all` function returns a topographically sorted list of all\n+        // steps that need to be executed as part of this build. Each step has a\n+        // corresponding entry in `step.rs` and indicates some unit of work that\n+        // needs to be done as part of the build.\n+        //\n+        // Almost all of these are simple one-liners that shell out to the\n+        // corresponding functionality in the extra modules, where more\n+        // documentation can be found.\n+        for target in step::all(self) {\n+            let doc_out = self.out.join(&target.target).join(\"doc\");\n+            match target.src {\n+                Llvm { _dummy } => {\n+                    native::llvm(self, target.target);\n+                }\n+                CompilerRt { _dummy } => {\n+                    native::compiler_rt(self, target.target);\n+                }\n+                TestHelpers { _dummy } => {\n+                    native::test_helpers(self, target.target);\n+                }\n+                Libstd { compiler } => {\n+                    compile::std(self, target.target, &compiler);\n+                }\n+                Libtest { compiler } => {\n+                    compile::test(self, target.target, &compiler);\n+                }\n+                Librustc { compiler } => {\n+                    compile::rustc(self, target.target, &compiler);\n+                }\n+                LibstdLink { compiler, host } => {\n+                    compile::std_link(self, target.target, &compiler, host);\n+                }\n+                LibtestLink { compiler, host } => {\n+                    compile::test_link(self, target.target, &compiler, host);\n+                }\n+                LibrustcLink { compiler, host } => {\n+                    compile::rustc_link(self, target.target, &compiler, host);\n+                }\n+                Rustc { stage: 0 } => {\n+                    // nothing to do...\n+                }\n+                Rustc { stage } => {\n+                    compile::assemble_rustc(self, stage, target.target);\n+                }\n+                ToolLinkchecker { stage } => {\n+                    compile::tool(self, stage, target.target, \"linkchecker\");\n+                }\n+                ToolRustbook { stage } => {\n+                    compile::tool(self, stage, target.target, \"rustbook\");\n+                }\n+                ToolErrorIndex { stage } => {\n+                    compile::tool(self, stage, target.target,\n+                                  \"error_index_generator\");\n+                }\n+                ToolCargoTest { stage } => {\n+                    compile::tool(self, stage, target.target, \"cargotest\");\n+                }\n+                ToolTidy { stage } => {\n+                    compile::tool(self, stage, target.target, \"tidy\");\n+                }\n+                ToolCompiletest { stage } => {\n+                    compile::tool(self, stage, target.target, \"compiletest\");\n+                }\n+                DocBook { stage } => {\n+                    doc::rustbook(self, stage, target.target, \"book\", &doc_out);\n+                }\n+                DocNomicon { stage } => {\n+                    doc::rustbook(self, stage, target.target, \"nomicon\",\n+                                  &doc_out);\n+                }\n+                DocStyle { stage } => {\n+                    doc::rustbook(self, stage, target.target, \"style\",\n+                                  &doc_out);\n+                }\n+                DocStandalone { stage } => {\n+                    doc::standalone(self, stage, target.target, &doc_out);\n+                }\n+                DocStd { stage } => {\n+                    doc::std(self, stage, target.target, &doc_out);\n+                }\n+                DocTest { stage } => {\n+                    doc::test(self, stage, target.target, &doc_out);\n+                }\n+                DocRustc { stage } => {\n+                    doc::rustc(self, stage, target.target, &doc_out);\n+                }\n+                DocErrorIndex { stage } => {\n+                    doc::error_index(self, stage, target.target, &doc_out);\n+                }\n+\n+                CheckLinkcheck { stage } => {\n+                    check::linkcheck(self, stage, target.target);\n+                }\n+                CheckCargoTest { stage } => {\n+                    check::cargotest(self, stage, target.target);\n+                }\n+                CheckTidy { stage } => {\n+                    check::tidy(self, stage, target.target);\n+                }\n+                CheckRPass { compiler } => {\n+                    check::compiletest(self, &compiler, target.target,\n+                                       \"run-pass\", \"run-pass\");\n+                }\n+                CheckRPassFull { compiler } => {\n+                    check::compiletest(self, &compiler, target.target,\n+                                       \"run-pass\", \"run-pass-fulldeps\");\n+                }\n+                CheckCFail { compiler } => {\n+                    check::compiletest(self, &compiler, target.target,\n+                                       \"compile-fail\", \"compile-fail\");\n+                }\n+                CheckCFailFull { compiler } => {\n+                    check::compiletest(self, &compiler, target.target,\n+                                       \"compile-fail\", \"compile-fail-fulldeps\")\n+                }\n+                CheckPFail { compiler } => {\n+                    check::compiletest(self, &compiler, target.target,\n+                                       \"parse-fail\", \"parse-fail\");\n+                }\n+                CheckRFail { compiler } => {\n+                    check::compiletest(self, &compiler, target.target,\n+                                       \"run-fail\", \"run-fail\");\n+                }\n+                CheckRFailFull { compiler } => {\n+                    check::compiletest(self, &compiler, target.target,\n+                                       \"run-fail\", \"run-fail-fulldeps\");\n+                }\n+                CheckPretty { compiler } => {\n+                    check::compiletest(self, &compiler, target.target,\n+                                       \"pretty\", \"pretty\");\n+                }\n+                CheckPrettyRPass { compiler } => {\n+                    check::compiletest(self, &compiler, target.target,\n+                                       \"pretty\", \"run-pass\");\n+                }\n+                CheckPrettyRPassFull { compiler } => {\n+                    check::compiletest(self, &compiler, target.target,\n+                                       \"pretty\", \"run-pass-fulldeps\");\n+                }\n+                CheckPrettyRFail { compiler } => {\n+                    check::compiletest(self, &compiler, target.target,\n+                                       \"pretty\", \"run-fail\");\n+                }\n+                CheckPrettyRFailFull { compiler } => {\n+                    check::compiletest(self, &compiler, target.target,\n+                                       \"pretty\", \"run-fail-fulldeps\");\n+                }\n+                CheckPrettyRPassValgrind { compiler } => {\n+                    check::compiletest(self, &compiler, target.target,\n+                                       \"pretty\", \"run-pass-valgrind\");\n+                }\n+                CheckCodegen { compiler } => {\n+                    check::compiletest(self, &compiler, target.target,\n+                                       \"codegen\", \"codegen\");\n+                }\n+                CheckCodegenUnits { compiler } => {\n+                    check::compiletest(self, &compiler, target.target,\n+                                       \"codegen-units\", \"codegen-units\");\n+                }\n+                CheckIncremental { compiler } => {\n+                    check::compiletest(self, &compiler, target.target,\n+                                       \"incremental\", \"incremental\");\n+                }\n+                CheckUi { compiler } => {\n+                    check::compiletest(self, &compiler, target.target,\n+                                       \"ui\", \"ui\");\n+                }\n+                CheckDebuginfo { compiler } => {\n+                    if target.target.contains(\"msvc\") {\n+                        // nothing to do\n+                    } else if target.target.contains(\"apple\") {\n+                        check::compiletest(self, &compiler, target.target,\n+                                           \"debuginfo-lldb\", \"debuginfo\");\n+                    } else {\n+                        check::compiletest(self, &compiler, target.target,\n+                                           \"debuginfo-gdb\", \"debuginfo\");\n+                    }\n+                }\n+                CheckRustdoc { compiler } => {\n+                    check::compiletest(self, &compiler, target.target,\n+                                       \"rustdoc\", \"rustdoc\");\n+                }\n+                CheckRPassValgrind { compiler } => {\n+                    check::compiletest(self, &compiler, target.target,\n+                                       \"run-pass-valgrind\", \"run-pass-valgrind\");\n+                }\n+                CheckDocs { compiler } => {\n+                    check::docs(self, &compiler);\n+                }\n+                CheckErrorIndex { compiler } => {\n+                    check::error_index(self, &compiler);\n+                }\n+                CheckRMake { compiler } => {\n+                    check::compiletest(self, &compiler, target.target,\n+                                       \"run-make\", \"run-make\")\n+                }\n+                CheckCrateStd { compiler } => {\n+                    check::krate(self, &compiler, target.target, Mode::Libstd)\n+                }\n+                CheckCrateTest { compiler } => {\n+                    check::krate(self, &compiler, target.target, Mode::Libtest)\n+                }\n+                CheckCrateRustc { compiler } => {\n+                    check::krate(self, &compiler, target.target, Mode::Librustc)\n+                }\n+\n+                DistDocs { stage } => dist::docs(self, stage, target.target),\n+                DistMingw { _dummy } => dist::mingw(self, target.target),\n+                DistRustc { stage } => dist::rustc(self, stage, target.target),\n+                DistStd { compiler } => dist::std(self, &compiler, target.target),\n+\n+                DebuggerScripts { stage } => {\n+                    let compiler = Compiler::new(stage, target.target);\n+                    dist::debugger_scripts(self,\n+                                           &self.sysroot(&compiler),\n+                                           target.target);\n+                }\n+\n+                AndroidCopyLibs { compiler } => {\n+                    check::android_copy_libs(self, &compiler, target.target);\n+                }\n+\n+                // pseudo-steps\n+                Dist { .. } |\n+                Doc { .. } |\n+                CheckTarget { .. } |\n+                Check { .. } => {}\n+            }\n+        }\n+    }\n+\n+    /// Updates all git submodules that we have.\n+    ///\n+    /// This will detect if any submodules are out of date an run the necessary\n+    /// commands to sync them all with upstream.\n+    fn update_submodules(&self) {\n+        if !self.config.submodules {\n+            return\n+        }\n+        if fs::metadata(self.src.join(\".git\")).is_err() {\n+            return\n+        }\n+        let git_submodule = || {\n+            let mut cmd = Command::new(\"git\");\n+            cmd.current_dir(&self.src).arg(\"submodule\");\n+            return cmd\n+        };\n+\n+        // FIXME: this takes a seriously long time to execute on Windows and a\n+        //        nontrivial amount of time on Unix, we should have a better way\n+        //        of detecting whether we need to run all the submodule commands\n+        //        below.\n+        let out = output(git_submodule().arg(\"status\"));\n+        if !out.lines().any(|l| l.starts_with(\"+\") || l.starts_with(\"-\")) {\n+            return\n+        }\n+\n+        self.run(git_submodule().arg(\"sync\"));\n+        self.run(git_submodule().arg(\"init\"));\n+        self.run(git_submodule().arg(\"update\"));\n+        self.run(git_submodule().arg(\"update\").arg(\"--recursive\"));\n+        self.run(git_submodule().arg(\"status\").arg(\"--recursive\"));\n+        self.run(git_submodule().arg(\"foreach\").arg(\"--recursive\")\n+                                .arg(\"git\").arg(\"clean\").arg(\"-fdx\"));\n+        self.run(git_submodule().arg(\"foreach\").arg(\"--recursive\")\n+                                .arg(\"git\").arg(\"checkout\").arg(\".\"));\n+    }\n+\n+    /// Clear out `dir` if `input` is newer.\n+    ///\n+    /// After this executes, it will also ensure that `dir` exists.\n+    fn clear_if_dirty(&self, dir: &Path, input: &Path) {\n+        let stamp = dir.join(\".stamp\");\n+        if mtime(&stamp) < mtime(input) {\n+            self.verbose(&format!(\"Dirty - {}\", dir.display()));\n+            let _ = fs::remove_dir_all(dir);\n+        }\n+        t!(fs::create_dir_all(dir));\n+        t!(File::create(stamp));\n+    }\n+\n+    /// Prepares an invocation of `cargo` to be run.\n+    ///\n+    /// This will create a `Command` that represents a pending execution of\n+    /// Cargo. This cargo will be configured to use `compiler` as the actual\n+    /// rustc compiler, its output will be scoped by `mode`'s output directory,\n+    /// it will pass the `--target` flag for the specified `target`, and will be\n+    /// executing the Cargo command `cmd`.\n+    fn cargo(&self,\n+             compiler: &Compiler,\n+             mode: Mode,\n+             target: &str,\n+             cmd: &str) -> Command {\n+        let mut cargo = Command::new(&self.cargo);\n+        let out_dir = self.stage_out(compiler, mode);\n+        cargo.env(\"CARGO_TARGET_DIR\", out_dir)\n+             .arg(cmd)\n+             .arg(\"-j\").arg(self.jobs().to_string())\n+             .arg(\"--target\").arg(target);\n+\n+        let stage;\n+        if compiler.stage == 0 && self.config.local_rebuild {\n+            // Assume the local-rebuild rustc already has stage1 features.\n+            stage = 1;\n+        } else {\n+            stage = compiler.stage;\n+        }\n+\n+        // Customize the compiler we're running. Specify the compiler to cargo\n+        // as our shim and then pass it some various options used to configure\n+        // how the actual compiler itself is called.\n+        //\n+        // These variables are primarily all read by\n+        // src/bootstrap/{rustc,rustdoc.rs}\n+        cargo.env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n+             .env(\"RUSTC_REAL\", self.compiler_path(compiler))\n+             .env(\"RUSTC_STAGE\", stage.to_string())\n+             .env(\"RUSTC_DEBUGINFO\", self.config.rust_debuginfo.to_string())\n+             .env(\"RUSTC_CODEGEN_UNITS\",\n+                  self.config.rust_codegen_units.to_string())\n+             .env(\"RUSTC_DEBUG_ASSERTIONS\",\n+                  self.config.rust_debug_assertions.to_string())\n+             .env(\"RUSTC_SNAPSHOT\", &self.rustc)\n+             .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n+             .env(\"RUSTC_LIBDIR\", self.rustc_libdir(compiler))\n+             .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_snapshot_libdir())\n+             .env(\"RUSTC_RPATH\", self.config.rust_rpath.to_string())\n+             .env(\"RUSTDOC\", self.out.join(\"bootstrap/debug/rustdoc\"))\n+             .env(\"RUSTDOC_REAL\", self.rustdoc(compiler))\n+             .env(\"RUSTC_FLAGS\", self.rustc_flags(target).join(\" \"));\n+\n+        self.add_bootstrap_key(compiler, &mut cargo);\n+\n+        // Specify some various options for build scripts used throughout\n+        // the build.\n+        //\n+        // FIXME: the guard against msvc shouldn't need to be here\n+        if !target.contains(\"msvc\") {\n+            cargo.env(format!(\"CC_{}\", target), self.cc(target))\n+                 .env(format!(\"AR_{}\", target), self.ar(target).unwrap()) // only msvc is None\n+                 .env(format!(\"CFLAGS_{}\", target), self.cflags(target).join(\" \"));\n+        }\n+\n+        // If we're building for OSX, inform the compiler and the linker that\n+        // we want to build a compiler runnable on 10.7\n+        if target.contains(\"apple-darwin\") {\n+            cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", \"10.7\");\n+        }\n+\n+        // Environment variables *required* needed throughout the build\n+        //\n+        // FIXME: should update code to not require this env var\n+        cargo.env(\"CFG_COMPILER_HOST_TRIPLE\", target);\n+\n+        if self.config.verbose || self.flags.verbose {\n+            cargo.arg(\"-v\");\n+        }\n+        if self.config.rust_optimize {\n+            cargo.arg(\"--release\");\n+        }\n+        return cargo\n+    }\n+\n+    /// Get a path to the compiler specified.\n+    fn compiler_path(&self, compiler: &Compiler) -> PathBuf {\n+        if compiler.is_snapshot(self) {\n+            self.rustc.clone()\n+        } else {\n+            self.sysroot(compiler).join(\"bin\").join(exe(\"rustc\", compiler.host))\n+        }\n+    }\n+\n+    /// Get the specified tool built by the specified compiler\n+    fn tool(&self, compiler: &Compiler, tool: &str) -> PathBuf {\n+        self.cargo_out(compiler, Mode::Tool, compiler.host)\n+            .join(exe(tool, compiler.host))\n+    }\n+\n+    /// Get the `rustdoc` executable next to the specified compiler\n+    fn rustdoc(&self, compiler: &Compiler) -> PathBuf {\n+        let mut rustdoc = self.compiler_path(compiler);\n+        rustdoc.pop();\n+        rustdoc.push(exe(\"rustdoc\", compiler.host));\n+        return rustdoc\n+    }\n+\n+    /// Get a `Command` which is ready to run `tool` in `stage` built for\n+    /// `host`.\n+    fn tool_cmd(&self, compiler: &Compiler, tool: &str) -> Command {\n+        let mut cmd = Command::new(self.tool(&compiler, tool));\n+        let host = compiler.host;\n+        let paths = vec![\n+            self.cargo_out(compiler, Mode::Libstd, host).join(\"deps\"),\n+            self.cargo_out(compiler, Mode::Libtest, host).join(\"deps\"),\n+            self.cargo_out(compiler, Mode::Librustc, host).join(\"deps\"),\n+            self.cargo_out(compiler, Mode::Tool, host).join(\"deps\"),\n+        ];\n+        add_lib_path(paths, &mut cmd);\n+        return cmd\n+    }\n+\n+    /// Get the space-separated set of activated features for the standard\n+    /// library.\n+    fn std_features(&self) -> String {\n+        let mut features = String::new();\n+        if self.config.debug_jemalloc {\n+            features.push_str(\" debug-jemalloc\");\n+        }\n+        if self.config.use_jemalloc {\n+            features.push_str(\" jemalloc\");\n+        }\n+        return features\n+    }\n+\n+    /// Get the space-separated set of activated features for the compiler.\n+    fn rustc_features(&self) -> String {\n+        let mut features = String::new();\n+        if self.config.use_jemalloc {\n+            features.push_str(\" jemalloc\");\n+        }\n+        return features\n+    }\n+\n+    /// Component directory that Cargo will produce output into (e.g.\n+    /// release/debug)\n+    fn cargo_dir(&self) -> &'static str {\n+        if self.config.rust_optimize {\"release\"} else {\"debug\"}\n+    }\n+\n+    /// Returns the sysroot for the `compiler` specified that *this build system\n+    /// generates*.\n+    ///\n+    /// That is, the sysroot for the stage0 compiler is not what the compiler\n+    /// thinks it is by default, but it's the same as the default for stages\n+    /// 1-3.\n+    fn sysroot(&self, compiler: &Compiler) -> PathBuf {\n+        if compiler.stage == 0 {\n+            self.out.join(compiler.host).join(\"stage0-sysroot\")\n+        } else {\n+            self.out.join(compiler.host).join(format!(\"stage{}\", compiler.stage))\n+        }\n+    }\n+\n+    /// Returns the libdir where the standard library and other artifacts are\n+    /// found for a compiler's sysroot.\n+    fn sysroot_libdir(&self, compiler: &Compiler, target: &str) -> PathBuf {\n+        self.sysroot(compiler).join(\"lib\").join(\"rustlib\")\n+            .join(target).join(\"lib\")\n+    }\n+\n+    /// Returns the root directory for all output generated in a particular\n+    /// stage when running with a particular host compiler.\n+    ///\n+    /// The mode indicates what the root directory is for.\n+    fn stage_out(&self, compiler: &Compiler, mode: Mode) -> PathBuf {\n+        let suffix = match mode {\n+            Mode::Libstd => \"-std\",\n+            Mode::Libtest => \"-test\",\n+            Mode::Tool => \"-tools\",\n+            Mode::Librustc => \"-rustc\",\n+        };\n+        self.out.join(compiler.host)\n+                .join(format!(\"stage{}{}\", compiler.stage, suffix))\n+    }\n+\n+    /// Returns the root output directory for all Cargo output in a given stage,\n+    /// running a particular comipler, wehther or not we're building the\n+    /// standard library, and targeting the specified architecture.\n+    fn cargo_out(&self,\n+                 compiler: &Compiler,\n+                 mode: Mode,\n+                 target: &str) -> PathBuf {\n+        self.stage_out(compiler, mode).join(target).join(self.cargo_dir())\n+    }\n+\n+    /// Root output directory for LLVM compiled for `target`\n+    ///\n+    /// Note that if LLVM is configured externally then the directory returned\n+    /// will likely be empty.\n+    fn llvm_out(&self, target: &str) -> PathBuf {\n+        self.out.join(target).join(\"llvm\")\n+    }\n+\n+    /// Returns the path to `llvm-config` for the specified target.\n+    ///\n+    /// If a custom `llvm-config` was specified for target then that's returned\n+    /// instead.\n+    fn llvm_config(&self, target: &str) -> PathBuf {\n+        let target_config = self.config.target_config.get(target);\n+        if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n+            s.clone()\n+        } else {\n+            self.llvm_out(&self.config.build).join(\"bin\")\n+                .join(exe(\"llvm-config\", target))\n+        }\n+    }\n+\n+    /// Returns the path to `FileCheck` binary for the specified target\n+    fn llvm_filecheck(&self, target: &str) -> PathBuf {\n+        let target_config = self.config.target_config.get(target);\n+        if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n+            s.parent().unwrap().join(exe(\"FileCheck\", target))\n+        } else {\n+            let base = self.llvm_out(&self.config.build).join(\"build\");\n+            let exe = exe(\"FileCheck\", target);\n+            if self.config.build.contains(\"msvc\") {\n+                base.join(\"Release/bin\").join(exe)\n+            } else {\n+                base.join(\"bin\").join(exe)\n+            }\n+        }\n+    }\n+\n+    /// Root output directory for compiler-rt compiled for `target`\n+    fn compiler_rt_out(&self, target: &str) -> PathBuf {\n+        self.out.join(target).join(\"compiler-rt\")\n+    }\n+\n+    /// Root output directory for rust_test_helpers library compiled for\n+    /// `target`\n+    fn test_helpers_out(&self, target: &str) -> PathBuf {\n+        self.out.join(target).join(\"rust-test-helpers\")\n+    }\n+\n+    /// Adds the compiler's directory of dynamic libraries to `cmd`'s dynamic\n+    /// library lookup path.\n+    fn add_rustc_lib_path(&self, compiler: &Compiler, cmd: &mut Command) {\n+        // Windows doesn't need dylib path munging because the dlls for the\n+        // compiler live next to the compiler and the system will find them\n+        // automatically.\n+        if cfg!(windows) {\n+            return\n+        }\n+\n+        add_lib_path(vec![self.rustc_libdir(compiler)], cmd);\n+    }\n+\n+    /// Adds the compiler's bootstrap key to the environment of `cmd`.\n+    fn add_bootstrap_key(&self, compiler: &Compiler, cmd: &mut Command) {\n+        // In stage0 we're using a previously released stable compiler, so we\n+        // use the stage0 bootstrap key. Otherwise we use our own build's\n+        // bootstrap key.\n+        let bootstrap_key = if compiler.is_snapshot(self) && !self.config.local_rebuild {\n+            &self.bootstrap_key_stage0\n+        } else {\n+            &self.bootstrap_key\n+        };\n+        cmd.env(\"RUSTC_BOOTSTRAP_KEY\", bootstrap_key);\n+    }\n+\n+    /// Returns the compiler's libdir where it stores the dynamic libraries that\n+    /// it itself links against.\n+    ///\n+    /// For example this returns `<sysroot>/lib` on Unix and `<sysroot>/bin` on\n+    /// Windows.\n+    fn rustc_libdir(&self, compiler: &Compiler) -> PathBuf {\n+        if compiler.is_snapshot(self) {\n+            self.rustc_snapshot_libdir()\n+        } else {\n+            self.sysroot(compiler).join(libdir(compiler.host))\n+        }\n+    }\n+\n+    /// Returns the libdir of the snapshot compiler.\n+    fn rustc_snapshot_libdir(&self) -> PathBuf {\n+        self.rustc.parent().unwrap().parent().unwrap()\n+            .join(libdir(&self.config.build))\n+    }\n+\n+    /// Runs a command, printing out nice contextual information if it fails.\n+    fn run(&self, cmd: &mut Command) {\n+        self.verbose(&format!(\"running: {:?}\", cmd));\n+        run_silent(cmd)\n+    }\n+\n+    /// Prints a message if this build is configured in verbose mode.\n+    fn verbose(&self, msg: &str) {\n+        if self.flags.verbose || self.config.verbose {\n+            println!(\"{}\", msg);\n+        }\n+    }\n+\n+    /// Returns the number of parallel jobs that have been configured for this\n+    /// build.\n+    fn jobs(&self) -> u32 {\n+        self.flags.jobs.unwrap_or(num_cpus::get() as u32)\n+    }\n+\n+    /// Returns the path to the C compiler for the target specified.\n+    fn cc(&self, target: &str) -> &Path {\n+        self.cc[target].0.path()\n+    }\n+\n+    /// Returns a list of flags to pass to the C compiler for the target\n+    /// specified.\n+    fn cflags(&self, target: &str) -> Vec<String> {\n+        // Filter out -O and /O (the optimization flags) that we picked up from\n+        // gcc-rs because the build scripts will determine that for themselves.\n+        let mut base = self.cc[target].0.args().iter()\n+                           .map(|s| s.to_string_lossy().into_owned())\n+                           .filter(|s| !s.starts_with(\"-O\") && !s.starts_with(\"/O\"))\n+                           .collect::<Vec<_>>();\n+\n+        // If we're compiling on OSX then we add a few unconditional flags\n+        // indicating that we want libc++ (more filled out than libstdc++) and\n+        // we want to compile for 10.7. This way we can ensure that\n+        // LLVM/jemalloc/etc are all properly compiled.\n+        if target.contains(\"apple-darwin\") {\n+            base.push(\"-stdlib=libc++\".into());\n+            base.push(\"-mmacosx-version-min=10.7\".into());\n+        }\n+        return base\n+    }\n+\n+    /// Returns the path to the `ar` archive utility for the target specified.\n+    fn ar(&self, target: &str) -> Option<&Path> {\n+        self.cc[target].1.as_ref().map(|p| &**p)\n+    }\n+\n+    /// Returns the path to the C++ compiler for the target specified, may panic\n+    /// if no C++ compiler was configured for the target.\n+    fn cxx(&self, target: &str) -> &Path {\n+        self.cxx[target].path()\n+    }\n+\n+    /// Returns flags to pass to the compiler to generate code for `target`.\n+    fn rustc_flags(&self, target: &str) -> Vec<String> {\n+        // New flags should be added here with great caution!\n+        //\n+        // It's quite unfortunate to **require** flags to generate code for a\n+        // target, so it should only be passed here if absolutely necessary!\n+        // Most default configuration should be done through target specs rather\n+        // than an entry here.\n+\n+        let mut base = Vec::new();\n+        if target != self.config.build && !target.contains(\"msvc\") {\n+            base.push(format!(\"-Clinker={}\", self.cc(target).display()));\n+        }\n+        return base\n     }\n }\n \n-/// Parses the `dylib_path_var()` environment variable, returning a list of\n-/// paths that are members of this lookup path.\n-pub fn dylib_path() -> Vec<PathBuf> {\n-    env::split_paths(&env::var_os(dylib_path_var()).unwrap_or(OsString::new()))\n-        .collect()\n+impl<'a> Compiler<'a> {\n+    /// Creates a new complier for the specified stage/host\n+    fn new(stage: u32, host: &'a str) -> Compiler<'a> {\n+        Compiler { stage: stage, host: host }\n+    }\n+\n+    /// Returns whether this is a snapshot compiler for `build`'s configuration\n+    fn is_snapshot(&self, build: &Build) -> bool {\n+        self.stage == 0 && self.host == build.config.build\n+    }\n }"}, {"sha": "83e9393fbaef7c7f73dfdc7351164703026f41fa", "filename": "src/bootstrap/native.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=4cf97fe57ef52c4addc03086aae784d980780d8f", "patch": "@@ -26,8 +26,8 @@ use build_helper::output;\n use cmake;\n use gcc;\n \n-use build::Build;\n-use build::util::{staticlib, up_to_date};\n+use Build;\n+use util::{staticlib, up_to_date};\n \n /// Compile LLVM for `target`.\n pub fn llvm(build: &Build, target: &str) {", "previous_filename": "src/bootstrap/build/native.rs"}, {"sha": "7c0f09c322f24cffa5bd39a0d515bc873a77a22f", "filename": "src/bootstrap/sanity.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=4cf97fe57ef52c4addc03086aae784d980780d8f", "patch": "@@ -26,7 +26,7 @@ use std::process::Command;\n \n use build_helper::output;\n \n-use build::Build;\n+use Build;\n \n pub fn check(build: &mut Build) {\n     let mut checked = HashSet::new();", "previous_filename": "src/bootstrap/build/sanity.rs"}, {"sha": "4b3be04b57c57948627bbbb601fcb7665c5315b5", "filename": "src/bootstrap/step.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=4cf97fe57ef52c4addc03086aae784d980780d8f", "patch": "@@ -22,7 +22,7 @@\n \n use std::collections::HashSet;\n \n-use build::{Build, Compiler};\n+use {Build, Compiler};\n \n #[derive(Hash, Eq, PartialEq, Clone, Debug)]\n pub struct Step<'a> {", "previous_filename": "src/bootstrap/build/step.rs"}, {"sha": "3ef7f8cab2d1b26d5a9fc41b2396b38a06215876", "filename": "src/bootstrap/util.rs", "status": "renamed", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf97fe57ef52c4addc03086aae784d980780d8f/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=4cf97fe57ef52c4addc03086aae784d980780d8f", "patch": "@@ -14,11 +14,11 @@\n //! not a lot of interesting happenings here unfortunately.\n \n use std::env;\n-use std::path::{Path, PathBuf};\n+use std::ffi::OsString;\n use std::fs;\n+use std::path::{Path, PathBuf};\n use std::process::Command;\n \n-use bootstrap::{dylib_path, dylib_path_var};\n use filetime::FileTime;\n \n /// Returns the `name` as the filename of a static library for `target`.\n@@ -121,3 +121,22 @@ fn dir_up_to_date(src: &Path, threshold: &FileTime) -> bool {\n         }\n     })\n }\n+\n+/// Returns the environment variable which the dynamic library lookup path\n+/// resides in for this platform.\n+pub fn dylib_path_var() -> &'static str {\n+    if cfg!(target_os = \"windows\") {\n+        \"PATH\"\n+    } else if cfg!(target_os = \"macos\") {\n+        \"DYLD_LIBRARY_PATH\"\n+    } else {\n+        \"LD_LIBRARY_PATH\"\n+    }\n+}\n+\n+/// Parses the `dylib_path_var()` environment variable, returning a list of\n+/// paths that are members of this lookup path.\n+pub fn dylib_path() -> Vec<PathBuf> {\n+    env::split_paths(&env::var_os(dylib_path_var()).unwrap_or(OsString::new()))\n+        .collect()\n+}", "previous_filename": "src/bootstrap/build/util.rs"}]}