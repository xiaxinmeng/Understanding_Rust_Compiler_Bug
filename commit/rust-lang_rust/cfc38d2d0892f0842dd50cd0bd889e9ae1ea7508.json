{"sha": "cfc38d2d0892f0842dd50cd0bd889e9ae1ea7508", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmYzM4ZDJkMDg5MmYwODQyZGQ1MGNkMGJkODg5ZTlhZTFlYTc1MDg=", "commit": {"author": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2020-12-07T11:34:27Z"}, "committer": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2020-12-16T13:41:47Z"}, "message": "Take into account negative impls in \"trait item not found\" suggestions", "tree": {"sha": "67556f4f12f9f50b7f41371398f862654d791078", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67556f4f12f9f50b7f41371398f862654d791078"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfc38d2d0892f0842dd50cd0bd889e9ae1ea7508", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfc38d2d0892f0842dd50cd0bd889e9ae1ea7508", "html_url": "https://github.com/rust-lang/rust/commit/cfc38d2d0892f0842dd50cd0bd889e9ae1ea7508", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfc38d2d0892f0842dd50cd0bd889e9ae1ea7508/comments", "author": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a68864b68859e5848865bd392ce6d892b16f5cdd", "url": "https://api.github.com/repos/rust-lang/rust/commits/a68864b68859e5848865bd392ce6d892b16f5cdd", "html_url": "https://github.com/rust-lang/rust/commit/a68864b68859e5848865bd392ce6d892b16f5cdd"}], "stats": {"total": 221, "additions": 193, "deletions": 28}, "files": [{"sha": "0f6253493cf69d9ff8f3a694f67253585e9cca78", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 80, "deletions": 28, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/cfc38d2d0892f0842dd50cd0bd889e9ae1ea7508/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc38d2d0892f0842dd50cd0bd889e9ae1ea7508/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=cfc38d2d0892f0842dd50cd0bd889e9ae1ea7508", "patch": "@@ -12,6 +12,7 @@ use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ExprKind, Node, QPath};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::hir::map as hir_map;\n+use rustc_middle::ty::fast_reject::simplify_type;\n use rustc_middle::ty::print::with_crate_prefix;\n use rustc_middle::ty::{\n     self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n@@ -1074,19 +1075,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             } else {\n                 \"items from traits can only be used if the trait is implemented and in scope\"\n             });\n+            let candidates_len = candidates.len();\n             let message = |action| {\n                 format!(\n                     \"the following {traits_define} an item `{name}`, perhaps you need to {action} \\\n                      {one_of_them}:\",\n                     traits_define =\n-                        if candidates.len() == 1 { \"trait defines\" } else { \"traits define\" },\n+                        if candidates_len == 1 { \"trait defines\" } else { \"traits define\" },\n                     action = action,\n-                    one_of_them = if candidates.len() == 1 { \"it\" } else { \"one of them\" },\n+                    one_of_them = if candidates_len == 1 { \"it\" } else { \"one of them\" },\n                     name = item_name,\n                 )\n             };\n             // Obtain the span for `param` and use it for a structured suggestion.\n-            let mut suggested = false;\n             if let (Some(ref param), Some(ref table)) =\n                 (param_type, self.in_progress_typeck_results)\n             {\n@@ -1147,7 +1148,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     Applicability::MaybeIncorrect,\n                                 );\n                             }\n-                            suggested = true;\n+                            return;\n                         }\n                         Node::Item(hir::Item {\n                             kind: hir::ItemKind::Trait(.., bounds, _),\n@@ -1167,45 +1168,96 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 }),\n                                 Applicability::MaybeIncorrect,\n                             );\n-                            suggested = true;\n+                            return;\n                         }\n                         _ => {}\n                     }\n                 }\n             }\n \n-            if !suggested {\n-                let action = if let Some(param) = param_type {\n-                    format!(\"restrict type parameter `{}` with\", param)\n-                } else {\n-                    // FIXME: it might only need to be imported into scope, not implemented.\n-                    \"implement\".to_string()\n-                };\n-                let mut use_note = true;\n-                if let [trait_info] = &candidates[..] {\n-                    if let Some(span) = self.tcx.hir().span_if_local(trait_info.def_id) {\n-                        err.span_note(\n-                            self.tcx.sess.source_map().guess_head_span(span),\n-                            &format!(\n-                                \"`{}` defines an item `{}`, perhaps you need to {} it\",\n-                                self.tcx.def_path_str(trait_info.def_id),\n-                                item_name,\n-                                action\n-                            ),\n-                        );\n-                        use_note = false\n+            let (potential_candidates, explicitly_negative) = if param_type.is_some() {\n+                // FIXME: Even though negative bounds are not implemented, we could maybe handle\n+                // cases where a positive bound implies a negative impl.\n+                (candidates, Vec::new())\n+            } else if let Some(simp_rcvr_ty) = simplify_type(self.tcx, rcvr_ty, true) {\n+                let mut potential_candidates = Vec::new();\n+                let mut explicitly_negative = Vec::new();\n+                for candidate in candidates {\n+                    // Check if there's a negative impl of `candidate` for `rcvr_ty`\n+                    if self\n+                        .tcx\n+                        .all_impls(candidate.def_id)\n+                        .filter(|imp_did| {\n+                            self.tcx.impl_polarity(*imp_did) == ty::ImplPolarity::Negative\n+                        })\n+                        .any(|imp_did| {\n+                            let imp = self.tcx.impl_trait_ref(imp_did).unwrap();\n+                            let imp_simp = simplify_type(self.tcx, imp.self_ty(), true);\n+                            imp_simp.map(|s| s == simp_rcvr_ty).unwrap_or(false)\n+                        })\n+                    {\n+                        explicitly_negative.push(candidate);\n+                    } else {\n+                        potential_candidates.push(candidate);\n                     }\n                 }\n-                if use_note {\n+                (potential_candidates, explicitly_negative)\n+            } else {\n+                // We don't know enough about `recv_ty` to make proper suggestions.\n+                (candidates, Vec::new())\n+            };\n+\n+            let action = if let Some(param) = param_type {\n+                format!(\"restrict type parameter `{}` with\", param)\n+            } else {\n+                // FIXME: it might only need to be imported into scope, not implemented.\n+                \"implement\".to_string()\n+            };\n+            match &potential_candidates[..] {\n+                [] => {}\n+                [trait_info] if trait_info.def_id.is_local() => {\n+                    let span = self.tcx.hir().span_if_local(trait_info.def_id).unwrap();\n+                    err.span_note(\n+                        self.tcx.sess.source_map().guess_head_span(span),\n+                        &format!(\n+                            \"`{}` defines an item `{}`, perhaps you need to {} it\",\n+                            self.tcx.def_path_str(trait_info.def_id),\n+                            item_name,\n+                            action\n+                        ),\n+                    );\n+                }\n+                trait_infos => {\n                     let mut msg = message(action);\n-                    for (i, trait_info) in candidates.iter().enumerate() {\n+                    for (i, trait_info) in trait_infos.iter().enumerate() {\n                         msg.push_str(&format!(\n                             \"\\ncandidate #{}: `{}`\",\n                             i + 1,\n                             self.tcx.def_path_str(trait_info.def_id),\n                         ));\n                     }\n-                    err.note(&msg[..]);\n+                    err.note(&msg);\n+                }\n+            }\n+            match &explicitly_negative[..] {\n+                [] => {}\n+                [trait_info] => {\n+                    let msg = format!(\n+                        \"the trait `{}` defines an item `{}`, but is explicitely unimplemented\",\n+                        self.tcx.def_path_str(trait_info.def_id),\n+                        item_name\n+                    );\n+                    err.note(&msg);\n+                }\n+                trait_infos => {\n+                    let mut msg = format!(\n+                        \"the following traits define an item `{}`, but are explicitely unimplemented:\",\n+                        item_name\n+                    );\n+                    for trait_info in trait_infos {\n+                        msg.push_str(&format!(\"\\n{}\", self.tcx.def_path_str(trait_info.def_id)));\n+                    }\n+                    err.note(&msg);\n                 }\n             }\n         }"}, {"sha": "3e336933937d04dcd782adf318e3b3bc189737e9", "filename": "src/test/ui/traits/negative-impls/explicitly-unimplemented-error-message.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/cfc38d2d0892f0842dd50cd0bd889e9ae1ea7508/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Fexplicitly-unimplemented-error-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc38d2d0892f0842dd50cd0bd889e9ae1ea7508/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Fexplicitly-unimplemented-error-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Fexplicitly-unimplemented-error-message.rs?ref=cfc38d2d0892f0842dd50cd0bd889e9ae1ea7508", "patch": "@@ -0,0 +1,53 @@\n+// This tests issue #79683: note in the error message that the trait is\n+// explicitely unimplemented instead of suggesting to implement it.\n+\n+#![feature(negative_impls)]\n+\n+struct Qux;\n+//~^ NOTE method `clone` not found for this\n+//~^^ NOTE method `foo` not found for this\n+\n+impl !Clone for Qux {}\n+\n+trait Bar {\n+    fn bar(&self);\n+}\n+\n+impl !Bar for u32 {}\n+\n+trait Foo {\n+    fn foo(&self);\n+}\n+//~^^^ NOTE `Foo` defines an item `foo`, perhaps you need to implement it\n+\n+trait FooBar {\n+    fn foo(&self);\n+}\n+\n+impl !Foo for Qux {}\n+\n+impl !FooBar for Qux {}\n+\n+impl !FooBar for u32 {}\n+\n+fn main() {\n+    Qux.clone();\n+    //~^ ERROR no method named `clone` found for struct `Qux`\n+    //~| NOTE method not found in `Qux`\n+    //~| NOTE `Clone` defines an item `clone`, but is explicitely unimplemented\n+\n+    0_u32.bar();\n+    //~^ ERROR no method named `bar` found for type `u32`\n+    //~| NOTE method not found in `u32`\n+    //~| NOTE `Bar` defines an item `bar`, but is explicitely unimplemented\n+\n+    Qux.foo();\n+    //~^ ERROR no method named `foo` found for struct `Qux`\n+    //~| NOTE method not found in `Qux`\n+    //~| NOTE the following traits define an item `foo`, but are explicitely unimplemented\n+\n+    0_u32.foo();\n+    //~^ ERROR no method named `foo` found for type `u32`\n+    //~| NOTE method not found in `u32`\n+    //~| NOTE `FooBar` defines an item `foo`, but is explicitely unimplemented\n+}"}, {"sha": "d39daaba206d2607e4180249bea9fac1e04db94b", "filename": "src/test/ui/traits/negative-impls/explicitly-unimplemented-error-message.stderr", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/cfc38d2d0892f0842dd50cd0bd889e9ae1ea7508/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Fexplicitly-unimplemented-error-message.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfc38d2d0892f0842dd50cd0bd889e9ae1ea7508/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Fexplicitly-unimplemented-error-message.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Fexplicitly-unimplemented-error-message.stderr?ref=cfc38d2d0892f0842dd50cd0bd889e9ae1ea7508", "patch": "@@ -0,0 +1,60 @@\n+error[E0599]: no method named `clone` found for struct `Qux` in the current scope\n+  --> $DIR/explicitly-unimplemented-error-message.rs:34:9\n+   |\n+LL | struct Qux;\n+   | ----------- method `clone` not found for this\n+...\n+LL |     Qux.clone();\n+   |         ^^^^^ method not found in `Qux`\n+   | \n+  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `Arc<Qux>` here\n+   |        the method is available for `Rc<Qux>` here\n+   |\n+   = help: items from traits can only be used if the trait is implemented and in scope\n+   = note: the trait `Clone` defines an item `clone`, but is explicitely unimplemented\n+\n+error[E0599]: no method named `bar` found for type `u32` in the current scope\n+  --> $DIR/explicitly-unimplemented-error-message.rs:39:11\n+   |\n+LL |     0_u32.bar();\n+   |           ^^^ method not found in `u32`\n+   |\n+   = help: items from traits can only be used if the trait is implemented and in scope\n+   = note: the trait `Bar` defines an item `bar`, but is explicitely unimplemented\n+\n+error[E0599]: no method named `foo` found for struct `Qux` in the current scope\n+  --> $DIR/explicitly-unimplemented-error-message.rs:44:9\n+   |\n+LL | struct Qux;\n+   | ----------- method `foo` not found for this\n+...\n+LL |     Qux.foo();\n+   |         ^^^ method not found in `Qux`\n+   |\n+   = help: items from traits can only be used if the trait is implemented and in scope\n+   = note: the following traits define an item `foo`, but are explicitely unimplemented:\n+           Foo\n+           FooBar\n+\n+error[E0599]: no method named `foo` found for type `u32` in the current scope\n+  --> $DIR/explicitly-unimplemented-error-message.rs:49:11\n+   |\n+LL |     0_u32.foo();\n+   |           ^^^ method not found in `u32`\n+   |\n+   = help: items from traits can only be used if the trait is implemented and in scope\n+note: `Foo` defines an item `foo`, perhaps you need to implement it\n+  --> $DIR/explicitly-unimplemented-error-message.rs:18:1\n+   |\n+LL | trait Foo {\n+   | ^^^^^^^^^\n+   = note: the trait `FooBar` defines an item `foo`, but is explicitely unimplemented\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0599`."}]}