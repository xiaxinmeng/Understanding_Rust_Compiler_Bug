{"sha": "eaac10ec0d7426b53386c053981de02a3aec2fed", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhYWMxMGVjMGQ3NDI2YjUzMzg2YzA1Mzk4MWRlMDJhM2FlYzJmZWQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-05-01T14:49:11Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-05-05T10:03:25Z"}, "message": "add `-Znll-facts` switch that dumps facts for new analysis", "tree": {"sha": "e2d92233a2a2221922a6de944efa982f1ebda760", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2d92233a2a2221922a6de944efa982f1ebda760"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eaac10ec0d7426b53386c053981de02a3aec2fed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eaac10ec0d7426b53386c053981de02a3aec2fed", "html_url": "https://github.com/rust-lang/rust/commit/eaac10ec0d7426b53386c053981de02a3aec2fed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eaac10ec0d7426b53386c053981de02a3aec2fed/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74bb9171cc50cbe560b2e780dbb1a1c2285d7886", "url": "https://api.github.com/repos/rust-lang/rust/commits/74bb9171cc50cbe560b2e780dbb1a1c2285d7886", "html_url": "https://github.com/rust-lang/rust/commit/74bb9171cc50cbe560b2e780dbb1a1c2285d7886"}], "stats": {"total": 495, "additions": 441, "deletions": 54}, "files": [{"sha": "0beda679e69592794be9d46f30235eaaf668f551", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eaac10ec0d7426b53386c053981de02a3aec2fed/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaac10ec0d7426b53386c053981de02a3aec2fed/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=eaac10ec0d7426b53386c053981de02a3aec2fed", "patch": "@@ -1250,6 +1250,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"choose which RELRO level to use\"),\n     nll_subminimal_causes: bool = (false, parse_bool, [UNTRACKED],\n         \"when tracking region error causes, accept subminimal results for faster execution.\"),\n+    nll_facts: bool = (false, parse_bool, [UNTRACKED],\n+                       \"dump facts from NLL analysis into side files\"),\n     disable_nll_user_type_assert: bool = (false, parse_bool, [UNTRACKED],\n         \"disable user provided type assertion in NLL\"),\n     trans_time_graph: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "1284a5b0e2a89a526b1a0399bf930b659bb4a146", "filename": "src/librustc_mir/borrow_check/location.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eaac10ec0d7426b53386c053981de02a3aec2fed/src%2Flibrustc_mir%2Fborrow_check%2Flocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaac10ec0d7426b53386c053981de02a3aec2fed/src%2Flibrustc_mir%2Fborrow_check%2Flocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Flocation.rs?ref=eaac10ec0d7426b53386c053981de02a3aec2fed", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(dead_code)] // TODO -- will be used in a later commit, remove then\n-\n use rustc::mir::{BasicBlock, Location, Mir};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n "}, {"sha": "d34e9434fbf2a0352a5cc4ec36b796f5cf1436f0", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 151, "deletions": 36, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/eaac10ec0d7426b53386c053981de02a3aec2fed/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaac10ec0d7426b53386c053981de02a3aec2fed/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=eaac10ec0d7426b53386c053981de02a3aec2fed", "patch": "@@ -8,28 +8,37 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use borrow_check::borrow_set::BorrowSet;\n+use borrow_check::location::LocationTable;\n+use borrow_check::nll::facts::AllFacts;\n use rustc::hir;\n-use rustc::mir::{BasicBlock, BasicBlockData, Location, Place, Mir, Rvalue};\n+use rustc::infer::InferCtxt;\n+use rustc::mir::visit::TyContext;\n use rustc::mir::visit::Visitor;\n use rustc::mir::Place::Projection;\n-use rustc::mir::{Local, PlaceProjection, ProjectionElem};\n-use rustc::mir::visit::TyContext;\n-use rustc::infer::InferCtxt;\n-use rustc::ty::{self, CanonicalTy, ClosureSubsts};\n-use rustc::ty::subst::Substs;\n+use rustc::mir::{BasicBlock, BasicBlockData, Location, Mir, Place, Rvalue};\n+use rustc::mir::{Local, PlaceProjection, ProjectionElem, Statement, Terminator};\n use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::subst::Substs;\n+use rustc::ty::{self, CanonicalTy, ClosureSubsts};\n \n+use super::region_infer::{Cause, RegionInferenceContext};\n use super::ToRegionVid;\n-use super::region_infer::{RegionInferenceContext, Cause};\n \n pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n     regioncx: &mut RegionInferenceContext<'tcx>,\n+    all_facts: &mut Option<AllFacts>,\n+    location_table: &LocationTable,\n     mir: &Mir<'tcx>,\n+    borrow_set: &BorrowSet<'tcx>,\n ) {\n     let mut cg = ConstraintGeneration {\n+        borrow_set,\n         infcx,\n         regioncx,\n+        location_table,\n+        all_facts,\n         mir,\n     };\n \n@@ -41,8 +50,11 @@ pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n /// 'cg = the duration of the constraint generation process itself.\n struct ConstraintGeneration<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> {\n     infcx: &'cg InferCtxt<'cx, 'gcx, 'tcx>,\n+    all_facts: &'cg mut Option<AllFacts>,\n+    location_table: &'cg LocationTable,\n     regioncx: &'cg mut RegionInferenceContext<'tcx>,\n     mir: &'cg Mir<'tcx>,\n+    borrow_set: &'cg BorrowSet<'tcx>,\n }\n \n impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx, 'tcx> {\n@@ -68,12 +80,14 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n     /// call. Make them live at the location where they appear.\n     fn visit_ty(&mut self, ty: &ty::Ty<'tcx>, ty_context: TyContext) {\n         match ty_context {\n-            TyContext::ReturnTy(source_info) |\n-            TyContext::YieldTy(source_info) |\n-            TyContext::LocalDecl { source_info, .. } => {\n-                span_bug!(source_info.span,\n-                          \"should not be visiting outside of the CFG: {:?}\",\n-                          ty_context);\n+            TyContext::ReturnTy(source_info)\n+            | TyContext::YieldTy(source_info)\n+            | TyContext::LocalDecl { source_info, .. } => {\n+                span_bug!(\n+                    source_info.span,\n+                    \"should not be visiting outside of the CFG: {:?}\",\n+                    ty_context\n+                );\n             }\n             TyContext::Location(location) => {\n                 self.add_regular_live_constraint(*ty, location, Cause::LiveOther(location));\n@@ -90,25 +104,117 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n         self.super_closure_substs(substs);\n     }\n \n+    fn visit_statement(\n+        &mut self,\n+        block: BasicBlock,\n+        statement: &Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        if let Some(all_facts) = self.all_facts {\n+            all_facts.cfg_edge.push((\n+                self.location_table.start_index(location),\n+                self.location_table.mid_index(location),\n+            ));\n+\n+            all_facts.cfg_edge.push((\n+                self.location_table.mid_index(location),\n+                self.location_table\n+                    .start_index(location.successor_within_block()),\n+            ));\n+        }\n+\n+        self.super_statement(block, statement, location);\n+    }\n+\n+    fn visit_assign(\n+        &mut self,\n+        block: BasicBlock,\n+        place: &Place<'tcx>,\n+        rvalue: &Rvalue<'tcx>,\n+        location: Location,\n+    ) {\n+        // When we see `X = ...`, then kill borrows of\n+        // `(*X).foo` and so forth.\n+        if let Some(all_facts) = self.all_facts {\n+            if let Place::Local(temp) = place {\n+                if let Some(borrow_indices) = self.borrow_set.local_map.get(temp) {\n+                    for &borrow_index in borrow_indices {\n+                        let location_index = self.location_table.mid_index(location);\n+                        all_facts.killed.push((borrow_index, location_index));\n+                    }\n+                }\n+            }\n+        }\n+\n+        self.super_assign(block, place, rvalue, location);\n+    }\n+\n+    fn visit_terminator(\n+        &mut self,\n+        block: BasicBlock,\n+        terminator: &Terminator<'tcx>,\n+        location: Location,\n+    ) {\n+        if let Some(all_facts) = self.all_facts {\n+            all_facts.cfg_edge.push((\n+                self.location_table.start_index(location),\n+                self.location_table.mid_index(location),\n+            ));\n+\n+            for successor_block in terminator.successors() {\n+                all_facts.cfg_edge.push((\n+                    self.location_table.mid_index(location),\n+                    self.location_table\n+                        .start_index(successor_block.start_location()),\n+                ));\n+            }\n+        }\n+\n+        self.super_terminator(block, terminator, location);\n+    }\n+\n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         debug!(\"visit_rvalue(rvalue={:?}, location={:?})\", rvalue, location);\n \n-        // Look for an rvalue like:\n-        //\n-        //     & L\n-        //\n-        // where L is the path that is borrowed. In that case, we have\n-        // to add the reborrow constraints (which don't fall out\n-        // naturally from the type-checker).\n-        if let Rvalue::Ref(region, _bk, ref borrowed_lv) = *rvalue {\n-            self.add_reborrow_constraint(location, region, borrowed_lv);\n+        match rvalue {\n+            Rvalue::Ref(region, _borrow_kind, borrowed_place) => {\n+                // In some cases, e.g. when borrowing from an unsafe\n+                // place, we don't bother to create a loan, since\n+                // there are no conditions to validate.\n+                if let Some(all_facts) = self.all_facts {\n+                    if let Some(borrow_index) = self.borrow_set.location_map.get(&location) {\n+                        let region_vid = region.to_region_vid();\n+                        all_facts.borrow_region.push((\n+                            region_vid,\n+                            *borrow_index,\n+                            self.location_table.mid_index(location),\n+                        ));\n+                    }\n+                }\n+\n+                // Look for an rvalue like:\n+                //\n+                //     & L\n+                //\n+                // where L is the path that is borrowed. In that case, we have\n+                // to add the reborrow constraints (which don't fall out\n+                // naturally from the type-checker).\n+                self.add_reborrow_constraint(location, region, borrowed_place);\n+            }\n+\n+            _ => { }\n         }\n \n         self.super_rvalue(rvalue, location);\n     }\n \n-    fn visit_user_assert_ty(&mut self, _c_ty: &CanonicalTy<'tcx>,\n-                            _local: &Local, _location: Location) { }\n+    fn visit_user_assert_ty(\n+        &mut self,\n+        _c_ty: &CanonicalTy<'tcx>,\n+        _local: &Local,\n+        _location: Location,\n+    ) {\n+    }\n }\n \n impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n@@ -122,8 +228,7 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n     {\n         debug!(\n             \"add_regular_live_constraint(live_ty={:?}, location={:?})\",\n-            live_ty,\n-            location\n+            live_ty, location\n         );\n \n         self.infcx\n@@ -144,8 +249,10 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n     ) {\n         let mut borrowed_place = borrowed_place;\n \n-        debug!(\"add_reborrow_constraint({:?}, {:?}, {:?})\",\n-               location, borrow_region, borrowed_place);\n+        debug!(\n+            \"add_reborrow_constraint({:?}, {:?}, {:?})\",\n+            location, borrow_region, borrowed_place\n+        );\n         while let Projection(box PlaceProjection { base, elem }) = borrowed_place {\n             debug!(\"add_reborrow_constraint - iteration {:?}\", borrowed_place);\n \n@@ -165,12 +272,20 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n                                 location.successor_within_block(),\n                             );\n \n+                            if let Some(all_facts) = self.all_facts {\n+                                all_facts.outlives.push((\n+                                    ref_region.to_region_vid(),\n+                                    borrow_region.to_region_vid(),\n+                                    self.location_table.mid_index(location),\n+                                ));\n+                            }\n+\n                             match mutbl {\n                                 hir::Mutability::MutImmutable => {\n                                     // Immutable reference. We don't need the base\n                                     // to be valid for the entire lifetime of\n                                     // the borrow.\n-                                    break\n+                                    break;\n                                 }\n                                 hir::Mutability::MutMutable => {\n                                     // Mutable reference. We *do* need the base\n@@ -199,19 +314,19 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n                         }\n                         ty::TyRawPtr(..) => {\n                             // deref of raw pointer, guaranteed to be valid\n-                            break\n+                            break;\n                         }\n                         ty::TyAdt(def, _) if def.is_box() => {\n                             // deref of `Box`, need the base to be valid - propagate\n                         }\n-                        _ => bug!(\"unexpected deref ty {:?} in {:?}\", base_ty, borrowed_place)\n+                        _ => bug!(\"unexpected deref ty {:?} in {:?}\", base_ty, borrowed_place),\n                     }\n                 }\n-                ProjectionElem::Field(..) |\n-                ProjectionElem::Downcast(..) |\n-                ProjectionElem::Index(..) |\n-                ProjectionElem::ConstantIndex { .. } |\n-                ProjectionElem::Subslice { .. } => {\n+                ProjectionElem::Field(..)\n+                | ProjectionElem::Downcast(..)\n+                | ProjectionElem::Index(..)\n+                | ProjectionElem::ConstantIndex { .. }\n+                | ProjectionElem::Subslice { .. } => {\n                     // other field access\n                 }\n             }"}, {"sha": "2802aa0dff4e23553430ca6651f149d87c5327bb", "filename": "src/librustc_mir/borrow_check/nll/facts.rs", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/eaac10ec0d7426b53386c053981de02a3aec2fed/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaac10ec0d7426b53386c053981de02a3aec2fed/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs?ref=eaac10ec0d7426b53386c053981de02a3aec2fed", "patch": "@@ -0,0 +1,194 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrow_check::location::{LocationIndex, LocationTable};\n+use dataflow::indexes::BorrowIndex;\n+use rustc::ty::RegionVid;\n+use std::error::Error;\n+use std::fmt::Debug;\n+use std::fs::{self, File};\n+use std::io::Write;\n+use std::path::Path;\n+\n+/// The \"facts\" which are the basis of the NLL borrow analysis.\n+#[derive(Default)]\n+crate struct AllFacts {\n+    // `borrow_region(R, B, P)` -- the region R may refer to data from borrow B\n+    // starting at the point P (this is usually the point *after* a borrow rvalue)\n+    crate borrow_region: Vec<(RegionVid, BorrowIndex, LocationIndex)>,\n+\n+    // universal_region(R) -- this is a \"free region\" within fn body\n+    crate universal_region: Vec<RegionVid>,\n+\n+    // `cfg_edge(P,Q)` for each edge P -> Q in the control flow\n+    crate cfg_edge: Vec<(LocationIndex, LocationIndex)>,\n+\n+    // `killed(B,P)` when some prefix of the path borrowed at B is assigned at point P\n+    crate killed: Vec<(BorrowIndex, LocationIndex)>,\n+\n+    // `outlives(R1, R2, P)` when we require `R1@P: R2@P`\n+    crate outlives: Vec<(RegionVid, RegionVid, LocationIndex)>,\n+\n+    // `region_live_at(R, P)` when the region R appears in a live variable at P\n+    crate region_live_at: Vec<(RegionVid, LocationIndex)>,\n+}\n+\n+impl AllFacts {\n+    crate fn write_to_dir(\n+        &self,\n+        dir: impl AsRef<Path>,\n+        location_table: &LocationTable,\n+    ) -> Result<(), Box<dyn Error>> {\n+        let dir: &Path = dir.as_ref();\n+        fs::create_dir_all(dir)?;\n+        let wr = FactWriter { location_table, dir };\n+        macro_rules! write_facts_to_path {\n+            ($wr:ident . write_facts_to_path($this:ident . [\n+                $($field:ident,)*\n+            ])) => {\n+                $(\n+                    $wr.write_facts_to_path(\n+                        &$this.$field,\n+                        &format!(\"{}.facts\", stringify!($field))\n+                    )?;\n+                )*\n+            }\n+        }\n+        write_facts_to_path! {\n+            wr.write_facts_to_path(self.[\n+                borrow_region,\n+                universal_region,\n+                cfg_edge,\n+                killed,\n+                outlives,\n+                region_live_at,\n+            ])\n+        }\n+        Ok(())\n+    }\n+}\n+\n+struct FactWriter<'w> {\n+    location_table: &'w LocationTable,\n+    dir: &'w Path,\n+}\n+\n+impl<'w> FactWriter<'w> {\n+    fn write_facts_to_path<T>(\n+        &self,\n+        rows: &Vec<T>,\n+        file_name: &str,\n+    ) -> Result<(), Box<dyn Error>>\n+    where\n+        T: FactRow,\n+    {\n+        let file = &self.dir.join(file_name);\n+        let mut file = File::create(file)?;\n+        for row in rows {\n+            row.write(&mut file, self.location_table)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+trait FactRow {\n+    fn write(\n+        &self,\n+        out: &mut File,\n+        location_table: &LocationTable,\n+    ) -> Result<(), Box<dyn Error>>;\n+}\n+\n+impl FactRow for RegionVid {\n+    fn write(\n+        &self,\n+        out: &mut File,\n+        location_table: &LocationTable,\n+    ) -> Result<(), Box<dyn Error>> {\n+        write_row(out, location_table, &[self])\n+    }\n+}\n+\n+impl<A, B> FactRow for (A, B)\n+where\n+    A: FactCell,\n+    B: FactCell,\n+{\n+    fn write(\n+        &self,\n+        out: &mut File,\n+        location_table: &LocationTable,\n+    ) -> Result<(), Box<dyn Error>> {\n+        write_row(out, location_table, &[&self.0, &self.1])\n+    }\n+}\n+\n+impl<A, B, C> FactRow for (A, B, C)\n+where\n+    A: FactCell,\n+    B: FactCell,\n+    C: FactCell,\n+{\n+    fn write(\n+        &self,\n+        out: &mut File,\n+        location_table: &LocationTable,\n+    ) -> Result<(), Box<dyn Error>> {\n+        write_row(out, location_table, &[&self.0, &self.1, &self.2])\n+    }\n+}\n+\n+impl<A, B, C, D> FactRow for (A, B, C, D)\n+where\n+    A: FactCell,\n+    B: FactCell,\n+    C: FactCell,\n+    D: FactCell,\n+{\n+    fn write(\n+        &self,\n+        out: &mut File,\n+        location_table: &LocationTable,\n+    ) -> Result<(), Box<dyn Error>> {\n+        write_row(out, location_table, &[&self.0, &self.1, &self.2, &self.3])\n+    }\n+}\n+\n+fn write_row(\n+    out: &mut dyn Write,\n+    location_table: &LocationTable,\n+    columns: &[&dyn FactCell],\n+) -> Result<(), Box<dyn Error>> {\n+    for (index, c) in columns.iter().enumerate() {\n+        let tail = if index == columns.len() - 1 {\n+            \"\\n\"\n+        } else {\n+            \"\\t\"\n+        };\n+        write!(out, \"{:?}{}\", c.to_string(location_table), tail)?;\n+    }\n+    Ok(())\n+}\n+\n+trait FactCell {\n+    fn to_string(&self, location_table: &LocationTable) -> String;\n+}\n+\n+impl<A: Debug> FactCell for A {\n+    default fn to_string(&self, _location_table: &LocationTable) -> String {\n+        format!(\"{:?}\", self)\n+    }\n+}\n+\n+impl FactCell for LocationIndex {\n+    fn to_string(&self, location_table: &LocationTable) -> String {\n+        format!(\"{:?}\", location_table.to_location(*self))\n+    }\n+}"}, {"sha": "0b1729294d8494b3ba74e8c61b482015f0789977", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 47, "deletions": 12, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/eaac10ec0d7426b53386c053981de02a3aec2fed/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaac10ec0d7426b53386c053981de02a3aec2fed/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=eaac10ec0d7426b53386c053981de02a3aec2fed", "patch": "@@ -10,32 +10,35 @@\n \n use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::LocationTable;\n+use dataflow::move_paths::MoveData;\n+use dataflow::FlowAtLocation;\n+use dataflow::MaybeInitializedPlaces;\n use rustc::hir::def_id::DefId;\n-use rustc::mir::{ClosureRegionRequirements, ClosureOutlivesSubject, Mir};\n use rustc::infer::InferCtxt;\n+use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements, Mir};\n use rustc::ty::{self, RegionKind, RegionVid};\n use rustc::util::nodemap::FxHashMap;\n use std::collections::BTreeSet;\n use std::fmt::Debug;\n use std::io;\n+use std::path::PathBuf;\n use transform::MirSource;\n use util::liveness::{LivenessResults, LocalSet};\n-use dataflow::FlowAtLocation;\n-use dataflow::MaybeInitializedPlaces;\n-use dataflow::move_paths::MoveData;\n \n+use self::mir_util::PassWhere;\n use util as mir_util;\n use util::pretty::{self, ALIGN};\n-use self::mir_util::PassWhere;\n \n mod constraint_generation;\n pub mod explain_borrow;\n+mod facts;\n crate mod region_infer;\n mod renumber;\n mod subtype_constraint_generation;\n crate mod type_check;\n mod universal_regions;\n \n+use self::facts::AllFacts;\n use self::region_infer::RegionInferenceContext;\n use self::universal_regions::UniversalRegions;\n \n@@ -71,11 +74,11 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     def_id: DefId,\n     universal_regions: UniversalRegions<'tcx>,\n     mir: &Mir<'tcx>,\n-    _location_table: &LocationTable,\n+    location_table: &LocationTable,\n     param_env: ty::ParamEnv<'gcx>,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'cx, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n-    _borrow_set: &BorrowSet<'tcx>,\n+    borrow_set: &BorrowSet<'tcx>,\n ) -> (\n     RegionInferenceContext<'tcx>,\n     Option<ClosureRegionRequirements<'gcx>>,\n@@ -93,15 +96,47 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n         move_data,\n     );\n \n+    let mut all_facts = if infcx.tcx.sess.opts.debugging_opts.nll_facts {\n+        Some(AllFacts::default())\n+    } else {\n+        None\n+    };\n+\n+    if let Some(all_facts) = &mut all_facts {\n+        all_facts\n+            .universal_region\n+            .extend(universal_regions.universal_regions());\n+    }\n+\n     // Create the region inference context, taking ownership of the region inference\n     // data that was contained in `infcx`.\n     let var_origins = infcx.take_region_var_origins();\n-    let mut regioncx = RegionInferenceContext::new(var_origins, universal_regions, mir);\n-    subtype_constraint_generation::generate(&mut regioncx, mir, constraint_sets);\n-\n+    let mut regioncx =\n+        RegionInferenceContext::new(var_origins, universal_regions, mir);\n+\n+    // Generate various constraints.\n+    subtype_constraint_generation::generate(\n+        &mut regioncx,\n+        &mut all_facts,\n+        location_table,\n+        mir,\n+        constraint_sets,\n+    );\n+    constraint_generation::generate_constraints(\n+        infcx,\n+        &mut regioncx,\n+        &mut all_facts,\n+        location_table,\n+        &mir,\n+        borrow_set,\n+    );\n \n-    // Generate non-subtyping constraints.\n-    constraint_generation::generate_constraints(infcx, &mut regioncx, &mir);\n+    // Dump facts if requested.\n+    if let Some(all_facts) = all_facts {\n+        let def_path = infcx.tcx.hir.def_path(def_id);\n+        let dir_path = PathBuf::from(\"nll-facts\").join(def_path.to_filename_friendly_no_crate());\n+        all_facts.write_to_dir(dir_path, location_table).unwrap();\n+    }\n \n     // Solve the region constraints.\n     let closure_region_requirements = regioncx.solve(infcx, &mir, def_id);"}, {"sha": "9db19085a39654b630dc4833d9a4b09fb2c45c70", "filename": "src/librustc_mir/borrow_check/nll/subtype_constraint_generation.rs", "status": "modified", "additions": 46, "deletions": 4, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/eaac10ec0d7426b53386c053981de02a3aec2fed/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaac10ec0d7426b53386c053981de02a3aec2fed/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs?ref=eaac10ec0d7426b53386c053981de02a3aec2fed", "patch": "@@ -8,14 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::mir::{Location, Mir};\n+use borrow_check::location::LocationTable;\n+use borrow_check::nll::facts::AllFacts;\n use rustc::infer::region_constraints::Constraint;\n use rustc::infer::region_constraints::RegionConstraintData;\n use rustc::infer::region_constraints::{Verify, VerifyBound};\n+use rustc::mir::{Location, Mir};\n use rustc::ty;\n+use std::iter;\n use syntax::codemap::Span;\n \n-use super::region_infer::{TypeTest, RegionInferenceContext, RegionTest};\n+use super::region_infer::{RegionInferenceContext, RegionTest, TypeTest};\n use super::type_check::Locations;\n use super::type_check::MirTypeckRegionConstraints;\n use super::type_check::OutlivesSet;\n@@ -27,19 +30,30 @@ use super::type_check::OutlivesSet;\n /// them into the NLL `RegionInferenceContext`.\n pub(super) fn generate<'tcx>(\n     regioncx: &mut RegionInferenceContext<'tcx>,\n+    all_facts: &mut Option<AllFacts>,\n+    location_table: &LocationTable,\n     mir: &Mir<'tcx>,\n     constraints: &MirTypeckRegionConstraints<'tcx>,\n ) {\n-    SubtypeConstraintGenerator { regioncx, mir }.generate(constraints);\n+    SubtypeConstraintGenerator {\n+        regioncx,\n+        location_table,\n+        mir,\n+    }.generate(constraints, all_facts);\n }\n \n struct SubtypeConstraintGenerator<'cx, 'tcx: 'cx> {\n     regioncx: &'cx mut RegionInferenceContext<'tcx>,\n+    location_table: &'cx LocationTable,\n     mir: &'cx Mir<'tcx>,\n }\n \n impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n-    fn generate(&mut self, constraints: &MirTypeckRegionConstraints<'tcx>) {\n+    fn generate(\n+        &mut self,\n+        constraints: &MirTypeckRegionConstraints<'tcx>,\n+        all_facts: &mut Option<AllFacts>,\n+    ) {\n         let MirTypeckRegionConstraints {\n             liveness_set,\n             outlives_sets,\n@@ -57,6 +71,17 @@ impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n             self.regioncx.add_live_point(region_vid, *location, &cause);\n         }\n \n+        if let Some(all_facts) = all_facts {\n+            all_facts\n+                .region_live_at\n+                .extend(liveness_set.into_iter().flat_map(|(region, location, _)| {\n+                    let r = self.to_region_vid(region);\n+                    let p1 = self.location_table.start_index(*location);\n+                    let p2 = self.location_table.mid_index(*location);\n+                    iter::once((r, p1)).chain(iter::once((r, p2)))\n+                }));\n+        }\n+\n         for OutlivesSet { locations, data } in outlives_sets {\n             debug!(\"generate: constraints at: {:#?}\", locations);\n             let RegionConstraintData {\n@@ -88,6 +113,23 @@ impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n                 // \"outlives\" (`>=`) whereas the region constraints\n                 // talk about `<=`.\n                 self.regioncx.add_outlives(span, b_vid, a_vid, at_location);\n+\n+                // In the new analysis, all outlives relations etc\n+                // \"take effect\" at the mid point of the statement\n+                // that requires them, so ignore the `at_location`.\n+                if let Some(all_facts) = all_facts {\n+                    if let Some(from_location) = locations.from_location() {\n+                        all_facts.outlives.push((\n+                            b_vid,\n+                            a_vid,\n+                            self.location_table.mid_index(from_location),\n+                        ));\n+                    } else {\n+                        for location in self.location_table.all_points() {\n+                            all_facts.outlives.push((b_vid, a_vid, location));\n+                        }\n+                    }\n+                }\n             }\n \n             for verify in verifys {"}, {"sha": "2545ba3a94af12215c6a4a15437304944a2ee358", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eaac10ec0d7426b53386c053981de02a3aec2fed/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaac10ec0d7426b53386c053981de02a3aec2fed/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=eaac10ec0d7426b53386c053981de02a3aec2fed", "patch": "@@ -34,6 +34,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(inclusive_range_methods)]\n #![feature(crate_visibility_modifier)]\n #![feature(never_type)]\n+#![feature(specialization)]\n #![cfg_attr(stage0, feature(try_trait))]\n \n extern crate arena;"}]}