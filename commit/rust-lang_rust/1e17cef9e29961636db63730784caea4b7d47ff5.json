{"sha": "1e17cef9e29961636db63730784caea4b7d47ff5", "node_id": "C_kwDOAAsO6NoAKDFlMTdjZWY5ZTI5OTYxNjM2ZGI2MzczMDc4NGNhZWE0YjdkNDdmZjU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-03T10:06:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-03T10:06:59Z"}, "message": "Auto merge of #109432 - flba-eb:108594_forkspawn_exponential_backoff, r=workingjubilee\n\nQNX Neutrino: exponential backoff when fork/spawn needs a retry\n\nFixes #108594: When retrying, sleep with an exponential duration. When sleep duration is lower than minimum possible sleeping time, yield instead (this will not be often due to the exponential increase of duration).\n\nMinimum possible sleeping time is determined using `libc::clock_getres` but only when spawn/fork failed the first time in a request. This is cached using a LazyLock.\n\nCC `@gh-tr`\n\nr? `@workingjubilee`\n`@rustbot` label +O-neutrino", "tree": {"sha": "f92edbe04aef03a1f27bba0adf597ad6d41370ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f92edbe04aef03a1f27bba0adf597ad6d41370ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e17cef9e29961636db63730784caea4b7d47ff5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e17cef9e29961636db63730784caea4b7d47ff5", "html_url": "https://github.com/rust-lang/rust/commit/1e17cef9e29961636db63730784caea4b7d47ff5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e17cef9e29961636db63730784caea4b7d47ff5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8177591aecf9c2ab1e96ba7fe2c00753f26a2011", "url": "https://api.github.com/repos/rust-lang/rust/commits/8177591aecf9c2ab1e96ba7fe2c00753f26a2011", "html_url": "https://github.com/rust-lang/rust/commit/8177591aecf9c2ab1e96ba7fe2c00753f26a2011"}, {"sha": "716cc5ac938ad0a5302fe924a7142c0cc1d7d515", "url": "https://api.github.com/repos/rust-lang/rust/commits/716cc5ac938ad0a5302fe924a7142c0cc1d7d515", "html_url": "https://github.com/rust-lang/rust/commit/716cc5ac938ad0a5302fe924a7142c0cc1d7d515"}], "stats": {"total": 84, "additions": 63, "deletions": 21}, "files": [{"sha": "3721988b405b4ff9a74cd2a3b7ef0355117c54f4", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 62, "deletions": 14, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/1e17cef9e29961636db63730784caea4b7d47ff5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e17cef9e29961636db63730784caea4b7d47ff5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=1e17cef9e29961636db63730784caea4b7d47ff5", "patch": "@@ -35,8 +35,26 @@ cfg_if::cfg_if! {\n     if #[cfg(all(target_os = \"nto\", target_env = \"nto71\"))] {\n         use crate::thread;\n         use libc::{c_char, posix_spawn_file_actions_t, posix_spawnattr_t};\n-        // arbitrary number of tries:\n-        const MAX_FORKSPAWN_TRIES: u32 = 4;\n+        use crate::time::Duration;\n+        use crate::sync::LazyLock;\n+        // Get smallest amount of time we can sleep.\n+        // Return a common value if it cannot be determined.\n+        fn get_clock_resolution() -> Duration {\n+            static MIN_DELAY: LazyLock<Duration, fn() -> Duration> = LazyLock::new(|| {\n+                let mut mindelay = libc::timespec { tv_sec: 0, tv_nsec: 0 };\n+                if unsafe { libc::clock_getres(libc::CLOCK_MONOTONIC, &mut mindelay) } == 0\n+                {\n+                    Duration::from_nanos(mindelay.tv_nsec as u64)\n+                } else {\n+                    Duration::from_millis(1)\n+                }\n+            });\n+            *MIN_DELAY\n+        }\n+        // Arbitrary minimum sleep duration for retrying fork/spawn\n+        const MIN_FORKSPAWN_SLEEP: Duration = Duration::from_nanos(1);\n+        // Maximum duration of sleeping before giving up and returning an error\n+        const MAX_FORKSPAWN_SLEEP: Duration = Duration::from_millis(1000);\n     }\n }\n \n@@ -163,12 +181,25 @@ impl Command {\n     unsafe fn do_fork(&mut self) -> Result<(pid_t, pid_t), io::Error> {\n         use crate::sys::os::errno;\n \n-        let mut tries_left = MAX_FORKSPAWN_TRIES;\n+        let mut delay = MIN_FORKSPAWN_SLEEP;\n+\n         loop {\n             let r = libc::fork();\n-            if r == -1 as libc::pid_t && tries_left > 0 && errno() as libc::c_int == libc::EBADF {\n-                thread::yield_now();\n-                tries_left -= 1;\n+            if r == -1 as libc::pid_t && errno() as libc::c_int == libc::EBADF {\n+                if delay < get_clock_resolution() {\n+                    // We cannot sleep this short (it would be longer).\n+                    // Yield instead.\n+                    thread::yield_now();\n+                } else if delay < MAX_FORKSPAWN_SLEEP {\n+                    thread::sleep(delay);\n+                } else {\n+                    return Err(io::const_io_error!(\n+                        ErrorKind::WouldBlock,\n+                        \"forking returned EBADF too often\",\n+                    ));\n+                }\n+                delay *= 2;\n+                continue;\n             } else {\n                 return cvt(r).map(|res| (res, -1));\n             }\n@@ -480,17 +511,28 @@ impl Command {\n             attrp: *const posix_spawnattr_t,\n             argv: *const *mut c_char,\n             envp: *const *mut c_char,\n-        ) -> i32 {\n-            let mut tries_left = MAX_FORKSPAWN_TRIES;\n+        ) -> io::Result<i32> {\n+            let mut delay = MIN_FORKSPAWN_SLEEP;\n             loop {\n                 match libc::posix_spawnp(pid, file, file_actions, attrp, argv, envp) {\n-                    libc::EBADF if tries_left > 0 => {\n-                        thread::yield_now();\n-                        tries_left -= 1;\n+                    libc::EBADF => {\n+                        if delay < get_clock_resolution() {\n+                            // We cannot sleep this short (it would be longer).\n+                            // Yield instead.\n+                            thread::yield_now();\n+                        } else if delay < MAX_FORKSPAWN_SLEEP {\n+                            thread::sleep(delay);\n+                        } else {\n+                            return Err(io::const_io_error!(\n+                                ErrorKind::WouldBlock,\n+                                \"posix_spawnp returned EBADF too often\",\n+                            ));\n+                        }\n+                        delay *= 2;\n                         continue;\n                     }\n                     r => {\n-                        return r;\n+                        return Ok(r);\n                     }\n                 }\n             }\n@@ -620,14 +662,20 @@ impl Command {\n             let spawn_fn = libc::posix_spawnp;\n             #[cfg(target_os = \"nto\")]\n             let spawn_fn = retrying_libc_posix_spawnp;\n-            cvt_nz(spawn_fn(\n+\n+            let spawn_res = spawn_fn(\n                 &mut p.pid,\n                 self.get_program_cstr().as_ptr(),\n                 file_actions.0.as_ptr(),\n                 attrs.0.as_ptr(),\n                 self.get_argv().as_ptr() as *const _,\n                 envp as *const _,\n-            ))?;\n+            );\n+\n+            #[cfg(target_os = \"nto\")]\n+            let spawn_res = spawn_res?;\n+\n+            cvt_nz(spawn_res)?;\n             Ok(Some(p))\n         }\n     }"}, {"sha": "b376c4a84ac9ee71d8ae077aa47e3db0f55b2953", "filename": "src/doc/rustc/src/platform-support/nto-qnx.md", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1e17cef9e29961636db63730784caea4b7d47ff5/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Fnto-qnx.md", "raw_url": "https://github.com/rust-lang/rust/raw/1e17cef9e29961636db63730784caea4b7d47ff5/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Fnto-qnx.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Fnto-qnx.md?ref=1e17cef9e29961636db63730784caea4b7d47ff5", "patch": "@@ -164,18 +164,12 @@ export exclude_tests='\n     --exclude tests/run-make-fulldeps'\n \n env $build_env \\\n-    ./x.py test -j 1 \\\n+    ./x.py test \\\n         $exclude_tests \\\n         --stage 1 \\\n         --target x86_64-pc-nto-qnx710\n ```\n \n-Currently, only one thread can be used when testing due to limitations in `libc::fork` and `libc::posix_spawnp`.\n-See [fork documentation](https://www.qnx.com/developers/docs/7.1/#com.qnx.doc.neutrino.lib_ref/topic/f/fork.html)\n-(error section) for more information.\n-This can be achieved by using the `-j 1` parameter in the `x.py` call.\n-This issue is being researched and we will try to allow parallelism in the future.\n-\n ## Building Rust programs\n \n Rust does not yet ship pre-compiled artifacts for this target."}]}