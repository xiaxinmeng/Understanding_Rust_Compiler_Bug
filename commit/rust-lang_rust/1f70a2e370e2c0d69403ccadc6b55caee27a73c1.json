{"sha": "1f70a2e370e2c0d69403ccadc6b55caee27a73c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmNzBhMmUzNzBlMmMwZDY5NDAzY2NhZGM2YjU1Y2FlZTI3YTczYzE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-06-16T21:33:36Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-06-18T22:18:43Z"}, "message": "rustc: allow \"lifting\" T<'a> to T<'tcx> if the value is part of ty::ctxt<'tcx>.", "tree": {"sha": "98eac30a666b7202fee82fc0ed9ae32b83bc5903", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98eac30a666b7202fee82fc0ed9ae32b83bc5903"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f70a2e370e2c0d69403ccadc6b55caee27a73c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f70a2e370e2c0d69403ccadc6b55caee27a73c1", "html_url": "https://github.com/rust-lang/rust/commit/1f70a2e370e2c0d69403ccadc6b55caee27a73c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f70a2e370e2c0d69403ccadc6b55caee27a73c1/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8952e7932823a3f3aa9d4af0ab9fa6f08b18cef", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8952e7932823a3f3aa9d4af0ab9fa6f08b18cef", "html_url": "https://github.com/rust-lang/rust/commit/d8952e7932823a3f3aa9d4af0ab9fa6f08b18cef"}], "stats": {"total": 122, "additions": 122, "deletions": 0}, "files": [{"sha": "2a0c224ad807a925ab3686bcc7346737fa66408a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/1f70a2e370e2c0d69403ccadc6b55caee27a73c1/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f70a2e370e2c0d69403ccadc6b55caee27a73c1/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=1f70a2e370e2c0d69403ccadc6b55caee27a73c1", "patch": "@@ -802,6 +802,128 @@ impl<'tcx> ctxt<'tcx> {\n     pub fn free_region_map(&self, id: NodeId) -> FreeRegionMap {\n         self.free_region_maps.borrow()[&id].clone()\n     }\n+\n+    pub fn lift<T: Lift<'tcx>>(&self, value: &T) -> Option<T::Lifted> {\n+        value.lift_to_tcx(self)\n+    }\n+}\n+\n+/// A trait implemented for all X<'a> types which can be safely and\n+/// efficiently converted to X<'tcx> as long as they are part of the\n+/// provided ty::ctxt<'tcx>.\n+/// This can be done, for example, for Ty<'tcx> or &'tcx Substs<'tcx>\n+/// by looking them up in their respective interners.\n+pub trait Lift<'tcx> {\n+    type Lifted;\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<Self::Lifted>;\n+}\n+\n+impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>> Lift<'tcx> for (A, B) {\n+    type Lifted = (A::Lifted, B::Lifted);\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.0).and_then(|a| tcx.lift(&self.1).map(|b| (a, b)))\n+    }\n+}\n+\n+impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Vec<T> {\n+    type Lifted = Vec<T::Lifted>;\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<Self::Lifted> {\n+        let mut result = Vec::with_capacity(self.len());\n+        for x in self {\n+            if let Some(value) = tcx.lift(x) {\n+                result.push(value);\n+            } else {\n+                return None;\n+            }\n+        }\n+        Some(result)\n+    }\n+}\n+\n+impl<'tcx> Lift<'tcx> for Region {\n+    type Lifted = Self;\n+    fn lift_to_tcx(&self, _: &ctxt<'tcx>) -> Option<Region> {\n+        Some(*self)\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for Ty<'a> {\n+    type Lifted = Ty<'tcx>;\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<Ty<'tcx>> {\n+        if let Some(&ty) = tcx.interner.borrow().get(&self.sty) {\n+            if *self as *const _ == ty as *const _ {\n+                return Some(ty);\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n+    type Lifted = &'tcx Substs<'tcx>;\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<&'tcx Substs<'tcx>> {\n+        if let Some(&substs) = tcx.substs_interner.borrow().get(*self) {\n+            if *self as *const _ == substs as *const _ {\n+                return Some(substs);\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for TraitRef<'a> {\n+    type Lifted = TraitRef<'tcx>;\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<TraitRef<'tcx>> {\n+        tcx.lift(&self.substs).map(|substs| TraitRef {\n+            def_id: self.def_id,\n+            substs: substs\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for TraitPredicate<'a> {\n+    type Lifted = TraitPredicate<'tcx>;\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<TraitPredicate<'tcx>> {\n+        tcx.lift(&self.trait_ref).map(|trait_ref| TraitPredicate {\n+            trait_ref: trait_ref\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for EquatePredicate<'a> {\n+    type Lifted = EquatePredicate<'tcx>;\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<EquatePredicate<'tcx>> {\n+        tcx.lift(&(self.0, self.1)).map(|(a, b)| EquatePredicate(a, b))\n+    }\n+}\n+\n+impl<'tcx, A: Copy+Lift<'tcx>, B: Copy+Lift<'tcx>> Lift<'tcx> for OutlivesPredicate<A, B> {\n+    type Lifted = OutlivesPredicate<A::Lifted, B::Lifted>;\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&(self.0, self.1)).map(|(a, b)| OutlivesPredicate(a, b))\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ProjectionPredicate<'a> {\n+    type Lifted = ProjectionPredicate<'tcx>;\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<ProjectionPredicate<'tcx>> {\n+        tcx.lift(&(self.projection_ty.trait_ref, self.ty)).map(|(trait_ref, ty)| {\n+            ProjectionPredicate {\n+                projection_ty: ProjectionTy {\n+                    trait_ref: trait_ref,\n+                    item_name: self.projection_ty.item_name\n+                },\n+                ty: ty\n+            }\n+        })\n+    }\n+}\n+\n+impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Binder<T> {\n+    type Lifted = Binder<T::Lifted>;\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.0).map(|x| Binder(x))\n+    }\n }\n \n pub mod tls {"}]}