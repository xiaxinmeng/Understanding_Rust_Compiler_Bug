{"sha": "e15538d7ac6c4a7f6ab269565d1aac8cca71e73a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxNTUzOGQ3YWM2YzRhN2Y2YWIyNjk1NjVkMWFhYzhjY2E3MWU3M2E=", "commit": {"author": {"name": "Alexis", "email": "a.beingessner@gmail.com", "date": "2015-02-06T18:57:13Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-06T19:12:29Z"}, "message": "fix outdated docs\n\nConflicts:\n\tsrc/libstd/collections/mod.rs", "tree": {"sha": "72f333fda4401d35a8fcca04309d823d650af2fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72f333fda4401d35a8fcca04309d823d650af2fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e15538d7ac6c4a7f6ab269565d1aac8cca71e73a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e15538d7ac6c4a7f6ab269565d1aac8cca71e73a", "html_url": "https://github.com/rust-lang/rust/commit/e15538d7ac6c4a7f6ab269565d1aac8cca71e73a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e15538d7ac6c4a7f6ab269565d1aac8cca71e73a/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a9b4e5f8dfc7bb8f27cc27c3f2ecf9750b87a26", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a9b4e5f8dfc7bb8f27cc27c3f2ecf9750b87a26", "html_url": "https://github.com/rust-lang/rust/commit/3a9b4e5f8dfc7bb8f27cc27c3f2ecf9750b87a26"}], "stats": {"total": 176, "additions": 88, "deletions": 88}, "files": [{"sha": "275fc34f8132659c3c35bfc381d7755e45168bc7", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e15538d7ac6c4a7f6ab269565d1aac8cca71e73a/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e15538d7ac6c4a7f6ab269565d1aac8cca71e73a/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=e15538d7ac6c4a7f6ab269565d1aac8cca71e73a", "patch": "@@ -183,7 +183,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     /// let mut heap = BinaryHeap::new();\n-    /// heap.push(4u);\n+    /// heap.push(4);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> BinaryHeap<T> { BinaryHeap { data: vec![] } }\n@@ -198,7 +198,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     /// let mut heap = BinaryHeap::with_capacity(10);\n-    /// heap.push(4u);\n+    /// heap.push(4);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: usize) -> BinaryHeap<T> {\n@@ -292,7 +292,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// use std::collections::BinaryHeap;\n     /// let mut heap = BinaryHeap::with_capacity(100);\n     /// assert!(heap.capacity() >= 100);\n-    /// heap.push(4u);\n+    /// heap.push(4);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> usize { self.data.capacity() }\n@@ -315,7 +315,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// let mut heap = BinaryHeap::new();\n     /// heap.reserve_exact(100);\n     /// assert!(heap.capacity() >= 100);\n-    /// heap.push(4u);\n+    /// heap.push(4);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: usize) {\n@@ -336,7 +336,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// let mut heap = BinaryHeap::new();\n     /// heap.reserve(100);\n     /// assert!(heap.capacity() >= 100);\n-    /// heap.push(4u);\n+    /// heap.push(4);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: usize) {"}, {"sha": "1b6057d4c728660d1e046776ea5718c08064e854", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e15538d7ac6c4a7f6ab269565d1aac8cca71e73a/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e15538d7ac6c4a7f6ab269565d1aac8cca71e73a/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=e15538d7ac6c4a7f6ab269565d1aac8cca71e73a", "patch": "@@ -173,7 +173,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut a = BTreeMap::new();\n-    /// a.insert(1u, \"a\");\n+    /// a.insert(1, \"a\");\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n@@ -203,7 +203,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n-    /// map.insert(1u, \"a\");\n+    /// map.insert(1, \"a\");\n     /// assert_eq!(map.get(&1), Some(&\"a\"));\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n@@ -235,7 +235,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n-    /// map.insert(1u, \"a\");\n+    /// map.insert(1, \"a\");\n     /// assert_eq!(map.contains_key(&1), true);\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n@@ -255,7 +255,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n-    /// map.insert(1u, \"a\");\n+    /// map.insert(1, \"a\");\n     /// match map.get_mut(&1) {\n     ///     Some(x) => *x = \"b\",\n     ///     None => (),\n@@ -317,7 +317,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n-    /// assert_eq!(map.insert(37u, \"a\"), None);\n+    /// assert_eq!(map.insert(37, \"a\"), None);\n     /// assert_eq!(map.is_empty(), false);\n     ///\n     /// map.insert(37, \"b\");\n@@ -429,7 +429,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n-    /// map.insert(1u, \"a\");\n+    /// map.insert(1, \"a\");\n     /// assert_eq!(map.remove(&1), Some(\"a\"));\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n@@ -1170,16 +1170,16 @@ impl<K, V> BTreeMap<K, V> {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n-    /// map.insert(1u, \"a\");\n-    /// map.insert(2u, \"b\");\n-    /// map.insert(3u, \"c\");\n+    /// map.insert(1, \"a\");\n+    /// map.insert(2, \"b\");\n+    /// map.insert(3, \"c\");\n     ///\n     /// for (key, value) in map.iter() {\n     ///     println!(\"{}: {}\", key, value);\n     /// }\n     ///\n     /// let (first_key, first_value) = map.iter().next().unwrap();\n-    /// assert_eq!((*first_key, *first_value), (1u, \"a\"));\n+    /// assert_eq!((*first_key, *first_value), (1, \"a\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<K, V> {\n@@ -1203,9 +1203,9 @@ impl<K, V> BTreeMap<K, V> {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n-    /// map.insert(\"a\", 1u);\n-    /// map.insert(\"b\", 2u);\n-    /// map.insert(\"c\", 3u);\n+    /// map.insert(\"a\", 1);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n     ///\n     /// // add 10 to the value if the key isn't \"a\"\n     /// for (key, value) in map.iter_mut() {\n@@ -1235,9 +1235,9 @@ impl<K, V> BTreeMap<K, V> {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n-    /// map.insert(1u, \"a\");\n-    /// map.insert(2u, \"b\");\n-    /// map.insert(3u, \"c\");\n+    /// map.insert(1, \"a\");\n+    /// map.insert(2, \"b\");\n+    /// map.insert(3, \"c\");\n     ///\n     /// for (key, value) in map.into_iter() {\n     ///     println!(\"{}: {}\", key, value);\n@@ -1264,11 +1264,11 @@ impl<K, V> BTreeMap<K, V> {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut a = BTreeMap::new();\n-    /// a.insert(1u, \"a\");\n-    /// a.insert(2u, \"b\");\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n     ///\n     /// let keys: Vec<usize> = a.keys().cloned().collect();\n-    /// assert_eq!(keys, vec![1u,2,]);\n+    /// assert_eq!(keys, vec![1,2,]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n@@ -1286,8 +1286,8 @@ impl<K, V> BTreeMap<K, V> {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut a = BTreeMap::new();\n-    /// a.insert(1u, \"a\");\n-    /// a.insert(2u, \"b\");\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n     ///\n     /// let values: Vec<&str> = a.values().cloned().collect();\n     /// assert_eq!(values, vec![\"a\",\"b\"]);\n@@ -1309,7 +1309,7 @@ impl<K, V> BTreeMap<K, V> {\n     ///\n     /// let mut a = BTreeMap::new();\n     /// assert_eq!(a.len(), 0);\n-    /// a.insert(1u, \"a\");\n+    /// a.insert(1, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1324,7 +1324,7 @@ impl<K, V> BTreeMap<K, V> {\n     ///\n     /// let mut a = BTreeMap::new();\n     /// assert!(a.is_empty());\n-    /// a.insert(1u, \"a\");\n+    /// a.insert(1, \"a\");\n     /// assert!(!a.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1474,13 +1474,13 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// use std::collections::Bound::{Included, Unbounded};\n     ///\n     /// let mut map = BTreeMap::new();\n-    /// map.insert(3u, \"a\");\n-    /// map.insert(5u, \"b\");\n-    /// map.insert(8u, \"c\");\n+    /// map.insert(3, \"a\");\n+    /// map.insert(5, \"b\");\n+    /// map.insert(8, \"c\");\n     /// for (&key, &value) in map.range(Included(&4), Included(&8)) {\n     ///     println!(\"{}: {}\", key, value);\n     /// }\n-    /// assert_eq!(Some((&5u, &\"b\")), map.range(Included(&4), Unbounded).next());\n+    /// assert_eq!(Some((&5, &\"b\")), map.range(Included(&4), Unbounded).next());\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n@@ -1539,7 +1539,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///     }\n     /// }\n     ///\n-    /// assert_eq!(count[\"a\"], 3u);\n+    /// assert_eq!(count[\"a\"], 3);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn entry(&mut self, mut key: K) -> Entry<K, V> {"}, {"sha": "c888a261f9d21851e426c654c687eca504b0a283", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e15538d7ac6c4a7f6ab269565d1aac8cca71e73a/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e15538d7ac6c4a7f6ab269565d1aac8cca71e73a/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=e15538d7ac6c4a7f6ab269565d1aac8cca71e73a", "patch": "@@ -114,14 +114,14 @@ impl<T> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let set: BTreeSet<usize> = [1u, 2, 3, 4].iter().map(|&x| x).collect();\n+    /// let set: BTreeSet<usize> = [1, 2, 3, 4].iter().map(|&x| x).collect();\n     ///\n     /// for x in set.iter() {\n     ///     println!(\"{}\", x);\n     /// }\n     ///\n     /// let v: Vec<usize> = set.iter().map(|&x| x).collect();\n-    /// assert_eq!(v, vec![1u,2,3,4]);\n+    /// assert_eq!(v, vec![1,2,3,4]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n@@ -135,10 +135,10 @@ impl<T> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let set: BTreeSet<usize> = [1u, 2, 3, 4].iter().map(|&x| x).collect();\n+    /// let set: BTreeSet<usize> = [1, 2, 3, 4].iter().map(|&x| x).collect();\n     ///\n     /// let v: Vec<usize> = set.into_iter().collect();\n-    /// assert_eq!(v, vec![1u,2,3,4]);\n+    /// assert_eq!(v, vec![1,2,3,4]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n@@ -162,13 +162,13 @@ impl<T: Ord> BTreeSet<T> {\n     /// use std::collections::Bound::{Included, Unbounded};\n     ///\n     /// let mut set = BTreeSet::new();\n-    /// set.insert(3u);\n-    /// set.insert(5u);\n-    /// set.insert(8u);\n+    /// set.insert(3);\n+    /// set.insert(5);\n+    /// set.insert(8);\n     /// for &elem in set.range(Included(&4), Included(&8)) {\n     ///     println!(\"{}\", elem);\n     /// }\n-    /// assert_eq!(Some(&5u), set.range(Included(&4), Unbounded).next());\n+    /// assert_eq!(Some(&5), set.range(Included(&4), Unbounded).next());\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n@@ -189,15 +189,15 @@ impl<T: Ord> BTreeSet<T> {\n     /// use std::collections::BTreeSet;\n     ///\n     /// let mut a = BTreeSet::new();\n-    /// a.insert(1u);\n-    /// a.insert(2u);\n+    /// a.insert(1);\n+    /// a.insert(2);\n     ///\n     /// let mut b = BTreeSet::new();\n-    /// b.insert(2u);\n-    /// b.insert(3u);\n+    /// b.insert(2);\n+    /// b.insert(3);\n     ///\n     /// let diff: Vec<usize> = a.difference(&b).cloned().collect();\n-    /// assert_eq!(diff, vec![1u]);\n+    /// assert_eq!(diff, vec![1]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n@@ -212,15 +212,15 @@ impl<T: Ord> BTreeSet<T> {\n     /// use std::collections::BTreeSet;\n     ///\n     /// let mut a = BTreeSet::new();\n-    /// a.insert(1u);\n-    /// a.insert(2u);\n+    /// a.insert(1);\n+    /// a.insert(2);\n     ///\n     /// let mut b = BTreeSet::new();\n-    /// b.insert(2u);\n-    /// b.insert(3u);\n+    /// b.insert(2);\n+    /// b.insert(3);\n     ///\n     /// let sym_diff: Vec<usize> = a.symmetric_difference(&b).cloned().collect();\n-    /// assert_eq!(sym_diff, vec![1u,3]);\n+    /// assert_eq!(sym_diff, vec![1,3]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a BTreeSet<T>)\n@@ -236,15 +236,15 @@ impl<T: Ord> BTreeSet<T> {\n     /// use std::collections::BTreeSet;\n     ///\n     /// let mut a = BTreeSet::new();\n-    /// a.insert(1u);\n-    /// a.insert(2u);\n+    /// a.insert(1);\n+    /// a.insert(2);\n     ///\n     /// let mut b = BTreeSet::new();\n-    /// b.insert(2u);\n-    /// b.insert(3u);\n+    /// b.insert(2);\n+    /// b.insert(3);\n     ///\n     /// let intersection: Vec<usize> = a.intersection(&b).cloned().collect();\n-    /// assert_eq!(intersection, vec![2u]);\n+    /// assert_eq!(intersection, vec![2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>)\n@@ -260,13 +260,13 @@ impl<T: Ord> BTreeSet<T> {\n     /// use std::collections::BTreeSet;\n     ///\n     /// let mut a = BTreeSet::new();\n-    /// a.insert(1u);\n+    /// a.insert(1);\n     ///\n     /// let mut b = BTreeSet::new();\n-    /// b.insert(2u);\n+    /// b.insert(2);\n     ///\n     /// let union: Vec<usize> = a.union(&b).cloned().collect();\n-    /// assert_eq!(union, vec![1u,2]);\n+    /// assert_eq!(union, vec![1,2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T> {"}, {"sha": "f5df7018153c4a039955460a061e122ae2405183", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e15538d7ac6c4a7f6ab269565d1aac8cca71e73a/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e15538d7ac6c4a7f6ab269565d1aac8cca71e73a/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=e15538d7ac6c4a7f6ab269565d1aac8cca71e73a", "patch": "@@ -388,7 +388,7 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::with_capacity(15);\n-    /// buf.extend(0u..4);\n+    /// buf.extend(0..4);\n     /// assert_eq!(buf.capacity(), 15);\n     /// buf.shrink_to_fit();\n     /// assert!(buf.capacity() >= 4);"}, {"sha": "aec9446773f2ac5e5e46f2d9371cce50b0089beb", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e15538d7ac6c4a7f6ab269565d1aac8cca71e73a/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e15538d7ac6c4a7f6ab269565d1aac8cca71e73a/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=e15538d7ac6c4a7f6ab269565d1aac8cca71e73a", "patch": "@@ -90,7 +90,7 @@ impl DefaultResizePolicy {\n fn test_resize_policy() {\n     use prelude::v1::*;\n     let rp = DefaultResizePolicy;\n-    for n in 0u..1000 {\n+    for n in 0..1000 {\n         assert!(rp.min_capacity(rp.usable_capacity(n)) <= n);\n         assert!(rp.usable_capacity(rp.min_capacity(n)) <= n);\n     }\n@@ -287,9 +287,9 @@ fn test_resize_policy() {\n /// // Use a HashMap to store the vikings' health points.\n /// let mut vikings = HashMap::new();\n ///\n-/// vikings.insert(Viking::new(\"Einar\", \"Norway\"), 25u);\n-/// vikings.insert(Viking::new(\"Olaf\", \"Denmark\"), 24u);\n-/// vikings.insert(Viking::new(\"Harald\", \"Iceland\"), 12u);\n+/// vikings.insert(Viking::new(\"Einar\", \"Norway\"), 25);\n+/// vikings.insert(Viking::new(\"Olaf\", \"Denmark\"), 24);\n+/// vikings.insert(Viking::new(\"Harald\", \"Iceland\"), 12);\n ///\n /// // Use derived implementation to print the status of the vikings.\n /// for (viking, health) in vikings.iter() {\n@@ -537,7 +537,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///\n     /// let s = RandomState::new();\n     /// let mut map = HashMap::with_hash_state(s);\n-    /// map.insert(1, 2u);\n+    /// map.insert(1, 2);\n     /// ```\n     #[inline]\n     #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n@@ -565,7 +565,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///\n     /// let s = RandomState::new();\n     /// let mut map = HashMap::with_capacity_and_hash_state(10, s);\n-    /// map.insert(1, 2u);\n+    /// map.insert(1, 2);\n     /// ```\n     #[inline]\n     #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n@@ -947,7 +947,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///\n     /// let mut a = HashMap::new();\n     /// assert_eq!(a.len(), 0);\n-    /// a.insert(1u, \"a\");\n+    /// a.insert(1, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -962,7 +962,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     ///\n     /// let mut a = HashMap::new();\n     /// assert!(a.is_empty());\n-    /// a.insert(1u, \"a\");\n+    /// a.insert(1, \"a\");\n     /// assert!(!a.is_empty());\n     /// ```\n     #[inline]\n@@ -978,8 +978,8 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// use std::collections::HashMap;\n     ///\n     /// let mut a = HashMap::new();\n-    /// a.insert(1u, \"a\");\n-    /// a.insert(2u, \"b\");\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n     ///\n     /// for (k, v) in a.drain().take(1) {\n     ///     assert!(k == 1 || k == 2);\n@@ -1009,7 +1009,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// use std::collections::HashMap;\n     ///\n     /// let mut a = HashMap::new();\n-    /// a.insert(1u, \"a\");\n+    /// a.insert(1, \"a\");\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n@@ -1031,7 +1031,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map = HashMap::new();\n-    /// map.insert(1u, \"a\");\n+    /// map.insert(1, \"a\");\n     /// assert_eq!(map.get(&1), Some(&\"a\"));\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n@@ -1054,7 +1054,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map = HashMap::new();\n-    /// map.insert(1u, \"a\");\n+    /// map.insert(1, \"a\");\n     /// assert_eq!(map.contains_key(&1), true);\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n@@ -1077,7 +1077,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map = HashMap::new();\n-    /// map.insert(1u, \"a\");\n+    /// map.insert(1, \"a\");\n     /// match map.get_mut(&1) {\n     ///     Some(x) => *x = \"b\",\n     ///     None => (),\n@@ -1100,7 +1100,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map = HashMap::new();\n-    /// assert_eq!(map.insert(37u, \"a\"), None);\n+    /// assert_eq!(map.insert(37, \"a\"), None);\n     /// assert_eq!(map.is_empty(), false);\n     ///\n     /// map.insert(37, \"b\");\n@@ -1132,7 +1132,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map = HashMap::new();\n-    /// map.insert(1u, \"a\");\n+    /// map.insert(1, \"a\");\n     /// assert_eq!(map.remove(&1), Some(\"a\"));\n     /// assert_eq!(map.remove(&1), None);\n     /// ```"}, {"sha": "e40f17f29e804d898c95390874922f788afe0c35", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e15538d7ac6c4a7f6ab269565d1aac8cca71e73a/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e15538d7ac6c4a7f6ab269565d1aac8cca71e73a/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=e15538d7ac6c4a7f6ab269565d1aac8cca71e73a", "patch": "@@ -81,10 +81,10 @@ use super::state::HashState;\n ///\n /// let mut vikings = HashSet::new();\n ///\n-/// vikings.insert(Viking { name: \"Einar\", power: 9u });\n-/// vikings.insert(Viking { name: \"Einar\", power: 9u });\n-/// vikings.insert(Viking { name: \"Olaf\", power: 4u });\n-/// vikings.insert(Viking { name: \"Harald\", power: 8u });\n+/// vikings.insert(Viking { name: \"Einar\", power: 9 });\n+/// vikings.insert(Viking { name: \"Einar\", power: 9 });\n+/// vikings.insert(Viking { name: \"Olaf\", power: 4 });\n+/// vikings.insert(Viking { name: \"Harald\", power: 8 });\n ///\n /// // Use derived implementation to print the vikings.\n /// for x in vikings.iter() {\n@@ -146,7 +146,7 @@ impl<T, S, H> HashSet<T, S>\n     ///\n     /// let s = RandomState::new();\n     /// let mut set = HashSet::with_hash_state(s);\n-    /// set.insert(2u);\n+    /// set.insert(2);\n     /// ```\n     #[inline]\n     #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n@@ -169,7 +169,7 @@ impl<T, S, H> HashSet<T, S>\n     /// use std::collections::hash_map::RandomState;\n     ///\n     /// let s = RandomState::new();\n-    /// let mut set = HashSet::with_capacity_and_hash_state(10u, s);\n+    /// let mut set = HashSet::with_capacity_and_hash_state(10, s);\n     /// set.insert(1);\n     /// ```\n     #[inline]\n@@ -398,7 +398,7 @@ impl<T, S, H> HashSet<T, S>\n     ///\n     /// let mut v = HashSet::new();\n     /// assert_eq!(v.len(), 0);\n-    /// v.insert(1u);\n+    /// v.insert(1);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -413,7 +413,7 @@ impl<T, S, H> HashSet<T, S>\n     ///\n     /// let mut v = HashSet::new();\n     /// assert!(v.is_empty());\n-    /// v.insert(1u);\n+    /// v.insert(1);\n     /// assert!(!v.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -438,7 +438,7 @@ impl<T, S, H> HashSet<T, S>\n     /// use std::collections::HashSet;\n     ///\n     /// let mut v = HashSet::new();\n-    /// v.insert(1u);\n+    /// v.insert(1);\n     /// v.clear();\n     /// assert!(v.is_empty());\n     /// ```\n@@ -545,7 +545,7 @@ impl<T, S, H> HashSet<T, S>\n     ///\n     /// let mut set = HashSet::new();\n     ///\n-    /// assert_eq!(set.insert(2u), true);\n+    /// assert_eq!(set.insert(2), true);\n     /// assert_eq!(set.insert(2), false);\n     /// assert_eq!(set.len(), 1);\n     /// ```\n@@ -566,7 +566,7 @@ impl<T, S, H> HashSet<T, S>\n     ///\n     /// let mut set = HashSet::new();\n     ///\n-    /// set.insert(2u);\n+    /// set.insert(2);\n     /// assert_eq!(set.remove(&2), true);\n     /// assert_eq!(set.remove(&2), false);\n     /// ```"}, {"sha": "55924bc73a8d5e2f6b4d9dc65b6425bbc8cccc56", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e15538d7ac6c4a7f6ab269565d1aac8cca71e73a/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e15538d7ac6c4a7f6ab269565d1aac8cca71e73a/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=e15538d7ac6c4a7f6ab269565d1aac8cca71e73a", "patch": "@@ -306,7 +306,7 @@\n //!\n //! for c in message.chars() {\n //!     match count.entry(c) {\n-//!         Entry::Vacant(entry) => { entry.insert(1u); },\n+//!         Entry::Vacant(entry) => { entry.insert(1); },\n //!         Entry::Occupied(mut entry) => *entry.get_mut() += 1,\n //!     }\n //! }"}]}