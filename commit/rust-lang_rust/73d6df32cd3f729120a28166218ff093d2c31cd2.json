{"sha": "73d6df32cd3f729120a28166218ff093d2c31cd2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczZDZkZjMyY2QzZjcyOTEyMGEyODE2NjIxOGZmMDkzZDJjMzFjZDI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-27T15:22:57Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-27T15:22:57Z"}, "message": "Emergency safe-ref-checker maintenance\n\nIt still has some big problems, but at least it more or less\nunderstands block arguments now.\n\nCloses #1925", "tree": {"sha": "5f6b8e2d7385c306d1d1b5b830a1438ab243ee0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f6b8e2d7385c306d1d1b5b830a1438ab243ee0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73d6df32cd3f729120a28166218ff093d2c31cd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73d6df32cd3f729120a28166218ff093d2c31cd2", "html_url": "https://github.com/rust-lang/rust/commit/73d6df32cd3f729120a28166218ff093d2c31cd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73d6df32cd3f729120a28166218ff093d2c31cd2/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5a4fa9456683f40539f885d4e555b87384df09a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5a4fa9456683f40539f885d4e555b87384df09a", "html_url": "https://github.com/rust-lang/rust/commit/b5a4fa9456683f40539f885d4e555b87384df09a"}], "stats": {"total": 174, "additions": 92, "deletions": 82}, "files": [{"sha": "3fe17f96bbdce6ee619fed626b38179b9f47f053", "filename": "src/rustc/middle/alias.rs", "status": "modified", "additions": 91, "deletions": 81, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/73d6df32cd3f729120a28166218ff093d2c31cd2/src%2Frustc%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d6df32cd3f729120a28166218ff093d2c31cd2/src%2Frustc%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Falias.rs?ref=73d6df32cd3f729120a28166218ff093d2c31cd2", "patch": "@@ -99,8 +99,8 @@ fn visit_expr(cx: @ctx, ex: @ast::expr, sc: scope, v: vt<scope>) {\n     let mut handled = true;\n     alt ex.node {\n       ast::expr_call(f, args, _) {\n-        check_call(*cx, sc, f, args);\n-        handled = false;\n+        check_call(cx, sc, f, args, v);\n+        visit_expr(cx, f, sc, v);\n       }\n       ast::expr_alt(input, arms, _) { check_alt(*cx, input, arms, sc, v); }\n       ast::expr_for(decl, seq, blk) {\n@@ -163,33 +163,6 @@ fn visit_block(cx: @ctx, b: ast::blk, sc: scope, v: vt<scope>) {\n     visit::visit_expr_opt(b.node.expr, sc, v);\n }\n \n-fn add_bindings_for_let(cx: ctx, &bs: [binding], loc: @ast::local) {\n-    alt loc.node.init {\n-      some(init) {\n-        if init.op == ast::init_move {\n-            err(cx, loc.span, \"can not move into a by-reference binding\");\n-        }\n-        let root = expr_root(cx, init.expr, false);\n-        let root_var = path_def_id(cx, root.ex);\n-        if is_none(root_var) {\n-            err(cx, loc.span, \"a reference binding can't be \\\n-                               rooted in a temporary\");\n-        }\n-        for proot in pattern_roots(cx.tcx, root.mutbl, loc.node.pat) {\n-            let bnd = mk_binding(cx, proot.id, proot.span, root_var,\n-                                 unsafe_set(proot.mutbl));\n-            // Don't implicitly copy explicit references\n-            bnd.copied = not_allowed;\n-            bs += [bnd];\n-        }\n-      }\n-      _ {\n-        err(cx, loc.span, \"by-reference bindings must be initialized\");\n-      }\n-    }\n-}\n-\n-\n fn cant_copy(cx: ctx, b: binding) -> bool {\n     alt b.copied {\n       not_allowed { ret true; }\n@@ -209,47 +182,67 @@ fn cant_copy(cx: ctx, b: binding) -> bool {\n     } else { ret true; }\n }\n \n-fn check_call(cx: ctx, sc: scope, f: @ast::expr, args: [@ast::expr])\n-    -> [binding] {\n+// FIXME this is a really awful hack\n+fn local_id_for_args(cx: ctx, args: [@ast::expr]) -> uint {\n+    for vec::each(args) {|arg|\n+        alt arg.node {\n+          ast::expr_fn_block(decl, _) | ast::expr_fn(_, decl, _, _) |\n+          ast::expr_loop_body(@{node: ast::expr_fn_block(decl, _), _}) {\n+            if decl.inputs.len() > 0u {\n+                ret local_id_of_node(cx, decl.inputs[0].id);\n+            }\n+          }\n+          _ {}\n+        }\n+    }\n+    0xFFFFFFFFu\n+}\n+\n+fn check_call(cx: @ctx, sc: scope, f: @ast::expr, args: [@ast::expr],\n+              v: vt<scope>) {\n     let fty = ty::expr_ty(cx.tcx, f);\n     let arg_ts = ty::ty_fn_args(fty);\n-    let mut mut_roots: [{arg: uint, node: node_id}] = [];\n+    let mut mut_roots: [{arg: @ast::expr, node: node_id}] = [];\n     let mut bindings = [];\n-    let mut i = 0u;\n-    for arg_t: ty::arg in arg_ts {\n-        let arg = args[i];\n-        let root = expr_root(cx, arg, false);\n+    let mut blocks = [], loc_id = local_id_for_args(*cx, args);\n+    vec::iter2(args, arg_ts) {|arg, arg_t|\n+        let root = expr_root(*cx, arg, false);\n         alt ty::resolved_mode(cx.tcx, arg_t.mode) {\n           ast::by_mutbl_ref {\n-            alt path_def(cx, arg) {\n+            alt path_def(*cx, arg) {\n               some(def) {\n                 let dnum = ast_util::def_id_of_def(def).node;\n-                mut_roots += [{arg: i, node: dnum}];\n+                mut_roots += [{arg: arg, node: dnum}];\n               }\n               _ { }\n             }\n           }\n-          ast::by_ref | ast::by_val | ast::by_move | ast::by_copy { }\n+          ast::by_ref | ast::by_val | ast::by_move | ast::by_copy {}\n+        }\n+        alt arg.node {\n+          ast::expr_fn_block(_, _) { blocks += [arg]; }\n+          ast::expr_loop_body(b) { blocks += [b]; }\n+          _ {\n+            let root_var = path_def_id(*cx, root.ex);\n+            let arg_copied = alt ty::resolved_mode(cx.tcx, arg_t.mode) {\n+              ast::by_move | ast::by_copy { copied }\n+              ast::by_mutbl_ref { not_allowed }\n+              ast::by_ref | ast::by_val { not_copied }\n+            };\n+            visit_expr(cx, arg, sc, v);\n+            bindings += [@{node_id: arg.id,\n+                           span: arg.span,\n+                           root_var: root_var,\n+                           local_id: loc_id,\n+                           unsafe_tys: unsafe_set(root.mutbl),\n+                           mut copied: arg_copied}];\n+          }\n         }\n-        let root_var = path_def_id(cx, root.ex);\n-        let arg_copied = alt ty::resolved_mode(cx.tcx, arg_t.mode) {\n-          ast::by_move | ast::by_copy { copied }\n-          ast::by_mutbl_ref { not_allowed }\n-          ast::by_ref | ast::by_val { not_copied }\n-        };\n-        bindings += [@{node_id: arg.id,\n-                       span: arg.span,\n-                       root_var: root_var,\n-                       local_id: 0u,\n-                       unsafe_tys: unsafe_set(root.mutbl),\n-                       mut copied: arg_copied}];\n-        i += 1u;\n     }\n-    let f_may_close =\n-        alt f.node {\n-          ast::expr_path(_) { def_is_local_or_self(cx.tcx.def_map.get(f.id)) }\n-          _ { true }\n-        };\n+    let f_may_close = alt f.node {\n+      ast::expr_path(_) { def_is_local_or_self(cx.tcx.def_map.get(f.id)) }\n+      _ { true }\n+    };\n     if f_may_close {\n         let mut i = 0u;\n         for b in bindings {\n@@ -264,43 +257,44 @@ fn check_call(cx: ctx, sc: scope, f: @ast::expr, args: [@ast::expr])\n               }\n               _ {}\n             }\n-            if unsfe && cant_copy(cx, b) {\n-                err(cx, f.span, #fmt[\"function may alias with argument \\\n-                                     %u, which is not immutably rooted\", i]);\n+            if unsfe && cant_copy(*cx, b) {\n+                err(*cx, f.span, #fmt[\"function may alias with argument \\\n+                                      %u, which is not immutably rooted\", i]);\n             }\n             i += 1u;\n         }\n     }\n     let mut j = 0u;\n     for b in bindings {\n         for unsafe_ty in b.unsafe_tys {\n-            let mut i = 0u;\n-            for arg_t: ty::arg in arg_ts {\n+            vec::iteri(arg_ts) {|i, arg_t|\n                 let mut_alias =\n                     (ast::by_mutbl_ref == ty::arg_mode(cx.tcx, arg_t));\n-                if i != j &&\n-                       ty_can_unsafely_include(cx, unsafe_ty, arg_t.ty,\n-                                               mut_alias) &&\n-                       cant_copy(cx, b) {\n-                    err(cx, args[i].span,\n-                        #fmt[\"argument %u may alias with argument %u, \\\n-                             which is not immutably rooted\", i, j]);\n+                alt args[i].node {\n+                  ast::expr_fn_block(_, _) | ast::expr_loop_body(_) {}\n+                  _ {\n+                    if i != j && ty_can_unsafely_include(\n+                        *cx, unsafe_ty, arg_t.ty, mut_alias) &&\n+                       cant_copy(*cx, b) {\n+                        err(*cx, args[i].span,\n+                            #fmt[\"argument %u may alias with argument %u, \\\n+                                  which is not immutably rooted\", i, j]);\n+                    }\n+                  }\n                 }\n-                i += 1u;\n             }\n         }\n         j += 1u;\n     }\n-    // Ensure we're not passing a root by mut alias.\n \n+    // Ensure we're not passing a root by mut alias.\n     for {node: node, arg: arg} in mut_roots {\n-        let mut i = 0u;\n         for b in bindings {\n-            if i != arg {\n+            if b.node_id != arg.id {\n                 alt b.root_var {\n                   some(root) {\n-                    if node == root && cant_copy(cx, b) {\n-                        err(cx, args[arg].span,\n+                    if node == root && cant_copy(*cx, b) {\n+                        err(*cx, arg.span,\n                             \"passing a mut reference to a \\\n                              variable that roots another reference\");\n                         break;\n@@ -309,10 +303,22 @@ fn check_call(cx: ctx, sc: scope, f: @ast::expr, args: [@ast::expr])\n                   none { }\n                 }\n             }\n-            i += 1u;\n         }\n     }\n-    ret bindings;\n+    // Check the bodies of block arguments against the current scope\n+    if blocks.len() > 0u {\n+        let inner_sc = {bs: bindings + sc.bs, invalid: sc.invalid};\n+        for blk in blocks {\n+            alt check blk.node {\n+              ast::expr_fn_block(_, body) {\n+                v.visit_block(body, inner_sc, v);\n+              }\n+            }\n+        }\n+        for binding in bindings {\n+            test_scope(*cx, sc, binding, none);\n+        }\n+    }\n }\n \n fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n@@ -397,7 +403,7 @@ fn check_var(cx: ctx, ex: @ast::expr, p: @ast::path, id: ast::node_id,\n                 }\n             }\n         } else if b.node_id == my_defnum {\n-            test_scope(cx, sc, b, p);\n+            test_scope(cx, sc, b, some(p));\n         }\n     }\n }\n@@ -444,7 +450,7 @@ fn check_loop(cx: ctx, sc: scope, checker: fn()) {\n     *sc.invalid = new_invalid;\n }\n \n-fn test_scope(cx: ctx, sc: scope, b: binding, p: @ast::path) {\n+fn test_scope(cx: ctx, sc: scope, b: binding, p: option<@ast::path>) {\n     let mut prob = find_invalid(b.node_id, *sc.invalid);\n     alt b.root_var {\n       some(dn) {\n@@ -463,8 +469,12 @@ fn test_scope(cx: ctx, sc: scope, b: binding, p: @ast::path) {\n           overwritten { \"overwriting \" + ast_util::path_name(i.path) }\n           val_taken { \"taking the value of \" + ast_util::path_name(i.path) }\n         };\n-        err(cx, i.sp, msg + \" will invalidate reference \" +\n-            ast_util::path_name(p) + \", which is still used\");\n+        let refname = alt p {\n+          some(pt) { \"reference \" + ast_util::path_name(pt) +\n+                        \", which is still used\" }\n+          none { \"an argument\" }\n+        };\n+        err(cx, i.sp, msg + \" will invalidate \" + refname);\n     }\n }\n "}, {"sha": "f8baf6b93aa51c7b4ab9c92b4ce2a0823d38636b", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73d6df32cd3f729120a28166218ff093d2c31cd2/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d6df32cd3f729120a28166218ff093d2c31cd2/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=73d6df32cd3f729120a28166218ff093d2c31cd2", "patch": "@@ -3677,7 +3677,7 @@ fn trans_block_cleanups(bcx: block, cleanup_cx: block) ->\n     let mut bcx = bcx;\n     alt check cleanup_cx.kind {\n       block_scope({cleanups, _}) {\n-        vec::riter(cleanups) {|cu|\n+        vec::riter(copy cleanups) {|cu|\n             alt cu { clean(cfn) | clean_temp(_, cfn) { bcx = cfn(bcx); } }\n         }\n       }"}]}