{"sha": "5508c28ff0e27d1027ddf372410cc5e1609662bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1MDhjMjhmZjBlMjdkMTAyN2RkZjM3MjQxMGNjNWUxNjA5NjYyYmQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-02-19T02:10:07Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-02-19T02:19:27Z"}, "message": "Factor out the call typechecking logic so that bind can use it", "tree": {"sha": "e274acc3de731a85f549e2fe9f4155d29b940ecd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e274acc3de731a85f549e2fe9f4155d29b940ecd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5508c28ff0e27d1027ddf372410cc5e1609662bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5508c28ff0e27d1027ddf372410cc5e1609662bd", "html_url": "https://github.com/rust-lang/rust/commit/5508c28ff0e27d1027ddf372410cc5e1609662bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5508c28ff0e27d1027ddf372410cc5e1609662bd/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80c67268fc007d55fa0ff193ac0be6ab83640aa6", "url": "https://api.github.com/repos/rust-lang/rust/commits/80c67268fc007d55fa0ff193ac0be6ab83640aa6", "html_url": "https://github.com/rust-lang/rust/commit/80c67268fc007d55fa0ff193ac0be6ab83640aa6"}], "stats": {"total": 143, "additions": 101, "deletions": 42}, "files": [{"sha": "b259fb4e40ca445c72e146897ddf683cb47e0e9d", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 101, "deletions": 42, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/5508c28ff0e27d1027ddf372410cc5e1609662bd/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5508c28ff0e27d1027ddf372410cc5e1609662bd/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=5508c28ff0e27d1027ddf372410cc5e1609662bd", "patch": "@@ -1244,6 +1244,87 @@ fn check_pat(&@fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n }\n \n fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n+    // A generic function to factor out common logic from call and bind\n+    // expressions.\n+    fn check_call_or_bind(&@fn_ctxt fcx, &@ast.expr f,\n+                          &vec[option.t[@ast.expr]] args)\n+            -> tup(@ast.expr, vec[option.t[@ast.expr]]) {\n+\n+        // Check the function.\n+        auto f_0 = check_expr(fcx, f);\n+\n+        // Check the arguments and generate the argument signature.\n+        let vec[option.t[@ast.expr]] args_0 = vec();\n+        let vec[arg] arg_tys_0 = vec();\n+        for (option.t[@ast.expr] a_opt in args) {\n+            alt (a_opt) {\n+                case (some[@ast.expr](?a)) {\n+                    auto a_0 = check_expr(fcx, a);\n+                    args_0 += vec(some[@ast.expr](a_0));\n+\n+                    // FIXME: this breaks aliases. We need a ty_fn_arg.\n+                    auto arg_ty = rec(mode=ast.val, ty=expr_ty(a_0));\n+                    append[arg](arg_tys_0, arg_ty);\n+                }\n+                case (none[@ast.expr]) {\n+                    args_0 += vec(none[@ast.expr]);\n+\n+                    // FIXME: breaks aliases too?\n+                    auto typ = next_ty_var(fcx.ccx);\n+                    append[arg](arg_tys_0, rec(mode=ast.val, ty=typ));\n+                }\n+            }\n+        }\n+\n+        auto proto_0 = ast.proto_fn;    // FIXME: typestate botch\n+        alt (expr_ty(f_0).struct) {\n+            case (ty.ty_fn(?proto, _, _))   { proto_0 = proto; }\n+            case (_) {\n+                log \"check_call_or_bind(): fn expr doesn't have fn type\";\n+                fail;\n+            }\n+        }\n+\n+        auto rt_0 = next_ty_var(fcx.ccx);\n+        auto t_0 = plain_ty(ty.ty_fn(proto_0, arg_tys_0, rt_0));\n+\n+        // Unify and write back to the function.\n+        auto f_1 = demand_expr(fcx, t_0, f_0);\n+\n+        // Take the argument types out of the resulting function type.\n+        auto t_1 = expr_ty(f_1);\n+\n+        if (!ty.is_fn_ty(t_1)) {\n+            fcx.ccx.sess.span_err(f_1.span,\n+                                  \"mismatched types: callee has \" +\n+                                  \"non-function type: \" +\n+                                  ty_to_str(t_1));\n+        }\n+\n+        let vec[arg] arg_tys_1 = ty.ty_fn_args(t_1);\n+        let @ty.t rt_1 = ty.ty_fn_ret(t_1);\n+\n+        // Unify and write back to the arguments.\n+        auto i = 0u;\n+        let vec[option.t[@ast.expr]] args_1 = vec();\n+        while (i < _vec.len[option.t[@ast.expr]](args_0)) {\n+            alt (args_0.(i)) {\n+                case (some[@ast.expr](?e_0)) {\n+                    auto arg_ty_1 = arg_tys_1.(i);\n+                    auto e_1 = demand_expr(fcx, arg_ty_1.ty, e_0);\n+                    append[option.t[@ast.expr]](args_1, some[@ast.expr](e_1));\n+                }\n+                case (none[@ast.expr]) {\n+                    append[option.t[@ast.expr]](args_1, none[@ast.expr]);\n+                }\n+            }\n+\n+            i += 1u;\n+        }\n+\n+        ret tup(f_1, args_1);\n+    }\n+\n     alt (expr.node) {\n         case (ast.expr_lit(?lit, _)) {\n             auto ty = check_lit(lit);\n@@ -1658,62 +1739,40 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 i += 1u;\n             }\n \n-            let @ty.t t_1 = plain_ty(ty.ty_fn(proto,\n-                                              residual_args, rt_0));\n+            let @ty.t t_1 = plain_ty(ty.ty_fn(proto, residual_args, rt_0));\n+\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_bind(f_0, args_1,\n                                                       ast.ann_type(t_1)));\n-\n         }\n \n         case (ast.expr_call(?f, ?args, _)) {\n-\n-            // Check the function.\n-            auto f_0 = check_expr(fcx, f);\n-\n-            // Check the arguments and generate the argument signature.\n-            let vec[@ast.expr] args_0 = vec();\n-            let vec[arg] arg_tys_0 = vec();\n-            for (@ast.expr a in args) {\n-                auto a_0 = check_expr(fcx, a);\n-                append[@ast.expr](args_0, a_0);\n-\n-                // FIXME: this breaks aliases. We need a ty_fn_arg.\n-                append[arg](arg_tys_0, rec(mode=ast.val, ty=expr_ty(a_0)));\n+            let vec[option.t[@ast.expr]] args_opt_0 = vec();\n+            for (@ast.expr arg in args) {\n+                args_opt_0 += vec(some[@ast.expr](arg));\n             }\n-            auto rt_0 = next_ty_var(fcx.ccx);\n-            auto t_0 = plain_ty(ty.ty_fn(ty.ty_fn_proto(expr_ty(f_0)),\n-                                         arg_tys_0, rt_0));\n-\n-            // Unify and write back to the function.\n-            auto f_1 = demand_expr(fcx, t_0, f_0);\n \n-            // Take the argument types out of the resulting function type.\n-            auto t_1 = expr_ty(f_1);\n+            // Call the generic checker.\n+            auto result = check_call_or_bind(fcx, f, args_opt_0);\n \n-            if (!ty.is_fn_ty(t_1)) {\n-                fcx.ccx.sess.span_err(f_1.span,\n-                                      \"mismatched types: callee has \" +\n-                                      \"non-function type: \" +\n-                                      ty_to_str(t_1));\n-            }\n-\n-            let vec[arg] arg_tys_1 = ty.ty_fn_args(t_1);\n-            let @ty.t rt_1 = ty.ty_fn_ret(t_1);\n-\n-            // Unify and write back to the arguments.\n-            auto i = 0u;\n+            // Pull out the arguments.\n             let vec[@ast.expr] args_1 = vec();\n-            while (i < _vec.len[@ast.expr](args_0)) {\n-                auto arg_ty_1 = arg_tys_1.(i);\n-                auto e = demand_expr(fcx, arg_ty_1.ty, args_0.(i));\n-                append[@ast.expr](args_1, e);\n+            for (option.t[@ast.expr] arg in result._1) {\n+                args_1 += vec(option.get[@ast.expr](arg));\n+            }\n \n-                i += 1u;\n+            // Pull the return type out of the type of the function.\n+            auto rt_1 = plain_ty(ty.ty_nil);    // FIXME: typestate botch\n+            alt (expr_ty(result._0).struct) {\n+                case (ty.ty_fn(_,_,?rt))    { rt_1 = rt; }\n+                case (_) {\n+                    log \"LHS of call expr didn't have a function type?!\";\n+                    fail;\n+                }\n             }\n \n             ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_call(f_1, args_1,\n+                                        ast.expr_call(result._0, args_1,\n                                                       ast.ann_type(rt_1)));\n         }\n "}]}