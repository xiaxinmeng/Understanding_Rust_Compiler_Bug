{"sha": "2be6c4ae5b075028a6c61ba75daaf22fb7921c85", "node_id": "C_kwDOAAsO6NoAKDJiZTZjNGFlNWIwNzUwMjhhNmM2MWJhNzVkYWFmMjJmYjc5MjFjODU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-03T00:05:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-03T00:05:05Z"}, "message": "Auto merge of #8762 - Jarcho:visitor, r=Jarcho\n\nReplace `expr_visitor` with  `for_each_expr`\n\nThis is a minor change which uses `ControlFlow` rather than a boolean. This also runs the visitor rather than returning the visitor, which results in a small readability win as well.\n\nchangelog: None", "tree": {"sha": "6bf52e692593d836420fa05c4d34706cab08d89a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bf52e692593d836420fa05c4d34706cab08d89a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2be6c4ae5b075028a6c61ba75daaf22fb7921c85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2be6c4ae5b075028a6c61ba75daaf22fb7921c85", "html_url": "https://github.com/rust-lang/rust/commit/2be6c4ae5b075028a6c61ba75daaf22fb7921c85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bef93d3b1464b6d467482d47a53c62aadaa9f41c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bef93d3b1464b6d467482d47a53c62aadaa9f41c", "html_url": "https://github.com/rust-lang/rust/commit/bef93d3b1464b6d467482d47a53c62aadaa9f41c"}, {"sha": "26bb36636ca9d71958055e05053946d22fcfbdbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/26bb36636ca9d71958055e05053946d22fcfbdbb", "html_url": "https://github.com/rust-lang/rust/commit/26bb36636ca9d71958055e05053946d22fcfbdbb"}], "stats": {"total": 1008, "additions": 413, "deletions": 595}, "files": [{"sha": "569bf27c3e716e13e3802e7e4cd6fe8bab627135", "filename": "clippy_lints/src/blocks_in_if_conditions.rs", "status": "modified", "additions": 28, "deletions": 40, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs?ref=2be6c4ae5b075028a6c61ba75daaf22fb7921c85", "patch": "@@ -3,10 +3,11 @@ use clippy_utils::get_parent_expr;\n use clippy_utils::higher;\n use clippy_utils::source::snippet_block_with_applicability;\n use clippy_utils::ty::implements_trait;\n+use clippy_utils::visitors::{for_each_expr, Descend};\n+use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n-use rustc_hir::{BlockCheckMode, Closure, Expr, ExprKind};\n+use rustc_hir::{BlockCheckMode, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -44,39 +45,6 @@ declare_clippy_lint! {\n \n declare_lint_pass!(BlocksInIfConditions => [BLOCKS_IN_IF_CONDITIONS]);\n \n-struct ExVisitor<'a, 'tcx> {\n-    found_block: Option<&'tcx Expr<'tcx>>,\n-    cx: &'a LateContext<'tcx>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for ExVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        if let ExprKind::Closure(&Closure { body, .. }) = expr.kind {\n-            // do not lint if the closure is called using an iterator (see #1141)\n-            if_chain! {\n-                if let Some(parent) = get_parent_expr(self.cx, expr);\n-                if let ExprKind::MethodCall(_, self_arg, ..) = &parent.kind;\n-                let caller = self.cx.typeck_results().expr_ty(self_arg);\n-                if let Some(iter_id) = self.cx.tcx.get_diagnostic_item(sym::Iterator);\n-                if implements_trait(self.cx, caller, iter_id, &[]);\n-                then {\n-                    return;\n-                }\n-            }\n-\n-            let body = self.cx.tcx.hir().body(body);\n-            let ex = &body.value;\n-            if let ExprKind::Block(block, _) = ex.kind {\n-                if !body.value.span.from_expansion() && !block.stmts.is_empty() {\n-                    self.found_block = Some(ex);\n-                    return;\n-                }\n-            }\n-        }\n-        walk_expr(self, expr);\n-    }\n-}\n-\n const BRACED_EXPR_MESSAGE: &str = \"omit braces around single expression condition\";\n const COMPLEX_BLOCK_MESSAGE: &str = \"in an `if` condition, avoid complex blocks or closures with blocks; \\\n                                     instead, move the block or closure higher and bind it with a `let`\";\n@@ -144,11 +112,31 @@ impl<'tcx> LateLintPass<'tcx> for BlocksInIfConditions {\n                     }\n                 }\n             } else {\n-                let mut visitor = ExVisitor { found_block: None, cx };\n-                walk_expr(&mut visitor, cond);\n-                if let Some(block) = visitor.found_block {\n-                    span_lint(cx, BLOCKS_IN_IF_CONDITIONS, block.span, COMPLEX_BLOCK_MESSAGE);\n-                }\n+                let _: Option<!> = for_each_expr(cond, |e| {\n+                    if let ExprKind::Closure(closure) = e.kind {\n+                        // do not lint if the closure is called using an iterator (see #1141)\n+                        if_chain! {\n+                            if let Some(parent) = get_parent_expr(cx, e);\n+                            if let ExprKind::MethodCall(_, self_arg, _, _) = &parent.kind;\n+                            let caller = cx.typeck_results().expr_ty(self_arg);\n+                            if let Some(iter_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n+                            if implements_trait(cx, caller, iter_id, &[]);\n+                            then {\n+                                return ControlFlow::Continue(Descend::No);\n+                            }\n+                        }\n+\n+                        let body = cx.tcx.hir().body(closure.body);\n+                        let ex = &body.value;\n+                        if let ExprKind::Block(block, _) = ex.kind {\n+                            if !body.value.span.from_expansion() && !block.stmts.is_empty() {\n+                                span_lint(cx, BLOCKS_IN_IF_CONDITIONS, ex.span, COMPLEX_BLOCK_MESSAGE);\n+                                return ControlFlow::Continue(Descend::No);\n+                            }\n+                        }\n+                    }\n+                    ControlFlow::Continue(Descend::Yes)\n+                });\n             }\n         }\n     }"}, {"sha": "77af3b53d63338ad735d7a46f351975af3343927", "filename": "clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 28, "deletions": 35, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=2be6c4ae5b075028a6c61ba75daaf22fb7921c85", "patch": "@@ -3,10 +3,12 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::visitors::for_each_expr;\n use clippy_utils::LimitStack;\n+use core::ops::ControlFlow;\n use rustc_ast::ast::Attribute;\n-use rustc_hir::intravisit::{walk_expr, FnKind, Visitor};\n-use rustc_hir::{Body, Expr, ExprKind, FnDecl, HirId};\n+use rustc_hir::intravisit::FnKind;\n+use rustc_hir::{Body, ExprKind, FnDecl, HirId};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n@@ -61,11 +63,27 @@ impl CognitiveComplexity {\n             return;\n         }\n \n-        let expr = &body.value;\n+        let expr = body.value;\n+\n+        let mut cc = 1u64;\n+        let mut returns = 0u64;\n+        let _: Option<!> = for_each_expr(expr, |e| {\n+            match e.kind {\n+                ExprKind::If(_, _, _) => {\n+                    cc += 1;\n+                },\n+                ExprKind::Match(_, arms, _) => {\n+                    if arms.len() > 1 {\n+                        cc += 1;\n+                    }\n+                    cc += arms.iter().filter(|arm| arm.guard.is_some()).count() as u64;\n+                },\n+                ExprKind::Ret(_) => returns += 1,\n+                _ => {},\n+            }\n+            ControlFlow::Continue(())\n+        });\n \n-        let mut helper = CcHelper { cc: 1, returns: 0 };\n-        helper.visit_expr(expr);\n-        let CcHelper { cc, returns } = helper;\n         let ret_ty = cx.typeck_results().node_type(expr.hir_id);\n         let ret_adjust = if is_type_diagnostic_item(cx, ret_ty, sym::Result) {\n             returns\n@@ -74,13 +92,12 @@ impl CognitiveComplexity {\n             (returns / 2)\n         };\n \n-        let mut rust_cc = cc;\n         // prevent degenerate cases where unreachable code contains `return` statements\n-        if rust_cc >= ret_adjust {\n-            rust_cc -= ret_adjust;\n+        if cc >= ret_adjust {\n+            cc -= ret_adjust;\n         }\n \n-        if rust_cc > self.limit.limit() {\n+        if cc > self.limit.limit() {\n             let fn_span = match kind {\n                 FnKind::ItemFn(ident, _, _) | FnKind::Method(ident, _) => ident.span,\n                 FnKind::Closure => {\n@@ -107,7 +124,7 @@ impl CognitiveComplexity {\n                 COGNITIVE_COMPLEXITY,\n                 fn_span,\n                 &format!(\n-                    \"the function has a cognitive complexity of ({rust_cc}/{})\",\n+                    \"the function has a cognitive complexity of ({cc}/{})\",\n                     self.limit.limit()\n                 ),\n                 None,\n@@ -140,27 +157,3 @@ impl<'tcx> LateLintPass<'tcx> for CognitiveComplexity {\n         self.limit.pop_attrs(cx.sess(), attrs, \"cognitive_complexity\");\n     }\n }\n-\n-struct CcHelper {\n-    cc: u64,\n-    returns: u64,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for CcHelper {\n-    fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n-        walk_expr(self, e);\n-        match e.kind {\n-            ExprKind::If(_, _, _) => {\n-                self.cc += 1;\n-            },\n-            ExprKind::Match(_, arms, _) => {\n-                if arms.len() > 1 {\n-                    self.cc += 1;\n-                }\n-                self.cc += arms.iter().filter(|arm| arm.guard.is_some()).count() as u64;\n-            },\n-            ExprKind::Ret(_) => self.returns += 1,\n-            _ => {},\n-        }\n-    }\n-}"}, {"sha": "d263804f32cf48538be82cad8e979d6543d490f8", "filename": "clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 33, "deletions": 44, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=2be6c4ae5b075028a6c61ba75daaf22fb7921c85", "patch": "@@ -1,7 +1,7 @@\n use rustc_ast::ast::Attribute;\n use rustc_errors::Applicability;\n use rustc_hir::def_id::{DefIdSet, LocalDefId};\n-use rustc_hir::{self as hir, def::Res, intravisit, QPath};\n+use rustc_hir::{self as hir, def::Res, QPath};\n use rustc_lint::{LateContext, LintContext};\n use rustc_middle::{\n     lint::in_external_macro,\n@@ -13,8 +13,11 @@ use clippy_utils::attrs::is_proc_macro;\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_then};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::is_must_use_ty;\n+use clippy_utils::visitors::for_each_expr;\n use clippy_utils::{match_def_path, return_ty, trait_ref_of_method};\n \n+use core::ops::ControlFlow;\n+\n use super::{DOUBLE_MUST_USE, MUST_USE_CANDIDATE, MUST_USE_UNIT};\n \n pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n@@ -200,79 +203,65 @@ fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, tys: &m\n     }\n }\n \n-struct StaticMutVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    mutates_static: bool,\n+fn is_mutated_static(e: &hir::Expr<'_>) -> bool {\n+    use hir::ExprKind::{Field, Index, Path};\n+\n+    match e.kind {\n+        Path(QPath::Resolved(_, path)) => !matches!(path.res, Res::Local(_)),\n+        Path(_) => true,\n+        Field(inner, _) | Index(inner, _) => is_mutated_static(inner),\n+        _ => false,\n+    }\n }\n \n-impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n+fn mutates_static<'tcx>(cx: &LateContext<'tcx>, body: &'tcx hir::Body<'_>) -> bool {\n+    for_each_expr(body.value, |e| {\n         use hir::ExprKind::{AddrOf, Assign, AssignOp, Call, MethodCall};\n \n-        if self.mutates_static {\n-            return;\n-        }\n-        match expr.kind {\n+        match e.kind {\n             Call(_, args) => {\n                 let mut tys = DefIdSet::default();\n                 for arg in args {\n-                    if self.cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n+                    if cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n                         && is_mutable_ty(\n-                            self.cx,\n-                            self.cx.tcx.typeck(arg.hir_id.owner.def_id).expr_ty(arg),\n+                            cx,\n+                            cx.tcx.typeck(arg.hir_id.owner.def_id).expr_ty(arg),\n                             arg.span,\n                             &mut tys,\n                         )\n                         && is_mutated_static(arg)\n                     {\n-                        self.mutates_static = true;\n-                        return;\n+                        return ControlFlow::Break(());\n                     }\n                     tys.clear();\n                 }\n+                ControlFlow::Continue(())\n             },\n             MethodCall(_, receiver, args, _) => {\n                 let mut tys = DefIdSet::default();\n                 for arg in std::iter::once(receiver).chain(args.iter()) {\n-                    if self.cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n+                    if cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n                         && is_mutable_ty(\n-                            self.cx,\n-                            self.cx.tcx.typeck(arg.hir_id.owner.def_id).expr_ty(arg),\n+                            cx,\n+                            cx.tcx.typeck(arg.hir_id.owner.def_id).expr_ty(arg),\n                             arg.span,\n                             &mut tys,\n                         )\n                         && is_mutated_static(arg)\n                     {\n-                        self.mutates_static = true;\n-                        return;\n+                        return ControlFlow::Break(());\n                     }\n                     tys.clear();\n                 }\n+                ControlFlow::Continue(())\n             },\n-            Assign(target, ..) | AssignOp(_, target, _) | AddrOf(_, hir::Mutability::Mut, target) => {\n-                self.mutates_static |= is_mutated_static(target);\n+            Assign(target, ..) | AssignOp(_, target, _) | AddrOf(_, hir::Mutability::Mut, target)\n+                if is_mutated_static(target) =>\n+            {\n+                ControlFlow::Break(())\n             },\n-            _ => {},\n+            _ => ControlFlow::Continue(()),\n         }\n-    }\n-}\n-\n-fn is_mutated_static(e: &hir::Expr<'_>) -> bool {\n-    use hir::ExprKind::{Field, Index, Path};\n-\n-    match e.kind {\n-        Path(QPath::Resolved(_, path)) => !matches!(path.res, Res::Local(_)),\n-        Path(_) => true,\n-        Field(inner, _) | Index(inner, _) => is_mutated_static(inner),\n-        _ => false,\n-    }\n-}\n-\n-fn mutates_static<'tcx>(cx: &LateContext<'tcx>, body: &'tcx hir::Body<'_>) -> bool {\n-    let mut v = StaticMutVisitor {\n-        cx,\n-        mutates_static: false,\n-    };\n-    intravisit::walk_expr(&mut v, body.value);\n-    v.mutates_static\n+    })\n+    .is_some()\n }"}, {"sha": "b7595d101e0fa9f04893f52eb75c8f44f4c98e96", "filename": "clippy_lints/src/functions/not_unsafe_ptr_arg_deref.rs", "status": "modified", "additions": 33, "deletions": 58, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs?ref=2be6c4ae5b075028a6c61ba75daaf22fb7921c85", "patch": "@@ -5,8 +5,11 @@ use rustc_span::def_id::LocalDefId;\n \n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::ty::type_is_unsafe_function;\n+use clippy_utils::visitors::for_each_expr_with_closures;\n use clippy_utils::{iter_input_pats, path_to_local};\n \n+use core::ops::ControlFlow;\n+\n use super::NOT_UNSAFE_PTR_ARG_DEREF;\n \n pub(super) fn check_fn<'tcx>(\n@@ -39,21 +42,34 @@ fn check_raw_ptr<'tcx>(\n     body: &'tcx hir::Body<'tcx>,\n     def_id: LocalDefId,\n ) {\n-    let expr = &body.value;\n     if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(def_id) {\n         let raw_ptrs = iter_input_pats(decl, body)\n             .filter_map(|arg| raw_ptr_arg(cx, arg))\n             .collect::<HirIdSet>();\n \n         if !raw_ptrs.is_empty() {\n-            let typeck_results = cx.tcx.typeck_body(body.id());\n-            let mut v = DerefVisitor {\n-                cx,\n-                ptrs: raw_ptrs,\n-                typeck_results,\n-            };\n-\n-            intravisit::walk_expr(&mut v, expr);\n+            let typeck = cx.tcx.typeck_body(body.id());\n+            let _: Option<!> = for_each_expr_with_closures(cx, body.value, |e| {\n+                match e.kind {\n+                    hir::ExprKind::Call(f, args) if type_is_unsafe_function(cx, typeck.expr_ty(f)) => {\n+                        for arg in args {\n+                            check_arg(cx, &raw_ptrs, arg);\n+                        }\n+                    },\n+                    hir::ExprKind::MethodCall(_, recv, args, _) => {\n+                        let def_id = typeck.type_dependent_def_id(e.hir_id).unwrap();\n+                        if cx.tcx.fn_sig(def_id).skip_binder().unsafety == hir::Unsafety::Unsafe {\n+                            check_arg(cx, &raw_ptrs, recv);\n+                            for arg in args {\n+                                check_arg(cx, &raw_ptrs, arg);\n+                            }\n+                        }\n+                    },\n+                    hir::ExprKind::Unary(hir::UnOp::Deref, ptr) => check_arg(cx, &raw_ptrs, ptr),\n+                    _ => (),\n+                }\n+                ControlFlow::Continue(())\n+            });\n         }\n     }\n }\n@@ -70,54 +86,13 @@ fn raw_ptr_arg(cx: &LateContext<'_>, arg: &hir::Param<'_>) -> Option<hir::HirId>\n     }\n }\n \n-struct DerefVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    ptrs: HirIdSet,\n-    typeck_results: &'a ty::TypeckResults<'tcx>,\n-}\n-\n-impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        match expr.kind {\n-            hir::ExprKind::Call(f, args) => {\n-                let ty = self.typeck_results.expr_ty(f);\n-\n-                if type_is_unsafe_function(self.cx, ty) {\n-                    for arg in args {\n-                        self.check_arg(arg);\n-                    }\n-                }\n-            },\n-            hir::ExprKind::MethodCall(_, receiver, args, _) => {\n-                let def_id = self.typeck_results.type_dependent_def_id(expr.hir_id).unwrap();\n-                let base_type = self.cx.tcx.type_of(def_id);\n-\n-                if type_is_unsafe_function(self.cx, base_type) {\n-                    self.check_arg(receiver);\n-                    for arg in args {\n-                        self.check_arg(arg);\n-                    }\n-                }\n-            },\n-            hir::ExprKind::Unary(hir::UnOp::Deref, ptr) => self.check_arg(ptr),\n-            _ => (),\n-        }\n-\n-        intravisit::walk_expr(self, expr);\n-    }\n-}\n-\n-impl<'a, 'tcx> DerefVisitor<'a, 'tcx> {\n-    fn check_arg(&self, ptr: &hir::Expr<'_>) {\n-        if let Some(id) = path_to_local(ptr) {\n-            if self.ptrs.contains(&id) {\n-                span_lint(\n-                    self.cx,\n-                    NOT_UNSAFE_PTR_ARG_DEREF,\n-                    ptr.span,\n-                    \"this public function might dereference a raw pointer but is not marked `unsafe`\",\n-                );\n-            }\n-        }\n+fn check_arg(cx: &LateContext<'_>, raw_ptrs: &HirIdSet, arg: &hir::Expr<'_>) {\n+    if path_to_local(arg).map_or(false, |id| raw_ptrs.contains(&id)) {\n+        span_lint(\n+            cx,\n+            NOT_UNSAFE_PTR_ARG_DEREF,\n+            arg.span,\n+            \"this public function might dereference a raw pointer but is not marked `unsafe`\",\n+        );\n     }\n }"}, {"sha": "946d04eff6f9850f6c81dce875bca890f0b9d76f", "filename": "clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_return.rs?ref=2be6c4ae5b075028a6c61ba75daaf22fb7921c85", "patch": "@@ -2,10 +2,11 @@ use clippy_utils::{\n     diagnostics::span_lint_hir_and_then,\n     get_async_fn_body, is_async_fn,\n     source::{snippet_with_applicability, snippet_with_context, walk_span_to_context},\n-    visitors::expr_visitor_no_bodies,\n+    visitors::for_each_expr,\n };\n+use core::ops::ControlFlow;\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{FnKind, Visitor};\n+use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Block, Body, Expr, ExprKind, FnDecl, FnRetTy, HirId};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n@@ -152,7 +153,7 @@ fn lint_implicit_returns(\n \n         ExprKind::Loop(block, ..) => {\n             let mut add_return = false;\n-            expr_visitor_no_bodies(|e| {\n+            let _: Option<!> = for_each_expr(block, |e| {\n                 if let ExprKind::Break(dest, sub_expr) = e.kind {\n                     if dest.target_id.ok() == Some(expr.hir_id) {\n                         if call_site_span.is_none() && e.span.ctxt() == ctxt {\n@@ -167,9 +168,8 @@ fn lint_implicit_returns(\n                         }\n                     }\n                 }\n-                true\n-            })\n-            .visit_block(block);\n+                ControlFlow::Continue(())\n+            });\n             if add_return {\n                 #[expect(clippy::option_if_let_else)]\n                 if let Some(span) = call_site_span {"}, {"sha": "ae3594bd36c3ab1ecfb3a1e6022666aa900b7001", "filename": "clippy_lints/src/methods/str_splitn.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs?ref=2be6c4ae5b075028a6c61ba75daaf22fb7921c85", "patch": "@@ -2,11 +2,11 @@ use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::snippet_with_context;\n use clippy_utils::usage::local_used_after_expr;\n-use clippy_utils::visitors::expr_visitor;\n+use clippy_utils::visitors::{for_each_expr_with_closures, Descend};\n use clippy_utils::{is_diag_item_method, match_def_path, meets_msrv, msrvs, path_to_local_id, paths};\n+use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::Visitor;\n use rustc_hir::{\n     BindingAnnotation, Expr, ExprKind, HirId, LangItem, Local, MatchSource, Node, Pat, PatKind, QPath, Stmt, StmtKind,\n };\n@@ -211,7 +211,7 @@ fn indirect_usage<'tcx>(\n     binding: HirId,\n     ctxt: SyntaxContext,\n ) -> Option<IndirectUsage<'tcx>> {\n-    if let StmtKind::Local(Local {\n+    if let StmtKind::Local(&Local {\n         pat: Pat {\n             kind: PatKind::Binding(BindingAnnotation::NONE, _, ident, None),\n             ..\n@@ -222,14 +222,12 @@ fn indirect_usage<'tcx>(\n     }) = stmt.kind\n     {\n         let mut path_to_binding = None;\n-        expr_visitor(cx, |expr| {\n-            if path_to_local_id(expr, binding) {\n-                path_to_binding = Some(expr);\n+        let _: Option<!> = for_each_expr_with_closures(cx, init_expr, |e| {\n+            if path_to_local_id(e, binding) {\n+                path_to_binding = Some(e);\n             }\n-\n-            path_to_binding.is_none()\n-        })\n-        .visit_expr(init_expr);\n+            ControlFlow::Continue(Descend::from(path_to_binding.is_none()))\n+        });\n \n         let mut parents = cx.tcx.hir().parent_iter(path_to_binding?.hir_id);\n         let iter_usage = parse_iter_usage(cx, ctxt, &mut parents)?;\n@@ -250,7 +248,7 @@ fn indirect_usage<'tcx>(\n             ..\n         } = iter_usage\n         {\n-            if parent_id == *local_hir_id {\n+            if parent_id == local_hir_id {\n                 return Some(IndirectUsage {\n                     name: ident.name,\n                     span: stmt.span,"}, {"sha": "1cef6226ad4ff40925445616a8bd93c986cef96e", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 13, "deletions": 38, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=2be6c4ae5b075028a6c61ba75daaf22fb7921c85", "patch": "@@ -2,9 +2,10 @@ use super::utils::clone_or_copy_needed;\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::ty::is_copy;\n use clippy_utils::usage::mutated_variables;\n+use clippy_utils::visitors::{for_each_expr, Descend};\n use clippy_utils::{is_res_lang_ctor, is_trait_method, path_res, path_to_local_id};\n+use core::ops::ControlFlow;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n@@ -13,7 +14,7 @@ use rustc_span::sym;\n use super::UNNECESSARY_FILTER_MAP;\n use super::UNNECESSARY_FIND_MAP;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, name: &str) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'tcx>, arg: &'tcx hir::Expr<'tcx>, name: &str) {\n     if !is_trait_method(cx, expr, sym::Iterator) {\n         return;\n     }\n@@ -26,10 +27,16 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n \n         let (mut found_mapping, mut found_filtering) = check_expression(cx, arg_id, body.value);\n \n-        let mut return_visitor = ReturnVisitor::new(cx, arg_id);\n-        return_visitor.visit_expr(body.value);\n-        found_mapping |= return_visitor.found_mapping;\n-        found_filtering |= return_visitor.found_filtering;\n+        let _: Option<!> = for_each_expr(body.value, |e| {\n+            if let hir::ExprKind::Ret(Some(e)) = &e.kind {\n+                let (found_mapping_res, found_filtering_res) = check_expression(cx, arg_id, e);\n+                found_mapping |= found_mapping_res;\n+                found_filtering |= found_filtering_res;\n+                ControlFlow::Continue(Descend::No)\n+            } else {\n+                ControlFlow::Continue(Descend::Yes)\n+            }\n+        });\n \n         let in_ty = cx.typeck_results().node_type(body.params[0].hir_id);\n         let sugg = if !found_filtering {\n@@ -97,35 +104,3 @@ fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tc\n         _ => (true, true),\n     }\n }\n-\n-struct ReturnVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    arg_id: hir::HirId,\n-    // Found a non-None return that isn't Some(input)\n-    found_mapping: bool,\n-    // Found a return that isn't Some\n-    found_filtering: bool,\n-}\n-\n-impl<'a, 'tcx> ReturnVisitor<'a, 'tcx> {\n-    fn new(cx: &'a LateContext<'tcx>, arg_id: hir::HirId) -> ReturnVisitor<'a, 'tcx> {\n-        ReturnVisitor {\n-            cx,\n-            arg_id,\n-            found_mapping: false,\n-            found_filtering: false,\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for ReturnVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        if let hir::ExprKind::Ret(Some(expr)) = &expr.kind {\n-            let (found_mapping, found_filtering) = check_expression(self.cx, self.arg_id, expr);\n-            self.found_mapping |= found_mapping;\n-            self.found_filtering |= found_filtering;\n-        } else {\n-            walk_expr(self, expr);\n-        }\n-    }\n-}"}, {"sha": "9d26e5900866c85ef55e1b0bad608ca8272177a3", "filename": "clippy_lints/src/needless_late_init.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Fneedless_late_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Fneedless_late_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_late_init.rs?ref=2be6c4ae5b075028a6c61ba75daaf22fb7921c85", "patch": "@@ -2,9 +2,9 @@ use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::path_to_local;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::needs_ordered_drop;\n-use clippy_utils::visitors::{expr_visitor, expr_visitor_no_bodies, is_local_used};\n+use clippy_utils::visitors::{for_each_expr, for_each_expr_with_closures, is_local_used};\n+use core::ops::ControlFlow;\n use rustc_errors::{Applicability, MultiSpan};\n-use rustc_hir::intravisit::Visitor;\n use rustc_hir::{\n     BindingAnnotation, Block, Expr, ExprKind, HirId, Local, LocalSource, MatchSource, Node, Pat, PatKind, Stmt,\n     StmtKind,\n@@ -64,31 +64,25 @@ declare_clippy_lint! {\n declare_lint_pass!(NeedlessLateInit => [NEEDLESS_LATE_INIT]);\n \n fn contains_assign_expr<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'tcx>) -> bool {\n-    let mut seen = false;\n-    expr_visitor(cx, |expr| {\n-        if let ExprKind::Assign(..) = expr.kind {\n-            seen = true;\n+    for_each_expr_with_closures(cx, stmt, |e| {\n+        if matches!(e.kind, ExprKind::Assign(..)) {\n+            ControlFlow::Break(())\n+        } else {\n+            ControlFlow::Continue(())\n         }\n-\n-        !seen\n     })\n-    .visit_stmt(stmt);\n-\n-    seen\n+    .is_some()\n }\n \n fn contains_let(cond: &Expr<'_>) -> bool {\n-    let mut seen = false;\n-    expr_visitor_no_bodies(|expr| {\n-        if let ExprKind::Let(_) = expr.kind {\n-            seen = true;\n+    for_each_expr(cond, |e| {\n+        if matches!(e.kind, ExprKind::Let(_)) {\n+            ControlFlow::Break(())\n+        } else {\n+            ControlFlow::Continue(())\n         }\n-\n-        !seen\n     })\n-    .visit_expr(cond);\n-\n-    seen\n+    .is_some()\n }\n \n fn stmt_needs_ordered_drop(cx: &LateContext<'_>, stmt: &Stmt<'_>) -> bool {"}, {"sha": "26bca7c306a84e99d7e81f8370ed53696b62c11b", "filename": "clippy_lints/src/operators/assign_op_pattern.rs", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs?ref=2be6c4ae5b075028a6c61ba75daaf22fb7921c85", "patch": "@@ -2,11 +2,12 @@ use clippy_utils::binop_traits;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::implements_trait;\n+use clippy_utils::visitors::for_each_expr;\n use clippy_utils::{eq_expr_value, trait_ref_of_method};\n+use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n use rustc_hir_analysis::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n use rustc_lint::LateContext;\n use rustc_middle::mir::FakeReadCause;\n@@ -65,15 +66,19 @@ pub(super) fn check<'tcx>(\n             }\n         };\n \n-        let mut visitor = ExprVisitor {\n-            assignee,\n-            counter: 0,\n-            cx,\n-        };\n-\n-        walk_expr(&mut visitor, e);\n+        let mut found = false;\n+        let found_multiple = for_each_expr(e, |e| {\n+            if eq_expr_value(cx, assignee, e) {\n+                if found {\n+                    return ControlFlow::Break(());\n+                }\n+                found = true;\n+            }\n+            ControlFlow::Continue(())\n+        })\n+        .is_some();\n \n-        if visitor.counter == 1 {\n+        if found && !found_multiple {\n             // a = a op b\n             if eq_expr_value(cx, assignee, l) {\n                 lint(assignee, r);\n@@ -98,22 +103,6 @@ pub(super) fn check<'tcx>(\n     }\n }\n \n-struct ExprVisitor<'a, 'tcx> {\n-    assignee: &'a hir::Expr<'a>,\n-    counter: u8,\n-    cx: &'a LateContext<'tcx>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        if eq_expr_value(self.cx, self.assignee, expr) {\n-            self.counter += 1;\n-        }\n-\n-        walk_expr(self, expr);\n-    }\n-}\n-\n fn imm_borrows_in_expr(cx: &LateContext<'_>, e: &hir::Expr<'_>) -> hir::HirIdSet {\n     struct S(hir::HirIdSet);\n     impl Delegate<'_> for S {"}, {"sha": "efec12489a9bad42708568988843610ddfb172b9", "filename": "clippy_lints/src/panic_in_result_fn.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_in_result_fn.rs?ref=2be6c4ae5b075028a6c61ba75daaf22fb7921c85", "patch": "@@ -2,9 +2,10 @@ use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::macros::root_macro_call_first_node;\n use clippy_utils::return_ty;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::visitors::expr_visitor_no_bodies;\n+use clippy_utils::visitors::{for_each_expr, Descend};\n+use core::ops::ControlFlow;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{FnKind, Visitor};\n+use rustc_hir::intravisit::FnKind;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n@@ -58,18 +59,20 @@ impl<'tcx> LateLintPass<'tcx> for PanicInResultFn {\n \n fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, body: &'tcx hir::Body<'tcx>) {\n     let mut panics = Vec::new();\n-    expr_visitor_no_bodies(|expr| {\n-        let Some(macro_call) = root_macro_call_first_node(cx, expr) else { return true };\n+    let _: Option<!> = for_each_expr(body.value, |e| {\n+        let Some(macro_call) = root_macro_call_first_node(cx, e) else {\n+            return ControlFlow::Continue(Descend::Yes);\n+        };\n         if matches!(\n             cx.tcx.item_name(macro_call.def_id).as_str(),\n             \"unimplemented\" | \"unreachable\" | \"panic\" | \"todo\" | \"assert\" | \"assert_eq\" | \"assert_ne\"\n         ) {\n             panics.push(macro_call.span);\n-            return false;\n+            ControlFlow::Continue(Descend::No)\n+        } else {\n+            ControlFlow::Continue(Descend::Yes)\n         }\n-        true\n-    })\n-    .visit_expr(body.value);\n+    });\n     if !panics.is_empty() {\n         span_lint_and_then(\n             cx,"}, {"sha": "fa107858863a44c79f5087903acd52d2913b8b09", "filename": "clippy_lints/src/read_zero_byte_vec.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Fread_zero_byte_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Fread_zero_byte_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fread_zero_byte_vec.rs?ref=2be6c4ae5b075028a6c61ba75daaf22fb7921c85", "patch": "@@ -2,9 +2,10 @@ use clippy_utils::{\n     diagnostics::{span_lint, span_lint_and_sugg},\n     higher::{get_vec_init_kind, VecInitKind},\n     source::snippet,\n-    visitors::expr_visitor_no_bodies,\n+    visitors::for_each_expr,\n };\n-use hir::{intravisit::Visitor, ExprKind, Local, PatKind, PathSegment, QPath, StmtKind};\n+use core::ops::ControlFlow;\n+use hir::{Expr, ExprKind, Local, PatKind, PathSegment, QPath, StmtKind};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n@@ -58,38 +59,31 @@ impl<'tcx> LateLintPass<'tcx> for ReadZeroByteVec {\n                 && let PatKind::Binding(_, _, ident, _) = pat.kind\n                 && let Some(vec_init_kind) = get_vec_init_kind(cx, init)\n             {\n-                // finds use of `_.read(&mut v)`\n-                let mut read_found = false;\n-                let mut visitor = expr_visitor_no_bodies(|expr| {\n-                    if let ExprKind::MethodCall(path, _self, [arg], _) = expr.kind\n+                let visitor = |expr: &Expr<'_>| {\n+                    if let ExprKind::MethodCall(path, _, [arg], _) = expr.kind\n                         && let PathSegment { ident: read_or_read_exact, .. } = *path\n                         && matches!(read_or_read_exact.as_str(), \"read\" | \"read_exact\")\n                         && let ExprKind::AddrOf(_, hir::Mutability::Mut, inner) = arg.kind\n                         && let ExprKind::Path(QPath::Resolved(None, inner_path)) = inner.kind\n                         && let [inner_seg] = inner_path.segments\n                         && ident.name == inner_seg.ident.name\n                     {\n-                        read_found = true;\n+                        ControlFlow::Break(())\n+                    } else {\n+                        ControlFlow::Continue(())\n                     }\n-                    !read_found\n-                });\n+                };\n \n-                let next_stmt_span;\n-                if idx == block.stmts.len() - 1 {\n+                let (read_found, next_stmt_span) =\n+                if let Some(next_stmt) = block.stmts.get(idx + 1) {\n+                    // case { .. stmt; stmt; .. }\n+                    (for_each_expr(next_stmt, visitor).is_some(), next_stmt.span)\n+                } else if let Some(e) = block.expr {\n                     // case { .. stmt; expr }\n-                    if let Some(e) = block.expr {\n-                        visitor.visit_expr(e);\n-                        next_stmt_span = e.span;\n-                    } else {\n-                        return;\n-                    }\n+                    (for_each_expr(e, visitor).is_some(), e.span)\n                 } else {\n-                    // case { .. stmt; stmt; .. }\n-                    let next_stmt = &block.stmts[idx + 1];\n-                    visitor.visit_stmt(next_stmt);\n-                    next_stmt_span = next_stmt.span;\n-                }\n-                drop(visitor);\n+                    return\n+                };\n \n                 if read_found && !next_stmt_span.from_expansion() {\n                     let applicability = Applicability::MaybeIncorrect;"}, {"sha": "2b2a41d160117a5f781cf7d389df8ad550e353d4", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=2be6c4ae5b075028a6c61ba75daaf22fb7921c85", "patch": "@@ -1,9 +1,11 @@\n use clippy_utils::diagnostics::{span_lint_and_then, span_lint_hir_and_then};\n use clippy_utils::source::{snippet_opt, snippet_with_context};\n+use clippy_utils::visitors::{for_each_expr, Descend};\n use clippy_utils::{fn_def_id, path_to_local_id};\n+use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{walk_expr, FnKind, Visitor};\n+use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Block, Body, Expr, ExprKind, FnDecl, HirId, MatchSource, PatKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n@@ -270,33 +272,20 @@ fn emit_return_lint(\n }\n \n fn last_statement_borrows<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-    let mut visitor = BorrowVisitor { cx, borrows: false };\n-    walk_expr(&mut visitor, expr);\n-    visitor.borrows\n-}\n-\n-struct BorrowVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    borrows: bool,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for BorrowVisitor<'_, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if self.borrows || expr.span.from_expansion() {\n-            return;\n-        }\n-\n-        if let Some(def_id) = fn_def_id(self.cx, expr) {\n-            self.borrows = self\n-                .cx\n+    for_each_expr(expr, |e| {\n+        if let Some(def_id) = fn_def_id(cx, e)\n+            && cx\n                 .tcx\n                 .fn_sig(def_id)\n-                .output()\n                 .skip_binder()\n+                .output()\n                 .walk()\n-                .any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)));\n+                .any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)))\n+        {\n+            ControlFlow::Break(())\n+        } else {\n+            ControlFlow::Continue(Descend::from(!expr.span.from_expansion()))\n         }\n-\n-        walk_expr(self, expr);\n-    }\n+    })\n+    .is_some()\n }"}, {"sha": "b57b484bdc897ed87aa85ae99daa1147153818c5", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=2be6c4ae5b075028a6c61ba75daaf22fb7921c85", "patch": "@@ -1,8 +1,9 @@\n use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::visitors::for_each_expr;\n use clippy_utils::{binop_traits, trait_ref_of_method, BINOP_TRAITS, OP_ASSIGN_TRAITS};\n+use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -92,25 +93,17 @@ impl<'tcx> LateLintPass<'tcx> for SuspiciousImpl {\n }\n \n fn count_binops(expr: &hir::Expr<'_>) -> u32 {\n-    let mut visitor = BinaryExprVisitor::default();\n-    visitor.visit_expr(expr);\n-    visitor.nb_binops\n-}\n-\n-#[derive(Default)]\n-struct BinaryExprVisitor {\n-    nb_binops: u32,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for BinaryExprVisitor {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        match expr.kind {\n+    let mut count = 0u32;\n+    let _: Option<!> = for_each_expr(expr, |e| {\n+        if matches!(\n+            e.kind,\n             hir::ExprKind::Binary(..)\n-            | hir::ExprKind::Unary(hir::UnOp::Not | hir::UnOp::Neg, _)\n-            | hir::ExprKind::AssignOp(..) => self.nb_binops += 1,\n-            _ => {},\n+                | hir::ExprKind::Unary(hir::UnOp::Not | hir::UnOp::Neg, _)\n+                | hir::ExprKind::AssignOp(..)\n+        ) {\n+            count += 1;\n         }\n-\n-        walk_expr(self, expr);\n-    }\n+        ControlFlow::Continue(())\n+    });\n+    count\n }"}, {"sha": "a69719b127b2fb04cc970d12356e83d1258dc687", "filename": "clippy_lints/src/unwrap_in_result.rs", "status": "modified", "additions": 29, "deletions": 43, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Funwrap_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_lints%2Fsrc%2Funwrap_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap_in_result.rs?ref=2be6c4ae5b075028a6c61ba75daaf22fb7921c85", "patch": "@@ -1,12 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::visitors::for_each_expr;\n use clippy_utils::{method_chain_args, return_ty};\n+use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::{Expr, ImplItemKind};\n+use rustc_hir::ImplItemKind;\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n \n@@ -73,59 +73,45 @@ impl<'tcx> LateLintPass<'tcx> for UnwrapInResult {\n     }\n }\n \n-struct FindExpectUnwrap<'a, 'tcx> {\n-    lcx: &'a LateContext<'tcx>,\n-    typeck_results: &'tcx ty::TypeckResults<'tcx>,\n-    result: Vec<Span>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for FindExpectUnwrap<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        // check for `expect`\n-        if let Some(arglists) = method_chain_args(expr, &[\"expect\"]) {\n-            let receiver_ty = self.typeck_results.expr_ty(arglists[0].0).peel_refs();\n-            if is_type_diagnostic_item(self.lcx, receiver_ty, sym::Option)\n-                || is_type_diagnostic_item(self.lcx, receiver_ty, sym::Result)\n-            {\n-                self.result.push(expr.span);\n+fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_item: &'tcx hir::ImplItem<'_>) {\n+    if let ImplItemKind::Fn(_, body_id) = impl_item.kind {\n+        let body = cx.tcx.hir().body(body_id);\n+        let typeck = cx.tcx.typeck(impl_item.def_id.def_id);\n+        let mut result = Vec::new();\n+        let _: Option<!> = for_each_expr(body.value, |e| {\n+            // check for `expect`\n+            if let Some(arglists) = method_chain_args(e, &[\"expect\"]) {\n+                let receiver_ty = typeck.expr_ty(arglists[0].0).peel_refs();\n+                if is_type_diagnostic_item(cx, receiver_ty, sym::Option)\n+                    || is_type_diagnostic_item(cx, receiver_ty, sym::Result)\n+                {\n+                    result.push(e.span);\n+                }\n             }\n-        }\n \n-        // check for `unwrap`\n-        if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n-            let receiver_ty = self.typeck_results.expr_ty(arglists[0].0).peel_refs();\n-            if is_type_diagnostic_item(self.lcx, receiver_ty, sym::Option)\n-                || is_type_diagnostic_item(self.lcx, receiver_ty, sym::Result)\n-            {\n-                self.result.push(expr.span);\n+            // check for `unwrap`\n+            if let Some(arglists) = method_chain_args(e, &[\"unwrap\"]) {\n+                let receiver_ty = typeck.expr_ty(arglists[0].0).peel_refs();\n+                if is_type_diagnostic_item(cx, receiver_ty, sym::Option)\n+                    || is_type_diagnostic_item(cx, receiver_ty, sym::Result)\n+                {\n+                    result.push(e.span);\n+                }\n             }\n-        }\n \n-        // and check sub-expressions\n-        intravisit::walk_expr(self, expr);\n-    }\n-}\n-\n-fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_item: &'tcx hir::ImplItem<'_>) {\n-    if let ImplItemKind::Fn(_, body_id) = impl_item.kind {\n-        let body = cx.tcx.hir().body(body_id);\n-        let mut fpu = FindExpectUnwrap {\n-            lcx: cx,\n-            typeck_results: cx.tcx.typeck(impl_item.def_id.def_id),\n-            result: Vec::new(),\n-        };\n-        fpu.visit_expr(body.value);\n+            ControlFlow::Continue(())\n+        });\n \n         // if we've found one, lint\n-        if !fpu.result.is_empty() {\n+        if !result.is_empty() {\n             span_lint_and_then(\n                 cx,\n                 UNWRAP_IN_RESULT,\n                 impl_span,\n                 \"used unwrap or expect in a function that returns result or option\",\n                 move |diag| {\n                     diag.help(\"unwrap and expect should not be used in a function that returns result or option\");\n-                    diag.span_note(fpu.result, \"potential non-recoverable error(s)\");\n+                    diag.span_note(result, \"potential non-recoverable error(s)\");\n                 },\n             );\n         }"}, {"sha": "3caa6380e0989eaa2ac39d5576f4241d1c5cdc74", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=2be6c4ae5b075028a6c61ba75daaf22fb7921c85", "patch": "@@ -3,6 +3,7 @@\n #![feature(control_flow_enum)]\n #![feature(let_chains)]\n #![feature(lint_reasons)]\n+#![feature(never_type)]\n #![feature(once_cell)]\n #![feature(rustc_private)]\n #![recursion_limit = \"512\"]\n@@ -65,6 +66,7 @@ pub use self::hir_utils::{\n     both, count_eq, eq_expr_value, hash_expr, hash_stmt, over, HirEqInterExpr, SpanlessEq, SpanlessHash,\n };\n \n+use core::ops::ControlFlow;\n use std::collections::hash_map::Entry;\n use std::hash::BuildHasherDefault;\n use std::sync::OnceLock;\n@@ -113,7 +115,7 @@ use rustc_target::abi::Integer;\n \n use crate::consts::{constant, Constant};\n use crate::ty::{can_partially_move_ty, expr_sig, is_copy, is_recursively_primitive_type, ty_is_fn_once_param};\n-use crate::visitors::expr_visitor_no_bodies;\n+use crate::visitors::for_each_expr;\n \n pub fn parse_msrv(msrv: &str, sess: Option<&Session>, span: Option<Span>) -> Option<RustcVersion> {\n     if let Ok(version) = RustcVersion::parse(msrv) {\n@@ -1193,17 +1195,14 @@ pub fn contains_name(name: Symbol, expr: &Expr<'_>) -> bool {\n \n /// Returns `true` if `expr` contains a return expression\n pub fn contains_return(expr: &hir::Expr<'_>) -> bool {\n-    let mut found = false;\n-    expr_visitor_no_bodies(|expr| {\n-        if !found {\n-            if let hir::ExprKind::Ret(..) = &expr.kind {\n-                found = true;\n-            }\n+    for_each_expr(expr, |e| {\n+        if matches!(e.kind, hir::ExprKind::Ret(..)) {\n+            ControlFlow::Break(())\n+        } else {\n+            ControlFlow::Continue(())\n         }\n-        !found\n     })\n-    .visit_expr(expr);\n-    found\n+    .is_some()\n }\n \n /// Extends the span to the beginning of the spans line, incl. whitespaces."}, {"sha": "dda21b903901f44707c87ebcae77a2e405a5a81a", "filename": "clippy_utils/src/macros.rs", "status": "modified", "additions": 35, "deletions": 46, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmacros.rs?ref=2be6c4ae5b075028a6c61ba75daaf22fb7921c85", "patch": "@@ -2,7 +2,7 @@\n \n use crate::is_path_diagnostic_item;\n use crate::source::snippet_opt;\n-use crate::visitors::expr_visitor_no_bodies;\n+use crate::visitors::{for_each_expr, Descend};\n \n use arrayvec::ArrayVec;\n use itertools::{izip, Either, Itertools};\n@@ -270,20 +270,19 @@ fn find_assert_args_inner<'a, const N: usize>(\n     };\n     let mut args = ArrayVec::new();\n     let mut panic_expn = None;\n-    expr_visitor_no_bodies(|e| {\n+    let _: Option<!> = for_each_expr(expr, |e| {\n         if args.is_full() {\n             if panic_expn.is_none() && e.span.ctxt() != expr.span.ctxt() {\n                 panic_expn = PanicExpn::parse(cx, e);\n             }\n-            panic_expn.is_none()\n+            ControlFlow::Continue(Descend::from(panic_expn.is_none()))\n         } else if is_assert_arg(cx, e, expn) {\n             args.push(e);\n-            false\n+            ControlFlow::Continue(Descend::No)\n         } else {\n-            true\n+            ControlFlow::Continue(Descend::Yes)\n         }\n-    })\n-    .visit_expr(expr);\n+    });\n     let args = args.into_inner().ok()?;\n     // if no `panic!(..)` is found, use `PanicExpn::Empty`\n     // to indicate that the default assertion message is used\n@@ -297,22 +296,19 @@ fn find_assert_within_debug_assert<'a>(\n     expn: ExpnId,\n     assert_name: Symbol,\n ) -> Option<(&'a Expr<'a>, ExpnId)> {\n-    let mut found = None;\n-    expr_visitor_no_bodies(|e| {\n-        if found.is_some() || !e.span.from_expansion() {\n-            return false;\n+    for_each_expr(expr, |e| {\n+        if !e.span.from_expansion() {\n+            return ControlFlow::Continue(Descend::No);\n         }\n         let e_expn = e.span.ctxt().outer_expn();\n         if e_expn == expn {\n-            return true;\n-        }\n-        if e_expn.expn_data().macro_def_id.map(|id| cx.tcx.item_name(id)) == Some(assert_name) {\n-            found = Some((e, e_expn));\n+            ControlFlow::Continue(Descend::Yes)\n+        } else if e_expn.expn_data().macro_def_id.map(|id| cx.tcx.item_name(id)) == Some(assert_name) {\n+            ControlFlow::Break((e, e_expn))\n+        } else {\n+            ControlFlow::Continue(Descend::No)\n         }\n-        false\n     })\n-    .visit_expr(expr);\n-    found\n }\n \n fn is_assert_arg(cx: &LateContext<'_>, expr: &Expr<'_>, assert_expn: ExpnId) -> bool {\n@@ -396,16 +392,14 @@ impl FormatString {\n         });\n \n         let mut parts = Vec::new();\n-        expr_visitor_no_bodies(|expr| {\n-            if let ExprKind::Lit(lit) = &expr.kind {\n-                if let LitKind::Str(symbol, _) = lit.node {\n-                    parts.push(symbol);\n-                }\n+        let _: Option<!> = for_each_expr(pieces, |expr| {\n+            if let ExprKind::Lit(lit) = &expr.kind\n+                && let LitKind::Str(symbol, _) = lit.node\n+            {\n+                parts.push(symbol);\n             }\n-\n-            true\n-        })\n-        .visit_expr(pieces);\n+            ControlFlow::Continue(())\n+        });\n \n         Some(Self {\n             span,\n@@ -431,7 +425,7 @@ impl<'tcx> FormatArgsValues<'tcx> {\n     fn new(args: &'tcx Expr<'tcx>, format_string_span: SpanData) -> Self {\n         let mut pos_to_value_index = Vec::new();\n         let mut value_args = Vec::new();\n-        expr_visitor_no_bodies(|expr| {\n+        let _: Option<!> = for_each_expr(args, |expr| {\n             if expr.span.ctxt() == args.span.ctxt() {\n                 // ArgumentV1::new_<format_trait>(<val>)\n                 // ArgumentV1::from_usize(<val>)\n@@ -453,16 +447,13 @@ impl<'tcx> FormatArgsValues<'tcx> {\n \n                     pos_to_value_index.push(val_idx);\n                 }\n-\n-                true\n+                ControlFlow::Continue(Descend::Yes)\n             } else {\n                 // assume that any expr with a differing span is a value\n                 value_args.push(expr);\n-\n-                false\n+                ControlFlow::Continue(Descend::No)\n             }\n-        })\n-        .visit_expr(args);\n+        });\n \n         Self {\n             value_args,\n@@ -866,22 +857,20 @@ impl<'tcx> FormatArgsExpn<'tcx> {\n     }\n \n     pub fn find_nested(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, expn_id: ExpnId) -> Option<Self> {\n-        let mut format_args = None;\n-        expr_visitor_no_bodies(|e| {\n-            if format_args.is_some() {\n-                return false;\n-            }\n+        for_each_expr(expr, |e| {\n             let e_ctxt = e.span.ctxt();\n             if e_ctxt == expr.span.ctxt() {\n-                return true;\n-            }\n-            if e_ctxt.outer_expn().is_descendant_of(expn_id) {\n-                format_args = FormatArgsExpn::parse(cx, e);\n+                ControlFlow::Continue(Descend::Yes)\n+            } else if e_ctxt.outer_expn().is_descendant_of(expn_id) {\n+                if let Some(args) = FormatArgsExpn::parse(cx, e) {\n+                    ControlFlow::Break(args)\n+                } else {\n+                    ControlFlow::Continue(Descend::No)\n+                }\n+            } else {\n+                ControlFlow::Continue(Descend::No)\n             }\n-            false\n         })\n-        .visit_expr(expr);\n-        format_args\n     }\n \n     /// Source callsite span of all inputs"}, {"sha": "88837d8a143eddf15d7472ae89321195667ddb3e", "filename": "clippy_utils/src/ptr.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_utils%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_utils%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fptr.rs?ref=2be6c4ae5b075028a6c61ba75daaf22fb7921c85", "patch": "@@ -1,7 +1,7 @@\n use crate::source::snippet;\n-use crate::visitors::expr_visitor_no_bodies;\n+use crate::visitors::{for_each_expr, Descend};\n use crate::{path_to_local_id, strip_pat_refs};\n-use rustc_hir::intravisit::Visitor;\n+use core::ops::ControlFlow;\n use rustc_hir::{Body, BodyId, ExprKind, HirId, PatKind};\n use rustc_lint::LateContext;\n use rustc_span::Span;\n@@ -30,28 +30,23 @@ fn extract_clone_suggestions<'tcx>(\n     replace: &[(&'static str, &'static str)],\n     body: &'tcx Body<'_>,\n ) -> Option<Vec<(Span, Cow<'static, str>)>> {\n-    let mut abort = false;\n     let mut spans = Vec::new();\n-    expr_visitor_no_bodies(|expr| {\n-        if abort {\n-            return false;\n-        }\n-        if let ExprKind::MethodCall(seg, recv, [], _) = expr.kind {\n-            if path_to_local_id(recv, id) {\n-                if seg.ident.name.as_str() == \"capacity\" {\n-                    abort = true;\n-                    return false;\n-                }\n-                for &(fn_name, suffix) in replace {\n-                    if seg.ident.name.as_str() == fn_name {\n-                        spans.push((expr.span, snippet(cx, recv.span, \"_\") + suffix));\n-                        return false;\n-                    }\n+    for_each_expr(body, |e| {\n+        if let ExprKind::MethodCall(seg, recv, [], _) = e.kind\n+            && path_to_local_id(recv, id)\n+        {\n+            if seg.ident.as_str() == \"capacity\" {\n+                return ControlFlow::Break(());\n+            }\n+            for &(fn_name, suffix) in replace {\n+                if seg.ident.as_str() == fn_name {\n+                    spans.push((e.span, snippet(cx, recv.span, \"_\") + suffix));\n+                    return ControlFlow::Continue(Descend::No);\n                 }\n             }\n         }\n-        !abort\n+        ControlFlow::Continue(Descend::Yes)\n     })\n-    .visit_body(body);\n-    if abort { None } else { Some(spans) }\n+    .is_none()\n+    .then_some(spans)\n }"}, {"sha": "b5ec3fef3e0b4b8f52867371e7088a0d7ef7ad8b", "filename": "clippy_utils/src/usage.rs", "status": "modified", "additions": 16, "deletions": 33, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_utils%2Fsrc%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_utils%2Fsrc%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fusage.rs?ref=2be6c4ae5b075028a6c61ba75daaf22fb7921c85", "patch": "@@ -1,5 +1,6 @@\n use crate as utils;\n-use crate::visitors::{expr_visitor, expr_visitor_no_bodies};\n+use crate::visitors::{for_each_expr, for_each_expr_with_closures, Descend};\n+use core::ops::ControlFlow;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::HirIdSet;\n@@ -148,28 +149,17 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for BindingUsageFinder<'a, 'tcx> {\n }\n \n pub fn contains_return_break_continue_macro(expression: &Expr<'_>) -> bool {\n-    let mut seen_return_break_continue = false;\n-    expr_visitor_no_bodies(|ex| {\n-        if seen_return_break_continue {\n-            return false;\n-        }\n-        match &ex.kind {\n-            ExprKind::Ret(..) | ExprKind::Break(..) | ExprKind::Continue(..) => {\n-                seen_return_break_continue = true;\n-            },\n+    for_each_expr(expression, |e| {\n+        match e.kind {\n+            ExprKind::Ret(..) | ExprKind::Break(..) | ExprKind::Continue(..) => ControlFlow::Break(()),\n             // Something special could be done here to handle while or for loop\n             // desugaring, as this will detect a break if there's a while loop\n             // or a for loop inside the expression.\n-            _ => {\n-                if ex.span.from_expansion() {\n-                    seen_return_break_continue = true;\n-                }\n-            },\n+            _ if e.span.from_expansion() => ControlFlow::Break(()),\n+            _ => ControlFlow::Continue(()),\n         }\n-        !seen_return_break_continue\n     })\n-    .visit_expr(expression);\n-    seen_return_break_continue\n+    .is_some()\n }\n \n pub fn local_used_after_expr(cx: &LateContext<'_>, local_id: HirId, after: &Expr<'_>) -> bool {\n@@ -200,23 +190,16 @@ pub fn local_used_after_expr(cx: &LateContext<'_>, local_id: HirId, after: &Expr\n         return true;\n     }\n \n-    let mut used_after_expr = false;\n     let mut past_expr = false;\n-    expr_visitor(cx, |expr| {\n-        if used_after_expr {\n-            return false;\n-        }\n-\n-        if expr.hir_id == after.hir_id {\n+    for_each_expr_with_closures(cx, block, |e| {\n+        if e.hir_id == after.hir_id {\n             past_expr = true;\n-            return false;\n-        }\n-\n-        if past_expr && utils::path_to_local_id(expr, local_id) {\n-            used_after_expr = true;\n+            ControlFlow::Continue(Descend::No)\n+        } else if past_expr && utils::path_to_local_id(e, local_id) {\n+            ControlFlow::Break(())\n+        } else {\n+            ControlFlow::Continue(Descend::Yes)\n         }\n-        !used_after_expr\n     })\n-    .visit_block(block);\n-    used_after_expr\n+    .is_some()\n }"}, {"sha": "d4294f18fd5019c0eed128e9321f8caca80b0109", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 75, "deletions": 89, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be6c4ae5b075028a6c61ba75daaf22fb7921c85/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=2be6c4ae5b075028a6c61ba75daaf22fb7921c85", "patch": "@@ -5,14 +5,13 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::intravisit::{self, walk_block, walk_expr, Visitor};\n use rustc_hir::{\n-    Arm, Block, BlockCheckMode, Body, BodyId, Expr, ExprKind, HirId, ItemId, ItemKind, Let, Pat, QPath, Stmt, UnOp,\n-    UnsafeSource, Unsafety,\n+    AnonConst, Arm, Block, BlockCheckMode, Body, BodyId, Expr, ExprKind, HirId, ItemId, ItemKind, Let, Pat, QPath,\n+    Stmt, UnOp, UnsafeSource, Unsafety,\n };\n use rustc_lint::LateContext;\n-use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::adjustment::Adjust;\n-use rustc_middle::ty::{self, Ty, TypeckResults};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeckResults};\n use rustc_span::Span;\n \n mod internal {\n@@ -48,6 +47,26 @@ impl Continue for Descend {\n     }\n }\n \n+/// A type which can be visited.\n+pub trait Visitable<'tcx> {\n+    /// Calls the corresponding `visit_*` function on the visitor.\n+    fn visit<V: Visitor<'tcx>>(self, visitor: &mut V);\n+}\n+macro_rules! visitable_ref {\n+    ($t:ident, $f:ident) => {\n+        impl<'tcx> Visitable<'tcx> for &'tcx $t<'tcx> {\n+            fn visit<V: Visitor<'tcx>>(self, visitor: &mut V) {\n+                visitor.$f(self);\n+            }\n+        }\n+    };\n+}\n+visitable_ref!(Arm, visit_arm);\n+visitable_ref!(Block, visit_block);\n+visitable_ref!(Body, visit_body);\n+visitable_ref!(Expr, visit_expr);\n+visitable_ref!(Stmt, visit_stmt);\n+\n /// Calls the given function once for each expression contained. This does not enter any bodies or\n /// nested items.\n pub fn for_each_expr<'tcx, B, C: Continue>(\n@@ -82,57 +101,63 @@ pub fn for_each_expr<'tcx, B, C: Continue>(\n     v.res\n }\n \n-/// Convenience method for creating a `Visitor` with just `visit_expr` overridden and nested\n-/// bodies (i.e. closures) are visited.\n-/// If the callback returns `true`, the expr just provided to the callback is walked.\n-#[must_use]\n-pub fn expr_visitor<'tcx>(cx: &LateContext<'tcx>, f: impl FnMut(&'tcx Expr<'tcx>) -> bool) -> impl Visitor<'tcx> {\n-    struct V<'tcx, F> {\n-        hir: Map<'tcx>,\n+/// Calls the given function once for each expression contained. This will enter bodies, but not\n+/// nested items.\n+pub fn for_each_expr_with_closures<'tcx, B, C: Continue>(\n+    cx: &LateContext<'tcx>,\n+    node: impl Visitable<'tcx>,\n+    f: impl FnMut(&'tcx Expr<'tcx>) -> ControlFlow<B, C>,\n+) -> Option<B> {\n+    struct V<'tcx, B, F> {\n+        tcx: TyCtxt<'tcx>,\n         f: F,\n+        res: Option<B>,\n     }\n-    impl<'tcx, F: FnMut(&'tcx Expr<'tcx>) -> bool> Visitor<'tcx> for V<'tcx, F> {\n+    impl<'tcx, B, C: Continue, F: FnMut(&'tcx Expr<'tcx>) -> ControlFlow<B, C>> Visitor<'tcx> for V<'tcx, B, F> {\n         type NestedFilter = nested_filter::OnlyBodies;\n         fn nested_visit_map(&mut self) -> Self::Map {\n-            self.hir\n+            self.tcx.hir()\n         }\n \n-        fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-            if (self.f)(expr) {\n-                walk_expr(self, expr);\n+        fn visit_expr(&mut self, e: &'tcx Expr<'tcx>) {\n+            if self.res.is_some() {\n+                return;\n             }\n-        }\n-    }\n-    V { hir: cx.tcx.hir(), f }\n-}\n-\n-/// Convenience method for creating a `Visitor` with just `visit_expr` overridden and nested\n-/// bodies (i.e. closures) are not visited.\n-/// If the callback returns `true`, the expr just provided to the callback is walked.\n-#[must_use]\n-pub fn expr_visitor_no_bodies<'tcx>(f: impl FnMut(&'tcx Expr<'tcx>) -> bool) -> impl Visitor<'tcx> {\n-    struct V<F>(F);\n-    impl<'tcx, F: FnMut(&'tcx Expr<'tcx>) -> bool> Visitor<'tcx> for V<F> {\n-        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n-            if (self.0)(e) {\n-                walk_expr(self, e);\n+            match (self.f)(e) {\n+                ControlFlow::Continue(c) if c.descend() => walk_expr(self, e),\n+                ControlFlow::Break(b) => self.res = Some(b),\n+                ControlFlow::Continue(_) => (),\n             }\n         }\n+\n+        // Only walk closures\n+        fn visit_anon_const(&mut self, _: &'tcx AnonConst) {}\n+        // Avoid unnecessary `walk_*` calls.\n+        fn visit_ty(&mut self, _: &'tcx hir::Ty<'tcx>) {}\n+        fn visit_pat(&mut self, _: &'tcx Pat<'tcx>) {}\n+        fn visit_qpath(&mut self, _: &'tcx QPath<'tcx>, _: HirId, _: Span) {}\n+        // Avoid monomorphising all `visit_*` functions.\n+        fn visit_nested_item(&mut self, _: ItemId) {}\n     }\n-    V(f)\n+    let mut v = V {\n+        tcx: cx.tcx,\n+        f,\n+        res: None,\n+    };\n+    node.visit(&mut v);\n+    v.res\n }\n \n /// returns `true` if expr contains match expr desugared from try\n fn contains_try(expr: &hir::Expr<'_>) -> bool {\n-    let mut found = false;\n-    expr_visitor_no_bodies(|e| {\n-        if !found {\n-            found = matches!(e.kind, hir::ExprKind::Match(_, _, hir::MatchSource::TryDesugar));\n+    for_each_expr(expr, |e| {\n+        if matches!(e.kind, hir::ExprKind::Match(_, _, hir::MatchSource::TryDesugar)) {\n+            ControlFlow::Break(())\n+        } else {\n+            ControlFlow::Continue(())\n         }\n-        !found\n     })\n-    .visit_expr(expr);\n-    found\n+    .is_some()\n }\n \n pub fn find_all_ret_expressions<'hir, F>(_cx: &LateContext<'_>, expr: &'hir hir::Expr<'hir>, callback: F) -> bool\n@@ -228,68 +253,29 @@ where\n     }\n }\n \n-/// A type which can be visited.\n-pub trait Visitable<'tcx> {\n-    /// Calls the corresponding `visit_*` function on the visitor.\n-    fn visit<V: Visitor<'tcx>>(self, visitor: &mut V);\n-}\n-macro_rules! visitable_ref {\n-    ($t:ident, $f:ident) => {\n-        impl<'tcx> Visitable<'tcx> for &'tcx $t<'tcx> {\n-            fn visit<V: Visitor<'tcx>>(self, visitor: &mut V) {\n-                visitor.$f(self);\n-            }\n-        }\n-    };\n-}\n-visitable_ref!(Arm, visit_arm);\n-visitable_ref!(Block, visit_block);\n-visitable_ref!(Body, visit_body);\n-visitable_ref!(Expr, visit_expr);\n-visitable_ref!(Stmt, visit_stmt);\n-\n-// impl<'tcx, I: IntoIterator> Visitable<'tcx> for I\n-// where\n-//     I::Item: Visitable<'tcx>,\n-// {\n-//     fn visit<V: Visitor<'tcx>>(self, visitor: &mut V) {\n-//         for x in self {\n-//             x.visit(visitor);\n-//         }\n-//     }\n-// }\n-\n /// Checks if the given resolved path is used in the given body.\n pub fn is_res_used(cx: &LateContext<'_>, res: Res, body: BodyId) -> bool {\n-    let mut found = false;\n-    expr_visitor(cx, |e| {\n-        if found {\n-            return false;\n-        }\n-\n+    for_each_expr_with_closures(cx, cx.tcx.hir().body(body).value, |e| {\n         if let ExprKind::Path(p) = &e.kind {\n             if cx.qpath_res(p, e.hir_id) == res {\n-                found = true;\n+                return ControlFlow::Break(());\n             }\n         }\n-        !found\n+        ControlFlow::Continue(())\n     })\n-    .visit_expr(cx.tcx.hir().body(body).value);\n-    found\n+    .is_some()\n }\n \n /// Checks if the given local is used.\n pub fn is_local_used<'tcx>(cx: &LateContext<'tcx>, visitable: impl Visitable<'tcx>, id: HirId) -> bool {\n-    let mut is_used = false;\n-    let mut visitor = expr_visitor(cx, |expr| {\n-        if !is_used {\n-            is_used = path_to_local_id(expr, id);\n+    for_each_expr_with_closures(cx, visitable, |e| {\n+        if path_to_local_id(e, id) {\n+            ControlFlow::Break(())\n+        } else {\n+            ControlFlow::Continue(())\n         }\n-        !is_used\n-    });\n-    visitable.visit(&mut visitor);\n-    drop(visitor);\n-    is_used\n+    })\n+    .is_some()\n }\n \n /// Checks if the given expression is a constant."}]}