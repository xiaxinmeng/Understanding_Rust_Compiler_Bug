{"sha": "7628cada4f56676c361730251841e65600d863fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2MjhjYWRhNGY1NjY3NmMzNjE3MzAyNTE4NDFlNjU2MDBkODYzZmU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-01T21:56:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-01T21:56:23Z"}, "message": "Rollup merge of #64912 - lzutao:unneeded-main-doc, r=jonas-schievink\n\nRemove unneeded `fn main` blocks from docs\n\n## [No whitespace diff](https://github.com/rust-lang/rust/pull/64912/files?w=1)", "tree": {"sha": "1bc24a00dc687139d6c6c2b2df1d155e2294a1fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bc24a00dc687139d6c6c2b2df1d155e2294a1fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7628cada4f56676c361730251841e65600d863fe", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdk8uHCRBK7hj4Ov3rIwAAdHIIAHwLlaDec+hLZjDlAvxfSXVx\n+ZhxUsW9Fyx0LkLvODRvWe7l/71aPsxXDf7IZacRlLka+CqCRpF2WEbyBgZm5lIH\nUWwDH0jZEb6FuFSvXm0pVjdUP1utEbITGQKdE34A3e2WWg930r3r1ShbGdHDiZhe\nxfwnlpHytRWgUYBMvdvG0dk9LCXkv5S+a9x+vvGcn7gHuEgwo6FTxpJRQ8PCaSGG\n5SguGBOa/pb6eGaQDAoBYHOYEqxDfB68FuiD7fHbKHx7et8YypyLyoQPJ1d9Xmy1\nShX1ATaW239kXh7uGZoJxyNZu9AZ3PsNjaL9IRFuzaeBV1Lwtmppa2D4yXJRxPA=\n=CiqF\n-----END PGP SIGNATURE-----\n", "payload": "tree 1bc24a00dc687139d6c6c2b2df1d155e2294a1fd\nparent db9689333a2b52af4dffde750e7055cf6badb576\nparent 6c1b447f2e67f5eae89394344ade698aca3ec7e6\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1569966983 +0200\ncommitter GitHub <noreply@github.com> 1569966983 +0200\n\nRollup merge of #64912 - lzutao:unneeded-main-doc, r=jonas-schievink\n\nRemove unneeded `fn main` blocks from docs\n\n## [No whitespace diff](https://github.com/rust-lang/rust/pull/64912/files?w=1)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7628cada4f56676c361730251841e65600d863fe", "html_url": "https://github.com/rust-lang/rust/commit/7628cada4f56676c361730251841e65600d863fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7628cada4f56676c361730251841e65600d863fe/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db9689333a2b52af4dffde750e7055cf6badb576", "url": "https://api.github.com/repos/rust-lang/rust/commits/db9689333a2b52af4dffde750e7055cf6badb576", "html_url": "https://github.com/rust-lang/rust/commit/db9689333a2b52af4dffde750e7055cf6badb576"}, {"sha": "6c1b447f2e67f5eae89394344ade698aca3ec7e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c1b447f2e67f5eae89394344ade698aca3ec7e6", "html_url": "https://github.com/rust-lang/rust/commit/6c1b447f2e67f5eae89394344ade698aca3ec7e6"}], "stats": {"total": 638, "additions": 266, "deletions": 372}, "files": [{"sha": "b2789a535fe498827bd78573e1fdf20d3b34efc3", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 21, "deletions": 33, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7628cada4f56676c361730251841e65600d863fe/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7628cada4f56676c361730251841e65600d863fe/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=7628cada4f56676c361730251841e65600d863fe", "patch": "@@ -29,10 +29,8 @@\n //!     Nil,\n //! }\n //!\n-//! fn main() {\n-//!     let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));\n-//!     println!(\"{:?}\", list);\n-//! }\n+//! let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));\n+//! println!(\"{:?}\", list);\n //! ```\n //!\n //! This will print `Cons(1, Cons(2, Nil))`.\n@@ -375,14 +373,12 @@ impl<T: ?Sized> Box<T> {\n     /// ```\n     /// #![feature(box_into_raw_non_null)]\n     ///\n-    /// fn main() {\n-    ///     let x = Box::new(5);\n-    ///     let ptr = Box::into_raw_non_null(x);\n+    /// let x = Box::new(5);\n+    /// let ptr = Box::into_raw_non_null(x);\n     ///\n-    ///     // Clean up the memory by converting the NonNull pointer back\n-    ///     // into a Box and letting the Box be dropped.\n-    ///     let x = unsafe { Box::from_raw(ptr.as_ptr()) };\n-    /// }\n+    /// // Clean up the memory by converting the NonNull pointer back\n+    /// // into a Box and letting the Box be dropped.\n+    /// let x = unsafe { Box::from_raw(ptr.as_ptr()) };\n     /// ```\n     #[unstable(feature = \"box_into_raw_non_null\", issue = \"47336\")]\n     #[inline]\n@@ -428,23 +424,19 @@ impl<T: ?Sized> Box<T> {\n     /// Simple usage:\n     ///\n     /// ```\n-    /// fn main() {\n-    ///     let x = Box::new(41);\n-    ///     let static_ref: &'static mut usize = Box::leak(x);\n-    ///     *static_ref += 1;\n-    ///     assert_eq!(*static_ref, 42);\n-    /// }\n+    /// let x = Box::new(41);\n+    /// let static_ref: &'static mut usize = Box::leak(x);\n+    /// *static_ref += 1;\n+    /// assert_eq!(*static_ref, 42);\n     /// ```\n     ///\n     /// Unsized data:\n     ///\n     /// ```\n-    /// fn main() {\n-    ///     let x = vec![1, 2, 3].into_boxed_slice();\n-    ///     let static_ref = Box::leak(x);\n-    ///     static_ref[0] = 4;\n-    ///     assert_eq!(*static_ref, [4, 2, 3]);\n-    /// }\n+    /// let x = vec![1, 2, 3].into_boxed_slice();\n+    /// let static_ref = Box::leak(x);\n+    /// static_ref[0] = 4;\n+    /// assert_eq!(*static_ref, [4, 2, 3]);\n     /// ```\n     #[stable(feature = \"box_leak\", since = \"1.26.0\")]\n     #[inline]\n@@ -780,11 +772,9 @@ impl Box<dyn Any> {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     let my_string = \"Hello World\".to_string();\n-    ///     print_if_string(Box::new(my_string));\n-    ///     print_if_string(Box::new(0i8));\n-    /// }\n+    /// let my_string = \"Hello World\".to_string();\n+    /// print_if_string(Box::new(my_string));\n+    /// print_if_string(Box::new(0i8));\n     /// ```\n     pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<dyn Any>> {\n         if self.is::<T>() {\n@@ -814,11 +804,9 @@ impl Box<dyn Any + Send> {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     let my_string = \"Hello World\".to_string();\n-    ///     print_if_string(Box::new(my_string));\n-    ///     print_if_string(Box::new(0i8));\n-    /// }\n+    /// let my_string = \"Hello World\".to_string();\n+    /// print_if_string(Box::new(my_string));\n+    /// print_if_string(Box::new(0i8));\n     /// ```\n     pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<dyn Any + Send>> {\n         <Box<dyn Any>>::downcast(self).map_err(|s| unsafe {"}, {"sha": "83fd4485f7321dbc6e15693d78fa8ac04f7e4ff8", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7628cada4f56676c361730251841e65600d863fe/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7628cada4f56676c361730251841e65600d863fe/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=7628cada4f56676c361730251841e65600d863fe", "patch": "@@ -2226,14 +2226,12 @@ impl<'a, K: Ord, V: Default> Entry<'a, K, V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # fn main() {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map: BTreeMap<&str, Option<usize>> = BTreeMap::new();\n     /// map.entry(\"poneyland\").or_default();\n     ///\n     /// assert_eq!(map[\"poneyland\"], None);\n-    /// # }\n     /// ```\n     pub fn or_default(self) -> &'a mut V {\n         match self {"}, {"sha": "a28c6d22abb9537ddf6f97357748978dc67bca35", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7628cada4f56676c361730251841e65600d863fe/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7628cada4f56676c361730251841e65600d863fe/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=7628cada4f56676c361730251841e65600d863fe", "patch": "@@ -861,11 +861,9 @@ impl Rc<dyn Any> {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     let my_string = \"Hello World\".to_string();\n-    ///     print_if_string(Rc::new(my_string));\n-    ///     print_if_string(Rc::new(0i8));\n-    /// }\n+    /// let my_string = \"Hello World\".to_string();\n+    /// print_if_string(Rc::new(my_string));\n+    /// print_if_string(Rc::new(0i8));\n     /// ```\n     pub fn downcast<T: Any>(self) -> Result<Rc<T>, Rc<dyn Any>> {\n         if (*self).is::<T>() {"}, {"sha": "4e4a285c21dab65eadc6914768f8fb2518f82bae", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7628cada4f56676c361730251841e65600d863fe/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7628cada4f56676c361730251841e65600d863fe/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=7628cada4f56676c361730251841e65600d863fe", "patch": "@@ -412,20 +412,15 @@ impl<T> [T] {\n     ///\n     /// ```\n     /// #![feature(repeat_generic_slice)]\n-    ///\n-    /// fn main() {\n-    ///     assert_eq!([1, 2].repeat(3), vec![1, 2, 1, 2, 1, 2]);\n-    /// }\n+    /// assert_eq!([1, 2].repeat(3), vec![1, 2, 1, 2, 1, 2]);\n     /// ```\n     ///\n     /// A panic upon overflow:\n     ///\n     /// ```should_panic\n     /// #![feature(repeat_generic_slice)]\n-    /// fn main() {\n-    ///     // this will panic at runtime\n-    ///     b\"0123456789abcdef\".repeat(usize::max_value());\n-    /// }\n+    /// // this will panic at runtime\n+    /// b\"0123456789abcdef\".repeat(usize::max_value());\n     /// ```\n     #[unstable(feature = \"repeat_generic_slice\",\n                reason = \"it's on str, why not on slice?\","}, {"sha": "9231c2d3f1d56e40546f002128b3cd412bd08243", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7628cada4f56676c361730251841e65600d863fe/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7628cada4f56676c361730251841e65600d863fe/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=7628cada4f56676c361730251841e65600d863fe", "patch": "@@ -500,10 +500,8 @@ impl str {\n     /// A panic upon overflow:\n     ///\n     /// ```should_panic\n-    /// fn main() {\n-    ///     // this will panic at runtime\n-    ///     \"0123456789abcdef\".repeat(usize::max_value());\n-    /// }\n+    /// // this will panic at runtime\n+    /// \"0123456789abcdef\".repeat(usize::max_value());\n     /// ```\n     #[stable(feature = \"repeat_str\", since = \"1.16.0\")]\n     pub fn repeat(&self, n: usize) -> String {"}, {"sha": "639124e26cc20e80ae8f873943f28035fd6a65ef", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7628cada4f56676c361730251841e65600d863fe/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7628cada4f56676c361730251841e65600d863fe/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=7628cada4f56676c361730251841e65600d863fe", "patch": "@@ -164,10 +164,8 @@ use crate::vec::Vec;\n ///\n /// fn example_func<A: TraitExample>(example_arg: A) {}\n ///\n-/// fn main() {\n-///     let example_string = String::from(\"example_string\");\n-///     example_func(&example_string);\n-/// }\n+/// let example_string = String::from(\"example_string\");\n+/// example_func(&example_string);\n /// ```\n ///\n /// There are two options that would work instead. The first would be to"}, {"sha": "5977e69b7fa0f297125b1ecab3e81374505dd4ce", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7628cada4f56676c361730251841e65600d863fe/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7628cada4f56676c361730251841e65600d863fe/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=7628cada4f56676c361730251841e65600d863fe", "patch": "@@ -1244,11 +1244,9 @@ impl Arc<dyn Any + Send + Sync> {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     let my_string = \"Hello World\".to_string();\n-    ///     print_if_string(Arc::new(my_string));\n-    ///     print_if_string(Arc::new(0i8));\n-    /// }\n+    /// let my_string = \"Hello World\".to_string();\n+    /// print_if_string(Arc::new(my_string));\n+    /// print_if_string(Arc::new(0i8));\n     /// ```\n     pub fn downcast<T>(self) -> Result<Arc<T>, Self>\n     where"}, {"sha": "6350b189c5faa47294fafd8193ced9a7d81802d0", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7628cada4f56676c361730251841e65600d863fe/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7628cada4f56676c361730251841e65600d863fe/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=7628cada4f56676c361730251841e65600d863fe", "patch": "@@ -389,28 +389,26 @@ impl<T> Vec<T> {\n     /// use std::ptr;\n     /// use std::mem;\n     ///\n-    /// fn main() {\n-    ///     let mut v = vec![1, 2, 3];\n-    ///\n-    ///     // Pull out the various important pieces of information about `v`\n-    ///     let p = v.as_mut_ptr();\n-    ///     let len = v.len();\n-    ///     let cap = v.capacity();\n+    /// let mut v = vec![1, 2, 3];\n     ///\n-    ///     unsafe {\n-    ///         // Cast `v` into the void: no destructor run, so we are in\n-    ///         // complete control of the allocation to which `p` points.\n-    ///         mem::forget(v);\n+    /// // Pull out the various important pieces of information about `v`\n+    /// let p = v.as_mut_ptr();\n+    /// let len = v.len();\n+    /// let cap = v.capacity();\n     ///\n-    ///         // Overwrite memory with 4, 5, 6\n-    ///         for i in 0..len as isize {\n-    ///             ptr::write(p.offset(i), 4 + i);\n-    ///         }\n+    /// unsafe {\n+    ///     // Cast `v` into the void: no destructor run, so we are in\n+    ///     // complete control of the allocation to which `p` points.\n+    ///     mem::forget(v);\n     ///\n-    ///         // Put everything back together into a Vec\n-    ///         let rebuilt = Vec::from_raw_parts(p, len, cap);\n-    ///         assert_eq!(rebuilt, [4, 5, 6]);\n+    ///     // Overwrite memory with 4, 5, 6\n+    ///     for i in 0..len as isize {\n+    ///         ptr::write(p.offset(i), 4 + i);\n     ///     }\n+    ///\n+    ///     // Put everything back together into a Vec\n+    ///     let rebuilt = Vec::from_raw_parts(p, len, cap);\n+    ///     assert_eq!(rebuilt, [4, 5, 6]);\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1391,12 +1389,10 @@ impl<T> Vec<T> {\n     /// ```\n     /// #![feature(vec_leak)]\n     ///\n-    /// fn main() {\n-    ///     let x = vec![1, 2, 3];\n-    ///     let static_ref: &'static mut [usize] = Vec::leak(x);\n-    ///     static_ref[0] += 1;\n-    ///     assert_eq!(static_ref, &[2, 2, 3]);\n-    /// }\n+    /// let x = vec![1, 2, 3];\n+    /// let static_ref: &'static mut [usize] = Vec::leak(x);\n+    /// static_ref[0] += 1;\n+    /// assert_eq!(static_ref, &[2, 2, 3]);\n     /// ```\n     #[unstable(feature = \"vec_leak\", issue = \"62195\")]\n     #[inline]"}, {"sha": "85b59162620fab9791541adcc7ef63c8f82c12bb", "filename": "src/libcore/any.rs", "status": "modified", "additions": 34, "deletions": 56, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/7628cada4f56676c361730251841e65600d863fe/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7628cada4f56676c361730251841e65600d863fe/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=7628cada4f56676c361730251841e65600d863fe", "patch": "@@ -87,10 +87,8 @@ pub trait Any: 'static {\n     ///     TypeId::of::<String>() == s.type_id()\n     /// }\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(is_string(&0), false);\n-    ///     assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n-    /// }\n+    /// assert_eq!(is_string(&0), false);\n+    /// assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n     /// ```\n     #[stable(feature = \"get_type_id\", since = \"1.34.0\")]\n     fn type_id(&self) -> TypeId;\n@@ -145,10 +143,8 @@ impl dyn Any {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     is_string(&0);\n-    ///     is_string(&\"cookie monster\".to_string());\n-    /// }\n+    /// is_string(&0);\n+    /// is_string(&\"cookie monster\".to_string());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -179,10 +175,8 @@ impl dyn Any {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     print_if_string(&0);\n-    ///     print_if_string(&\"cookie monster\".to_string());\n-    /// }\n+    /// print_if_string(&0);\n+    /// print_if_string(&\"cookie monster\".to_string());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -210,16 +204,14 @@ impl dyn Any {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     let mut x = 10u32;\n-    ///     let mut s = \"starlord\".to_string();\n+    /// let mut x = 10u32;\n+    /// let mut s = \"starlord\".to_string();\n     ///\n-    ///     modify_if_u32(&mut x);\n-    ///     modify_if_u32(&mut s);\n+    /// modify_if_u32(&mut x);\n+    /// modify_if_u32(&mut s);\n     ///\n-    ///     assert_eq!(x, 42);\n-    ///     assert_eq!(&s, \"starlord\");\n-    /// }\n+    /// assert_eq!(x, 42);\n+    /// assert_eq!(&s, \"starlord\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -250,10 +242,8 @@ impl dyn Any+Send {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     is_string(&0);\n-    ///     is_string(&\"cookie monster\".to_string());\n-    /// }\n+    /// is_string(&0);\n+    /// is_string(&\"cookie monster\".to_string());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -276,10 +266,8 @@ impl dyn Any+Send {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     print_if_string(&0);\n-    ///     print_if_string(&\"cookie monster\".to_string());\n-    /// }\n+    /// print_if_string(&0);\n+    /// print_if_string(&\"cookie monster\".to_string());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -300,16 +288,14 @@ impl dyn Any+Send {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     let mut x = 10u32;\n-    ///     let mut s = \"starlord\".to_string();\n+    /// let mut x = 10u32;\n+    /// let mut s = \"starlord\".to_string();\n     ///\n-    ///     modify_if_u32(&mut x);\n-    ///     modify_if_u32(&mut s);\n+    /// modify_if_u32(&mut x);\n+    /// modify_if_u32(&mut s);\n     ///\n-    ///     assert_eq!(x, 42);\n-    ///     assert_eq!(&s, \"starlord\");\n-    /// }\n+    /// assert_eq!(x, 42);\n+    /// assert_eq!(&s, \"starlord\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -334,10 +320,8 @@ impl dyn Any+Send+Sync {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     is_string(&0);\n-    ///     is_string(&\"cookie monster\".to_string());\n-    /// }\n+    /// is_string(&0);\n+    /// is_string(&\"cookie monster\".to_string());\n     /// ```\n     #[stable(feature = \"any_send_sync_methods\", since = \"1.28.0\")]\n     #[inline]\n@@ -360,10 +344,8 @@ impl dyn Any+Send+Sync {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     print_if_string(&0);\n-    ///     print_if_string(&\"cookie monster\".to_string());\n-    /// }\n+    /// print_if_string(&0);\n+    /// print_if_string(&\"cookie monster\".to_string());\n     /// ```\n     #[stable(feature = \"any_send_sync_methods\", since = \"1.28.0\")]\n     #[inline]\n@@ -384,16 +366,14 @@ impl dyn Any+Send+Sync {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     let mut x = 10u32;\n-    ///     let mut s = \"starlord\".to_string();\n+    /// let mut x = 10u32;\n+    /// let mut s = \"starlord\".to_string();\n     ///\n-    ///     modify_if_u32(&mut x);\n-    ///     modify_if_u32(&mut s);\n+    /// modify_if_u32(&mut x);\n+    /// modify_if_u32(&mut s);\n     ///\n-    ///     assert_eq!(x, 42);\n-    ///     assert_eq!(&s, \"starlord\");\n-    /// }\n+    /// assert_eq!(x, 42);\n+    /// assert_eq!(&s, \"starlord\");\n     /// ```\n     #[stable(feature = \"any_send_sync_methods\", since = \"1.28.0\")]\n     #[inline]\n@@ -437,10 +417,8 @@ impl TypeId {\n     ///     TypeId::of::<String>() == TypeId::of::<T>()\n     /// }\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(is_string(&0), false);\n-    ///     assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n-    /// }\n+    /// assert_eq!(is_string(&0), false);\n+    /// assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_unstable(feature=\"const_type_id\")]"}, {"sha": "c456e14db12d4f311f43177458301a9c316dd2a1", "filename": "src/libcore/char/convert.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7628cada4f56676c361730251841e65600d863fe/src%2Flibcore%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7628cada4f56676c361730251841e65600d863fe/src%2Flibcore%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fconvert.rs?ref=7628cada4f56676c361730251841e65600d863fe", "patch": "@@ -111,11 +111,9 @@ impl From<char> for u32 {\n     /// ```\n     /// use std::mem;\n     ///\n-    /// fn main() {\n-    ///     let c = 'c';\n-    ///     let u = u32::from(c);\n-    ///     assert!(4 == mem::size_of_val(&u))\n-    /// }\n+    /// let c = 'c';\n+    /// let u = u32::from(c);\n+    /// assert!(4 == mem::size_of_val(&u))\n     /// ```\n     #[inline]\n     fn from(c: char) -> Self {\n@@ -150,11 +148,9 @@ impl From<u8> for char {\n     /// ```\n     /// use std::mem;\n     ///\n-    /// fn main() {\n-    ///     let u = 32 as u8;\n-    ///     let c = char::from(u);\n-    ///     assert!(4 == mem::size_of_val(&c))\n-    /// }\n+    /// let u = 32 as u8;\n+    /// let c = char::from(u);\n+    /// assert!(4 == mem::size_of_val(&c))\n     /// ```\n     #[inline]\n     fn from(i: u8) -> Self {"}, {"sha": "b71c9c2c40b37878c3253e1469f367218b1d062d", "filename": "src/libcore/char/decode.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7628cada4f56676c361730251841e65600d863fe/src%2Flibcore%2Fchar%2Fdecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7628cada4f56676c361730251841e65600d863fe/src%2Flibcore%2Fchar%2Fdecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fdecode.rs?ref=7628cada4f56676c361730251841e65600d863fe", "patch": "@@ -31,39 +31,41 @@ pub struct DecodeUtf16Error {\n /// ```\n /// use std::char::decode_utf16;\n ///\n-/// fn main() {\n-///     // \ud834\udd1emus<invalid>ic<invalid>\n-///     let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n-///              0x0073, 0xDD1E, 0x0069, 0x0063,\n-///              0xD834];\n+/// // \ud834\udd1emus<invalid>ic<invalid>\n+/// let v = [\n+///     0xD834, 0xDD1E, 0x006d, 0x0075, 0x0073, 0xDD1E, 0x0069, 0x0063, 0xD834,\n+/// ];\n ///\n-///     assert_eq!(decode_utf16(v.iter().cloned())\n-///                            .map(|r| r.map_err(|e| e.unpaired_surrogate()))\n-///                            .collect::<Vec<_>>(),\n-///                vec![Ok('\ud834\udd1e'),\n-///                     Ok('m'), Ok('u'), Ok('s'),\n-///                     Err(0xDD1E),\n-///                     Ok('i'), Ok('c'),\n-///                     Err(0xD834)]);\n-/// }\n+/// assert_eq!(\n+///     decode_utf16(v.iter().cloned())\n+///         .map(|r| r.map_err(|e| e.unpaired_surrogate()))\n+///         .collect::<Vec<_>>(),\n+///     vec![\n+///         Ok('\ud834\udd1e'),\n+///         Ok('m'), Ok('u'), Ok('s'),\n+///         Err(0xDD1E),\n+///         Ok('i'), Ok('c'),\n+///         Err(0xD834)\n+///     ]\n+/// );\n /// ```\n ///\n /// A lossy decoder can be obtained by replacing `Err` results with the replacement character:\n ///\n /// ```\n /// use std::char::{decode_utf16, REPLACEMENT_CHARACTER};\n ///\n-/// fn main() {\n-///     // \ud834\udd1emus<invalid>ic<invalid>\n-///     let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n-///              0x0073, 0xDD1E, 0x0069, 0x0063,\n-///              0xD834];\n+/// // \ud834\udd1emus<invalid>ic<invalid>\n+/// let v = [\n+///     0xD834, 0xDD1E, 0x006d, 0x0075, 0x0073, 0xDD1E, 0x0069, 0x0063, 0xD834,\n+/// ];\n ///\n-///     assert_eq!(decode_utf16(v.iter().cloned())\n-///                    .map(|r| r.unwrap_or(REPLACEMENT_CHARACTER))\n-///                    .collect::<String>(),\n-///                \"\ud834\udd1emus\ufffdic\ufffd\");\n-/// }\n+/// assert_eq!(\n+///     decode_utf16(v.iter().cloned())\n+///        .map(|r| r.unwrap_or(REPLACEMENT_CHARACTER))\n+///        .collect::<String>(),\n+///     \"\ud834\udd1emus\ufffdic\ufffd\"\n+/// );\n /// ```\n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n #[inline]"}, {"sha": "5dfdd1623061e19e7fb8fb0d307bfdd0ed6f9068", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7628cada4f56676c361730251841e65600d863fe/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7628cada4f56676c361730251841e65600d863fe/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=7628cada4f56676c361730251841e65600d863fe", "patch": "@@ -1532,12 +1532,10 @@ impl<'a> Formatter<'a> {\n     ///     }\n     /// }\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(&format!(\"{:<}\", Foo), \"left\");\n-    ///     assert_eq!(&format!(\"{:>}\", Foo), \"right\");\n-    ///     assert_eq!(&format!(\"{:^}\", Foo), \"center\");\n-    ///     assert_eq!(&format!(\"{}\", Foo), \"into the void\");\n-    /// }\n+    /// assert_eq!(&format!(\"{:<}\", Foo), \"left\");\n+    /// assert_eq!(&format!(\"{:>}\", Foo), \"right\");\n+    /// assert_eq!(&format!(\"{:^}\", Foo), \"center\");\n+    /// assert_eq!(&format!(\"{}\", Foo), \"into the void\");\n     /// ```\n     #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n     pub fn align(&self) -> Option<Alignment> {"}, {"sha": "933919185956e54c5fb65aa810c2d671327a3350", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7628cada4f56676c361730251841e65600d863fe/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7628cada4f56676c361730251841e65600d863fe/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=7628cada4f56676c361730251841e65600d863fe", "patch": "@@ -2732,31 +2732,29 @@ impl<T: ?Sized> Eq for *mut T {}\n /// impl Trait for Wrapper {}\n /// impl Trait for i32 {}\n ///\n-/// fn main() {\n-///     let wrapper = Wrapper { member: 10 };\n-///\n-///     // Pointers have equal addresses.\n-///     assert!(std::ptr::eq(\n-///         &wrapper as *const Wrapper as *const u8,\n-///         &wrapper.member as *const i32 as *const u8\n-///     ));\n-///\n-///     // Objects have equal addresses, but `Trait` has different implementations.\n-///     assert!(!std::ptr::eq(\n-///         &wrapper as &dyn Trait,\n-///         &wrapper.member as &dyn Trait,\n-///     ));\n-///     assert!(!std::ptr::eq(\n-///         &wrapper as &dyn Trait as *const dyn Trait,\n-///         &wrapper.member as &dyn Trait as *const dyn Trait,\n-///     ));\n-///\n-///     // Converting the reference to a `*const u8` compares by address.\n-///     assert!(std::ptr::eq(\n-///         &wrapper as &dyn Trait as *const dyn Trait as *const u8,\n-///         &wrapper.member as &dyn Trait as *const dyn Trait as *const u8,\n-///     ));\n-/// }\n+/// let wrapper = Wrapper { member: 10 };\n+///\n+/// // Pointers have equal addresses.\n+/// assert!(std::ptr::eq(\n+///     &wrapper as *const Wrapper as *const u8,\n+///     &wrapper.member as *const i32 as *const u8\n+/// ));\n+///\n+/// // Objects have equal addresses, but `Trait` has different implementations.\n+/// assert!(!std::ptr::eq(\n+///     &wrapper as &dyn Trait,\n+///     &wrapper.member as &dyn Trait,\n+/// ));\n+/// assert!(!std::ptr::eq(\n+///     &wrapper as &dyn Trait as *const dyn Trait,\n+///     &wrapper.member as &dyn Trait as *const dyn Trait,\n+/// ));\n+///\n+/// // Converting the reference to a `*const u8` compares by address.\n+/// assert!(std::ptr::eq(\n+///     &wrapper as &dyn Trait as *const dyn Trait as *const u8,\n+///     &wrapper.member as &dyn Trait as *const dyn Trait as *const u8,\n+/// ));\n /// ```\n #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n #[inline]"}, {"sha": "ff50051ef504043d673d3f3bdec1466093fa0850", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7628cada4f56676c361730251841e65600d863fe/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7628cada4f56676c361730251841e65600d863fe/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=7628cada4f56676c361730251841e65600d863fe", "patch": "@@ -192,14 +192,9 @@ use crate::sys;\n /// ```\n /// use std::collections::HashMap;\n ///\n-/// fn main() {\n-///     let timber_resources: HashMap<&str, i32> =\n-///     [(\"Norway\", 100),\n-///      (\"Denmark\", 50),\n-///      (\"Iceland\", 10)]\n-///      .iter().cloned().collect();\n-///     // use the values stored in map\n-/// }\n+/// let timber_resources: HashMap<&str, i32> = [(\"Norway\", 100), (\"Denmark\", 50), (\"Iceland\", 10)]\n+///     .iter().cloned().collect();\n+/// // use the values stored in map\n /// ```\n \n #[derive(Clone)]"}, {"sha": "092fb443468483c043786407a14d2043a80be742", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7628cada4f56676c361730251841e65600d863fe/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7628cada4f56676c361730251841e65600d863fe/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=7628cada4f56676c361730251841e65600d863fe", "patch": "@@ -93,11 +93,9 @@ use super::map::{self, HashMap, Keys, RandomState};\n /// ```\n /// use std::collections::HashSet;\n ///\n-/// fn main() {\n-///     let viking_names: HashSet<&'static str> =\n-///         [ \"Einar\", \"Olaf\", \"Harald\" ].iter().cloned().collect();\n-///     // use the values stored in the set\n-/// }\n+/// let viking_names: HashSet<&'static str> =\n+///     [ \"Einar\", \"Olaf\", \"Harald\" ].iter().cloned().collect();\n+/// // use the values stored in the set\n /// ```\n ///\n /// [`Cell`]: ../../std/cell/struct.Cell.html"}, {"sha": "f9255b82fc83e399299ec5c09686115cd0bcaf95", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7628cada4f56676c361730251841e65600d863fe/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7628cada4f56676c361730251841e65600d863fe/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=7628cada4f56676c361730251841e65600d863fe", "patch": "@@ -217,11 +217,9 @@ impl SocketAddr {\n     /// ```\n     /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n     ///\n-    /// fn main() {\n-    ///     let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n-    ///     assert_eq!(socket.is_ipv4(), true);\n-    ///     assert_eq!(socket.is_ipv6(), false);\n-    /// }\n+    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n+    /// assert_eq!(socket.is_ipv4(), true);\n+    /// assert_eq!(socket.is_ipv6(), false);\n     /// ```\n     #[stable(feature = \"sockaddr_checker\", since = \"1.16.0\")]\n     pub fn is_ipv4(&self) -> bool {\n@@ -244,12 +242,9 @@ impl SocketAddr {\n     /// ```\n     /// use std::net::{IpAddr, Ipv6Addr, SocketAddr};\n     ///\n-    /// fn main() {\n-    ///     let socket = SocketAddr::new(\n-    ///                      IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 65535, 0, 1)), 8080);\n-    ///     assert_eq!(socket.is_ipv4(), false);\n-    ///     assert_eq!(socket.is_ipv6(), true);\n-    /// }\n+    /// let socket = SocketAddr::new(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 65535, 0, 1)), 8080);\n+    /// assert_eq!(socket.is_ipv4(), false);\n+    /// assert_eq!(socket.is_ipv6(), true);\n     /// ```\n     #[stable(feature = \"sockaddr_checker\", since = \"1.16.0\")]\n     pub fn is_ipv6(&self) -> bool {"}, {"sha": "70b68d134855087a8f83ea9a9b4aa7bf21c99db4", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 102, "deletions": 135, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/7628cada4f56676c361730251841e65600d863fe/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7628cada4f56676c361730251841e65600d863fe/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=7628cada4f56676c361730251841e65600d863fe", "patch": "@@ -197,11 +197,8 @@ impl IpAddr {\n     ///\n     /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(IpAddr::V4(Ipv4Addr::new(80, 9, 12, 3)).is_global(), true);\n-    ///     assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0x1c9, 0, 0, 0xafc8, 0, 0x1)).is_global(),\n-    ///                true);\n-    /// }\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(80, 9, 12, 3)).is_global(), true);\n+    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0x1c9, 0, 0, 0xafc8, 0, 0x1)).is_global(), true);\n     /// ```\n     pub fn is_global(&self) -> bool {\n         match self {\n@@ -251,11 +248,11 @@ impl IpAddr {\n     ///\n     /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_documentation(), true);\n-    ///     assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0))\n-    ///                       .is_documentation(), true);\n-    /// }\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_documentation(), true);\n+    /// assert_eq!(\n+    ///     IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_documentation(),\n+    ///     true\n+    /// );\n     /// ```\n     pub fn is_documentation(&self) -> bool {\n         match self {\n@@ -275,11 +272,8 @@ impl IpAddr {\n     /// ```\n     /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_ipv4(), true);\n-    ///     assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_ipv4(),\n-    ///                false);\n-    /// }\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_ipv4(), true);\n+    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_ipv4(), false);\n     /// ```\n     #[stable(feature = \"ipaddr_checker\", since = \"1.16.0\")]\n     pub fn is_ipv4(&self) -> bool {\n@@ -300,11 +294,8 @@ impl IpAddr {\n     /// ```\n     /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_ipv6(), false);\n-    ///     assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_ipv6(),\n-    ///                true);\n-    /// }\n+    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_ipv6(), false);\n+    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_ipv6(), true);\n     /// ```\n     #[stable(feature = \"ipaddr_checker\", since = \"1.16.0\")]\n     pub fn is_ipv6(&self) -> bool {\n@@ -526,48 +517,46 @@ impl Ipv4Addr {\n     ///\n     /// use std::net::Ipv4Addr;\n     ///\n-    /// fn main() {\n-    ///     // private addresses are not global\n-    ///     assert_eq!(Ipv4Addr::new(10, 254, 0, 0).is_global(), false);\n-    ///     assert_eq!(Ipv4Addr::new(192, 168, 10, 65).is_global(), false);\n-    ///     assert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_global(), false);\n+    /// // private addresses are not global\n+    /// assert_eq!(Ipv4Addr::new(10, 254, 0, 0).is_global(), false);\n+    /// assert_eq!(Ipv4Addr::new(192, 168, 10, 65).is_global(), false);\n+    /// assert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_global(), false);\n     ///\n-    ///     // the 0.0.0.0/8 block is not global\n-    ///     assert_eq!(Ipv4Addr::new(0, 1, 2, 3).is_global(), false);\n-    ///     // in particular, the unspecified address is not global\n-    ///     assert_eq!(Ipv4Addr::new(0, 0, 0, 0).is_global(), false);\n+    /// // the 0.0.0.0/8 block is not global\n+    /// assert_eq!(Ipv4Addr::new(0, 1, 2, 3).is_global(), false);\n+    /// // in particular, the unspecified address is not global\n+    /// assert_eq!(Ipv4Addr::new(0, 0, 0, 0).is_global(), false);\n     ///\n-    ///     // the loopback address is not global\n-    ///     assert_eq!(Ipv4Addr::new(127, 0, 0, 1).is_global(), false);\n+    /// // the loopback address is not global\n+    /// assert_eq!(Ipv4Addr::new(127, 0, 0, 1).is_global(), false);\n     ///\n-    ///     // link local addresses are not global\n-    ///     assert_eq!(Ipv4Addr::new(169, 254, 45, 1).is_global(), false);\n+    /// // link local addresses are not global\n+    /// assert_eq!(Ipv4Addr::new(169, 254, 45, 1).is_global(), false);\n     ///\n-    ///     // the broadcast address is not global\n-    ///     assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_global(), false);\n+    /// // the broadcast address is not global\n+    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_global(), false);\n     ///\n-    ///     // the broadcast address is not global\n-    ///     assert_eq!(Ipv4Addr::new(192, 0, 2, 255).is_global(), false);\n-    ///     assert_eq!(Ipv4Addr::new(198, 51, 100, 65).is_global(), false);\n-    ///     assert_eq!(Ipv4Addr::new(203, 0, 113, 6).is_global(), false);\n+    /// // the broadcast address is not global\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).is_global(), false);\n+    /// assert_eq!(Ipv4Addr::new(198, 51, 100, 65).is_global(), false);\n+    /// assert_eq!(Ipv4Addr::new(203, 0, 113, 6).is_global(), false);\n     ///\n-    ///     // shared addresses are not global\n-    ///     assert_eq!(Ipv4Addr::new(100, 100, 0, 0).is_global(), false);\n+    /// // shared addresses are not global\n+    /// assert_eq!(Ipv4Addr::new(100, 100, 0, 0).is_global(), false);\n     ///\n-    ///     // addresses reserved for protocol assignment are not global\n-    ///     assert_eq!(Ipv4Addr::new(192, 0, 0, 0).is_global(), false);\n-    ///     assert_eq!(Ipv4Addr::new(192, 0, 0, 255).is_global(), false);\n+    /// // addresses reserved for protocol assignment are not global\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 0).is_global(), false);\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 255).is_global(), false);\n     ///\n-    ///     // addresses reserved for future use are not global\n-    ///     assert_eq!(Ipv4Addr::new(250, 10, 20, 30).is_global(), false);\n+    /// // addresses reserved for future use are not global\n+    /// assert_eq!(Ipv4Addr::new(250, 10, 20, 30).is_global(), false);\n     ///\n-    ///     // addresses reserved for network devices benchmarking are not global\n-    ///     assert_eq!(Ipv4Addr::new(198, 18, 0, 0).is_global(), false);\n+    /// // addresses reserved for network devices benchmarking are not global\n+    /// assert_eq!(Ipv4Addr::new(198, 18, 0, 0).is_global(), false);\n     ///\n-    ///     // All the other addresses are global\n-    ///     assert_eq!(Ipv4Addr::new(1, 1, 1, 1).is_global(), true);\n-    ///     assert_eq!(Ipv4Addr::new(80, 9, 12, 3).is_global(), true);\n-    /// }\n+    /// // All the other addresses are global\n+    /// assert_eq!(Ipv4Addr::new(1, 1, 1, 1).is_global(), true);\n+    /// assert_eq!(Ipv4Addr::new(80, 9, 12, 3).is_global(), true);\n     /// ```\n     pub fn is_global(&self) -> bool {\n         // check if this address is 192.0.0.9 or 192.0.0.10. These addresses are the only two\n@@ -600,11 +589,9 @@ impl Ipv4Addr {\n     /// #![feature(ip)]\n     /// use std::net::Ipv4Addr;\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(Ipv4Addr::new(100, 64, 0, 0).is_shared(), true);\n-    ///     assert_eq!(Ipv4Addr::new(100, 127, 255, 255).is_shared(), true);\n-    ///     assert_eq!(Ipv4Addr::new(100, 128, 0, 0).is_shared(), false);\n-    /// }\n+    /// assert_eq!(Ipv4Addr::new(100, 64, 0, 0).is_shared(), true);\n+    /// assert_eq!(Ipv4Addr::new(100, 127, 255, 255).is_shared(), true);\n+    /// assert_eq!(Ipv4Addr::new(100, 128, 0, 0).is_shared(), false);\n     /// ```\n     pub fn is_shared(&self) -> bool {\n         self.octets()[0] == 100 && (self.octets()[1] & 0b1100_0000 == 0b0100_0000)\n@@ -631,14 +618,12 @@ impl Ipv4Addr {\n     /// #![feature(ip)]\n     /// use std::net::Ipv4Addr;\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(Ipv4Addr::new(192, 0, 0, 0).is_ietf_protocol_assignment(), true);\n-    ///     assert_eq!(Ipv4Addr::new(192, 0, 0, 8).is_ietf_protocol_assignment(), true);\n-    ///     assert_eq!(Ipv4Addr::new(192, 0, 0, 9).is_ietf_protocol_assignment(), true);\n-    ///     assert_eq!(Ipv4Addr::new(192, 0, 0, 255).is_ietf_protocol_assignment(), true);\n-    ///     assert_eq!(Ipv4Addr::new(192, 0, 1, 0).is_ietf_protocol_assignment(), false);\n-    ///     assert_eq!(Ipv4Addr::new(191, 255, 255, 255).is_ietf_protocol_assignment(), false);\n-    /// }\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 0).is_ietf_protocol_assignment(), true);\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 8).is_ietf_protocol_assignment(), true);\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 9).is_ietf_protocol_assignment(), true);\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 255).is_ietf_protocol_assignment(), true);\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 1, 0).is_ietf_protocol_assignment(), false);\n+    /// assert_eq!(Ipv4Addr::new(191, 255, 255, 255).is_ietf_protocol_assignment(), false);\n     /// ```\n     pub fn is_ietf_protocol_assignment(&self) -> bool {\n         self.octets()[0] == 192 && self.octets()[1] == 0 && self.octets()[2] == 0\n@@ -658,12 +643,10 @@ impl Ipv4Addr {\n     /// #![feature(ip)]\n     /// use std::net::Ipv4Addr;\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(Ipv4Addr::new(198, 17, 255, 255).is_benchmarking(), false);\n-    ///     assert_eq!(Ipv4Addr::new(198, 18, 0, 0).is_benchmarking(), true);\n-    ///     assert_eq!(Ipv4Addr::new(198, 19, 255, 255).is_benchmarking(), true);\n-    ///     assert_eq!(Ipv4Addr::new(198, 20, 0, 0).is_benchmarking(), false);\n-    /// }\n+    /// assert_eq!(Ipv4Addr::new(198, 17, 255, 255).is_benchmarking(), false);\n+    /// assert_eq!(Ipv4Addr::new(198, 18, 0, 0).is_benchmarking(), true);\n+    /// assert_eq!(Ipv4Addr::new(198, 19, 255, 255).is_benchmarking(), true);\n+    /// assert_eq!(Ipv4Addr::new(198, 20, 0, 0).is_benchmarking(), false);\n     /// ```\n     pub fn is_benchmarking(&self) -> bool {\n         self.octets()[0] == 198 && (self.octets()[1] & 0xfe) == 18\n@@ -690,15 +673,12 @@ impl Ipv4Addr {\n     /// #![feature(ip)]\n     /// use std::net::Ipv4Addr;\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(Ipv4Addr::new(240, 0, 0, 0).is_reserved(), true);\n-    ///     assert_eq!(Ipv4Addr::new(255, 255, 255, 254).is_reserved(), true);\n+    /// assert_eq!(Ipv4Addr::new(240, 0, 0, 0).is_reserved(), true);\n+    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 254).is_reserved(), true);\n     ///\n-    ///     assert_eq!(Ipv4Addr::new(239, 255, 255, 255).is_reserved(), false);\n-    ///     // The broadcast address is not considered as reserved for future use by this\n-    ///     // implementation\n-    ///     assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_reserved(), false);\n-    /// }\n+    /// assert_eq!(Ipv4Addr::new(239, 255, 255, 255).is_reserved(), false);\n+    /// // The broadcast address is not considered as reserved for future use by this implementation\n+    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_reserved(), false);\n     /// ```\n     pub fn is_reserved(&self) -> bool {\n         self.octets()[0] & 240 == 240 && !self.is_broadcast()\n@@ -788,8 +768,10 @@ impl Ipv4Addr {\n     /// ```\n     /// use std::net::{Ipv4Addr, Ipv6Addr};\n     ///\n-    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).to_ipv6_compatible(),\n-    ///            Ipv6Addr::new(0, 0, 0, 0, 0, 0, 49152, 767));\n+    /// assert_eq!(\n+    ///     Ipv4Addr::new(192, 0, 2, 255).to_ipv6_compatible(),\n+    ///     Ipv6Addr::new(0, 0, 0, 0, 0, 0, 49152, 767)\n+    /// );\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_ipv6_compatible(&self) -> Ipv6Addr {\n@@ -1161,11 +1143,9 @@ impl Ipv6Addr {\n     ///\n     /// use std::net::Ipv6Addr;\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_global(), true);\n-    ///     assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1).is_global(), false);\n-    ///     assert_eq!(Ipv6Addr::new(0, 0, 0x1c9, 0, 0, 0xafc8, 0, 0x1).is_global(), true);\n-    /// }\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_global(), true);\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1).is_global(), false);\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0x1c9, 0, 0, 0xafc8, 0, 0x1).is_global(), true);\n     /// ```\n     pub fn is_global(&self) -> bool {\n         match self.multicast_scope() {\n@@ -1189,11 +1169,8 @@ impl Ipv6Addr {\n     ///\n     /// use std::net::Ipv6Addr;\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unique_local(),\n-    ///                false);\n-    ///     assert_eq!(Ipv6Addr::new(0xfc02, 0, 0, 0, 0, 0, 0, 0).is_unique_local(), true);\n-    /// }\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unique_local(), false);\n+    /// assert_eq!(Ipv6Addr::new(0xfc02, 0, 0, 0, 0, 0, 0, 0).is_unique_local(), true);\n     /// ```\n     pub fn is_unique_local(&self) -> bool {\n         (self.segments()[0] & 0xfe00) == 0xfc00\n@@ -1223,21 +1200,19 @@ impl Ipv6Addr {\n     ///\n     /// use std::net::Ipv6Addr;\n     ///\n-    /// fn main() {\n-    ///     let ip = Ipv6Addr::new(0xfe80, 0, 0, 0, 0, 0, 0, 0);\n-    ///     assert!(ip.is_unicast_link_local_strict());\n+    /// let ip = Ipv6Addr::new(0xfe80, 0, 0, 0, 0, 0, 0, 0);\n+    /// assert!(ip.is_unicast_link_local_strict());\n     ///\n-    ///     let ip = Ipv6Addr::new(0xfe80, 0, 0, 0, 0xffff, 0xffff, 0xffff, 0xffff);\n-    ///     assert!(ip.is_unicast_link_local_strict());\n+    /// let ip = Ipv6Addr::new(0xfe80, 0, 0, 0, 0xffff, 0xffff, 0xffff, 0xffff);\n+    /// assert!(ip.is_unicast_link_local_strict());\n     ///\n-    ///     let ip = Ipv6Addr::new(0xfe80, 0, 0, 1, 0, 0, 0, 0);\n-    ///     assert!(!ip.is_unicast_link_local_strict());\n-    ///     assert!(ip.is_unicast_link_local());\n+    /// let ip = Ipv6Addr::new(0xfe80, 0, 0, 1, 0, 0, 0, 0);\n+    /// assert!(!ip.is_unicast_link_local_strict());\n+    /// assert!(ip.is_unicast_link_local());\n     ///\n-    ///     let ip = Ipv6Addr::new(0xfe81, 0, 0, 0, 0, 0, 0, 0);\n-    ///     assert!(!ip.is_unicast_link_local_strict());\n-    ///     assert!(ip.is_unicast_link_local());\n-    /// }\n+    /// let ip = Ipv6Addr::new(0xfe81, 0, 0, 0, 0, 0, 0, 0);\n+    /// assert!(!ip.is_unicast_link_local_strict());\n+    /// assert!(ip.is_unicast_link_local());\n     /// ```\n     ///\n     /// # See also\n@@ -1284,21 +1259,19 @@ impl Ipv6Addr {\n     ///\n     /// use std::net::Ipv6Addr;\n     ///\n-    /// fn main() {\n-    ///     let ip = Ipv6Addr::new(0xfe80, 0, 0, 0, 0, 0, 0, 0);\n-    ///     assert!(ip.is_unicast_link_local());\n+    /// let ip = Ipv6Addr::new(0xfe80, 0, 0, 0, 0, 0, 0, 0);\n+    /// assert!(ip.is_unicast_link_local());\n     ///\n-    ///     let ip = Ipv6Addr::new(0xfe80, 0, 0, 0, 0xffff, 0xffff, 0xffff, 0xffff);\n-    ///     assert!(ip.is_unicast_link_local());\n+    /// let ip = Ipv6Addr::new(0xfe80, 0, 0, 0, 0xffff, 0xffff, 0xffff, 0xffff);\n+    /// assert!(ip.is_unicast_link_local());\n     ///\n-    ///     let ip = Ipv6Addr::new(0xfe80, 0, 0, 1, 0, 0, 0, 0);\n-    ///     assert!(ip.is_unicast_link_local());\n-    ///     assert!(!ip.is_unicast_link_local_strict());\n+    /// let ip = Ipv6Addr::new(0xfe80, 0, 0, 1, 0, 0, 0, 0);\n+    /// assert!(ip.is_unicast_link_local());\n+    /// assert!(!ip.is_unicast_link_local_strict());\n     ///\n-    ///     let ip = Ipv6Addr::new(0xfe81, 0, 0, 0, 0, 0, 0, 0);\n-    ///     assert!(ip.is_unicast_link_local());\n-    ///     assert!(!ip.is_unicast_link_local_strict());\n-    /// }\n+    /// let ip = Ipv6Addr::new(0xfe81, 0, 0, 0, 0, 0, 0, 0);\n+    /// assert!(ip.is_unicast_link_local());\n+    /// assert!(!ip.is_unicast_link_local_strict());\n     /// ```\n     ///\n     /// # See also\n@@ -1336,11 +1309,11 @@ impl Ipv6Addr {\n     ///\n     /// use std::net::Ipv6Addr;\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unicast_site_local(),\n-    ///                false);\n-    ///     assert_eq!(Ipv6Addr::new(0xfec2, 0, 0, 0, 0, 0, 0, 0).is_unicast_site_local(), true);\n-    /// }\n+    /// assert_eq!(\n+    ///     Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unicast_site_local(),\n+    ///     false\n+    /// );\n+    /// assert_eq!(Ipv6Addr::new(0xfec2, 0, 0, 0, 0, 0, 0, 0).is_unicast_site_local(), true);\n     /// ```\n     ///\n     /// # Warning\n@@ -1369,11 +1342,8 @@ impl Ipv6Addr {\n     ///\n     /// use std::net::Ipv6Addr;\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_documentation(),\n-    ///                false);\n-    ///     assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_documentation(), true);\n-    /// }\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_documentation(), false);\n+    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_documentation(), true);\n     /// ```\n     pub fn is_documentation(&self) -> bool {\n         (self.segments()[0] == 0x2001) && (self.segments()[1] == 0xdb8)\n@@ -1407,11 +1377,8 @@ impl Ipv6Addr {\n     ///\n     /// use std::net::Ipv6Addr;\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_unicast_global(), false);\n-    ///     assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unicast_global(),\n-    ///                true);\n-    /// }\n+    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_unicast_global(), false);\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unicast_global(), true);\n     /// ```\n     pub fn is_unicast_global(&self) -> bool {\n         !self.is_multicast()\n@@ -1431,11 +1398,11 @@ impl Ipv6Addr {\n     ///\n     /// use std::net::{Ipv6Addr, Ipv6MulticastScope};\n     ///\n-    /// fn main() {\n-    ///     assert_eq!(Ipv6Addr::new(0xff0e, 0, 0, 0, 0, 0, 0, 0).multicast_scope(),\n-    ///                              Some(Ipv6MulticastScope::Global));\n-    ///     assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).multicast_scope(), None);\n-    /// }\n+    /// assert_eq!(\n+    ///     Ipv6Addr::new(0xff0e, 0, 0, 0, 0, 0, 0, 0).multicast_scope(),\n+    ///     Some(Ipv6MulticastScope::Global)\n+    /// );\n+    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).multicast_scope(), None);\n     /// ```\n     pub fn multicast_scope(&self) -> Option<Ipv6MulticastScope> {\n         if self.is_multicast() {"}, {"sha": "a72951c03461083a4bae1960c0b6cef616c198c9", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7628cada4f56676c361730251841e65600d863fe/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7628cada4f56676c361730251841e65600d863fe/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=7628cada4f56676c361730251841e65600d863fe", "patch": "@@ -426,14 +426,12 @@ mod prim_unit { }\n ///\n /// use std::mem;\n ///\n-/// fn main() {\n-///     unsafe {\n-///         let my_num: *mut i32 = libc::malloc(mem::size_of::<i32>()) as *mut i32;\n-///         if my_num.is_null() {\n-///             panic!(\"failed to allocate memory\");\n-///         }\n-///         libc::free(my_num as *mut libc::c_void);\n+/// unsafe {\n+///     let my_num: *mut i32 = libc::malloc(mem::size_of::<i32>()) as *mut i32;\n+///     if my_num.is_null() {\n+///         panic!(\"failed to allocate memory\");\n ///     }\n+///     libc::free(my_num as *mut libc::c_void);\n /// }\n /// ```\n ///"}]}