{"sha": "8d9cef4709db316c35d78d3cd1d13d970edbd57c", "node_id": "C_kwDOAAsO6NoAKDhkOWNlZjQ3MDlkYjMxNmMzNWQ3OGQzY2QxZDEzZDk3MGVkYmQ1N2M", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2023-03-01T02:02:17Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2023-03-07T13:30:08Z"}, "message": "Directly import rust-installer submodule\n\nThis moves the rust-installer code to be directly hosted in\nrust-lang/rust, since it's not used elsewhere and this makes it easier\nto make and review changes without needing a separate upstream commit.", "tree": {"sha": "c691ac44e357a7a7aa3db14afd6a9b40f190ca62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c691ac44e357a7a7aa3db14afd6a9b40f190ca62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d9cef4709db316c35d78d3cd1d13d970edbd57c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d9cef4709db316c35d78d3cd1d13d970edbd57c", "html_url": "https://github.com/rust-lang/rust/commit/8d9cef4709db316c35d78d3cd1d13d970edbd57c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d9cef4709db316c35d78d3cd1d13d970edbd57c/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e733ff797faeaaca1ede731e483e59b9e83c764b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e733ff797faeaaca1ede731e483e59b9e83c764b", "html_url": "https://github.com/rust-lang/rust/commit/e733ff797faeaaca1ede731e483e59b9e83c764b"}], "stats": {"total": 4374, "additions": 4370, "deletions": 4}, "files": [{"sha": "e79f2f089c1ed21ce7e360a70d29022e4a7c6203", "filename": ".gitmodules", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -1,6 +1,3 @@\n-[submodule \"src/rust-installer\"]\n-\tpath = src/tools/rust-installer\n-\turl = https://github.com/rust-lang/rust-installer.git\n [submodule \"src/doc/nomicon\"]\n \tpath = src/doc/nomicon\n \turl = https://github.com/rust-lang/nomicon.git"}, {"sha": "31b4e313213dfaf62b2dd13a4da8176990929526", "filename": "src/tools/rust-installer", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer?ref=e733ff797faeaaca1ede731e483e59b9e83c764b", "patch": "@@ -1 +0,0 @@\n-Subproject commit 31b4e313213dfaf62b2dd13a4da8176990929526"}, {"sha": "fb017f484b15975123cd34d7e32e46289212037c", "filename": "src/tools/rust-installer/.gitignore", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2F.gitignore?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1,5 @@\n+*~\n+tmp\n+target/\n+**/*.rs.bk\n+Cargo.lock"}, {"sha": "38b81a1baacd809ec96ae95b489d5ca94709b625", "filename": "src/tools/rust-installer/Cargo.toml", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2FCargo.toml?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1,28 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"installer\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[[bin]]\n+doc = false\n+name = \"rust-installer\"\n+path = \"src/main.rs\"\n+\n+[dependencies]\n+anyhow = \"1.0.19\"\n+flate2 = \"1.0.1\"\n+rayon = \"1.0\"\n+tar = \"0.4.13\"\n+walkdir = \"2\"\n+xz2 = \"0.1.4\"\n+num_cpus = \"1\"\n+remove_dir_all = \"0.5\"\n+\n+[dependencies.clap]\n+features = [\"derive\"]\n+version = \"3.1\"\n+\n+[target.\"cfg(windows)\".dependencies]\n+lazy_static = \"1\"\n+winapi = { version = \"0.3\", features = [\"errhandlingapi\", \"handleapi\", \"ioapiset\", \"winerror\", \"winioctl\", \"winnt\"] }"}, {"sha": "99d8e5ca4cf1c13f7d24248475ee7bd24567c1a6", "filename": "src/tools/rust-installer/README.md", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2FREADME.md?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1,71 @@\n+[![Build Status](https://travis-ci.org/rust-lang/rust-installer.svg?branch=master)](https://travis-ci.org/rust-lang/rust-installer)\n+\n+A generator for the install.sh script commonly used to install Rust in\n+Unix environments. It is used By Rust, Cargo, and is intended to be\n+used by a future combined installer of Rust + Cargo.\n+\n+# Usage\n+\n+```\n+./gen-installer.sh --product-name=Rust \\\n+                   --rel-manifest-dir=rustlib \\\n+                   --success-message=Rust-is-ready-to-roll. \\\n+                   --image-dir=./install-image \\\n+                   --work-dir=./temp \\\n+                   --output-dir=./dist \\\n+                   --non-installed-overlay=./overlay \\\n+                   --package-name=rustc-nightly-i686-apple-darwin \\\n+                   --component-name=rustc \\\n+                   --legacy-manifest-dirs=rustlib \\\n+                   --bulk-dirs=share/doc\n+```\n+\n+Or, to just generate the script.\n+\n+```\n+./gen-install-script.sh --product-name=Rust \\\n+                        --rel-manifest-dir=rustlib \\\n+                        --success-message=Rust-is-ready-to-roll. \\\n+                        --output-script=install.sh \\\n+                        --legacy-manifest-dirs=rustlib\n+```\n+\n+*Note: the dashes in `success-message` are converted to spaces. The\n+script's argument handling is broken with spaces.*\n+\n+To combine installers.\n+\n+```\n+./combine-installers.sh --product-name=Rust \\\n+                        --rel-manifest-dir=rustlib \\\n+                        --success-message=Rust-is-ready-to-roll. \\\n+                        --work-dir=./temp \\\n+                        --output-dir=./dist \\\n+                        --non-installed-overlay=./overlay \\\n+                        --package-name=rustc-nightly-i686-apple-darwin \\\n+                        --legacy-manifest-dirs=rustlib \\\n+                        --input-tarballs=./rustc.tar.gz,cargo.tar.gz\n+```\n+\n+# Future work\n+\n+* Make install.sh not have to be customized, pull it's data from a\n+  config file.\n+* Be more resiliant to installation failures, particularly if the disk\n+  is full.\n+* Pre-install and post-uninstall scripts.\n+* Allow components to depend on or contradict other components.\n+* Sanity check that expected destination dirs (bin, lib, share exist)?\n+* Add --docdir flag. Is there a standard name for this?\n+* Remove empty directories on uninstall.\n+* Detect mismatches in --prefix, --mandir, etc. in follow-on\n+  installs/uninstalls.\n+* Fix argument handling for spaces.\n+* Add --bindir.\n+\n+# License\n+\n+This software is distributed under the terms of both the MIT license\n+and/or the Apache License (Version 2.0), at your option.\n+\n+See [LICENSE-APACHE](LICENSE-APACHE), [LICENSE-MIT](LICENSE-MIT) for details."}, {"sha": "4931c34ddc27ffd3438542383dd528f901819a93", "filename": "src/tools/rust-installer/combine-installers.sh", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Fcombine-installers.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Fcombine-installers.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fcombine-installers.sh?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1,24 @@\n+#!/bin/bash\n+# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ue\n+\n+# Prints the absolute path of a directory to stdout\n+abs_path() {\n+    local path=\"$1\"\n+    # Unset CDPATH because it causes havok: it makes the destination unpredictable\n+    # and triggers 'cd' to print the path to stdout. Route `cd`'s output to /dev/null\n+    # for good measure.\n+    (unset CDPATH && cd \"$path\" > /dev/null && pwd)\n+}\n+\n+src_dir=\"$(abs_path $(dirname \"$0\"))\"\n+cargo run --manifest-path=\"$src_dir/Cargo.toml\" -- combine \"$@\""}, {"sha": "b4559d147addd61de2ffe5d5a6b58541cfdfa3ce", "filename": "src/tools/rust-installer/gen-install-script.sh", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Fgen-install-script.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Fgen-install-script.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fgen-install-script.sh?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1,24 @@\n+#!/bin/bash\n+# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ue\n+\n+# Prints the absolute path of a directory to stdout\n+abs_path() {\n+    local path=\"$1\"\n+    # Unset CDPATH because it causes havok: it makes the destination unpredictable\n+    # and triggers 'cd' to print the path to stdout. Route `cd`'s output to /dev/null\n+    # for good measure.\n+    (unset CDPATH && cd \"$path\" > /dev/null && pwd)\n+}\n+\n+src_dir=\"$(abs_path $(dirname \"$0\"))\"\n+cargo run --manifest-path=\"$src_dir/Cargo.toml\" -- script \"$@\""}, {"sha": "198cfe7425534a33ea7b14bf961b82dac187afd2", "filename": "src/tools/rust-installer/gen-installer.sh", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Fgen-installer.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Fgen-installer.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fgen-installer.sh?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1,24 @@\n+#!/bin/bash\n+# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ue\n+\n+# Prints the absolute path of a directory to stdout\n+abs_path() {\n+    local path=\"$1\"\n+    # Unset CDPATH because it causes havok: it makes the destination unpredictable\n+    # and triggers 'cd' to print the path to stdout. Route `cd`'s output to /dev/null\n+    # for good measure.\n+    (unset CDPATH && cd \"$path\" > /dev/null && pwd)\n+}\n+\n+src_dir=\"$(abs_path $(dirname \"$0\"))\"\n+cargo run --manifest-path=\"$src_dir/Cargo.toml\" -- generate \"$@\""}, {"sha": "7790541a4201ad7cccc599f0caa8ef852b938974", "filename": "src/tools/rust-installer/install-template.sh", "status": "added", "additions": 1005, "deletions": 0, "changes": 1005, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Finstall-template.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Finstall-template.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Finstall-template.sh?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1,1005 @@\n+#!/bin/bash\n+# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+# No undefined variables\n+set -u\n+\n+init_logging() {\n+    local _abs_libdir=\"$1\"\n+    local _logfile=\"$_abs_libdir/$TEMPLATE_REL_MANIFEST_DIR/install.log\"\n+    rm -f \"$_logfile\"\n+    need_ok \"failed to remove old installation log\"\n+    touch \"$_logfile\"\n+    need_ok \"failed to create installation log\"\n+    LOGFILE=\"$_logfile\"\n+}\n+\n+log_line() {\n+    local _line=\"$1\"\n+\n+    if [ -n \"${LOGFILE-}\" -a -e \"${LOGFILE-}\" ]; then\n+\techo \"$_line\" >> \"$LOGFILE\"\n+\t# Ignore errors, which may happen e.g. after the manifest dir is deleted\n+    fi\n+}\n+\n+msg() {\n+    local _line=\"install: ${1-}\"\n+    echo \"$_line\"\n+    log_line \"$_line\"\n+}\n+\n+verbose_msg() {\n+    if [ -n \"${CFG_VERBOSE-}\" ]; then\n+\tmsg \"${1-}\"\n+    else\n+\tlog_line \"install: ${1-}\"\n+    fi\n+}\n+\n+step_msg() {\n+    msg\n+    msg \"$1\"\n+    msg\n+}\n+\n+verbose_step_msg() {\n+    if [ -n \"${CFG_VERBOSE-}\" ]; then\n+\tmsg\n+\tmsg \"$1\"\n+\tmsg\n+    else\n+\tlog_line \"\"\n+\tlog_line \"install: $1\"\n+\tlog_line \"\"\n+    fi\n+}\n+\n+warn() {\n+    local _line=\"install: WARNING: $1\"\n+    echo \"$_line\" >&2\n+    log_line \"$_line\"\n+}\n+\n+err() {\n+    local _line=\"install: error: $1\"\n+    echo \"$_line\" >&2\n+    log_line \"$_line\"\n+    exit 1\n+}\n+\n+# A non-user error that is likely to result in a corrupted install\n+critical_err() {\n+    local _line=\"install: error: $1. see logs at '${LOGFILE-}'\"\n+    echo \"$_line\" >&2\n+    log_line \"$_line\"\n+    exit 1\n+}\n+\n+need_ok() {\n+    if [ $? -ne 0 ]\n+    then\n+        err \"$1\"\n+    fi\n+}\n+\n+critical_need_ok() {\n+    if [ $? -ne 0 ]\n+    then\n+        critical_err \"$1\"\n+    fi\n+}\n+\n+want_ok() {\n+    if [ $? -ne 0 ]; then\n+\twarn \"$1\"\n+    fi\n+}\n+\n+assert_nz() {\n+    if [ -z \"$1\" ]; then err \"assert_nz $2\"; fi\n+}\n+\n+need_cmd() {\n+    if command -v $1 >/dev/null 2>&1\n+    then verbose_msg \"found $1\"\n+    else err \"need $1\"\n+    fi\n+}\n+\n+run() {\n+    local _line=\"\\$ $*\"\n+    \"$@\"\n+    local _retval=$?\n+    log_line \"$_line\"\n+    return $_retval\n+}\n+\n+write_to_file() {\n+    local _msg=\"$1\"\n+    local _file=\"$2\"\n+    local _line=\"$ echo \\\"$_msg\\\" > \\\"$_file\\\"\"\n+    echo \"$_msg\" > \"$_file\"\n+    local _retval=$?\n+    log_line \"$_line\"\n+    return $_retval\n+}\n+\n+append_to_file() {\n+    local _msg=\"$1\"\n+    local _file=\"$2\"\n+    local _line=\"$ echo \\\"$_msg\\\" >> \\\"$_file\\\"\"\n+    echo \"$_msg\" >> \"$_file\"\n+    local _retval=$?\n+    log_line \"$_line\"\n+    return $_retval\n+}\n+\n+make_dir_recursive() {\n+    local _dir=\"$1\"\n+    local _line=\"$ umask 022 && mkdir -p \\\"$_dir\\\"\"\n+    umask 022 && mkdir -p \"$_dir\"\n+    local _retval=$?\n+    log_line \"$_line\"\n+    return $_retval\n+}\n+\n+putvar() {\n+    local t\n+    local tlen\n+    eval t=\\$$1\n+    eval tlen=\\${#$1}\n+}\n+\n+valopt() {\n+    VAL_OPTIONS=\"$VAL_OPTIONS $1\"\n+\n+    local op=$1\n+    local default=$2\n+    shift\n+    shift\n+    local doc=\"$*\"\n+    if [ $HELP -eq 0 ]\n+    then\n+        local uop=$(echo $op | tr 'a-z-' 'A-Z_')\n+        local v=\"CFG_${uop}\"\n+        eval $v=\"$default\"\n+        for arg in $CFG_ARGS\n+        do\n+            if echo \"$arg\" | grep -q -- \"--$op=\"\n+            then\n+                local val=$(echo \"$arg\" | cut -f2 -d=)\n+                eval $v=$val\n+            fi\n+        done\n+        putvar $v\n+    else\n+        if [ -z \"$default\" ]\n+        then\n+            default=\"<none>\"\n+        fi\n+        op=\"${op}=[${default}]\"\n+        printf \"    --%-30s %s\\n\" \"$op\" \"$doc\"\n+    fi\n+}\n+\n+opt() {\n+    BOOL_OPTIONS=\"$BOOL_OPTIONS $1\"\n+\n+    local op=$1\n+    local default=$2\n+    shift\n+    shift\n+    local doc=\"$*\"\n+    local flag=\"\"\n+\n+    if [ $default -eq 0 ]\n+    then\n+        flag=\"enable\"\n+    else\n+        flag=\"disable\"\n+        doc=\"don't $doc\"\n+    fi\n+\n+    if [ $HELP -eq 0 ]\n+    then\n+        for arg in $CFG_ARGS\n+        do\n+            if [ \"$arg\" = \"--${flag}-${op}\" ]\n+            then\n+                op=$(echo $op | tr 'a-z-' 'A-Z_')\n+                flag=$(echo $flag | tr 'a-z' 'A-Z')\n+                local v=\"CFG_${flag}_${op}\"\n+                eval $v=1\n+                putvar $v\n+            fi\n+        done\n+    else\n+        if [ ! -z \"${META-}\" ]\n+        then\n+            op=\"$op=<$META>\"\n+        fi\n+        printf \"    --%-30s %s\\n\" \"$flag-$op\" \"$doc\"\n+     fi\n+}\n+\n+flag() {\n+    BOOL_OPTIONS=\"$BOOL_OPTIONS $1\"\n+\n+    local op=$1\n+    shift\n+    local doc=\"$*\"\n+\n+    if [ $HELP -eq 0 ]\n+    then\n+        for arg in $CFG_ARGS\n+        do\n+            if [ \"$arg\" = \"--${op}\" ]\n+            then\n+                op=$(echo $op | tr 'a-z-' 'A-Z_')\n+                local v=\"CFG_${op}\"\n+                eval $v=1\n+                putvar $v\n+            fi\n+        done\n+    else\n+        if [ ! -z \"${META-}\" ]\n+        then\n+            op=\"$op=<$META>\"\n+        fi\n+        printf \"    --%-30s %s\\n\" \"$op\" \"$doc\"\n+     fi\n+}\n+\n+validate_opt () {\n+    for arg in $CFG_ARGS\n+    do\n+        local is_arg_valid=0\n+        for option in $BOOL_OPTIONS\n+        do\n+            if test --disable-$option = $arg\n+            then\n+                is_arg_valid=1\n+            fi\n+            if test --enable-$option = $arg\n+            then\n+                is_arg_valid=1\n+            fi\n+            if test --$option = $arg\n+            then\n+                is_arg_valid=1\n+            fi\n+        done\n+        for option in $VAL_OPTIONS\n+        do\n+            if echo \"$arg\" | grep -q -- \"--$option=\"\n+            then\n+                is_arg_valid=1\n+            fi\n+        done\n+        if [ \"$arg\" = \"--help\" ]\n+        then\n+            echo\n+            echo \"No more help available for Configure options,\"\n+            echo \"check the Wiki or join our IRC channel\"\n+            break\n+        else\n+            if test $is_arg_valid -eq 0\n+            then\n+                err \"Option '$arg' is not recognized\"\n+            fi\n+        fi\n+    done\n+}\n+\n+absolutify() {\n+    local file_path=\"$1\"\n+    local file_path_dirname=\"$(dirname \"$file_path\")\"\n+    local file_path_basename=\"$(basename \"$file_path\")\"\n+    local file_abs_path=\"$(abs_path \"$file_path_dirname\")\"\n+    local file_path=\"$file_abs_path/$file_path_basename\"\n+    # This is the return value\n+    RETVAL=\"$file_path\"\n+}\n+\n+# Prints the absolute path of a directory to stdout\n+abs_path() {\n+    local path=\"$1\"\n+    # Unset CDPATH because it causes havok: it makes the destination unpredictable\n+    # and triggers 'cd' to print the path to stdout. Route `cd`'s output to /dev/null\n+    # for good measure.\n+    (unset CDPATH && cd \"$path\" > /dev/null && pwd)\n+}\n+\n+uninstall_legacy() {\n+    local _abs_libdir=\"$1\"\n+\n+    local _uninstalled_something=false\n+\n+    # Replace commas in legacy manifest list with spaces\n+    _legacy_manifest_dirs=`echo \"$TEMPLATE_LEGACY_MANIFEST_DIRS\" | sed \"s/,/ /g\"`\n+\n+    # Uninstall from legacy manifests\n+    local _md\n+    for _md in $_legacy_manifest_dirs; do\n+\t# First, uninstall from the installation prefix.\n+\t# Errors are warnings - try to rm everything in the manifest even if some fail.\n+\tif [ -f \"$_abs_libdir/$_md/manifest\" ]\n+\tthen\n+\n+\t    # iterate through installed manifest and remove files\n+\t    local _p;\n+\t    while read _p; do\n+\t\t# the installed manifest contains absolute paths\n+\t\tmsg \"removing legacy file $_p\"\n+\t\tif [ -f \"$_p\" ]\n+\t\tthen\n+\t\t    run rm -f \"$_p\"\n+\t\t    want_ok \"failed to remove $_p\"\n+\t\telse\n+\t\t    warn \"supposedly installed file $_p does not exist!\"\n+\t\tfi\n+\t    done < \"$_abs_libdir/$_md/manifest\"\n+\n+\t    # If we fail to remove $md below, then the\n+\t    # installed manifest will still be full; the installed manifest\n+\t    # needs to be empty before install.\n+\t    msg \"removing legacy manifest $_abs_libdir/$_md/manifest\"\n+\t    run rm -f \"$_abs_libdir/$_md/manifest\"\n+\t    # For the above reason, this is a hard error\n+\t    need_ok \"failed to remove installed manifest\"\n+\n+\t    # Remove $template_rel_manifest_dir directory\n+\t    msg \"removing legacy manifest dir $_abs_libdir/$_md\"\n+\t    run rm -R \"$_abs_libdir/$_md\"\n+\t    want_ok \"failed to remove $_md\"\n+\n+\t    _uninstalled_something=true\n+\tfi\n+    done\n+\n+    RETVAL=\"$_uninstalled_something\"\n+}\n+\n+uninstall_components() {\n+    local _abs_libdir=\"$1\"\n+    local _dest_prefix=\"$2\"\n+    local _components=\"$3\"\n+\n+    # We're going to start by uninstalling existing components. This\n+    local _uninstalled_something=false\n+\n+    # First, try removing any 'legacy' manifests from before\n+    # rust-installer\n+    uninstall_legacy \"$_abs_libdir\"\n+    assert_nz \"$RETVAL\", \"RETVAL\"\n+    if [ \"$RETVAL\" = true ]; then\n+\t_uninstalled_something=true;\n+    fi\n+\n+    # Load the version of the installed installer\n+    local _installed_version=\n+    if [ -f \"$abs_libdir/$TEMPLATE_REL_MANIFEST_DIR/rust-installer-version\" ]; then\n+\t_installed_version=`cat \"$_abs_libdir/$TEMPLATE_REL_MANIFEST_DIR/rust-installer-version\"`\n+\n+\t# Sanity check\n+\tif [ ! -n \"$_installed_version\" ]; then critical_err \"rust installer version is empty\"; fi\n+    fi\n+\n+    # If there's something installed, then uninstall\n+    if [ -n \"$_installed_version\" ]; then\n+\t# Check the version of the installed installer\n+\tcase \"$_installed_version\" in\n+\n+\t    # If this is a previous version, then upgrade in place to the\n+\t    # current version before uninstalling.\n+\t    2 )\n+\t\t# The only change between version 2 -> 3 is that components are placed\n+\t\t# in subdirectories of the installer tarball. There are no changes\n+\t\t# to the installed data format, so nothing to do.\n+\t\t;;\n+\n+\t    # This is the current version. Nothing need to be done except uninstall.\n+\t    \"$TEMPLATE_RUST_INSTALLER_VERSION\")\n+\t\t;;\n+\n+\t    # If this is an unknown (future) version then bail.\n+\t    * )\n+\t\techo \"The copy of $TEMPLATE_PRODUCT_NAME at $_dest_prefix was installed using an\"\n+\t\techo \"unknown version ($_installed_version) of rust-installer.\"\n+\t\techo \"Uninstall it first with the installer used for the original installation\"\n+\t\techo \"before continuing.\"\n+\t\texit 1\n+\t\t;;\n+\tesac\n+\n+\tlocal _md=\"$_abs_libdir/$TEMPLATE_REL_MANIFEST_DIR\"\n+\tlocal _installed_components=\"$(cat \"$_md/components\")\"\n+\n+\t# Uninstall (our components only) before reinstalling\n+\tlocal _available_component\n+\tfor _available_component in $_components; do\n+\t    local _installed_component\n+\t    for _installed_component in $_installed_components; do\n+\t\tif [ \"$_available_component\" = \"$_installed_component\" ]; then\n+\t\t    msg \"uninstalling component '$_available_component'\"\n+\t\t    local _component_manifest=\"$_md/manifest-$_installed_component\"\n+\n+\t\t    # Sanity check: there should be a component manifest\n+\t\t    if [ ! -f \"$_component_manifest\" ]; then\n+\t\t\tcritical_err \"installed component '$_installed_component' has no manifest\"\n+\t\t    fi\n+\n+\t\t    # Iterate through installed component manifest and remove files\n+\t\t    local _directive\n+\t\t    while read _directive; do\n+\n+\t\t\tlocal _command=`echo $_directive | cut -f1 -d:`\n+\t\t\tlocal _file=`echo $_directive | cut -f2 -d:`\n+\n+\t\t\t# Sanity checks\n+\t\t\tif [ ! -n \"$_command\" ]; then critical_err \"malformed installation directive\"; fi\n+\t\t\tif [ ! -n \"$_file\" ]; then critical_err \"malformed installation directive\"; fi\n+\n+\t\t\tcase \"$_command\" in\n+\t\t\t    file)\n+\t\t\t\tverbose_msg \"removing file $_file\"\n+\t\t\t\tif [ -f \"$_file\" ]; then\n+\t\t\t\t    run rm -f \"$_file\"\n+\t\t\t\t    want_ok \"failed to remove $_file\"\n+\t\t\t\telse\n+\t\t\t\t    warn \"supposedly installed file $_file does not exist!\"\n+\t\t\t\tfi\n+\t\t\t\t;;\n+\n+\t\t\t    dir)\n+\t\t\t\tverbose_msg \"removing directory $_file\"\n+\t\t\t\trun rm -r \"$_file\"\n+\t\t\t\twant_ok \"unable to remove directory $_file\"\n+\t\t\t\t;;\n+\n+\t\t\t    *)\n+\t\t\t\tcritical_err \"unknown installation directive\"\n+\t\t\t\t;;\n+\t\t\tesac\n+\n+\t\t    done < \"$_component_manifest\"\n+\n+\t\t    # Remove the installed component manifest\n+\t\t    verbose_msg \"removing component manifest $_component_manifest\"\n+\t\t    run rm \"$_component_manifest\"\n+\t\t    # This is a hard error because the installation is unrecoverable\n+\t\t    critical_need_ok \"failed to remove installed manifest for component '$_installed_component'\"\n+\n+\t\t    # Update the installed component list\n+\t\t    local _modified_components=\"$(sed \"/^$_installed_component\\$/d\" \"$_md/components\")\"\n+\t\t    write_to_file \"$_modified_components\" \"$_md/components\"\n+\t\t    critical_need_ok \"failed to update installed component list\"\n+\t\tfi\n+\t    done\n+\tdone\n+\n+\t# If there are no remaining components delete the manifest directory,\n+\t# but only if we're doing an uninstall - if we're doing an install,\n+\t# then leave the manifest directory around to hang onto the logs,\n+\t# and any files not managed by the installer.\n+\tif [ -n \"${CFG_UNINSTALL-}\" ]; then\n+\t    local _remaining_components=\"$(cat \"$_md/components\")\"\n+\t    if [ ! -n \"$_remaining_components\" ]; then\n+\t\tverbose_msg \"removing manifest directory $_md\"\n+\t\trun rm -r \"$_md\"\n+\t\twant_ok \"failed to remove $_md\"\n+\n+\t\tmaybe_unconfigure_ld\n+\t    fi\n+\tfi\n+\n+\t_uninstalled_something=true\n+    fi\n+\n+    # There's no installed version. If we were asked to uninstall, then that's a problem.\n+    if [ -n \"${CFG_UNINSTALL-}\" -a \"$_uninstalled_something\" = false ]\n+    then\n+\terr \"unable to find installation manifest at $CFG_LIBDIR/$TEMPLATE_REL_MANIFEST_DIR\"\n+    fi\n+}\n+\n+install_components() {\n+    local _src_dir=\"$1\"\n+    local _abs_libdir=\"$2\"\n+    local _dest_prefix=\"$3\"\n+    local _components=\"$4\"\n+\n+    local _component\n+    for _component in $_components; do\n+\n+\tmsg \"installing component '$_component'\"\n+\n+\t# The file name of the manifest we're installing from\n+\tlocal _input_manifest=\"$_src_dir/$_component/manifest.in\"\n+\n+\t# Sanity check: do we have our input manifests?\n+\tif [ ! -f \"$_input_manifest\" ]; then\n+\t    critical_err \"manifest for $_component does not exist at $_input_manifest\"\n+\tfi\n+\n+\t# The installed manifest directory\n+\tlocal _md=\"$_abs_libdir/$TEMPLATE_REL_MANIFEST_DIR\"\n+\n+\t# The file name of the manifest we're going to create during install\n+\tlocal _installed_manifest=\"$_md/manifest-$_component\"\n+\n+\t# Create the installed manifest, which we will fill in with absolute file paths\n+\ttouch \"$_installed_manifest\"\n+\tcritical_need_ok \"failed to create installed manifest\"\n+\n+\t# Add this component to the installed component list\n+\tappend_to_file \"$_component\" \"$_md/components\"\n+\tcritical_need_ok \"failed to update components list for $_component\"\n+\n+\t# Now install, iterate through the new manifest and copy files\n+\tlocal _directive\n+\twhile read _directive; do\n+\n+\t    local _command=`echo $_directive | cut -f1 -d:`\n+\t    local _file=`echo $_directive | cut -f2 -d:`\n+\n+\t    # Sanity checks\n+\t    if [ ! -n \"$_command\" ]; then critical_err \"malformed installation directive\"; fi\n+\t    if [ ! -n \"$_file\" ]; then critical_err \"malformed installation directive\"; fi\n+\n+\t    # Decide the destination of the file\n+\t    local _file_install_path=\"$_dest_prefix/$_file\"\n+\n+\t    if echo \"$_file\" | grep \"^etc/\" > /dev/null\n+\t    then\n+\t\tlocal _f=\"$(echo \"$_file\" | sed 's/^etc\\///')\"\n+\t\t_file_install_path=\"$CFG_SYSCONFDIR/$_f\"\n+\t    fi\n+\n+\t    if echo \"$_file\" | grep \"^bin/\" > /dev/null\n+\t    then\n+\t\tlocal _f=\"$(echo \"$_file\" | sed 's/^bin\\///')\"\n+\t\t_file_install_path=\"$CFG_BINDIR/$_f\"\n+\t    fi\n+\n+\t    if echo \"$_file\" | grep \"^lib/\" > /dev/null\n+\t    then\n+\t\tlocal _f=\"$(echo \"$_file\" | sed 's/^lib\\///')\"\n+\t\t_file_install_path=\"$CFG_LIBDIR/$_f\"\n+\t    fi\n+\n+\t    if echo \"$_file\" | grep \"^share\" > /dev/null\n+\t    then\n+\t\tlocal _f=\"$(echo \"$_file\" | sed 's/^share\\///')\"\n+\t\t_file_install_path=\"$CFG_DATADIR/$_f\"\n+\t    fi\n+\n+\t    if echo \"$_file\" | grep \"^share/man/\" > /dev/null\n+\t    then\n+\t\tlocal _f=\"$(echo \"$_file\" | sed 's/^share\\/man\\///')\"\n+\t\t_file_install_path=\"$CFG_MANDIR/$_f\"\n+\t    fi\n+\n+            # HACK: Try to support overriding --docdir.  Paths with the form\n+            # \"share/doc/$product/\" can be redirected to a single --docdir\n+            # path. If the following detects that --docdir has been specified\n+            # then it will replace everything preceeding the \"$product\" path\n+            # component. The problem here is that the combined rust installer\n+            # contains two \"products\": rust and cargo; so the contents of those\n+            # directories will both be dumped into the same directory; and the\n+            # contents of those directories are _not_ disjoint. Since this feature\n+            # is almost entirely to support 'make install' anyway I don't expect\n+            # this problem to be a big deal in practice.\n+            if [ \"$CFG_DOCDIR\" != \"<default>\" ]\n+            then\n+\t        if echo \"$_file\" | grep \"^share/doc/\" > /dev/null\n+\t        then\n+\t\t    local _f=\"$(echo \"$_file\" | sed 's/^share\\/doc\\/[^/]*\\///')\"\n+\t\t    _file_install_path=\"$CFG_DOCDIR/$_f\"\n+\t        fi\n+            fi\n+\n+\t    # Make sure there's a directory for it\n+\t    make_dir_recursive \"$(dirname \"$_file_install_path\")\"\n+\t    critical_need_ok \"directory creation failed\"\n+\n+\t    # Make the path absolute so we can uninstall it later without\n+\t    # starting from the installation cwd\n+\t    absolutify \"$_file_install_path\"\n+\t    _file_install_path=\"$RETVAL\"\n+\t    assert_nz \"$_file_install_path\" \"file_install_path\"\n+\n+\t    case \"$_command\" in\n+\t\tfile )\n+\n+\t\t    verbose_msg \"copying file $_file_install_path\"\n+\n+\t\t    maybe_backup_path \"$_file_install_path\"\n+\n+\t\t    if echo \"$_file\" | grep \"^bin/\" > /dev/null || test -x \"$_src_dir/$_component/$_file\"\n+\t\t    then\n+\t\t\trun cp \"$_src_dir/$_component/$_file\" \"$_file_install_path\"\n+\t\t\trun chmod 755 \"$_file_install_path\"\n+\t\t    else\n+\t\t\trun cp \"$_src_dir/$_component/$_file\" \"$_file_install_path\"\n+\t\t\trun chmod 644 \"$_file_install_path\"\n+\t\t    fi\n+\t\t    critical_need_ok \"file creation failed\"\n+\n+\t\t    # Update the manifest\n+\t\t    append_to_file \"file:$_file_install_path\" \"$_installed_manifest\"\n+\t\t    critical_need_ok \"failed to update manifest\"\n+\n+\t\t    ;;\n+\n+\t\tdir )\n+\n+\t\t    verbose_msg \"copying directory $_file_install_path\"\n+\n+\t\t    maybe_backup_path \"$_file_install_path\"\n+\n+\t\t    run cp -R \"$_src_dir/$_component/$_file\" \"$_file_install_path\"\n+\t\t    critical_need_ok \"failed to copy directory\"\n+\n+                    # Set permissions. 0755 for dirs, 644 for files\n+                    run chmod -R u+rwX,go+rX,go-w \"$_file_install_path\"\n+                    critical_need_ok \"failed to set permissions on directory\"\n+\n+\t\t    # Update the manifest\n+\t\t    append_to_file \"dir:$_file_install_path\" \"$_installed_manifest\"\n+\t\t    critical_need_ok \"failed to update manifest\"\n+\t\t    ;;\n+\n+\t\t*)\n+\t\t    critical_err \"unknown installation directive\"\n+\t\t    ;;\n+\t    esac\n+\tdone < \"$_input_manifest\"\n+\n+    done\n+}\n+\n+maybe_configure_ld() {\n+    local _abs_libdir=\"$1\"\n+\n+    local _ostype=\"$(uname -s)\"\n+    assert_nz \"$_ostype\"  \"ostype\"\n+\n+    if [ \"$_ostype\" = \"Linux\" -a ! -n \"${CFG_DISABLE_LDCONFIG-}\" ]; then\n+\n+\t# Fedora-based systems do not configure the dynamic linker to look\n+\t# /usr/local/lib, which is our default installation directory. To\n+\t# make things just work, try to put that directory in\n+\t# /etc/ld.so.conf.d/rust-installer-v1 so ldconfig picks it up.\n+\t# Issue #30.\n+\t#\n+\t# This will get rm'd when the last component is uninstalled in\n+\t# maybe_unconfigure_ld.\n+\tif [ \"$_abs_libdir\" = \"/usr/local/lib\" -a -d \"/etc/ld.so.conf.d\" ]; then\n+\t    echo \"$_abs_libdir\" > \"/etc/ld.so.conf.d/rust-installer-v1-$TEMPLATE_REL_MANIFEST_DIR.conf\"\n+\t    if [ $? -ne 0 ]; then\n+\t\t# This shouldn't happen if we've gotten this far\n+\t\t# installing to /usr/local\n+\t\twarn \"failed to update /etc/ld.so.conf.d. this is unexpected\"\n+\t    fi\n+\tfi\n+\n+\tverbose_msg \"running ldconfig\"\n+\tif [ -n \"${CFG_VERBOSE-}\" ]; then\n+\t    ldconfig\n+\telse\n+\t    ldconfig 2> /dev/null\n+\tfi\n+\tif [ $? -ne 0 ]\n+\tthen\n+            warn \"failed to run ldconfig. this may happen when not installing as root. run with --verbose to see the error\"\n+\tfi\n+    fi\n+}\n+\n+maybe_unconfigure_ld() {\n+    local _ostype=\"$(uname -s)\"\n+    assert_nz \"$_ostype\"  \"ostype\"\n+\n+    if [ \"$_ostype\" != \"Linux\" ]; then\n+\treturn 0\n+    fi\n+\n+    rm \"/etc/ld.so.conf.d/rust-installer-v1-$TEMPLATE_REL_MANIFEST_DIR.conf\" 2> /dev/null\n+    # Above may fail since that file may not have been created on install\n+}\n+\n+# Doing our own 'install'-like backup that is consistent across platforms\n+maybe_backup_path() {\n+    local _file_install_path=\"$1\"\n+\n+    if [ -e \"$_file_install_path\" ]; then\n+\tmsg \"backing up existing file at $_file_install_path\"\n+\trun mv -f \"$_file_install_path\" \"$_file_install_path.old\"\n+\tcritical_need_ok \"failed to back up $_file_install_path\"\n+    fi\n+}\n+\n+install_uninstaller() {\n+    local _src_dir=\"$1\"\n+    local _src_basename=\"$2\"\n+    local _abs_libdir=\"$3\"\n+\n+    local _uninstaller=\"$_abs_libdir/$TEMPLATE_REL_MANIFEST_DIR/uninstall.sh\"\n+    msg \"creating uninstall script at $_uninstaller\"\n+    run cp \"$_src_dir/$_src_basename\" \"$_uninstaller\"\n+    critical_need_ok \"unable to install uninstaller\"\n+}\n+\n+do_preflight_sanity_checks() {\n+    local _src_dir=\"$1\"\n+    local _dest_prefix=\"$2\"\n+\n+    # Sanity check: can we can write to the destination?\n+    verbose_msg \"verifying destination is writable\"\n+    make_dir_recursive \"$CFG_LIBDIR\"\n+    need_ok \"can't write to destination. consider \\`sudo\\`.\"\n+    touch \"$CFG_LIBDIR/rust-install-probe\" > /dev/null\n+    if [ $? -ne 0 ]\n+    then\n+\terr \"can't write to destination. consider \\`sudo\\`.\"\n+    fi\n+    rm \"$CFG_LIBDIR/rust-install-probe\"\n+    need_ok \"failed to remove install probe\"\n+\n+    # Sanity check: don't install to the directory containing the installer.\n+    # That would surely cause chaos.\n+    verbose_msg \"verifying destination is not the same as source\"\n+    local _prefix_dir=\"$(abs_path \"$dest_prefix\")\"\n+    if [ \"$_src_dir\" = \"$_dest_prefix\" -a \"${CFG_UNINSTALL-}\" != 1 ]; then\n+\terr \"cannot install to same directory as installer\"\n+    fi\n+}\n+\n+verbose_msg \"looking for install programs\"\n+verbose_msg\n+\n+need_cmd mkdir\n+need_cmd printf\n+need_cmd cut\n+need_cmd grep\n+need_cmd uname\n+need_cmd tr\n+need_cmd sed\n+need_cmd chmod\n+need_cmd env\n+need_cmd pwd\n+\n+CFG_ARGS=\"${@:-}\"\n+\n+HELP=0\n+if [ \"${1-}\" = \"--help\" ]\n+then\n+    HELP=1\n+    shift\n+    echo\n+    echo \"Usage: $0 [options]\"\n+    echo\n+    echo \"Options:\"\n+    echo\n+else\n+    verbose_step_msg \"processing arguments\"\n+fi\n+\n+OPTIONS=\"\"\n+BOOL_OPTIONS=\"\"\n+VAL_OPTIONS=\"\"\n+\n+flag uninstall \"only uninstall from the installation prefix\"\n+valopt destdir \"\" \"set installation root\"\n+valopt prefix \"/usr/local\" \"set installation prefix\"\n+\n+# Avoid prepending an extra / to the prefix path if there's no destdir\n+# NB: CFG vars here are undefined when passing --help\n+if [ -z \"${CFG_DESTDIR-}\" ]; then\n+    CFG_DESTDIR_PREFIX=\"${CFG_PREFIX-}\"\n+else\n+    CFG_DESTDIR_PREFIX=\"$CFG_DESTDIR/$CFG_PREFIX\"\n+fi\n+\n+# NB This isn't quite the same definition as in `configure`.\n+# just using 'lib' instead of configure's CFG_LIBDIR_RELATIVE\n+valopt without \"\" \"comma-separated list of components to not install\"\n+valopt components \"\" \"comma-separated list of components to install\"\n+flag list-components \"list available components\"\n+valopt sysconfdir \"$CFG_DESTDIR_PREFIX/etc\" \"install system configuration files\"\n+valopt bindir \"$CFG_DESTDIR_PREFIX/bin\" \"install binaries\"\n+valopt libdir \"$CFG_DESTDIR_PREFIX/lib\" \"install libraries\"\n+valopt datadir \"$CFG_DESTDIR_PREFIX/share\" \"install data\"\n+# NB We repeat datadir default value because we don't set CFG_DATADIR in --help\n+valopt mandir \"${CFG_DATADIR-\"$CFG_DESTDIR_PREFIX/share\"}/man\" \"install man pages in PATH\"\n+# NB See the docdir handling in install_components for an explanation of this\n+# weird <default> string\n+valopt docdir \"\\<default\\>\" \"install documentation in PATH\"\n+opt ldconfig 1 \"run ldconfig after installation (Linux only)\"\n+opt verify 1 \"obsolete\"\n+flag verbose \"run with verbose output\"\n+\n+if [ $HELP -eq 1 ]\n+then\n+    echo\n+    exit 0\n+fi\n+\n+verbose_step_msg \"validating arguments\"\n+validate_opt\n+\n+# Template configuration.\n+# These names surrounded by '%%` are replaced by sed when generating install.sh\n+# FIXME: Might want to consider loading this from a file and not generating install.sh\n+\n+# Rust or Cargo\n+TEMPLATE_PRODUCT_NAME=%%TEMPLATE_PRODUCT_NAME%%\n+# rustlib or cargo\n+TEMPLATE_REL_MANIFEST_DIR=%%TEMPLATE_REL_MANIFEST_DIR%%\n+# 'Rust is ready to roll.' or 'Cargo is cool to cruise.'\n+TEMPLATE_SUCCESS_MESSAGE=%%TEMPLATE_SUCCESS_MESSAGE%%\n+# Locations to look for directories containing legacy, pre-versioned manifests\n+TEMPLATE_LEGACY_MANIFEST_DIRS=%%TEMPLATE_LEGACY_MANIFEST_DIRS%%\n+# The installer version\n+TEMPLATE_RUST_INSTALLER_VERSION=%%TEMPLATE_RUST_INSTALLER_VERSION%%\n+\n+# OK, let's get installing ...\n+\n+# This is where we are installing from\n+src_dir=\"$(abs_path $(dirname \"$0\"))\"\n+\n+# The name of the script\n+src_basename=\"$(basename \"$0\")\"\n+\n+# If we've been run as 'uninstall.sh' (from the existing installation)\n+# then we're doing a full uninstall, as opposed to the --uninstall flag\n+# which just means 'uninstall my components'.\n+if [ \"$src_basename\" = \"uninstall.sh\" ]; then\n+    if [ \"${*:-}\" != \"\" ]; then\n+\t# Currently don't know what to do with arguments in this mode\n+\terr \"uninstall.sh does not take any arguments\"\n+    fi\n+    CFG_UNINSTALL=1\n+    CFG_DESTDIR_PREFIX=\"$(abs_path \"$src_dir/../../\")\"\n+    CFG_LIBDIR=\"$(abs_path \"$src_dir/../\")\"\n+fi\n+\n+# This is where we are installing to\n+dest_prefix=\"$CFG_DESTDIR_PREFIX\"\n+\n+# Open the components file to get the list of components to install.\n+# NB: During install this components file is read from the installer's\n+# source dir, during a full uninstall it's read from the manifest dir,\n+# and thus contains all installed components.\n+components=`cat \"$src_dir/components\"`\n+\n+# Sanity check: do we have components?\n+if [ ! -n \"$components\" ]; then\n+    err \"unable to find installation components\"\n+fi\n+\n+# If the user asked for a component list, do that and exit\n+if [ -n \"${CFG_LIST_COMPONENTS-}\" ]; then\n+    echo\n+    echo \"# Available components\"\n+    echo\n+    for component in $components; do\n+\techo \"* $component\"\n+    done\n+    echo\n+    exit 0\n+fi\n+\n+# If the user specified which components to install/uninstall,\n+# then validate that they exist and select them for installation\n+if [ -n \"$CFG_COMPONENTS\" ]; then\n+    # Remove commas\n+    user_components=\"$(echo \"$CFG_COMPONENTS\" | sed \"s/,/ /g\")\"\n+    for user_component in $user_components; do\n+\tfound=false\n+\tfor my_component in $components; do\n+\t    if [ \"$user_component\" = \"$my_component\" ]; then\n+\t\tfound=true\n+\t    fi\n+\tdone\n+\tif [ \"$found\" = false ]; then\n+\t    err \"unknown component: $user_component\"\n+\tfi\n+    done\n+    components=\"$user_components\"\n+fi\n+\n+if [ -n \"$CFG_WITHOUT\" ]; then\n+    without_components=\"$(echo \"$CFG_WITHOUT\" | sed \"s/,/ /g\")\"\n+\n+    # This does **not** check that all components in without_components are\n+    # actually present in the list of available components.\n+    #\n+    # Currently that's considered good as it makes it easier to be compatible\n+    # with multiple Rust versions (which may change the exact list of\n+    # components) when writing install scripts.\n+    new_comp=\"\"\n+    for component in $components; do\n+        found=false\n+        for my_component in $without_components; do\n+            if [ \"$component\" = \"$my_component\" ]; then\n+                found=true\n+            fi\n+        done\n+        if [ \"$found\" = false ]; then\n+            # If we didn't find the component in without, then add it to new list.\n+            new_comp=\"$new_comp $component\"\n+        fi\n+    done\n+    components=\"$new_comp\"\n+fi\n+\n+if [ -z \"$components\" ]; then\n+    if [ -z \"${CFG_UNINSTALL-}\" ]; then\n+\terr \"no components selected for installation\"\n+    else\n+\terr \"no components selected for uninstallation\"\n+    fi\n+fi\n+\n+do_preflight_sanity_checks \"$src_dir\" \"$dest_prefix\"\n+\n+# Using an absolute path to libdir in a few places so that the status\n+# messages are consistently using absolute paths.\n+absolutify \"$CFG_LIBDIR\"\n+abs_libdir=\"$RETVAL\"\n+assert_nz \"$abs_libdir\" \"abs_libdir\"\n+\n+# Create the manifest directory, where we will put our logs\n+make_dir_recursive \"$abs_libdir/$TEMPLATE_REL_MANIFEST_DIR\"\n+need_ok \"failed to create $TEMPLATE_REL_MANIFEST_DIR\"\n+\n+# Log messages and commands\n+init_logging \"$abs_libdir\"\n+\n+# First do any uninstallation, including from legacy manifests. This\n+# will also upgrade the metadata of existing installs.\n+uninstall_components \"$abs_libdir\" \"$dest_prefix\" \"$components\"\n+\n+# If we're only uninstalling then exit\n+if [ -n \"${CFG_UNINSTALL-}\" ]\n+then\n+    echo\n+    echo \"    $TEMPLATE_PRODUCT_NAME is uninstalled.\"\n+    echo\n+    exit 0\n+fi\n+\n+# Create the manifest directory again! uninstall_legacy\n+# may have deleted it.\n+make_dir_recursive \"$abs_libdir/$TEMPLATE_REL_MANIFEST_DIR\"\n+need_ok \"failed to create $TEMPLATE_REL_MANIFEST_DIR\"\n+\n+# Drop the version number into the manifest dir\n+write_to_file \"$TEMPLATE_RUST_INSTALLER_VERSION\" \"$abs_libdir/$TEMPLATE_REL_MANIFEST_DIR/rust-installer-version\"\n+critical_need_ok \"failed to write installer version\"\n+\n+# Install the uninstaller\n+install_uninstaller \"$src_dir\" \"$src_basename\" \"$abs_libdir\"\n+\n+# Install each component\n+install_components \"$src_dir\" \"$abs_libdir\" \"$dest_prefix\" \"$components\"\n+\n+# Make dynamic libraries available to the linker\n+maybe_configure_ld \"$abs_libdir\"\n+\n+echo\n+echo \"    $TEMPLATE_SUCCESS_MESSAGE\"\n+echo\n+\n+"}, {"sha": "e9f88cc8b7186ee00c63d3d8534377914a261195", "filename": "src/tools/rust-installer/make-tarballs.sh", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Fmake-tarballs.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Fmake-tarballs.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fmake-tarballs.sh?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1,24 @@\n+#!/bin/sh\n+# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ue\n+\n+# Prints the absolute path of a directory to stdout\n+abs_path() {\n+    local path=\"$1\"\n+    # Unset CDPATH because it causes havok: it makes the destination unpredictable\n+    # and triggers 'cd' to print the path to stdout. Route `cd`'s output to /dev/null\n+    # for good measure.\n+    (unset CDPATH && cd \"$path\" > /dev/null && pwd)\n+}\n+\n+src_dir=\"$(abs_path $(dirname \"$0\"))\"\n+cargo run --manifest-path=\"$src_dir/Cargo.toml\" -- tarball \"$@\""}, {"sha": "e440e5c842586965a7fb77deda2eca68612b1f53", "filename": "src/tools/rust-installer/rust-installer-version", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Frust-installer-version", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Frust-installer-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Frust-installer-version?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1 @@\n+3\n\\ No newline at end of file"}, {"sha": "2ec09d67e3e62acca475575e88962fc42870f5d5", "filename": "src/tools/rust-installer/src/combiner.rs", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Fsrc%2Fcombiner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Fsrc%2Fcombiner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fsrc%2Fcombiner.rs?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1,161 @@\n+use super::Scripter;\n+use super::Tarballer;\n+use crate::{\n+    compression::{CompressionFormat, CompressionFormats},\n+    util::*,\n+};\n+use anyhow::{bail, Context, Result};\n+use std::io::{Read, Write};\n+use std::path::Path;\n+use tar::Archive;\n+\n+actor! {\n+    #[derive(Debug)]\n+    pub struct Combiner {\n+        /// The name of the product, for display.\n+        #[clap(value_name = \"NAME\")]\n+        product_name: String = \"Product\",\n+\n+        /// The name of the package  tarball.\n+        #[clap(value_name = \"NAME\")]\n+        package_name: String = \"package\",\n+\n+        /// The directory under lib/ where the manifest lives.\n+        #[clap(value_name = \"DIR\")]\n+        rel_manifest_dir: String = \"packagelib\",\n+\n+        /// The string to print after successful installation.\n+        #[clap(value_name = \"MESSAGE\")]\n+        success_message: String = \"Installed.\",\n+\n+        /// Places to look for legacy manifests to uninstall.\n+        #[clap(value_name = \"DIRS\")]\n+        legacy_manifest_dirs: String = \"\",\n+\n+        /// Installers to combine.\n+        #[clap(value_name = \"FILE,FILE\")]\n+        input_tarballs: String = \"\",\n+\n+        /// Directory containing files that should not be installed.\n+        #[clap(value_name = \"DIR\")]\n+        non_installed_overlay: String = \"\",\n+\n+        /// The directory to do temporary work.\n+        #[clap(value_name = \"DIR\")]\n+        work_dir: String = \"./workdir\",\n+\n+        /// The location to put the final image and tarball.\n+        #[clap(value_name = \"DIR\")]\n+        output_dir: String = \"./dist\",\n+\n+        /// The formats used to compress the tarball\n+        #[clap(value_name = \"FORMAT\", default_value_t)]\n+        compression_formats: CompressionFormats,\n+    }\n+}\n+\n+impl Combiner {\n+    /// Combines the installer tarballs.\n+    pub fn run(self) -> Result<()> {\n+        create_dir_all(&self.work_dir)?;\n+\n+        let package_dir = Path::new(&self.work_dir).join(&self.package_name);\n+        if package_dir.exists() {\n+            remove_dir_all(&package_dir)?;\n+        }\n+        create_dir_all(&package_dir)?;\n+\n+        // Merge each installer into the work directory of the new installer.\n+        let components = create_new_file(package_dir.join(\"components\"))?;\n+        for input_tarball in self\n+            .input_tarballs\n+            .split(',')\n+            .map(str::trim)\n+            .filter(|s| !s.is_empty())\n+        {\n+            // Extract the input tarballs\n+            let compression =\n+                CompressionFormat::detect_from_path(input_tarball).ok_or_else(|| {\n+                    anyhow::anyhow!(\"couldn't figure out the format of {}\", input_tarball)\n+                })?;\n+            Archive::new(compression.decode(input_tarball)?)\n+                .unpack(&self.work_dir)\n+                .with_context(|| {\n+                    format!(\n+                        \"unable to extract '{}' into '{}'\",\n+                        &input_tarball, self.work_dir\n+                    )\n+                })?;\n+\n+            let pkg_name =\n+                input_tarball.trim_end_matches(&format!(\".tar.{}\", compression.extension()));\n+            let pkg_name = Path::new(pkg_name).file_name().unwrap();\n+            let pkg_dir = Path::new(&self.work_dir).join(&pkg_name);\n+\n+            // Verify the version number.\n+            let mut version = String::new();\n+            open_file(pkg_dir.join(\"rust-installer-version\"))\n+                .and_then(|mut file| Ok(file.read_to_string(&mut version)?))\n+                .with_context(|| format!(\"failed to read version in '{}'\", input_tarball))?;\n+            if version.trim().parse() != Ok(crate::RUST_INSTALLER_VERSION) {\n+                bail!(\"incorrect installer version in {}\", input_tarball);\n+            }\n+\n+            // Copy components to the new combined installer.\n+            let mut pkg_components = String::new();\n+            open_file(pkg_dir.join(\"components\"))\n+                .and_then(|mut file| Ok(file.read_to_string(&mut pkg_components)?))\n+                .with_context(|| format!(\"failed to read components in '{}'\", input_tarball))?;\n+            for component in pkg_components.split_whitespace() {\n+                // All we need to do is copy the component directory. We could\n+                // move it, but rustbuild wants to reuse the unpacked package\n+                // dir for OS-specific installers on macOS and Windows.\n+                let component_dir = package_dir.join(&component);\n+                create_dir(&component_dir)?;\n+                copy_recursive(&pkg_dir.join(&component), &component_dir)?;\n+\n+                // Merge the component name.\n+                writeln!(&components, \"{}\", component).context(\"failed to write new components\")?;\n+            }\n+        }\n+        drop(components);\n+\n+        // Write the installer version.\n+        let version = package_dir.join(\"rust-installer-version\");\n+        writeln!(\n+            create_new_file(version)?,\n+            \"{}\",\n+            crate::RUST_INSTALLER_VERSION\n+        )\n+        .context(\"failed to write new installer version\")?;\n+\n+        // Copy the overlay.\n+        if !self.non_installed_overlay.is_empty() {\n+            copy_recursive(self.non_installed_overlay.as_ref(), &package_dir)?;\n+        }\n+\n+        // Generate the install script.\n+        let output_script = package_dir.join(\"install.sh\");\n+        let mut scripter = Scripter::default();\n+        scripter\n+            .product_name(self.product_name)\n+            .rel_manifest_dir(self.rel_manifest_dir)\n+            .success_message(self.success_message)\n+            .legacy_manifest_dirs(self.legacy_manifest_dirs)\n+            .output_script(path_to_str(&output_script)?.into());\n+        scripter.run()?;\n+\n+        // Make the tarballs.\n+        create_dir_all(&self.output_dir)?;\n+        let output = Path::new(&self.output_dir).join(&self.package_name);\n+        let mut tarballer = Tarballer::default();\n+        tarballer\n+            .work_dir(self.work_dir)\n+            .input(self.package_name)\n+            .output(path_to_str(&output)?.into())\n+            .compression_formats(self.compression_formats.clone());\n+        tarballer.run()?;\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "9b176982d000d15125b2a38f2c0452839dc7e374", "filename": "src/tools/rust-installer/src/compression.rs", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Fsrc%2Fcompression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Fsrc%2Fcompression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fsrc%2Fcompression.rs?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1,203 @@\n+use anyhow::{Context, Error};\n+use flate2::{read::GzDecoder, write::GzEncoder};\n+use rayon::prelude::*;\n+use std::{convert::TryFrom, fmt, io::Read, io::Write, path::Path, str::FromStr};\n+use xz2::{read::XzDecoder, write::XzEncoder};\n+\n+#[derive(Debug, Copy, Clone)]\n+pub enum CompressionFormat {\n+    Gz,\n+    Xz,\n+}\n+\n+impl CompressionFormat {\n+    pub(crate) fn detect_from_path(path: impl AsRef<Path>) -> Option<Self> {\n+        match path.as_ref().extension().and_then(|e| e.to_str()) {\n+            Some(\"gz\") => Some(CompressionFormat::Gz),\n+            Some(\"xz\") => Some(CompressionFormat::Xz),\n+            _ => None,\n+        }\n+    }\n+\n+    pub(crate) fn extension(&self) -> &'static str {\n+        match self {\n+            CompressionFormat::Gz => \"gz\",\n+            CompressionFormat::Xz => \"xz\",\n+        }\n+    }\n+\n+    pub(crate) fn encode(&self, path: impl AsRef<Path>) -> Result<Box<dyn Encoder>, Error> {\n+        let mut os = path.as_ref().as_os_str().to_os_string();\n+        os.push(format!(\".{}\", self.extension()));\n+        let path = Path::new(&os);\n+\n+        if path.exists() {\n+            crate::util::remove_file(path)?;\n+        }\n+        let file = crate::util::create_new_file(path)?;\n+\n+        Ok(match self {\n+            CompressionFormat::Gz => Box::new(GzEncoder::new(file, flate2::Compression::best())),\n+            CompressionFormat::Xz => {\n+                let mut filters = xz2::stream::Filters::new();\n+                // the preset is overridden by the other options so it doesn't matter\n+                let mut lzma_ops = xz2::stream::LzmaOptions::new_preset(9).unwrap();\n+                // This sets the overall dictionary size, which is also how much memory (baseline)\n+                // is needed for decompression.\n+                lzma_ops.dict_size(64 * 1024 * 1024);\n+                // Use the best match finder for compression ratio.\n+                lzma_ops.match_finder(xz2::stream::MatchFinder::BinaryTree4);\n+                lzma_ops.mode(xz2::stream::Mode::Normal);\n+                // Set nice len to the maximum for best compression ratio\n+                lzma_ops.nice_len(273);\n+                // Set depth to a reasonable value, 0 means auto, 1000 is somwhat high but gives\n+                // good results.\n+                lzma_ops.depth(1000);\n+                // 2 is the default and does well for most files\n+                lzma_ops.position_bits(2);\n+                // 0 is the default and does well for most files\n+                lzma_ops.literal_position_bits(0);\n+                // 3 is the default and does well for most files\n+                lzma_ops.literal_context_bits(3);\n+\n+                filters.lzma2(&lzma_ops);\n+                let compressor = XzEncoder::new_stream(\n+                    std::io::BufWriter::new(file),\n+                    xz2::stream::MtStreamBuilder::new()\n+                        .threads(1)\n+                        .filters(filters)\n+                        .encoder()\n+                        .unwrap(),\n+                );\n+                Box::new(compressor)\n+            }\n+        })\n+    }\n+\n+    pub(crate) fn decode(&self, path: impl AsRef<Path>) -> Result<Box<dyn Read>, Error> {\n+        let file = crate::util::open_file(path.as_ref())?;\n+        Ok(match self {\n+            CompressionFormat::Gz => Box::new(GzDecoder::new(file)),\n+            CompressionFormat::Xz => Box::new(XzDecoder::new(file)),\n+        })\n+    }\n+}\n+\n+/// This struct wraps Vec<CompressionFormat> in order to parse the value from the command line.\n+#[derive(Debug, Clone)]\n+pub struct CompressionFormats(Vec<CompressionFormat>);\n+\n+impl TryFrom<&'_ str> for CompressionFormats {\n+    type Error = Error;\n+\n+    fn try_from(value: &str) -> Result<Self, Self::Error> {\n+        let mut parsed = Vec::new();\n+        for format in value.split(',') {\n+            match format.trim() {\n+                \"gz\" => parsed.push(CompressionFormat::Gz),\n+                \"xz\" => parsed.push(CompressionFormat::Xz),\n+                other => anyhow::bail!(\"unknown compression format: {}\", other),\n+            }\n+        }\n+        Ok(CompressionFormats(parsed))\n+    }\n+}\n+\n+impl FromStr for CompressionFormats {\n+    type Err = Error;\n+\n+    fn from_str(value: &str) -> Result<Self, Self::Err> {\n+        Self::try_from(value)\n+    }\n+}\n+\n+impl fmt::Display for CompressionFormats {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        for (i, format) in self.iter().enumerate() {\n+            if i != 0 {\n+                write!(f, \",\")?;\n+            }\n+            fmt::Display::fmt(\n+                match format {\n+                    CompressionFormat::Xz => \"xz\",\n+                    CompressionFormat::Gz => \"gz\",\n+                },\n+                f,\n+            )?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl Default for CompressionFormats {\n+    fn default() -> Self {\n+        Self(vec![CompressionFormat::Gz, CompressionFormat::Xz])\n+    }\n+}\n+\n+impl CompressionFormats {\n+    pub(crate) fn iter(&self) -> impl Iterator<Item = CompressionFormat> + '_ {\n+        self.0.iter().map(|i| *i)\n+    }\n+}\n+\n+pub(crate) trait Encoder: Send + Write {\n+    fn finish(self: Box<Self>) -> Result<(), Error>;\n+}\n+\n+impl<W: Send + Write> Encoder for GzEncoder<W> {\n+    fn finish(self: Box<Self>) -> Result<(), Error> {\n+        GzEncoder::finish(*self).context(\"failed to finish .gz file\")?;\n+        Ok(())\n+    }\n+}\n+\n+impl<W: Send + Write> Encoder for XzEncoder<W> {\n+    fn finish(self: Box<Self>) -> Result<(), Error> {\n+        XzEncoder::finish(*self).context(\"failed to finish .xz file\")?;\n+        Ok(())\n+    }\n+}\n+\n+pub(crate) struct CombinedEncoder {\n+    encoders: Vec<Box<dyn Encoder>>,\n+}\n+\n+impl CombinedEncoder {\n+    pub(crate) fn new(encoders: Vec<Box<dyn Encoder>>) -> Box<dyn Encoder> {\n+        Box::new(Self { encoders })\n+    }\n+}\n+\n+impl Write for CombinedEncoder {\n+    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {\n+        self.write_all(buf)?;\n+        Ok(buf.len())\n+    }\n+\n+    fn write_all(&mut self, buf: &[u8]) -> std::io::Result<()> {\n+        self.encoders\n+            .par_iter_mut()\n+            .map(|w| w.write_all(buf))\n+            .collect::<std::io::Result<Vec<()>>>()?;\n+        Ok(())\n+    }\n+\n+    fn flush(&mut self) -> std::io::Result<()> {\n+        self.encoders\n+            .par_iter_mut()\n+            .map(|w| w.flush())\n+            .collect::<std::io::Result<Vec<()>>>()?;\n+        Ok(())\n+    }\n+}\n+\n+impl Encoder for CombinedEncoder {\n+    fn finish(self: Box<Self>) -> Result<(), Error> {\n+        self.encoders\n+            .into_par_iter()\n+            .map(|e| e.finish())\n+            .collect::<Result<Vec<()>, Error>>()?;\n+        Ok(())\n+    }\n+}"}, {"sha": "1e4d00b0553aa25ea43709bdf267c23956993254", "filename": "src/tools/rust-installer/src/generator.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fsrc%2Fgenerator.rs?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1,178 @@\n+use super::Scripter;\n+use super::Tarballer;\n+use crate::compression::CompressionFormats;\n+use crate::util::*;\n+use anyhow::{bail, format_err, Context, Result};\n+use std::collections::BTreeSet;\n+use std::io::Write;\n+use std::path::Path;\n+\n+actor! {\n+    #[derive(Debug)]\n+    pub struct Generator {\n+        /// The name of the product, for display\n+        #[clap(value_name = \"NAME\")]\n+        product_name: String = \"Product\",\n+\n+        /// The name of the component, distinct from other installed components\n+        #[clap(value_name = \"NAME\")]\n+        component_name: String = \"component\",\n+\n+        /// The name of the package, tarball\n+        #[clap(value_name = \"NAME\")]\n+        package_name: String = \"package\",\n+\n+        /// The directory under lib/ where the manifest lives\n+        #[clap(value_name = \"DIR\")]\n+        rel_manifest_dir: String = \"packagelib\",\n+\n+        /// The string to print after successful installation\n+        #[clap(value_name = \"MESSAGE\")]\n+        success_message: String = \"Installed.\",\n+\n+        /// Places to look for legacy manifests to uninstall\n+        #[clap(value_name = \"DIRS\")]\n+        legacy_manifest_dirs: String = \"\",\n+\n+        /// Directory containing files that should not be installed\n+        #[clap(value_name = \"DIR\")]\n+        non_installed_overlay: String = \"\",\n+\n+        /// Path prefixes of directories that should be installed/uninstalled in bulk\n+        #[clap(value_name = \"DIRS\")]\n+        bulk_dirs: String = \"\",\n+\n+        /// The directory containing the installation medium\n+        #[clap(value_name = \"DIR\")]\n+        image_dir: String = \"./install_image\",\n+\n+        /// The directory to do temporary work\n+        #[clap(value_name = \"DIR\")]\n+        work_dir: String = \"./workdir\",\n+\n+        /// The location to put the final image and tarball\n+        #[clap(value_name = \"DIR\")]\n+        output_dir: String = \"./dist\",\n+\n+        /// The formats used to compress the tarball\n+        #[clap(value_name = \"FORMAT\", default_value_t)]\n+        compression_formats: CompressionFormats,\n+    }\n+}\n+\n+impl Generator {\n+    /// Generates the actual installer tarball\n+    pub fn run(self) -> Result<()> {\n+        create_dir_all(&self.work_dir)?;\n+\n+        let package_dir = Path::new(&self.work_dir).join(&self.package_name);\n+        if package_dir.exists() {\n+            remove_dir_all(&package_dir)?;\n+        }\n+\n+        // Copy the image and write the manifest\n+        let component_dir = package_dir.join(&self.component_name);\n+        create_dir_all(&component_dir)?;\n+        copy_and_manifest(self.image_dir.as_ref(), &component_dir, &self.bulk_dirs)?;\n+\n+        // Write the component name\n+        let components = package_dir.join(\"components\");\n+        writeln!(create_new_file(components)?, \"{}\", self.component_name)\n+            .context(\"failed to write the component file\")?;\n+\n+        // Write the installer version (only used by combine-installers.sh)\n+        let version = package_dir.join(\"rust-installer-version\");\n+        writeln!(\n+            create_new_file(version)?,\n+            \"{}\",\n+            crate::RUST_INSTALLER_VERSION\n+        )\n+        .context(\"failed to write new installer version\")?;\n+\n+        // Copy the overlay\n+        if !self.non_installed_overlay.is_empty() {\n+            copy_recursive(self.non_installed_overlay.as_ref(), &package_dir)?;\n+        }\n+\n+        // Generate the install script\n+        let output_script = package_dir.join(\"install.sh\");\n+        let mut scripter = Scripter::default();\n+        scripter\n+            .product_name(self.product_name)\n+            .rel_manifest_dir(self.rel_manifest_dir)\n+            .success_message(self.success_message)\n+            .legacy_manifest_dirs(self.legacy_manifest_dirs)\n+            .output_script(path_to_str(&output_script)?.into());\n+        scripter.run()?;\n+\n+        // Make the tarballs\n+        create_dir_all(&self.output_dir)?;\n+        let output = Path::new(&self.output_dir).join(&self.package_name);\n+        let mut tarballer = Tarballer::default();\n+        tarballer\n+            .work_dir(self.work_dir)\n+            .input(self.package_name)\n+            .output(path_to_str(&output)?.into())\n+            .compression_formats(self.compression_formats.clone());\n+        tarballer.run()?;\n+\n+        Ok(())\n+    }\n+}\n+\n+/// Copies the `src` directory recursively to `dst`, writing `manifest.in` too.\n+fn copy_and_manifest(src: &Path, dst: &Path, bulk_dirs: &str) -> Result<()> {\n+    let mut manifest = create_new_file(dst.join(\"manifest.in\"))?;\n+    let bulk_dirs: Vec<_> = bulk_dirs\n+        .split(',')\n+        .filter(|s| !s.is_empty())\n+        .map(Path::new)\n+        .collect();\n+\n+    let mut paths = BTreeSet::new();\n+    copy_with_callback(src, dst, |path, file_type| {\n+        // We need paths to be compatible with both Unix and Windows.\n+        if path\n+            .components()\n+            .filter_map(|c| c.as_os_str().to_str())\n+            .any(|s| s.contains('\\\\'))\n+        {\n+            bail!(\n+                \"rust-installer doesn't support '\\\\' in path components: {:?}\",\n+                path\n+            );\n+        }\n+\n+        // Normalize to Unix-style path separators.\n+        let normalized_string;\n+        let mut string = path.to_str().ok_or_else(|| {\n+            format_err!(\n+                \"rust-installer doesn't support non-Unicode paths: {:?}\",\n+                path\n+            )\n+        })?;\n+        if string.contains('\\\\') {\n+            normalized_string = string.replace('\\\\', \"/\");\n+            string = &normalized_string;\n+        }\n+\n+        if file_type.is_dir() {\n+            // Only manifest directories that are explicitly bulk.\n+            if bulk_dirs.contains(&path) {\n+                paths.insert(format!(\"dir:{}\\n\", string));\n+            }\n+        } else {\n+            // Only manifest files that aren't under bulk directories.\n+            if !bulk_dirs.iter().any(|d| path.starts_with(d)) {\n+                paths.insert(format!(\"file:{}\\n\", string));\n+            }\n+        }\n+        Ok(())\n+    })?;\n+\n+    for path in paths {\n+        manifest.write_all(path.as_bytes())?;\n+    }\n+\n+    Ok(())\n+}"}, {"sha": "7990920192a6c0ac2d10a77600d6f140fe6261bf", "filename": "src/tools/rust-installer/src/lib.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fsrc%2Flib.rs?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1,17 @@\n+#[macro_use]\n+mod util;\n+\n+mod combiner;\n+mod compression;\n+mod generator;\n+mod scripter;\n+mod tarballer;\n+\n+pub use crate::combiner::Combiner;\n+pub use crate::generator::Generator;\n+pub use crate::scripter::Scripter;\n+pub use crate::tarballer::Tarballer;\n+\n+/// The installer version, output only to be used by combine-installers.sh.\n+/// (should match `SOURCE_DIRECTORY/rust_installer_version`)\n+pub const RUST_INSTALLER_VERSION: u32 = 3;"}, {"sha": "be8a0d68343e4c2a0804d0f9846cf210649a6962", "filename": "src/tools/rust-installer/src/main.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fsrc%2Fmain.rs?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1,27 @@\n+use anyhow::{Context, Result};\n+use clap::{self, Parser};\n+\n+#[derive(Parser)]\n+struct CommandLine {\n+    #[clap(subcommand)]\n+    command: Subcommand,\n+}\n+\n+#[derive(clap::Subcommand)]\n+enum Subcommand {\n+    Generate(installer::Generator),\n+    Combine(installer::Combiner),\n+    Script(installer::Scripter),\n+    Tarball(installer::Tarballer),\n+}\n+\n+fn main() -> Result<()> {\n+    let command_line = CommandLine::parse();\n+    match command_line.command {\n+        Subcommand::Combine(combiner) => combiner.run().context(\"failed to combine installers\")?,\n+        Subcommand::Generate(generator) => generator.run().context(\"failed to generate installer\")?,\n+        Subcommand::Script(scripter) => scripter.run().context(\"failed to generate installation script\")?,\n+        Subcommand::Tarball(tarballer) => tarballer.run().context(\"failed to generate tarballs\")?,\n+    }\n+    Ok(())\n+}"}, {"sha": "11097652865c4221bbddffce70c35744c29fee0a", "filename": "src/tools/rust-installer/src/remove_dir_all.rs", "status": "added", "additions": 860, "deletions": 0, "changes": 860, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Fsrc%2Fremove_dir_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Fsrc%2Fremove_dir_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fsrc%2Fremove_dir_all.rs?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1,860 @@\n+#![allow(non_snake_case)]\n+\n+use std::io;\n+use std::path::Path;\n+\n+#[cfg(not(windows))]\n+pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n+    ::std::fs::remove_dir_all(path)\n+}\n+\n+#[cfg(windows)]\n+pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n+    win::remove_dir_all(path)\n+}\n+\n+#[cfg(windows)]\n+mod win {\n+    use winapi::ctypes::{c_uint, c_ushort};\n+    use winapi::shared::minwindef::{BOOL, DWORD, FALSE, FILETIME, LPVOID};\n+    use winapi::shared::winerror::{\n+        ERROR_CALL_NOT_IMPLEMENTED, ERROR_INSUFFICIENT_BUFFER, ERROR_NO_MORE_FILES,\n+    };\n+    use winapi::um::errhandlingapi::{GetLastError, SetLastError};\n+    use winapi::um::fileapi::{\n+        CreateFileW, FindFirstFileW, FindNextFileW, GetFileInformationByHandle,\n+    };\n+    use winapi::um::fileapi::{BY_HANDLE_FILE_INFORMATION, CREATE_ALWAYS, CREATE_NEW};\n+    use winapi::um::fileapi::{FILE_BASIC_INFO, FILE_RENAME_INFO, TRUNCATE_EXISTING};\n+    use winapi::um::fileapi::{OPEN_ALWAYS, OPEN_EXISTING};\n+    use winapi::um::handleapi::{CloseHandle, INVALID_HANDLE_VALUE};\n+    use winapi::um::ioapiset::DeviceIoControl;\n+    use winapi::um::libloaderapi::{GetModuleHandleW, GetProcAddress};\n+    use winapi::um::minwinbase::{\n+        FileBasicInfo, FileRenameInfo, FILE_INFO_BY_HANDLE_CLASS, WIN32_FIND_DATAW,\n+    };\n+    use winapi::um::winbase::SECURITY_SQOS_PRESENT;\n+    use winapi::um::winbase::{\n+        FILE_FLAG_BACKUP_SEMANTICS, FILE_FLAG_DELETE_ON_CLOSE, FILE_FLAG_OPEN_REPARSE_POINT,\n+    };\n+    use winapi::um::winioctl::FSCTL_GET_REPARSE_POINT;\n+    use winapi::um::winnt::{DELETE, FILE_ATTRIBUTE_DIRECTORY, HANDLE, LPCWSTR};\n+    use winapi::um::winnt::{FILE_ATTRIBUTE_READONLY, FILE_ATTRIBUTE_REPARSE_POINT};\n+    use winapi::um::winnt::{FILE_GENERIC_WRITE, FILE_WRITE_DATA, GENERIC_READ, GENERIC_WRITE};\n+    use winapi::um::winnt::{FILE_READ_ATTRIBUTES, FILE_WRITE_ATTRIBUTES};\n+    use winapi::um::winnt::{FILE_SHARE_DELETE, FILE_SHARE_READ, FILE_SHARE_WRITE};\n+    use winapi::um::winnt::{IO_REPARSE_TAG_MOUNT_POINT, IO_REPARSE_TAG_SYMLINK, LARGE_INTEGER};\n+\n+    use std::ffi::{OsStr, OsString};\n+    use std::io;\n+    use std::mem;\n+    use std::os::windows::ffi::{OsStrExt, OsStringExt};\n+    use std::path::{Path, PathBuf};\n+    use std::ptr;\n+    use std::sync::Arc;\n+\n+    pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n+        // On Windows it is not enough to just recursively remove the contents of a\n+        // directory and then the directory itself. Deleting does not happen\n+        // instantaneously, but is scheduled.\n+        // To work around this, we move the file or directory to some `base_dir`\n+        // right before deletion to avoid races.\n+        //\n+        // As `base_dir` we choose the parent dir of the directory we want to\n+        // remove. We very probably have permission to create files here, as we\n+        // already need write permission in this dir to delete the directory. And it\n+        // should be on the same volume.\n+        //\n+        // To handle files with names like `CON` and `morse .. .`, and when a\n+        // directory structure is so deep it needs long path names the path is first\n+        // converted to a `//?/`-path with `get_path()`.\n+        //\n+        // To make sure we don't leave a moved file laying around if the process\n+        // crashes before we can delete the file, we do all operations on an file\n+        // handle. By opening a file with `FILE_FLAG_DELETE_ON_CLOSE` Windows will\n+        // always delete the file when the handle closes.\n+        //\n+        // All files are renamed to be in the `base_dir`, and have their name\n+        // changed to \"rm-<counter>\". After every rename the counter is increased.\n+        // Rename should not overwrite possibly existing files in the base dir. So\n+        // if it fails with `AlreadyExists`, we just increase the counter and try\n+        // again.\n+        //\n+        // For read-only files and directories we first have to remove the read-only\n+        // attribute before we can move or delete them. This also removes the\n+        // attribute from possible hardlinks to the file, so just before closing we\n+        // restore the read-only attribute.\n+        //\n+        // If 'path' points to a directory symlink or junction we should not\n+        // recursively remove the target of the link, but only the link itself.\n+        //\n+        // Moving and deleting is guaranteed to succeed if we are able to open the\n+        // file with `DELETE` permission. If others have the file open we only have\n+        // `DELETE` permission if they have specified `FILE_SHARE_DELETE`. We can\n+        // also delete the file now, but it will not disappear until all others have\n+        // closed the file. But no-one can open the file after we have flagged it\n+        // for deletion.\n+\n+        // Open the path once to get the canonical path, file type and attributes.\n+        let (path, metadata) = {\n+            let mut opts = OpenOptions::new();\n+            opts.access_mode(FILE_READ_ATTRIBUTES);\n+            opts.custom_flags(FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT);\n+            let file = File::open(path, &opts)?;\n+            (get_path(&file)?, file.file_attr()?)\n+        };\n+\n+        let mut ctx = RmdirContext {\n+            base_dir: match path.parent() {\n+                Some(dir) => dir,\n+                None => {\n+                    return Err(io::Error::new(\n+                        io::ErrorKind::PermissionDenied,\n+                        \"can't delete root directory\",\n+                    ))\n+                }\n+            },\n+            readonly: metadata.perm().readonly(),\n+            counter: 0,\n+        };\n+\n+        let filetype = metadata.file_type();\n+        if filetype.is_dir() {\n+            remove_dir_all_recursive(path.as_ref(), &mut ctx)\n+        } else if filetype.is_symlink_dir() {\n+            remove_item(path.as_ref(), &mut ctx)\n+        } else {\n+            Err(io::Error::new(\n+                io::ErrorKind::PermissionDenied,\n+                \"Not a directory\",\n+            ))\n+        }\n+    }\n+\n+    fn readdir(p: &Path) -> io::Result<ReadDir> {\n+        let root = p.to_path_buf();\n+        let star = p.join(\"*\");\n+        let path = to_u16s(&star)?;\n+\n+        unsafe {\n+            let mut wfd = mem::zeroed();\n+            let find_handle = FindFirstFileW(path.as_ptr(), &mut wfd);\n+            if find_handle != INVALID_HANDLE_VALUE {\n+                Ok(ReadDir {\n+                    handle: FindNextFileHandle(find_handle),\n+                    root: Arc::new(root),\n+                    first: Some(wfd),\n+                })\n+            } else {\n+                Err(io::Error::last_os_error())\n+            }\n+        }\n+    }\n+\n+    struct RmdirContext<'a> {\n+        base_dir: &'a Path,\n+        readonly: bool,\n+        counter: u64,\n+    }\n+\n+    fn remove_dir_all_recursive(path: &Path, ctx: &mut RmdirContext) -> io::Result<()> {\n+        let dir_readonly = ctx.readonly;\n+        for child in readdir(path)? {\n+            let child = child?;\n+            let child_type = child.file_type()?;\n+            ctx.readonly = child.metadata()?.perm().readonly();\n+            if child_type.is_dir() {\n+                remove_dir_all_recursive(&child.path(), ctx)?;\n+            } else {\n+                remove_item(&child.path().as_ref(), ctx)?;\n+            }\n+        }\n+        ctx.readonly = dir_readonly;\n+        remove_item(path, ctx)\n+    }\n+\n+    fn remove_item(path: &Path, ctx: &mut RmdirContext) -> io::Result<()> {\n+        if !ctx.readonly {\n+            let mut opts = OpenOptions::new();\n+            opts.access_mode(DELETE);\n+            opts.custom_flags(\n+                FILE_FLAG_BACKUP_SEMANTICS | // delete directory\n+                              FILE_FLAG_OPEN_REPARSE_POINT | // delete symlink\n+                              FILE_FLAG_DELETE_ON_CLOSE,\n+            );\n+            let file = File::open(path, &opts)?;\n+            move_item(&file, ctx)\n+        } else {\n+            // remove read-only permision\n+            set_perm(&path, FilePermissions::new())?;\n+            // move and delete file, similar to !readonly.\n+            // only the access mode is different.\n+            let mut opts = OpenOptions::new();\n+            opts.access_mode(DELETE | FILE_WRITE_ATTRIBUTES);\n+            opts.custom_flags(\n+                FILE_FLAG_BACKUP_SEMANTICS\n+                    | FILE_FLAG_OPEN_REPARSE_POINT\n+                    | FILE_FLAG_DELETE_ON_CLOSE,\n+            );\n+            let file = File::open(path, &opts)?;\n+            move_item(&file, ctx)?;\n+            // restore read-only flag just in case there are other hard links\n+            let mut perm = FilePermissions::new();\n+            perm.set_readonly(true);\n+            let _ = file.set_perm(perm); // ignore if this fails\n+            Ok(())\n+        }\n+    }\n+\n+    macro_rules! compat_fn {\n+        ($module:ident: $(\n+            fn $symbol:ident($($argname:ident: $argtype:ty),*)\n+                             -> $rettype:ty {\n+                $($body:expr);*\n+            }\n+        )*) => ($(\n+            #[allow(unused_variables)]\n+            unsafe fn $symbol($($argname: $argtype),*) -> $rettype {\n+                use std::sync::atomic::{AtomicUsize, Ordering};\n+                use std::mem;\n+                use std::ffi::CString;\n+                type F = unsafe extern \"system\" fn($($argtype),*) -> $rettype;\n+\n+                lazy_static! { static ref PTR: AtomicUsize = AtomicUsize::new(0);}\n+\n+                fn lookup(module: &str, symbol: &str) -> Option<usize> {\n+                    let mut module: Vec<u16> = module.encode_utf16().collect();\n+                    module.push(0);\n+                    let symbol = CString::new(symbol).unwrap();\n+                    unsafe {\n+                        let handle = GetModuleHandleW(module.as_ptr());\n+                        match GetProcAddress(handle, symbol.as_ptr()) as usize {\n+                            0 => None,\n+                            n => Some(n),\n+                        }\n+                    }\n+                }\n+\n+                fn store_func(ptr: &AtomicUsize, module: &str, symbol: &str,\n+                              fallback: usize) -> usize {\n+                    let value = lookup(module, symbol).unwrap_or(fallback);\n+                    ptr.store(value, Ordering::SeqCst);\n+                    value\n+                }\n+\n+                fn load() -> usize {\n+                    store_func(&PTR, stringify!($module), stringify!($symbol), fallback as usize)\n+                }\n+                unsafe extern \"system\" fn fallback($($argname: $argtype),*)\n+                                                   -> $rettype {\n+                    $($body);*\n+                }\n+\n+                let addr = match PTR.load(Ordering::SeqCst) {\n+                    0 => load(),\n+                    n => n,\n+                };\n+                mem::transmute::<usize, F>(addr)($($argname),*)\n+            }\n+        )*)\n+    }\n+\n+    compat_fn! {\n+        kernel32:\n+        fn GetFinalPathNameByHandleW(_hFile: HANDLE,\n+                                     _lpszFilePath: LPCWSTR,\n+                                     _cchFilePath: DWORD,\n+                                     _dwFlags: DWORD) -> DWORD {\n+            SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n+        }\n+        fn SetFileInformationByHandle(_hFile: HANDLE,\n+                                      _FileInformationClass: FILE_INFO_BY_HANDLE_CLASS,\n+                                      _lpFileInformation: LPVOID,\n+                                      _dwBufferSize: DWORD) -> BOOL {\n+            SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n+        }\n+    }\n+\n+    fn cvt(i: i32) -> io::Result<i32> {\n+        if i == 0 {\n+            Err(io::Error::last_os_error())\n+        } else {\n+            Ok(i)\n+        }\n+    }\n+\n+    fn to_u16s<S: AsRef<OsStr>>(s: S) -> io::Result<Vec<u16>> {\n+        fn inner(s: &OsStr) -> io::Result<Vec<u16>> {\n+            let mut maybe_result: Vec<u16> = s.encode_wide().collect();\n+            if maybe_result.iter().any(|&u| u == 0) {\n+                return Err(io::Error::new(\n+                    io::ErrorKind::InvalidInput,\n+                    \"strings passed to WinAPI cannot contain NULs\",\n+                ));\n+            }\n+            maybe_result.push(0);\n+            Ok(maybe_result)\n+        }\n+        inner(s.as_ref())\n+    }\n+\n+    fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n+        match v.iter().position(|c| *c == 0) {\n+            // don't include the 0\n+            Some(i) => &v[..i],\n+            None => v,\n+        }\n+    }\n+\n+    fn fill_utf16_buf<F1, F2, T>(mut f1: F1, f2: F2) -> io::Result<T>\n+    where\n+        F1: FnMut(*mut u16, DWORD) -> DWORD,\n+        F2: FnOnce(&[u16]) -> T,\n+    {\n+        // Start off with a stack buf but then spill over to the heap if we end up\n+        // needing more space.\n+        let mut stack_buf = [0u16; 512];\n+        let mut heap_buf = Vec::new();\n+        unsafe {\n+            let mut n = stack_buf.len();\n+            loop {\n+                let buf = if n <= stack_buf.len() {\n+                    &mut stack_buf[..]\n+                } else {\n+                    let extra = n - heap_buf.len();\n+                    heap_buf.reserve(extra);\n+                    heap_buf.set_len(n);\n+                    &mut heap_buf[..]\n+                };\n+\n+                // This function is typically called on windows API functions which\n+                // will return the correct length of the string, but these functions\n+                // also return the `0` on error. In some cases, however, the\n+                // returned \"correct length\" may actually be 0!\n+                //\n+                // To handle this case we call `SetLastError` to reset it to 0 and\n+                // then check it again if we get the \"0 error value\". If the \"last\n+                // error\" is still 0 then we interpret it as a 0 length buffer and\n+                // not an actual error.\n+                SetLastError(0);\n+                let k = match f1(buf.as_mut_ptr(), n as DWORD) {\n+                    0 if GetLastError() == 0 => 0,\n+                    0 => return Err(io::Error::last_os_error()),\n+                    n => n,\n+                } as usize;\n+                if k == n && GetLastError() == ERROR_INSUFFICIENT_BUFFER {\n+                    n *= 2;\n+                } else if k >= n {\n+                    n = k;\n+                } else {\n+                    return Ok(f2(&buf[..k]));\n+                }\n+            }\n+        }\n+    }\n+\n+    #[derive(Clone, PartialEq, Eq, Debug, Default)]\n+    struct FilePermissions {\n+        readonly: bool,\n+    }\n+\n+    impl FilePermissions {\n+        fn new() -> FilePermissions {\n+            Default::default()\n+        }\n+        fn readonly(&self) -> bool {\n+            self.readonly\n+        }\n+        fn set_readonly(&mut self, readonly: bool) {\n+            self.readonly = readonly\n+        }\n+    }\n+\n+    #[derive(Clone)]\n+    struct OpenOptions {\n+        // generic\n+        read: bool,\n+        write: bool,\n+        append: bool,\n+        truncate: bool,\n+        create: bool,\n+        create_new: bool,\n+        // system-specific\n+        custom_flags: u32,\n+        access_mode: Option<DWORD>,\n+        attributes: DWORD,\n+        share_mode: DWORD,\n+        security_qos_flags: DWORD,\n+        security_attributes: usize, // FIXME: should be a reference\n+    }\n+\n+    impl OpenOptions {\n+        fn new() -> OpenOptions {\n+            OpenOptions {\n+                // generic\n+                read: false,\n+                write: false,\n+                append: false,\n+                truncate: false,\n+                create: false,\n+                create_new: false,\n+                // system-specific\n+                custom_flags: 0,\n+                access_mode: None,\n+                share_mode: FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n+                attributes: 0,\n+                security_qos_flags: 0,\n+                security_attributes: 0,\n+            }\n+        }\n+        fn custom_flags(&mut self, flags: u32) {\n+            self.custom_flags = flags;\n+        }\n+        fn access_mode(&mut self, access_mode: u32) {\n+            self.access_mode = Some(access_mode);\n+        }\n+\n+        fn get_access_mode(&self) -> io::Result<DWORD> {\n+            const ERROR_INVALID_PARAMETER: i32 = 87;\n+\n+            match (self.read, self.write, self.append, self.access_mode) {\n+                (_, _, _, Some(mode)) => Ok(mode),\n+                (true, false, false, None) => Ok(GENERIC_READ),\n+                (false, true, false, None) => Ok(GENERIC_WRITE),\n+                (true, true, false, None) => Ok(GENERIC_READ | GENERIC_WRITE),\n+                (false, _, true, None) => Ok(FILE_GENERIC_WRITE & !FILE_WRITE_DATA),\n+                (true, _, true, None) => Ok(GENERIC_READ | (FILE_GENERIC_WRITE & !FILE_WRITE_DATA)),\n+                (false, false, false, None) => {\n+                    Err(io::Error::from_raw_os_error(ERROR_INVALID_PARAMETER))\n+                }\n+            }\n+        }\n+\n+        fn get_creation_mode(&self) -> io::Result<DWORD> {\n+            const ERROR_INVALID_PARAMETER: i32 = 87;\n+\n+            match (self.write, self.append) {\n+                (true, false) => {}\n+                (false, false) => {\n+                    if self.truncate || self.create || self.create_new {\n+                        return Err(io::Error::from_raw_os_error(ERROR_INVALID_PARAMETER));\n+                    }\n+                }\n+                (_, true) => {\n+                    if self.truncate && !self.create_new {\n+                        return Err(io::Error::from_raw_os_error(ERROR_INVALID_PARAMETER));\n+                    }\n+                }\n+            }\n+\n+            Ok(match (self.create, self.truncate, self.create_new) {\n+                (false, false, false) => OPEN_EXISTING,\n+                (true, false, false) => OPEN_ALWAYS,\n+                (false, true, false) => TRUNCATE_EXISTING,\n+                (true, true, false) => CREATE_ALWAYS,\n+                (_, _, true) => CREATE_NEW,\n+            })\n+        }\n+\n+        fn get_flags_and_attributes(&self) -> DWORD {\n+            self.custom_flags\n+                | self.attributes\n+                | self.security_qos_flags\n+                | if self.security_qos_flags != 0 {\n+                    SECURITY_SQOS_PRESENT\n+                } else {\n+                    0\n+                }\n+                | if self.create_new {\n+                    FILE_FLAG_OPEN_REPARSE_POINT\n+                } else {\n+                    0\n+                }\n+        }\n+    }\n+\n+    struct File {\n+        handle: Handle,\n+    }\n+\n+    impl File {\n+        fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n+            let path = to_u16s(path)?;\n+            let handle = unsafe {\n+                CreateFileW(\n+                    path.as_ptr(),\n+                    opts.get_access_mode()?,\n+                    opts.share_mode,\n+                    opts.security_attributes as *mut _,\n+                    opts.get_creation_mode()?,\n+                    opts.get_flags_and_attributes(),\n+                    ptr::null_mut(),\n+                )\n+            };\n+            if handle == INVALID_HANDLE_VALUE {\n+                Err(io::Error::last_os_error())\n+            } else {\n+                Ok(File {\n+                    handle: Handle::new(handle),\n+                })\n+            }\n+        }\n+\n+        fn file_attr(&self) -> io::Result<FileAttr> {\n+            unsafe {\n+                let mut info: BY_HANDLE_FILE_INFORMATION = mem::zeroed();\n+                cvt(GetFileInformationByHandle(self.handle.raw(), &mut info))?;\n+                let mut attr = FileAttr {\n+                    attributes: info.dwFileAttributes,\n+                    creation_time: info.ftCreationTime,\n+                    last_access_time: info.ftLastAccessTime,\n+                    last_write_time: info.ftLastWriteTime,\n+                    file_size: ((info.nFileSizeHigh as u64) << 32) | (info.nFileSizeLow as u64),\n+                    reparse_tag: 0,\n+                };\n+                if attr.is_reparse_point() {\n+                    let mut b = [0; MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n+                    if let Ok((_, buf)) = self.reparse_point(&mut b) {\n+                        attr.reparse_tag = buf.ReparseTag;\n+                    }\n+                }\n+                Ok(attr)\n+            }\n+        }\n+\n+        fn set_attributes(&self, attr: DWORD) -> io::Result<()> {\n+            let zero: LARGE_INTEGER = unsafe { mem::zeroed() };\n+\n+            let mut info = FILE_BASIC_INFO {\n+                CreationTime: zero,   // do not change\n+                LastAccessTime: zero, // do not change\n+                LastWriteTime: zero,  // do not change\n+                ChangeTime: zero,     // do not change\n+                FileAttributes: attr,\n+            };\n+            let size = mem::size_of_val(&info);\n+            cvt(unsafe {\n+                SetFileInformationByHandle(\n+                    self.handle.raw(),\n+                    FileBasicInfo,\n+                    &mut info as *mut _ as *mut _,\n+                    size as DWORD,\n+                )\n+            })?;\n+            Ok(())\n+        }\n+\n+        fn rename(&self, new: &Path, replace: bool) -> io::Result<()> {\n+            // &self must be opened with DELETE permission\n+            use std::iter;\n+            #[cfg(target_arch = \"x86\")]\n+            const STRUCT_SIZE: usize = 12;\n+            #[cfg(target_arch = \"x86_64\")]\n+            const STRUCT_SIZE: usize = 20;\n+\n+            // FIXME: check for internal NULs in 'new'\n+            let mut data: Vec<u16> = iter::repeat(0u16)\n+                .take(STRUCT_SIZE / 2)\n+                .chain(new.as_os_str().encode_wide())\n+                .collect();\n+            data.push(0);\n+            let size = data.len() * 2;\n+\n+            unsafe {\n+                // Thanks to alignment guarantees on Windows this works\n+                // (8 for 32-bit and 16 for 64-bit)\n+                let info = data.as_mut_ptr() as *mut FILE_RENAME_INFO;\n+                // The type of ReplaceIfExists is BOOL, but it actually expects a\n+                // BOOLEAN. This means true is -1, not c::TRUE.\n+                (*info).ReplaceIfExists = if replace { -1 } else { FALSE };\n+                (*info).RootDirectory = ptr::null_mut();\n+                (*info).FileNameLength = (size - STRUCT_SIZE) as DWORD;\n+                cvt(SetFileInformationByHandle(\n+                    self.handle().raw(),\n+                    FileRenameInfo,\n+                    data.as_mut_ptr() as *mut _ as *mut _,\n+                    size as DWORD,\n+                ))?;\n+                Ok(())\n+            }\n+        }\n+        fn set_perm(&self, perm: FilePermissions) -> io::Result<()> {\n+            let attr = self.file_attr()?.attributes;\n+            if perm.readonly == (attr & FILE_ATTRIBUTE_READONLY != 0) {\n+                Ok(())\n+            } else if perm.readonly {\n+                self.set_attributes(attr | FILE_ATTRIBUTE_READONLY)\n+            } else {\n+                self.set_attributes(attr & !FILE_ATTRIBUTE_READONLY)\n+            }\n+        }\n+\n+        fn handle(&self) -> &Handle {\n+            &self.handle\n+        }\n+\n+        fn reparse_point<'a>(\n+            &self,\n+            space: &'a mut [u8; MAXIMUM_REPARSE_DATA_BUFFER_SIZE],\n+        ) -> io::Result<(DWORD, &'a REPARSE_DATA_BUFFER)> {\n+            unsafe {\n+                let mut bytes = 0;\n+                cvt({\n+                    DeviceIoControl(\n+                        self.handle.raw(),\n+                        FSCTL_GET_REPARSE_POINT,\n+                        ptr::null_mut(),\n+                        0,\n+                        space.as_mut_ptr() as *mut _,\n+                        space.len() as DWORD,\n+                        &mut bytes,\n+                        ptr::null_mut(),\n+                    )\n+                })?;\n+                Ok((bytes, &*(space.as_ptr() as *const REPARSE_DATA_BUFFER)))\n+            }\n+        }\n+    }\n+\n+    #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+    enum FileType {\n+        Dir,\n+        File,\n+        SymlinkFile,\n+        SymlinkDir,\n+        ReparsePoint,\n+        MountPoint,\n+    }\n+\n+    impl FileType {\n+        fn new(attrs: DWORD, reparse_tag: DWORD) -> FileType {\n+            match (\n+                attrs & FILE_ATTRIBUTE_DIRECTORY != 0,\n+                attrs & FILE_ATTRIBUTE_REPARSE_POINT != 0,\n+                reparse_tag,\n+            ) {\n+                (false, false, _) => FileType::File,\n+                (true, false, _) => FileType::Dir,\n+                (false, true, IO_REPARSE_TAG_SYMLINK) => FileType::SymlinkFile,\n+                (true, true, IO_REPARSE_TAG_SYMLINK) => FileType::SymlinkDir,\n+                (true, true, IO_REPARSE_TAG_MOUNT_POINT) => FileType::MountPoint,\n+                (_, true, _) => FileType::ReparsePoint,\n+                // Note: if a _file_ has a reparse tag of the type IO_REPARSE_TAG_MOUNT_POINT it is\n+                // invalid, as junctions always have to be dirs. We set the filetype to ReparsePoint\n+                // to indicate it is something symlink-like, but not something you can follow.\n+            }\n+        }\n+\n+        fn is_dir(&self) -> bool {\n+            *self == FileType::Dir\n+        }\n+        fn is_symlink_dir(&self) -> bool {\n+            *self == FileType::SymlinkDir || *self == FileType::MountPoint\n+        }\n+    }\n+\n+    impl DirEntry {\n+        fn new(root: &Arc<PathBuf>, wfd: &WIN32_FIND_DATAW) -> Option<DirEntry> {\n+            let first_bytes = &wfd.cFileName[0..3];\n+            if first_bytes.starts_with(&[46, 0]) || first_bytes.starts_with(&[46, 46, 0]) {\n+                None\n+            } else {\n+                Some(DirEntry {\n+                    root: root.clone(),\n+                    data: *wfd,\n+                })\n+            }\n+        }\n+\n+        fn path(&self) -> PathBuf {\n+            self.root.join(&self.file_name())\n+        }\n+\n+        fn file_name(&self) -> OsString {\n+            let filename = truncate_utf16_at_nul(&self.data.cFileName);\n+            OsString::from_wide(filename)\n+        }\n+\n+        fn file_type(&self) -> io::Result<FileType> {\n+            Ok(FileType::new(\n+                self.data.dwFileAttributes,\n+                /* reparse_tag = */ self.data.dwReserved0,\n+            ))\n+        }\n+\n+        fn metadata(&self) -> io::Result<FileAttr> {\n+            Ok(FileAttr {\n+                attributes: self.data.dwFileAttributes,\n+                creation_time: self.data.ftCreationTime,\n+                last_access_time: self.data.ftLastAccessTime,\n+                last_write_time: self.data.ftLastWriteTime,\n+                file_size: ((self.data.nFileSizeHigh as u64) << 32)\n+                    | (self.data.nFileSizeLow as u64),\n+                reparse_tag: if self.data.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n+                    // reserved unless this is a reparse point\n+                    self.data.dwReserved0\n+                } else {\n+                    0\n+                },\n+            })\n+        }\n+    }\n+\n+    struct DirEntry {\n+        root: Arc<PathBuf>,\n+        data: WIN32_FIND_DATAW,\n+    }\n+\n+    struct ReadDir {\n+        handle: FindNextFileHandle,\n+        root: Arc<PathBuf>,\n+        first: Option<WIN32_FIND_DATAW>,\n+    }\n+\n+    impl Iterator for ReadDir {\n+        type Item = io::Result<DirEntry>;\n+        fn next(&mut self) -> Option<io::Result<DirEntry>> {\n+            if let Some(first) = self.first.take() {\n+                if let Some(e) = DirEntry::new(&self.root, &first) {\n+                    return Some(Ok(e));\n+                }\n+            }\n+            unsafe {\n+                let mut wfd = mem::zeroed();\n+                loop {\n+                    if FindNextFileW(self.handle.0, &mut wfd) == 0 {\n+                        if GetLastError() == ERROR_NO_MORE_FILES {\n+                            return None;\n+                        } else {\n+                            return Some(Err(io::Error::last_os_error()));\n+                        }\n+                    }\n+                    if let Some(e) = DirEntry::new(&self.root, &wfd) {\n+                        return Some(Ok(e));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    #[derive(Clone)]\n+    struct FileAttr {\n+        attributes: DWORD,\n+        creation_time: FILETIME,\n+        last_access_time: FILETIME,\n+        last_write_time: FILETIME,\n+        file_size: u64,\n+        reparse_tag: DWORD,\n+    }\n+\n+    impl FileAttr {\n+        fn perm(&self) -> FilePermissions {\n+            FilePermissions {\n+                readonly: self.attributes & FILE_ATTRIBUTE_READONLY != 0,\n+            }\n+        }\n+\n+        fn file_type(&self) -> FileType {\n+            FileType::new(self.attributes, self.reparse_tag)\n+        }\n+\n+        fn is_reparse_point(&self) -> bool {\n+            self.attributes & FILE_ATTRIBUTE_REPARSE_POINT != 0\n+        }\n+    }\n+\n+    #[repr(C)]\n+    struct REPARSE_DATA_BUFFER {\n+        ReparseTag: c_uint,\n+        ReparseDataLength: c_ushort,\n+        Reserved: c_ushort,\n+        rest: (),\n+    }\n+\n+    const MAXIMUM_REPARSE_DATA_BUFFER_SIZE: usize = 16 * 1024;\n+\n+    /// An owned container for `HANDLE` object, closing them on Drop.\n+    ///\n+    /// All methods are inherited through a `Deref` impl to `RawHandle`\n+    struct Handle(RawHandle);\n+\n+    use std::ops::Deref;\n+\n+    /// A wrapper type for `HANDLE` objects to give them proper Send/Sync inference\n+    /// as well as Rust-y methods.\n+    ///\n+    /// This does **not** drop the handle when it goes out of scope, use `Handle`\n+    /// instead for that.\n+    #[derive(Copy, Clone)]\n+    struct RawHandle(HANDLE);\n+\n+    unsafe impl Send for RawHandle {}\n+    unsafe impl Sync for RawHandle {}\n+\n+    impl Handle {\n+        fn new(handle: HANDLE) -> Handle {\n+            Handle(RawHandle::new(handle))\n+        }\n+    }\n+\n+    impl Deref for Handle {\n+        type Target = RawHandle;\n+        fn deref(&self) -> &RawHandle {\n+            &self.0\n+        }\n+    }\n+\n+    impl Drop for Handle {\n+        fn drop(&mut self) {\n+            unsafe {\n+                let _ = CloseHandle(self.raw());\n+            }\n+        }\n+    }\n+\n+    impl RawHandle {\n+        fn new(handle: HANDLE) -> RawHandle {\n+            RawHandle(handle)\n+        }\n+\n+        fn raw(&self) -> HANDLE {\n+            self.0\n+        }\n+    }\n+\n+    struct FindNextFileHandle(HANDLE);\n+\n+    fn get_path(f: &File) -> io::Result<PathBuf> {\n+        fill_utf16_buf(\n+            |buf, sz| unsafe {\n+                GetFinalPathNameByHandleW(f.handle.raw(), buf, sz, VOLUME_NAME_DOS)\n+            },\n+            |buf| PathBuf::from(OsString::from_wide(buf)),\n+        )\n+    }\n+\n+    fn move_item(file: &File, ctx: &mut RmdirContext) -> io::Result<()> {\n+        let mut tmpname = ctx.base_dir.join(format! {\"rm-{}\", ctx.counter});\n+        ctx.counter += 1;\n+        // Try to rename the file. If it already exists, just retry with an other\n+        // filename.\n+        while let Err(err) = file.rename(tmpname.as_ref(), false) {\n+            if err.kind() != io::ErrorKind::AlreadyExists {\n+                return Err(err);\n+            };\n+            tmpname = ctx.base_dir.join(format!(\"rm-{}\", ctx.counter));\n+            ctx.counter += 1;\n+        }\n+        Ok(())\n+    }\n+\n+    fn set_perm(path: &Path, perm: FilePermissions) -> io::Result<()> {\n+        let mut opts = OpenOptions::new();\n+        opts.access_mode(FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES);\n+        opts.custom_flags(FILE_FLAG_BACKUP_SEMANTICS);\n+        let file = File::open(path, &opts)?;\n+        file.set_perm(perm)\n+    }\n+\n+    const VOLUME_NAME_DOS: DWORD = 0x0;\n+}"}, {"sha": "06affc029fd1ec3d1f12e2f4cb1303bf42f52fd5", "filename": "src/tools/rust-installer/src/scripter.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Fsrc%2Fscripter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Fsrc%2Fscripter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fsrc%2Fscripter.rs?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1,68 @@\n+use crate::util::*;\n+use anyhow::{Context, Result};\n+use std::io::Write;\n+\n+const TEMPLATE: &'static str = include_str!(\"../install-template.sh\");\n+\n+actor! {\n+    #[derive(Debug)]\n+    pub struct Scripter {\n+        /// The name of the product, for display\n+        #[clap(value_name = \"NAME\")]\n+        product_name: String = \"Product\",\n+\n+        /// The directory under lib/ where the manifest lives\n+        #[clap(value_name = \"DIR\")]\n+        rel_manifest_dir: String = \"manifestlib\",\n+\n+        /// The string to print after successful installation\n+        #[clap(value_name = \"MESSAGE\")]\n+        success_message: String = \"Installed.\",\n+\n+        /// Places to look for legacy manifests to uninstall\n+        #[clap(value_name = \"DIRS\")]\n+        legacy_manifest_dirs: String = \"\",\n+\n+        /// The name of the output script\n+        #[clap(value_name = \"FILE\")]\n+        output_script: String = \"install.sh\",\n+    }\n+}\n+\n+impl Scripter {\n+    /// Generates the actual installer script\n+    pub fn run(self) -> Result<()> {\n+        // Replace dashes in the success message with spaces (our arg handling botches spaces)\n+        // TODO: still needed? Kept for compatibility for now.\n+        let product_name = self.product_name.replace('-', \" \");\n+\n+        // Replace dashes in the success message with spaces (our arg handling botches spaces)\n+        // TODO: still needed? Kept for compatibility for now.\n+        let success_message = self.success_message.replace('-', \" \");\n+\n+        let script = TEMPLATE\n+            .replace(\"%%TEMPLATE_PRODUCT_NAME%%\", &sh_quote(&product_name))\n+            .replace(\"%%TEMPLATE_REL_MANIFEST_DIR%%\", &self.rel_manifest_dir)\n+            .replace(\"%%TEMPLATE_SUCCESS_MESSAGE%%\", &sh_quote(&success_message))\n+            .replace(\n+                \"%%TEMPLATE_LEGACY_MANIFEST_DIRS%%\",\n+                &sh_quote(&self.legacy_manifest_dirs),\n+            )\n+            .replace(\n+                \"%%TEMPLATE_RUST_INSTALLER_VERSION%%\",\n+                &sh_quote(&crate::RUST_INSTALLER_VERSION),\n+            );\n+\n+        create_new_executable(&self.output_script)?\n+            .write_all(script.as_ref())\n+            .with_context(|| format!(\"failed to write output script '{}'\", self.output_script))?;\n+\n+        Ok(())\n+    }\n+}\n+\n+fn sh_quote<T: ToString>(s: &T) -> String {\n+    // We'll single-quote the whole thing, so first replace single-quotes with\n+    // '\"'\"' (leave quoting, double-quote one `'`, re-enter single-quoting)\n+    format!(\"'{}'\", s.to_string().replace('\\'', r#\"'\"'\"'\"#))\n+}"}, {"sha": "76f5af3fa53926a52c649b10779c21929cd6921e", "filename": "src/tools/rust-installer/src/tarballer.rs", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Fsrc%2Ftarballer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Fsrc%2Ftarballer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fsrc%2Ftarballer.rs?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1,143 @@\n+use anyhow::{bail, Context, Result};\n+use std::fs::{read_link, symlink_metadata};\n+use std::io::{empty, BufWriter, Write};\n+use std::path::Path;\n+use tar::{Builder, Header};\n+use walkdir::WalkDir;\n+\n+use crate::{\n+    compression::{CombinedEncoder, CompressionFormats},\n+    util::*,\n+};\n+\n+actor! {\n+    #[derive(Debug)]\n+    pub struct Tarballer {\n+        /// The input folder to be compressed.\n+        #[clap(value_name = \"NAME\")]\n+        input: String = \"package\",\n+\n+        /// The prefix of the tarballs.\n+        #[clap(value_name = \"PATH\")]\n+        output: String = \"./dist\",\n+\n+        /// The folder in which the input is to be found.\n+        #[clap(value_name = \"DIR\")]\n+        work_dir: String = \"./workdir\",\n+\n+        /// The formats used to compress the tarball.\n+        #[clap(value_name = \"FORMAT\", default_value_t)]\n+        compression_formats: CompressionFormats,\n+    }\n+}\n+\n+impl Tarballer {\n+    /// Generates the actual tarballs\n+    pub fn run(self) -> Result<()> {\n+        let tarball_name = self.output.clone() + \".tar\";\n+        let encoder = CombinedEncoder::new(\n+            self.compression_formats\n+                .iter()\n+                .map(|f| f.encode(&tarball_name))\n+                .collect::<Result<Vec<_>>>()?,\n+        );\n+\n+        // Sort files by their suffix, to group files with the same name from\n+        // different locations (likely identical) and files with the same\n+        // extension (likely containing similar data).\n+        let (dirs, mut files) = get_recursive_paths(&self.work_dir, &self.input)\n+            .context(\"failed to collect file paths\")?;\n+        files.sort_by(|a, b| a.bytes().rev().cmp(b.bytes().rev()));\n+\n+        // Write the tar into both encoded files. We write all directories\n+        // first, so files may be directly created. (See rust-lang/rustup.rs#1092.)\n+        let buf = BufWriter::with_capacity(1024 * 1024, encoder);\n+        let mut builder = Builder::new(buf);\n+\n+        let pool = rayon::ThreadPoolBuilder::new()\n+            .num_threads(2)\n+            .build()\n+            .unwrap();\n+        pool.install(move || {\n+            for path in dirs {\n+                let src = Path::new(&self.work_dir).join(&path);\n+                builder\n+                    .append_dir(&path, &src)\n+                    .with_context(|| format!(\"failed to tar dir '{}'\", src.display()))?;\n+            }\n+            for path in files {\n+                let src = Path::new(&self.work_dir).join(&path);\n+                append_path(&mut builder, &src, &path)\n+                    .with_context(|| format!(\"failed to tar file '{}'\", src.display()))?;\n+            }\n+            builder\n+                .into_inner()\n+                .context(\"failed to finish writing .tar stream\")?\n+                .into_inner()\n+                .ok()\n+                .unwrap()\n+                .finish()?;\n+\n+            Ok(())\n+        })\n+    }\n+}\n+\n+fn append_path<W: Write>(builder: &mut Builder<W>, src: &Path, path: &String) -> Result<()> {\n+    let stat = symlink_metadata(src)?;\n+    let mut header = Header::new_gnu();\n+    header.set_metadata(&stat);\n+    if stat.file_type().is_symlink() {\n+        let link = read_link(src)?;\n+        header.set_link_name(&link)?;\n+        builder.append_data(&mut header, path, &mut empty())?;\n+    } else {\n+        if cfg!(windows) {\n+            // Windows doesn't really have a mode, so `tar` never marks files executable.\n+            // Use an extension whitelist to update files that usually should be so.\n+            const EXECUTABLES: [&'static str; 4] = [\"exe\", \"dll\", \"py\", \"sh\"];\n+            if let Some(ext) = src.extension().and_then(|s| s.to_str()) {\n+                if EXECUTABLES.contains(&ext) {\n+                    let mode = header.mode()?;\n+                    header.set_mode(mode | 0o111);\n+                }\n+            }\n+        }\n+        let file = open_file(src)?;\n+        builder.append_data(&mut header, path, &file)?;\n+    }\n+    Ok(())\n+}\n+\n+/// Returns all `(directories, files)` under the source path.\n+fn get_recursive_paths<P, Q>(root: P, name: Q) -> Result<(Vec<String>, Vec<String>)>\n+where\n+    P: AsRef<Path>,\n+    Q: AsRef<Path>,\n+{\n+    let root = root.as_ref();\n+    let name = name.as_ref();\n+\n+    if !name.is_relative() && !name.starts_with(root) {\n+        bail!(\n+            \"input '{}' is not in work dir '{}'\",\n+            name.display(),\n+            root.display()\n+        );\n+    }\n+\n+    let mut dirs = vec![];\n+    let mut files = vec![];\n+    for entry in WalkDir::new(root.join(name)) {\n+        let entry = entry?;\n+        let path = entry.path().strip_prefix(root)?;\n+        let path = path_to_str(&path)?;\n+\n+        if entry.file_type().is_dir() {\n+            dirs.push(path.to_owned());\n+        } else {\n+            files.push(path.to_owned());\n+        }\n+    }\n+    Ok((dirs, files))\n+}"}, {"sha": "674617c657c599a8a58943f7b6d5fc35dc782526", "filename": "src/tools/rust-installer/src/util.rs", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fsrc%2Futil.rs?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1,156 @@\n+use anyhow::{format_err, Context, Result};\n+use std::fs;\n+use std::path::Path;\n+use walkdir::WalkDir;\n+\n+// Needed to set the script mode to executable.\n+#[cfg(unix)]\n+use std::os::unix::fs::OpenOptionsExt;\n+// FIXME: what about Windows? Are default ACLs executable?\n+\n+#[cfg(unix)]\n+use std::os::unix::fs::symlink as symlink_file;\n+#[cfg(windows)]\n+use std::os::windows::fs::symlink_file;\n+\n+/// Converts a `&Path` to a UTF-8 `&str`.\n+pub fn path_to_str(path: &Path) -> Result<&str> {\n+    path.to_str()\n+        .ok_or_else(|| format_err!(\"path is not valid UTF-8 '{}'\", path.display()))\n+}\n+\n+/// Wraps `fs::copy` with a nicer error message.\n+pub fn copy<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> Result<u64> {\n+    if fs::symlink_metadata(&from)?.file_type().is_symlink() {\n+        let link = fs::read_link(&from)?;\n+        symlink_file(link, &to)?;\n+        Ok(0)\n+    } else {\n+        let amt = fs::copy(&from, &to).with_context(|| {\n+            format!(\n+                \"failed to copy '{}' to '{}'\",\n+                from.as_ref().display(),\n+                to.as_ref().display()\n+            )\n+        })?;\n+        Ok(amt)\n+    }\n+}\n+\n+/// Wraps `fs::create_dir` with a nicer error message.\n+pub fn create_dir<P: AsRef<Path>>(path: P) -> Result<()> {\n+    fs::create_dir(&path)\n+        .with_context(|| format!(\"failed to create dir '{}'\", path.as_ref().display()))?;\n+    Ok(())\n+}\n+\n+/// Wraps `fs::create_dir_all` with a nicer error message.\n+pub fn create_dir_all<P: AsRef<Path>>(path: P) -> Result<()> {\n+    fs::create_dir_all(&path)\n+        .with_context(|| format!(\"failed to create dir '{}'\", path.as_ref().display()))?;\n+    Ok(())\n+}\n+\n+/// Wraps `fs::OpenOptions::create_new().open()` as executable, with a nicer error message.\n+pub fn create_new_executable<P: AsRef<Path>>(path: P) -> Result<fs::File> {\n+    let mut options = fs::OpenOptions::new();\n+    options.write(true).create_new(true);\n+    #[cfg(unix)]\n+    options.mode(0o755);\n+    let file = options\n+        .open(&path)\n+        .with_context(|| format!(\"failed to create file '{}'\", path.as_ref().display()))?;\n+    Ok(file)\n+}\n+\n+/// Wraps `fs::OpenOptions::create_new().open()`, with a nicer error message.\n+pub fn create_new_file<P: AsRef<Path>>(path: P) -> Result<fs::File> {\n+    let file = fs::OpenOptions::new()\n+        .write(true)\n+        .create_new(true)\n+        .open(&path)\n+        .with_context(|| format!(\"failed to create file '{}'\", path.as_ref().display()))?;\n+    Ok(file)\n+}\n+\n+/// Wraps `fs::File::open()` with a nicer error message.\n+pub fn open_file<P: AsRef<Path>>(path: P) -> Result<fs::File> {\n+    let file = fs::File::open(&path)\n+        .with_context(|| format!(\"failed to open file '{}'\", path.as_ref().display()))?;\n+    Ok(file)\n+}\n+\n+/// Wraps `remove_dir_all` with a nicer error message.\n+pub fn remove_dir_all<P: AsRef<Path>>(path: P) -> Result<()> {\n+    remove_dir_all::remove_dir_all(path.as_ref())\n+        .with_context(|| format!(\"failed to remove dir '{}'\", path.as_ref().display()))?;\n+    Ok(())\n+}\n+\n+/// Wrap `fs::remove_file` with a nicer error message\n+pub fn remove_file<P: AsRef<Path>>(path: P) -> Result<()> {\n+    fs::remove_file(path.as_ref())\n+        .with_context(|| format!(\"failed to remove file '{}'\", path.as_ref().display()))?;\n+    Ok(())\n+}\n+\n+/// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n+/// when this function is called.\n+pub fn copy_recursive(src: &Path, dst: &Path) -> Result<()> {\n+    copy_with_callback(src, dst, |_, _| Ok(()))\n+}\n+\n+/// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n+/// when this function is called. Invokes a callback for each path visited.\n+pub fn copy_with_callback<F>(src: &Path, dst: &Path, mut callback: F) -> Result<()>\n+where\n+    F: FnMut(&Path, fs::FileType) -> Result<()>,\n+{\n+    for entry in WalkDir::new(src).min_depth(1) {\n+        let entry = entry?;\n+        let file_type = entry.file_type();\n+        let path = entry.path().strip_prefix(src)?;\n+        let dst = dst.join(path);\n+\n+        if file_type.is_dir() {\n+            create_dir(&dst)?;\n+        } else {\n+            copy(entry.path(), dst)?;\n+        }\n+        callback(&path, file_type)?;\n+    }\n+    Ok(())\n+}\n+\n+macro_rules! actor_field_default {\n+    () => { Default::default() };\n+    (= $expr:expr) => { $expr.into() }\n+}\n+\n+/// Creates an \"actor\" with default values, setters for all fields, and Clap parser support.\n+macro_rules! actor {\n+    ($( #[ $attr:meta ] )+ pub struct $name:ident {\n+        $( $( #[ $field_attr:meta ] )+ $field:ident : $type:ty $(= $default:tt)*, )*\n+    }) => {\n+        $( #[ $attr ] )+\n+        #[derive(clap::Args)]\n+        pub struct $name {\n+            $( $( #[ $field_attr ] )+ #[clap(long, $(default_value = $default)*)] $field : $type, )*\n+        }\n+\n+        impl Default for $name {\n+            fn default() -> $name {\n+                $name {\n+                    $($field : actor_field_default!($(= $default)*), )*\n+                }\n+            }\n+        }\n+\n+        impl $name {\n+            $(pub fn $field(&mut self, value: $type) -> &mut Self {\n+                self.$field = value;\n+                self\n+            })*\n+        }\n+    }\n+}"}, {"sha": "bf6de4cb1fa00bfa28d350e20cda4c358a5b856a", "filename": "src/tools/rust-installer/test.sh", "status": "added", "additions": 1342, "deletions": 0, "changes": 1342, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Ftest.sh?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1,1342 @@\n+#!/bin/bash\n+\n+set -e -u\n+\n+if [ -x /bin/echo ]; then\n+    ECHO='/bin/echo'\n+else\n+    ECHO='echo'\n+fi\n+\n+# Prints the absolute path of a directory to stdout\n+abs_path() {\n+    local path=\"$1\"\n+    # Unset CDPATH because it causes havok: it makes the destination unpredictable\n+    # and triggers 'cd' to print the path to stdout. Route `cd`'s output to /dev/null\n+    # for good measure.\n+    (unset CDPATH && cd \"$path\" > /dev/null && pwd)\n+}\n+\n+S=\"$(abs_path $(dirname $0))\"\n+\n+TEST_DIR=\"$S/test\"\n+TMP_DIR=\"$S/tmp\"\n+WORK_DIR=\"$TMP_DIR/workdir\"\n+OUT_DIR=\"$TMP_DIR/outdir\"\n+PREFIX_DIR=\"$TMP_DIR/prefix\"\n+\n+case $(uname -s) in\n+\n+    MINGW* | MSYS*)\n+\tWINDOWS=1\n+        ;;\n+esac\n+\n+say() {\n+    echo \"test: $1\"\n+}\n+\n+pre() {\n+    echo \"test: $1\"\n+    rm -Rf \"$WORK_DIR\"\n+    rm -Rf \"$OUT_DIR\"\n+    rm -Rf \"$PREFIX_DIR\"\n+    mkdir -p \"$WORK_DIR\"\n+    mkdir -p \"$OUT_DIR\"\n+    mkdir -p \"$PREFIX_DIR\"\n+}\n+\n+need_ok() {\n+    if [ $? -ne 0 ]\n+    then\n+\techo\n+\techo \"TEST FAILED!\"\n+\techo\n+\texit 1\n+    fi\n+}\n+\n+fail() {\n+    echo\n+    echo \"$1\"\n+    echo\n+    echo \"TEST FAILED!\"\n+    echo\n+    exit 1\n+}\n+\n+try() {\n+    set +e\n+    _cmd=\"$@\"\n+    _output=`$@ 2>&1`\n+    if [ $? -ne 0 ]; then\n+\techo \\$ \"$_cmd\"\n+\t# Using /bin/echo to avoid escaping\n+\t$ECHO \"$_output\"\n+\techo\n+\techo \"TEST FAILED!\"\n+\techo\n+\texit 1\n+    else\n+\tif [ -n \"${VERBOSE-}\" -o -n \"${VERBOSE_CMD-}\" ]; then\n+\t    echo \\$ \"$_cmd\"\n+\tfi\n+\tif [ -n \"${VERBOSE-}\" -o -n \"${VERBOSE_OUTPUT-}\" ]; then\n+\t    $ECHO \"$_output\"\n+\tfi\n+    fi\n+    set -e\n+}\n+\n+expect_fail() {\n+    set +e\n+    _cmd=\"$@\"\n+    _output=`$@ 2>&1`\n+    if [ $? -eq 0 ]; then\n+\techo \\$ \"$_cmd\"\n+\t# Using /bin/echo to avoid escaping\n+\t$ECHO \"$_output\"\n+\techo\n+\techo \"TEST FAILED!\"\n+\techo\n+\texit 1\n+    else\n+\tif [ -n \"${VERBOSE-}\" -o -n \"${VERBOSE_CMD-}\" ]; then\n+\t    echo \\$ \"$_cmd\"\n+\tfi\n+\tif [ -n \"${VERBOSE-}\" -o -n \"${VERBOSE_OUTPUT-}\" ]; then\n+\t    $ECHO \"$_output\"\n+\tfi\n+    fi\n+    set -e\n+}\n+\n+expect_output_ok() {\n+    set +e\n+    local _expected=\"$1\"\n+    shift 1\n+    _cmd=\"$@\"\n+    _output=`$@ 2>&1`\n+    if [ $? -ne 0 ]; then\n+\techo \\$ \"$_cmd\"\n+\t# Using /bin/echo to avoid escaping\n+\t$ECHO \"$_output\"\n+\techo\n+\techo \"TEST FAILED!\"\n+\techo\n+\texit 1\n+    elif ! echo \"$_output\" | grep -q \"$_expected\"; then\n+\techo \\$ \"$_cmd\"\n+\t$ECHO \"$_output\"\n+\techo\n+\techo \"missing expected output '$_expected'\"\n+\techo\n+\techo\n+\techo \"TEST FAILED!\"\n+\techo\n+\texit 1\n+    else\n+\tif [ -n \"${VERBOSE-}\" -o -n \"${VERBOSE_CMD-}\" ]; then\n+\t    echo \\$ \"$_cmd\"\n+\tfi\n+\tif [ -n \"${VERBOSE-}\" -o -n \"${VERBOSE_OUTPUT-}\" ]; then\n+\t    $ECHO \"$_output\"\n+\tfi\n+    fi\n+    set -e\n+}\n+\n+expect_output_fail() {\n+    set +e\n+    local _expected=\"$1\"\n+    shift 1\n+    _cmd=\"$@\"\n+    _output=`$@ 2>&1`\n+    if [ $? -eq 0 ]; then\n+\techo \\$ \"$_cmd\"\n+\t# Using /bin/echo to avoid escaping\n+\t$ECHO \"$_output\"\n+\techo\n+\techo \"TEST FAILED!\"\n+\techo\n+\texit 1\n+    elif ! echo \"$_output\" | grep -q \"$_expected\"; then\n+\techo \\$ \"$_cmd\"\n+\t$ECHO \"$_output\"\n+\techo\n+\techo \"missing expected output '$_expected'\"\n+\techo\n+\techo\n+\techo \"TEST FAILED!\"\n+\techo\n+\texit 1\n+    else\n+\tif [ -n \"${VERBOSE-}\" -o -n \"${VERBOSE_CMD-}\" ]; then\n+\t    echo \\$ \"$_cmd\"\n+\tfi\n+\tif [ -n \"${VERBOSE-}\" -o -n \"${VERBOSE_OUTPUT-}\" ]; then\n+\t    $ECHO \"$_output\"\n+\tfi\n+    fi\n+    set -e\n+}\n+\n+expect_not_output_ok() {\n+    set +e\n+    local _expected=\"$1\"\n+    shift 1\n+    _cmd=\"$@\"\n+    _output=`$@ 2>&1`\n+    if [ $? -ne 0 ]; then\n+\techo \\$ \"$_cmd\"\n+\t# Using /bin/echo to avoid escaping\n+\t$ECHO \"$_output\"\n+\techo\n+\techo \"TEST FAILED!\"\n+\techo\n+\texit 1\n+    elif echo \"$_output\" | grep -q \"$_expected\"; then\n+\techo \\$ \"$_cmd\"\n+\t$ECHO \"$_output\"\n+\techo\n+\techo \"unexpected output '$_expected'\"\n+\techo\n+\techo\n+\techo \"TEST FAILED!\"\n+\techo\n+\texit 1\n+    else\n+\tif [ -n \"${VERBOSE-}\" -o -n \"${VERBOSE_CMD-}\" ]; then\n+\t    echo \\$ \"$_cmd\"\n+\tfi\n+\tif [ -n \"${VERBOSE-}\" -o -n \"${VERBOSE_OUTPUT-}\" ]; then\n+\t    $ECHO \"$_output\"\n+\tfi\n+    fi\n+    set -e\n+}\n+\n+runtest() {\n+    local _testname=\"$1\"\n+    if [ -n \"${TESTNAME-}\" ]; then\n+\tif ! echo \"$_testname\" | grep -q \"$TESTNAME\"; then\n+\t    return 0\n+\tfi\n+    fi\n+\n+    pre \"$_testname\"\n+    \"$_testname\"\n+}\n+\n+# Installation tests\n+\n+basic_install() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\"\n+    try \"$WORK_DIR/package/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try test -e \"$PREFIX_DIR/something-to-install\"\n+    try test -e \"$PREFIX_DIR/dir-to-install/foo\"\n+    try test -e \"$PREFIX_DIR/bin/program\"\n+    try test -e \"$PREFIX_DIR/bin/program2\"\n+    try test -e \"$PREFIX_DIR/bin/bad-bin\"\n+}\n+runtest basic_install\n+\n+basic_uninstall() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\"\n+    try \"$WORK_DIR/package/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try \"$WORK_DIR/package/install.sh --uninstall\" --prefix=\"$PREFIX_DIR\"\n+    try test ! -e \"$PREFIX_DIR/something-to-install\"\n+    try test ! -e \"$PREFIX_DIR/dir-to-install/foo\"\n+    try test ! -e \"$PREFIX_DIR/bin/program\"\n+    try test ! -e \"$PREFIX_DIR/bin/program2\"\n+    try test ! -e \"$PREFIX_DIR/bin/bad-bin\"\n+    try test ! -e \"$PREFIX_DIR/lib/packagelib\"\n+}\n+runtest basic_uninstall\n+\n+not_installed_files() {\n+    mkdir -p \"$WORK_DIR/overlay\"\n+    touch \"$WORK_DIR/overlay/not-installed\"\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--non-installed-overlay=\"$WORK_DIR/overlay\"\n+    try test -e \"$WORK_DIR/package/not-installed\"\n+    try \"$WORK_DIR/package/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try test ! -e \"$PREFIX_DIR/not-installed\"\n+}\n+runtest not_installed_files\n+\n+tarball_with_package_name() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rustc-nightly\n+    try \"$WORK_DIR/rustc-nightly/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try test -e \"$OUT_DIR/rustc-nightly.tar.gz\"\n+    try test -e \"$OUT_DIR/rustc-nightly.tar.xz\"\n+}\n+runtest tarball_with_package_name\n+\n+install_overwrite_backup() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\"\n+    try mkdir -p \"$PREFIX_DIR/bin\"\n+    touch \"$PREFIX_DIR/bin/program\"\n+    try \"$WORK_DIR/package/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    # The existing program was backed up by 'install'\n+    try test -e \"$PREFIX_DIR/bin/program.old\"\n+}\n+runtest install_overwrite_backup\n+\n+bulk_directory() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--bulk-dirs=dir-to-install\n+    try \"$WORK_DIR/package/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try test -e \"$PREFIX_DIR/something-to-install\"\n+    try test -e \"$PREFIX_DIR/dir-to-install/foo\"\n+    try test -e \"$PREFIX_DIR/bin/program\"\n+    try test -e \"$PREFIX_DIR/bin/program2\"\n+    try test -e \"$PREFIX_DIR/bin/bad-bin\"\n+    try \"$WORK_DIR/package/install.sh\" --prefix=\"$PREFIX_DIR\" --uninstall\n+    try test ! -e \"$PREFIX_DIR/dir-to-install\"\n+}\n+runtest bulk_directory\n+\n+bulk_directory_overwrite() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--bulk-dirs=dir-to-install\n+    try mkdir -p \"$PREFIX_DIR/dir-to-install\"\n+    try touch \"$PREFIX_DIR/dir-to-install/overwrite\"\n+    try \"$WORK_DIR/package/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    # The file that used to exist in the directory no longer does\n+    try test ! -e \"$PREFIX_DIR/dir-to-install/overwrite\"\n+    # It was backed up\n+    try test -e \"$PREFIX_DIR/dir-to-install.old/overwrite\"\n+}\n+runtest bulk_directory_overwrite\n+\n+bulk_directory_overwrite_existing_backup() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--bulk-dirs=dir-to-install\n+    try mkdir -p \"$PREFIX_DIR/dir-to-install\"\n+    try touch \"$PREFIX_DIR/dir-to-install/overwrite\"\n+    # This time we've already got an existing backup of the overwritten directory.\n+    # The install should still succeed.\n+    try mkdir -p \"$PREFIX_DIR/dir-to-install~\"\n+    try touch \"$PREFIX_DIR/dir-to-install~/overwrite\"\n+    try \"$WORK_DIR/package/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try test ! -e \"$PREFIX_DIR/dir-to-install/overwrite\"\n+    try test -e \"$PREFIX_DIR/dir-to-install~/overwrite\"\n+}\n+runtest bulk_directory_overwrite_existing_backup\n+\n+nested_bulk_directory() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image4\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--bulk-dirs=dir-to-install/qux\n+    try \"$WORK_DIR/package/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try test -e \"$PREFIX_DIR/dir-to-install/qux/bar\"\n+    try \"$WORK_DIR/package/install.sh\" --prefix=\"$PREFIX_DIR\" --uninstall\n+    try test ! -e \"$PREFIX_DIR/dir-to-install/qux\"\n+}\n+runtest nested_bulk_directory\n+\n+only_bulk_directory_no_files() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image5\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--bulk-dirs=dir-to-install\n+    try \"$WORK_DIR/package/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try test -e \"$PREFIX_DIR/dir-to-install/foo\"\n+    try \"$WORK_DIR/package/install.sh\" --prefix=\"$PREFIX_DIR\" --uninstall\n+    try test ! -e \"$PREFIX_DIR/dir-to-install/foo\"\n+}\n+runtest only_bulk_directory_no_files\n+\n+nested_not_installed_files() {\n+    mkdir -p \"$WORK_DIR/overlay\"\n+    touch \"$WORK_DIR/overlay/not-installed\"\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image4\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--non-installed-overlay=\"$WORK_DIR/overlay\"\n+    try test -e \"$WORK_DIR/package/not-installed\"\n+    try \"$WORK_DIR/package/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try test ! -e \"$PREFIX_DIR/not-installed\"\n+}\n+runtest nested_not_installed_files\n+\n+multiple_components() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR/c1\" \\\n+\t--output-dir=\"$OUT_DIR/c1\" \\\n+\t--component-name=rustc\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image3\" \\\n+\t--work-dir=\"$WORK_DIR/c2\" \\\n+\t--output-dir=\"$OUT_DIR/c2\" \\\n+\t--component-name=cargo\n+    try \"$WORK_DIR/c1/package/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try \"$WORK_DIR/c2/package/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try test -e \"$PREFIX_DIR/something-to-install\"\n+    try test -e \"$PREFIX_DIR/dir-to-install/foo\"\n+    try test -e \"$PREFIX_DIR/bin/program\"\n+    try test -e \"$PREFIX_DIR/bin/program2\"\n+    try test -e \"$PREFIX_DIR/bin/bad-bin\"\n+    try test -e \"$PREFIX_DIR/bin/cargo\"\n+    try \"$WORK_DIR/c1/package/install.sh\" --prefix=\"$PREFIX_DIR\" --uninstall\n+    try test ! -e \"$PREFIX_DIR/something-to-install\"\n+    try test ! -e \"$PREFIX_DIR/dir-to-install/foo\"\n+    try test ! -e \"$PREFIX_DIR/bin/program\"\n+    try test ! -e \"$PREFIX_DIR/bin/program2\"\n+    try test ! -e \"$PREFIX_DIR/bin/bad-bin\"\n+    try \"$WORK_DIR/c2/package/install.sh\" --prefix=\"$PREFIX_DIR\" --uninstall\n+    try test ! -e \"$PREFIX_DIR/bin/cargo\"\n+    try test ! -e \"$PREFIX_DIR/lib/packagelib\"\n+}\n+runtest multiple_components\n+\n+uninstall_from_installed_script() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR/c1\" \\\n+\t--output-dir=\"$OUT_DIR/c1\" \\\n+\t--component-name=rustc\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image3\" \\\n+\t--work-dir=\"$WORK_DIR/c2\" \\\n+\t--output-dir=\"$OUT_DIR/c2\" \\\n+\t--component-name=cargo\n+    try \"$WORK_DIR/c1/package/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try \"$WORK_DIR/c2/package/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try test -e \"$PREFIX_DIR/something-to-install\"\n+    try test -e \"$PREFIX_DIR/dir-to-install/foo\"\n+    try test -e \"$PREFIX_DIR/bin/program\"\n+    try test -e \"$PREFIX_DIR/bin/program2\"\n+    try test -e \"$PREFIX_DIR/bin/bad-bin\"\n+    try test -e \"$PREFIX_DIR/bin/cargo\"\n+    # All components should be uninstalled by this script\n+    try sh \"$PREFIX_DIR/lib/packagelib/uninstall.sh\"\n+    try test ! -e \"$PREFIX_DIR/something-to-install\"\n+    try test ! -e \"$PREFIX_DIR/dir-to-install/foo\"\n+    try test ! -e \"$PREFIX_DIR/bin/program\"\n+    try test ! -e \"$PREFIX_DIR/bin/program2\"\n+    try test ! -e \"$PREFIX_DIR/bin/bad-bin\"\n+    try test ! -e \"$PREFIX_DIR/bin/cargo\"\n+    try test ! -e \"$PREFIX_DIR/lib/packagelib\"\n+}\n+runtest uninstall_from_installed_script\n+\n+uninstall_from_installed_script_with_args_fails() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR/c1\" \\\n+\t--output-dir=\"$OUT_DIR/c1\" \\\n+\t--component-name=rustc\n+    try \"$WORK_DIR/c1/package/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    expect_output_fail \"uninstall.sh does not take any arguments\" sh \"$PREFIX_DIR/lib/packagelib/uninstall.sh\" --prefix=foo\n+}\n+runtest uninstall_from_installed_script_with_args_fails\n+\n+# Combined installer tests\n+\n+combine_installers() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rustc \\\n+\t--component-name=rustc\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image3\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=cargo \\\n+\t--component-name=cargo\n+    try sh \"$S/combine-installers.sh\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rust \\\n+\t--input-tarballs=\"$OUT_DIR/rustc.tar.gz,$OUT_DIR/cargo.tar.gz\"\n+    try \"$WORK_DIR/rust/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try test -e \"$PREFIX_DIR/something-to-install\"\n+    try test -e \"$PREFIX_DIR/dir-to-install/foo\"\n+    try test -e \"$PREFIX_DIR/bin/program\"\n+    try test -e \"$PREFIX_DIR/bin/program2\"\n+    try test -e \"$PREFIX_DIR/bin/bad-bin\"\n+    try test -e \"$PREFIX_DIR/bin/cargo\"\n+    try \"$WORK_DIR/rust/install.sh --uninstall\" --prefix=\"$PREFIX_DIR\"\n+    try test ! -e \"$PREFIX_DIR/something-to-install\"\n+    try test ! -e \"$PREFIX_DIR/dir-to-install/foo\"\n+    try test ! -e \"$PREFIX_DIR/bin/program\"\n+    try test ! -e \"$PREFIX_DIR/bin/program2\"\n+    try test ! -e \"$PREFIX_DIR/bin/bad-bin\"\n+    try test ! -e \"$PREFIX_DIR/bin/cargo\"\n+    try test ! -e \"$PREFIX_DIR/lib/packagelib\"\n+}\n+runtest combine_installers\n+\n+combine_three_installers() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rustc \\\n+\t--component-name=rustc\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image3\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=cargo \\\n+\t--component-name=cargo\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image4\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rust-docs \\\n+\t--component-name=rust-docs\n+    try sh \"$S/combine-installers.sh\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rust \\\n+\t--input-tarballs=\"$OUT_DIR/rustc.tar.gz,$OUT_DIR/cargo.tar.gz,$OUT_DIR/rust-docs.tar.gz\"\n+    try \"$WORK_DIR/rust/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try test -e \"$PREFIX_DIR/something-to-install\"\n+    try test -e \"$PREFIX_DIR/dir-to-install/foo\"\n+    try test -e \"$PREFIX_DIR/bin/program\"\n+    try test -e \"$PREFIX_DIR/bin/program2\"\n+    try test -e \"$PREFIX_DIR/bin/bad-bin\"\n+    try test -e \"$PREFIX_DIR/bin/cargo\"\n+    try test -e \"$PREFIX_DIR/dir-to-install/qux/bar\"\n+    try \"$WORK_DIR/rust/install.sh --uninstall\" --prefix=\"$PREFIX_DIR\"\n+    try test ! -e \"$PREFIX_DIR/something-to-install\"\n+    try test ! -e \"$PREFIX_DIR/dir-to-install/foo\"\n+    try test ! -e \"$PREFIX_DIR/bin/program\"\n+    try test ! -e \"$PREFIX_DIR/bin/program2\"\n+    try test ! -e \"$PREFIX_DIR/bin/bad-bin\"\n+    try test ! -e \"$PREFIX_DIR/bin/cargo\"\n+    try test ! -e \"$PREFIX_DIR/lib/packagelib\"\n+    try test ! -e \"$PREFIX_DIR/dir-to-install/qux/bar\"\n+}\n+runtest combine_three_installers\n+\n+combine_installers_with_overlay() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rustc \\\n+\t--component-name=rustc\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image3\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=cargo \\\n+\t--component-name=cargo\n+    mkdir -p \"$WORK_DIR/overlay\"\n+    touch \"$WORK_DIR/overlay/README\"\n+    try sh \"$S/combine-installers.sh\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rust \\\n+\t--input-tarballs=\"$OUT_DIR/rustc.tar.gz,$OUT_DIR/cargo.tar.gz\" \\\n+\t--non-installed-overlay=\"$WORK_DIR/overlay\"\n+    try test -e \"$WORK_DIR/rust/README\"\n+    try \"$WORK_DIR/rust/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try test ! -e \"$PREFIX_DIR/README\"\n+}\n+runtest combine_installers_with_overlay\n+\n+combined_with_bulk_dirs() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rustc \\\n+\t--component-name=rustc \\\n+\t--bulk-dirs=dir-to-install\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image3\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=cargo \\\n+\t--component-name=cargo\n+    try sh \"$S/combine-installers.sh\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rust \\\n+\t--input-tarballs=\"$OUT_DIR/rustc.tar.gz,$OUT_DIR/cargo.tar.gz\"\n+    try \"$WORK_DIR/rust/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try test -e \"$PREFIX_DIR/dir-to-install/foo\"\n+    try \"$WORK_DIR/rust/install.sh --uninstall\" --prefix=\"$PREFIX_DIR\"\n+    try test ! -e \"$PREFIX_DIR/dir-to-install\"\n+}\n+runtest combined_with_bulk_dirs\n+\n+combine_install_with_separate_uninstall() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rustc \\\n+\t--component-name=rustc \\\n+\t--rel-manifest-dir=rustlib\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image3\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=cargo \\\n+\t--component-name=cargo \\\n+\t--rel-manifest-dir=rustlib\n+    try sh \"$S/combine-installers.sh\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rust \\\n+\t--input-tarballs=\"$OUT_DIR/rustc.tar.gz,$OUT_DIR/cargo.tar.gz\" \\\n+\t--rel-manifest-dir=rustlib\n+    try \"$WORK_DIR/rust/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try test -e \"$PREFIX_DIR/something-to-install\"\n+    try test -e \"$PREFIX_DIR/dir-to-install/foo\"\n+    try test -e \"$PREFIX_DIR/bin/program\"\n+    try test -e \"$PREFIX_DIR/bin/program2\"\n+    try test -e \"$PREFIX_DIR/bin/bad-bin\"\n+    try test -e \"$PREFIX_DIR/bin/cargo\"\n+    try \"$WORK_DIR/rustc/install.sh --uninstall\" --prefix=\"$PREFIX_DIR\"\n+    try test ! -e \"$PREFIX_DIR/something-to-install\"\n+    try test ! -e \"$PREFIX_DIR/dir-to-install/foo\"\n+    try test ! -e \"$PREFIX_DIR/bin/program\"\n+    try test ! -e \"$PREFIX_DIR/bin/program2\"\n+    try test ! -e \"$PREFIX_DIR/bin/bad-bin\"\n+    try \"$WORK_DIR/cargo/install.sh --uninstall\" --prefix=\"$PREFIX_DIR\"\n+    try test ! -e \"$PREFIX_DIR/bin/cargo\"\n+    try test ! -e \"$PREFIX_DIR/lib/packagelib\"\n+}\n+runtest combine_install_with_separate_uninstall\n+\n+select_components_to_install() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rustc \\\n+\t--component-name=rustc\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image3\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=cargo \\\n+\t--component-name=cargo\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image4\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rust-docs \\\n+\t--component-name=rust-docs\n+    try sh \"$S/combine-installers.sh\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rust \\\n+\t--input-tarballs=\"$OUT_DIR/rustc.tar.gz,$OUT_DIR/cargo.tar.gz,$OUT_DIR/rust-docs.tar.gz\"\n+    try \"$WORK_DIR/rust/install.sh\" --prefix=\"$PREFIX_DIR\" --components=rustc\n+    try test -e \"$PREFIX_DIR/bin/program\"\n+    try test ! -e \"$PREFIX_DIR/bin/cargo\"\n+    try test ! -e \"$PREFIX_DIR/baz\"\n+    try \"$WORK_DIR/rust/install.sh --uninstall\" --prefix=\"$PREFIX_DIR\"\n+    try \"$WORK_DIR/rust/install.sh\" --prefix=\"$PREFIX_DIR\" --components=cargo\n+    try test ! -e \"$PREFIX_DIR/bin/program\"\n+    try test -e \"$PREFIX_DIR/bin/cargo\"\n+    try test ! -e \"$PREFIX_DIR/baz\"\n+    try \"$WORK_DIR/rust/install.sh --uninstall\" --prefix=\"$PREFIX_DIR\"\n+    try \"$WORK_DIR/rust/install.sh\" --prefix=\"$PREFIX_DIR\" --components=rust-docs\n+    try test ! -e \"$PREFIX_DIR/bin/program\"\n+    try test ! -e \"$PREFIX_DIR/bin/cargo\"\n+    try test -e \"$PREFIX_DIR/baz\"\n+    try \"$WORK_DIR/rust/install.sh --uninstall\" --prefix=\"$PREFIX_DIR\"\n+    try \"$WORK_DIR/rust/install.sh\" --prefix=\"$PREFIX_DIR\" --components=rustc,cargo\n+    try test -e \"$PREFIX_DIR/bin/program\"\n+    try test -e \"$PREFIX_DIR/bin/cargo\"\n+    try test ! -e \"$PREFIX_DIR/baz\"\n+    try \"$WORK_DIR/rust/install.sh --uninstall\" --prefix=\"$PREFIX_DIR\" --components=rustc,cargo,rust-docs\n+    try test ! -e \"$PREFIX_DIR/bin/program\"\n+    try test ! -e \"$PREFIX_DIR/bin/cargo\"\n+    try test ! -e \"$PREFIX_DIR/baz\"\n+    try test ! -e \"$PREFIX_DIR/lib/packagelib\"\n+}\n+runtest select_components_to_install\n+\n+select_components_to_uninstall() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rustc \\\n+\t--component-name=rustc\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image3\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=cargo \\\n+\t--component-name=cargo\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image4\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rust-docs \\\n+\t--component-name=rust-docs\n+    try sh \"$S/combine-installers.sh\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rust \\\n+\t--input-tarballs=\"$OUT_DIR/rustc.tar.gz,$OUT_DIR/cargo.tar.gz,$OUT_DIR/rust-docs.tar.gz\"\n+    try \"$WORK_DIR/rust/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try \"$WORK_DIR/rust/install.sh --uninstall\" --prefix=\"$PREFIX_DIR\" --components=rustc\n+    try test ! -e \"$PREFIX_DIR/bin/program\"\n+    try test -e \"$PREFIX_DIR/bin/cargo\"\n+    try test -e \"$PREFIX_DIR/baz\"\n+    try \"$WORK_DIR/rust/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try \"$WORK_DIR/rust/install.sh --uninstall\" --prefix=\"$PREFIX_DIR\" --components=cargo\n+    try test -e \"$PREFIX_DIR/bin/program\"\n+    try test ! -e \"$PREFIX_DIR/bin/cargo\"\n+    try test -e \"$PREFIX_DIR/baz\"\n+    try \"$WORK_DIR/rust/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try \"$WORK_DIR/rust/install.sh --uninstall\" --prefix=\"$PREFIX_DIR\" --components=rust-docs\n+    try test -e \"$PREFIX_DIR/bin/program\"\n+    try test -e \"$PREFIX_DIR/bin/cargo\"\n+    try test ! -e \"$PREFIX_DIR/baz\"\n+    try \"$WORK_DIR/rust/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try \"$WORK_DIR/rust/install.sh --uninstall\" --prefix=\"$PREFIX_DIR\" --components=rustc,cargo\n+    try test ! -e \"$PREFIX_DIR/bin/program\"\n+    try test ! -e \"$PREFIX_DIR/bin/cargo\"\n+    try test -e \"$PREFIX_DIR/baz\"\n+    try \"$WORK_DIR/rust/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try \"$WORK_DIR/rust/install.sh --uninstall\" --prefix=\"$PREFIX_DIR\" --components=rustc,cargo,rust-docs\n+    try test ! -e \"$PREFIX_DIR/bin/program\"\n+    try test ! -e \"$PREFIX_DIR/bin/cargo\"\n+    try test ! -e \"$PREFIX_DIR/baz\"\n+    try test ! -e \"$PREFIX_DIR/lib/packagelib\"\n+}\n+runtest select_components_to_uninstall\n+\n+invalid_component() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rustc \\\n+\t--component-name=rustc\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image3\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=cargo \\\n+\t--component-name=cargo\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image4\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rust-docs \\\n+\t--component-name=rust-docs\n+    try sh \"$S/combine-installers.sh\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rust \\\n+\t--input-tarballs=\"$OUT_DIR/rustc.tar.gz,$OUT_DIR/cargo.tar.gz,$OUT_DIR/rust-docs.tar.gz\"\n+    expect_output_fail \"unknown component\" \"$WORK_DIR/rust/install.sh\" --prefix=\"$PREFIX_DIR\" --components=foo\n+}\n+runtest invalid_component\n+\n+without_components() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rustc \\\n+\t--component-name=rustc\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image3\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=cargo \\\n+\t--component-name=cargo\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image4\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rust-docs \\\n+\t--component-name=rust-docs\n+    try sh \"$S/combine-installers.sh\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rust \\\n+\t--input-tarballs=\"$OUT_DIR/rustc.tar.gz,$OUT_DIR/cargo.tar.gz,$OUT_DIR/rust-docs.tar.gz\"\n+    try \"$WORK_DIR/rust/install.sh\" --prefix=\"$PREFIX_DIR\" --without=rust-docs\n+    try test -e \"$PREFIX_DIR/bin/program\"\n+    try test -e \"$PREFIX_DIR/bin/cargo\"\n+    try test ! -e \"$PREFIX_DIR/baz\"\n+    try \"$WORK_DIR/rust/install.sh --uninstall\" --prefix=\"$PREFIX_DIR\"\n+    try \"$WORK_DIR/rust/install.sh\" --prefix=\"$PREFIX_DIR\" --without=rust-docs,cargo\n+    try test -e \"$PREFIX_DIR/bin/program\"\n+    try test ! -e \"$PREFIX_DIR/bin/cargo\"\n+    try test ! -e \"$PREFIX_DIR/baz\"\n+    try \"$WORK_DIR/rust/install.sh --uninstall\" --prefix=\"$PREFIX_DIR\"\n+    try \"$WORK_DIR/rust/install.sh\" --prefix=\"$PREFIX_DIR\" --without=rust-docs,rustc\n+    try test ! -e \"$PREFIX_DIR/bin/program\"\n+    try test -e \"$PREFIX_DIR/bin/cargo\"\n+    try test ! -e \"$PREFIX_DIR/baz\"\n+    try \"$WORK_DIR/rust/install.sh --uninstall\" --prefix=\"$PREFIX_DIR\"\n+}\n+runtest without_components\n+\n+# --uninstall --without is kind of weird,\n+# --without causes components to remain installed\n+uninstall_without_components() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rustc \\\n+\t--component-name=rustc\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image3\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=cargo \\\n+\t--component-name=cargo\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image4\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rust-docs \\\n+\t--component-name=rust-docs\n+    try sh \"$S/combine-installers.sh\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rust \\\n+\t--input-tarballs=\"$OUT_DIR/rustc.tar.gz,$OUT_DIR/cargo.tar.gz,$OUT_DIR/rust-docs.tar.gz\"\n+    try \"$WORK_DIR/rust/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try \"$WORK_DIR/rust/install.sh --uninstall\" --prefix=\"$PREFIX_DIR\" --without=rust-docs\n+    try test ! -e \"$PREFIX_DIR/bin/program\"\n+    try test ! -e \"$PREFIX_DIR/bin/cargo\"\n+    try test -e \"$PREFIX_DIR/baz\"\n+    try \"$WORK_DIR/rust/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try \"$WORK_DIR/rust/install.sh --uninstall\" --prefix=\"$PREFIX_DIR\" --without=rust-docs,cargo\n+    try test ! -e \"$PREFIX_DIR/bin/program\"\n+    try test -e \"$PREFIX_DIR/bin/cargo\"\n+    try test -e \"$PREFIX_DIR/baz\"\n+    try \"$WORK_DIR/rust/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try \"$WORK_DIR/rust/install.sh --uninstall\" --prefix=\"$PREFIX_DIR\" --without=rust-docs,rustc\n+    try test -e \"$PREFIX_DIR/bin/program\"\n+    try test ! -e \"$PREFIX_DIR/bin/cargo\"\n+    try test -e \"$PREFIX_DIR/baz\"\n+}\n+runtest uninstall_without_components\n+\n+without_any_components() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rustc \\\n+\t--component-name=rustc\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image3\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=cargo \\\n+\t--component-name=cargo\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image4\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rust-docs \\\n+\t--component-name=rust-docs\n+    try sh \"$S/combine-installers.sh\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rust \\\n+\t--input-tarballs=\"$OUT_DIR/rustc.tar.gz,$OUT_DIR/cargo.tar.gz,$OUT_DIR/rust-docs.tar.gz\"\n+    expect_output_fail \"no components selected for installation\" \\\n+\t\"$WORK_DIR/rust/install.sh\" --prefix=\"$PREFIX_DIR\" --without=rust-docs,rustc,cargo\n+}\n+runtest without_any_components\n+\n+uninstall_without_any_components() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rustc \\\n+\t--component-name=rustc\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image3\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=cargo \\\n+\t--component-name=cargo\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image4\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rust-docs \\\n+\t--component-name=rust-docs\n+    try sh \"$S/combine-installers.sh\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rust \\\n+\t--input-tarballs=\"$OUT_DIR/rustc.tar.gz,$OUT_DIR/cargo.tar.gz,$OUT_DIR/rust-docs.tar.gz\"\n+    try \"$WORK_DIR/rust/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    expect_output_fail \"no components selected for uninstallation\" \\\n+\t\"$WORK_DIR/rust/install.sh\" --prefix=\"$PREFIX_DIR\" \\\n+\t--uninstall --without=rust-docs,rustc,cargo\n+}\n+runtest uninstall_without_any_components\n+\n+list_components() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rustc \\\n+\t--component-name=rustc\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image3\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=cargo \\\n+\t--component-name=cargo\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image4\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rust-docs \\\n+\t--component-name=rust-docs\n+    try sh \"$S/combine-installers.sh\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rust \\\n+\t--input-tarballs=\"$OUT_DIR/rustc.tar.gz,$OUT_DIR/cargo.tar.gz,$OUT_DIR/rust-docs.tar.gz\"\n+    expect_output_ok \"rustc\" \"$WORK_DIR/rust/install.sh\" --list-components\n+    expect_output_ok \"cargo\" \"$WORK_DIR/rust/install.sh\" --list-components\n+    expect_output_ok \"rust-docs\" \"$WORK_DIR/rust/install.sh\" --list-components\n+}\n+runtest list_components\n+\n+combined_remains() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rustc \\\n+\t--component-name=rustc\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image3\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=cargo \\\n+\t--component-name=cargo\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image4\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rust-docs \\\n+\t--component-name=rust-docs\n+    try sh \"$S/combine-installers.sh\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rust \\\n+\t--input-tarballs=\"$OUT_DIR/rustc.tar.gz,$OUT_DIR/cargo.tar.gz,$OUT_DIR/rust-docs.tar.gz\"\n+    for component in rustc cargo rust-docs; do\n+\t# rustbuild wants the original extracted package intact too\n+\ttry test -d \"$WORK_DIR/$component/$component\"\n+\ttry test -d \"$WORK_DIR/rust/$component\"\n+    done\n+}\n+runtest combined_remains\n+\n+# Smoke tests\n+\n+cannot_write_error() {\n+    # chmod doesn't work on windows\n+    if [ ! -n \"${WINDOWS-}\" ]; then\n+\ttry sh \"$S/gen-installer.sh\" \\\n+\t    --image-dir=\"$TEST_DIR/image1\" \\\n+\t    --work-dir=\"$WORK_DIR\" \\\n+\t    --output-dir=\"$OUT_DIR\"\n+\tchmod u-w \"$PREFIX_DIR\"\n+\texpect_fail \"$WORK_DIR/package/install.sh\" --prefix=\"$PREFIX_DIR\"\n+\tchmod u+w \"$PREFIX_DIR\"\n+    fi\n+}\n+runtest cannot_write_error\n+\n+cannot_install_to_installer() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=my-package\n+    expect_output_fail \"cannot install to same directory as installer\" \\\n+\t\"$WORK_DIR/my-package/install.sh\" --prefix=\"$WORK_DIR/my-package\"\n+}\n+runtest cannot_install_to_installer\n+\n+upgrade_from_future_installer_error() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--rel-manifest-dir=rustlib\n+    try \"$WORK_DIR/package/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    echo 100 > \"$PREFIX_DIR/lib/rustlib/rust-installer-version\"\n+    expect_fail \"$WORK_DIR/package/install.sh\" --prefix=\"$PREFIX_DIR\"\n+}\n+runtest upgrade_from_future_installer_error\n+\n+destdir() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\"\n+    try \"$WORK_DIR/package/install.sh\" --destdir=\"$PREFIX_DIR/\" --prefix=prefix\n+    try test -e \"$PREFIX_DIR/prefix/bin/program\"\n+}\n+runtest destdir\n+\n+destdir_no_trailing_slash() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\"\n+    try \"$WORK_DIR/package/install.sh\" --destdir=\"$PREFIX_DIR\" --prefix=prefix\n+    try test -e \"$PREFIX_DIR/prefix/bin/program\"\n+}\n+runtest destdir_no_trailing_slash\n+\n+disable_verify_noop() {\n+    # Obsolete --disable-verify flag doesn't generate error\n+    try sh \"$S/gen-installer.sh\" \\\n+       --image-dir=\"$TEST_DIR/image1\" \\\n+       --work-dir=\"$WORK_DIR\" \\\n+       --output-dir=\"$OUT_DIR\"\n+    try \"$WORK_DIR/package/install.sh\" --prefix=\"$PREFIX_DIR\" --disable-verify\n+}\n+runtest disable_verify_noop\n+\n+create_log() {\n+    try sh \"$S/gen-installer.sh\" \\\n+       --image-dir=\"$TEST_DIR/image1\" \\\n+       --work-dir=\"$WORK_DIR\" \\\n+       --output-dir=\"$OUT_DIR\"\n+    try \"$WORK_DIR/package/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try test -e \"$PREFIX_DIR/lib/packagelib/install.log\"\n+    local _log=\"$(cat \"$PREFIX_DIR/lib/packagelib/install.log\")\"\n+    if [ -z \"$_log\" ]; then\n+\tfail \"log is empty\"\n+    fi\n+}\n+runtest create_log\n+\n+leave_log_after_failure() {\n+    # chmod doesn't work on windows\n+    if [ ! -n \"${WINDOWS-}\" ]; then\n+\ttry sh \"$S/gen-installer.sh\" \\\n+\t    --image-dir=\"$TEST_DIR/image1\" \\\n+\t    --work-dir=\"$WORK_DIR\" \\\n+\t    --output-dir=\"$OUT_DIR\"\n+\tmkdir -p \"$PREFIX_DIR/lib/packagelib\"\n+\ttouch \"$PREFIX_DIR/lib/packagelib/components\"\n+\tchmod u-w \"$PREFIX_DIR/lib/packagelib/components\"\n+\texpect_fail \"$WORK_DIR/package/install.sh\" --prefix=\"$PREFIX_DIR\"\n+\tchmod u+w \"$PREFIX_DIR/lib/packagelib/components\"\n+\ttry test -e \"$PREFIX_DIR/lib/packagelib/install.log\"\n+\tlocal _log=\"$(cat \"$PREFIX_DIR/lib/packagelib/install.log\")\"\n+\tif [ -z \"$_log\" ]; then\n+\t    fail \"log is empty\"\n+\tfi\n+\t# script should tell user where the logs are\n+\tif ! grep -q \"see logs at\" \"$PREFIX_DIR/lib/packagelib/install.log\"; then\n+\t    fail \"missing log message\"\n+\tfi\n+    fi\n+}\n+runtest leave_log_after_failure\n+\n+# https://github.com/rust-lang/rust-installer/issues/22\n+help() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\"\n+    try \"$WORK_DIR/package/install.sh\" --help\n+}\n+runtest help\n+\n+# https://github.com/rust-lang/rust-installer/issues/31\n+CDPATH_does_not_destroy_things() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\"\n+    cd \"$WORK_DIR\" || exit 1\n+    export CDPATH=\"../$(basename $WORK_DIR)/foo\"\n+    try sh \"package/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    cd \"$S\" || exit 1\n+    cd \"$PREFIX_DIR\" || exit 1\n+    export CDPATH=\"../$(basename $PREFIX_DIR)\"\n+    try sh \"lib/packagelib/uninstall.sh\"\n+    cd \"$S\" || exit 1\n+    unset CDPATH\n+}\n+runtest CDPATH_does_not_destroy_things\n+\n+docdir_default() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image-docdir1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\"\n+    try \"$WORK_DIR/package/install.sh\" --prefix=\"$PREFIX_DIR\"\n+    try test -e \"$PREFIX_DIR/share/doc/rust/README\"\n+    try test -e \"$PREFIX_DIR/share/doc/rust/rustdocs.txt\"\n+}\n+runtest docdir_default\n+\n+docdir() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image-docdir1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\"\n+    try mkdir \"$WORK_DIR/docdir\"\n+    try \"$WORK_DIR/package/install.sh\" --prefix=\"$PREFIX_DIR\" --docdir=\"$WORK_DIR/docdir\"\n+    try test -e \"$WORK_DIR/docdir/README\"\n+    try test -e \"$WORK_DIR/docdir/rustdocs.txt\"\n+}\n+runtest docdir\n+\n+docdir_combined() {\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image-docdir1\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+        --package-name=\"rustc\" \\\n+        --component-name=\"rustc\"\n+    try sh \"$S/gen-installer.sh\" \\\n+\t--image-dir=\"$TEST_DIR/image-docdir2\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+        --package-name=\"cargo\" \\\n+        --component-name=\"cargo\"\n+    try sh \"$S/combine-installers.sh\" \\\n+\t--work-dir=\"$WORK_DIR\" \\\n+\t--output-dir=\"$OUT_DIR\" \\\n+\t--package-name=rust \\\n+\t--input-tarballs=\"$OUT_DIR/rustc.tar.gz,$OUT_DIR/cargo.tar.gz\"\n+    try mkdir \"$WORK_DIR/docdir\"\n+    try \"$WORK_DIR/rust/install.sh\" --prefix=\"$PREFIX_DIR\" --docdir=\"$WORK_DIR/docdir\"\n+    try test -e \"$WORK_DIR/docdir/README\"\n+    try test -e \"$WORK_DIR/docdir/rustdocs.txt\"\n+    try test -e \"$WORK_DIR/docdir/README\"\n+    try test -e \"$WORK_DIR/docdir/cargodocs.txt\"\n+}\n+runtest docdir_combined\n+\n+combine_installers_different_input_compression_formats() {\n+    try sh \"$S/gen-installer.sh\" \\\n+        --image-dir=\"$TEST_DIR/image1\" \\\n+        --work-dir=\"$WORK_DIR\" \\\n+        --output-dir=\"$OUT_DIR\" \\\n+        --package-name=rustc \\\n+        --component-name=rustc \\\n+        --compression-formats=xz\n+    try sh \"$S/gen-installer.sh\" \\\n+        --image-dir=\"$TEST_DIR/image3\" \\\n+        --work-dir=\"$WORK_DIR\" \\\n+        --output-dir=\"$OUT_DIR\" \\\n+        --package-name=cargo \\\n+        --component-name=cargo \\\n+        --compression-formats=gz\n+    try sh \"$S/combine-installers.sh\" \\\n+        --work-dir=\"$WORK_DIR\" \\\n+        --output-dir=\"$OUT_DIR\" \\\n+        --package-name=rust \\\n+        --input-tarballs=\"$OUT_DIR/rustc.tar.xz,$OUT_DIR/cargo.tar.gz\"\n+\n+    try test -e \"${OUT_DIR}/rust.tar.gz\"\n+    try test -e \"${OUT_DIR}/rust.tar.xz\"\n+}\n+runtest combine_installers_different_input_compression_formats\n+\n+generate_compression_formats_one() {\n+    try sh \"$S/gen-installer.sh\" \\\n+        --image-dir=\"$TEST_DIR/image1\" \\\n+        --work-dir=\"$WORK_DIR\" \\\n+        --output-dir=\"$OUT_DIR\" \\\n+        --package-name=\"rustc\" \\\n+        --component-name=\"rustc\" \\\n+        --compression-formats=\"xz\"\n+\n+    try test ! -e \"${OUT_DIR}/rustc.tar.gz\"\n+    try test -e \"${OUT_DIR}/rustc.tar.xz\"\n+}\n+runtest generate_compression_formats_one\n+\n+generate_compression_formats_multiple() {\n+    try sh \"$S/gen-installer.sh\" \\\n+        --image-dir=\"$TEST_DIR/image1\" \\\n+        --work-dir=\"$WORK_DIR\" \\\n+        --output-dir=\"$OUT_DIR\" \\\n+        --package-name=\"rustc\" \\\n+        --component-name=\"rustc\" \\\n+        --compression-formats=\"gz,xz\"\n+\n+    try test -e \"${OUT_DIR}/rustc.tar.gz\"\n+    try test -e \"${OUT_DIR}/rustc.tar.xz\"\n+}\n+runtest generate_compression_formats_multiple\n+\n+generate_compression_formats_error() {\n+    expect_fail sh \"$S/gen-installer.sh\" \\\n+        --image-dir=\"$TEST_DIR/image1\" \\\n+        --work-dir=\"$WORK_DIR\" \\\n+        --output-dir=\"$OUT_DIR\" \\\n+        --package-name=\"rustc\" \\\n+        --component-name=\"rustc\" \\\n+        --compression-formats=\"xz,foobar\"\n+}\n+runtest generate_compression_formats_error\n+\n+combine_compression_formats_one() {\n+    try sh \"$S/gen-installer.sh\" \\\n+        --image-dir=\"$TEST_DIR/image1\" \\\n+        --work-dir=\"$WORK_DIR\" \\\n+        --output-dir=\"$OUT_DIR\" \\\n+        --package-name=rustc \\\n+        --component-name=rustc\n+    try sh \"$S/gen-installer.sh\" \\\n+        --image-dir=\"$TEST_DIR/image3\" \\\n+        --work-dir=\"$WORK_DIR\" \\\n+        --output-dir=\"$OUT_DIR\" \\\n+        --package-name=cargo \\\n+        --component-name=cargo\n+    try sh \"$S/combine-installers.sh\" \\\n+        --work-dir=\"$WORK_DIR\" \\\n+        --output-dir=\"$OUT_DIR\" \\\n+        --package-name=rust \\\n+        --input-tarballs=\"$OUT_DIR/rustc.tar.gz,$OUT_DIR/cargo.tar.gz\" \\\n+        --compression-formats=xz\n+\n+    try test ! -e \"${OUT_DIR}/rust.tar.gz\"\n+    try test -e \"${OUT_DIR}/rust.tar.xz\"\n+}\n+runtest combine_compression_formats_one\n+\n+combine_compression_formats_multiple() {\n+    try sh \"$S/gen-installer.sh\" \\\n+        --image-dir=\"$TEST_DIR/image1\" \\\n+        --work-dir=\"$WORK_DIR\" \\\n+        --output-dir=\"$OUT_DIR\" \\\n+        --package-name=rustc \\\n+        --component-name=rustc\n+    try sh \"$S/gen-installer.sh\" \\\n+        --image-dir=\"$TEST_DIR/image3\" \\\n+        --work-dir=\"$WORK_DIR\" \\\n+        --output-dir=\"$OUT_DIR\" \\\n+        --package-name=cargo \\\n+        --component-name=cargo\n+    try sh \"$S/combine-installers.sh\" \\\n+        --work-dir=\"$WORK_DIR\" \\\n+        --output-dir=\"$OUT_DIR\" \\\n+        --package-name=rust \\\n+        --input-tarballs=\"$OUT_DIR/rustc.tar.gz,$OUT_DIR/cargo.tar.gz\" \\\n+        --compression-formats=xz,gz\n+\n+    try test -e \"${OUT_DIR}/rust.tar.gz\"\n+    try test -e \"${OUT_DIR}/rust.tar.xz\"\n+}\n+runtest combine_compression_formats_multiple\n+\n+combine_compression_formats_error() {\n+    try sh \"$S/gen-installer.sh\" \\\n+        --image-dir=\"$TEST_DIR/image1\" \\\n+        --work-dir=\"$WORK_DIR\" \\\n+        --output-dir=\"$OUT_DIR\" \\\n+        --package-name=rustc \\\n+        --component-name=rustc\n+    try sh \"$S/gen-installer.sh\" \\\n+        --image-dir=\"$TEST_DIR/image3\" \\\n+        --work-dir=\"$WORK_DIR\" \\\n+        --output-dir=\"$OUT_DIR\" \\\n+        --package-name=cargo \\\n+        --component-name=cargo\n+    expect_fail sh \"$S/combine-installers.sh\" \\\n+        --work-dir=\"$WORK_DIR\" \\\n+        --output-dir=\"$OUT_DIR\" \\\n+        --package-name=rust \\\n+        --input-tarballs=\"$OUT_DIR/rustc.tar.gz,$OUT_DIR/cargo.tar.gz\" \\\n+        --compression-formats=xz,foobar\n+}\n+runtest combine_compression_formats_error\n+\n+tarball_compression_formats_one() {\n+    try cp -r \"${TEST_DIR}/image1\" \"${WORK_DIR}/image\"\n+    try sh \"$S/make-tarballs.sh\" \\\n+        --input=\"${WORK_DIR}/image\" \\\n+        --work-dir=\"${WORK_DIR}\" \\\n+        --output=\"${OUT_DIR}/rustc\" \\\n+        --compression-formats=\"xz\"\n+\n+    try test ! -e \"${OUT_DIR}/rustc.tar.gz\"\n+    try test -e \"${OUT_DIR}/rustc.tar.xz\"\n+}\n+runtest tarball_compression_formats_one\n+\n+tarball_compression_formats_multiple() {\n+    try cp -r \"${TEST_DIR}/image1\" \"${WORK_DIR}/image\"\n+    try sh \"$S/make-tarballs.sh\" \\\n+        --input=\"${WORK_DIR}/image\" \\\n+        --work-dir=\"${WORK_DIR}\" \\\n+        --output=\"${OUT_DIR}/rustc\" \\\n+        --compression-formats=\"xz,gz\"\n+\n+    try test -e \"${OUT_DIR}/rustc.tar.gz\"\n+    try test -e \"${OUT_DIR}/rustc.tar.xz\"\n+}\n+runtest tarball_compression_formats_multiple\n+\n+tarball_compression_formats_error() {\n+    try cp -r \"${TEST_DIR}/image1\" \"${WORK_DIR}/image\"\n+    expect_fail sh \"$S/make-tarballs.sh\" \\\n+        --input=\"${WORK_DIR}/image\" \\\n+        --work-dir=\"${WORK_DIR}\" \\\n+        --output=\"${OUT_DIR}/rustc\" \\\n+        --compression-formats=\"xz,foobar\"\n+}\n+runtest tarball_compression_formats_error\n+\n+echo\n+echo \"TOTAL SUCCESS!\"\n+echo"}, {"sha": "871732e64f9459ce08344d55a240f1525d8b5b12", "filename": "src/tools/rust-installer/test/image-docdir1/share/doc/rust/README", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage-docdir1%2Fshare%2Fdoc%2Frust%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage-docdir1%2Fshare%2Fdoc%2Frust%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Ftest%2Fimage-docdir1%2Fshare%2Fdoc%2Frust%2FREADME?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1 @@\n+rust"}, {"sha": "871732e64f9459ce08344d55a240f1525d8b5b12", "filename": "src/tools/rust-installer/test/image-docdir1/share/doc/rust/rustdocs.txt", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage-docdir1%2Fshare%2Fdoc%2Frust%2Frustdocs.txt", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage-docdir1%2Fshare%2Fdoc%2Frust%2Frustdocs.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Ftest%2Fimage-docdir1%2Fshare%2Fdoc%2Frust%2Frustdocs.txt?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1 @@\n+rust"}, {"sha": "033a48cafdf50b6d930dcdc90978e23e0c365161", "filename": "src/tools/rust-installer/test/image-docdir2/share/doc/cargo/README", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage-docdir2%2Fshare%2Fdoc%2Fcargo%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage-docdir2%2Fshare%2Fdoc%2Fcargo%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Ftest%2Fimage-docdir2%2Fshare%2Fdoc%2Fcargo%2FREADME?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1 @@\n+cargo"}, {"sha": "033a48cafdf50b6d930dcdc90978e23e0c365161", "filename": "src/tools/rust-installer/test/image-docdir2/share/doc/cargo/cargodocs.txt", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage-docdir2%2Fshare%2Fdoc%2Fcargo%2Fcargodocs.txt", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage-docdir2%2Fshare%2Fdoc%2Fcargo%2Fcargodocs.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Ftest%2Fimage-docdir2%2Fshare%2Fdoc%2Fcargo%2Fcargodocs.txt?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1 @@\n+cargo"}, {"sha": "b5b0e3234b424b6dcf7bb230dec52185ed51decc", "filename": "src/tools/rust-installer/test/image1/bin/bad-bin", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage1%2Fbin%2Fbad-bin", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage1%2Fbin%2Fbad-bin", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Ftest%2Fimage1%2Fbin%2Fbad-bin?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1 @@\n+#!/bin/bogus\n\\ No newline at end of file"}, {"sha": "96b4b06ad41630359f54d12db5d43eb52e076ed8", "filename": "src/tools/rust-installer/test/image1/bin/program", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage1%2Fbin%2Fprogram", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage1%2Fbin%2Fprogram", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Ftest%2Fimage1%2Fbin%2Fprogram?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1 @@\n+#!/bin/sh\n\\ No newline at end of file"}, {"sha": "96b4b06ad41630359f54d12db5d43eb52e076ed8", "filename": "src/tools/rust-installer/test/image1/bin/program2", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage1%2Fbin%2Fprogram2", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage1%2Fbin%2Fprogram2", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Ftest%2Fimage1%2Fbin%2Fprogram2?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1 @@\n+#!/bin/sh\n\\ No newline at end of file"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/tools/rust-installer/test/image1/dir-to-install/foo", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage1%2Fdir-to-install%2Ffoo", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage1%2Fdir-to-install%2Ffoo", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Ftest%2Fimage1%2Fdir-to-install%2Ffoo?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/tools/rust-installer/test/image1/dir-to-not-install/foo", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage1%2Fdir-to-not-install%2Ffoo", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage1%2Fdir-to-not-install%2Ffoo", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Ftest%2Fimage1%2Fdir-to-not-install%2Ffoo?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/tools/rust-installer/test/image1/something-to-install", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage1%2Fsomething-to-install", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage1%2Fsomething-to-install", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Ftest%2Fimage1%2Fsomething-to-install?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/tools/rust-installer/test/image1/something-to-not-install", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage1%2Fsomething-to-not-install", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage1%2Fsomething-to-not-install", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Ftest%2Fimage1%2Fsomething-to-not-install?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c"}, {"sha": "96b4b06ad41630359f54d12db5d43eb52e076ed8", "filename": "src/tools/rust-installer/test/image2/bin/oldprogram", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage2%2Fbin%2Foldprogram", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage2%2Fbin%2Foldprogram", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Ftest%2Fimage2%2Fbin%2Foldprogram?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1 @@\n+#!/bin/sh\n\\ No newline at end of file"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/tools/rust-installer/test/image2/dir-to-install/bar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage2%2Fdir-to-install%2Fbar", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage2%2Fdir-to-install%2Fbar", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Ftest%2Fimage2%2Fdir-to-install%2Fbar?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/tools/rust-installer/test/image2/something-to-install", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage2%2Fsomething-to-install", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage2%2Fsomething-to-install", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Ftest%2Fimage2%2Fsomething-to-install?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c"}, {"sha": "96b4b06ad41630359f54d12db5d43eb52e076ed8", "filename": "src/tools/rust-installer/test/image3/bin/cargo", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage3%2Fbin%2Fcargo", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage3%2Fbin%2Fcargo", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Ftest%2Fimage3%2Fbin%2Fcargo?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c", "patch": "@@ -0,0 +1 @@\n+#!/bin/sh\n\\ No newline at end of file"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/tools/rust-installer/test/image4/baz", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage4%2Fbaz", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage4%2Fbaz", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Ftest%2Fimage4%2Fbaz?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/tools/rust-installer/test/image4/dir-to-install/qux/bar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage4%2Fdir-to-install%2Fqux%2Fbar", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage4%2Fdir-to-install%2Fqux%2Fbar", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Ftest%2Fimage4%2Fdir-to-install%2Fqux%2Fbar?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/tools/rust-installer/test/image5/dir-to-install/foo", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage5%2Fdir-to-install%2Ffoo", "raw_url": "https://github.com/rust-lang/rust/raw/8d9cef4709db316c35d78d3cd1d13d970edbd57c/src%2Ftools%2Frust-installer%2Ftest%2Fimage5%2Fdir-to-install%2Ffoo", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Ftest%2Fimage5%2Fdir-to-install%2Ffoo?ref=8d9cef4709db316c35d78d3cd1d13d970edbd57c"}]}