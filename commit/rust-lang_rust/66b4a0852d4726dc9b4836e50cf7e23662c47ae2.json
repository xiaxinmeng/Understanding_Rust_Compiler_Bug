{"sha": "66b4a0852d4726dc9b4836e50cf7e23662c47ae2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2YjRhMDg1MmQ0NzI2ZGM5YjQ4MzZlNTBjZjdlMjM2NjJjNDdhZTI=", "commit": {"author": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2019-02-08T11:44:16Z"}, "committer": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2019-03-20T19:09:26Z"}, "message": "Reorganize `chalk_context::program_clauses`", "tree": {"sha": "0f286f6c684d42a86ca8074920a1a766a623bdc1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f286f6c684d42a86ca8074920a1a766a623bdc1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66b4a0852d4726dc9b4836e50cf7e23662c47ae2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66b4a0852d4726dc9b4836e50cf7e23662c47ae2", "html_url": "https://github.com/rust-lang/rust/commit/66b4a0852d4726dc9b4836e50cf7e23662c47ae2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66b4a0852d4726dc9b4836e50cf7e23662c47ae2/comments", "author": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60ea7cbe4eebc04e8910c63baeabd5d385fadc4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/60ea7cbe4eebc04e8910c63baeabd5d385fadc4c", "html_url": "https://github.com/rust-lang/rust/commit/60ea7cbe4eebc04e8910c63baeabd5d385fadc4c"}], "stats": {"total": 662, "additions": 343, "deletions": 319}, "files": [{"sha": "3622cacbb012e555672123005b5140d05d8bd71a", "filename": "src/librustc_traits/chalk_context/program_clauses/builtin.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/66b4a0852d4726dc9b4836e50cf7e23662c47ae2/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b4a0852d4726dc9b4836e50cf7e23662c47ae2/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs?ref=66b4a0852d4726dc9b4836e50cf7e23662c47ae2", "patch": "@@ -0,0 +1,132 @@\n+use rustc::traits::{\n+    GoalKind,\n+    Clause,\n+    ProgramClause,\n+    ProgramClauseCategory,\n+};\n+use rustc::ty;\n+use rustc::ty::subst::{InternalSubsts, Subst};\n+use rustc::hir::def_id::DefId;\n+use crate::lowering::Lower;\n+use crate::generic_types;\n+\n+crate fn assemble_builtin_sized_impls<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    sized_def_id: DefId,\n+    ty: ty::Ty<'tcx>,\n+    clauses: &mut Vec<Clause<'tcx>>\n+) {\n+    let mut push_builtin_impl = |ty: ty::Ty<'tcx>, nested: &[ty::Ty<'tcx>]| {\n+        let clause = ProgramClause {\n+            goal: ty::TraitPredicate {\n+                trait_ref: ty::TraitRef {\n+                    def_id: sized_def_id,\n+                    substs: tcx.mk_substs_trait(ty, &[]),\n+                },\n+            }.lower(),\n+            hypotheses: tcx.mk_goals(\n+                nested.iter()\n+                    .cloned()\n+                    .map(|nested_ty| ty::TraitRef {\n+                        def_id: sized_def_id,\n+                        substs: tcx.mk_substs_trait(nested_ty, &[]),\n+                    })\n+                    .map(|trait_ref| ty::TraitPredicate { trait_ref })\n+                    .map(|pred| GoalKind::DomainGoal(pred.lower()))\n+                    .map(|goal_kind| tcx.mk_goal(goal_kind))\n+            ),\n+            category: ProgramClauseCategory::Other,\n+        };\n+        // Bind innermost bound vars that may exist in `ty` and `nested`.\n+        clauses.push(Clause::ForAll(ty::Binder::bind(clause)));\n+    };\n+\n+    match &ty.sty {\n+        // Non parametric primitive types.\n+        ty::Bool |\n+        ty::Char |\n+        ty::Int(..) |\n+        ty::Uint(..) |\n+        ty::Float(..) |\n+        ty::Error |\n+        ty::Never => push_builtin_impl(ty, &[]),\n+\n+        // These ones are always `Sized`.\n+        &ty::Array(_, length) => {\n+            push_builtin_impl(tcx.mk_ty(ty::Array(generic_types::bound(tcx, 0), length)), &[]);\n+        }\n+        ty::RawPtr(ptr) => {\n+            push_builtin_impl(generic_types::raw_ptr(tcx, ptr.mutbl), &[]);\n+        }\n+        &ty::Ref(_, _, mutbl) => {\n+            push_builtin_impl(generic_types::ref_ty(tcx, mutbl), &[]);\n+        }\n+        ty::FnPtr(fn_ptr) => {\n+            let fn_ptr = fn_ptr.skip_binder();\n+            let fn_ptr = generic_types::fn_ptr(\n+                tcx,\n+                fn_ptr.inputs_and_output.len(),\n+                fn_ptr.c_variadic,\n+                fn_ptr.unsafety,\n+                fn_ptr.abi\n+            );\n+            push_builtin_impl(fn_ptr, &[]);\n+        }\n+        &ty::FnDef(def_id, ..) => {\n+            push_builtin_impl(generic_types::fn_def(tcx, def_id), &[]);\n+        }\n+        &ty::Closure(def_id, ..) => {\n+            push_builtin_impl(generic_types::closure(tcx, def_id), &[]);\n+        }\n+        &ty::Generator(def_id, ..) => {\n+            push_builtin_impl(generic_types::generator(tcx, def_id), &[]);\n+        }\n+\n+        // `Sized` if the last type is `Sized` (because else we will get a WF error anyway).\n+        &ty::Tuple(type_list) => {\n+            let type_list = generic_types::type_list(tcx, type_list.len());\n+            push_builtin_impl(tcx.mk_ty(ty::Tuple(type_list)), &**type_list);\n+        }\n+\n+        // Struct def\n+        ty::Adt(adt_def, _) => {\n+            let substs = InternalSubsts::bound_vars_for_item(tcx, adt_def.did);\n+            let adt = tcx.mk_ty(ty::Adt(adt_def, substs));\n+            let sized_constraint = adt_def.sized_constraint(tcx)\n+                .iter()\n+                .map(|ty| ty.subst(tcx, substs))\n+                .collect::<Vec<_>>();\n+            push_builtin_impl(adt, &sized_constraint);\n+        }\n+\n+        // Artificially trigger an ambiguity.\n+        ty::Infer(..) => {\n+            // Everybody can find at least two types to unify against:\n+            // general ty vars, int vars and float vars.\n+            push_builtin_impl(tcx.types.i32, &[]);\n+            push_builtin_impl(tcx.types.u32, &[]);\n+            push_builtin_impl(tcx.types.f32, &[]);\n+            push_builtin_impl(tcx.types.f64, &[]);\n+        }\n+\n+        ty::Projection(_projection_ty) => {\n+            // FIXME: add builtin impls from the associated type values found in\n+            // trait impls of `projection_ty.trait_ref(tcx)`.\n+        }\n+\n+        // The `Sized` bound can only come from the environment.\n+        ty::Param(..) |\n+        ty::Placeholder(..) |\n+        ty::UnnormalizedProjection(..) => (),\n+\n+        // Definitely not `Sized`.\n+        ty::Foreign(..) |\n+        ty::Str |\n+        ty::Slice(..) |\n+        ty::Dynamic(..) |\n+        ty::Opaque(..) => (),\n+\n+        ty::Bound(..) |\n+        ty::GeneratorWitness(..) => bug!(\"unexpected type {:?}\", ty),\n+    }\n+}"}, {"sha": "b6fb70b05777983ea3a9ddbd9e29e3bccc4acd01", "filename": "src/librustc_traits/chalk_context/program_clauses/mod.rs", "status": "renamed", "additions": 7, "deletions": 319, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/66b4a0852d4726dc9b4836e50cf7e23662c47ae2/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b4a0852d4726dc9b4836e50cf7e23662c47ae2/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs?ref=66b4a0852d4726dc9b4836e50cf7e23662c47ae2", "patch": "@@ -1,24 +1,23 @@\n+mod builtin;\n+mod primitive;\n+\n use rustc::traits::{\n     WellFormed,\n     FromEnv,\n     DomainGoal,\n-    GoalKind,\n     Clause,\n-    Clauses,\n     ProgramClause,\n     ProgramClauseCategory,\n     Environment,\n };\n use rustc::ty;\n-use rustc::ty::subst::{InternalSubsts, Subst};\n-use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc_target::spec::abi;\n use super::ChalkInferenceContext;\n-use crate::lowering::Lower;\n-use crate::generic_types;\n use std::iter;\n \n+use self::primitive::*;\n+use self::builtin::*;\n+\n fn assemble_clauses_from_impls<'tcx>(\n     tcx: ty::TyCtxt<'_, '_, 'tcx>,\n     trait_def_id: DefId,\n@@ -49,315 +48,6 @@ fn assemble_clauses_from_assoc_ty_values<'tcx>(\n     });\n }\n \n-fn assemble_builtin_sized_impls<'tcx>(\n-    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n-    sized_def_id: DefId,\n-    ty: ty::Ty<'tcx>,\n-    clauses: &mut Vec<Clause<'tcx>>\n-) {\n-    let mut push_builtin_impl = |ty: ty::Ty<'tcx>, nested: &[ty::Ty<'tcx>]| {\n-        let clause = ProgramClause {\n-            goal: ty::TraitPredicate {\n-                trait_ref: ty::TraitRef {\n-                    def_id: sized_def_id,\n-                    substs: tcx.mk_substs_trait(ty, &[]),\n-                },\n-            }.lower(),\n-            hypotheses: tcx.mk_goals(\n-                nested.iter()\n-                    .cloned()\n-                    .map(|nested_ty| ty::TraitRef {\n-                        def_id: sized_def_id,\n-                        substs: tcx.mk_substs_trait(nested_ty, &[]),\n-                    })\n-                    .map(|trait_ref| ty::TraitPredicate { trait_ref })\n-                    .map(|pred| GoalKind::DomainGoal(pred.lower()))\n-                    .map(|goal_kind| tcx.mk_goal(goal_kind))\n-            ),\n-            category: ProgramClauseCategory::Other,\n-        };\n-        // Bind innermost bound vars that may exist in `ty` and `nested`.\n-        clauses.push(Clause::ForAll(ty::Binder::bind(clause)));\n-    };\n-\n-    match &ty.sty {\n-        // Non parametric primitive types.\n-        ty::Bool |\n-        ty::Char |\n-        ty::Int(..) |\n-        ty::Uint(..) |\n-        ty::Float(..) |\n-        ty::Error |\n-        ty::Never => push_builtin_impl(ty, &[]),\n-\n-        // These ones are always `Sized`.\n-        &ty::Array(_, length) => {\n-            push_builtin_impl(tcx.mk_ty(ty::Array(generic_types::bound(tcx, 0), length)), &[]);\n-        }\n-        ty::RawPtr(ptr) => {\n-            push_builtin_impl(generic_types::raw_ptr(tcx, ptr.mutbl), &[]);\n-        }\n-        &ty::Ref(_, _, mutbl) => {\n-            push_builtin_impl(generic_types::ref_ty(tcx, mutbl), &[]);\n-        }\n-        ty::FnPtr(fn_ptr) => {\n-            let fn_ptr = fn_ptr.skip_binder();\n-            let fn_ptr = generic_types::fn_ptr(\n-                tcx,\n-                fn_ptr.inputs_and_output.len(),\n-                fn_ptr.c_variadic,\n-                fn_ptr.unsafety,\n-                fn_ptr.abi\n-            );\n-            push_builtin_impl(fn_ptr, &[]);\n-        }\n-        &ty::FnDef(def_id, ..) => {\n-            push_builtin_impl(generic_types::fn_def(tcx, def_id), &[]);\n-        }\n-        &ty::Closure(def_id, ..) => {\n-            push_builtin_impl(generic_types::closure(tcx, def_id), &[]);\n-        }\n-        &ty::Generator(def_id, ..) => {\n-            push_builtin_impl(generic_types::generator(tcx, def_id), &[]);\n-        }\n-\n-        // `Sized` if the last type is `Sized` (because else we will get a WF error anyway).\n-        &ty::Tuple(type_list) => {\n-            let type_list = generic_types::type_list(tcx, type_list.len());\n-            push_builtin_impl(tcx.mk_ty(ty::Tuple(type_list)), &**type_list);\n-        }\n-\n-        // Struct def\n-        ty::Adt(adt_def, _) => {\n-            let substs = InternalSubsts::bound_vars_for_item(tcx, adt_def.did);\n-            let adt = tcx.mk_ty(ty::Adt(adt_def, substs));\n-            let sized_constraint = adt_def.sized_constraint(tcx)\n-                .iter()\n-                .map(|ty| ty.subst(tcx, substs))\n-                .collect::<Vec<_>>();\n-            push_builtin_impl(adt, &sized_constraint);\n-        }\n-\n-        // Artificially trigger an ambiguity.\n-        ty::Infer(..) => {\n-            // Everybody can find at least two types to unify against:\n-            // general ty vars, int vars and float vars.\n-            push_builtin_impl(tcx.types.i32, &[]);\n-            push_builtin_impl(tcx.types.u32, &[]);\n-            push_builtin_impl(tcx.types.f32, &[]);\n-            push_builtin_impl(tcx.types.f64, &[]);\n-        }\n-\n-        ty::Projection(_projection_ty) => {\n-            // FIXME: add builtin impls from the associated type values found in\n-            // trait impls of `projection_ty.trait_ref(tcx)`.\n-        }\n-\n-        // The `Sized` bound can only come from the environment.\n-        ty::Param(..) |\n-        ty::Placeholder(..) |\n-        ty::UnnormalizedProjection(..) => (),\n-\n-        // Definitely not `Sized`.\n-        ty::Foreign(..) |\n-        ty::Str |\n-        ty::Slice(..) |\n-        ty::Dynamic(..) |\n-        ty::Opaque(..) => (),\n-\n-        ty::Bound(..) |\n-        ty::GeneratorWitness(..) => bug!(\"unexpected type {:?}\", ty),\n-    }\n-}\n-\n-fn wf_clause_for_raw_ptr<'tcx>(\n-    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n-    mutbl: hir::Mutability\n-) -> Clauses<'tcx> {\n-    let ptr_ty = generic_types::raw_ptr(tcx, mutbl);\n-\n-    let wf_clause = ProgramClause {\n-        goal: DomainGoal::WellFormed(WellFormed::Ty(ptr_ty)),\n-        hypotheses: ty::List::empty(),\n-        category: ProgramClauseCategory::WellFormed,\n-    };\n-    let wf_clause = Clause::Implies(wf_clause);\n-\n-    // `forall<T> { WellFormed(*const T). }`\n-    tcx.mk_clauses(iter::once(wf_clause))\n-}\n-\n-fn wf_clause_for_fn_ptr<'tcx>(\n-    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n-    arity_and_output: usize,\n-    c_variadic: bool,\n-    unsafety: hir::Unsafety,\n-    abi: abi::Abi\n-) -> Clauses<'tcx> {\n-    let fn_ptr = generic_types::fn_ptr(tcx, arity_and_output, c_variadic, unsafety, abi);\n-\n-    let wf_clause = ProgramClause {\n-        goal: DomainGoal::WellFormed(WellFormed::Ty(fn_ptr)),\n-        hypotheses: ty::List::empty(),\n-        category: ProgramClauseCategory::WellFormed,\n-    };\n-    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n-\n-    // `forall <T1, ..., Tn+1> { WellFormed(for<> fn(T1, ..., Tn) -> Tn+1). }`\n-    // where `n + 1` == `arity_and_output`\n-    tcx.mk_clauses(iter::once(wf_clause))\n-}\n-\n-fn wf_clause_for_slice<'tcx>(tcx: ty::TyCtxt<'_, '_, 'tcx>) -> Clauses<'tcx> {\n-    let ty = generic_types::bound(tcx, 0);\n-    let slice_ty = tcx.mk_slice(ty);\n-\n-    let sized_trait = match tcx.lang_items().sized_trait() {\n-        Some(def_id) => def_id,\n-        None => return ty::List::empty(),\n-    };\n-    let sized_implemented = ty::TraitRef {\n-        def_id: sized_trait,\n-        substs: tcx.mk_substs_trait(ty, ty::List::empty()),\n-    };\n-    let sized_implemented: DomainGoal<'_> = ty::TraitPredicate {\n-        trait_ref: sized_implemented\n-    }.lower();\n-\n-    let wf_clause = ProgramClause {\n-        goal: DomainGoal::WellFormed(WellFormed::Ty(slice_ty)),\n-        hypotheses: tcx.mk_goals(\n-            iter::once(tcx.mk_goal(GoalKind::DomainGoal(sized_implemented)))\n-        ),\n-        category: ProgramClauseCategory::WellFormed,\n-    };\n-    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n-\n-    // `forall<T> { WellFormed([T]) :- Implemented(T: Sized). }`\n-    tcx.mk_clauses(iter::once(wf_clause))\n-}\n-\n-fn wf_clause_for_array<'tcx>(\n-    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n-    length: &'tcx ty::Const<'tcx>\n-) -> Clauses<'tcx> {\n-    let ty = generic_types::bound(tcx, 0);\n-    let array_ty = tcx.mk_ty(ty::Array(ty, length));\n-\n-    let sized_trait = match tcx.lang_items().sized_trait() {\n-        Some(def_id) => def_id,\n-        None => return ty::List::empty(),\n-    };\n-    let sized_implemented = ty::TraitRef {\n-        def_id: sized_trait,\n-        substs: tcx.mk_substs_trait(ty, ty::List::empty()),\n-    };\n-    let sized_implemented: DomainGoal<'_> = ty::TraitPredicate {\n-        trait_ref: sized_implemented\n-    }.lower();\n-\n-    let wf_clause = ProgramClause {\n-        goal: DomainGoal::WellFormed(WellFormed::Ty(array_ty)),\n-        hypotheses: tcx.mk_goals(\n-            iter::once(tcx.mk_goal(GoalKind::DomainGoal(sized_implemented)))\n-        ),\n-        category: ProgramClauseCategory::WellFormed,\n-    };\n-    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n-\n-    // `forall<T> { WellFormed([T; length]) :- Implemented(T: Sized). }`\n-    tcx.mk_clauses(iter::once(wf_clause))\n-}\n-\n-fn wf_clause_for_tuple<'tcx>(\n-    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n-    arity: usize\n-) -> Clauses<'tcx> {\n-    let type_list = generic_types::type_list(tcx, arity);\n-    let tuple_ty = tcx.mk_ty(ty::Tuple(type_list));\n-\n-    let sized_trait = match tcx.lang_items().sized_trait() {\n-        Some(def_id) => def_id,\n-        None => return ty::List::empty(),\n-    };\n-\n-    // If `arity == 0` (i.e. the unit type) or `arity == 1`, this list of\n-    // hypotheses is actually empty.\n-    let sized_implemented = type_list[0 .. std::cmp::max(arity, 1) - 1].iter()\n-        .map(|ty| ty::TraitRef {\n-            def_id: sized_trait,\n-            substs: tcx.mk_substs_trait(*ty, ty::List::empty()),\n-        })\n-        .map(|trait_ref| ty::TraitPredicate { trait_ref })\n-        .map(|predicate| predicate.lower());\n-\n-    let wf_clause = ProgramClause {\n-        goal: DomainGoal::WellFormed(WellFormed::Ty(tuple_ty)),\n-        hypotheses: tcx.mk_goals(\n-            sized_implemented.map(|domain_goal| {\n-                tcx.mk_goal(GoalKind::DomainGoal(domain_goal))\n-            })\n-        ),\n-        category: ProgramClauseCategory::WellFormed,\n-    };\n-    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n-\n-    // ```\n-    // forall<T1, ..., Tn-1, Tn> {\n-    //     WellFormed((T1, ..., Tn)) :-\n-    //         Implemented(T1: Sized),\n-    //         ...\n-    //         Implemented(Tn-1: Sized).\n-    // }\n-    // ```\n-    tcx.mk_clauses(iter::once(wf_clause))\n-}\n-\n-fn wf_clause_for_ref<'tcx>(\n-    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n-    mutbl: hir::Mutability\n-) -> Clauses<'tcx> {\n-    let region = tcx.mk_region(\n-        ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(0))\n-    );\n-    let ty = generic_types::bound(tcx, 1);\n-    let ref_ty = tcx.mk_ref(region, ty::TypeAndMut {\n-        ty,\n-        mutbl,\n-    });\n-\n-    let outlives: DomainGoal<'_> = ty::OutlivesPredicate(ty, region).lower();\n-    let wf_clause = ProgramClause {\n-        goal: DomainGoal::WellFormed(WellFormed::Ty(ref_ty)),\n-        hypotheses: tcx.mk_goals(\n-            iter::once(tcx.mk_goal(outlives.into_goal()))\n-        ),\n-        category: ProgramClauseCategory::WellFormed,\n-    };\n-    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n-\n-    // `forall<'a, T> { WellFormed(&'a T) :- Outlives(T: 'a). }`\n-    tcx.mk_clauses(iter::once(wf_clause))\n-}\n-\n-fn wf_clause_for_fn_def<'tcx>(\n-    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n-    def_id: DefId\n-) -> Clauses<'tcx> {\n-    let fn_def = generic_types::fn_def(tcx, def_id);\n-\n-    let wf_clause = ProgramClause {\n-        goal: DomainGoal::WellFormed(WellFormed::Ty(fn_def)),\n-        hypotheses: ty::List::empty(),\n-        category: ProgramClauseCategory::WellFormed,\n-    };\n-    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n-\n-    // `forall <T1, ..., Tn+1> { WellFormed(fn some_fn(T1, ..., Tn) -> Tn+1). }`\n-    // where `def_id` maps to the `some_fn` function definition\n-    tcx.mk_clauses(iter::once(wf_clause))\n-}\n-\n impl ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n     pub(super) fn program_clauses_impl(\n         &self,\n@@ -394,10 +84,8 @@ impl ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n                     );\n                 }\n \n-                // FIXME: we need to add special rules for builtin impls:\n+                // FIXME: we need to add special rules for other builtin impls:\n                 // * `Copy` / `Clone`\n-                // * `Sized`\n-                // * `Unsize`\n                 // * `Generator`\n                 // * `FnOnce` / `FnMut` / `Fn`\n                 // * trait objects", "previous_filename": "src/librustc_traits/chalk_context/program_clauses.rs"}, {"sha": "fc6d40914745dca03ee84e9b8c5fa941cb494e08", "filename": "src/librustc_traits/chalk_context/program_clauses/primitive.rs", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/66b4a0852d4726dc9b4836e50cf7e23662c47ae2/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b4a0852d4726dc9b4836e50cf7e23662c47ae2/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs?ref=66b4a0852d4726dc9b4836e50cf7e23662c47ae2", "patch": "@@ -0,0 +1,204 @@\n+use rustc::traits::{\n+    WellFormed,\n+    DomainGoal,\n+    GoalKind,\n+    Clause,\n+    Clauses,\n+    ProgramClause,\n+    ProgramClauseCategory,\n+};\n+use rustc::ty;\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc_target::spec::abi;\n+use crate::lowering::Lower;\n+use crate::generic_types;\n+use std::iter;\n+\n+crate fn wf_clause_for_raw_ptr<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    mutbl: hir::Mutability\n+) -> Clauses<'tcx> {\n+    let ptr_ty = generic_types::raw_ptr(tcx, mutbl);\n+\n+    let wf_clause = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(ptr_ty)),\n+        hypotheses: ty::List::empty(),\n+        category: ProgramClauseCategory::WellFormed,\n+    };\n+    let wf_clause = Clause::Implies(wf_clause);\n+\n+    // `forall<T> { WellFormed(*const T). }`\n+    tcx.mk_clauses(iter::once(wf_clause))\n+}\n+\n+crate fn wf_clause_for_fn_ptr<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    arity_and_output: usize,\n+    variadic: bool,\n+    unsafety: hir::Unsafety,\n+    abi: abi::Abi\n+) -> Clauses<'tcx> {\n+    let fn_ptr = generic_types::fn_ptr(tcx, arity_and_output, variadic, unsafety, abi);\n+\n+    let wf_clause = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(fn_ptr)),\n+        hypotheses: ty::List::empty(),\n+        category: ProgramClauseCategory::WellFormed,\n+    };\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n+\n+    // `forall <T1, ..., Tn+1> { WellFormed(for<> fn(T1, ..., Tn) -> Tn+1). }`\n+    // where `n + 1` == `arity_and_output`\n+    tcx.mk_clauses(iter::once(wf_clause))\n+}\n+\n+crate fn wf_clause_for_slice<'tcx>(tcx: ty::TyCtxt<'_, '_, 'tcx>) -> Clauses<'tcx> {\n+    let ty = generic_types::bound(tcx, 0);\n+    let slice_ty = tcx.mk_slice(ty);\n+\n+    let sized_trait = match tcx.lang_items().sized_trait() {\n+        Some(def_id) => def_id,\n+        None => return ty::List::empty(),\n+    };\n+    let sized_implemented = ty::TraitRef {\n+        def_id: sized_trait,\n+        substs: tcx.mk_substs_trait(ty, ty::List::empty()),\n+    };\n+    let sized_implemented: DomainGoal<'_> = ty::TraitPredicate {\n+        trait_ref: sized_implemented\n+    }.lower();\n+\n+    let wf_clause = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(slice_ty)),\n+        hypotheses: tcx.mk_goals(\n+            iter::once(tcx.mk_goal(GoalKind::DomainGoal(sized_implemented)))\n+        ),\n+        category: ProgramClauseCategory::WellFormed,\n+    };\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n+\n+    // `forall<T> { WellFormed([T]) :- Implemented(T: Sized). }`\n+    tcx.mk_clauses(iter::once(wf_clause))\n+}\n+\n+crate fn wf_clause_for_array<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    length: &'tcx ty::Const<'tcx>\n+) -> Clauses<'tcx> {\n+    let ty = generic_types::bound(tcx, 0);\n+    let array_ty = tcx.mk_ty(ty::Array(ty, length));\n+\n+    let sized_trait = match tcx.lang_items().sized_trait() {\n+        Some(def_id) => def_id,\n+        None => return ty::List::empty(),\n+    };\n+    let sized_implemented = ty::TraitRef {\n+        def_id: sized_trait,\n+        substs: tcx.mk_substs_trait(ty, ty::List::empty()),\n+    };\n+    let sized_implemented: DomainGoal<'_> = ty::TraitPredicate {\n+        trait_ref: sized_implemented\n+    }.lower();\n+\n+    let wf_clause = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(array_ty)),\n+        hypotheses: tcx.mk_goals(\n+            iter::once(tcx.mk_goal(GoalKind::DomainGoal(sized_implemented)))\n+        ),\n+        category: ProgramClauseCategory::WellFormed,\n+    };\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n+\n+    // `forall<T> { WellFormed([T; length]) :- Implemented(T: Sized). }`\n+    tcx.mk_clauses(iter::once(wf_clause))\n+}\n+\n+crate fn wf_clause_for_tuple<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    arity: usize\n+) -> Clauses<'tcx> {\n+    let type_list = generic_types::type_list(tcx, arity);\n+    let tuple_ty = tcx.mk_ty(ty::Tuple(type_list));\n+\n+    let sized_trait = match tcx.lang_items().sized_trait() {\n+        Some(def_id) => def_id,\n+        None => return ty::List::empty(),\n+    };\n+\n+    // If `arity == 0` (i.e. the unit type) or `arity == 1`, this list of\n+    // hypotheses is actually empty.\n+    let sized_implemented = type_list[0 .. std::cmp::max(arity, 1) - 1].iter()\n+        .map(|ty| ty::TraitRef {\n+            def_id: sized_trait,\n+            substs: tcx.mk_substs_trait(*ty, ty::List::empty()),\n+        })\n+        .map(|trait_ref| ty::TraitPredicate { trait_ref })\n+        .map(|predicate| predicate.lower());\n+\n+    let wf_clause = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(tuple_ty)),\n+        hypotheses: tcx.mk_goals(\n+            sized_implemented.map(|domain_goal| {\n+                tcx.mk_goal(GoalKind::DomainGoal(domain_goal))\n+            })\n+        ),\n+        category: ProgramClauseCategory::WellFormed,\n+    };\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n+\n+    // ```\n+    // forall<T1, ..., Tn-1, Tn> {\n+    //     WellFormed((T1, ..., Tn)) :-\n+    //         Implemented(T1: Sized),\n+    //         ...\n+    //         Implemented(Tn-1: Sized).\n+    // }\n+    // ```\n+    tcx.mk_clauses(iter::once(wf_clause))\n+}\n+\n+crate fn wf_clause_for_ref<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    mutbl: hir::Mutability\n+) -> Clauses<'tcx> {\n+    let region = tcx.mk_region(\n+        ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(0))\n+    );\n+    let ty = generic_types::bound(tcx, 1);\n+    let ref_ty = tcx.mk_ref(region, ty::TypeAndMut {\n+        ty,\n+        mutbl,\n+    });\n+\n+    let outlives: DomainGoal<'_> = ty::OutlivesPredicate(ty, region).lower();\n+    let wf_clause = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(ref_ty)),\n+        hypotheses: tcx.mk_goals(\n+            iter::once(tcx.mk_goal(outlives.into_goal()))\n+        ),\n+        category: ProgramClauseCategory::WellFormed,\n+    };\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n+\n+    // `forall<'a, T> { WellFormed(&'a T) :- Outlives(T: 'a). }`\n+    tcx.mk_clauses(iter::once(wf_clause))\n+}\n+\n+crate fn wf_clause_for_fn_def<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    def_id: DefId\n+) -> Clauses<'tcx> {\n+    let fn_def = generic_types::fn_def(tcx, def_id);\n+\n+    let wf_clause = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(fn_def)),\n+        hypotheses: ty::List::empty(),\n+        category: ProgramClauseCategory::WellFormed,\n+    };\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n+\n+    // `forall <T1, ..., Tn+1> { WellFormed(fn some_fn(T1, ..., Tn) -> Tn+1). }`\n+    // where `def_id` maps to the `some_fn` function definition\n+    tcx.mk_clauses(iter::once(wf_clause))\n+}"}]}