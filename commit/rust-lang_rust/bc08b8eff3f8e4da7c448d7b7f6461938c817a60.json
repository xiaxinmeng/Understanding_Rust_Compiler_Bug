{"sha": "bc08b8eff3f8e4da7c448d7b7f6461938c817a60", "node_id": "C_kwDOAAsO6NoAKGJjMDhiOGVmZjNmOGU0ZGE3YzQ0OGQ3YjdmNjQ2MTkzOGM4MTdhNjA", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-27T17:22:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-27T17:22:02Z"}, "message": "Merge #11833\n\n11833: internal: Move mismatched arg count diagnostic to inference r=flodiebold a=flodiebold\n\nThis means we only need to handle legacy const generics in one place, and it fits there especially since there will be more diagnostics coming.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "3d3a6adf27fd58f4e82e231180145e0ec05a5a65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d3a6adf27fd58f4e82e231180145e0ec05a5a65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc08b8eff3f8e4da7c448d7b7f6461938c817a60", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiQJ06CRBK7hj4Ov3rIwAA1c0IAKc/kZBYrU3xSeNrYT8eVJm1\nfgMKzTYRe+JD65ijap7RrBcy6K57paWCeG8xp/of/CEDNjLrKqS8Lyco00LT73iD\nzNrxAPHd1eTG5fhtGkMz/qJEJlQKpTxMjYn9sSjRglZv/FNUPWhQ4UjXR+vP4qki\nXyjyL2S7lB3Mx9RcQvtz66jJmU4nODcQJHsrQc5AmMdA8CLFlTCPV9vjwvV8XceW\nbQMp3y2cVrVAY1gskjWNMuHBboqJFzXc0VPH3jCSgx6EWKPWhLzlMrteUgXl42GP\nhMyhcRLvwb4DqS3Un40Su4777f1N6TC3Scnrx3D2kkpwW5d9Y9yVZqBLx/xS8gw=\n=ze5i\n-----END PGP SIGNATURE-----\n", "payload": "tree 3d3a6adf27fd58f4e82e231180145e0ec05a5a65\nparent 837901a4a624f4c1b1e5e7102a3dac79a217c686\nparent c2a31bfbb804b1e7a4ac51ea0f0d40f3ed05d017\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1648401722 +0000\ncommitter GitHub <noreply@github.com> 1648401722 +0000\n\nMerge #11833\n\n11833: internal: Move mismatched arg count diagnostic to inference r=flodiebold a=flodiebold\n\nThis means we only need to handle legacy const generics in one place, and it fits there especially since there will be more diagnostics coming.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc08b8eff3f8e4da7c448d7b7f6461938c817a60", "html_url": "https://github.com/rust-lang/rust/commit/bc08b8eff3f8e4da7c448d7b7f6461938c817a60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc08b8eff3f8e4da7c448d7b7f6461938c817a60/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "837901a4a624f4c1b1e5e7102a3dac79a217c686", "url": "https://api.github.com/repos/rust-lang/rust/commits/837901a4a624f4c1b1e5e7102a3dac79a217c686", "html_url": "https://github.com/rust-lang/rust/commit/837901a4a624f4c1b1e5e7102a3dac79a217c686"}, {"sha": "c2a31bfbb804b1e7a4ac51ea0f0d40f3ed05d017", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2a31bfbb804b1e7a4ac51ea0f0d40f3ed05d017", "html_url": "https://github.com/rust-lang/rust/commit/c2a31bfbb804b1e7a4ac51ea0f0d40f3ed05d017"}], "stats": {"total": 173, "additions": 70, "deletions": 103}, "files": [{"sha": "c07c017c3df4b95eb519da888a542cb1df1379c1", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bc08b8eff3f8e4da7c448d7b7f6461938c817a60/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc08b8eff3f8e4da7c448d7b7f6461938c817a60/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=bc08b8eff3f8e4da7c448d7b7f6461938c817a60", "patch": "@@ -1183,6 +1183,19 @@ impl DefWithBody {\n                         .expect(\"break outside of loop in synthetic syntax\");\n                     acc.push(BreakOutsideOfLoop { expr }.into())\n                 }\n+                hir_ty::InferenceDiagnostic::MismatchedArgCount { call_expr, expected, found } => {\n+                    match source_map.expr_syntax(*call_expr) {\n+                        Ok(source_ptr) => acc.push(\n+                            MismatchedArgCount {\n+                                call_expr: source_ptr,\n+                                expected: *expected,\n+                                found: *found,\n+                            }\n+                            .into(),\n+                        ),\n+                        Err(SyntheticSyntax) => (),\n+                    }\n+                }\n             }\n         }\n         for (expr, mismatch) in infer.expr_type_mismatches() {\n@@ -1297,14 +1310,6 @@ impl DefWithBody {\n                         );\n                     }\n                 }\n-                BodyValidationDiagnostic::MismatchedArgCount { call_expr, expected, found } => {\n-                    match source_map.expr_syntax(call_expr) {\n-                        Ok(source_ptr) => acc.push(\n-                            MismatchedArgCount { call_expr: source_ptr, expected, found }.into(),\n-                        ),\n-                        Err(SyntheticSyntax) => (),\n-                    }\n-                }\n                 BodyValidationDiagnostic::MissingMatchArms { match_expr } => {\n                     match source_map.expr_syntax(match_expr) {\n                         Ok(source_ptr) => {"}, {"sha": "335d95c0cf2652c0deae27bb458cc5b693134daf", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 4, "deletions": 62, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/bc08b8eff3f8e4da7c448d7b7f6461938c817a60/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc08b8eff3f8e4da7c448d7b7f6461938c817a60/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=bc08b8eff3f8e4da7c448d7b7f6461938c817a60", "patch": "@@ -17,7 +17,7 @@ use crate::{\n         deconstruct_pat::DeconstructedPat,\n         usefulness::{compute_match_usefulness, MatchCheckCtx},\n     },\n-    InferenceResult, Interner, TyExt,\n+    InferenceResult, TyExt,\n };\n \n pub(crate) use hir_def::{\n@@ -35,11 +35,6 @@ pub enum BodyValidationDiagnostic {\n     ReplaceFilterMapNextWithFindMap {\n         method_call_expr: ExprId,\n     },\n-    MismatchedArgCount {\n-        call_expr: ExprId,\n-        expected: usize,\n-        found: usize,\n-    },\n     MissingMatchArms {\n         match_expr: ExprId,\n     },\n@@ -119,18 +114,9 @@ impl ExprValidator {\n             return;\n         }\n \n-        let is_method_call = matches!(expr, Expr::MethodCall { .. });\n-        let (sig, mut arg_count) = match expr {\n-            Expr::Call { callee, args } => {\n-                let callee = &self.infer.type_of_expr[*callee];\n-                let sig = match callee.callable_sig(db) {\n-                    Some(sig) => sig,\n-                    None => return,\n-                };\n-                (sig, args.len())\n-            }\n-            Expr::MethodCall { receiver, args, .. } => {\n-                let (callee, subst) = match self.infer.method_resolution(call_id) {\n+        match expr {\n+            Expr::MethodCall { receiver, .. } => {\n+                let (callee, _) = match self.infer.method_resolution(call_id) {\n                     Some(it) => it,\n                     None => return,\n                 };\n@@ -148,53 +134,9 @@ impl ExprValidator {\n                         },\n                     );\n                 }\n-                let receiver = &self.infer.type_of_expr[*receiver];\n-                if receiver.strip_references().is_unknown() {\n-                    // if the receiver is of unknown type, it's very likely we\n-                    // don't know enough to correctly resolve the method call.\n-                    // This is kind of a band-aid for #6975.\n-                    return;\n-                }\n-\n-                let sig = db.callable_item_signature(callee.into()).substitute(Interner, &subst);\n-\n-                (sig, args.len() + 1)\n             }\n             _ => return,\n         };\n-\n-        if sig.is_varargs {\n-            return;\n-        }\n-\n-        if sig.legacy_const_generics_indices.is_empty() {\n-            let mut param_count = sig.params().len();\n-\n-            if arg_count != param_count {\n-                if is_method_call {\n-                    param_count -= 1;\n-                    arg_count -= 1;\n-                }\n-                self.diagnostics.push(BodyValidationDiagnostic::MismatchedArgCount {\n-                    call_expr: call_id,\n-                    expected: param_count,\n-                    found: arg_count,\n-                });\n-            }\n-        } else {\n-            // With `#[rustc_legacy_const_generics]` there are basically two parameter counts that\n-            // are allowed.\n-            let count_non_legacy = sig.params().len();\n-            let count_legacy = sig.params().len() + sig.legacy_const_generics_indices.len();\n-            if arg_count != count_non_legacy && arg_count != count_legacy {\n-                self.diagnostics.push(BodyValidationDiagnostic::MismatchedArgCount {\n-                    call_expr: call_id,\n-                    // Since most users will use the legacy way to call them, report against that.\n-                    expected: count_legacy,\n-                    found: arg_count,\n-                });\n-            }\n-        }\n     }\n \n     fn validate_match("}, {"sha": "71e81b43485755af3cb74c43ffdd72618bfef020", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc08b8eff3f8e4da7c448d7b7f6461938c817a60/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc08b8eff3f8e4da7c448d7b7f6461938c817a60/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=bc08b8eff3f8e4da7c448d7b7f6461938c817a60", "patch": "@@ -143,6 +143,7 @@ pub(crate) type InferResult<T> = Result<InferOk<T>, TypeError>;\n pub enum InferenceDiagnostic {\n     NoSuchField { expr: ExprId },\n     BreakOutsideOfLoop { expr: ExprId },\n+    MismatchedArgCount { call_expr: ExprId, expected: usize, found: usize },\n }\n \n /// A mismatch between an expected and an inferred type."}, {"sha": "238aff75c45ed8ad780baf5425f0b3b449aa4f1b", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 49, "deletions": 13, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/bc08b8eff3f8e4da7c448d7b7f6461938c817a60/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc08b8eff3f8e4da7c448d7b7f6461938c817a60/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=bc08b8eff3f8e4da7c448d7b7f6461938c817a60", "patch": "@@ -296,13 +296,18 @@ impl<'a> InferenceContext<'a> {\n                         break;\n                     }\n                 }\n+                // if the function is unresolved, we use is_varargs=true to\n+                // suppress the arg count diagnostic here\n+                let is_varargs =\n+                    derefed_callee.callable_sig(self.db).map_or(false, |sig| sig.is_varargs)\n+                        || res.is_none();\n                 let (param_tys, ret_ty) = match res {\n                     Some(res) => {\n                         let adjustments = auto_deref_adjust_steps(&derefs);\n                         self.write_expr_adj(*callee, adjustments);\n                         res\n                     }\n-                    None => (Vec::new(), self.err_ty()),\n+                    None => (Vec::new(), self.err_ty()), // FIXME diagnostic\n                 };\n                 let indices_to_skip = self.check_legacy_const_generics(derefed_callee, args);\n                 self.register_obligations_for_call(&callee_ty);\n@@ -313,7 +318,14 @@ impl<'a> InferenceContext<'a> {\n                     param_tys.clone(),\n                 );\n \n-                self.check_call_arguments(args, &expected_inputs, &param_tys, &indices_to_skip);\n+                self.check_call_arguments(\n+                    tgt_expr,\n+                    args,\n+                    &expected_inputs,\n+                    &param_tys,\n+                    &indices_to_skip,\n+                    is_varargs,\n+                );\n                 self.normalize_associated_types_in(ret_ty)\n             }\n             Expr::MethodCall { receiver, args, method_name, generic_args } => self\n@@ -948,22 +960,28 @@ impl<'a> InferenceContext<'a> {\n         };\n         let method_ty = method_ty.substitute(Interner, &substs);\n         self.register_obligations_for_call(&method_ty);\n-        let (formal_receiver_ty, param_tys, ret_ty) = match method_ty.callable_sig(self.db) {\n-            Some(sig) => {\n-                if !sig.params().is_empty() {\n-                    (sig.params()[0].clone(), sig.params()[1..].to_vec(), sig.ret().clone())\n-                } else {\n-                    (self.err_ty(), Vec::new(), sig.ret().clone())\n+        let (formal_receiver_ty, param_tys, ret_ty, is_varargs) =\n+            match method_ty.callable_sig(self.db) {\n+                Some(sig) => {\n+                    if !sig.params().is_empty() {\n+                        (\n+                            sig.params()[0].clone(),\n+                            sig.params()[1..].to_vec(),\n+                            sig.ret().clone(),\n+                            sig.is_varargs,\n+                        )\n+                    } else {\n+                        (self.err_ty(), Vec::new(), sig.ret().clone(), sig.is_varargs)\n+                    }\n                 }\n-            }\n-            None => (self.err_ty(), Vec::new(), self.err_ty()),\n-        };\n+                None => (self.err_ty(), Vec::new(), self.err_ty(), true),\n+            };\n         self.unify(&formal_receiver_ty, &receiver_ty);\n \n         let expected_inputs =\n             self.expected_inputs_for_expected_output(expected, ret_ty.clone(), param_tys.clone());\n \n-        self.check_call_arguments(args, &expected_inputs, &param_tys, &[]);\n+        self.check_call_arguments(tgt_expr, args, &expected_inputs, &param_tys, &[], is_varargs);\n         self.normalize_associated_types_in(ret_ty)\n     }\n \n@@ -996,11 +1014,21 @@ impl<'a> InferenceContext<'a> {\n \n     fn check_call_arguments(\n         &mut self,\n+        expr: ExprId,\n         args: &[ExprId],\n         expected_inputs: &[Ty],\n         param_tys: &[Ty],\n         skip_indices: &[u32],\n+        is_varargs: bool,\n     ) {\n+        if args.len() != param_tys.len() + skip_indices.len() && !is_varargs {\n+            self.push_diagnostic(InferenceDiagnostic::MismatchedArgCount {\n+                call_expr: expr,\n+                expected: param_tys.len() + skip_indices.len(),\n+                found: args.len(),\n+            });\n+        }\n+\n         // Quoting https://github.com/rust-lang/rust/blob/6ef275e6c3cb1384ec78128eceeb4963ff788dca/src/librustc_typeck/check/mod.rs#L3325 --\n         // We do this in a pretty awful way: first we type-check any arguments\n         // that are not closures, then we type-check the closures. This is so\n@@ -1188,7 +1216,15 @@ impl<'a> InferenceContext<'a> {\n \n         // only use legacy const generics if the param count matches with them\n         if data.params.len() + data.legacy_const_generics_indices.len() != args.len() {\n-            return Vec::new();\n+            if args.len() <= data.params.len() {\n+                return Vec::new();\n+            } else {\n+                // there are more parameters than there should be without legacy\n+                // const params; use them\n+                let mut indices = data.legacy_const_generics_indices.clone();\n+                indices.sort();\n+                return indices;\n+            }\n         }\n \n         // check legacy const parameters"}, {"sha": "8729b52ae8b04607698f441c988e6ca7e0752049", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc08b8eff3f8e4da7c448d7b7f6461938c817a60/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc08b8eff3f8e4da7c448d7b7f6461938c817a60/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=bc08b8eff3f8e4da7c448d7b7f6461938c817a60", "patch": "@@ -217,7 +217,6 @@ pub fn make_canonical<T: HasInterner<Interner = Interner>>(\n pub struct CallableSig {\n     params_and_return: Arc<[Ty]>,\n     is_varargs: bool,\n-    legacy_const_generics_indices: Arc<[u32]>,\n }\n \n has_interner!(CallableSig);\n@@ -228,11 +227,7 @@ pub type PolyFnSig = Binders<CallableSig>;\n impl CallableSig {\n     pub fn from_params_and_return(mut params: Vec<Ty>, ret: Ty, is_varargs: bool) -> CallableSig {\n         params.push(ret);\n-        CallableSig {\n-            params_and_return: params.into(),\n-            is_varargs,\n-            legacy_const_generics_indices: Arc::new([]),\n-        }\n+        CallableSig { params_and_return: params.into(), is_varargs }\n     }\n \n     pub fn from_fn_ptr(fn_ptr: &FnPointer) -> CallableSig {\n@@ -249,14 +244,9 @@ impl CallableSig {\n                 .map(|arg| arg.assert_ty_ref(Interner).clone())\n                 .collect(),\n             is_varargs: fn_ptr.sig.variadic,\n-            legacy_const_generics_indices: Arc::new([]),\n         }\n     }\n \n-    pub fn set_legacy_const_generics_indices(&mut self, indices: &[u32]) {\n-        self.legacy_const_generics_indices = indices.into();\n-    }\n-\n     pub fn to_fn_ptr(&self) -> FnPointer {\n         FnPointer {\n             num_binders: 0,\n@@ -287,11 +277,7 @@ impl Fold<Interner> for CallableSig {\n     ) -> Result<Self::Result, E> {\n         let vec = self.params_and_return.to_vec();\n         let folded = vec.fold_with(folder, outer_binder)?;\n-        Ok(CallableSig {\n-            params_and_return: folded.into(),\n-            is_varargs: self.is_varargs,\n-            legacy_const_generics_indices: self.legacy_const_generics_indices,\n-        })\n+        Ok(CallableSig { params_and_return: folded.into(), is_varargs: self.is_varargs })\n     }\n }\n "}, {"sha": "d0226cec26386757bb431dc94a478b4f390f7e5f", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc08b8eff3f8e4da7c448d7b7f6461938c817a60/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc08b8eff3f8e4da7c448d7b7f6461938c817a60/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=bc08b8eff3f8e4da7c448d7b7f6461938c817a60", "patch": "@@ -1364,10 +1364,7 @@ fn fn_sig_for_fn(db: &dyn HirDatabase, def: FunctionId) -> PolyFnSig {\n         .with_type_param_mode(ParamLoweringMode::Variable);\n     let ret = ctx_ret.lower_ty(&data.ret_type);\n     let generics = generics(db.upcast(), def.into());\n-    let mut sig = CallableSig::from_params_and_return(params, ret, data.is_varargs());\n-    if !data.legacy_const_generics_indices.is_empty() {\n-        sig.set_legacy_const_generics_indices(&data.legacy_const_generics_indices);\n-    }\n+    let sig = CallableSig::from_params_and_return(params, ret, data.is_varargs());\n     make_binders(db, &generics, sig)\n }\n "}]}