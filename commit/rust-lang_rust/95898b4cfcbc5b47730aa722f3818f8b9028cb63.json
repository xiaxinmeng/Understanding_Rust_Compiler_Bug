{"sha": "95898b4cfcbc5b47730aa722f3818f8b9028cb63", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1ODk4YjRjZmNiYzViNDc3MzBhYTcyMmYzODE4ZjhiOTAyOGNiNjM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-25T05:03:14Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-25T05:05:31Z"}, "message": "std: Simplify run_high_level_loop further", "tree": {"sha": "a7519cd1068f574033df9683baf2adaa06bc0fdb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7519cd1068f574033df9683baf2adaa06bc0fdb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95898b4cfcbc5b47730aa722f3818f8b9028cb63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95898b4cfcbc5b47730aa722f3818f8b9028cb63", "html_url": "https://github.com/rust-lang/rust/commit/95898b4cfcbc5b47730aa722f3818f8b9028cb63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95898b4cfcbc5b47730aa722f3818f8b9028cb63/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "623acaa0139b77984ec93a0e0002b7149343ae37", "url": "https://api.github.com/repos/rust-lang/rust/commits/623acaa0139b77984ec93a0e0002b7149343ae37", "html_url": "https://github.com/rust-lang/rust/commit/623acaa0139b77984ec93a0e0002b7149343ae37"}], "stats": {"total": 63, "additions": 15, "deletions": 48}, "files": [{"sha": "5e3ecfd531815ea3e6a6ca108d55f096455aa8ea", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/95898b4cfcbc5b47730aa722f3818f8b9028cb63/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95898b4cfcbc5b47730aa722f3818f8b9028cb63/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=95898b4cfcbc5b47730aa722f3818f8b9028cb63", "patch": "@@ -94,29 +94,20 @@ fn get_monitor_task_gl() -> hl::high_level_loop unsafe {\n }\n \n fn spawn_high_level_loop() -> hl::high_level_loop unsafe {\n-    let exit_po = port::<hl::high_level_loop>();\n-    let exit_ch = exit_po.chan();\n+    let hll_po = port::<hl::high_level_loop>();\n+    let hll_ch = hll_po.chan();\n \n     spawn_sched(single_threaded) {||\n         #debug(\"entering global libuv task\");\n         weaken_task() {|weak_exit_po|\n             #debug(\"global libuv task is now weak %?\", weak_exit_po);\n-            let loop_msg_po = port::<hl::high_level_msg>();\n-            let loop_msg_ch = loop_msg_po.chan();\n-            hl::run_high_level_loop(loop_msg_po) {|async_handle|\n-                #debug(\"global libuv: before_run %?\", async_handle);\n-                let hll = hl::high_level_loop({\n-                    async_handle: async_handle,\n-                    op_chan: loop_msg_ch\n-                });\n-                exit_ch.send(hll);\n-            }\n+            hl::run_high_level_loop(hll_ch);\n             #debug(\"global libuv task is leaving weakened state\");\n         };\n         #debug(\"global libuv task exiting\");\n     };\n \n-    exit_po.recv()\n+    hll_po.recv()\n }\n \n #[cfg(test)]"}, {"sha": "e6a5508aae408e23a5410e6d70e29d50d08c1ab9", "filename": "src/libstd/uv_hl.rs", "status": "modified", "additions": 11, "deletions": 35, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/95898b4cfcbc5b47730aa722f3818f8b9028cb63/src%2Flibstd%2Fuv_hl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95898b4cfcbc5b47730aa722f3818f8b9028cb63/src%2Flibstd%2Fuv_hl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_hl.rs?ref=95898b4cfcbc5b47730aa722f3818f8b9028cb63", "patch": "@@ -41,27 +41,9 @@ closed, causing a failure otherwise. This should not be sent/used from\n \n #[doc = \"\n Useful for anyone who wants to roll their own `high_level_loop`.\n-\n-# Arguments\n-\n-* loop_ptr - a pointer to a currently unused libuv loop. Its `data` field\n-will be overwritten before the loop begins\n-* msg_po - an active port that receives `high_level_msg`s. You can distribute\n-a paired channel to users, along with the `async_handle` returned in the\n-following callback (combine them to make a `hl::simpler_task_loop` varient\n-of `hl::high_level_loop`)\n-* before_run - a unique closure that is invoked before `uv_run()` is called\n-on the provided `loop_ptr`. An `async_handle` is passed in which will be\n-live for the duration of the loop. You can distribute this to users so that\n-they can interact with the loop safely.\n-* before_msg_process - a unique closure that is invoked at least once when\n-the loop is woken up, and once more for every message that is drained from\n-the loop's msg port\n-* before_tear_down - called just before the loop invokes `uv_close()` on the\n-provided `async_handle`. `uv_run` should return shortly after\n \"]\n-unsafe fn run_high_level_loop(msg_po: port<high_level_msg>,\n-                              before_run: fn~(*ll::uv_async_t)) {\n+unsafe fn run_high_level_loop(hll_ch: chan<high_level_loop>) {\n+    let msg_po = port::<high_level_msg>();\n     let loop_ptr = ll::loop_new();\n     // set up the special async handle we'll use to allow multi-task\n     // communication with this loop\n@@ -78,8 +60,13 @@ unsafe fn run_high_level_loop(msg_po: port<high_level_msg>,\n     };\n     ll::set_data_for_uv_handle(async_handle, addr_of(data));\n \n-    // call before_run\n-    before_run(async_handle);\n+    // Send out a handle through which folks can talk to us\n+    // while we dwell in the I/O loop\n+    let hll = high_level_loop({\n+        async_handle: async_handle,\n+        op_chan: msg_po.chan()\n+    });\n+    hll_ch.send(hll);\n \n     log(debug, \"about to run high level loop\");\n     // enter the loop... this blocks until the loop is done..\n@@ -224,19 +211,8 @@ mod test {\n         let hl_loop_port = comm::port::<high_level_loop>();\n         let hl_loop_ch = comm::chan(hl_loop_port);\n         task::spawn_sched(task::manual_threads(1u)) {||\n-            let msg_po = comm::port::<high_level_msg>();\n-            let msg_ch = comm::chan(msg_po);\n-            run_high_level_loop(msg_po) {|async_handle|\n-                log(debug,#fmt(\"hltest before_run: async_handle %?\",\n-                               async_handle));\n-                // do an async_send with it\n-                ll::async_send(async_handle);\n-                comm::send(hl_loop_ch, high_level_loop({\n-                    async_handle: async_handle,\n-                    op_chan: msg_ch\n-                }));\n-            }\n-            comm::send(exit_ch, ());\n+            run_high_level_loop(hl_loop_ch);\n+            exit_ch.send(());\n         };\n         ret comm::recv(hl_loop_port);\n     }"}]}