{"sha": "3e4d41d1e409315ce42cb3c3479236b5e73d0643", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlNGQ0MWQxZTQwOTMxNWNlNDJjYjNjMzQ3OTIzNmI1ZTczZDA2NDM=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2018-12-25T16:43:58Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2018-12-25T16:43:58Z"}, "message": "Determine receiver for completion in a more robust way\n\nAlso rename a parameter.", "tree": {"sha": "0ae517904e3324d7a9779fb83e11574e1427ee29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ae517904e3324d7a9779fb83e11574e1427ee29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e4d41d1e409315ce42cb3c3479236b5e73d0643", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e4d41d1e409315ce42cb3c3479236b5e73d0643", "html_url": "https://github.com/rust-lang/rust/commit/3e4d41d1e409315ce42cb3c3479236b5e73d0643", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e4d41d1e409315ce42cb3c3479236b5e73d0643/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3befd1a9e82809fef5bc68950d3265dbcbbd5527", "url": "https://api.github.com/repos/rust-lang/rust/commits/3befd1a9e82809fef5bc68950d3265dbcbbd5527", "html_url": "https://github.com/rust-lang/rust/commit/3befd1a9e82809fef5bc68950d3265dbcbbd5527"}], "stats": {"total": 52, "additions": 31, "deletions": 21}, "files": [{"sha": "93d657576813bf0827a6ba84b3940001b61ebd36", "filename": "crates/ra_analysis/src/completion/complete_dot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e4d41d1e409315ce42cb3c3479236b5e73d0643/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e4d41d1e409315ce42cb3c3479236b5e73d0643/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=3e4d41d1e409315ce42cb3c3479236b5e73d0643", "patch": "@@ -33,9 +33,9 @@ pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) -> Ca\n     Ok(())\n }\n \n-fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, ty: Ty) -> Cancelable<()> {\n+fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty) -> Cancelable<()> {\n     // TODO: autoderef etc.\n-    match ty {\n+    match receiver {\n         Ty::Adt { def_id, .. } => {\n             match def_id.resolve(ctx.db)? {\n                 Def::Struct(s) => {"}, {"sha": "978772fd447f969136fd7be3612a9be87e0df54c", "filename": "crates/ra_analysis/src/completion/completion_context.rs", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3e4d41d1e409315ce42cb3c3479236b5e73d0643/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e4d41d1e409315ce42cb3c3479236b5e73d0643/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=3e4d41d1e409315ce42cb3c3479236b5e73d0643", "patch": "@@ -1,12 +1,13 @@\n use ra_editor::find_node_at_offset;\n use ra_text_edit::AtomTextEdit;\n use ra_syntax::{\n-    algo::find_leaf_at_offset,\n+    algo::{find_leaf_at_offset, find_covering_node},\n     ast,\n     AstNode,\n     SyntaxNodeRef,\n     SourceFileNode,\n     TextUnit,\n+    TextRange,\n     SyntaxKind::*,\n };\n use hir::source_binder;\n@@ -65,7 +66,7 @@ impl<'a> CompletionContext<'a> {\n         Ok(Some(ctx))\n     }\n \n-    fn fill(&mut self, original_file: &SourceFileNode, offset: TextUnit) {\n+    fn fill(&mut self, original_file: &'a SourceFileNode, offset: TextUnit) {\n         // Insert a fake ident to get a valid parse tree. We will use this file\n         // to determine context, though the original_file will be used for\n         // actual completion.\n@@ -82,7 +83,7 @@ impl<'a> CompletionContext<'a> {\n                 self.is_param = true;\n                 return;\n             }\n-            self.classify_name_ref(&file, name_ref);\n+            self.classify_name_ref(original_file, name_ref);\n         }\n \n         // Otherwise, see if this is a declaration. We can use heuristics to\n@@ -94,7 +95,7 @@ impl<'a> CompletionContext<'a> {\n             }\n         }\n     }\n-    fn classify_name_ref(&mut self, file: &SourceFileNode, name_ref: ast::NameRef) {\n+    fn classify_name_ref(&mut self, original_file: &'a SourceFileNode, name_ref: ast::NameRef) {\n         let name_range = name_ref.syntax().range();\n         let top_node = name_ref\n             .syntax()\n@@ -144,34 +145,43 @@ impl<'a> CompletionContext<'a> {\n                 };\n \n                 if let Some(off) = name_ref.syntax().range().start().checked_sub(2.into()) {\n-                    if let Some(if_expr) = find_node_at_offset::<ast::IfExpr>(file.syntax(), off) {\n+                    if let Some(if_expr) =\n+                        find_node_at_offset::<ast::IfExpr>(original_file.syntax(), off)\n+                    {\n                         if if_expr.syntax().range().end() < name_ref.syntax().range().start() {\n                             self.after_if = true;\n                         }\n                     }\n                 }\n             }\n         }\n-        if let Some(_field_expr) = ast::FieldExpr::cast(parent) {\n-            self.dot_receiver = self\n-                .leaf\n-                .ancestors()\n-                .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n-                .find_map(ast::FieldExpr::cast)\n-                .and_then(ast::FieldExpr::expr);\n+        if let Some(field_expr) = ast::FieldExpr::cast(parent) {\n+            // The receiver comes before the point of insertion of the fake\n+            // ident, so it should have the same range in the non-modified file\n+            self.dot_receiver = field_expr\n+                .expr()\n+                .map(|e| e.syntax().range())\n+                .and_then(|r| find_node_with_range(original_file.syntax(), r));\n         }\n-        if let Some(_method_call_expr) = ast::MethodCallExpr::cast(parent) {\n-            self.dot_receiver = self\n-                .leaf\n-                .ancestors()\n-                .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n-                .find_map(ast::MethodCallExpr::cast)\n-                .and_then(ast::MethodCallExpr::expr);\n+        if let Some(method_call_expr) = ast::MethodCallExpr::cast(parent) {\n+            // As above\n+            self.dot_receiver = method_call_expr\n+                .expr()\n+                .map(|e| e.syntax().range())\n+                .and_then(|r| find_node_with_range(original_file.syntax(), r));\n             self.is_method_call = true;\n         }\n     }\n }\n \n+fn find_node_with_range<'a, N: AstNode<'a>>(\n+    syntax: SyntaxNodeRef<'a>,\n+    range: TextRange,\n+) -> Option<N> {\n+    let node = find_covering_node(syntax, range);\n+    node.ancestors().find_map(N::cast)\n+}\n+\n fn is_node<'a, N: AstNode<'a>>(node: SyntaxNodeRef<'a>) -> bool {\n     match node.ancestors().filter_map(N::cast).next() {\n         None => false,"}]}