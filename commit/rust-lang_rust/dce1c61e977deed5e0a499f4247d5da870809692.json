{"sha": "dce1c61e977deed5e0a499f4247d5da870809692", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjZTFjNjFlOTc3ZGVlZDVlMGE0OTlmNDI0N2Q1ZGE4NzA4MDk2OTI=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-06-07T07:25:14Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-07-28T14:14:58Z"}, "message": "Add dropflag hints (stack-local booleans) for unfragmented paths in trans.\n\nAdded code to maintain these hints at runtime, and to conditionalize\ndrop-filling and calls to destructors.\n\nIn this early stage, we are using hints, so we are always free to\nleave out a flag for a path -- then we just pass `None` as the\ndropflag hint in the corresponding schedule cleanup call. But, once a\npath has a hint, we must at least maintain it: i.e. if the hint\nexists, we must ensure it is never set to \"moved\" if the data in\nquestion might actually have been initialized. It remains sound to\nconservatively set the hint to \"initialized\" as long as the true\ndrop-flag embedded in the value itself is up-to-date.\n\n----\n\nHere are some high-level details I want to point out:\n\n * We maintain the hint in Lvalue::post_store, marking the lvalue as\n   moved. (But also continue drop-filling if necessary.)\n\n * We update the hint on ExprAssign.\n\n * We pass along the hint in once closures that capture-by-move.\n\n * You only call `drop_ty` for state that does not have an associated hint.\n   If you have a hint, you must call `drop_ty_core` instead.\n   (Originally I passed the hint into `drop_ty` as well, to make the\n   connection to a hint more apparent, but the vast majority of\n   current calls to `drop_ty` are in contexts where no hint is\n   available, so it just seemed like noise in the resulting diff.)", "tree": {"sha": "7fff58a51ee7955ca8df32f0a340397c770d7cd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fff58a51ee7955ca8df32f0a340397c770d7cd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dce1c61e977deed5e0a499f4247d5da870809692", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dce1c61e977deed5e0a499f4247d5da870809692", "html_url": "https://github.com/rust-lang/rust/commit/dce1c61e977deed5e0a499f4247d5da870809692", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dce1c61e977deed5e0a499f4247d5da870809692/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3d552b71b89633fe6692bf2214a2d001683bfa9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3d552b71b89633fe6692bf2214a2d001683bfa9", "html_url": "https://github.com/rust-lang/rust/commit/d3d552b71b89633fe6692bf2214a2d001683bfa9"}], "stats": {"total": 329, "additions": 259, "deletions": 70}, "files": [{"sha": "7a491a628e5f8774a1622c7faec3ccc07f88f792", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 44, "deletions": 28, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/dce1c61e977deed5e0a499f4247d5da870809692/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dce1c61e977deed5e0a499f4247d5da870809692/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=dce1c61e977deed5e0a499f4247d5da870809692", "patch": "@@ -205,7 +205,7 @@ use trans::build::{AddCase, And, Br, CondBr, GEPi, InBoundsGEP, Load, PointerCas\n use trans::build::{Not, Store, Sub, add_comment};\n use trans::build;\n use trans::callee;\n-use trans::cleanup::{self, CleanupMethods};\n+use trans::cleanup::{self, CleanupMethods, DropHintMethods};\n use trans::common::*;\n use trans::consts;\n use trans::datum::*;\n@@ -947,14 +947,14 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             TrByCopy(llbinding) |\n             TrByMoveIntoCopy(llbinding) => {\n                 let llval = Load(bcx, binding_info.llmatch);\n-                let lval = match binding_info.trmode {\n+                let lvalue = match binding_info.trmode {\n                     TrByCopy(..) =>\n                         Lvalue::new(\"_match::insert_lllocals\"),\n                     TrByMoveIntoCopy(..) =>\n                         Lvalue::match_input(\"_match::insert_lllocals\", bcx, binding_info.id),\n                     _ => unreachable!(),\n                 };\n-                let datum = Datum::new(llval, binding_info.ty, lval);\n+                let datum = Datum::new(llval, binding_info.ty, lvalue);\n                 call_lifetime_start(bcx, llbinding);\n                 bcx = datum.store_to(bcx, llbinding);\n                 if let Some(cs) = cs {\n@@ -971,14 +971,15 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             TrByRef => (binding_info.llmatch, true),\n         };\n \n-        let lval = Lvalue::local(\"_match::insert_lllocals\",\n-                                 bcx,\n-                                 binding_info.id,\n-                                 aliases_other_state);\n-        let datum = Datum::new(llval, binding_info.ty, lval);\n+        let lvalue = Lvalue::local(\"_match::insert_lllocals\",\n+                                   bcx,\n+                                   binding_info.id,\n+                                   aliases_other_state);\n+        let datum = Datum::new(llval, binding_info.ty, lvalue);\n         if let Some(cs) = cs {\n+            let opt_datum = lvalue.dropflag_hint(bcx);\n             bcx.fcx.schedule_lifetime_end(cs, binding_info.llmatch);\n-            bcx.fcx.schedule_drop_and_fill_mem(cs, llval, binding_info.ty);\n+            bcx.fcx.schedule_drop_and_fill_mem(cs, llval, binding_info.ty, opt_datum);\n         }\n \n         debug!(\"binding {} to {}\", binding_info.id, bcx.val_to_string(llval));\n@@ -1505,13 +1506,13 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &ast::Pat,\n                 // but during matching we need to store a *T as explained\n                 // above\n                 llmatch = alloca_no_lifetime(bcx,\n-                                 llvariable_ty.ptr_to(),\n-                                 &bcx.name(name));\n+                                             llvariable_ty.ptr_to(),\n+                                             &bcx.name(name));\n                 trmode = TrByMoveRef;\n             }\n             ast::BindByRef(_) => {\n                 llmatch = alloca_no_lifetime(bcx,\n-                                             llvariable_ty,\n+                                 llvariable_ty,\n                                  &bcx.name(name));\n                 trmode = TrByRef;\n             }\n@@ -1631,7 +1632,25 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             bcx = mk_binding_alloca(\n                 bcx, p_id, path1.node.name, scope, (),\n                 \"_match::store_local::create_dummy_locals\",\n-                |(), bcx, llval, ty| { drop_done_fill_mem(bcx, llval, ty); bcx });\n+                |(), bcx, Datum { val: llval, ty, kind }| {\n+                    // Dummy-locals start out uninitialized, so set their\n+                    // drop-flag hints (if any) to \"moved.\"\n+                    if let Some(hint) = kind.dropflag_hint(bcx) {\n+                        let moved_hint = adt::DTOR_MOVED_HINT as usize;\n+                        debug!(\"store moved_hint={} for hint={:?}, uninitialized dummy\",\n+                               moved_hint, hint);\n+                        Store(bcx, C_u8(bcx.fcx.ccx, moved_hint), hint.to_value().value());\n+                    }\n+\n+                    if kind.drop_flag_info.must_zero() {\n+                        // if no drop-flag hint, or the hint requires\n+                        // we maintain the embedded drop-flag, then\n+                        // mark embedded drop-flag(s) as moved\n+                        // (i.e. \"already dropped\").\n+                        drop_done_fill_mem(bcx, llval, ty);\n+                    }\n+                    bcx\n+                });\n         });\n         bcx\n     }\n@@ -1654,8 +1673,8 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     return mk_binding_alloca(\n                         bcx, pat.id, ident.name, var_scope, (),\n                         \"_match::store_local\",\n-                        |(), bcx, v, _| expr::trans_into(bcx, &**init_expr,\n-                                                         expr::SaveIn(v)));\n+                        |(), bcx, Datum { val: v, .. }| expr::trans_into(bcx, &**init_expr,\n+                                                                         expr::SaveIn(v)));\n                 }\n \n                 None => {}\n@@ -1684,23 +1703,23 @@ fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n                                        caller_name: &'static str,\n                                        populate: F)\n                                        -> Block<'blk, 'tcx> where\n-    F: FnOnce(A, Block<'blk, 'tcx>, ValueRef, Ty<'tcx>) -> Block<'blk, 'tcx>,\n+    F: FnOnce(A, Block<'blk, 'tcx>, Datum<'tcx, Lvalue>) -> Block<'blk, 'tcx>,\n {\n     let var_ty = node_id_type(bcx, p_id);\n \n     // Allocate memory on stack for the binding.\n     let llval = alloc_ty(bcx, var_ty, &bcx.name(name));\n+    let lvalue = Lvalue::binding(caller_name, bcx, p_id, name);\n+    let datum = Datum::new(llval, var_ty, lvalue);\n \n     // Subtle: be sure that we *populate* the memory *before*\n     // we schedule the cleanup.\n-    let bcx = populate(arg, bcx, llval, var_ty);\n+    let bcx = populate(arg, bcx, datum);\n     bcx.fcx.schedule_lifetime_end(cleanup_scope, llval);\n-    bcx.fcx.schedule_drop_mem(cleanup_scope, llval, var_ty);\n+    bcx.fcx.schedule_drop_mem(cleanup_scope, llval, var_ty, lvalue.dropflag_hint(bcx));\n \n     // Now that memory is initialized and has cleanup scheduled,\n-    // create the datum and insert into the local variable map.\n-    let lval = Lvalue::binding(caller_name, bcx, p_id, name);\n-    let datum = Datum::new(llval, var_ty, lval);\n+    // insert datum into the local variable map.\n     bcx.fcx.lllocals.borrow_mut().insert(p_id, datum);\n     bcx\n }\n@@ -1746,7 +1765,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 bcx = mk_binding_alloca(\n                     bcx, pat.id, path1.node.name, cleanup_scope, (),\n                     \"_match::bind_irrefutable_pat\",\n-                    |(), bcx, llval, ty| {\n+                    |(), bcx, Datum { val: llval, ty, kind: _ }| {\n                         match pat_binding_mode {\n                             ast::BindByValue(_) => {\n                                 // By value binding: move the value that `val`\n@@ -1854,10 +1873,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::PatBox(ref inner) => {\n             let llbox = Load(bcx, val.val);\n             bcx = bind_irrefutable_pat(\n-                bcx,\n-                &**inner,\n-                MatchInput::from_val(llbox),\n-                cleanup_scope);\n+                bcx, &**inner, MatchInput::from_val(llbox), cleanup_scope);\n         }\n         ast::PatRegion(ref inner, _) => {\n             let loaded_val = Load(bcx, val.val);\n@@ -1884,13 +1900,13 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 .chain(slice.iter())\n                 .chain(after.iter())\n                 .zip(extracted.vals)\n-                .fold(bcx, |bcx, (inner, elem)|\n+                .fold(bcx, |bcx, (inner, elem)| {\n                     bind_irrefutable_pat(\n                         bcx,\n                         &**inner,\n                         MatchInput::from_val(elem),\n                         cleanup_scope)\n-                );\n+                });\n         }\n         ast::PatMac(..) => {\n             bcx.sess().span_bug(pat.span, \"unexpanded macro\");"}, {"sha": "b47d2dd4112ca719fae9a73a202cbe762ec8d827", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dce1c61e977deed5e0a499f4247d5da870809692/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dce1c61e977deed5e0a499f4247d5da870809692/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=dce1c61e977deed5e0a499f4247d5da870809692", "patch": "@@ -163,6 +163,20 @@ macro_rules! repeat_u8_as_u64 {\n                        (repeat_u8_as_u32!($name) as u64)) }\n }\n \n+/// `DTOR_NEEDED_HINT` is a stack-local hint that just means\n+/// \"we do not know whether the destructor has run or not; check the\n+/// drop-flag embedded in the value itself.\"\n+pub const DTOR_NEEDED_HINT: u8 = 0x3d;\n+\n+/// `DTOR_MOVED_HINT` is a stack-local hint that means \"this value has\n+/// definitely been moved; you do not need to run its destructor.\"\n+///\n+/// (However, for now, such values may still end up being explicitly\n+/// zeroed by the generated code; this is the distinction between\n+/// `datum::DropFlagInfo::ZeroAndMaintain` versus\n+/// `datum::DropFlagInfo::DontZeroJustUse`.)\n+pub const DTOR_MOVED_HINT: u8 = 0x2d;\n+\n pub const DTOR_NEEDED: u8 = 0xd4;\n pub const DTOR_NEEDED_U32: u32 = repeat_u8_as_u32!(DTOR_NEEDED);\n pub const DTOR_NEEDED_U64: u64 = repeat_u8_as_u64!(DTOR_NEEDED);"}, {"sha": "61e81d75607cf702caae9432d3e1b245a5271b45", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 50, "deletions": 3, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/dce1c61e977deed5e0a499f4247d5da870809692/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dce1c61e977deed5e0a499f4247d5da870809692/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=dce1c61e977deed5e0a499f4247d5da870809692", "patch": "@@ -51,8 +51,7 @@ use trans::attributes;\n use trans::build::*;\n use trans::builder::{Builder, noname};\n use trans::callee;\n-use trans::cleanup::CleanupMethods;\n-use trans::cleanup;\n+use trans::cleanup::{self, CleanupMethods, DropHint};\n use trans::closure;\n use trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_int, C_integral};\n use trans::common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n@@ -88,7 +87,7 @@ use arena::TypedArena;\n use libc::c_uint;\n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n-use std::collections::HashSet;\n+use std::collections::{HashMap, HashSet};\n use std::mem;\n use std::str;\n use std::{i8, i16, i32, i64};\n@@ -1284,6 +1283,54 @@ pub fn init_function<'a, 'tcx>(fcx: &'a FunctionContext<'a, 'tcx>,\n         }\n     }\n \n+    // Create the drop-flag hints for every unfragmented path in the function.\n+    let tcx = fcx.ccx.tcx();\n+    let fn_did = ast::DefId { krate: ast::LOCAL_CRATE, node: fcx.id };\n+    let mut hints = fcx.lldropflag_hints.borrow_mut();\n+    let fragment_infos = tcx.fragment_infos.borrow();\n+\n+    // Intern table for drop-flag hint datums.\n+    let mut seen = HashMap::new();\n+\n+    if let Some(fragment_infos) = fragment_infos.get(&fn_did) {\n+        for &info in fragment_infos {\n+\n+            let make_datum = |id| {\n+                let init_val = C_u8(fcx.ccx, adt::DTOR_NEEDED_HINT as usize);\n+                let llname = &format!(\"dropflag_hint_{}\", id);\n+                debug!(\"adding hint {}\", llname);\n+                let ptr = alloc_ty(entry_bcx, tcx.types.u8, llname);\n+                Store(entry_bcx, init_val, ptr);\n+                let ty = tcx.mk_ptr(ty::TypeAndMut { ty: tcx.types.u8, mutbl: ast::MutMutable });\n+                let flag = datum::Lvalue::new_dropflag_hint(\"base::init_function\");\n+                let datum = datum::Datum::new(ptr, ty, flag);\n+                datum\n+            };\n+\n+            let (var, datum) = match info {\n+                ty::FragmentInfo::Moved { var, .. } |\n+                ty::FragmentInfo::Assigned { var, .. } => {\n+                    let datum = seen.get(&var).cloned().unwrap_or_else(|| {\n+                        let datum = make_datum(var);\n+                        seen.insert(var, datum.clone());\n+                        datum\n+                    });\n+                    (var, datum)\n+                }\n+            };\n+            match info {\n+                ty::FragmentInfo::Moved { move_expr: expr_id, .. } => {\n+                    debug!(\"FragmentInfo::Moved insert drop hint for {}\", expr_id);\n+                    hints.insert(expr_id, DropHint::new(var, datum));\n+                }\n+                ty::FragmentInfo::Assigned { assignee_id: expr_id, .. } => {\n+                    debug!(\"FragmentInfo::Assigned insert drop hint for {}\", expr_id);\n+                    hints.insert(expr_id, DropHint::new(var, datum));\n+                }\n+            }\n+        }\n+    }\n+\n     entry_bcx\n }\n "}, {"sha": "b4b0472512e61a5eb165db96295f0c150630a0f5", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 39, "deletions": 9, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/dce1c61e977deed5e0a499f4247d5da870809692/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dce1c61e977deed5e0a499f4247d5da870809692/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=dce1c61e977deed5e0a499f4247d5da870809692", "patch": "@@ -219,6 +219,23 @@ pub struct DropHint<K>(pub ast::NodeId, pub K);\n pub type DropHintDatum<'tcx> = DropHint<Datum<'tcx, Lvalue>>;\n pub type DropHintValue = DropHint<ValueRef>;\n \n+impl<K> DropHint<K> {\n+    pub fn new(id: ast::NodeId, k: K) -> DropHint<K> { DropHint(id, k) }\n+}\n+\n+impl DropHint<ValueRef> {\n+    pub fn value(&self) -> ValueRef { self.1 }\n+}\n+\n+pub trait DropHintMethods {\n+    type ValueKind;\n+    fn to_value(&self) -> Self::ValueKind;\n+}\n+impl<'tcx> DropHintMethods for DropHintDatum<'tcx> {\n+    type ValueKind = DropHintValue;\n+    fn to_value(&self) -> DropHintValue { DropHint(self.0, self.1.val) }\n+}\n+\n impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     /// Invoked when we start to trans the code contained within a new cleanup scope.\n     fn push_ast_cleanup_scope(&self, debug_loc: NodeIdAndSpan) {\n@@ -389,14 +406,17 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     fn schedule_drop_mem(&self,\n                          cleanup_scope: ScopeId,\n                          val: ValueRef,\n-                         ty: Ty<'tcx>) {\n+                         ty: Ty<'tcx>,\n+                         drop_hint: Option<DropHintDatum<'tcx>>) {\n         if !self.type_needs_drop(ty) { return; }\n+        let drop_hint = drop_hint.map(|hint|hint.to_value());\n         let drop = box DropValue {\n             is_immediate: false,\n             val: val,\n             ty: ty,\n             fill_on_drop: false,\n             skip_dtor: false,\n+            drop_hint: drop_hint,\n         };\n \n         debug!(\"schedule_drop_mem({:?}, val={}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n@@ -413,23 +433,28 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     fn schedule_drop_and_fill_mem(&self,\n                                   cleanup_scope: ScopeId,\n                                   val: ValueRef,\n-                                  ty: Ty<'tcx>) {\n+                                  ty: Ty<'tcx>,\n+                                  drop_hint: Option<DropHintDatum<'tcx>>) {\n         if !self.type_needs_drop(ty) { return; }\n \n+        let drop_hint = drop_hint.map(|datum|datum.to_value());\n         let drop = box DropValue {\n             is_immediate: false,\n             val: val,\n             ty: ty,\n             fill_on_drop: true,\n             skip_dtor: false,\n+            drop_hint: drop_hint,\n         };\n \n-        debug!(\"schedule_drop_and_fill_mem({:?}, val={}, ty={:?}, fill_on_drop={}, skip_dtor={})\",\n+        debug!(\"schedule_drop_and_fill_mem({:?}, val={}, ty={:?},\n+                fill_on_drop={}, skip_dtor={}, has_drop_hint={})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n                ty,\n                drop.fill_on_drop,\n-               drop.skip_dtor);\n+               drop.skip_dtor,\n+               drop_hint.is_some());\n \n         self.schedule_clean(cleanup_scope, drop as CleanupObj);\n     }\n@@ -453,6 +478,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             ty: ty,\n             fill_on_drop: false,\n             skip_dtor: true,\n+            drop_hint: None,\n         };\n \n         debug!(\"schedule_drop_adt_contents({:?}, val={}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n@@ -472,13 +498,14 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                                ty: Ty<'tcx>) {\n \n         if !self.type_needs_drop(ty) { return; }\n-        let drop = box DropValue {\n+        let drop = Box::new(DropValue {\n             is_immediate: true,\n             val: val,\n             ty: ty,\n             fill_on_drop: false,\n             skip_dtor: false,\n-        };\n+            drop_hint: None,\n+        });\n \n         debug!(\"schedule_drop_immediate({:?}, val={}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n                cleanup_scope,\n@@ -983,6 +1010,7 @@ pub struct DropValue<'tcx> {\n     ty: Ty<'tcx>,\n     fill_on_drop: bool,\n     skip_dtor: bool,\n+    drop_hint: Option<DropHintValue>,\n }\n \n impl<'tcx> Cleanup<'tcx> for DropValue<'tcx> {\n@@ -1007,7 +1035,7 @@ impl<'tcx> Cleanup<'tcx> for DropValue<'tcx> {\n         let bcx = if self.is_immediate {\n             glue::drop_ty_immediate(bcx, self.val, self.ty, debug_loc, self.skip_dtor)\n         } else {\n-            glue::drop_ty_core(bcx, self.val, self.ty, debug_loc, self.skip_dtor)\n+            glue::drop_ty_core(bcx, self.val, self.ty, debug_loc, self.skip_dtor, self.drop_hint)\n         };\n         if self.fill_on_drop {\n             base::drop_done_fill_mem(bcx, self.val, self.ty);\n@@ -1135,11 +1163,13 @@ pub trait CleanupMethods<'blk, 'tcx> {\n     fn schedule_drop_mem(&self,\n                          cleanup_scope: ScopeId,\n                          val: ValueRef,\n-                         ty: Ty<'tcx>);\n+                         ty: Ty<'tcx>,\n+                         drop_hint: Option<DropHintDatum<'tcx>>);\n     fn schedule_drop_and_fill_mem(&self,\n                                   cleanup_scope: ScopeId,\n                                   val: ValueRef,\n-                                  ty: Ty<'tcx>);\n+                                  ty: Ty<'tcx>,\n+                                  drop_hint: Option<DropHintDatum<'tcx>>);\n     fn schedule_drop_adt_contents(&self,\n                                   cleanup_scope: ScopeId,\n                                   val: ValueRef,"}, {"sha": "d97872310966beed76b4f87a6a4c448cc4917868", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dce1c61e977deed5e0a499f4247d5da870809692/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dce1c61e977deed5e0a499f4247d5da870809692/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=dce1c61e977deed5e0a499f4247d5da870809692", "patch": "@@ -82,9 +82,11 @@ fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         bcx.fcx.llupvars.borrow_mut().insert(def_id.node, upvar_ptr);\n \n         if kind == ty::FnOnceClosureKind && !captured_by_ref {\n+            let hint = bcx.fcx.lldropflag_hints.borrow().hint_datum(upvar_id.var_id);\n             bcx.fcx.schedule_drop_mem(arg_scope_id,\n                                       upvar_ptr,\n-                                      node_id_type(bcx, def_id.node))\n+                                      node_id_type(bcx, def_id.node),\n+                                      hint)\n         }\n \n         if let Some(env_pointer_alloca) = env_pointer_alloca {"}, {"sha": "9478c197a44d0b70e5187d4a687d849d8d01c5c6", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dce1c61e977deed5e0a499f4247d5da870809692/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dce1c61e977deed5e0a499f4247d5da870809692/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=dce1c61e977deed5e0a499f4247d5da870809692", "patch": "@@ -318,6 +318,12 @@ pub struct DropFlagHintsMap<'tcx> {\n impl<'tcx> DropFlagHintsMap<'tcx> {\n     pub fn new() -> DropFlagHintsMap<'tcx> { DropFlagHintsMap { node_map: NodeMap() } }\n     pub fn has_hint(&self, id: ast::NodeId) -> bool { self.node_map.contains_key(&id) }\n+    pub fn insert(&mut self, id: ast::NodeId, datum: cleanup::DropHintDatum<'tcx>) {\n+        self.node_map.insert(id, HintEntry { datum: datum });\n+    }\n+    pub fn hint_datum(&self, id: ast::NodeId) -> Option<cleanup::DropHintDatum<'tcx>> {\n+        self.node_map.get(&id).map(|t|t.datum)\n+    }\n }\n \n // Function context.  Every LLVM function we create will have one of"}, {"sha": "28fbc9fc8d56f58d2ea0c33e7644f348199a67fa", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 54, "deletions": 16, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/dce1c61e977deed5e0a499f4247d5da870809692/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dce1c61e977deed5e0a499f4247d5da870809692/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=dce1c61e977deed5e0a499f4247d5da870809692", "patch": "@@ -93,11 +93,12 @@ pub use self::Expr::*;\n pub use self::RvalueMode::*;\n \n use llvm::ValueRef;\n+use trans::adt;\n use trans::base::*;\n-use trans::build::Load;\n+use trans::build::{Load, Store};\n use trans::common::*;\n use trans::cleanup;\n-use trans::cleanup::CleanupMethods;\n+use trans::cleanup::{CleanupMethods, DropHintDatum, DropHintMethods};\n use trans::expr;\n use trans::tvec;\n use trans::type_of;\n@@ -111,7 +112,7 @@ use syntax::codemap::DUMMY_SP;\n /// describes where the value is stored, what Rust type the value has,\n /// whether it is addressed by reference, and so forth. Please refer\n /// the section on datums in `README.md` for more details.\n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, Debug)]\n pub struct Datum<'tcx, K> {\n     /// The llvm value.  This is either a pointer to the Rust value or\n     /// the value itself, depending on `kind` below.\n@@ -141,7 +142,7 @@ pub enum Expr {\n     LvalueExpr(Lvalue),\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum DropFlagInfo {\n     DontZeroJustUse(ast::NodeId),\n     ZeroAndMaintain(ast::NodeId),\n@@ -157,12 +158,18 @@ impl DropFlagInfo {\n         }\n     }\n \n-    pub fn hint_to_maintain(&self) -> Option<ast::NodeId> {\n-        match *self {\n-            DropFlagInfo::DontZeroJustUse(id) => Some(id),\n-            DropFlagInfo::ZeroAndMaintain(id) => Some(id),\n-            DropFlagInfo::None => None,\n-        }\n+    pub fn hint_datum<'blk, 'tcx>(&self, bcx: Block<'blk, 'tcx>)\n+                              -> Option<DropHintDatum<'tcx>> {\n+        let id = match *self {\n+            DropFlagInfo::None => return None,\n+            DropFlagInfo::DontZeroJustUse(id) |\n+            DropFlagInfo::ZeroAndMaintain(id) => id,\n+        };\n+\n+        let hints = bcx.fcx.lldropflag_hints.borrow();\n+        let retval = hints.hint_datum(id);\n+        assert!(retval.is_some(), \"An id (={}) means must have a hint\", id);\n+        retval\n     }\n }\n \n@@ -182,7 +189,8 @@ pub struct Rvalue {\n     pub mode: RvalueMode\n }\n \n-impl Lvalue {\n+// XXX: reduce this to a smaller kernel of constructors.\n+impl Lvalue { // These are all constructors for various Lvalues.\n     pub fn new(source: &'static str) -> Lvalue {\n         Lvalue { source: source, drop_flag_info: DropFlagInfo::None }\n     }\n@@ -267,9 +275,21 @@ impl Lvalue {\n         Lvalue { source: source, drop_flag_info: info }\n     }\n \n+    pub fn new_dropflag_hint(source: &'static str) -> Lvalue {\n+        debug!(\"dropflag hint Lvalue at {}\", source);\n+        Lvalue { source: source, drop_flag_info: DropFlagInfo::None }\n+    }\n+} // end Lvalue constructor methods.\n+\n+impl Lvalue {\n     fn has_dropflag_hint<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      id: ast::NodeId) -> bool {\n-        bcx.fcx.lldropflag_hints.borrow().has_hint(id)\n+        let hints = bcx.fcx.lldropflag_hints.borrow();\n+        hints.has_hint(id)\n+    }\n+    pub fn dropflag_hint<'blk, 'tcx>(&self, bcx: Block<'blk, 'tcx>)\n+                                 -> Option<DropHintDatum<'tcx>> {\n+        self.drop_flag_info.hint_datum(bcx)\n     }\n }\n \n@@ -323,7 +343,7 @@ pub fn lvalue_scratch_datum<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n     // Subtle. Populate the scratch memory *before* scheduling cleanup.\n     let bcx = populate(arg, bcx, scratch);\n     bcx.fcx.schedule_lifetime_end(scope, scratch);\n-    bcx.fcx.schedule_drop_mem(scope, scratch, ty);\n+    bcx.fcx.schedule_drop_mem(scope, scratch, ty, None);\n \n     DatumBlock::new(bcx, Datum::new(scratch, ty, Lvalue::new(\"datum::lvalue_scratch_datum\")))\n }\n@@ -362,7 +382,7 @@ fn add_rvalue_clean<'a, 'tcx>(mode: RvalueMode,\n         ByValue => { fcx.schedule_drop_immediate(scope, val, ty); }\n         ByRef => {\n             fcx.schedule_lifetime_end(scope, val);\n-            fcx.schedule_drop_mem(scope, val, ty);\n+            fcx.schedule_drop_mem(scope, val, ty, None);\n         }\n     }\n }\n@@ -419,10 +439,28 @@ impl KindOps for Lvalue {\n                               -> Block<'blk, 'tcx> {\n         let _icx = push_ctxt(\"<Lvalue as KindOps>::post_store\");\n         if bcx.fcx.type_needs_drop(ty) {\n-            // cancel cleanup of affine values by drop-filling the memory\n-            let () = drop_done_fill_mem(bcx, val, ty);\n+            // cancel cleanup of affine values:\n+            // 1. if it has drop-hint, mark as moved; then code\n+            //    aware of drop-hint won't bother calling the\n+            //    drop-glue itself.\n+            if let Some(hint_datum) = self.drop_flag_info.hint_datum(bcx) {\n+                let moved_hint_byte = adt::DTOR_MOVED_HINT as usize;\n+                let hint_llval = hint_datum.to_value().value();\n+                Store(bcx, C_u8(bcx.fcx.ccx, moved_hint_byte), hint_llval);\n+            }\n+            // 2. if the drop info says its necessary, drop-fill the memory.\n+            if self.drop_flag_info.must_zero() {\n+                let () = drop_done_fill_mem(bcx, val, ty);\n+            }\n             bcx\n         } else {\n+            // XXX would be nice to assert this, but we currently are\n+            // adding e.g.  DontZeroJustUse flags. (The dropflag hint\n+            // construction should be taking !type_needs_drop into\n+            // account; earlier analysis phases may not have all the\n+            // info they need to do it properly, I think...)\n+            //\n+            // assert_eq!(self.drop_flag_info, DropFlagInfo::None);\n             bcx\n         }\n     }"}, {"sha": "ba0ae27a0057340d669b77b4501b7df5094e2593", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/dce1c61e977deed5e0a499f4247d5da870809692/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dce1c61e977deed5e0a499f4247d5da870809692/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=dce1c61e977deed5e0a499f4247d5da870809692", "patch": "@@ -61,7 +61,7 @@ use middle::traits;\n use trans::{_match, adt, asm, base, callee, closure, consts, controlflow};\n use trans::base::*;\n use trans::build::*;\n-use trans::cleanup::{self, CleanupMethods};\n+use trans::cleanup::{self, CleanupMethods, DropHintMethods};\n use trans::common::*;\n use trans::datum::*;\n use trans::debuginfo::{self, DebugLoc, ToDebugLoc};\n@@ -1004,10 +1004,26 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n                 let src_datum = unpack_datum!(\n                     bcx, src_datum.to_rvalue_datum(bcx, \"ExprAssign\"));\n-                bcx = glue::drop_ty(bcx,\n-                                    dst_datum.val,\n-                                    dst_datum.ty,\n-                                    expr.debug_loc());\n+                if let Some(hint_datum) = dst_datum.kind.drop_flag_info.hint_datum(bcx) {\n+                    let hint_val = hint_datum.to_value();\n+                    // XXX the checkpointed branch only does the\n+                    // drop_ty call within this branch (and I claim\n+                    // that seems like a bug). At this point I have\n+                    // moved it into the branch solely to see if it\n+                    // makes my plague of bugs go away.\n+                    bcx = glue::drop_ty_core(bcx,\n+                                             dst_datum.val,\n+                                             dst_datum.ty,\n+                                             expr.debug_loc(),\n+                                             false,\n+                                             Some(hint_val));\n+                    // We are initializing or overwriting the\n+                    // destination, so we need to write \"drop needed\"\n+                    // into the hint.\n+                    let hint_llval = hint_val.value();\n+                    let drop_needed = C_u8(bcx.fcx.ccx, adt::DTOR_NEEDED_HINT as usize);\n+                    Store(bcx, drop_needed, hint_llval);\n+                }\n                 src_datum.store_to(bcx, dst_datum.val)\n             } else {\n                 src_datum.store_to(bcx, dst_datum.val)\n@@ -1578,7 +1594,8 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             bcx = trans_into(bcx, &**e, SaveIn(dest));\n             let scope = cleanup::CustomScope(custom_cleanup_scope);\n             fcx.schedule_lifetime_end(scope, dest);\n-            fcx.schedule_drop_mem(scope, dest, e_ty);\n+            // FIXME: nonzeroing move should generalize to fields\n+            fcx.schedule_drop_mem(scope, dest, e_ty, None);\n         }\n     }\n "}, {"sha": "6019099c058254024afdd009b800b41f81da7984", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/dce1c61e977deed5e0a499f4247d5da870809692/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dce1c61e977deed5e0a499f4247d5da870809692/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=dce1c61e977deed5e0a499f4247d5da870809692", "patch": "@@ -130,17 +130,20 @@ pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                            v: ValueRef,\n                            t: Ty<'tcx>,\n                            debug_loc: DebugLoc) -> Block<'blk, 'tcx> {\n-    drop_ty_core(bcx, v, t, debug_loc, false)\n+    drop_ty_core(bcx, v, t, debug_loc, false, None)\n }\n \n pub fn drop_ty_core<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 v: ValueRef,\n                                 t: Ty<'tcx>,\n                                 debug_loc: DebugLoc,\n-                                skip_dtor: bool) -> Block<'blk, 'tcx> {\n+                                skip_dtor: bool,\n+                                drop_hint: Option<cleanup::DropHintValue>)\n+                                -> Block<'blk, 'tcx> {\n     // NB: v is an *alias* of type t here, not a direct value.\n-    debug!(\"drop_ty_core(t={:?}, skip_dtor={})\", t, skip_dtor);\n+    debug!(\"drop_ty_core(t={:?}, skip_dtor={} drop_hint={:?})\", t, skip_dtor, drop_hint);\n     let _icx = push_ctxt(\"drop_ty\");\n+    let mut bcx = bcx;\n     if bcx.fcx.type_needs_drop(t) {\n         let ccx = bcx.ccx();\n         let g = if skip_dtor {\n@@ -156,7 +159,23 @@ pub fn drop_ty_core<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             v\n         };\n \n-        Call(bcx, glue, &[ptr], None, debug_loc);\n+        match drop_hint {\n+            Some(drop_hint) => {\n+                let hint_val = load_ty(bcx, drop_hint.value(), bcx.tcx().types.u8);\n+                let moved_val =\n+                    C_integral(Type::i8(bcx.ccx()), adt::DTOR_MOVED_HINT as u64, false);\n+                let may_need_drop =\n+                    ICmp(bcx, llvm::IntNE, hint_val, moved_val, DebugLoc::None);\n+                bcx = with_cond(bcx, may_need_drop, |cx| {\n+                    Call(cx, glue, &[ptr], None, debug_loc);\n+                    cx\n+                })\n+            }\n+            None => {\n+                // No drop-hint ==> call standard drop glue\n+                Call(bcx, glue, &[ptr], None, debug_loc);\n+            }\n+        }\n     }\n     bcx\n }\n@@ -170,7 +189,7 @@ pub fn drop_ty_immediate<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"drop_ty_immediate\");\n     let vp = alloca(bcx, type_of(bcx.ccx(), t), \"\");\n     store_ty(bcx, v, vp, t);\n-    drop_ty_core(bcx, vp, t, debug_loc, skip_dtor)\n+    drop_ty_core(bcx, vp, t, debug_loc, skip_dtor, None)\n }\n \n pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> ValueRef {"}, {"sha": "a9abc61c274d16a85475c530da8e815ecada7f86", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dce1c61e977deed5e0a499f4247d5da870809692/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dce1c61e977deed5e0a499f4247d5da870809692/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=dce1c61e977deed5e0a499f4247d5da870809692", "patch": "@@ -117,7 +117,7 @@ pub fn trans_slice_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // Arrange for the backing array to be cleaned up.\n         let cleanup_scope = cleanup::temporary_scope(bcx.tcx(), content_expr.id);\n         fcx.schedule_lifetime_end(cleanup_scope, llfixed);\n-        fcx.schedule_drop_mem(cleanup_scope, llfixed, fixed_ty);\n+        fcx.schedule_drop_mem(cleanup_scope, llfixed, fixed_ty, None);\n \n         // Generate the content into the backing array.\n         // llfixed has type *[T x N], but we want the type *T,\n@@ -212,7 +212,7 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                SaveIn(lleltptr));\n                         let scope = cleanup::CustomScope(temp_scope);\n                         fcx.schedule_lifetime_end(scope, lleltptr);\n-                        fcx.schedule_drop_mem(scope, lleltptr, vt.unit_ty);\n+                        fcx.schedule_drop_mem(scope, lleltptr, vt.unit_ty, None);\n                     }\n                     fcx.pop_custom_cleanup_scope(temp_scope);\n                 }"}]}