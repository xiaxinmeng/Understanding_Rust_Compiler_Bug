{"sha": "2babbbb97800b526cc29f244bb6ea58b213d24f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiYWJiYmI5NzgwMGI1MjZjYzI5ZjI0NGJiNmVhNThiMjEzZDI0ZjM=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-11T10:54:27Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-11T10:54:27Z"}, "message": "Merge #784\n\n784: WIP: improve multi-crate fixtures r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "c7721643a31072a06aced7d2c3b9122941db479e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7721643a31072a06aced7d2c3b9122941db479e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2babbbb97800b526cc29f244bb6ea58b213d24f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2babbbb97800b526cc29f244bb6ea58b213d24f3", "html_url": "https://github.com/rust-lang/rust/commit/2babbbb97800b526cc29f244bb6ea58b213d24f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2babbbb97800b526cc29f244bb6ea58b213d24f3/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "b60ccac9d3b964d4700b4a8461ab21d5e9688622", "url": "https://api.github.com/repos/rust-lang/rust/commits/b60ccac9d3b964d4700b4a8461ab21d5e9688622", "html_url": "https://github.com/rust-lang/rust/commit/b60ccac9d3b964d4700b4a8461ab21d5e9688622"}, {"sha": "9923383d5351089a337dc855ec9d9bbcbd297778", "url": "https://api.github.com/repos/rust-lang/rust/commits/9923383d5351089a337dc855ec9d9bbcbd297778", "html_url": "https://github.com/rust-lang/rust/commit/9923383d5351089a337dc855ec9d9bbcbd297778"}], "stats": {"total": 262, "additions": 146, "deletions": 116}, "files": [{"sha": "8ed8c4bdc2976d33ae3a0517a59bcddd8d6c7475", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2babbbb97800b526cc29f244bb6ea58b213d24f3/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2babbbb97800b526cc29f244bb6ea58b213d24f3/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=2babbbb97800b526cc29f244bb6ea58b213d24f3", "patch": "@@ -18,6 +18,7 @@ macro_rules! impl_froms {\n }\n \n pub mod db;\n+#[macro_use]\n pub mod mock;\n mod query_definitions;\n mod path;"}, {"sha": "5ca87086753c7cd9782adcafeefdb71370f931f0", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 90, "deletions": 27, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/2babbbb97800b526cc29f244bb6ea58b213d24f3/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2babbbb97800b526cc29f244bb6ea58b213d24f3/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=2babbbb97800b526cc29f244bb6ea58b213d24f3", "patch": "@@ -6,6 +6,7 @@ use ra_db::{\n };\n use relative_path::RelativePathBuf;\n use test_utils::{parse_fixture, CURSOR_MARKER, extract_offset};\n+use rustc_hash::FxHashMap;\n \n use crate::{db, HirInterner};\n \n@@ -21,82 +22,125 @@ pub struct MockDatabase {\n     events: Mutex<Option<Vec<salsa::Event<MockDatabase>>>>,\n     runtime: salsa::Runtime<MockDatabase>,\n     interner: Arc<HirInterner>,\n-    file_counter: u32,\n+    files: FxHashMap<String, FileId>,\n }\n \n impl panic::RefUnwindSafe for MockDatabase {}\n \n impl MockDatabase {\n-    pub fn with_files(fixture: &str) -> (MockDatabase, SourceRoot) {\n-        let (db, source_root, position) = MockDatabase::from_fixture(fixture);\n+    pub fn with_files(fixture: &str) -> MockDatabase {\n+        let (db, position) = MockDatabase::from_fixture(fixture);\n         assert!(position.is_none());\n-        (db, source_root)\n+        db\n     }\n \n     pub fn with_single_file(text: &str) -> (MockDatabase, SourceRoot, FileId) {\n         let mut db = MockDatabase::default();\n         let mut source_root = SourceRoot::default();\n-        let file_id = db.add_file(WORKSPACE, &mut source_root, \"/main.rs\", text);\n+        let file_id = db.add_file(WORKSPACE, \"/\", &mut source_root, \"/main.rs\", text);\n         db.set_source_root(WORKSPACE, Arc::new(source_root.clone()));\n         (db, source_root, file_id)\n     }\n \n     pub fn with_position(fixture: &str) -> (MockDatabase, FilePosition) {\n-        let (db, _, position) = MockDatabase::from_fixture(fixture);\n+        let (db, position) = MockDatabase::from_fixture(fixture);\n         let position = position.expect(\"expected a marker ( <|> )\");\n         (db, position)\n     }\n \n-    fn from_fixture(fixture: &str) -> (MockDatabase, SourceRoot, Option<FilePosition>) {\n+    pub fn file_id_of(&self, path: &str) -> FileId {\n+        match self.files.get(path) {\n+            Some(it) => *it,\n+            None => panic!(\"unknown file: {:?}\\nexisting files:\\n{:#?}\", path, self.files),\n+        }\n+    }\n+\n+    pub fn set_crate_graph_from_fixture(&mut self, graph: CrateGraphFixture) {\n+        let mut ids = FxHashMap::default();\n+        let mut crate_graph = CrateGraph::default();\n+        for (crate_name, (crate_root, _)) in graph.0.iter() {\n+            let crate_root = self.file_id_of(&crate_root);\n+            let crate_id = crate_graph.add_crate_root(crate_root);\n+            ids.insert(crate_name, crate_id);\n+        }\n+        for (crate_name, (_, deps)) in graph.0.iter() {\n+            let from = ids[crate_name];\n+            for dep in deps {\n+                let to = ids[dep];\n+                crate_graph.add_dep(from, dep.as_str().into(), to).unwrap();\n+            }\n+        }\n+        self.set_crate_graph(Arc::new(crate_graph))\n+    }\n+\n+    fn from_fixture(fixture: &str) -> (MockDatabase, Option<FilePosition>) {\n         let mut db = MockDatabase::default();\n \n-        let (source_root, pos) = db.add_fixture(WORKSPACE, fixture);\n+        let pos = db.add_fixture(fixture);\n \n-        (db, source_root, pos)\n+        (db, pos)\n     }\n \n-    pub fn add_fixture(\n-        &mut self,\n-        source_root_id: SourceRootId,\n-        fixture: &str,\n-    ) -> (SourceRoot, Option<FilePosition>) {\n+    fn add_fixture(&mut self, fixture: &str) -> Option<FilePosition> {\n         let mut position = None;\n         let mut source_root = SourceRoot::default();\n+        let mut source_root_id = WORKSPACE;\n+        let mut source_root_prefix = \"/\".to_string();\n         for entry in parse_fixture(fixture) {\n+            if entry.meta.starts_with(\"root\") {\n+                self.set_source_root(source_root_id, Arc::new(source_root));\n+                source_root = SourceRoot::default();\n+\n+                source_root_id = SourceRootId(source_root_id.0 + 1);\n+                source_root_prefix = entry.meta[\"root\".len()..].trim().to_string();\n+                continue;\n+            }\n             if entry.text.contains(CURSOR_MARKER) {\n                 assert!(position.is_none(), \"only one marker (<|>) per fixture is allowed\");\n                 position = Some(self.add_file_with_position(\n                     source_root_id,\n+                    &source_root_prefix,\n                     &mut source_root,\n                     &entry.meta,\n                     &entry.text,\n                 ));\n             } else {\n-                self.add_file(source_root_id, &mut source_root, &entry.meta, &entry.text);\n+                self.add_file(\n+                    source_root_id,\n+                    &source_root_prefix,\n+                    &mut source_root,\n+                    &entry.meta,\n+                    &entry.text,\n+                );\n             }\n         }\n-        self.set_source_root(source_root_id, Arc::new(source_root.clone()));\n-        (source_root, position)\n+        self.set_source_root(source_root_id, Arc::new(source_root));\n+        position\n     }\n \n     fn add_file(\n         &mut self,\n         source_root_id: SourceRootId,\n+        source_root_prefix: &str,\n         source_root: &mut SourceRoot,\n         path: &str,\n         text: &str,\n     ) -> FileId {\n-        assert!(path.starts_with('/'));\n-        let is_crate_root = path == \"/lib.rs\" || path == \"/main.rs\";\n+        assert!(source_root_prefix.starts_with('/'));\n+        assert!(source_root_prefix.ends_with('/'));\n+        assert!(path.starts_with(source_root_prefix));\n+        let rel_path = RelativePathBuf::from_path(&path[source_root_prefix.len()..]).unwrap();\n+\n+        let is_crate_root = rel_path == \"lib.rs\" || rel_path == \"/main.rs\";\n \n-        let path = RelativePathBuf::from_path(&path[1..]).unwrap();\n-        let file_id = FileId(self.file_counter);\n-        self.file_counter += 1;\n+        let file_id = FileId(self.files.len() as u32);\n+        let prev = self.files.insert(path.to_string(), file_id);\n+        assert!(prev.is_none(), \"duplicate files in the text fixture\");\n         let text = Arc::new(text.to_string());\n         self.set_file_text(file_id, text);\n-        self.set_file_relative_path(file_id, path.clone());\n+        self.set_file_relative_path(file_id, rel_path.clone());\n         self.set_file_source_root(file_id, source_root_id);\n-        source_root.files.insert(path, file_id);\n+        source_root.files.insert(rel_path, file_id);\n \n         if is_crate_root {\n             let mut crate_graph = CrateGraph::default();\n@@ -109,12 +153,13 @@ impl MockDatabase {\n     fn add_file_with_position(\n         &mut self,\n         source_root_id: SourceRootId,\n+        source_root_prefix: &str,\n         source_root: &mut SourceRoot,\n         path: &str,\n         text: &str,\n     ) -> FilePosition {\n         let (offset, text) = extract_offset(text);\n-        let file_id = self.add_file(source_root_id, source_root, path, &text);\n+        let file_id = self.add_file(source_root_id, source_root_prefix, source_root, path, &text);\n         FilePosition { file_id, offset }\n     }\n }\n@@ -138,7 +183,7 @@ impl Default for MockDatabase {\n             events: Default::default(),\n             runtime: salsa::Runtime::default(),\n             interner: Default::default(),\n-            file_counter: 0,\n+            files: FxHashMap::default(),\n         };\n         db.set_crate_graph(Default::default());\n         db\n@@ -151,7 +196,8 @@ impl salsa::ParallelDatabase for MockDatabase {\n             events: Default::default(),\n             runtime: self.runtime.snapshot(self),\n             interner: Arc::clone(&self.interner),\n-            file_counter: self.file_counter,\n+            // only the root database can be used to get file_id by path.\n+            files: FxHashMap::default(),\n         })\n     }\n }\n@@ -184,3 +230,20 @@ impl MockDatabase {\n             .collect()\n     }\n }\n+\n+#[derive(Default)]\n+pub struct CrateGraphFixture(pub FxHashMap<String, (String, Vec<String>)>);\n+\n+#[macro_export]\n+macro_rules! crate_graph {\n+    ($($crate_name:literal: ($crate_path:literal, [$($dep:literal),*]),)*) => {{\n+        let mut res = $crate::mock::CrateGraphFixture::default();\n+        $(\n+            res.0.insert(\n+                $crate_name.to_string(),\n+                ($crate_path.to_string(), vec![$($dep.to_string()),*])\n+            );\n+        )*\n+        res\n+    }}\n+}"}, {"sha": "9b621fbc27ead15849aa0149a67545c93b7089e6", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 55, "deletions": 89, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/2babbbb97800b526cc29f244bb6ea58b213d24f3/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2babbbb97800b526cc29f244bb6ea58b213d24f3/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=2babbbb97800b526cc29f244bb6ea58b213d24f3", "patch": "@@ -1,7 +1,6 @@\n use std::sync::Arc;\n \n-use ra_db::{CrateGraph, SourceRootId, SourceDatabase};\n-use relative_path::RelativePath;\n+use ra_db::SourceDatabase;\n use test_utils::{assert_eq_text, covers};\n \n use crate::{\n@@ -20,20 +19,6 @@ fn item_map(fixture: &str) -> (Arc<ItemMap>, ModuleId) {\n     (db.item_map(krate), module_id)\n }\n \n-/// Sets the crate root to the file of the cursor marker\n-fn item_map_custom_crate_root(fixture: &str) -> (Arc<ItemMap>, ModuleId) {\n-    let (mut db, pos) = MockDatabase::with_position(fixture);\n-\n-    let mut crate_graph = CrateGraph::default();\n-    crate_graph.add_crate_root(pos.file_id);\n-    db.set_crate_graph(Arc::new(crate_graph));\n-\n-    let module = crate::source_binder::module_from_position(&db, pos).unwrap();\n-    let krate = module.krate(&db).unwrap();\n-    let module_id = module.module_id;\n-    (db.item_map(krate), module_id)\n-}\n-\n fn check_module_item_map(map: &ItemMap, module_id: ModuleId, expected: &str) {\n     let mut lines = map[module_id]\n         .items\n@@ -252,24 +237,20 @@ fn glob_enum() {\n #[test]\n fn glob_across_crates() {\n     covers!(glob_across_crates);\n-    let (mut db, sr) = MockDatabase::with_files(\n+    let mut db = MockDatabase::with_files(\n         \"\n         //- /main.rs\n         use test_crate::*;\n \n         //- /lib.rs\n         pub struct Baz;\n-    \",\n+        \",\n     );\n-    let main_id = sr.files[RelativePath::new(\"/main.rs\")];\n-    let lib_id = sr.files[RelativePath::new(\"/lib.rs\")];\n-\n-    let mut crate_graph = CrateGraph::default();\n-    let main_crate = crate_graph.add_crate_root(main_id);\n-    let lib_crate = crate_graph.add_crate_root(lib_id);\n-    crate_graph.add_dep(main_crate, \"test_crate\".into(), lib_crate).unwrap();\n-\n-    db.set_crate_graph(Arc::new(crate_graph));\n+    db.set_crate_graph_from_fixture(crate_graph! {\n+        \"main\": (\"/main.rs\", [\"test_crate\"]),\n+        \"test_crate\": (\"/lib.rs\", []),\n+    });\n+    let main_id = db.file_id_of(\"/main.rs\");\n \n     let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n     let krate = module.krate(&db).unwrap();\n@@ -286,22 +267,31 @@ fn glob_across_crates() {\n \n #[test]\n fn module_resolution_works_for_non_standard_filenames() {\n-    let (item_map, module_id) = item_map_custom_crate_root(\n+    let mut db = MockDatabase::with_files(\n         \"\n         //- /my_library.rs\n         mod foo;\n         use self::foo::Bar;\n-        <|>\n+\n         //- /foo/mod.rs\n         pub struct Bar;\n-    \",\n+        \",\n     );\n+    db.set_crate_graph_from_fixture(crate_graph! {\n+        \"my_library\": (\"/my_library.rs\", []),\n+    });\n+    let file_id = db.file_id_of(\"/my_library.rs\");\n+\n+    let module = crate::source_binder::module_from_file_id(&db, file_id).unwrap();\n+    let krate = module.krate(&db).unwrap();\n+    let module_id = module.module_id;\n+    let item_map = db.item_map(krate);\n     check_module_item_map(\n         &item_map,\n         module_id,\n         \"\n-            Bar: t v\n-            foo: t\n+        Bar: t v\n+        foo: t\n         \",\n     );\n }\n@@ -411,24 +401,20 @@ fn item_map_enum_importing() {\n \n #[test]\n fn item_map_across_crates() {\n-    let (mut db, sr) = MockDatabase::with_files(\n+    let mut db = MockDatabase::with_files(\n         \"\n         //- /main.rs\n         use test_crate::Baz;\n \n         //- /lib.rs\n         pub struct Baz;\n-    \",\n+        \",\n     );\n-    let main_id = sr.files[RelativePath::new(\"/main.rs\")];\n-    let lib_id = sr.files[RelativePath::new(\"/lib.rs\")];\n-\n-    let mut crate_graph = CrateGraph::default();\n-    let main_crate = crate_graph.add_crate_root(main_id);\n-    let lib_crate = crate_graph.add_crate_root(lib_id);\n-    crate_graph.add_dep(main_crate, \"test_crate\".into(), lib_crate).unwrap();\n-\n-    db.set_crate_graph(Arc::new(crate_graph));\n+    db.set_crate_graph_from_fixture(crate_graph! {\n+        \"main\": (\"/main.rs\", [\"test_crate\"]),\n+        \"test_crate\": (\"/lib.rs\", []),\n+    });\n+    let main_id = db.file_id_of(\"/main.rs\");\n \n     let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n     let krate = module.krate(&db).unwrap();\n@@ -438,14 +424,14 @@ fn item_map_across_crates() {\n         &item_map,\n         module.module_id,\n         \"\n-            Baz: t v\n+        Baz: t v\n         \",\n     );\n }\n \n #[test]\n fn extern_crate_rename() {\n-    let (mut db, sr) = MockDatabase::with_files(\n+    let mut db = MockDatabase::with_files(\n         \"\n         //- /main.rs\n         extern crate alloc as alloc_crate;\n@@ -458,18 +444,13 @@ fn extern_crate_rename() {\n \n         //- /lib.rs\n         struct Arc;\n-    \",\n+        \",\n     );\n-    let main_id = sr.files[RelativePath::new(\"/main.rs\")];\n-    let sync_id = sr.files[RelativePath::new(\"/sync.rs\")];\n-    let lib_id = sr.files[RelativePath::new(\"/lib.rs\")];\n-\n-    let mut crate_graph = CrateGraph::default();\n-    let main_crate = crate_graph.add_crate_root(main_id);\n-    let lib_crate = crate_graph.add_crate_root(lib_id);\n-    crate_graph.add_dep(main_crate, \"alloc\".into(), lib_crate).unwrap();\n-\n-    db.set_crate_graph(Arc::new(crate_graph));\n+    db.set_crate_graph_from_fixture(crate_graph! {\n+        \"main\": (\"/main.rs\", [\"alloc\"]),\n+        \"alloc\": (\"/lib.rs\", []),\n+    });\n+    let sync_id = db.file_id_of(\"/sync.rs\");\n \n     let module = crate::source_binder::module_from_file_id(&db, sync_id).unwrap();\n     let krate = module.krate(&db).unwrap();\n@@ -479,44 +460,33 @@ fn extern_crate_rename() {\n         &item_map,\n         module.module_id,\n         \"\n-            Arc: t v\n+        Arc: t v\n         \",\n     );\n }\n \n #[test]\n fn import_across_source_roots() {\n-    let (mut db, sr) = MockDatabase::with_files(\n+    let mut db = MockDatabase::with_files(\n         \"\n         //- /lib.rs\n         pub mod a {\n             pub mod b {\n                 pub struct C;\n             }\n         }\n-    \",\n-    );\n-    let lib_id = sr.files[RelativePath::new(\"/lib.rs\")];\n \n-    let source_root = SourceRootId(1);\n+        //- root /main/\n \n-    let (sr2, pos) = db.add_fixture(\n-        source_root,\n-        \"\n-        //- /main.rs\n+        //- /main/main.rs\n         use test_crate::a::b::C;\n-    \",\n+        \",\n     );\n-    assert!(pos.is_none());\n-\n-    let main_id = sr2.files[RelativePath::new(\"/main.rs\")];\n-\n-    let mut crate_graph = CrateGraph::default();\n-    let main_crate = crate_graph.add_crate_root(main_id);\n-    let lib_crate = crate_graph.add_crate_root(lib_id);\n-    crate_graph.add_dep(main_crate, \"test_crate\".into(), lib_crate).unwrap();\n-\n-    db.set_crate_graph(Arc::new(crate_graph));\n+    db.set_crate_graph_from_fixture(crate_graph! {\n+        \"main\": (\"/main/main.rs\", [\"test_crate\"]),\n+        \"test_crate\": (\"/lib.rs\", []),\n+    });\n+    let main_id = db.file_id_of(\"/main/main.rs\");\n \n     let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n     let krate = module.krate(&db).unwrap();\n@@ -533,7 +503,7 @@ fn import_across_source_roots() {\n \n #[test]\n fn reexport_across_crates() {\n-    let (mut db, sr) = MockDatabase::with_files(\n+    let mut db = MockDatabase::with_files(\n         \"\n         //- /main.rs\n         use test_crate::Baz;\n@@ -545,17 +515,13 @@ fn reexport_across_crates() {\n \n         //- /foo.rs\n         pub struct Baz;\n-    \",\n+        \",\n     );\n-    let main_id = sr.files[RelativePath::new(\"/main.rs\")];\n-    let lib_id = sr.files[RelativePath::new(\"/lib.rs\")];\n-\n-    let mut crate_graph = CrateGraph::default();\n-    let main_crate = crate_graph.add_crate_root(main_id);\n-    let lib_crate = crate_graph.add_crate_root(lib_id);\n-    crate_graph.add_dep(main_crate, \"test_crate\".into(), lib_crate).unwrap();\n-\n-    db.set_crate_graph(Arc::new(crate_graph));\n+    db.set_crate_graph_from_fixture(crate_graph! {\n+        \"main\": (\"/main.rs\", [\"test_crate\"]),\n+        \"test_crate\": (\"/lib.rs\", []),\n+    });\n+    let main_id = db.file_id_of(\"/main.rs\");\n \n     let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n     let krate = module.krate(&db).unwrap();\n@@ -565,7 +531,7 @@ fn reexport_across_crates() {\n         &item_map,\n         module.module_id,\n         \"\n-            Baz: t v\n+        Baz: t v\n         \",\n     );\n }"}]}