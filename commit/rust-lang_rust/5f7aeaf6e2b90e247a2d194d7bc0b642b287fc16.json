{"sha": "5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmN2FlYWY2ZTJiOTBlMjQ3YTJkMTk0ZDdiYzBiNjQyYjI4N2ZjMTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-28T06:45:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-28T06:45:31Z"}, "message": "Auto merge of #47013 - topecongiro:issue-46655, r=petrochenkov\n\nDo not expand a derive invocation when derive is not allowed\n\nCloses #46655.\n\nThe first commit is what actually closes #46655. The second one is just a refactoring I have done while waiting on a test.", "tree": {"sha": "22dc195d1b7fbb49907dd10bbf5e333c8090b672", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22dc195d1b7fbb49907dd10bbf5e333c8090b672"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16", "html_url": "https://github.com/rust-lang/rust/commit/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a8c753d5e410b50e86f7a13d509760ee4ffe319", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a8c753d5e410b50e86f7a13d509760ee4ffe319", "html_url": "https://github.com/rust-lang/rust/commit/9a8c753d5e410b50e86f7a13d509760ee4ffe319"}, {"sha": "d88269104679110dacab2aca32001352c2833ec5", "url": "https://api.github.com/repos/rust-lang/rust/commits/d88269104679110dacab2aca32001352c2833ec5", "html_url": "https://github.com/rust-lang/rust/commit/d88269104679110dacab2aca32001352c2833ec5"}], "stats": {"total": 259, "additions": 151, "deletions": 108}, "files": [{"sha": "e435f14470c57fa25792cfbc689e532b69855737", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16", "patch": "@@ -1571,7 +1571,7 @@ impl<'a> LoweringContext<'a> {\n             bounds,\n             default: tp.default.as_ref().map(|x| self.lower_ty(x, ImplTraitContext::Disallowed)),\n             span: tp.span,\n-            pure_wrt_drop: tp.attrs.iter().any(|attr| attr.check_name(\"may_dangle\")),\n+            pure_wrt_drop: attr::contains_name(&tp.attrs, \"may_dangle\"),\n             synthetic: tp.attrs.iter()\n                                .filter(|attr| attr.check_name(\"rustc_synthetic\"))\n                                .map(|_| hir::SyntheticTyParamKind::ImplTrait)\n@@ -1611,7 +1611,7 @@ impl<'a> LoweringContext<'a> {\n         let def = hir::LifetimeDef {\n             lifetime: self.lower_lifetime(&l.lifetime),\n             bounds: self.lower_lifetimes(&l.bounds),\n-            pure_wrt_drop: l.attrs.iter().any(|attr| attr.check_name(\"may_dangle\")),\n+            pure_wrt_drop: attr::contains_name(&l.attrs, \"may_dangle\"),\n             in_band: false,\n         };\n \n@@ -2331,7 +2331,7 @@ impl<'a> LoweringContext<'a> {\n         let mut vis = self.lower_visibility(&i.vis, None);\n         let attrs = self.lower_attrs(&i.attrs);\n         if let ItemKind::MacroDef(ref def) = i.node {\n-            if !def.legacy || i.attrs.iter().any(|attr| attr.path == \"macro_export\") {\n+            if !def.legacy || attr::contains_name(&i.attrs, \"macro_export\") {\n                 let body = self.lower_token_stream(def.stream());\n                 self.exported_macros.push(hir::MacroDef {\n                     name,"}, {"sha": "757b078086d9c0531a0b342c3502c386e17c4854", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16", "patch": "@@ -140,9 +140,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n     {\n         let attrs = tcx.get_attrs(impl_def_id);\n \n-        let attr = if let Some(item) =\n-            attrs.into_iter().find(|a| a.check_name(\"rustc_on_unimplemented\"))\n-        {\n+        let attr = if let Some(item) = attr::find_by_name(&attrs, \"rustc_on_unimplemented\") {\n             item\n         } else {\n             return Ok(None);"}, {"sha": "12e5451f83cf4dc27dea935cf992762377e8e375", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16", "patch": "@@ -2402,7 +2402,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     /// Determine whether an item is annotated with an attribute\n     pub fn has_attr(self, did: DefId, attr: &str) -> bool {\n-        self.get_attrs(did).iter().any(|item| item.check_name(attr))\n+        attr::contains_name(&self.get_attrs(did), attr)\n     }\n \n     /// Returns true if this is an `auto trait`."}, {"sha": "839d1831f95443fe7e4105d5808eb8bf1e710c9a", "filename": "src/librustc_driver/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Flibrustc_driver%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Flibrustc_driver%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FREADME.md?ref=5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16", "patch": "@@ -3,7 +3,7 @@ compiler as a whole, see\n [the README.md file found in `librustc`](../librustc/README.md).\n \n The `driver` crate is effectively the \"main\" function for the rust\n-compiler.  It orchstrates the compilation process and \"knits together\"\n+compiler.  It orchestrates the compilation process and \"knits together\"\n the code from the other crates within rustc. This crate itself does\n not contain any of the \"main logic\" of the compiler (though it does\n have some code related to pretty printing or other minor compiler"}, {"sha": "0303b503691d19022a57961ec4e53915a4bfa306", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16", "patch": "@@ -221,9 +221,7 @@ impl LintPass for NonSnakeCase {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n     fn check_crate(&mut self, cx: &LateContext, cr: &hir::Crate) {\n-        let attr_crate_name = cr.attrs\n-            .iter()\n-            .find(|at| at.check_name(\"crate_name\"))\n+        let attr_crate_name = attr::find_by_name(&cr.attrs, \"crate_name\")\n             .and_then(|at| at.value_str().map(|s| (at, s)));\n         if let Some(ref name) = cx.tcx.sess.opts.crate_name {\n             self.check_snake_case(cx, \"crate\", name, None);"}, {"sha": "725a1b845e7ea39ff226d3b2f9d8518c50ea666f", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16", "patch": "@@ -27,6 +27,7 @@ use rustc::ty::subst::Subst;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n use syntax::ast;\n+use syntax::attr;\n use syntax::symbol::Symbol;\n use rustc::hir;\n use rustc_const_math::{ConstInt, ConstUsize};\n@@ -78,8 +79,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         // Some functions always have overflow checks enabled,\n         // however, they may not get codegen'd, depending on\n         // the settings for the crate they are translated in.\n-        let mut check_overflow = attrs.iter()\n-            .any(|item| item.check_name(\"rustc_inherit_overflow_checks\"));\n+        let mut check_overflow = attr::contains_name(attrs, \"rustc_inherit_overflow_checks\");\n \n         // Respect -C overflow-checks.\n         check_overflow |= tcx.sess.overflow_checks();"}, {"sha": "61f54774163d4772fcc0fcaa52aad5b26fc9c5e0", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16", "patch": "@@ -51,8 +51,7 @@ impl<'a> AstValidator<'a> {\n     }\n \n     fn invalid_non_exhaustive_attribute(&self, variant: &Variant) {\n-        let has_non_exhaustive = variant.node.attrs.iter()\n-            .any(|attr| attr.check_name(\"non_exhaustive\"));\n+        let has_non_exhaustive = attr::contains_name(&variant.node.attrs, \"non_exhaustive\");\n         if has_non_exhaustive {\n             self.err_handler().span_err(variant.span,\n                                         \"#[non_exhaustive] is not yet supported on variants\");\n@@ -308,7 +307,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             ItemKind::Mod(_) => {\n                 // Ensure that `path` attributes on modules are recorded as used (c.f. #35584).\n                 attr::first_attr_value_str_by_name(&item.attrs, \"path\");\n-                if item.attrs.iter().any(|attr| attr.check_name(\"warn_directory_ownership\")) {\n+                if attr::contains_name(&item.attrs, \"warn_directory_ownership\") {\n                     let lint = lint::builtin::LEGACY_DIRECTORY_OWNERSHIP;\n                     let msg = \"cannot declare a new module at this location\";\n                     self.session.buffer_lint(lint, item.id, item.span, msg);"}, {"sha": "5866c8f93f094cfe51f122856c6b8d807af1a75b", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16", "patch": "@@ -358,8 +358,7 @@ impl<'a> Resolver<'a> {\n \n                 let mut ctor_vis = vis;\n \n-                let has_non_exhaustive = item.attrs.iter()\n-                    .any(|item| item.check_name(\"non_exhaustive\"));\n+                let has_non_exhaustive = attr::contains_name(&item.attrs, \"non_exhaustive\");\n \n                 // If the structure is marked as non_exhaustive then lower the visibility\n                 // to within the crate."}, {"sha": "aabe931d79c579af326fa6a93ef1263fa72a898f", "filename": "src/librustc_trans_utils/link.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Flibrustc_trans_utils%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Flibrustc_trans_utils%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Flink.rs?ref=5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16", "patch": "@@ -13,7 +13,7 @@ use rustc::session::Session;\n use rustc::middle::cstore::{self, LinkMeta};\n use rustc::hir::svh::Svh;\n use std::path::{Path, PathBuf};\n-use syntax::ast;\n+use syntax::{ast, attr};\n use syntax_pos::Span;\n \n pub fn out_filename(sess: &Session,\n@@ -69,8 +69,8 @@ pub fn find_crate_name(sess: Option<&Session>,\n     // as used. After doing this, however, we still prioritize a crate name from\n     // the command line over one found in the #[crate_name] attribute. If we\n     // find both we ensure that they're the same later on as well.\n-    let attr_crate_name = attrs.iter().find(|at| at.check_name(\"crate_name\"))\n-                               .and_then(|at| at.value_str().map(|s| (at, s)));\n+    let attr_crate_name = attr::find_by_name(attrs, \"crate_name\")\n+        .and_then(|at| at.value_str().map(|s| (at, s)));\n \n     if let Some(sess) = sess {\n         if let Some(ref s) = sess.opts.crate_name {"}, {"sha": "be71d6e038c854a8e23f84343d94d4cced6f9076", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16", "patch": "@@ -96,6 +96,18 @@ impl Annotatable {\n             _ => panic!(\"expected Item\")\n         }\n     }\n+\n+    pub fn derive_allowed(&self) -> bool {\n+        match *self {\n+            Annotatable::Item(ref item) => match item.node {\n+                ast::ItemKind::Struct(..) |\n+                ast::ItemKind::Enum(..) |\n+                ast::ItemKind::Union(..) => true,\n+                _ => false,\n+            },\n+            _ => false,\n+        }\n+    }\n }\n \n // A more flexible ItemDecorator."}, {"sha": "11988a8f89d70a471512a01acf9393cf03ff27ce", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 91, "deletions": 79, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16", "patch": "@@ -136,8 +136,8 @@ expansions! {\n }\n \n impl ExpansionKind {\n-    fn dummy(self, span: Span) -> Expansion {\n-        self.make_from(DummyResult::any(span)).unwrap()\n+    fn dummy(self, span: Span) -> Option<Expansion> {\n+        self.make_from(DummyResult::any(span))\n     }\n \n     fn expect_from_annotatables<I: IntoIterator<Item = Annotatable>>(self, items: I) -> Expansion {\n@@ -304,21 +304,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             // FIXME(jseyfried): Refactor out the following logic\n             let (expansion, new_invocations) = if let Some(ext) = ext {\n                 if let Some(ext) = ext {\n-                    let expansion = self.expand_invoc(invoc, ext);\n+                    let dummy = invoc.expansion_kind.dummy(invoc.span()).unwrap();\n+                    let expansion = self.expand_invoc(invoc, ext).unwrap_or(dummy);\n                     self.collect_invocations(expansion, &[])\n                 } else if let InvocationKind::Attr { attr: None, traits, item } = invoc.kind {\n-                    let derive_allowed = match item {\n-                        Annotatable::Item(ref item) => match item.node {\n-                            ast::ItemKind::Struct(..) |\n-                            ast::ItemKind::Enum(..) |\n-                            ast::ItemKind::Union(..) => true,\n-                            _ => false,\n-                        },\n-                        _ => false,\n-                    };\n-                    if !derive_allowed {\n-                        let attr = item.attrs().iter()\n-                            .find(|attr| attr.check_name(\"derive\"))\n+                    if !item.derive_allowed() {\n+                        let attr = attr::find_by_name(item.attrs(), \"derive\")\n                             .expect(\"`derive` attribute should exist\");\n                         let span = attr.span;\n                         let mut err = self.cx.mut_span_err(span,\n@@ -366,7 +357,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     unreachable!()\n                 }\n             } else {\n-                self.collect_invocations(invoc.expansion_kind.dummy(invoc.span()), &[])\n+                self.collect_invocations(invoc.expansion_kind.dummy(invoc.span()).unwrap(), &[])\n             };\n \n             if expansions.len() < depth {\n@@ -446,11 +437,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n     }\n \n-    fn expand_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n+    fn expand_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Option<Expansion> {\n         let result = match invoc.kind {\n-            InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc, ext),\n-            InvocationKind::Attr { .. } => self.expand_attr_invoc(invoc, ext),\n-            InvocationKind::Derive { .. } => self.expand_derive_invoc(invoc, ext),\n+            InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc, ext)?,\n+            InvocationKind::Attr { .. } => self.expand_attr_invoc(invoc, ext)?,\n+            InvocationKind::Derive { .. } => self.expand_derive_invoc(invoc, ext)?,\n         };\n \n         if self.cx.current_expansion.depth > self.cx.ecfg.recursion_limit {\n@@ -467,13 +458,16 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             panic!(FatalError);\n         }\n \n-        result\n+        Some(result)\n     }\n \n-    fn expand_attr_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n+    fn expand_attr_invoc(&mut self,\n+                         invoc: Invocation,\n+                         ext: Rc<SyntaxExtension>)\n+                         -> Option<Expansion> {\n         let Invocation { expansion_kind: kind, .. } = invoc;\n         let (attr, item) = match invoc.kind {\n-            InvocationKind::Attr { attr, item, .. } => (attr.unwrap(), item),\n+            InvocationKind::Attr { attr, item, .. } => (attr?, item),\n             _ => unreachable!(),\n         };\n \n@@ -490,16 +484,16 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n         match *ext {\n             MultiModifier(ref mac) => {\n-                let meta = panictry!(attr.parse_meta(self.cx.parse_sess));\n+                let meta = attr.parse_meta(self.cx.parse_sess).ok()?;\n                 let item = mac.expand(self.cx, attr.span, &meta, item);\n-                kind.expect_from_annotatables(item)\n+                Some(kind.expect_from_annotatables(item))\n             }\n             MultiDecorator(ref mac) => {\n                 let mut items = Vec::new();\n-                let meta = panictry!(attr.parse_meta(self.cx.parse_sess));\n+                let meta = attr.parse_meta(self.cx.parse_sess).ok()?;\n                 mac.expand(self.cx, attr.span, &meta, &item, &mut |item| items.push(item));\n                 items.push(item);\n-                kind.expect_from_annotatables(items)\n+                Some(kind.expect_from_annotatables(items))\n             }\n             AttrProcMacro(ref mac) => {\n                 let item_tok = TokenTree::Token(DUMMY_SP, Token::interpolated(match item {\n@@ -525,7 +519,10 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     }\n \n     /// Expand a macro invocation. Returns the result of expansion.\n-    fn expand_bang_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n+    fn expand_bang_invoc(&mut self,\n+                         invoc: Invocation,\n+                         ext: Rc<SyntaxExtension>)\n+                         -> Option<Expansion> {\n         let (mark, kind) = (invoc.expansion_data.mark, invoc.expansion_kind);\n         let (mac, ident, span) = match invoc.kind {\n             InvocationKind::Bang { mac, ident, span } => (mac, ident, span),\n@@ -558,9 +555,10 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                                                              false, false) {\n                     self.cx.span_err(path.span, &msg);\n                     self.cx.trace_macros_diag();\n-                    return kind.dummy(span);\n+                    kind.dummy(span)\n+                } else {\n+                    kind.make_from(expand.expand(self.cx, span, mac.node.stream()))\n                 }\n-                kind.make_from(expand.expand(self.cx, span, mac.node.stream()))\n             }\n \n             NormalTT {\n@@ -574,44 +572,45 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                                                              allow_internal_unsafe) {\n                     self.cx.span_err(path.span, &msg);\n                     self.cx.trace_macros_diag();\n-                    return kind.dummy(span);\n+                    kind.dummy(span)\n+                } else {\n+                    kind.make_from(expander.expand(self.cx, span, mac.node.stream()))\n                 }\n-                kind.make_from(expander.expand(self.cx, span, mac.node.stream()))\n             }\n \n             IdentTT(ref expander, tt_span, allow_internal_unstable) => {\n                 if ident.name == keywords::Invalid.name() {\n                     self.cx.span_err(path.span,\n                                     &format!(\"macro {}! expects an ident argument\", path));\n                     self.cx.trace_macros_diag();\n-                    return kind.dummy(span);\n-                };\n-\n-                invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n-                    call_site: span,\n-                    callee: NameAndSpan {\n-                        format: macro_bang_format(path),\n-                        span: tt_span,\n-                        allow_internal_unstable,\n-                        allow_internal_unsafe: false,\n-                    }\n-                });\n+                    kind.dummy(span)\n+                } else {\n+                    invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n+                        call_site: span,\n+                        callee: NameAndSpan {\n+                            format: macro_bang_format(path),\n+                            span: tt_span,\n+                            allow_internal_unstable,\n+                            allow_internal_unsafe: false,\n+                        }\n+                    });\n \n-                let input: Vec<_> = mac.node.stream().into_trees().collect();\n-                kind.make_from(expander.expand(self.cx, span, ident, input))\n+                    let input: Vec<_> = mac.node.stream().into_trees().collect();\n+                    kind.make_from(expander.expand(self.cx, span, ident, input))\n+                }\n             }\n \n             MultiDecorator(..) | MultiModifier(..) | AttrProcMacro(..) => {\n                 self.cx.span_err(path.span,\n                                  &format!(\"`{}` can only be used in attributes\", path));\n                 self.cx.trace_macros_diag();\n-                return kind.dummy(span);\n+                kind.dummy(span)\n             }\n \n             ProcMacroDerive(..) | BuiltinDerive(..) => {\n                 self.cx.span_err(path.span, &format!(\"`{}` is a derive mode\", path));\n                 self.cx.trace_macros_diag();\n-                return kind.dummy(span);\n+                kind.dummy(span)\n             }\n \n             ProcMacro(ref expandfun) => {\n@@ -620,43 +619,51 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         format!(\"macro {}! expects no ident argument, given '{}'\", path, ident);\n                     self.cx.span_err(path.span, &msg);\n                     self.cx.trace_macros_diag();\n-                    return kind.dummy(span);\n-                }\n+                    kind.dummy(span)\n+                } else {\n+                    invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n+                        call_site: span,\n+                        callee: NameAndSpan {\n+                            format: macro_bang_format(path),\n+                            // FIXME procedural macros do not have proper span info\n+                            // yet, when they do, we should use it here.\n+                            span: None,\n+                            // FIXME probably want to follow macro_rules macros here.\n+                            allow_internal_unstable: false,\n+                            allow_internal_unsafe: false,\n+                        },\n+                    });\n \n-                invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n-                    call_site: span,\n-                    callee: NameAndSpan {\n-                        format: macro_bang_format(path),\n-                        // FIXME procedural macros do not have proper span info\n-                        // yet, when they do, we should use it here.\n-                        span: None,\n-                        // FIXME probably want to follow macro_rules macros here.\n-                        allow_internal_unstable: false,\n-                        allow_internal_unsafe: false,\n-                    },\n-                });\n-\n-                let tok_result = expandfun.expand(self.cx, span, mac.node.stream());\n-                Some(self.parse_expansion(tok_result, kind, path, span))\n+                    let tok_result = expandfun.expand(self.cx, span, mac.node.stream());\n+                    self.parse_expansion(tok_result, kind, path, span)\n+                }\n             }\n         };\n \n-        unwrap_or!(opt_expanded, {\n+        if opt_expanded.is_some() {\n+            opt_expanded\n+        } else {\n             let msg = format!(\"non-{kind} macro in {kind} position: {name}\",\n                               name = path.segments[0].identifier.name, kind = kind.name());\n             self.cx.span_err(path.span, &msg);\n             self.cx.trace_macros_diag();\n             kind.dummy(span)\n-        })\n+        }\n     }\n \n     /// Expand a derive invocation. Returns the result of expansion.\n-    fn expand_derive_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n+    fn expand_derive_invoc(&mut self,\n+                           invoc: Invocation,\n+                           ext: Rc<SyntaxExtension>)\n+                           -> Option<Expansion> {\n         let Invocation { expansion_kind: kind, .. } = invoc;\n         let (path, item) = match invoc.kind {\n             InvocationKind::Derive { path, item } => (path, item),\n             _ => unreachable!(),\n         };\n+        if !item.derive_allowed() {\n+            return None;\n+        }\n \n         let pretty_name = Symbol::intern(&format!(\"derive({})\", path));\n         let span = path.span;\n@@ -686,15 +693,15 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     span: DUMMY_SP,\n                     node: ast::MetaItemKind::Word,\n                 };\n-                kind.expect_from_annotatables(ext.expand(self.cx, span, &dummy, item))\n+                Some(kind.expect_from_annotatables(ext.expand(self.cx, span, &dummy, item)))\n             }\n             BuiltinDerive(func) => {\n                 expn_info.callee.allow_internal_unstable = true;\n                 invoc.expansion_data.mark.set_expn_info(expn_info);\n                 let span = span.with_ctxt(self.cx.backtrace());\n                 let mut items = Vec::new();\n-                func(self.cx, span, &attr.meta().unwrap(), &item, &mut |a| items.push(a));\n-                kind.expect_from_annotatables(items)\n+                func(self.cx, span, &attr.meta()?, &item, &mut |a| items.push(a));\n+                Some(kind.expect_from_annotatables(items))\n             }\n             _ => {\n                 let msg = &format!(\"macro `{}` may not be used for derive attributes\", attr.path);\n@@ -705,19 +712,24 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n     }\n \n-    fn parse_expansion(&mut self, toks: TokenStream, kind: ExpansionKind, path: &Path, span: Span)\n-                       -> Expansion {\n+    fn parse_expansion(&mut self,\n+                       toks: TokenStream,\n+                       kind: ExpansionKind,\n+                       path: &Path,\n+                       span: Span)\n+                       -> Option<Expansion> {\n         let mut parser = self.cx.new_parser_from_tts(&toks.into_trees().collect::<Vec<_>>());\n-        let expansion = match parser.parse_expansion(kind, false) {\n-            Ok(expansion) => expansion,\n+        match parser.parse_expansion(kind, false) {\n+            Ok(expansion) => {\n+                parser.ensure_complete_parse(path, kind.name(), span);\n+                Some(expansion)\n+            }\n             Err(mut err) => {\n                 err.emit();\n                 self.cx.trace_macros_diag();\n-                return kind.dummy(span);\n+                kind.dummy(span)\n             }\n-        };\n-        parser.ensure_complete_parse(path, kind.name(), span);\n-        expansion\n+        }\n     }\n }\n "}, {"sha": "eff7dd57f08af0086dc0a2aaee00a3a659b34084", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16", "patch": "@@ -386,15 +386,15 @@ fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n }\n \n fn is_ignored(i: &ast::Item) -> bool {\n-    i.attrs.iter().any(|attr| attr.check_name(\"ignore\"))\n+    attr::contains_name(&i.attrs, \"ignore\")\n }\n \n fn is_allowed_fail(i: &ast::Item) -> bool {\n-    i.attrs.iter().any(|attr| attr.check_name(\"allow_fail\"))\n+    attr::contains_name(&i.attrs, \"allow_fail\")\n }\n \n fn should_panic(i: &ast::Item, cx: &TestCtxt) -> ShouldPanic {\n-    match i.attrs.iter().find(|attr| attr.check_name(\"should_panic\")) {\n+    match attr::find_by_name(&i.attrs, \"should_panic\") {\n         Some(attr) => {\n             let sd = cx.span_diagnostic;\n             if attr.is_value_str() {"}, {"sha": "8c5276e1d74b532121a1d2cc260102a0aa2d0988", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16", "patch": "@@ -13,6 +13,7 @@ use std::mem;\n use errors;\n \n use syntax::ast::{self, Ident, NodeId};\n+use syntax::attr;\n use syntax::codemap::{ExpnInfo, NameAndSpan, MacroAttribute};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n@@ -248,8 +249,7 @@ impl<'a> CollectProcMacros<'a> {\n impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n     fn visit_item(&mut self, item: &'a ast::Item) {\n         if let ast::ItemKind::MacroDef(..) = item.node {\n-            if self.is_proc_macro_crate &&\n-               item.attrs.iter().any(|attr| attr.path == \"macro_export\") {\n+            if self.is_proc_macro_crate && attr::contains_name(&item.attrs, \"macro_export\") {\n                 let msg =\n                     \"cannot export macro_rules! macros from a `proc-macro` crate type currently\";\n                 self.handler.span_err(item.span, msg);"}, {"sha": "9ff1c14f54c6e114e85a9082aa812302d11ec948", "filename": "src/test/compile-fail/derive-on-trait-item-or-impl-item.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Ftest%2Fcompile-fail%2Fderive-on-trait-item-or-impl-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Ftest%2Fcompile-fail%2Fderive-on-trait-item-or-impl-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderive-on-trait-item-or-impl-item.rs?ref=5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {\n+    #[derive(Clone)]\n+    //~^ ERROR `derive` may only be applied to structs, enums and unions\n+    type Bar;\n+}\n+\n+impl Bar {\n+    #[derive(Clone)]\n+    //~^ ERROR `derive` may only be applied to structs, enums and unions\n+    fn bar(&self) {}\n+}\n+\n+fn main() {}"}, {"sha": "0f90cb3752cf5a9043f601b9566bac508ab4c557", "filename": "src/test/run-pass-fulldeps/auxiliary/custom_derive_plugin_attr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin_attr.rs?ref=5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16", "patch": "@@ -21,6 +21,7 @@ extern crate rustc;\n extern crate rustc_plugin;\n \n use syntax::ast;\n+use syntax::attr;\n use syntax::ext::base::{MultiDecorator, ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n use syntax::symbol::Symbol;\n@@ -80,7 +81,7 @@ fn totalsum_substructure(cx: &mut ExtCtxt, trait_span: Span,\n     };\n \n     fields.iter().fold(cx.expr_isize(trait_span, 0), |acc, ref item| {\n-        if item.attrs.iter().find(|a| a.check_name(\"ignore\")).is_some() {\n+        if attr::contains_name(&item.attrs, \"ignore\") {\n             acc\n         } else {\n             cx.expr_binary(item.span, ast::BinOpKind::Add, acc,"}, {"sha": "0433b11f7c1271aaf5a6e66b707223762060d601", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/issue-40001-plugin.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-40001-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-40001-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-40001-plugin.rs?ref=5f7aeaf6e2b90e247a2d194d7bc0b642b287fc16", "patch": "@@ -17,6 +17,7 @@ extern crate rustc_plugin;\n extern crate syntax;\n \n use rustc_plugin::Registry;\n+use syntax::attr;\n use syntax::ext::base::*;\n use syntax::feature_gate::AttributeType::Whitelisted;\n use syntax::symbol::Symbol;\n@@ -59,9 +60,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingWhitelistedAttrPass {\n             _ => cx.tcx.hir.expect_item(cx.tcx.hir.get_parent(id)),\n         };\n \n-        if !item.attrs.iter().any(|a| a.check_name(\"whitelisted_attr\")) {\n+        if !attr::contains_name(&item.attrs, \"whitelisted_attr\") {\n             cx.span_lint(MISSING_WHITELISTED_ATTR, span,\n-                         \"Missing 'whitelited_attr' attribute\");\n+                         \"Missing 'whitelisted_attr' attribute\");\n         }\n     }\n }"}]}