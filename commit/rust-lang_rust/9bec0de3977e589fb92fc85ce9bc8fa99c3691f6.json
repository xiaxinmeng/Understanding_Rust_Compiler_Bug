{"sha": "9bec0de3977e589fb92fc85ce9bc8fa99c3691f6", "node_id": "C_kwDOAAsO6NoAKDliZWMwZGUzOTc3ZTU4OWZiOTJmYzg1Y2U5YmM4ZmE5OWMzNjkxZjY", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-08-08T14:17:08Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-09-27T11:13:08Z"}, "message": "Rewrite and refactor format_args!() builtin macro.", "tree": {"sha": "ba52134752254b6fed558b11f15794a04f5242b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba52134752254b6fed558b11f15794a04f5242b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bec0de3977e589fb92fc85ce9bc8fa99c3691f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bec0de3977e589fb92fc85ce9bc8fa99c3691f6", "html_url": "https://github.com/rust-lang/rust/commit/9bec0de3977e589fb92fc85ce9bc8fa99c3691f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bec0de3977e589fb92fc85ce9bc8fa99c3691f6/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9297d22ad9edc2b56f0dd8734c1187a0c88be69", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9297d22ad9edc2b56f0dd8734c1187a0c88be69", "html_url": "https://github.com/rust-lang/rust/commit/d9297d22ad9edc2b56f0dd8734c1187a0c88be69"}], "stats": {"total": 2463, "additions": 1168, "deletions": 1295}, "files": [{"sha": "06a831e36692e4dfbe3181ba8ffb329b5e1caed0", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 792, "deletions": 1287, "changes": 2079, "blob_url": "https://github.com/rust-lang/rust/blob/9bec0de3977e589fb92fc85ce9bc8fa99c3691f6/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bec0de3977e589fb92fc85ce9bc8fa99c3691f6/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=9bec0de3977e589fb92fc85ce9bc8fa99c3691f6", "patch": "@@ -1,271 +1,192 @@\n-use ArgumentType::*;\n-use Position::*;\n-\n use rustc_ast as ast;\n use rustc_ast::ptr::P;\n+use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n-use rustc_ast::visit::{self, Visitor};\n-use rustc_ast::{token, BlockCheckMode, UnsafeSource};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, Applicability, MultiSpan, PResult};\n use rustc_expand::base::{self, *};\n use rustc_parse_format as parse;\n-use rustc_span::symbol::{sym, Ident, Symbol};\n+use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::{BytePos, InnerSpan, Span};\n-use smallvec::SmallVec;\n \n use rustc_lint_defs::builtin::NAMED_ARGUMENTS_USED_POSITIONALLY;\n use rustc_lint_defs::{BufferedEarlyLint, BuiltinLintDiagnostics, LintId};\n-use rustc_parse_format::Count;\n-use std::borrow::Cow;\n-use std::collections::hash_map::Entry;\n-\n-#[derive(PartialEq)]\n-enum ArgumentType {\n-    Placeholder(&'static str),\n-    Count,\n-}\n \n-enum Position {\n-    Exact(usize),\n-    Capture(usize),\n-    Named(Symbol, InnerSpan),\n+mod expand;\n+use expand::expand_parsed_format_args;\n+\n+// The format_args!() macro is expanded in three steps:\n+//  1. First, `parse_args` will parse the `(literal, arg, arg, name=arg, name=arg)` syntax,\n+//     but doesn't parse the template (the literal) itself.\n+//  2. Second, `make_format_args` will parse the template, the format options, resolve argument references,\n+//     produce diagnostics, and turn the whole thing into a `FormatArgs` structure.\n+//  3. Finally, `expand_parsed_format_args` will turn that `FormatArgs` structure\n+//     into the expression that the macro expands to.\n+\n+// Definitions:\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+//                     FormatArgs\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+//                                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+//                                      argument\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+//              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+//                     template\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+//               \u2514\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2518\n+//                      pieces\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+//               \u2514\u2500\u2500\u2500\u2500\u2518           \u2514\u2518\n+//                   literal pieces\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+//                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+//                     placeholder\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+//                      \u2514\u2500\u2518  \u2514\u2500\u2518\n+//                      positions (could be names, numbers, empty, or `*`)\n+\n+/// (Parsed) format args.\n+///\n+/// Basically the \"AST\" for a complete `format_args!()`.\n+///\n+/// E.g., `format_args!(\"hello {name}\");`.\n+#[derive(Clone, Debug)]\n+pub struct FormatArgs {\n+    pub span: Span,\n+    pub template: Vec<FormatArgsPiece>,\n+    pub arguments: Vec<(P<ast::Expr>, FormatArgKind)>,\n }\n \n-/// Indicates how positional named argument (i.e. an named argument which is used by position\n-/// instead of by name) is used in format string\n-/// * `Arg` is the actual argument to print\n-/// * `Width` is width format argument\n-/// * `Precision` is precion format argument\n-/// Example: `{Arg:Width$.Precision$}\n-#[derive(Debug, Eq, PartialEq)]\n-enum PositionalNamedArgType {\n-    Arg,\n-    Width,\n-    Precision,\n+#[derive(Clone, Debug)]\n+pub enum FormatArgsPiece {\n+    Literal(Symbol),\n+    Placeholder(FormatPlaceholder),\n }\n \n-/// Contains information necessary to create a lint for a positional named argument\n-#[derive(Debug)]\n-struct PositionalNamedArg {\n-    ty: PositionalNamedArgType,\n-    /// The piece of the using this argument (multiple pieces can use the same argument)\n-    cur_piece: usize,\n-    /// The InnerSpan for in the string to be replaced with the named argument\n-    /// This will be None when the position is implicit\n-    inner_span_to_replace: Option<rustc_parse_format::InnerSpan>,\n-    /// The name to use instead of the position\n-    replacement: Symbol,\n-    /// The span for the positional named argument (so the lint can point a message to it)\n-    positional_named_arg_span: Span,\n-    has_formatting: bool,\n+#[derive(Clone, Debug)]\n+pub enum FormatArgKind {\n+    /// `format_args(\u2026, arg)`\n+    Normal,\n+    /// `format_args(\u2026, arg = 1)`\n+    Named(Ident),\n+    /// `format_args(\"\u2026 {arg} \u2026\")`\n+    Captured(Ident),\n }\n \n-impl PositionalNamedArg {\n-    /// Determines:\n-    /// 1) span to be replaced with the name of the named argument and\n-    /// 2) span to be underlined for error messages\n-    fn get_positional_arg_spans(&self, cx: &Context<'_, '_>) -> (Option<Span>, Option<Span>) {\n-        if let Some(inner_span) = &self.inner_span_to_replace {\n-            let span =\n-                cx.fmtsp.from_inner(InnerSpan { start: inner_span.start, end: inner_span.end });\n-            (Some(span), Some(span))\n-        } else if self.ty == PositionalNamedArgType::Arg {\n-            // In the case of a named argument whose position is implicit, if the argument *has*\n-            // formatting, there will not be a span to replace. Instead, we insert the name after\n-            // the `{`, which will be the first character of arg_span. If the argument does *not*\n-            // have formatting, there may or may not be a span to replace. This is because\n-            // whitespace is allowed in arguments without formatting (such as `format!(\"{  }\", 1);`)\n-            // but is not allowed in arguments with formatting (an error will be generated in cases\n-            // like `format!(\"{ :1.1}\", 1.0f32);`.\n-            // For the message span, if there is formatting, we want to use the opening `{` and the\n-            // next character, which will the `:` indicating the start of formatting. If there is\n-            // not any formatting, we want to underline the entire span.\n-            cx.arg_spans.get(self.cur_piece).map_or((None, None), |arg_span| {\n-                if self.has_formatting {\n-                    (\n-                        Some(arg_span.with_lo(arg_span.lo() + BytePos(1)).shrink_to_lo()),\n-                        Some(arg_span.with_hi(arg_span.lo() + BytePos(2))),\n-                    )\n-                } else {\n-                    let replace_start = arg_span.lo() + BytePos(1);\n-                    let replace_end = arg_span.hi() - BytePos(1);\n-                    let to_replace = arg_span.with_lo(replace_start).with_hi(replace_end);\n-                    (Some(to_replace), Some(*arg_span))\n-                }\n-            })\n-        } else {\n-            (None, None)\n+impl FormatArgKind {\n+    pub fn ident(&self) -> Option<Ident> {\n+        match self {\n+            &Self::Normal => None,\n+            &Self::Named(id) => Some(id),\n+            &Self::Captured(id) => Some(id),\n         }\n     }\n }\n \n-/// Encapsulates all the named arguments that have been used positionally\n-#[derive(Debug)]\n-struct PositionalNamedArgsLint {\n-    positional_named_args: Vec<PositionalNamedArg>,\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct FormatPlaceholder {\n+    /// Index into [`FormatArgs::arguments`].\n+    pub argument: FormatArgPosition,\n+    /// The span inside the format string for the full `{\u2026}` placeholder.\n+    pub span: Option<Span>,\n+    /// `{}`, `{:?}`, or `{:x}`, etc.\n+    pub format_trait: FormatTrait,\n+    /// `{}` or `{:.5}` or `{:-^20}`, etc.\n+    pub format_options: FormatOptions,\n }\n \n-impl PositionalNamedArgsLint {\n-    /// For a given positional argument, check if the index is for a named argument.\n-    ///\n-    /// Since positional arguments are required to come before named arguments, if the positional\n-    /// index is greater than or equal to the start of named arguments, we know it's a named\n-    /// argument used positionally.\n-    ///\n-    /// Example:\n-    /// println!(\"{} {} {2}\", 0, a=1, b=2);\n-    ///\n-    /// In this case, the first piece (`{}`) would be ArgumentImplicitlyIs with an index of 0. The\n-    /// total number of arguments is 3 and the number of named arguments is 2, so the start of named\n-    /// arguments is index 1. Therefore, the index of 0 is okay.\n-    ///\n-    /// The second piece (`{}`) would be ArgumentImplicitlyIs with an index of 1, which is the start\n-    /// of named arguments, and so we should add a lint to use the named argument `a`.\n-    ///\n-    /// The third piece (`{2}`) would be ArgumentIs with an index of 2, which is greater than the\n-    /// start of named arguments, and so we should add a lint to use the named argument `b`.\n-    ///\n-    /// This same check also works for width and precision formatting when either or both are\n-    /// CountIsParam, which contains an index into the arguments.\n-    fn maybe_add_positional_named_arg(\n-        &mut self,\n-        arg: Option<&FormatArg>,\n-        ty: PositionalNamedArgType,\n-        cur_piece: usize,\n-        inner_span_to_replace: Option<rustc_parse_format::InnerSpan>,\n-        has_formatting: bool,\n-    ) {\n-        if let Some(arg) = arg {\n-            if let Some(name) = arg.name {\n-                self.push(name, ty, cur_piece, inner_span_to_replace, has_formatting)\n-            }\n-        }\n-    }\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct FormatArgPosition {\n+    /// Which argument this position refers to (Ok),\n+    /// or would've referred to if it existed (Err).\n+    pub index: Result<usize, usize>,\n+    /// What kind of position this is. See [`FormatArgsPositionKind`].\n+    pub kind: FormatArgPositionKind,\n+    /// The span of the name or number.\n+    pub span: Option<Span>,\n+}\n \n-    /// Construct a PositionalNamedArg struct and push it into the vec of positional\n-    /// named arguments.\n-    fn push(\n-        &mut self,\n-        arg_name: Ident,\n-        ty: PositionalNamedArgType,\n-        cur_piece: usize,\n-        inner_span_to_replace: Option<rustc_parse_format::InnerSpan>,\n-        has_formatting: bool,\n-    ) {\n-        // In FormatSpec, `precision_span` starts at the leading `.`, which we want to keep in\n-        // the lint suggestion, so increment `start` by 1 when `PositionalArgumentType` is\n-        // `Precision`.\n-        let inner_span_to_replace = if ty == PositionalNamedArgType::Precision {\n-            inner_span_to_replace\n-                .map(|is| rustc_parse_format::InnerSpan { start: is.start + 1, end: is.end })\n-        } else {\n-            inner_span_to_replace\n-        };\n-        self.positional_named_args.push(PositionalNamedArg {\n-            ty,\n-            cur_piece,\n-            inner_span_to_replace,\n-            replacement: arg_name.name,\n-            positional_named_arg_span: arg_name.span,\n-            has_formatting,\n-        });\n-    }\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum FormatArgPositionKind {\n+    /// `{}` or `{.*}`\n+    Implicit,\n+    /// `{1}` or `{:1$}` or `{:.1$}`\n+    Number,\n+    /// `{a}` or `{:a$}` or `{:.a$}`\n+    Named,\n+}\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub enum FormatTrait {\n+    /// `{}`\n+    Display,\n+    /// `{:?}`\n+    Debug,\n+    /// `{:e}`\n+    LowerExp,\n+    /// `{:E}`\n+    UpperExp,\n+    /// `{:o}`\n+    Octal,\n+    /// `{:p}`\n+    Pointer,\n+    /// `{:b}`\n+    Binary,\n+    /// `{:x}`\n+    LowerHex,\n+    /// `{:X}`\n+    UpperHex,\n+}\n+\n+#[derive(Clone, Debug, Default, PartialEq, Eq)]\n+pub struct FormatOptions {\n+    /// The width. E.g. `{:5}` or `{:width$}`.\n+    pub width: Option<FormatCount>,\n+    /// The precision. E.g. `{:.5}` or `{:.precision$}`.\n+    pub precision: Option<FormatCount>,\n+    /// The alignment. E.g. `{:>}` or `{:<}` or `{:^}`.\n+    pub alignment: Option<FormatAlignment>,\n+    /// The fill character. E.g. the `.` in `{:.>10}`.\n+    pub fill: Option<char>,\n+    /// The `+`, `-`, `0`, `#`, `x?` and `X?` flags.\n+    pub flags: u32,\n }\n \n-struct Context<'a, 'b> {\n-    ecx: &'a mut ExtCtxt<'b>,\n-    /// The macro's call site. References to unstable formatting internals must\n-    /// use this span to pass the stability checker.\n-    macsp: Span,\n-    /// The span of the format string literal.\n-    fmtsp: Span,\n-\n-    /// List of parsed argument expressions.\n-    /// Named expressions are resolved early, and are appended to the end of\n-    /// argument expressions.\n-    ///\n-    /// Example showing the various data structures in motion:\n-    ///\n-    /// * Original: `\"{foo:o} {:o} {foo:x} {0:x} {1:o} {:x} {1:x} {0:o}\"`\n-    /// * Implicit argument resolution: `\"{foo:o} {0:o} {foo:x} {0:x} {1:o} {1:x} {1:x} {0:o}\"`\n-    /// * Name resolution: `\"{2:o} {0:o} {2:x} {0:x} {1:o} {1:x} {1:x} {0:o}\"`\n-    /// * `arg_types` (in JSON): `[[0, 1, 0], [0, 1, 1], [0, 1]]`\n-    /// * `arg_unique_types` (in simplified JSON): `[[\"o\", \"x\"], [\"o\", \"x\"], [\"o\", \"x\"]]`\n-    /// * `names` (in JSON): `{\"foo\": 2}`\n-    args: Vec<FormatArg>,\n-    /// The number of arguments that were added by implicit capturing.\n-    num_captured_args: usize,\n-    /// Placeholder slot numbers indexed by argument.\n-    arg_types: Vec<Vec<usize>>,\n-    /// Unique format specs seen for each argument.\n-    arg_unique_types: Vec<Vec<ArgumentType>>,\n-    /// Map from named arguments to their resolved indices.\n-    names: FxHashMap<Symbol, usize>,\n-\n-    /// The latest consecutive literal strings, or empty if there weren't any.\n-    literal: String,\n-\n-    /// Collection of the compiled `rt::Argument` structures\n-    pieces: Vec<P<ast::Expr>>,\n-    /// Collection of string literals\n-    str_pieces: Vec<P<ast::Expr>>,\n-    /// Stays `true` if all formatting parameters are default (as in \"{}{}\").\n-    all_pieces_simple: bool,\n-\n-    /// Mapping between positional argument references and indices into the\n-    /// final generated static argument array. We record the starting indices\n-    /// corresponding to each positional argument, and number of references\n-    /// consumed so far for each argument, to facilitate correct `Position`\n-    /// mapping in `build_piece`. In effect this can be seen as a \"flattened\"\n-    /// version of `arg_unique_types`.\n-    ///\n-    /// Again with the example described above in docstring for `args`:\n-    ///\n-    /// * `arg_index_map` (in JSON): `[[0, 1, 0], [2, 3, 3], [4, 5]]`\n-    arg_index_map: Vec<Vec<usize>>,\n-\n-    /// Starting offset of count argument slots.\n-    count_args_index_offset: usize,\n-\n-    /// Count argument slots and tracking data structures.\n-    /// Count arguments are separately tracked for de-duplication in case\n-    /// multiple references are made to one argument. For example, in this\n-    /// format string:\n-    ///\n-    /// * Original: `\"{:.*} {:.foo$} {1:.*} {:.0$}\"`\n-    /// * Implicit argument resolution: `\"{1:.0$} {2:.foo$} {1:.3$} {4:.0$}\"`\n-    /// * Name resolution: `\"{1:.0$} {2:.5$} {1:.3$} {4:.0$}\"`\n-    /// * `count_positions` (in JSON): `{0: 0, 5: 1, 3: 2}`\n-    /// * `count_args`: `vec![0, 5, 3]`\n-    count_args: Vec<usize>,\n-    /// Relative slot numbers for count arguments.\n-    count_positions: FxHashMap<usize, usize>,\n-    /// Number of count slots assigned.\n-    count_positions_count: usize,\n-\n-    /// Current position of the implicit positional arg pointer, as if it\n-    /// still existed in this phase of processing.\n-    /// Used only for `all_pieces_simple` tracking in `build_piece`.\n-    curarg: usize,\n-    /// Current piece being evaluated, used for error reporting.\n-    curpiece: usize,\n-    /// Keep track of invalid references to positional arguments.\n-    invalid_refs: Vec<(usize, usize)>,\n-    /// Spans of all the formatting arguments, in order.\n-    arg_spans: Vec<Span>,\n-    /// All the formatting arguments that have formatting flags set, in order for diagnostics.\n-    arg_with_formatting: Vec<parse::FormatSpec<'a>>,\n-\n-    /// Whether this format string came from a string literal, as opposed to a macro.\n-    is_literal: bool,\n-    unused_names_lint: PositionalNamedArgsLint,\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum FormatAlignment {\n+    /// `{:<}`\n+    Left,\n+    /// `{:>}`\n+    Right,\n+    /// `{:^}`\n+    Center,\n }\n \n-pub struct FormatArg {\n-    expr: P<ast::Expr>,\n-    name: Option<Ident>,\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum FormatCount {\n+    /// `{:0}` or `{:.0}`\n+    Literal(usize),\n+    /// `{:.*}`, `{:.0$}`, or `{:a$}`, etc.\n+    Argument(FormatArgPosition),\n+}\n+\n+// Only used in parse_args and report_invalid_references,\n+// to indicate how a referred argument was used.\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+enum PositionUsedAs {\n+    Placeholder(Option<Span>),\n+    Precision,\n+    Width,\n }\n+use PositionUsedAs::*;\n \n /// Parses the arguments from the given list of tokens, returning the diagnostic\n /// if there's a parse error so we can continue parsing other format!\n@@ -274,15 +195,14 @@ pub struct FormatArg {\n /// If parsing succeeds, the return value is:\n ///\n /// ```text\n-/// Some((fmtstr, parsed arguments, index map for named arguments))\n+/// Some((fmtstr, parsed arguments))\n /// ```\n fn parse_args<'a>(\n     ecx: &mut ExtCtxt<'a>,\n     sp: Span,\n     tts: TokenStream,\n-) -> PResult<'a, (P<ast::Expr>, Vec<FormatArg>, FxHashMap<Symbol, usize>)> {\n-    let mut args = Vec::<FormatArg>::new();\n-    let mut names = FxHashMap::<Symbol, usize>::default();\n+) -> PResult<'a, (P<ast::Expr>, Vec<(P<ast::Expr>, FormatArgKind)>)> {\n+    let mut args = Vec::<(P<ast::Expr>, FormatArgKind)>::new();\n \n     let mut p = ecx.new_parser_from_tts(tts);\n \n@@ -347,21 +267,19 @@ fn parse_args<'a>(\n                 p.bump();\n                 p.expect(&token::Eq)?;\n                 let e = p.parse_expr()?;\n-                if let Some(&prev) = names.get(&ident.name) {\n-                    ecx.struct_span_err(e.span, &format!(\"duplicate argument named `{}`\", ident))\n-                        .span_label(args[prev].expr.span, \"previously here\")\n-                        .span_label(e.span, \"duplicate argument\")\n-                        .emit();\n+                if let Some(prev) =\n+                    args.iter().rev().map_while(|a| a.1.ident()).find(|n| n.name == ident.name)\n+                {\n+                    ecx.struct_span_err(\n+                        ident.span,\n+                        &format!(\"duplicate argument named `{}`\", ident),\n+                    )\n+                    .span_label(prev.span, \"previously here\")\n+                    .span_label(ident.span, \"duplicate argument\")\n+                    .emit();\n                     continue;\n                 }\n-\n-                // Resolve names into slots early.\n-                // Since all the positional args are already seen at this point\n-                // if the input is valid, we can simply append to the positional\n-                // args. And remember the names.\n-                let slot = args.len();\n-                names.insert(ident.name, slot);\n-                args.push(FormatArg { expr: e, name: Some(ident) });\n+                args.push((e, FormatArgKind::Named(ident)));\n             }\n             _ => {\n                 let e = p.parse_expr()?;\n@@ -371,851 +289,31 @@ fn parse_args<'a>(\n                         \"positional arguments cannot follow named arguments\",\n                     );\n                     err.span_label(e.span, \"positional arguments must be before named arguments\");\n-                    for &pos in names.values() {\n-                        err.span_label(args[pos].expr.span, \"named argument\");\n+                    for arg in &args {\n+                        if let Some(name) = arg.1.ident() {\n+                            err.span_label(name.span.to(arg.0.span), \"named argument\");\n+                        }\n                     }\n                     err.emit();\n                 }\n-                args.push(FormatArg { expr: e, name: None });\n+                args.push((e, FormatArgKind::Normal));\n             }\n         }\n     }\n-    Ok((fmtstr, args, names))\n+    Ok((fmtstr, args))\n }\n \n-impl<'a, 'b> Context<'a, 'b> {\n-    /// The number of arguments that were explicitly given.\n-    fn num_args(&self) -> usize {\n-        self.args.len() - self.num_captured_args\n-    }\n-\n-    fn resolve_name_inplace(&mut self, p: &mut parse::Piece<'_>) {\n-        // NOTE: the `unwrap_or` branch is needed in case of invalid format\n-        // arguments, e.g., `format_args!(\"{foo}\")`.\n-        let lookup = |s: &str| self.names.get(&Symbol::intern(s)).copied().unwrap_or(0);\n-\n-        match *p {\n-            parse::String(_) => {}\n-            parse::NextArgument(ref mut arg) => {\n-                if let parse::ArgumentNamed(s) = arg.position {\n-                    arg.position = parse::ArgumentIs(lookup(s));\n-                }\n-                if let parse::CountIsName(s, _) = arg.format.width {\n-                    arg.format.width = parse::CountIsParam(lookup(s));\n-                }\n-                if let parse::CountIsName(s, _) = arg.format.precision {\n-                    arg.format.precision = parse::CountIsParam(lookup(s));\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Verifies one piece of a parse string, and remembers it if valid.\n-    /// All errors are not emitted as fatal so we can continue giving errors\n-    /// about this and possibly other format strings.\n-    fn verify_piece(&mut self, p: &parse::Piece<'a>) {\n-        match *p {\n-            parse::String(..) => {}\n-            parse::NextArgument(ref arg) => {\n-                // width/precision first, if they have implicit positional\n-                // parameters it makes more sense to consume them first.\n-                self.verify_count(\n-                    arg.format.width,\n-                    &arg.format.width_span,\n-                    PositionalNamedArgType::Width,\n-                );\n-                self.verify_count(\n-                    arg.format.precision,\n-                    &arg.format.precision_span,\n-                    PositionalNamedArgType::Precision,\n-                );\n-\n-                let has_precision = arg.format.precision != Count::CountImplied;\n-                let has_width = arg.format.width != Count::CountImplied;\n-\n-                if has_precision || has_width {\n-                    // push before named params are resolved to aid diagnostics\n-                    self.arg_with_formatting.push(arg.format);\n-                }\n-\n-                // argument second, if it's an implicit positional parameter\n-                // it's written second, so it should come after width/precision.\n-                let pos = match arg.position {\n-                    parse::ArgumentIs(i) => {\n-                        self.unused_names_lint.maybe_add_positional_named_arg(\n-                            self.args.get(i),\n-                            PositionalNamedArgType::Arg,\n-                            self.curpiece,\n-                            Some(arg.position_span),\n-                            has_precision || has_width,\n-                        );\n-\n-                        Exact(i)\n-                    }\n-                    parse::ArgumentImplicitlyIs(i) => {\n-                        self.unused_names_lint.maybe_add_positional_named_arg(\n-                            self.args.get(i),\n-                            PositionalNamedArgType::Arg,\n-                            self.curpiece,\n-                            None,\n-                            has_precision || has_width,\n-                        );\n-                        Exact(i)\n-                    }\n-                    parse::ArgumentNamed(s) => {\n-                        let symbol = Symbol::intern(s);\n-                        let span = arg.position_span;\n-                        Named(symbol, InnerSpan::new(span.start, span.end))\n-                    }\n-                };\n-\n-                let ty = Placeholder(match arg.format.ty {\n-                    \"\" => \"Display\",\n-                    \"?\" => \"Debug\",\n-                    \"e\" => \"LowerExp\",\n-                    \"E\" => \"UpperExp\",\n-                    \"o\" => \"Octal\",\n-                    \"p\" => \"Pointer\",\n-                    \"b\" => \"Binary\",\n-                    \"x\" => \"LowerHex\",\n-                    \"X\" => \"UpperHex\",\n-                    _ => {\n-                        let fmtsp = self.fmtsp;\n-                        let sp = arg\n-                            .format\n-                            .ty_span\n-                            .map(|sp| fmtsp.from_inner(InnerSpan::new(sp.start, sp.end)));\n-                        let mut err = self.ecx.struct_span_err(\n-                            sp.unwrap_or(fmtsp),\n-                            &format!(\"unknown format trait `{}`\", arg.format.ty),\n-                        );\n-                        err.note(\n-                            \"the only appropriate formatting traits are:\\n\\\n-                                - ``, which uses the `Display` trait\\n\\\n-                                - `?`, which uses the `Debug` trait\\n\\\n-                                - `e`, which uses the `LowerExp` trait\\n\\\n-                                - `E`, which uses the `UpperExp` trait\\n\\\n-                                - `o`, which uses the `Octal` trait\\n\\\n-                                - `p`, which uses the `Pointer` trait\\n\\\n-                                - `b`, which uses the `Binary` trait\\n\\\n-                                - `x`, which uses the `LowerHex` trait\\n\\\n-                                - `X`, which uses the `UpperHex` trait\",\n-                        );\n-                        if let Some(sp) = sp {\n-                            for (fmt, name) in &[\n-                                (\"\", \"Display\"),\n-                                (\"?\", \"Debug\"),\n-                                (\"e\", \"LowerExp\"),\n-                                (\"E\", \"UpperExp\"),\n-                                (\"o\", \"Octal\"),\n-                                (\"p\", \"Pointer\"),\n-                                (\"b\", \"Binary\"),\n-                                (\"x\", \"LowerHex\"),\n-                                (\"X\", \"UpperHex\"),\n-                            ] {\n-                                // FIXME: rustfix (`run-rustfix`) fails to apply suggestions.\n-                                // > \"Cannot replace slice of data that was already replaced\"\n-                                err.tool_only_span_suggestion(\n-                                    sp,\n-                                    &format!(\"use the `{}` trait\", name),\n-                                    *fmt,\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            }\n-                        }\n-                        err.emit();\n-                        \"<invalid>\"\n-                    }\n-                });\n-                self.verify_arg_type(pos, ty);\n-                self.curpiece += 1;\n-            }\n-        }\n-    }\n-\n-    fn verify_count(\n-        &mut self,\n-        c: parse::Count<'_>,\n-        inner_span: &Option<rustc_parse_format::InnerSpan>,\n-        named_arg_type: PositionalNamedArgType,\n-    ) {\n-        match c {\n-            parse::CountImplied | parse::CountIs(..) => {}\n-            parse::CountIsParam(i) | parse::CountIsStar(i) => {\n-                self.unused_names_lint.maybe_add_positional_named_arg(\n-                    self.args.get(i),\n-                    named_arg_type,\n-                    self.curpiece,\n-                    *inner_span,\n-                    true,\n-                );\n-                self.verify_arg_type(Exact(i), Count);\n-            }\n-            parse::CountIsName(s, span) => {\n-                self.verify_arg_type(\n-                    Named(Symbol::intern(s), InnerSpan::new(span.start, span.end)),\n-                    Count,\n-                );\n-            }\n-        }\n-    }\n-\n-    fn describe_num_args(&self) -> Cow<'_, str> {\n-        match self.num_args() {\n-            0 => \"no arguments were given\".into(),\n-            1 => \"there is 1 argument\".into(),\n-            x => format!(\"there are {} arguments\", x).into(),\n-        }\n-    }\n-\n-    /// Handle invalid references to positional arguments. Output different\n-    /// errors for the case where all arguments are positional and for when\n-    /// there are named arguments or numbered positional arguments in the\n-    /// format string.\n-    fn report_invalid_references(&self, numbered_position_args: bool) {\n-        let mut e;\n-        let sp = if !self.arg_spans.is_empty() {\n-            // Point at the formatting arguments.\n-            MultiSpan::from_spans(self.arg_spans.clone())\n-        } else {\n-            MultiSpan::from_span(self.fmtsp)\n-        };\n-        let refs =\n-            self.invalid_refs.iter().map(|(r, pos)| (r.to_string(), self.arg_spans.get(*pos)));\n-\n-        let mut zero_based_note = false;\n-\n-        let count = self.pieces.len()\n-            + self\n-                .arg_with_formatting\n-                .iter()\n-                .filter(|fmt| matches!(fmt.precision, parse::CountIsStar(_)))\n-                .count();\n-        if self.names.is_empty() && !numbered_position_args && count != self.num_args() {\n-            e = self.ecx.struct_span_err(\n-                sp,\n-                &format!(\n-                    \"{} positional argument{} in format string, but {}\",\n-                    count,\n-                    pluralize!(count),\n-                    self.describe_num_args(),\n-                ),\n-            );\n-            for arg in &self.args {\n-                // Point at the arguments that will be formatted.\n-                e.span_label(arg.expr.span, \"\");\n-            }\n-        } else {\n-            let (mut refs, spans): (Vec<_>, Vec<_>) = refs.unzip();\n-            // Avoid `invalid reference to positional arguments 7 and 7 (there is 1 argument)`\n-            // for `println!(\"{7:7$}\", 1);`\n-            refs.sort();\n-            refs.dedup();\n-            let spans: Vec<_> = spans.into_iter().filter_map(|sp| sp.copied()).collect();\n-            let sp = if self.arg_spans.is_empty() || spans.is_empty() {\n-                MultiSpan::from_span(self.fmtsp)\n-            } else {\n-                MultiSpan::from_spans(spans)\n-            };\n-            let arg_list = if refs.len() == 1 {\n-                format!(\"argument {}\", refs[0])\n-            } else {\n-                let reg = refs.pop().unwrap();\n-                format!(\"arguments {head} and {tail}\", head = refs.join(\", \"), tail = reg)\n-            };\n-\n-            e = self.ecx.struct_span_err(\n-                sp,\n-                &format!(\n-                    \"invalid reference to positional {} ({})\",\n-                    arg_list,\n-                    self.describe_num_args()\n-                ),\n-            );\n-            zero_based_note = true;\n-        };\n-\n-        for fmt in &self.arg_with_formatting {\n-            if let Some(span) = fmt.precision_span {\n-                let span = self.fmtsp.from_inner(InnerSpan::new(span.start, span.end));\n-                match fmt.precision {\n-                    parse::CountIsParam(pos) if pos >= self.num_args() => {\n-                        e.span_label(\n-                            span,\n-                            &format!(\n-                                \"this precision flag expects an `usize` argument at position {}, \\\n-                             but {}\",\n-                                pos,\n-                                self.describe_num_args(),\n-                            ),\n-                        );\n-                        zero_based_note = true;\n-                    }\n-                    parse::CountIsStar(pos) => {\n-                        let count = self.pieces.len()\n-                            + self\n-                                .arg_with_formatting\n-                                .iter()\n-                                .filter(|fmt| matches!(fmt.precision, parse::CountIsStar(_)))\n-                                .count();\n-                        e.span_label(\n-                            span,\n-                            &format!(\n-                            \"this precision flag adds an extra required argument at position {}, \\\n-                             which is why there {} expected\",\n-                            pos,\n-                            if count == 1 {\n-                                \"is 1 argument\".to_string()\n-                            } else {\n-                                format!(\"are {} arguments\", count)\n-                            },\n-                        ),\n-                        );\n-                        if let Some(arg) = self.args.get(pos) {\n-                            e.span_label(\n-                                arg.expr.span,\n-                                \"this parameter corresponds to the precision flag\",\n-                            );\n-                        }\n-                        zero_based_note = true;\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            if let Some(span) = fmt.width_span {\n-                let span = self.fmtsp.from_inner(InnerSpan::new(span.start, span.end));\n-                match fmt.width {\n-                    parse::CountIsParam(pos) if pos >= self.num_args() => {\n-                        e.span_label(\n-                            span,\n-                            &format!(\n-                                \"this width flag expects an `usize` argument at position {}, \\\n-                             but {}\",\n-                                pos,\n-                                self.describe_num_args(),\n-                            ),\n-                        );\n-                        zero_based_note = true;\n-                    }\n-                    _ => {}\n-                }\n-            }\n-        }\n-        if zero_based_note {\n-            e.note(\"positional arguments are zero-based\");\n-        }\n-        if !self.arg_with_formatting.is_empty() {\n-            e.note(\n-                \"for information about formatting flags, visit \\\n-                    https://doc.rust-lang.org/std/fmt/index.html\",\n-            );\n-        }\n-\n-        e.emit();\n-    }\n-\n-    /// Actually verifies and tracks a given format placeholder\n-    /// (a.k.a. argument).\n-    fn verify_arg_type(&mut self, arg: Position, ty: ArgumentType) {\n-        if let Exact(arg) = arg {\n-            if arg >= self.num_args() {\n-                self.invalid_refs.push((arg, self.curpiece));\n-                return;\n-            }\n-        }\n-\n-        match arg {\n-            Exact(arg) | Capture(arg) => {\n-                match ty {\n-                    Placeholder(_) => {\n-                        // record every (position, type) combination only once\n-                        let seen_ty = &mut self.arg_unique_types[arg];\n-                        let i = seen_ty.iter().position(|x| *x == ty).unwrap_or_else(|| {\n-                            let i = seen_ty.len();\n-                            seen_ty.push(ty);\n-                            i\n-                        });\n-                        self.arg_types[arg].push(i);\n-                    }\n-                    Count => {\n-                        if let Entry::Vacant(e) = self.count_positions.entry(arg) {\n-                            let i = self.count_positions_count;\n-                            e.insert(i);\n-                            self.count_args.push(arg);\n-                            self.count_positions_count += 1;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            Named(name, span) => {\n-                match self.names.get(&name) {\n-                    Some(&idx) => {\n-                        // Treat as positional arg.\n-                        self.verify_arg_type(Capture(idx), ty)\n-                    }\n-                    None => {\n-                        // For the moment capturing variables from format strings expanded from macros is\n-                        // disabled (see RFC #2795)\n-                        if self.is_literal {\n-                            // Treat this name as a variable to capture from the surrounding scope\n-                            let idx = self.args.len();\n-                            self.arg_types.push(Vec::new());\n-                            self.arg_unique_types.push(Vec::new());\n-                            let span = if self.is_literal {\n-                                self.fmtsp.from_inner(span)\n-                            } else {\n-                                self.fmtsp\n-                            };\n-                            self.num_captured_args += 1;\n-                            self.args.push(FormatArg {\n-                                expr: self.ecx.expr_ident(span, Ident::new(name, span)),\n-                                name: Some(Ident::new(name, span)),\n-                            });\n-                            self.names.insert(name, idx);\n-                            self.verify_arg_type(Capture(idx), ty)\n-                        } else {\n-                            let msg = format!(\"there is no argument named `{}`\", name);\n-                            let sp = if self.is_literal {\n-                                self.fmtsp.from_inner(span)\n-                            } else {\n-                                self.fmtsp\n-                            };\n-                            let mut err = self.ecx.struct_span_err(sp, &msg);\n-\n-                            err.note(&format!(\n-                                \"did you intend to capture a variable `{}` from \\\n-                                 the surrounding scope?\",\n-                                name\n-                            ));\n-                            err.note(\n-                                \"to avoid ambiguity, `format_args!` cannot capture variables \\\n-                                 when the format string is expanded from a macro\",\n-                            );\n-\n-                            err.emit();\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Builds the mapping between format placeholders and argument objects.\n-    fn build_index_map(&mut self) {\n-        // NOTE: Keep the ordering the same as `into_expr`'s expansion would do!\n-        let args_len = self.args.len();\n-        self.arg_index_map.reserve(args_len);\n-\n-        let mut sofar = 0usize;\n-\n-        // Map the arguments\n-        for i in 0..args_len {\n-            let arg_types = &self.arg_types[i];\n-            let arg_offsets = arg_types.iter().map(|offset| sofar + *offset).collect::<Vec<_>>();\n-            self.arg_index_map.push(arg_offsets);\n-            sofar += self.arg_unique_types[i].len();\n-        }\n-\n-        // Record starting index for counts, which appear just after arguments\n-        self.count_args_index_offset = sofar;\n-    }\n-\n-    fn rtpath(ecx: &ExtCtxt<'_>, s: Symbol) -> Vec<Ident> {\n-        ecx.std_path(&[sym::fmt, sym::rt, sym::v1, s])\n-    }\n-\n-    fn build_count(&self, c: parse::Count<'_>) -> P<ast::Expr> {\n-        let sp = self.macsp;\n-        let count = |c, arg| {\n-            let mut path = Context::rtpath(self.ecx, sym::Count);\n-            path.push(Ident::new(c, sp));\n-            match arg {\n-                Some(arg) => self.ecx.expr_call_global(sp, path, vec![arg]),\n-                None => self.ecx.expr_path(self.ecx.path_global(sp, path)),\n-            }\n-        };\n-        match c {\n-            parse::CountIs(i) => count(sym::Is, Some(self.ecx.expr_usize(sp, i))),\n-            parse::CountIsParam(i) | parse::CountIsStar(i) => {\n-                // This needs mapping too, as `i` is referring to a macro\n-                // argument. If `i` is not found in `count_positions` then\n-                // the error had already been emitted elsewhere.\n-                let i = self.count_positions.get(&i).cloned().unwrap_or(0)\n-                    + self.count_args_index_offset;\n-                count(sym::Param, Some(self.ecx.expr_usize(sp, i)))\n-            }\n-            parse::CountImplied => count(sym::Implied, None),\n-            // should never be the case, names are already resolved\n-            parse::CountIsName(..) => panic!(\"should never happen\"),\n-        }\n-    }\n-\n-    /// Build a literal expression from the accumulated string literals\n-    fn build_literal_string(&mut self) -> P<ast::Expr> {\n-        let sp = self.fmtsp;\n-        let s = Symbol::intern(&self.literal);\n-        self.literal.clear();\n-        self.ecx.expr_str(sp, s)\n-    }\n-\n-    /// Builds a static `rt::Argument` from a `parse::Piece` or append\n-    /// to the `literal` string.\n-    fn build_piece(\n-        &mut self,\n-        piece: &parse::Piece<'a>,\n-        arg_index_consumed: &mut Vec<usize>,\n-    ) -> Option<P<ast::Expr>> {\n-        let sp = self.macsp;\n-        match *piece {\n-            parse::String(s) => {\n-                self.literal.push_str(s);\n-                None\n-            }\n-            parse::NextArgument(ref arg) => {\n-                // Build the position\n-                let pos = {\n-                    match arg.position {\n-                        parse::ArgumentIs(i, ..) | parse::ArgumentImplicitlyIs(i) => {\n-                            // Map to index in final generated argument array\n-                            // in case of multiple types specified\n-                            let arg_idx = match arg_index_consumed.get_mut(i) {\n-                                None => 0, // error already emitted elsewhere\n-                                Some(offset) => {\n-                                    let idx_map = &self.arg_index_map[i];\n-                                    // unwrap_or branch: error already emitted elsewhere\n-                                    let arg_idx = *idx_map.get(*offset).unwrap_or(&0);\n-                                    *offset += 1;\n-                                    arg_idx\n-                                }\n-                            };\n-                            self.ecx.expr_usize(sp, arg_idx)\n-                        }\n-\n-                        // should never be the case, because names are already\n-                        // resolved.\n-                        parse::ArgumentNamed(..) => panic!(\"should never happen\"),\n-                    }\n-                };\n-\n-                let simple_arg = parse::Argument {\n-                    position: {\n-                        // We don't have ArgumentNext any more, so we have to\n-                        // track the current argument ourselves.\n-                        let i = self.curarg;\n-                        self.curarg += 1;\n-                        parse::ArgumentIs(i)\n-                    },\n-                    position_span: arg.position_span,\n-                    format: parse::FormatSpec {\n-                        fill: None,\n-                        align: parse::AlignUnknown,\n-                        flags: 0,\n-                        precision: parse::CountImplied,\n-                        precision_span: arg.format.precision_span,\n-                        width: parse::CountImplied,\n-                        width_span: arg.format.width_span,\n-                        ty: arg.format.ty,\n-                        ty_span: arg.format.ty_span,\n-                    },\n-                };\n-\n-                let fill = arg.format.fill.unwrap_or(' ');\n-                let pos_simple = arg.position.index() == simple_arg.position.index();\n-\n-                if !pos_simple || arg.format != simple_arg.format {\n-                    self.all_pieces_simple = false;\n-                }\n-\n-                // Build the format\n-                let fill = self.ecx.expr_char(sp, fill);\n-                let align = |name| {\n-                    let mut p = Context::rtpath(self.ecx, sym::Alignment);\n-                    p.push(Ident::new(name, sp));\n-                    self.ecx.path_global(sp, p)\n-                };\n-                let align = match arg.format.align {\n-                    parse::AlignLeft => align(sym::Left),\n-                    parse::AlignRight => align(sym::Right),\n-                    parse::AlignCenter => align(sym::Center),\n-                    parse::AlignUnknown => align(sym::Unknown),\n-                };\n-                let align = self.ecx.expr_path(align);\n-                let flags = self.ecx.expr_u32(sp, arg.format.flags);\n-                let prec = self.build_count(arg.format.precision);\n-                let width = self.build_count(arg.format.width);\n-                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, sym::FormatSpec));\n-                let fmt = self.ecx.expr_struct(\n-                    sp,\n-                    path,\n-                    vec![\n-                        self.ecx.field_imm(sp, Ident::new(sym::fill, sp), fill),\n-                        self.ecx.field_imm(sp, Ident::new(sym::align, sp), align),\n-                        self.ecx.field_imm(sp, Ident::new(sym::flags, sp), flags),\n-                        self.ecx.field_imm(sp, Ident::new(sym::precision, sp), prec),\n-                        self.ecx.field_imm(sp, Ident::new(sym::width, sp), width),\n-                    ],\n-                );\n-\n-                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, sym::Argument));\n-                Some(self.ecx.expr_struct(\n-                    sp,\n-                    path,\n-                    vec![\n-                        self.ecx.field_imm(sp, Ident::new(sym::position, sp), pos),\n-                        self.ecx.field_imm(sp, Ident::new(sym::format, sp), fmt),\n-                    ],\n-                ))\n-            }\n-        }\n-    }\n-\n-    /// Actually builds the expression which the format_args! block will be\n-    /// expanded to.\n-    fn into_expr(self) -> P<ast::Expr> {\n-        let mut original_args = self.args;\n-        let mut fmt_args = Vec::with_capacity(\n-            self.arg_unique_types.iter().map(|v| v.len()).sum::<usize>() + self.count_args.len(),\n-        );\n-\n-        // First, build up the static array which will become our precompiled\n-        // format \"string\"\n-        let pieces = self.ecx.expr_array_ref(self.fmtsp, self.str_pieces);\n-\n-        // We need to construct a &[ArgumentV1] to pass into the fmt::Arguments\n-        // constructor. In general the expressions in this slice might be\n-        // permuted from their order in original_args (such as in the case of\n-        // \"{1} {0}\"), or may have multiple entries referring to the same\n-        // element of original_args (\"{0} {0}\").\n-        //\n-        // The following vector has one item per element of our output slice,\n-        // identifying the index of which element of original_args it's passing,\n-        // and that argument's type.\n-        let mut fmt_arg_index_and_ty = SmallVec::<[(usize, &ArgumentType); 8]>::new();\n-        for (i, unique_types) in self.arg_unique_types.iter().enumerate() {\n-            fmt_arg_index_and_ty.extend(unique_types.iter().map(|ty| (i, ty)));\n-        }\n-        fmt_arg_index_and_ty.extend(self.count_args.iter().map(|&i| (i, &Count)));\n-\n-        // Figure out whether there are permuted or repeated elements. If not,\n-        // we can generate simpler code.\n-        //\n-        // The sequence has no indices out of order or repeated if: for every\n-        // adjacent pair of elements, the first one's index is less than the\n-        // second one's index.\n-        let nicely_ordered =\n-            fmt_arg_index_and_ty.array_windows().all(|[(i, _i_ty), (j, _j_ty)]| i < j);\n-\n-        // We want to emit:\n-        //\n-        //     [ArgumentV1::new(&$arg0, \u2026), ArgumentV1::new(&$arg1, \u2026), \u2026]\n-        //\n-        // However, it's only legal to do so if $arg0, $arg1, \u2026 were written in\n-        // exactly that order by the programmer. When arguments are permuted, we\n-        // want them evaluated in the order written by the programmer, not in\n-        // the order provided to fmt::Arguments. When arguments are repeated, we\n-        // want the expression evaluated only once.\n-        //\n-        // Further, if any arg _after the first one_ contains a yield point such\n-        // as `await` or `yield`, the above short form is inconvenient for the\n-        // caller because it would keep a temporary of type ArgumentV1 alive\n-        // across the yield point. ArgumentV1 can't implement Send since it\n-        // holds a type-erased arbitrary type.\n-        //\n-        // Thus in the not nicely ordered case, and in the yielding case, we\n-        // emit the following instead:\n-        //\n-        //     match (&$arg0, &$arg1, \u2026) {\n-        //         args => [ArgumentV1::new(args.$i, \u2026), ArgumentV1::new(args.$j, \u2026), \u2026]\n-        //     }\n-        //\n-        // for the sequence of indices $i, $j, \u2026 governed by fmt_arg_index_and_ty.\n-        // This more verbose representation ensures that all arguments are\n-        // evaluated a single time each, in the order written by the programmer,\n-        // and that the surrounding future/generator (if any) is Send whenever\n-        // possible.\n-        let no_need_for_match = nicely_ordered\n-            && !original_args.iter().skip(1).any(|arg| may_contain_yield_point(&arg.expr));\n-\n-        for (arg_index, arg_ty) in fmt_arg_index_and_ty {\n-            let e = &mut original_args[arg_index].expr;\n-            let span = e.span;\n-            let arg = if no_need_for_match {\n-                let expansion_span = e.span.with_ctxt(self.macsp.ctxt());\n-                // The indices are strictly ordered so e has not been taken yet.\n-                self.ecx.expr_addr_of(expansion_span, P(e.take()))\n-            } else {\n-                let def_site = self.ecx.with_def_site_ctxt(span);\n-                let args_tuple = self.ecx.expr_ident(def_site, Ident::new(sym::args, def_site));\n-                let member = Ident::new(sym::integer(arg_index), def_site);\n-                self.ecx.expr(def_site, ast::ExprKind::Field(args_tuple, member))\n-            };\n-            fmt_args.push(Context::format_arg(self.ecx, self.macsp, span, arg_ty, arg));\n-        }\n-\n-        let args_array = self.ecx.expr_array(self.macsp, fmt_args);\n-        let args_slice = self.ecx.expr_addr_of(\n-            self.macsp,\n-            if no_need_for_match {\n-                args_array\n-            } else {\n-                // In the !no_need_for_match case, none of the exprs were moved\n-                // away in the previous loop.\n-                //\n-                // This uses the arg span for `&arg` so that borrowck errors\n-                // point to the specific expression passed to the macro (the\n-                // span is otherwise unavailable in the MIR used by borrowck).\n-                let heads = original_args\n-                    .into_iter()\n-                    .map(|arg| {\n-                        self.ecx.expr_addr_of(arg.expr.span.with_ctxt(self.macsp.ctxt()), arg.expr)\n-                    })\n-                    .collect();\n-\n-                let pat = self.ecx.pat_ident(self.macsp, Ident::new(sym::args, self.macsp));\n-                let arm = self.ecx.arm(self.macsp, pat, args_array);\n-                let head = self.ecx.expr(self.macsp, ast::ExprKind::Tup(heads));\n-                self.ecx.expr_match(self.macsp, head, vec![arm])\n-            },\n-        );\n-\n-        // Now create the fmt::Arguments struct with all our locals we created.\n-        let (fn_name, fn_args) = if self.all_pieces_simple {\n-            (\"new_v1\", vec![pieces, args_slice])\n-        } else {\n-            // Build up the static array which will store our precompiled\n-            // nonstandard placeholders, if there are any.\n-            let fmt = self.ecx.expr_array_ref(self.macsp, self.pieces);\n-\n-            let path = self.ecx.std_path(&[sym::fmt, sym::UnsafeArg, sym::new]);\n-            let unsafe_arg = self.ecx.expr_call_global(self.macsp, path, Vec::new());\n-            let unsafe_expr = self.ecx.expr_block(P(ast::Block {\n-                stmts: vec![self.ecx.stmt_expr(unsafe_arg)],\n-                id: ast::DUMMY_NODE_ID,\n-                rules: BlockCheckMode::Unsafe(UnsafeSource::CompilerGenerated),\n-                span: self.macsp,\n-                tokens: None,\n-                could_be_bare_literal: false,\n-            }));\n-\n-            (\"new_v1_formatted\", vec![pieces, args_slice, fmt, unsafe_expr])\n-        };\n-\n-        let path = self.ecx.std_path(&[sym::fmt, sym::Arguments, Symbol::intern(fn_name)]);\n-        self.ecx.expr_call_global(self.macsp, path, fn_args)\n-    }\n-\n-    fn format_arg(\n-        ecx: &ExtCtxt<'_>,\n-        macsp: Span,\n-        mut sp: Span,\n-        ty: &ArgumentType,\n-        arg: P<ast::Expr>,\n-    ) -> P<ast::Expr> {\n-        sp = ecx.with_def_site_ctxt(sp);\n-        let trait_ = match *ty {\n-            Placeholder(trait_) if trait_ == \"<invalid>\" => return DummyResult::raw_expr(sp, true),\n-            Placeholder(trait_) => trait_,\n-            Count => {\n-                let path = ecx.std_path(&[sym::fmt, sym::ArgumentV1, sym::from_usize]);\n-                return ecx.expr_call_global(macsp, path, vec![arg]);\n-            }\n-        };\n-        let new_fn_name = match trait_ {\n-            \"Display\" => \"new_display\",\n-            \"Debug\" => \"new_debug\",\n-            \"LowerExp\" => \"new_lower_exp\",\n-            \"UpperExp\" => \"new_upper_exp\",\n-            \"Octal\" => \"new_octal\",\n-            \"Pointer\" => \"new_pointer\",\n-            \"Binary\" => \"new_binary\",\n-            \"LowerHex\" => \"new_lower_hex\",\n-            \"UpperHex\" => \"new_upper_hex\",\n-            _ => unreachable!(),\n-        };\n-\n-        let path = ecx.std_path(&[sym::fmt, sym::ArgumentV1, Symbol::intern(new_fn_name)]);\n-        ecx.expr_call_global(sp, path, vec![arg])\n-    }\n-}\n-\n-fn expand_format_args_impl<'cx>(\n-    ecx: &'cx mut ExtCtxt<'_>,\n-    mut sp: Span,\n-    tts: TokenStream,\n-    nl: bool,\n-) -> Box<dyn base::MacResult + 'cx> {\n-    sp = ecx.with_def_site_ctxt(sp);\n-    match parse_args(ecx, sp, tts) {\n-        Ok((efmt, args, names)) => {\n-            MacEager::expr(expand_preparsed_format_args(ecx, sp, efmt, args, names, nl))\n-        }\n-        Err(mut err) => {\n-            err.emit();\n-            DummyResult::any(sp)\n-        }\n-    }\n-}\n-\n-pub fn expand_format_args<'cx>(\n-    ecx: &'cx mut ExtCtxt<'_>,\n-    sp: Span,\n-    tts: TokenStream,\n-) -> Box<dyn base::MacResult + 'cx> {\n-    expand_format_args_impl(ecx, sp, tts, false)\n-}\n-\n-pub fn expand_format_args_nl<'cx>(\n-    ecx: &'cx mut ExtCtxt<'_>,\n-    sp: Span,\n-    tts: TokenStream,\n-) -> Box<dyn base::MacResult + 'cx> {\n-    expand_format_args_impl(ecx, sp, tts, true)\n-}\n-\n-fn create_lints_for_named_arguments_used_positionally(cx: &mut Context<'_, '_>) {\n-    for named_arg in &cx.unused_names_lint.positional_named_args {\n-        let (position_sp_to_replace, position_sp_for_msg) = named_arg.get_positional_arg_spans(cx);\n-\n-        let msg = format!(\"named argument `{}` is not used by name\", named_arg.replacement);\n-\n-        cx.ecx.buffered_early_lint.push(BufferedEarlyLint {\n-            span: MultiSpan::from_span(named_arg.positional_named_arg_span),\n-            msg: msg.into(),\n-            node_id: ast::CRATE_NODE_ID,\n-            lint_id: LintId::of(&NAMED_ARGUMENTS_USED_POSITIONALLY),\n-            diagnostic: BuiltinLintDiagnostics::NamedArgumentUsedPositionally {\n-                position_sp_to_replace,\n-                position_sp_for_msg,\n-                named_arg_sp: named_arg.positional_named_arg_span,\n-                named_arg_name: named_arg.replacement.to_string(),\n-                is_formatting_arg: named_arg.ty != PositionalNamedArgType::Arg,\n-            },\n-        });\n-    }\n-}\n-\n-/// Take the various parts of `format_args!(efmt, args..., name=names...)`\n-/// and construct the appropriate formatting expression.\n-pub fn expand_preparsed_format_args(\n+pub fn make_format_args(\n     ecx: &mut ExtCtxt<'_>,\n-    sp: Span,\n     efmt: P<ast::Expr>,\n-    args: Vec<FormatArg>,\n-    names: FxHashMap<Symbol, usize>,\n+    mut args: Vec<(P<ast::Expr>, FormatArgKind)>,\n     append_newline: bool,\n-) -> P<ast::Expr> {\n-    // NOTE: this verbose way of initializing `Vec<Vec<ArgumentType>>` is because\n-    // `ArgumentType` does not derive `Clone`.\n-    let arg_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n-    let arg_unique_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n-\n-    let mut macsp = ecx.call_site();\n-    macsp = ecx.with_def_site_ctxt(macsp);\n+) -> Result<FormatArgs, ()> {\n+    let start_of_named_args =\n+        args.iter().position(|arg| arg.1.ident().is_some()).unwrap_or(args.len());\n \n     let msg = \"format argument must be a string literal\";\n-    let fmt_sp = efmt.span;\n-    let efmt_kind_is_lit: bool = matches!(efmt.kind, ast::ExprKind::Lit(_));\n+    let fmt_span = efmt.span;\n     let (fmt_str, fmt_style, fmt_span) = match expr_to_spanned_string(ecx, efmt, msg) {\n         Ok(mut fmt) if append_newline => {\n             fmt.0 = Symbol::intern(&format!(\"{}\\n\", fmt.0));\n@@ -1230,15 +328,15 @@ pub fn expand_preparsed_format_args(\n                 };\n                 if !suggested {\n                     err.span_suggestion(\n-                        fmt_sp.shrink_to_lo(),\n+                        fmt_span.shrink_to_lo(),\n                         \"you might be missing a string literal to format with\",\n                         format!(\"\\\"{}\\\", \", sugg_fmt),\n                         Applicability::MaybeIncorrect,\n                     );\n                 }\n                 err.emit();\n             }\n-            return DummyResult::raw_expr(sp, true);\n+            return Err(());\n         }\n     };\n \n@@ -1248,7 +346,7 @@ pub fn expand_preparsed_format_args(\n     };\n \n     let fmt_str = fmt_str.as_str(); // for the suggestions below\n-    let fmt_snippet = ecx.source_map().span_to_snippet(fmt_sp).ok();\n+    let fmt_snippet = ecx.source_map().span_to_snippet(fmt_span).ok();\n     let mut parser = parse::Parser::new(\n         fmt_str,\n         str_style,\n@@ -1257,18 +355,20 @@ pub fn expand_preparsed_format_args(\n         parse::ParseMode::Format,\n     );\n \n-    let mut unverified_pieces = Vec::new();\n+    let mut pieces = Vec::new();\n     while let Some(piece) = parser.next() {\n         if !parser.errors.is_empty() {\n             break;\n         } else {\n-            unverified_pieces.push(piece);\n+            pieces.push(piece);\n         }\n     }\n \n+    let is_literal = parser.is_literal;\n+\n     if !parser.errors.is_empty() {\n         let err = parser.errors.remove(0);\n-        let sp = if efmt_kind_is_lit {\n+        let sp = if is_literal {\n             fmt_span.from_inner(InnerSpan::new(err.span.start, err.span.end))\n         } else {\n             // The format string could be another macro invocation, e.g.:\n@@ -1287,266 +387,671 @@ pub fn expand_preparsed_format_args(\n             e.note(&note);\n         }\n         if let Some((label, span)) = err.secondary_label {\n-            if efmt_kind_is_lit {\n+            if is_literal {\n                 e.span_label(fmt_span.from_inner(InnerSpan::new(span.start, span.end)), label);\n             }\n         }\n         if err.should_be_replaced_with_positional_argument {\n             let captured_arg_span =\n                 fmt_span.from_inner(InnerSpan::new(err.span.start, err.span.end));\n-            let n_positional_args =\n-                args.iter().rposition(|arg| arg.name.is_none()).map_or(0, |i| i + 1);\n             if let Ok(arg) = ecx.source_map().span_to_snippet(captured_arg_span) {\n-                let span = match args[..n_positional_args].last() {\n-                    Some(arg) => arg.expr.span,\n-                    None => fmt_sp,\n+                let span = match args[..start_of_named_args].last() {\n+                    Some(arg) => arg.0.span,\n+                    None => fmt_span,\n                 };\n                 e.multipart_suggestion_verbose(\n                     \"consider using a positional formatting argument instead\",\n                     vec![\n-                        (captured_arg_span, n_positional_args.to_string()),\n+                        (captured_arg_span, start_of_named_args.to_string()),\n                         (span.shrink_to_hi(), format!(\", {}\", arg)),\n                     ],\n                     Applicability::MachineApplicable,\n                 );\n             }\n         }\n         e.emit();\n-        return DummyResult::raw_expr(sp, true);\n+        return Err(());\n     }\n \n-    let arg_spans = parser\n-        .arg_places\n-        .iter()\n-        .map(|span| fmt_span.from_inner(InnerSpan::new(span.start, span.end)))\n-        .collect();\n-\n-    let mut cx = Context {\n-        ecx,\n-        args,\n-        num_captured_args: 0,\n-        arg_types,\n-        arg_unique_types,\n-        names,\n-        curarg: 0,\n-        curpiece: 0,\n-        arg_index_map: Vec::new(),\n-        count_args: Vec::new(),\n-        count_positions: FxHashMap::default(),\n-        count_positions_count: 0,\n-        count_args_index_offset: 0,\n-        literal: String::new(),\n-        pieces: Vec::with_capacity(unverified_pieces.len()),\n-        str_pieces: Vec::with_capacity(unverified_pieces.len()),\n-        all_pieces_simple: true,\n-        macsp,\n-        fmtsp: fmt_span,\n-        invalid_refs: Vec::new(),\n-        arg_spans,\n-        arg_with_formatting: Vec::new(),\n-        is_literal: parser.is_literal,\n-        unused_names_lint: PositionalNamedArgsLint { positional_named_args: vec![] },\n+    let to_span = |inner_span: rustc_parse_format::InnerSpan| {\n+        is_literal.then(|| {\n+            fmt_span.from_inner(InnerSpan { start: inner_span.start, end: inner_span.end })\n+        })\n     };\n \n-    // This needs to happen *after* the Parser has consumed all pieces to create all the spans\n-    let pieces = unverified_pieces\n-        .into_iter()\n-        .map(|mut piece| {\n-            cx.verify_piece(&piece);\n-            cx.resolve_name_inplace(&mut piece);\n-            piece\n-        })\n-        .collect::<Vec<_>>();\n+    enum ArgRef<'a> {\n+        Index(usize),\n+        Name(&'a str, Option<Span>),\n+    }\n+    use ArgRef::*;\n+\n+    let num_explicit_args = args.len();\n+    let mut used = vec![false; num_explicit_args];\n+    let mut invalid_refs = Vec::new();\n+    let mut numeric_refences_to_named_arg = Vec::new();\n+\n+    let mut lookup_arg = |arg: ArgRef<'_>,\n+                          span: Option<Span>,\n+                          used_as: PositionUsedAs,\n+                          kind: FormatArgPositionKind|\n+     -> FormatArgPosition {\n+        let index = match arg {\n+            Index(index) => {\n+                if let Some((_, arg_kind)) = args.get(index) {\n+                    match arg_kind {\n+                        FormatArgKind::Normal => {\n+                            used[index] = true;\n+                            Ok(index)\n+                        }\n+                        FormatArgKind::Named(_) => {\n+                            used[index] = true;\n+                            numeric_refences_to_named_arg.push((index, span, used_as));\n+                            Ok(index)\n+                        }\n+                        FormatArgKind::Captured(_) => {\n+                            // Doesn't exist as an explicit argument.\n+                            invalid_refs.push((index, span, used_as, kind));\n+                            Err(index)\n+                        }\n+                    }\n+                } else {\n+                    invalid_refs.push((index, span, used_as, kind));\n+                    Err(index)\n+                }\n+            }\n+            Name(name, span) => {\n+                let name = Symbol::intern(name);\n+                if let Some(i) = args[start_of_named_args..]\n+                    .iter()\n+                    .position(|arg| arg.1.ident().is_some_and(|id| id.name == name))\n+                {\n+                    let index = start_of_named_args + i;\n+                    if !matches!(args[index].1, FormatArgKind::Captured(_)) {\n+                        used[index] = true;\n+                    }\n+                    Ok(index)\n+                } else {\n+                    let span = span.unwrap_or(fmt_span);\n+                    let ident = Ident::new(name, span);\n+                    let arg = if is_literal {\n+                        ecx.expr_ident(span, ident)\n+                    } else {\n+                        // For the moment capturing variables from format strings expanded from macros is\n+                        // disabled (see RFC #2795)\n+                        ecx.struct_span_err(span, &format!(\"there is no argument named `{name}`\"))\n+                            .note(format!(\"did you intend to capture a variable `{name}` from the surrounding scope?\"))\n+                            .note(\"to avoid ambiguity, `format_args!` cannot capture variables when the format string is expanded from a macro\")\n+                            .emit();\n+                        DummyResult::raw_expr(span, true)\n+                    };\n+                    args.push((arg, FormatArgKind::Captured(ident)));\n+                    Ok(args.len() - 1)\n+                }\n+            }\n+        };\n+        FormatArgPosition { index, kind, span }\n+    };\n+\n+    let mut template = Vec::new();\n+    let mut unfinished_literal = String::new();\n+    let mut placeholder_index = 0;\n \n-    let numbered_position_args = pieces.iter().any(|arg: &parse::Piece<'_>| match *arg {\n-        parse::String(_) => false,\n-        parse::NextArgument(arg) => matches!(arg.position, parse::Position::ArgumentIs(..)),\n-    });\n+    for piece in pieces {\n+        match piece {\n+            parse::Piece::String(s) => {\n+                unfinished_literal.push_str(s);\n+            }\n+            parse::Piece::NextArgument(parse::Argument { position, position_span, format }) => {\n+                if !unfinished_literal.is_empty() {\n+                    template.push(FormatArgsPiece::Literal(Symbol::intern(&unfinished_literal)));\n+                    unfinished_literal.clear();\n+                }\n \n-    cx.build_index_map();\n+                let span = parser.arg_places.get(placeholder_index).and_then(|&s| to_span(s));\n+                placeholder_index += 1;\n+\n+                let position_span = to_span(position_span);\n+                let argument = match position {\n+                    parse::ArgumentImplicitlyIs(i) => lookup_arg(\n+                        Index(i),\n+                        position_span,\n+                        Placeholder(span),\n+                        FormatArgPositionKind::Implicit,\n+                    ),\n+                    parse::ArgumentIs(i) => lookup_arg(\n+                        Index(i),\n+                        position_span,\n+                        Placeholder(span),\n+                        FormatArgPositionKind::Number,\n+                    ),\n+                    parse::ArgumentNamed(name) => lookup_arg(\n+                        Name(name, position_span),\n+                        position_span,\n+                        Placeholder(span),\n+                        FormatArgPositionKind::Named,\n+                    ),\n+                };\n \n-    let mut arg_index_consumed = vec![0usize; cx.arg_index_map.len()];\n+                let alignment = match format.align {\n+                    parse::AlignUnknown => None,\n+                    parse::AlignLeft => Some(FormatAlignment::Left),\n+                    parse::AlignRight => Some(FormatAlignment::Right),\n+                    parse::AlignCenter => Some(FormatAlignment::Center),\n+                };\n \n-    for piece in pieces {\n-        if let Some(piece) = cx.build_piece(&piece, &mut arg_index_consumed) {\n-            let s = cx.build_literal_string();\n-            cx.str_pieces.push(s);\n-            cx.pieces.push(piece);\n+                let format_trait = match format.ty {\n+                    \"\" => FormatTrait::Display,\n+                    \"?\" => FormatTrait::Debug,\n+                    \"e\" => FormatTrait::LowerExp,\n+                    \"E\" => FormatTrait::UpperExp,\n+                    \"o\" => FormatTrait::Octal,\n+                    \"p\" => FormatTrait::Pointer,\n+                    \"b\" => FormatTrait::Binary,\n+                    \"x\" => FormatTrait::LowerHex,\n+                    \"X\" => FormatTrait::UpperHex,\n+                    _ => {\n+                        invalid_placeholder_type_error(ecx, format.ty, format.ty_span, fmt_span);\n+                        FormatTrait::Display\n+                    }\n+                };\n+\n+                let precision_span = format.precision_span.and_then(to_span);\n+                let precision = match format.precision {\n+                    parse::CountIs(n) => Some(FormatCount::Literal(n)),\n+                    parse::CountIsName(name, name_span) => Some(FormatCount::Argument(lookup_arg(\n+                        Name(name, to_span(name_span)),\n+                        precision_span,\n+                        Precision,\n+                        FormatArgPositionKind::Named,\n+                    ))),\n+                    parse::CountIsParam(i) => Some(FormatCount::Argument(lookup_arg(\n+                        Index(i),\n+                        precision_span,\n+                        Precision,\n+                        FormatArgPositionKind::Number,\n+                    ))),\n+                    parse::CountIsStar(i) => Some(FormatCount::Argument(lookup_arg(\n+                        Index(i),\n+                        precision_span,\n+                        Precision,\n+                        FormatArgPositionKind::Implicit,\n+                    ))),\n+                    parse::CountImplied => None,\n+                };\n+\n+                let width_span = format.width_span.and_then(to_span);\n+                let width = match format.width {\n+                    parse::CountIs(n) => Some(FormatCount::Literal(n)),\n+                    parse::CountIsName(name, name_span) => Some(FormatCount::Argument(lookup_arg(\n+                        Name(name, to_span(name_span)),\n+                        width_span,\n+                        Width,\n+                        FormatArgPositionKind::Named,\n+                    ))),\n+                    parse::CountIsParam(i) => Some(FormatCount::Argument(lookup_arg(\n+                        Index(i),\n+                        width_span,\n+                        Width,\n+                        FormatArgPositionKind::Number,\n+                    ))),\n+                    parse::CountIsStar(_) => unreachable!(),\n+                    parse::CountImplied => None,\n+                };\n+\n+                template.push(FormatArgsPiece::Placeholder(FormatPlaceholder {\n+                    argument,\n+                    span,\n+                    format_trait,\n+                    format_options: FormatOptions {\n+                        fill: format.fill,\n+                        alignment,\n+                        flags: format.flags,\n+                        precision,\n+                        width,\n+                    },\n+                }));\n+            }\n         }\n     }\n \n-    if !cx.literal.is_empty() {\n-        let s = cx.build_literal_string();\n-        cx.str_pieces.push(s);\n+    if !unfinished_literal.is_empty() {\n+        template.push(FormatArgsPiece::Literal(Symbol::intern(&unfinished_literal)));\n+        drop(unfinished_literal);\n     }\n \n-    if !cx.invalid_refs.is_empty() {\n-        cx.report_invalid_references(numbered_position_args);\n+    if !invalid_refs.is_empty() {\n+        report_invalid_references(\n+            ecx,\n+            &invalid_refs,\n+            &template,\n+            fmt_span,\n+            num_explicit_args,\n+            &args,\n+            parser,\n+        );\n     }\n \n-    // Make sure that all arguments were used and all arguments have types.\n-    let errs = cx\n-        .arg_types\n+    let unused = used\n         .iter()\n         .enumerate()\n-        .filter(|(i, ty)| ty.is_empty() && !cx.count_positions.contains_key(&i))\n+        .filter(|&(_, used)| !used)\n         .map(|(i, _)| {\n-            let msg = if cx.args[i].name.is_some() {\n+            let msg = if let FormatArgKind::Named(_) = args[i].1 {\n                 \"named argument never used\"\n             } else {\n                 \"argument never used\"\n             };\n-            (cx.args[i].expr.span, msg)\n+            (args[i].0.span, msg)\n         })\n         .collect::<Vec<_>>();\n \n-    let errs_len = errs.len();\n-    if !errs.is_empty() {\n-        let args_used = cx.arg_types.len() - errs_len;\n-        let args_unused = errs_len;\n+    if !unused.is_empty() {\n+        // If there's a lot of unused arguments,\n+        // let's check if this format arguments looks like another syntax (printf / shell).\n+        let detect_foreign_fmt = unused.len() > num_explicit_args / 2;\n+        report_missing_placeholders(ecx, unused, detect_foreign_fmt, str_style, fmt_str, fmt_span);\n+    }\n \n-        let mut diag = {\n-            if let [(sp, msg)] = &errs[..] {\n-                let mut diag = cx.ecx.struct_span_err(*sp, *msg);\n-                diag.span_label(*sp, *msg);\n-                diag\n-            } else {\n-                let mut diag = cx.ecx.struct_span_err(\n-                    errs.iter().map(|&(sp, _)| sp).collect::<Vec<Span>>(),\n-                    \"multiple unused formatting arguments\",\n-                );\n-                diag.span_label(cx.fmtsp, \"multiple missing formatting specifiers\");\n-                for (sp, msg) in errs {\n-                    diag.span_label(sp, msg);\n+    // Only check for unused named argument names if there are no other errors to avoid causing\n+    // too much noise in output errors, such as when a named argument is entirely unused.\n+    if invalid_refs.is_empty() && ecx.sess.err_count() == 0 {\n+        for &(index, span, used_as) in &numeric_refences_to_named_arg {\n+            let (position_sp_to_replace, position_sp_for_msg) = match used_as {\n+                Placeholder(pspan) => (span, pspan),\n+                Precision => {\n+                    // Strip the leading `.` for precision.\n+                    let span = span.map(|span| span.with_lo(span.lo() + BytePos(1)));\n+                    (span, span)\n                 }\n-                diag\n-            }\n-        };\n+                Width => (span, span),\n+            };\n+            let arg_name = args[index].1.ident().unwrap();\n+            ecx.buffered_early_lint.push(BufferedEarlyLint {\n+                span: arg_name.span.into(),\n+                msg: format!(\"named argument `{}` is not used by name\", arg_name.name).into(),\n+                node_id: ast::CRATE_NODE_ID,\n+                lint_id: LintId::of(&NAMED_ARGUMENTS_USED_POSITIONALLY),\n+                diagnostic: BuiltinLintDiagnostics::NamedArgumentUsedPositionally {\n+                    position_sp_to_replace,\n+                    position_sp_for_msg,\n+                    named_arg_sp: arg_name.span,\n+                    named_arg_name: arg_name.name.to_string(),\n+                    is_formatting_arg: matches!(used_as, Width | Precision),\n+                },\n+            });\n+        }\n+    }\n \n-        // Used to ensure we only report translations for *one* kind of foreign format.\n-        let mut found_foreign = false;\n-        // Decide if we want to look for foreign formatting directives.\n-        if args_used < args_unused {\n-            use super::format_foreign as foreign;\n-\n-            // The set of foreign substitutions we've explained.  This prevents spamming the user\n-            // with `%d should be written as {}` over and over again.\n-            let mut explained = FxHashSet::default();\n-\n-            macro_rules! check_foreign {\n-                ($kind:ident) => {{\n-                    let mut show_doc_note = false;\n-\n-                    let mut suggestions = vec![];\n-                    // account for `\"` and account for raw strings `r#`\n-                    let padding = str_style.map(|i| i + 2).unwrap_or(1);\n-                    for sub in foreign::$kind::iter_subs(fmt_str, padding) {\n-                        let (trn, success) = match sub.translate() {\n-                            Ok(trn) => (trn, true),\n-                            Err(Some(msg)) => (msg, false),\n-\n-                            // If it has no translation, don't call it out specifically.\n-                            _ => continue,\n-                        };\n-\n-                        let pos = sub.position();\n-                        let sub = String::from(sub.as_str());\n-                        if explained.contains(&sub) {\n-                            continue;\n-                        }\n-                        explained.insert(sub.clone());\n+    Ok(FormatArgs { span: fmt_span, template, arguments: args })\n+}\n \n-                        if !found_foreign {\n-                            found_foreign = true;\n-                            show_doc_note = true;\n-                        }\n+fn invalid_placeholder_type_error(\n+    ecx: &ExtCtxt<'_>,\n+    ty: &str,\n+    ty_span: Option<rustc_parse_format::InnerSpan>,\n+    fmt_span: Span,\n+) {\n+    let sp = ty_span.map(|sp| fmt_span.from_inner(InnerSpan::new(sp.start, sp.end)));\n+    let mut err =\n+        ecx.struct_span_err(sp.unwrap_or(fmt_span), &format!(\"unknown format trait `{}`\", ty));\n+    err.note(\n+        \"the only appropriate formatting traits are:\\n\\\n+                                - ``, which uses the `Display` trait\\n\\\n+                                - `?`, which uses the `Debug` trait\\n\\\n+                                - `e`, which uses the `LowerExp` trait\\n\\\n+                                - `E`, which uses the `UpperExp` trait\\n\\\n+                                - `o`, which uses the `Octal` trait\\n\\\n+                                - `p`, which uses the `Pointer` trait\\n\\\n+                                - `b`, which uses the `Binary` trait\\n\\\n+                                - `x`, which uses the `LowerHex` trait\\n\\\n+                                - `X`, which uses the `UpperHex` trait\",\n+    );\n+    if let Some(sp) = sp {\n+        for (fmt, name) in &[\n+            (\"\", \"Display\"),\n+            (\"?\", \"Debug\"),\n+            (\"e\", \"LowerExp\"),\n+            (\"E\", \"UpperExp\"),\n+            (\"o\", \"Octal\"),\n+            (\"p\", \"Pointer\"),\n+            (\"b\", \"Binary\"),\n+            (\"x\", \"LowerHex\"),\n+            (\"X\", \"UpperHex\"),\n+        ] {\n+            err.tool_only_span_suggestion(\n+                sp,\n+                &format!(\"use the `{}` trait\", name),\n+                *fmt,\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+    }\n+    err.emit();\n+}\n \n-                        if let Some(inner_sp) = pos {\n-                            let sp = fmt_sp.from_inner(inner_sp);\n-\n-                            if success {\n-                                suggestions.push((sp, trn));\n-                            } else {\n-                                diag.span_note(\n-                                    sp,\n-                                    &format!(\"format specifiers use curly braces, and {}\", trn),\n-                                );\n-                            }\n-                        } else {\n-                            if success {\n-                                diag.help(&format!(\"`{}` should be written as `{}`\", sub, trn));\n-                            } else {\n-                                diag.note(&format!(\n-                                    \"`{}` should use curly braces, and {}\",\n-                                    sub, trn\n-                                ));\n-                            }\n-                        }\n+fn report_missing_placeholders(\n+    ecx: &mut ExtCtxt<'_>,\n+    unused: Vec<(Span, &str)>,\n+    detect_foreign_fmt: bool,\n+    str_style: Option<usize>,\n+    fmt_str: &str,\n+    fmt_span: Span,\n+) {\n+    let mut diag = if let &[(span, msg)] = &unused[..] {\n+        let mut diag = ecx.struct_span_err(span, msg);\n+        diag.span_label(span, msg);\n+        diag\n+    } else {\n+        let mut diag = ecx.struct_span_err(\n+            unused.iter().map(|&(sp, _)| sp).collect::<Vec<Span>>(),\n+            \"multiple unused formatting arguments\",\n+        );\n+        diag.span_label(fmt_span, \"multiple missing formatting specifiers\");\n+        for &(span, msg) in &unused {\n+            diag.span_label(span, msg);\n+        }\n+        diag\n+    };\n+\n+    // Used to ensure we only report translations for *one* kind of foreign format.\n+    let mut found_foreign = false;\n+\n+    // Decide if we want to look for foreign formatting directives.\n+    if detect_foreign_fmt {\n+        use super::format_foreign as foreign;\n+\n+        // The set of foreign substitutions we've explained.  This prevents spamming the user\n+        // with `%d should be written as {}` over and over again.\n+        let mut explained = FxHashSet::default();\n+\n+        macro_rules! check_foreign {\n+            ($kind:ident) => {{\n+                let mut show_doc_note = false;\n+\n+                let mut suggestions = vec![];\n+                // account for `\"` and account for raw strings `r#`\n+                let padding = str_style.map(|i| i + 2).unwrap_or(1);\n+                for sub in foreign::$kind::iter_subs(fmt_str, padding) {\n+                    let (trn, success) = match sub.translate() {\n+                        Ok(trn) => (trn, true),\n+                        Err(Some(msg)) => (msg, false),\n+\n+                        // If it has no translation, don't call it out specifically.\n+                        _ => continue,\n+                    };\n+\n+                    let pos = sub.position();\n+                    let sub = String::from(sub.as_str());\n+                    if explained.contains(&sub) {\n+                        continue;\n                     }\n+                    explained.insert(sub.clone());\n \n-                    if show_doc_note {\n-                        diag.note(concat!(\n-                            stringify!($kind),\n-                            \" formatting not supported; see the documentation for `std::fmt`\",\n-                        ));\n+                    if !found_foreign {\n+                        found_foreign = true;\n+                        show_doc_note = true;\n                     }\n-                    if suggestions.len() > 0 {\n-                        diag.multipart_suggestion(\n-                            \"format specifiers use curly braces\",\n-                            suggestions,\n-                            Applicability::MachineApplicable,\n-                        );\n+\n+                    if let Some(inner_sp) = pos {\n+                        let sp = fmt_span.from_inner(inner_sp);\n+\n+                        if success {\n+                            suggestions.push((sp, trn));\n+                        } else {\n+                            diag.span_note(\n+                                sp,\n+                                &format!(\"format specifiers use curly braces, and {}\", trn),\n+                            );\n+                        }\n+                    } else {\n+                        if success {\n+                            diag.help(&format!(\"`{}` should be written as `{}`\", sub, trn));\n+                        } else {\n+                            diag.note(&format!(\"`{}` should use curly braces, and {}\", sub, trn));\n+                        }\n                     }\n-                }};\n-            }\n+                }\n \n-            check_foreign!(printf);\n-            if !found_foreign {\n-                check_foreign!(shell);\n-            }\n-        }\n-        if !found_foreign && errs_len == 1 {\n-            diag.span_label(cx.fmtsp, \"formatting specifier missing\");\n+                if show_doc_note {\n+                    diag.note(concat!(\n+                        stringify!($kind),\n+                        \" formatting not supported; see the documentation for `std::fmt`\",\n+                    ));\n+                }\n+                if suggestions.len() > 0 {\n+                    diag.multipart_suggestion(\n+                        \"format specifiers use curly braces\",\n+                        suggestions,\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }};\n         }\n \n-        diag.emit();\n-    } else if cx.invalid_refs.is_empty() && cx.ecx.sess.err_count() == 0 {\n-        // Only check for unused named argument names if there are no other errors to avoid causing\n-        // too much noise in output errors, such as when a named argument is entirely unused.\n-        create_lints_for_named_arguments_used_positionally(&mut cx);\n+        check_foreign!(printf);\n+        if !found_foreign {\n+            check_foreign!(shell);\n+        }\n+    }\n+    if !found_foreign && unused.len() == 1 {\n+        diag.span_label(fmt_span, \"formatting specifier missing\");\n     }\n \n-    cx.into_expr()\n+    diag.emit();\n }\n \n-fn may_contain_yield_point(e: &ast::Expr) -> bool {\n-    struct MayContainYieldPoint(bool);\n+/// Handle invalid references to positional arguments. Output different\n+/// errors for the case where all arguments are positional and for when\n+/// there are named arguments or numbered positional arguments in the\n+/// format string.\n+fn report_invalid_references(\n+    ecx: &mut ExtCtxt<'_>,\n+    invalid_refs: &[(usize, Option<Span>, PositionUsedAs, FormatArgPositionKind)],\n+    template: &[FormatArgsPiece],\n+    fmt_span: Span,\n+    num_explicit_args: usize,\n+    args: &[(P<ast::Expr>, FormatArgKind)],\n+    parser: parse::Parser<'_>,\n+) {\n+    let num_args_desc = match num_explicit_args {\n+        0 => \"no arguments were given\".to_string(),\n+        1 => \"there is 1 argument\".to_string(),\n+        n => format!(\"there are {} arguments\", n),\n+    };\n \n-    impl Visitor<'_> for MayContainYieldPoint {\n-        fn visit_expr(&mut self, e: &ast::Expr) {\n-            if let ast::ExprKind::Await(_) | ast::ExprKind::Yield(_) = e.kind {\n-                self.0 = true;\n-            } else {\n-                visit::walk_expr(self, e);\n+    let mut e;\n+\n+    if template.iter().all(|piece| match piece {\n+        FormatArgsPiece::Placeholder(FormatPlaceholder {\n+            argument: FormatArgPosition { kind: FormatArgPositionKind::Number, .. },\n+            ..\n+        }) => false,\n+        FormatArgsPiece::Placeholder(FormatPlaceholder {\n+            format_options:\n+                FormatOptions {\n+                    precision:\n+                        Some(FormatCount::Argument(FormatArgPosition {\n+                            kind: FormatArgPositionKind::Number,\n+                            ..\n+                        })),\n+                    ..\n+                }\n+                | FormatOptions {\n+                    width:\n+                        Some(FormatCount::Argument(FormatArgPosition {\n+                            kind: FormatArgPositionKind::Number,\n+                            ..\n+                        })),\n+                    ..\n+                },\n+            ..\n+        }) => false,\n+        _ => true,\n+    }) {\n+        // There are no numeric positions.\n+        // Collect all the implicit positions:\n+        let mut spans = Vec::new();\n+        let mut num_placeholders = 0;\n+        for piece in template {\n+            let mut placeholder = None;\n+            // `{arg:.*}`\n+            if let FormatArgsPiece::Placeholder(FormatPlaceholder {\n+                format_options:\n+                    FormatOptions {\n+                        precision:\n+                            Some(FormatCount::Argument(FormatArgPosition {\n+                                span,\n+                                kind: FormatArgPositionKind::Implicit,\n+                                ..\n+                            })),\n+                        ..\n+                    },\n+                ..\n+            }) = piece\n+            {\n+                placeholder = *span;\n+                num_placeholders += 1;\n+            }\n+            // `{}`\n+            if let FormatArgsPiece::Placeholder(FormatPlaceholder {\n+                argument: FormatArgPosition { kind: FormatArgPositionKind::Implicit, .. },\n+                span,\n+                ..\n+            }) = piece\n+            {\n+                placeholder = *span;\n+                num_placeholders += 1;\n             }\n+            // For `{:.*}`, we only push one span.\n+            spans.extend(placeholder);\n         }\n-\n-        fn visit_mac_call(&mut self, _: &ast::MacCall) {\n-            self.0 = true;\n+        let span = if spans.is_empty() {\n+            MultiSpan::from_span(fmt_span)\n+        } else {\n+            MultiSpan::from_spans(spans)\n+        };\n+        e = ecx.struct_span_err(\n+            span,\n+            &format!(\n+                \"{} positional argument{} in format string, but {}\",\n+                num_placeholders,\n+                pluralize!(num_placeholders),\n+                num_args_desc,\n+            ),\n+        );\n+        for (arg, _) in &args[..num_explicit_args] {\n+            e.span_label(arg.span, \"\");\n+        }\n+        // Point out `{:.*}` placeholders: those take an extra argument.\n+        let mut has_precision_star = false;\n+        for piece in template {\n+            if let FormatArgsPiece::Placeholder(FormatPlaceholder {\n+                format_options:\n+                    FormatOptions {\n+                        precision:\n+                            Some(FormatCount::Argument(FormatArgPosition {\n+                                index,\n+                                span: Some(span),\n+                                kind: FormatArgPositionKind::Implicit,\n+                                ..\n+                            })),\n+                        ..\n+                    },\n+                ..\n+            }) = piece\n+            {\n+                let (Ok(index) | Err(index)) = index;\n+                has_precision_star = true;\n+                e.span_label(\n+                    *span,\n+                    &format!(\n+                        \"this precision flag adds an extra required argument at position {}, which is why there {} expected\",\n+                        index,\n+                        if num_placeholders == 1 {\n+                            \"is 1 argument\".to_string()\n+                        } else {\n+                            format!(\"are {} arguments\", num_placeholders)\n+                        },\n+                    ),\n+                );\n+            }\n+        }\n+        if has_precision_star {\n+            e.note(\"positional arguments are zero-based\");\n         }\n+    } else {\n+        let mut indexes: Vec<_> = invalid_refs.iter().map(|&(index, _, _, _)| index).collect();\n+        // Avoid `invalid reference to positional arguments 7 and 7 (there is 1 argument)`\n+        // for `println!(\"{7:7$}\", 1);`\n+        indexes.sort();\n+        indexes.dedup();\n+        let span: MultiSpan = if !parser.is_literal || parser.arg_places.is_empty() {\n+            MultiSpan::from_span(fmt_span)\n+        } else {\n+            MultiSpan::from_spans(invalid_refs.iter().filter_map(|&(_, span, _, _)| span).collect())\n+        };\n+        let arg_list = if let &[index] = &indexes[..] {\n+            format!(\"argument {index}\")\n+        } else {\n+            let tail = indexes.pop().unwrap();\n+            format!(\n+                \"arguments {head} and {tail}\",\n+                head = indexes.into_iter().map(|i| i.to_string()).collect::<Vec<_>>().join(\", \")\n+            )\n+        };\n+        e = ecx.struct_span_err(\n+            span,\n+            &format!(\"invalid reference to positional {} ({})\", arg_list, num_args_desc),\n+        );\n+        e.note(\"positional arguments are zero-based\");\n+    }\n \n-        fn visit_attribute(&mut self, _: &ast::Attribute) {\n-            // Conservatively assume this may be a proc macro attribute in\n-            // expression position.\n-            self.0 = true;\n+    if template.iter().any(|piece| match piece {\n+        FormatArgsPiece::Placeholder(FormatPlaceholder { format_options: f, .. }) => {\n+            *f != FormatOptions::default()\n         }\n+        _ => false,\n+    }) {\n+        e.note(\"for information about formatting flags, visit https://doc.rust-lang.org/std/fmt/index.html\");\n+    }\n+\n+    e.emit();\n+}\n \n-        fn visit_item(&mut self, _: &ast::Item) {\n-            // Do not recurse into nested items.\n+fn expand_format_args_impl<'cx>(\n+    ecx: &'cx mut ExtCtxt<'_>,\n+    mut sp: Span,\n+    tts: TokenStream,\n+    nl: bool,\n+) -> Box<dyn base::MacResult + 'cx> {\n+    sp = ecx.with_def_site_ctxt(sp);\n+    match parse_args(ecx, sp, tts) {\n+        Ok((efmt, args)) => {\n+            if let Ok(format_args) = make_format_args(ecx, efmt, args, nl) {\n+                MacEager::expr(expand_parsed_format_args(ecx, format_args))\n+            } else {\n+                MacEager::expr(DummyResult::raw_expr(sp, true))\n+            }\n+        }\n+        Err(mut err) => {\n+            err.emit();\n+            DummyResult::any(sp)\n         }\n     }\n+}\n \n-    let mut visitor = MayContainYieldPoint(false);\n-    visitor.visit_expr(e);\n-    visitor.0\n+pub fn expand_format_args<'cx>(\n+    ecx: &'cx mut ExtCtxt<'_>,\n+    sp: Span,\n+    tts: TokenStream,\n+) -> Box<dyn base::MacResult + 'cx> {\n+    expand_format_args_impl(ecx, sp, tts, false)\n+}\n+\n+pub fn expand_format_args_nl<'cx>(\n+    ecx: &'cx mut ExtCtxt<'_>,\n+    sp: Span,\n+    tts: TokenStream,\n+) -> Box<dyn base::MacResult + 'cx> {\n+    expand_format_args_impl(ecx, sp, tts, true)\n }"}, {"sha": "d1c114a67ac1eac94890caf0dca6b91c32129bd0", "filename": "compiler/rustc_builtin_macros/src/format/expand.rs", "status": "added", "additions": 352, "deletions": 0, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/9bec0de3977e589fb92fc85ce9bc8fa99c3691f6/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bec0de3977e589fb92fc85ce9bc8fa99c3691f6/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fexpand.rs?ref=9bec0de3977e589fb92fc85ce9bc8fa99c3691f6", "patch": "@@ -0,0 +1,352 @@\n+use super::*;\n+use rustc_ast as ast;\n+use rustc_ast::visit::{self, Visitor};\n+use rustc_ast::{BlockCheckMode, UnsafeSource};\n+use rustc_data_structures::fx::FxIndexSet;\n+use rustc_span::{sym, symbol::kw};\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+enum ArgumentType {\n+    Format(FormatTrait),\n+    Usize,\n+}\n+\n+fn make_argument(ecx: &ExtCtxt<'_>, sp: Span, arg: P<ast::Expr>, ty: ArgumentType) -> P<ast::Expr> {\n+    // Generate:\n+    //     ::core::fmt::ArgumentV1::new_\u2026(arg)\n+    use ArgumentType::*;\n+    use FormatTrait::*;\n+    ecx.expr_call_global(\n+        sp,\n+        ecx.std_path(&[\n+            sym::fmt,\n+            sym::ArgumentV1,\n+            match ty {\n+                Format(Display) => sym::new_display,\n+                Format(Debug) => sym::new_debug,\n+                Format(LowerExp) => sym::new_lower_exp,\n+                Format(UpperExp) => sym::new_upper_exp,\n+                Format(Octal) => sym::new_octal,\n+                Format(Pointer) => sym::new_pointer,\n+                Format(Binary) => sym::new_binary,\n+                Format(LowerHex) => sym::new_lower_hex,\n+                Format(UpperHex) => sym::new_upper_hex,\n+                Usize => sym::from_usize,\n+            },\n+        ]),\n+        vec![arg],\n+    )\n+}\n+\n+fn make_count(\n+    ecx: &ExtCtxt<'_>,\n+    sp: Span,\n+    count: &Option<FormatCount>,\n+    argmap: &mut FxIndexSet<(usize, ArgumentType)>,\n+) -> P<ast::Expr> {\n+    // Generate:\n+    //     ::core::fmt::rt::v1::Count::\u2026(\u2026)\n+    match count {\n+        Some(FormatCount::Literal(n)) => ecx.expr_call_global(\n+            sp,\n+            ecx.std_path(&[sym::fmt, sym::rt, sym::v1, sym::Count, sym::Is]),\n+            vec![ecx.expr_usize(sp, *n)],\n+        ),\n+        Some(FormatCount::Argument(arg)) => {\n+            if let Ok(arg_index) = arg.index {\n+                let (i, _) = argmap.insert_full((arg_index, ArgumentType::Usize));\n+                ecx.expr_call_global(\n+                    sp,\n+                    ecx.std_path(&[sym::fmt, sym::rt, sym::v1, sym::Count, sym::Param]),\n+                    vec![ecx.expr_usize(sp, i)],\n+                )\n+            } else {\n+                DummyResult::raw_expr(sp, true)\n+            }\n+        }\n+        None => ecx.expr_path(ecx.path_global(\n+            sp,\n+            ecx.std_path(&[sym::fmt, sym::rt, sym::v1, sym::Count, sym::Implied]),\n+        )),\n+    }\n+}\n+\n+fn make_format_spec(\n+    ecx: &ExtCtxt<'_>,\n+    sp: Span,\n+    placeholder: &FormatPlaceholder,\n+    argmap: &mut FxIndexSet<(usize, ArgumentType)>,\n+) -> P<ast::Expr> {\n+    // Generate:\n+    //     ::core::fmt::rt::v1::Argument {\n+    //         position: 0usize,\n+    //         format: ::core::fmt::rt::v1::FormatSpec {\n+    //             fill: ' ',\n+    //             align: ::core::fmt::rt::v1::Alignment::Unknown,\n+    //             flags: 0u32,\n+    //             precision: ::core::fmt::rt::v1::Count::Implied,\n+    //             width: ::core::fmt::rt::v1::Count::Implied,\n+    //         },\n+    //     }\n+    let position = match placeholder.argument.index {\n+        Ok(arg_index) => {\n+            let (i, _) =\n+                argmap.insert_full((arg_index, ArgumentType::Format(placeholder.format_trait)));\n+            ecx.expr_usize(sp, i)\n+        }\n+        Err(_) => DummyResult::raw_expr(sp, true),\n+    };\n+    let fill = ecx.expr_char(sp, placeholder.format_options.fill.unwrap_or(' '));\n+    let align = ecx.expr_path(ecx.path_global(\n+        sp,\n+        ecx.std_path(&[\n+            sym::fmt,\n+            sym::rt,\n+            sym::v1,\n+            sym::Alignment,\n+            match placeholder.format_options.alignment {\n+                Some(FormatAlignment::Left) => sym::Left,\n+                Some(FormatAlignment::Right) => sym::Right,\n+                Some(FormatAlignment::Center) => sym::Center,\n+                None => sym::Unknown,\n+            },\n+        ]),\n+    ));\n+    let flags = ecx.expr_u32(sp, placeholder.format_options.flags);\n+    let prec = make_count(ecx, sp, &placeholder.format_options.precision, argmap);\n+    let width = make_count(ecx, sp, &placeholder.format_options.width, argmap);\n+    ecx.expr_struct(\n+        sp,\n+        ecx.path_global(sp, ecx.std_path(&[sym::fmt, sym::rt, sym::v1, sym::Argument])),\n+        vec![\n+            ecx.field_imm(sp, Ident::new(sym::position, sp), position),\n+            ecx.field_imm(\n+                sp,\n+                Ident::new(sym::format, sp),\n+                ecx.expr_struct(\n+                    sp,\n+                    ecx.path_global(\n+                        sp,\n+                        ecx.std_path(&[sym::fmt, sym::rt, sym::v1, sym::FormatSpec]),\n+                    ),\n+                    vec![\n+                        ecx.field_imm(sp, Ident::new(sym::fill, sp), fill),\n+                        ecx.field_imm(sp, Ident::new(sym::align, sp), align),\n+                        ecx.field_imm(sp, Ident::new(sym::flags, sp), flags),\n+                        ecx.field_imm(sp, Ident::new(sym::precision, sp), prec),\n+                        ecx.field_imm(sp, Ident::new(sym::width, sp), width),\n+                    ],\n+                ),\n+            ),\n+        ],\n+    )\n+}\n+\n+pub fn expand_parsed_format_args(ecx: &mut ExtCtxt<'_>, fmt: FormatArgs) -> P<ast::Expr> {\n+    let macsp = ecx.with_def_site_ctxt(ecx.call_site());\n+\n+    let lit_pieces = ecx.expr_array_ref(\n+        fmt.span,\n+        fmt.template\n+            .iter()\n+            .enumerate()\n+            .filter_map(|(i, piece)| match piece {\n+                &FormatArgsPiece::Literal(s) => Some(ecx.expr_str(fmt.span, s)),\n+                &FormatArgsPiece::Placeholder(_) => {\n+                    // Inject empty string before placeholders when not already preceded by a literal piece.\n+                    if i == 0 || matches!(fmt.template[i - 1], FormatArgsPiece::Placeholder(_)) {\n+                        Some(ecx.expr_str(fmt.span, kw::Empty))\n+                    } else {\n+                        None\n+                    }\n+                }\n+            })\n+            .collect(),\n+    );\n+\n+    let has_any_format_options = fmt.template.iter().any(|piece| {\n+        let FormatArgsPiece::Placeholder(placeholder) = piece else { return false };\n+        placeholder.format_options != Default::default()\n+    });\n+\n+    let (args, format_options) = if has_any_format_options {\n+        // Create a list of all _unique_ (argument, format trait) combinations.\n+        // E.g. \"{0} {0:x} {0} {1}\" -> [(0, Display), (0, LowerHex), (1, Display)]\n+        let mut argmap = FxIndexSet::default();\n+        // Generate:\n+        //     &[format_spec_0, format_spec_1, format_spec_2]\n+        let format_options = ecx.expr_array_ref(\n+            macsp,\n+            fmt.template\n+                .iter()\n+                .filter_map(|piece| {\n+                    let FormatArgsPiece::Placeholder(placeholder) = piece else { return None };\n+                    Some(make_format_spec(ecx, macsp, placeholder, &mut argmap))\n+                })\n+                .collect(),\n+        );\n+        (Vec::from_iter(argmap), Some(format_options))\n+    } else {\n+        // Create a list of all (argument, format trait) pairs, one for each placeholder.\n+        // E.g. \"{0} {0:x} {0} {1}\" -> [(0, Display), (0, LowerHex), (0, Display), (1, Display)]\n+        let args = fmt\n+            .template\n+            .iter()\n+            .filter_map(|piece| {\n+                let FormatArgsPiece::Placeholder(placeholder) = piece else { return None };\n+                Some((\n+                    placeholder.argument.index.ok()?,\n+                    ArgumentType::Format(placeholder.format_trait),\n+                ))\n+            })\n+            .collect();\n+        (args, None)\n+    };\n+\n+    // If the args array contains exactly all the original arguments once,\n+    // in order, we can use a simple array instead of a `match` construction.\n+    // However, if there's a yield point in any argument except the first one,\n+    // we don't do this, because an ArgumentV1 cannot be kept across yield points.\n+    let use_simple_array = args.len() == fmt.arguments.len()\n+        && args.iter().enumerate().all(|(i, &(j, _))| i == j)\n+        && fmt.arguments.iter().skip(1).all(|(arg, _)| !may_contain_yield_point(arg));\n+\n+    let args_expr = if use_simple_array {\n+        // Generate:\n+        //     &[\n+        //         ::core::fmt::ArgumentV1::new_display(&arg0),\n+        //         ::core::fmt::ArgumentV1::new_lower_hex(&arg1),\n+        //         ::core::fmt::ArgumentV1::new_debug(&arg2),\n+        //     ]\n+        ecx.expr_array_ref(\n+            macsp,\n+            fmt.arguments\n+                .into_iter()\n+                .zip(args)\n+                .map(|((arg, _), (_, ty))| {\n+                    let sp = arg.span.with_ctxt(macsp.ctxt());\n+                    make_argument(ecx, sp, ecx.expr_addr_of(sp, arg), ty)\n+                })\n+                .collect(),\n+        )\n+    } else {\n+        // Generate:\n+        //     match (&arg0, &arg1, &arg2) {\n+        //         args => &[\n+        //             ::core::fmt::ArgumentV1::new_display(args.0),\n+        //             ::core::fmt::ArgumentV1::new_lower_hex(args.1),\n+        //             ::core::fmt::ArgumentV1::new_debug(args.0),\n+        //         ]\n+        //     }\n+        let args_ident = Ident::new(sym::args, macsp);\n+        let args = args\n+            .iter()\n+            .map(|&(arg_index, ty)| {\n+                if let Some((arg, _)) = fmt.arguments.get(arg_index) {\n+                    let sp = arg.span.with_ctxt(macsp.ctxt());\n+                    make_argument(\n+                        ecx,\n+                        sp,\n+                        ecx.expr_field(\n+                            sp,\n+                            ecx.expr_ident(macsp, args_ident),\n+                            Ident::new(sym::integer(arg_index), macsp),\n+                        ),\n+                        ty,\n+                    )\n+                } else {\n+                    DummyResult::raw_expr(macsp, true)\n+                }\n+            })\n+            .collect();\n+        ecx.expr_addr_of(\n+            macsp,\n+            ecx.expr_match(\n+                macsp,\n+                ecx.expr_tuple(\n+                    macsp,\n+                    fmt.arguments\n+                        .into_iter()\n+                        .map(|(arg, _)| ecx.expr_addr_of(arg.span.with_ctxt(macsp.ctxt()), arg))\n+                        .collect(),\n+                ),\n+                [ecx.arm(macsp, ecx.pat_ident(macsp, args_ident), ecx.expr_array(macsp, args))]\n+                    .into(),\n+            ),\n+        )\n+    };\n+\n+    if let Some(format_options) = format_options {\n+        // Generate:\n+        //     ::core::fmt::Arguments::new_v1_formatted(\n+        //         lit_pieces,\n+        //         args,\n+        //         format_options,\n+        //         unsafe { ::core::fmt::UnsafeArg::new() }\n+        //     )\n+        ecx.expr_call_global(\n+            macsp,\n+            ecx.std_path(&[sym::fmt, sym::Arguments, sym::new_v1_formatted]),\n+            vec![\n+                lit_pieces,\n+                args_expr,\n+                format_options,\n+                ecx.expr_block(P(ast::Block {\n+                    stmts: vec![ecx.stmt_expr(ecx.expr_call_global(\n+                        macsp,\n+                        ecx.std_path(&[sym::fmt, sym::UnsafeArg, sym::new]),\n+                        Vec::new(),\n+                    ))],\n+                    id: ast::DUMMY_NODE_ID,\n+                    rules: BlockCheckMode::Unsafe(UnsafeSource::CompilerGenerated),\n+                    span: macsp,\n+                    tokens: None,\n+                    could_be_bare_literal: false,\n+                })),\n+            ],\n+        )\n+    } else {\n+        // Generate:\n+        //     ::core::fmt::Arguments::new_v1(\n+        //         lit_pieces,\n+        //         args,\n+        //     )\n+        ecx.expr_call_global(\n+            macsp,\n+            ecx.std_path(&[sym::fmt, sym::Arguments, sym::new_v1]),\n+            vec![lit_pieces, args_expr],\n+        )\n+    }\n+}\n+\n+fn may_contain_yield_point(e: &ast::Expr) -> bool {\n+    struct MayContainYieldPoint(bool);\n+\n+    impl Visitor<'_> for MayContainYieldPoint {\n+        fn visit_expr(&mut self, e: &ast::Expr) {\n+            if let ast::ExprKind::Await(_) | ast::ExprKind::Yield(_) = e.kind {\n+                self.0 = true;\n+            } else {\n+                visit::walk_expr(self, e);\n+            }\n+        }\n+\n+        fn visit_mac_call(&mut self, _: &ast::MacCall) {\n+            self.0 = true;\n+        }\n+\n+        fn visit_attribute(&mut self, _: &ast::Attribute) {\n+            // Conservatively assume this may be a proc macro attribute in\n+            // expression position.\n+            self.0 = true;\n+        }\n+\n+        fn visit_item(&mut self, _: &ast::Item) {\n+            // Do not recurse into nested items.\n+        }\n+    }\n+\n+    let mut visitor = MayContainYieldPoint(false);\n+    visitor.visit_expr(e);\n+    visitor.0\n+}"}, {"sha": "f058503064bf1e0c423aad2f2cf911dc75b063c9", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9bec0de3977e589fb92fc85ce9bc8fa99c3691f6/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bec0de3977e589fb92fc85ce9bc8fa99c3691f6/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=9bec0de3977e589fb92fc85ce9bc8fa99c3691f6", "patch": "@@ -7,6 +7,7 @@\n #![feature(box_patterns)]\n #![feature(decl_macro)]\n #![feature(if_let_guard)]\n+#![feature(is_some_with)]\n #![feature(is_sorted)]\n #![feature(let_chains)]\n #![feature(proc_macro_internals)]"}, {"sha": "0952e65cfee3d590b3643a1d2d96a33acfacd190", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9bec0de3977e589fb92fc85ce9bc8fa99c3691f6/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bec0de3977e589fb92fc85ce9bc8fa99c3691f6/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=9bec0de3977e589fb92fc85ce9bc8fa99c3691f6", "patch": "@@ -252,6 +252,10 @@ impl<'a> ExtCtxt<'a> {\n         self.expr_ident(span, Ident::with_dummy_span(kw::SelfLower))\n     }\n \n+    pub fn expr_field(&self, span: Span, expr: P<Expr>, field: Ident) -> P<ast::Expr> {\n+        self.expr(span, ast::ExprKind::Field(expr, field))\n+    }\n+\n     pub fn expr_binary(\n         &self,\n         sp: Span,"}, {"sha": "7657f9486c227b70257cc42f56018118ededff4a", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9bec0de3977e589fb92fc85ce9bc8fa99c3691f6/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bec0de3977e589fb92fc85ce9bc8fa99c3691f6/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=9bec0de3977e589fb92fc85ce9bc8fa99c3691f6", "patch": "@@ -991,7 +991,18 @@ symbols! {\n         never_type,\n         never_type_fallback,\n         new,\n+        new_binary,\n+        new_debug,\n+        new_display,\n+        new_lower_exp,\n+        new_lower_hex,\n+        new_octal,\n+        new_pointer,\n         new_unchecked,\n+        new_upper_exp,\n+        new_upper_hex,\n+        new_v1,\n+        new_v1_formatted,\n         next,\n         nll,\n         no,"}, {"sha": "af645c2ba3ad782ad7d7cf6d7c7469995ad963f4", "filename": "src/test/ui/fmt/ifmt-bad-arg.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9bec0de3977e589fb92fc85ce9bc8fa99c3691f6/src%2Ftest%2Fui%2Ffmt%2Fifmt-bad-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9bec0de3977e589fb92fc85ce9bc8fa99c3691f6/src%2Ftest%2Fui%2Ffmt%2Fifmt-bad-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fifmt-bad-arg.stderr?ref=9bec0de3977e589fb92fc85ce9bc8fa99c3691f6", "patch": "@@ -117,20 +117,20 @@ LL |     format!(\"{} {}\", 1, 2, foo=1, bar=2);\n    |             multiple missing formatting specifiers\n \n error: duplicate argument named `foo`\n-  --> $DIR/ifmt-bad-arg.rs:40:33\n+  --> $DIR/ifmt-bad-arg.rs:40:29\n    |\n LL |     format!(\"{foo}\", foo=1, foo=2);\n-   |                          -      ^ duplicate argument\n-   |                          |\n-   |                          previously here\n+   |                      ---    ^^^ duplicate argument\n+   |                      |\n+   |                      previously here\n \n error: positional arguments cannot follow named arguments\n   --> $DIR/ifmt-bad-arg.rs:41:35\n    |\n LL |     format!(\"{foo} {} {}\", foo=1, 2);\n-   |                                -  ^ positional arguments must be before named arguments\n-   |                                |\n-   |                                named argument\n+   |                            -----  ^ positional arguments must be before named arguments\n+   |                            |\n+   |                            named argument\n \n error: named argument never used\n   --> $DIR/ifmt-bad-arg.rs:45:51"}, {"sha": "f9ea4c63377b09493f0d001f7e89b3087c1f9156", "filename": "src/test/ui/macros/format-parse-errors.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9bec0de3977e589fb92fc85ce9bc8fa99c3691f6/src%2Ftest%2Fui%2Fmacros%2Fformat-parse-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9bec0de3977e589fb92fc85ce9bc8fa99c3691f6/src%2Ftest%2Fui%2Fmacros%2Fformat-parse-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fformat-parse-errors.stderr?ref=9bec0de3977e589fb92fc85ce9bc8fa99c3691f6", "patch": "@@ -22,7 +22,7 @@ error: positional arguments cannot follow named arguments\n   --> $DIR/format-parse-errors.rs:10:9\n    |\n LL |         foo = foo,\n-   |               --- named argument\n+   |         --------- named argument\n LL |         bar,\n    |         ^^^ positional arguments must be before named arguments\n "}]}