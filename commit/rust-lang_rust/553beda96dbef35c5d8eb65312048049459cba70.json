{"sha": "553beda96dbef35c5d8eb65312048049459cba70", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1M2JlZGE5NmRiZWYzNWM1ZDhlYjY1MzEyMDQ4MDQ5NDU5Y2JhNzA=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-07-07T00:13:39Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-07-07T00:16:53Z"}, "message": "Add span information to create_vtbl and friends.", "tree": {"sha": "b5c3b7ab904b7fd1d6df5103014cb463b666a135", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5c3b7ab904b7fd1d6df5103014cb463b666a135"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/553beda96dbef35c5d8eb65312048049459cba70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/553beda96dbef35c5d8eb65312048049459cba70", "html_url": "https://github.com/rust-lang/rust/commit/553beda96dbef35c5d8eb65312048049459cba70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/553beda96dbef35c5d8eb65312048049459cba70/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41f6a3d5e1d18a1aa4e4537923768dc072807413", "url": "https://api.github.com/repos/rust-lang/rust/commits/41f6a3d5e1d18a1aa4e4537923768dc072807413", "html_url": "https://github.com/rust-lang/rust/commit/41f6a3d5e1d18a1aa4e4537923768dc072807413"}], "stats": {"total": 32, "additions": 14, "deletions": 18}, "files": [{"sha": "da21043e56ac039520382169681dd5b3ea632daa", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/553beda96dbef35c5d8eb65312048049459cba70/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553beda96dbef35c5d8eb65312048049459cba70/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=553beda96dbef35c5d8eb65312048049459cba70", "patch": "@@ -7022,7 +7022,7 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n             // create_vtbl() with no \"additional methods\".  What's happening\n             // is that, since *all* of the methods are \"additional\", we can\n             // get away with acting like none of them are.\n-            vtbl = create_vtbl(bcx.fcx.lcx, llouter_obj_ty, outer_obj_ty,\n+            vtbl = create_vtbl(bcx.fcx.lcx, sp, llouter_obj_ty, outer_obj_ty,\n                                wrapper_obj, ty_params, none,\n                                additional_field_tys);\n         }\n@@ -7045,7 +7045,7 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n             // one with a matching name and type being added, we'll need to\n             // create a forwarding slot.  And, of course, we need to create a\n             // normal vtable entry for every method being added.\n-            vtbl = create_vtbl(bcx.fcx.lcx, llouter_obj_ty, outer_obj_ty,\n+            vtbl = create_vtbl(bcx.fcx.lcx, sp, llouter_obj_ty, outer_obj_ty,\n                                wrapper_obj, ty_params, \n                                some(with_obj_ty),\n                                additional_field_tys);\n@@ -7822,8 +7822,9 @@ fn trans_fn(@local_ctxt cx, &span sp, &ast::_fn f, ValueRef llfndecl,\n // process_fwding_mthd: Create the forwarding function that appears in a\n // vtable slot for method calls that \"fall through\" to an inner object.  A\n // helper function for create_vtbl.\n-fn process_fwding_mthd(@local_ctxt cx, @ty::method m, TypeRef llself_ty,\n-                       ty::t self_ty, &vec[ast::ty_param] ty_params,\n+fn process_fwding_mthd(@local_ctxt cx, &span sp, @ty::method m, \n+                       TypeRef llself_ty, ty::t self_ty,\n+                       &vec[ast::ty_param] ty_params,\n                        ty::t with_obj_ty,\n                        ty::t[] additional_field_tys) -> ValueRef {\n \n@@ -7840,11 +7841,6 @@ fn process_fwding_mthd(@local_ctxt cx, @ty::method m, TypeRef llself_ty,\n     // on.  That object won't exist until run-time, but we know its type\n     // statically.\n \n-    // Create a fake span for functions that expect it.  Shouldn't matter what\n-    // it is, since this isn't user-written code.  (Possibly better: have\n-    // create_vtable take a span argument and pass it in here?)\n-    let span fake_span = rec(lo=0u,hi=0u);\n-\n     // Create a local context that's aware of the name of the method we're\n     // creating.\n     let @local_ctxt mcx =\n@@ -7857,15 +7853,15 @@ fn process_fwding_mthd(@local_ctxt cx, @ty::method m, TypeRef llself_ty,\n     // Get the forwarding function's type and declare it.\n     let TypeRef llforwarding_fn_ty =\n         type_of_fn_full(\n-            cx.ccx, fake_span, m.proto, \n+            cx.ccx, sp, m.proto,\n             some[TypeRef](llself_ty), m.inputs, m.output,\n             vec::len[ast::ty_param](ty_params));\n     let ValueRef llforwarding_fn =\n         decl_internal_fastcall_fn(cx.ccx.llmod, s, llforwarding_fn_ty);\n \n     // Create a new function context and block context for the forwarding\n     // function, holding onto a pointer to the first block.\n-    auto fcx = new_fn_ctxt(cx, fake_span, llforwarding_fn);\n+    auto fcx = new_fn_ctxt(cx, sp, llforwarding_fn);\n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n \n@@ -7926,8 +7922,7 @@ fn process_fwding_mthd(@local_ctxt cx, @ty::method m, TypeRef llself_ty,\n \n     // And cast to that type.\n     llself_obj_body = bcx.build.PointerCast(llself_obj_body,\n-                                            T_ptr(type_of(cx.ccx,\n-                                                          fake_span,\n+                                            T_ptr(type_of(cx.ccx, sp,\n                                                           body_ty)));\n \n     // Now, reach into the body and grab the with_obj.\n@@ -7950,7 +7945,7 @@ fn process_fwding_mthd(@local_ctxt cx, @ty::method m, TypeRef llself_ty,\n     let uint ix = 0u;\n     alt (ty::struct(bcx.fcx.lcx.ccx.tcx, with_obj_ty)) {\n         case (ty::ty_obj(?methods)) {\n-            ix = ty::method_idx(cx.ccx.sess, fake_span, m.ident, methods);\n+            ix = ty::method_idx(cx.ccx.sess, sp, m.ident, methods);\n         }\n         case (_) {\n             // Shouldn't happen.\n@@ -7968,7 +7963,7 @@ fn process_fwding_mthd(@local_ctxt cx, @ty::method m, TypeRef llself_ty,\n     auto orig_mthd_ty = ty::method_ty_to_fn_ty(cx.ccx.tcx, *m);\n     auto llwith_obj_ty = val_ty(llwith_obj.val);\n     auto llorig_mthd_ty =\n-        type_of_fn_full(bcx.fcx.lcx.ccx, fake_span,\n+        type_of_fn_full(bcx.fcx.lcx.ccx, sp,\n                         ty::ty_fn_proto(bcx.fcx.lcx.ccx.tcx, orig_mthd_ty),\n                         some[TypeRef](llwith_obj_ty),\n                         m.inputs,\n@@ -8042,7 +8037,7 @@ fn process_normal_mthd(@local_ctxt cx, @ast::method m, TypeRef llself_ty,\n \n // Create a vtable for an object being translated.  Returns a pointer into\n // read-only memory.\n-fn create_vtbl(@local_ctxt cx, TypeRef llself_ty, ty::t self_ty,\n+fn create_vtbl(@local_ctxt cx, &span sp, TypeRef llself_ty, ty::t self_ty,\n                &ast::_obj ob, &vec[ast::ty_param] ty_params,\n                option::t[ty::t] with_obj_ty,\n                ty::t[] additional_field_tys) -> ValueRef {\n@@ -8187,7 +8182,7 @@ fn create_vtbl(@local_ctxt cx, TypeRef llself_ty, ty::t self_ty,\n                     }\n                     case (some(?t)) {\n                         llmethods += [process_fwding_mthd(\n-                                cx, fm, llself_ty, \n+                                cx, sp, fm, llself_ty,\n                                 self_ty, ty_params,\n                                 t,\n                                 additional_field_tys)];\n@@ -8285,7 +8280,8 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::node_id ctor_id,\n     // It will be located in the read-only memory of the executable we're\n     // creating and will contain ValueRefs for all of this object's methods.\n     // create_vtbl returns a pointer to the vtable, which we store.\n-    auto vtbl = create_vtbl(cx, llself_ty, self_ty, ob, ty_params, none, ~[]);\n+    auto vtbl = create_vtbl(cx, sp, llself_ty, self_ty, ob, ty_params, none, \n+                            ~[]);\n \n     bcx.build.Store(vtbl, pair_vtbl);\n "}]}