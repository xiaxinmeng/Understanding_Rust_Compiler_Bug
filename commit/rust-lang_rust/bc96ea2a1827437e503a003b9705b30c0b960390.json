{"sha": "bc96ea2a1827437e503a003b9705b30c0b960390", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjOTZlYTJhMTgyNzQzN2U1MDNhMDAzYjk3MDViMzBjMGI5NjAzOTA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-14T23:12:18Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-14T23:13:13Z"}, "message": "libcore: Implement a box annihilator, not called yet", "tree": {"sha": "3221de94d03f5b3fcf20251433c48479ab77ed4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3221de94d03f5b3fcf20251433c48479ab77ed4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc96ea2a1827437e503a003b9705b30c0b960390", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc96ea2a1827437e503a003b9705b30c0b960390", "html_url": "https://github.com/rust-lang/rust/commit/bc96ea2a1827437e503a003b9705b30c0b960390", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc96ea2a1827437e503a003b9705b30c0b960390/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7107b4eff51e58aa1ae5e30b073b4d788b13a2cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/7107b4eff51e58aa1ae5e30b073b4d788b13a2cb", "html_url": "https://github.com/rust-lang/rust/commit/7107b4eff51e58aa1ae5e30b073b4d788b13a2cb"}], "stats": {"total": 158, "additions": 158, "deletions": 0}, "files": [{"sha": "46dad7496da714bdda18abd201ab99c10eb338c8", "filename": "src/libcore/cleanup.rs", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/bc96ea2a1827437e503a003b9705b30c0b960390/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc96ea2a1827437e503a003b9705b30c0b960390/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=bc96ea2a1827437e503a003b9705b30c0b960390", "patch": "@@ -0,0 +1,152 @@\n+use libc::{c_char, c_void, intptr_t, uintptr_t};\n+use ptr::{mut_null, null, to_unsafe_ptr};\n+use repr::BoxRepr;\n+use rt::rt_free;\n+use sys::TypeDesc;\n+use unsafe::transmute;\n+\n+/**\n+ * Runtime structures\n+ *\n+ * NB: These must match the representation in the C++ runtime.\n+ */\n+\n+type DropGlue = fn(**TypeDesc, *c_void);\n+type FreeGlue = fn(**TypeDesc, *c_void);\n+\n+type TaskID = uintptr_t;\n+\n+struct StackSegment { priv opaque: () }\n+struct Scheduler { priv opaque: () }\n+struct SchedulerLoop { priv opaque: () }\n+struct Kernel { priv opaque: () }\n+struct Env { priv opaque: () }\n+struct AllocHeader { priv opaque: () }\n+struct MemoryRegion { priv opaque: () }\n+\n+// XXX: i386\n+struct Registers {\n+    data: [u64 * 22]\n+}\n+\n+struct Context {\n+    regs: Registers,\n+    next: *Context,\n+    pad: u64\n+}\n+\n+struct BoxedRegion {\n+    env: *Env,\n+    backing_region: *MemoryRegion,\n+    live_allocs: *BoxRepr\n+}\n+\n+struct Task {\n+    // Public fields\n+    refcount: intptr_t,\n+    id: TaskID,\n+    ctx: Context,\n+    stack_segment: *StackSegment,\n+    runtime_sp: uintptr_t,\n+    scheduler: *Scheduler,\n+    scheduler_loop: *SchedulerLoop,\n+\n+    // Fields known only to the runtime\n+    kernel: *Kernel,\n+    name: *c_char,\n+    list_index: *i32,\n+    rendezvous_ptr: *uintptr_t,\n+    boxed_region: BoxedRegion\n+}\n+\n+/*\n+ * Box annihilation\n+ *\n+ * This runs at task death to free all boxes.\n+ */\n+\n+/// Destroys all managed memory (i.e. @ boxes) held by the current task.\n+pub unsafe fn annihilate() {\n+    let task: *Task = transmute(rustrt::rust_get_task());\n+\n+    // Pass 1: Make all boxes immortal.\n+    let box = (*task).boxed_region.live_allocs;\n+    let mut box: *mut BoxRepr = transmute(copy box);\n+    assert (*box).prev == null();\n+    while box != mut_null() {\n+        debug!(\"making box immortal: %x\", box as uint);\n+        (*box).ref_count = 0x77777777;\n+        box = transmute(copy (*box).next);\n+    }\n+\n+    // Pass 2: Drop all boxes.\n+    let box = (*task).boxed_region.live_allocs;\n+    let mut box: *mut BoxRepr = transmute(copy box);\n+    assert (*box).prev == null();\n+    while box != mut_null() {\n+        debug!(\"calling drop glue for box: %x\", box as uint);\n+        let tydesc: *TypeDesc = transmute(copy (*box).type_desc);\n+        let drop_glue: DropGlue = transmute(((*tydesc).drop_glue, 0));\n+        drop_glue(to_unsafe_ptr(&tydesc), transmute(&(*box).data));\n+\n+        box = transmute(copy (*box).next);\n+    }\n+\n+    // Pass 3: Free all boxes.\n+    loop {\n+        let box = (*task).boxed_region.live_allocs;\n+        if box == null() { break; }\n+        let mut box: *mut BoxRepr = transmute(copy box);\n+        assert (*box).prev == null();\n+\n+        debug!(\"freeing box: %x\", box as uint);\n+        rt_free(transmute(box));\n+    }\n+}\n+\n+/// Bindings to the runtime\n+extern mod rustrt {\n+    #[rust_stack]\n+    /*priv*/ fn rust_get_task() -> *c_void;\n+}\n+\n+/*\n+ * Tests\n+ */\n+\n+#[cfg(test)]\n+mod tests {\n+    /*struct Knot {\n+        mut a: Option<@Knot>\n+    }\n+\n+    struct Blah {\n+        x: int,\n+        drop { io::println(\"Blah!\"); }\n+    }\n+\n+    #[test]\n+    fn test_box_annihilation() {\n+        let knot = @Knot { a: None };\n+        knot.a = Some(knot);\n+\n+        let x = @~\"foo\";\n+\n+        let blah = @Blah { x: 3 };\n+\n+        let f_ref = @mut None;\n+        let f = || { util::ignore(f_ref); };\n+        *f_ref = Some(f);\n+\n+        unsafe { annihilate(); }\n+\n+        unsafe {\n+            unsafe::forget(knot);\n+            unsafe::forget(x);\n+            unsafe::forget(blah);\n+            unsafe::forget(f_ref);\n+            unsafe::forget(f);\n+        }\n+    }*/\n+}\n+"}, {"sha": "8b5a218bb93afd477674be445b85491c56ecbc43", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc96ea2a1827437e503a003b9705b30c0b960390/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/bc96ea2a1827437e503a003b9705b30c0b960390/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=bc96ea2a1827437e503a003b9705b30c0b960390", "patch": "@@ -244,6 +244,7 @@ mod unicode;\n mod private;\n mod cmath;\n mod stackwalk;\n+mod cleanup;\n \n // Local Variables:\n // mode: rust;"}, {"sha": "82eacaed606ce365e9564c6ff5761a3fb20fa025", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc96ea2a1827437e503a003b9705b30c0b960390/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc96ea2a1827437e503a003b9705b30c0b960390/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=bc96ea2a1827437e503a003b9705b30c0b960390", "patch": "@@ -9,6 +9,7 @@ export offset;\n export const_offset;\n export mut_offset;\n export null;\n+export mut_null;\n export is_null;\n export is_not_null;\n export memcpy;\n@@ -98,6 +99,10 @@ unsafe fn position<T>(buf: *T, f: fn(T) -> bool) -> uint {\n #[inline(always)]\n pure fn null<T>() -> *T { unsafe { unsafe::reinterpret_cast(&0u) } }\n \n+/// Create an unsafe mutable null pointer\n+#[inline(always)]\n+pure fn mut_null<T>() -> *mut T { unsafe { unsafe::reinterpret_cast(&0u) } }\n+\n /// Returns true if the pointer is equal to the null pointer.\n pure fn is_null<T>(ptr: *const T) -> bool { ptr == null() }\n "}]}