{"sha": "6a9db39f6ccf25e97d0017a6921d95c3534bd714", "node_id": "C_kwDOAAsO6NoAKDZhOWRiMzlmNmNjZjI1ZTk3ZDAwMTdhNjkyMWQ5NWMzNTM0YmQ3MTQ", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-07-05T05:12:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-05T05:12:54Z"}, "message": "Rollup merge of #98761 - lcnr:need_type_info-cont, r=estebank\n\nmore `need_type_info` improvements\n\nthis now deals with macros in suggestions and the source cost computation does what I want for `channel` :tada:\n\nr? ``@estebank``", "tree": {"sha": "90cbaa160b0cbc580e126a7490b06c14316b7baa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90cbaa160b0cbc580e126a7490b06c14316b7baa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a9db39f6ccf25e97d0017a6921d95c3534bd714", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiw8hXCRBK7hj4Ov3rIwAATPQIACPZZLOEKr8yQGXSNgcRdDLS\nu9pNLMuFYlAyIbqh8tNsaj2nxPutB31djuwK4kgt2bQSMoTRxGCpt3qd16tRvjb8\nrOvBGI1MMIKSre5nCFsUXJgrJKg7D2leLbzRoZH9xNaV0V1xb6zwMyWy4iQBpo8E\n7e/V7jYSYjoCjs7dRxXN6jET2hwRTounRJPRczHmalldXn8jxogFC0g5BLdsUv7M\nbAU5c0HXSJ9KwZ9rvNe7ucGLS5RUOjkX6IowTju6/PXtbV9NDtwxoN835w5DDTxE\nChXgVs9CLAZwPpcg5brygsCyOKiQoT1gKY7tCe6259TH01mKrzLHyBnzeSNgFfI=\n=qZen\n-----END PGP SIGNATURE-----\n", "payload": "tree 90cbaa160b0cbc580e126a7490b06c14316b7baa\nparent d26ccf7067ef5e18154db6e16f6285e2f62371dc\nparent f475e880a4c6b2359ebaef88c844daede9c88fc9\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1656997974 +0530\ncommitter GitHub <noreply@github.com> 1656997974 +0530\n\nRollup merge of #98761 - lcnr:need_type_info-cont, r=estebank\n\nmore `need_type_info` improvements\n\nthis now deals with macros in suggestions and the source cost computation does what I want for `channel` :tada:\n\nr? ``@estebank``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a9db39f6ccf25e97d0017a6921d95c3534bd714", "html_url": "https://github.com/rust-lang/rust/commit/6a9db39f6ccf25e97d0017a6921d95c3534bd714", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a9db39f6ccf25e97d0017a6921d95c3534bd714/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d26ccf7067ef5e18154db6e16f6285e2f62371dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/d26ccf7067ef5e18154db6e16f6285e2f62371dc", "html_url": "https://github.com/rust-lang/rust/commit/d26ccf7067ef5e18154db6e16f6285e2f62371dc"}, {"sha": "f475e880a4c6b2359ebaef88c844daede9c88fc9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f475e880a4c6b2359ebaef88c844daede9c88fc9", "html_url": "https://github.com/rust-lang/rust/commit/f475e880a4c6b2359ebaef88c844daede9c88fc9"}], "stats": {"total": 257, "additions": 167, "deletions": 90}, "files": [{"sha": "4d29fc469462c43b01434e1ab086e04657be794b", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 76, "deletions": 31, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/6a9db39f6ccf25e97d0017a6921d95c3534bd714/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a9db39f6ccf25e97d0017a6921d95c3534bd714/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=6a9db39f6ccf25e97d0017a6921d95c3534bd714", "patch": "@@ -315,8 +315,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         body_id: Option<hir::BodyId>,\n         failure_span: Span,\n         arg: GenericArg<'tcx>,\n-        // FIXME(#94483): Either use this or remove it.\n-        _impl_candidates: Vec<ty::TraitRef<'tcx>>,\n         error_code: TypeAnnotationNeeded,\n         should_label_span: bool,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n@@ -534,6 +532,23 @@ enum InferSourceKind<'tcx> {\n     },\n }\n \n+impl<'tcx> InferSource<'tcx> {\n+    fn from_expansion(&self) -> bool {\n+        let source_from_expansion = match self.kind {\n+            InferSourceKind::LetBinding { insert_span, .. }\n+            | InferSourceKind::ClosureArg { insert_span, .. }\n+            | InferSourceKind::GenericArg { insert_span, .. } => insert_span.from_expansion(),\n+            InferSourceKind::FullyQualifiedMethodCall { receiver, .. } => {\n+                receiver.span.from_expansion()\n+            }\n+            InferSourceKind::ClosureReturn { data, should_wrap_expr, .. } => {\n+                data.span().from_expansion() || should_wrap_expr.map_or(false, Span::from_expansion)\n+            }\n+        };\n+        source_from_expansion || self.span.from_expansion()\n+    }\n+}\n+\n impl<'tcx> InferSourceKind<'tcx> {\n     fn ty_msg(&self, infcx: &InferCtxt<'_, 'tcx>) -> String {\n         match *self {\n@@ -604,57 +619,85 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n     /// Sources with a small cost are prefer and should result\n     /// in a clearer and idiomatic suggestion.\n     fn source_cost(&self, source: &InferSource<'tcx>) -> usize {\n-        let tcx = self.infcx.tcx;\n-\n-        fn arg_cost<'tcx>(arg: GenericArg<'tcx>) -> usize {\n-            match arg.unpack() {\n-                GenericArgKind::Lifetime(_) => 0, // erased\n-                GenericArgKind::Type(ty) => ty_cost(ty),\n-                GenericArgKind::Const(_) => 3, // some non-zero value\n-            }\n+        #[derive(Clone, Copy)]\n+        struct CostCtxt<'tcx> {\n+            tcx: TyCtxt<'tcx>,\n         }\n-        fn ty_cost<'tcx>(ty: Ty<'tcx>) -> usize {\n-            match ty.kind() {\n-                ty::Closure(..) => 100,\n-                ty::FnDef(..) => 20,\n-                ty::FnPtr(..) => 10,\n-                ty::Infer(..) => 0,\n-                _ => 1,\n+        impl<'tcx> CostCtxt<'tcx> {\n+            fn arg_cost(self, arg: GenericArg<'tcx>) -> usize {\n+                match arg.unpack() {\n+                    GenericArgKind::Lifetime(_) => 0, // erased\n+                    GenericArgKind::Type(ty) => self.ty_cost(ty),\n+                    GenericArgKind::Const(_) => 3, // some non-zero value\n+                }\n+            }\n+            fn ty_cost(self, ty: Ty<'tcx>) -> usize {\n+                match *ty.kind() {\n+                    ty::Closure(..) => 1000,\n+                    ty::FnDef(..) => 150,\n+                    ty::FnPtr(..) => 30,\n+                    ty::Adt(def, substs) => {\n+                        5 + self\n+                            .tcx\n+                            .generics_of(def.did())\n+                            .own_substs_no_defaults(self.tcx, substs)\n+                            .iter()\n+                            .map(|&arg| self.arg_cost(arg))\n+                            .sum::<usize>()\n+                    }\n+                    ty::Tuple(args) => 5 + args.iter().map(|arg| self.ty_cost(arg)).sum::<usize>(),\n+                    ty::Ref(_, ty, _) => 2 + self.ty_cost(ty),\n+                    ty::Infer(..) => 0,\n+                    _ => 1,\n+                }\n             }\n         }\n \n         // The sources are listed in order of preference here.\n-        match source.kind {\n-            InferSourceKind::LetBinding { ty, .. } => ty_cost(ty),\n-            InferSourceKind::ClosureArg { ty, .. } => 5 + ty_cost(ty),\n+        let tcx = self.infcx.tcx;\n+        let ctx = CostCtxt { tcx };\n+        let base_cost = match source.kind {\n+            InferSourceKind::LetBinding { ty, .. } => ctx.ty_cost(ty),\n+            InferSourceKind::ClosureArg { ty, .. } => ctx.ty_cost(ty),\n             InferSourceKind::GenericArg { def_id, generic_args, .. } => {\n                 let variant_cost = match tcx.def_kind(def_id) {\n-                    DefKind::Variant | DefKind::Ctor(CtorOf::Variant, _) => 15, // `None::<u32>` and friends are ugly.\n-                    _ => 12,\n+                    // `None::<u32>` and friends are ugly.\n+                    DefKind::Variant | DefKind::Ctor(CtorOf::Variant, _) => 15,\n+                    _ => 10,\n                 };\n-                variant_cost + generic_args.iter().map(|&arg| arg_cost(arg)).sum::<usize>()\n+                variant_cost + generic_args.iter().map(|&arg| ctx.arg_cost(arg)).sum::<usize>()\n             }\n             InferSourceKind::FullyQualifiedMethodCall { substs, .. } => {\n-                20 + substs.iter().map(|arg| arg_cost(arg)).sum::<usize>()\n+                20 + substs.iter().map(|arg| ctx.arg_cost(arg)).sum::<usize>()\n             }\n             InferSourceKind::ClosureReturn { ty, should_wrap_expr, .. } => {\n-                30 + ty_cost(ty) + if should_wrap_expr.is_some() { 10 } else { 0 }\n+                30 + ctx.ty_cost(ty) + if should_wrap_expr.is_some() { 10 } else { 0 }\n             }\n-        }\n+        };\n+\n+        let suggestion_may_apply = if source.from_expansion() { 10000 } else { 0 };\n+\n+        base_cost + suggestion_may_apply\n     }\n \n     /// Uses `fn source_cost` to determine whether this inference source is preferable to\n     /// previous sources. We generally prefer earlier sources.\n     #[instrument(level = \"debug\", skip(self))]\n     fn update_infer_source(&mut self, new_source: InferSource<'tcx>) {\n         let cost = self.source_cost(&new_source) + self.attempt;\n+        debug!(?cost);\n         self.attempt += 1;\n         if cost < self.infer_source_cost {\n             self.infer_source_cost = cost;\n             self.infer_source = Some(new_source);\n         }\n     }\n \n+    fn node_substs_opt(&self, hir_id: HirId) -> Option<SubstsRef<'tcx>> {\n+        let substs = self.typeck_results.node_substs_opt(hir_id);\n+        self.infcx.resolve_vars_if_possible(substs)\n+    }\n+\n     fn opt_node_type(&self, hir_id: HirId) -> Option<Ty<'tcx>> {\n         let ty = self.typeck_results.node_type_opt(hir_id);\n         self.infcx.resolve_vars_if_possible(ty)\n@@ -737,7 +780,7 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n         let tcx = self.infcx.tcx;\n         match expr.kind {\n             hir::ExprKind::Path(ref path) => {\n-                if let Some(substs) = self.typeck_results.node_substs_opt(expr.hir_id) {\n+                if let Some(substs) = self.node_substs_opt(expr.hir_id) {\n                     return self.path_inferred_subst_iter(expr.hir_id, substs, path);\n                 }\n             }\n@@ -765,7 +808,7 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n                         if generics.has_impl_trait() {\n                             None?\n                         }\n-                        let substs = self.typeck_results.node_substs_opt(expr.hir_id)?;\n+                        let substs = self.node_substs_opt(expr.hir_id)?;\n                         let span = tcx.hir().span(segment.hir_id?);\n                         let insert_span = segment.ident.span.shrink_to_hi().with_hi(span.hi());\n                         InsertableGenericArgs {\n@@ -980,8 +1023,10 @@ impl<'a, 'tcx> Visitor<'tcx> for FindInferSourceVisitor<'a, 'tcx> {\n             debug!(?args);\n             let InsertableGenericArgs { insert_span, substs, generics_def_id, def_id } = args;\n             let generics = tcx.generics_of(generics_def_id);\n-            if let Some(argument_index) =\n-                generics.own_substs(substs).iter().position(|&arg| self.generic_arg_is_target(arg))\n+            if let Some(argument_index) = generics\n+                .own_substs(substs)\n+                .iter()\n+                .position(|&arg| self.generic_arg_contains_target(arg))\n             {\n                 let substs = self.infcx.resolve_vars_if_possible(substs);\n                 let generic_args = &generics.own_substs_no_defaults(tcx, substs)\n@@ -1037,7 +1082,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindInferSourceVisitor<'a, 'tcx> {\n             .any(|generics| generics.has_impl_trait())\n         };\n         if let ExprKind::MethodCall(path, args, span) = expr.kind\n-            && let Some(substs) = self.typeck_results.node_substs_opt(expr.hir_id)\n+            && let Some(substs) = self.node_substs_opt(expr.hir_id)\n             && substs.iter().any(|arg| self.generic_arg_contains_target(arg))\n             && let Some(def_id) = self.typeck_results.type_dependent_def_id(expr.hir_id)\n             && self.infcx.tcx.trait_of_item(def_id).is_some()"}, {"sha": "88b09f4de0a4c260485e7262b84aef91f5b42797", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6a9db39f6ccf25e97d0017a6921d95c3534bd714/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a9db39f6ccf25e97d0017a6921d95c3534bd714/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=6a9db39f6ccf25e97d0017a6921d95c3534bd714", "patch": "@@ -1980,7 +1980,6 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                             body_id,\n                             span,\n                             trait_ref.self_ty().skip_binder().into(),\n-                            vec![],\n                             ErrorCode::E0282,\n                             false,\n                         )\n@@ -2005,19 +2004,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                 let subst = data.trait_ref.substs.iter().find(|s| s.has_infer_types_or_consts());\n \n                 let mut err = if let Some(subst) = subst {\n-                    let impl_candidates = self\n-                        .find_similar_impl_candidates(trait_ref)\n-                        .into_iter()\n-                        .map(|candidate| candidate.trait_ref)\n-                        .collect();\n-                    self.emit_inference_failure_err(\n-                        body_id,\n-                        span,\n-                        subst,\n-                        impl_candidates,\n-                        ErrorCode::E0283,\n-                        true,\n-                    )\n+                    self.emit_inference_failure_err(body_id, span, subst, ErrorCode::E0283, true)\n                 } else {\n                     struct_span_err!(\n                         self.tcx.sess,\n@@ -2117,7 +2104,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                     return;\n                 }\n \n-                self.emit_inference_failure_err(body_id, span, arg, vec![], ErrorCode::E0282, false)\n+                self.emit_inference_failure_err(body_id, span, arg, ErrorCode::E0282, false)\n             }\n \n             ty::PredicateKind::Subtype(data) => {\n@@ -2131,14 +2118,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                 let SubtypePredicate { a_is_expected: _, a, b } = data;\n                 // both must be type variables, or the other would've been instantiated\n                 assert!(a.is_ty_var() && b.is_ty_var());\n-                self.emit_inference_failure_err(\n-                    body_id,\n-                    span,\n-                    a.into(),\n-                    vec![],\n-                    ErrorCode::E0282,\n-                    true,\n-                )\n+                self.emit_inference_failure_err(body_id, span, a.into(), ErrorCode::E0282, true)\n             }\n             ty::PredicateKind::Projection(data) => {\n                 if predicate.references_error() || self.is_tainted_by_errors() {\n@@ -2155,7 +2135,6 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                         body_id,\n                         span,\n                         subst,\n-                        vec![],\n                         ErrorCode::E0284,\n                         true,\n                     );"}, {"sha": "5297c48b4c37d07058aa152d2931dffb6ee2c041", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6a9db39f6ccf25e97d0017a6921d95c3534bd714/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a9db39f6ccf25e97d0017a6921d95c3534bd714/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=6a9db39f6ccf25e97d0017a6921d95c3534bd714", "patch": "@@ -1538,15 +1538,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty\n         } else {\n             if !self.is_tainted_by_errors() {\n-                self.emit_inference_failure_err(\n-                    (**self).body_id,\n-                    sp,\n-                    ty.into(),\n-                    vec![],\n-                    E0282,\n-                    true,\n-                )\n-                .emit();\n+                self.emit_inference_failure_err((**self).body_id, sp, ty.into(), E0282, true)\n+                    .emit();\n             }\n             let err = self.tcx.ty_error();\n             self.demand_suptype(sp, err, ty);"}, {"sha": "16e5639096c5e7c62dd339cf797775c05e2e452b", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a9db39f6ccf25e97d0017a6921d95c3534bd714/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a9db39f6ccf25e97d0017a6921d95c3534bd714/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=6a9db39f6ccf25e97d0017a6921d95c3534bd714", "patch": "@@ -692,7 +692,6 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n                     Some(self.body.id()),\n                     self.span.to_span(self.tcx),\n                     t.into(),\n-                    vec![],\n                     E0282,\n                     false,\n                 )\n@@ -707,7 +706,6 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n                     Some(self.body.id()),\n                     self.span.to_span(self.tcx),\n                     c.into(),\n-                    vec![],\n                     E0282,\n                     false,\n                 )"}, {"sha": "9cbe221de1393f86ee5b6cb3d70350b24acee14b", "filename": "src/test/ui/inference/ambiguous_type_parameter.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6a9db39f6ccf25e97d0017a6921d95c3534bd714/src%2Ftest%2Fui%2Finference%2Fambiguous_type_parameter.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6a9db39f6ccf25e97d0017a6921d95c3534bd714/src%2Ftest%2Fui%2Finference%2Fambiguous_type_parameter.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fambiguous_type_parameter.stderr?ref=6a9db39f6ccf25e97d0017a6921d95c3534bd714", "patch": "@@ -2,7 +2,12 @@ error[E0282]: type annotations needed\n   --> $DIR/ambiguous_type_parameter.rs:16:19\n    |\n LL |     InMemoryStore.get_raw(&String::default());\n-   |                   ^^^^^^^ cannot infer type for type parameter `K`\n+   |                   ^^^^^^^\n+   |\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <InMemoryStore as Store<String, HashMap<K, String>>>::get_raw(&InMemoryStore, &String::default());\n+   |     +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++             ~\n \n error: aborting due to previous error\n "}, {"sha": "b555697dc3461058cb0648ed1e0d01f3fd022985", "filename": "src/test/ui/inference/cannot-infer-partial-try-return.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a9db39f6ccf25e97d0017a6921d95c3534bd714/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a9db39f6ccf25e97d0017a6921d95c3534bd714/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.rs?ref=6a9db39f6ccf25e97d0017a6921d95c3534bd714", "patch": "@@ -16,8 +16,8 @@ fn infallible() -> Result<(), std::convert::Infallible> {\n \n fn main() {\n     let x = || -> Result<_, QualifiedError<_>> {\n-        //~^ ERROR type annotations needed for `Result<(), QualifiedError<_>>`\n         infallible()?;\n         Ok(())\n+        //~^ ERROR type annotations needed\n     };\n }"}, {"sha": "2a56aaa44fef23b3ae435b47451aa9e7986f4769", "filename": "src/test/ui/inference/cannot-infer-partial-try-return.stderr", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6a9db39f6ccf25e97d0017a6921d95c3534bd714/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6a9db39f6ccf25e97d0017a6921d95c3534bd714/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.stderr?ref=6a9db39f6ccf25e97d0017a6921d95c3534bd714", "patch": "@@ -1,16 +1,15 @@\n-error[E0282]: type annotations needed for `Result<(), QualifiedError<_>>`\n-  --> $DIR/cannot-infer-partial-try-return.rs:18:13\n+error[E0282]: type annotations needed\n+  --> $DIR/cannot-infer-partial-try-return.rs:20:9\n    |\n-LL |     let x = || -> Result<_, QualifiedError<_>> {\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-LL |\n LL |         infallible()?;\n    |         ------------- type must be known at this point\n+LL |         Ok(())\n+   |         ^^ cannot infer type of the type parameter `E` declared on the enum `Result`\n    |\n-help: try giving this closure an explicit return type\n+help: consider specifying the generic arguments\n    |\n-LL |     let x = || -> Result<(), QualifiedError<_>> {\n-   |                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+LL |         Ok::<(), QualifiedError<_>>(())\n+   |           +++++++++++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "e2ba5a9417138abf8a4de9ef6a6eea6b0ce38dbe", "filename": "src/test/ui/inference/need_type_info/channel.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6a9db39f6ccf25e97d0017a6921d95c3534bd714/src%2Ftest%2Fui%2Finference%2Fneed_type_info%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a9db39f6ccf25e97d0017a6921d95c3534bd714/src%2Ftest%2Fui%2Finference%2Fneed_type_info%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fneed_type_info%2Fchannel.rs?ref=6a9db39f6ccf25e97d0017a6921d95c3534bd714", "patch": "@@ -0,0 +1,19 @@\n+// Test that we suggest specifying the generic argument of `channel`\n+// instead of the return type of that function, which is a lot more\n+// complex.\n+use std::sync::mpsc::channel;\n+\n+fn no_tuple() {\n+    let _data =\n+        channel(); //~ ERROR type annotations needed\n+}\n+\n+fn tuple() {\n+    let (_sender, _receiver) =\n+        channel(); //~ ERROR type annotations needed\n+}\n+\n+fn main() {\n+    no_tuple();\n+    tuple();\n+}"}, {"sha": "e33ace0338d5040b8b360870082532aa02df23f7", "filename": "src/test/ui/inference/need_type_info/channel.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6a9db39f6ccf25e97d0017a6921d95c3534bd714/src%2Ftest%2Fui%2Finference%2Fneed_type_info%2Fchannel.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6a9db39f6ccf25e97d0017a6921d95c3534bd714/src%2Ftest%2Fui%2Finference%2Fneed_type_info%2Fchannel.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fneed_type_info%2Fchannel.stderr?ref=6a9db39f6ccf25e97d0017a6921d95c3534bd714", "patch": "@@ -0,0 +1,25 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/channel.rs:8:9\n+   |\n+LL |         channel();\n+   |         ^^^^^^^ cannot infer type of the type parameter `T` declared on the function `channel`\n+   |\n+help: consider specifying the generic argument\n+   |\n+LL |         channel::<T>();\n+   |                +++++\n+\n+error[E0282]: type annotations needed\n+  --> $DIR/channel.rs:13:9\n+   |\n+LL |         channel();\n+   |         ^^^^^^^ cannot infer type of the type parameter `T` declared on the function `channel`\n+   |\n+help: consider specifying the generic argument\n+   |\n+LL |         channel::<T>();\n+   |                +++++\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "7b9a1634a0d4c146fcf552639d47cd17af7c1b7e", "filename": "src/test/ui/issues/issue-23041.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6a9db39f6ccf25e97d0017a6921d95c3534bd714/src%2Ftest%2Fui%2Fissues%2Fissue-23041.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6a9db39f6ccf25e97d0017a6921d95c3534bd714/src%2Ftest%2Fui%2Fissues%2Fissue-23041.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23041.stderr?ref=6a9db39f6ccf25e97d0017a6921d95c3534bd714", "patch": "@@ -1,8 +1,13 @@\n error[E0282]: type annotations needed\n-  --> $DIR/issue-23041.rs:6:22\n+  --> $DIR/issue-23041.rs:6:7\n    |\n LL |     b.downcast_ref::<fn(_)->_>();\n-   |                      ^^^^^^^^ cannot infer type\n+   |       ^^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the associated function `downcast_ref`\n+   |\n+help: consider specifying the generic arguments\n+   |\n+LL |     b.downcast_ref::<fn(_) -> _>();\n+   |                   ~~~~~~~~~~~~~~\n \n error: aborting due to previous error\n "}, {"sha": "863993f45090460bca6f8277e5712b5a6c4169b2", "filename": "src/test/ui/issues/issue-24013.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6a9db39f6ccf25e97d0017a6921d95c3534bd714/src%2Ftest%2Fui%2Fissues%2Fissue-24013.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6a9db39f6ccf25e97d0017a6921d95c3534bd714/src%2Ftest%2Fui%2Fissues%2Fissue-24013.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24013.stderr?ref=6a9db39f6ccf25e97d0017a6921d95c3534bd714", "patch": "@@ -1,8 +1,13 @@\n error[E0282]: type annotations needed\n-  --> $DIR/issue-24013.rs:5:20\n+  --> $DIR/issue-24013.rs:5:13\n    |\n LL |     unsafe {swap::<&mut _>(transmute(&a), transmute(&b))};\n-   |                    ^^^^^^ cannot infer type\n+   |             ^^^^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the function `swap`\n+   |\n+help: consider specifying the generic arguments\n+   |\n+LL |     unsafe {swap::<&mut _>(transmute(&a), transmute(&b))};\n+   |                 ~~~~~~~~~~\n \n error: aborting due to previous error\n "}, {"sha": "4be83457f7a8be46f232542df8f4eb392be9eeb6", "filename": "src/test/ui/issues/issue-25368.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a9db39f6ccf25e97d0017a6921d95c3534bd714/src%2Ftest%2Fui%2Fissues%2Fissue-25368.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a9db39f6ccf25e97d0017a6921d95c3534bd714/src%2Ftest%2Fui%2Fissues%2Fissue-25368.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-25368.rs?ref=6a9db39f6ccf25e97d0017a6921d95c3534bd714", "patch": "@@ -5,10 +5,10 @@ use std::marker::PhantomData;\n struct Foo<T> {foo: PhantomData<T>}\n \n fn main() {\n-    let (tx, rx) = //~ ERROR type annotations needed\n+    let (tx, rx) =\n         channel();\n-    // FIXME(#89862): Suggest adding a generic argument to `channel` instead\n     spawn(move || {\n         tx.send(Foo{ foo: PhantomData });\n+        //~^ ERROR type annotations needed\n     });\n }"}, {"sha": "e6ed3aac71032f1d646a4d6efa09785f6abb3934", "filename": "src/test/ui/issues/issue-25368.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a9db39f6ccf25e97d0017a6921d95c3534bd714/src%2Ftest%2Fui%2Fissues%2Fissue-25368.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6a9db39f6ccf25e97d0017a6921d95c3534bd714/src%2Ftest%2Fui%2Fissues%2Fissue-25368.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-25368.stderr?ref=6a9db39f6ccf25e97d0017a6921d95c3534bd714", "patch": "@@ -1,13 +1,13 @@\n-error[E0282]: type annotations needed for `(Sender<Foo<T>>, std::sync::mpsc::Receiver<Foo<T>>)`\n-  --> $DIR/issue-25368.rs:8:9\n+error[E0282]: type annotations needed\n+  --> $DIR/issue-25368.rs:11:27\n    |\n-LL |     let (tx, rx) =\n-   |         ^^^^^^^^\n+LL |         tx.send(Foo{ foo: PhantomData });\n+   |                           ^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the struct `PhantomData`\n    |\n-help: consider giving this pattern a type, where the type for type parameter `T` is specified\n+help: consider specifying the generic argument\n    |\n-LL |     let (tx, rx): (Sender<Foo<T>>, std::sync::mpsc::Receiver<Foo<T>>) =\n-   |                 +++++++++++++++++++++++++++++++++++++++++++++++++++++\n+LL |         tx.send(Foo{ foo: PhantomData::<T> });\n+   |                                      +++++\n \n error: aborting due to previous error\n "}, {"sha": "e0f8a5447b081b884cf4640562efe0cd8ff1a4db", "filename": "src/test/ui/methods/method-ambig-one-trait-unknown-int-type.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a9db39f6ccf25e97d0017a6921d95c3534bd714/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-one-trait-unknown-int-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6a9db39f6ccf25e97d0017a6921d95c3534bd714/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-one-trait-unknown-int-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-one-trait-unknown-int-type.stderr?ref=6a9db39f6ccf25e97d0017a6921d95c3534bd714", "patch": "@@ -13,7 +13,7 @@ error[E0283]: type annotations needed\n   --> $DIR/method-ambig-one-trait-unknown-int-type.rs:26:7\n    |\n LL |     x.foo();\n-   |       ^^^ cannot infer type for struct `Vec<_>`\n+   |       ^^^\n    |\n note: multiple `impl`s satisfying `Vec<_>: Foo` found\n   --> $DIR/method-ambig-one-trait-unknown-int-type.rs:9:1\n@@ -23,6 +23,10 @@ LL | impl Foo for Vec<usize> {\n ...\n LL | impl Foo for Vec<isize> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <Vec<T> as Foo>::foo(&x);\n+   |     ++++++++++++++++++++++ ~\n \n error[E0308]: mismatched types\n   --> $DIR/method-ambig-one-trait-unknown-int-type.rs:33:20"}]}