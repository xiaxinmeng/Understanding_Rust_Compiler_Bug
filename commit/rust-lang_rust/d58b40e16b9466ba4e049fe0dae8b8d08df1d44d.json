{"sha": "d58b40e16b9466ba4e049fe0dae8b8d08df1d44d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1OGI0MGUxNmI5NDY2YmE0ZTA0OWZlMGRhZThiOGQwOGRmMWQ0NGQ=", "commit": {"author": {"name": "scalexm", "email": "martin.alex32@hotmail.fr", "date": "2017-08-09T11:55:27Z"}, "committer": {"name": "scalexm", "email": "martin.alex32@hotmail.fr", "date": "2017-08-14T13:07:22Z"}, "message": "Use an helper struct", "tree": {"sha": "4d701575c13491cff9e9767c0f65e7ee767dd845", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d701575c13491cff9e9767c0f65e7ee767dd845"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d58b40e16b9466ba4e049fe0dae8b8d08df1d44d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d58b40e16b9466ba4e049fe0dae8b8d08df1d44d", "html_url": "https://github.com/rust-lang/rust/commit/d58b40e16b9466ba4e049fe0dae8b8d08df1d44d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d58b40e16b9466ba4e049fe0dae8b8d08df1d44d/comments", "author": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1f1798ba90676d36906c016145f237e54eea294", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1f1798ba90676d36906c016145f237e54eea294", "html_url": "https://github.com/rust-lang/rust/commit/e1f1798ba90676d36906c016145f237e54eea294"}], "stats": {"total": 606, "additions": 312, "deletions": 294}, "files": [{"sha": "f3c3c808446f0b13d2238de3b20a0fd4f2b2442f", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 302, "deletions": 284, "changes": 586, "blob_url": "https://github.com/rust-lang/rust/blob/d58b40e16b9466ba4e049fe0dae8b8d08df1d44d/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58b40e16b9466ba4e049fe0dae8b8d08df1d44d/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=d58b40e16b9466ba4e049fe0dae8b8d08df1d44d", "patch": "@@ -277,348 +277,366 @@ fn build_clone_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n                               self_ty: ty::Ty<'tcx>)\n                               -> Mir<'tcx>\n {\n-    let sig = tcx.fn_sig(def_id);\n-    let sig = tcx.erase_late_bound_regions(&sig);\n-    let span = tcx.def_span(def_id);\n-\n     debug!(\"build_clone_shim(def_id={:?})\", def_id);\n \n-    let mut local_decls = local_decls_for_sig(&sig, span);\n-    let source_info = SourceInfo { span, scope: ARGUMENT_VISIBILITY_SCOPE };\n+    let mut builder = CloneShimBuilder::new(tcx, def_id);\n+    let is_copy = !self_ty.moves_by_default(tcx, tcx.param_env(def_id), builder.span);\n \n-    let rcvr = Lvalue::Local(Local::new(1+0)).deref();\n+    match self_ty.sty {\n+        _ if is_copy => builder.copy_shim(),\n+        ty::TyArray(ty, len) => builder.array_shim(ty, len),\n+        ty::TyTuple(tys, _) => builder.tuple_shim(tys),\n+        _ => {\n+            bug!(\"clone shim for `{:?}` which is not `Copy` and is not an aggregate\", self_ty);\n+        }\n+    };\n \n-    let mut blocks = IndexVec::new();\n-    let block = |blocks: &mut IndexVec<_, _>, statements, kind, is_cleanup| {\n-        blocks.push(BasicBlockData {\n+    builder.into_mir()\n+}\n+\n+struct CloneShimBuilder<'a, 'tcx: 'a> {\n+    tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId,\n+    local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n+    blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n+    span: Span,\n+    sig: ty::FnSig<'tcx>,\n+}\n+\n+impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n+    fn new(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Self {\n+        let sig = tcx.fn_sig(def_id);\n+        let sig = tcx.erase_late_bound_regions(&sig);\n+        let span = tcx.def_span(def_id);\n+\n+        CloneShimBuilder {\n+            tcx,\n+            def_id,\n+            local_decls: local_decls_for_sig(&sig, span),\n+            blocks: IndexVec::new(),\n+            span,\n+            sig,\n+        }\n+    }\n+\n+    fn into_mir(self) -> Mir<'tcx> {\n+        Mir::new(\n+            self.blocks,\n+            IndexVec::from_elem_n(\n+                VisibilityScopeData { span: self.span, parent_scope: None }, 1\n+            ),\n+            IndexVec::new(),\n+            self.sig.output(),\n+            self.local_decls,\n+            self.sig.inputs().len(),\n+            vec![],\n+            self.span\n+        )\n+    }\n+\n+    fn source_info(&self) -> SourceInfo {\n+        SourceInfo { span: self.span, scope: ARGUMENT_VISIBILITY_SCOPE }\n+    }\n+\n+    fn block(\n+        &mut self,\n+        statements: Vec<Statement<'tcx>>,\n+        kind: TerminatorKind<'tcx>,\n+        is_cleanup: bool\n+    ) -> BasicBlock {\n+        let source_info = self.source_info();\n+        self.blocks.push(BasicBlockData {\n             statements,\n             terminator: Some(Terminator { source_info, kind }),\n             is_cleanup,\n         })\n-    };\n+    }\n \n-    let make_lvalue = |mutability, ty, local_decls: &mut IndexVec<_, _>| {\n+    fn make_statement(&self, kind: StatementKind<'tcx>) -> Statement<'tcx> {\n+        Statement {\n+            source_info: self.source_info(),\n+            kind,\n+        }\n+    }\n+\n+    fn copy_shim(&mut self) {\n+        let rcvr = Lvalue::Local(Local::new(1+0)).deref();\n+        let ret_statement = self.make_statement(\n+            StatementKind::Assign(\n+                Lvalue::Local(RETURN_POINTER),\n+                Rvalue::Use(Operand::Consume(rcvr))\n+            )\n+        );\n+        self.block(vec![ret_statement], TerminatorKind::Return, false);\n+    }\n+\n+    fn make_lvalue(&mut self, mutability: Mutability, ty: ty::Ty<'tcx>) -> Lvalue<'tcx> {\n+        let span = self.span;\n         Lvalue::Local(\n-            local_decls.push(temp_decl(mutability, ty, span))\n+            self.local_decls.push(temp_decl(mutability, ty, span))\n         )\n-    };\n+    }\n+\n+    fn make_clone_call(\n+        &mut self,\n+        ty: ty::Ty<'tcx>,\n+        rcvr_field: Lvalue<'tcx>,\n+        next: BasicBlock,\n+        cleanup: BasicBlock\n+    ) -> Lvalue<'tcx> {\n+        let tcx = self.tcx;\n+\n+        let substs = Substs::for_item(\n+            tcx,\n+            self.def_id,\n+            |_, _| tcx.types.re_erased,\n+            |_, _| ty\n+        );\n \n-    let call_clone = |ty, rcvr_field, next, cleanup,\n-                      blocks: &mut _, local_decls: &mut IndexVec<_, _>|\n-    {\n         // `func == Clone::clone(&ty) -> ty`\n-        let substs = Substs::for_item(tcx, def_id, |_, _| tcx.types.re_erased, |_, _| ty);\n         let func = Operand::Constant(box Constant {\n-            span: span,\n-            ty: tcx.mk_fn_def(def_id, substs),\n+            span: self.span,\n+            ty: tcx.mk_fn_def(self.def_id, substs),\n             literal: Literal::Value {\n-                value: ConstVal::Function(def_id, substs),\n+                value: ConstVal::Function(self.def_id, substs),\n             },\n         });\n \n-        let ref_loc = make_lvalue(\n+        let ref_loc = self.make_lvalue(\n             Mutability::Not,\n             tcx.mk_ref(tcx.types.re_erased, ty::TypeAndMut {\n                 ty,\n                 mutbl: hir::Mutability::MutImmutable,\n-            }),\n-            local_decls\n+            })\n         );\n \n-        let loc = make_lvalue(Mutability::Not, ty, local_decls);\n+        let loc = self.make_lvalue(Mutability::Not, ty);\n \n         // `let ref_loc: &ty = &rcvr_field;`\n-        let statement = Statement {\n-            source_info,\n-            kind: StatementKind::Assign(\n+        let statement = self.make_statement(\n+            StatementKind::Assign(\n                 ref_loc.clone(),\n                 Rvalue::Ref(tcx.types.re_erased, BorrowKind::Shared, rcvr_field)\n             )\n-        };\n+        );\n \n         // `let loc = Clone::clone(ref_loc);`\n-        block(blocks, vec![statement], TerminatorKind::Call {\n+        self.block(vec![statement], TerminatorKind::Call {\n             func,\n             args: vec![Operand::Consume(ref_loc)],\n             destination: Some((loc.clone(), next)),\n             cleanup: Some(cleanup),\n         }, false);\n \n         loc\n-    };\n-\n-    let is_copy = !self_ty.moves_by_default(tcx, tcx.param_env(def_id), span);\n-    match self_ty.sty {\n-        _ if is_copy => {\n-            // `return *self;`\n-            let ret_statement = Statement {\n-                source_info,\n-                kind: StatementKind::Assign(\n-                    Lvalue::Local(RETURN_POINTER),\n-                    Rvalue::Use(Operand::Consume(rcvr))\n-                )\n-            };\n-            block(&mut blocks, vec![ret_statement], TerminatorKind::Return, false);\n-        }\n-        ty::TyArray(ty, len) => {\n-            let make_loop = |beg, end, loop_body, loop_end,\n-                             blocks: &mut _, local_decls: &mut _, is_cleanup|\n-            {\n-                let cond = make_lvalue(Mutability::Mut, tcx.types.bool, local_decls);\n-                let compute_cond = Statement {\n-                    source_info,\n-                    kind: StatementKind::Assign(\n-                        cond.clone(),\n-                        Rvalue::BinaryOp(BinOp::Ne, Operand::Consume(end), Operand::Consume(beg))\n-                    )\n-                };\n-\n-                // `if end != beg { goto loop_body; } else { goto loop_end; }`\n-                block(\n-                    blocks,\n-                    vec![compute_cond],\n-                    TerminatorKind::if_(tcx, Operand::Consume(cond), loop_body, loop_end),\n-                    is_cleanup\n-                );\n-            };\n-\n-            let make_usize = |value| {\n-                let value = ConstUsize::new(value as u64, tcx.sess.target.uint_type).unwrap();\n-                box Constant {\n-                    span,\n-                    ty: tcx.types.usize,\n-                    literal: Literal::Value {\n-                        value: ConstVal::Integral(ConstInt::Usize(value))\n-                    }\n-                }\n-            };\n+    }\n \n-            let beg = make_lvalue(Mutability::Mut, tcx.types.usize, &mut local_decls);\n-            let end = make_lvalue(Mutability::Not, tcx.types.usize, &mut local_decls);\n-            let ret = make_lvalue(Mutability::Mut, tcx.mk_array(ty, len), &mut local_decls);\n-\n-            // BB #0\n-            // `let mut beg = 0;`\n-            // `let end = len;`\n-            // `goto #1;`\n-            let inits = vec![\n-                Statement {\n-                    source_info,\n-                    kind: StatementKind::Assign(\n-                        beg.clone(),\n-                        Rvalue::Use(Operand::Constant(make_usize(0)))\n-                    )\n-                },\n-                Statement {\n-                    source_info,\n-                    kind: StatementKind::Assign(\n-                        end.clone(),\n-                        Rvalue::Use(Operand::Constant(make_usize(len)))\n-                    )\n-                }\n-            ];\n-            block(&mut blocks, inits, TerminatorKind::Goto { target: BasicBlock::new(1) }, false);\n-\n-            // BB #1: loop {\n-            //     BB #2;\n-            //     BB #3;\n-            // }\n-            // BB #4;\n-            make_loop(\n-                beg.clone(),\n-                end,\n-                BasicBlock::new(2),\n-                BasicBlock::new(4),\n-                &mut blocks,\n-                &mut local_decls,\n-                false\n-            );\n+    fn loop_header(\n+        &mut self,\n+        beg: Lvalue<'tcx>,\n+        end: Lvalue<'tcx>,\n+        loop_body: BasicBlock,\n+        loop_end: BasicBlock,\n+        is_cleanup: bool\n+    ) {\n+        let tcx = self.tcx;\n+\n+        let cond = self.make_lvalue(Mutability::Mut, tcx.types.bool);\n+        let compute_cond = self.make_statement(\n+            StatementKind::Assign(\n+                cond.clone(),\n+                Rvalue::BinaryOp(BinOp::Ne, Operand::Consume(end), Operand::Consume(beg))\n+            )\n+        );\n \n-            // BB #2\n-            // `let cloned = Clone::clone(rcvr[beg])`;\n-            // Goto #3 if ok, #5 if unwinding happens.\n-            let rcvr_field = rcvr.clone().index(Operand::Consume(beg.clone()));\n-            let cloned = call_clone(\n-                ty,\n-                rcvr_field,\n-                BasicBlock::new(3),\n-                BasicBlock::new(5),\n-                &mut blocks,\n-                &mut local_decls\n-            );\n+        // `if end != beg { goto loop_body; } else { goto loop_end; }`\n+        self.block(\n+            vec![compute_cond],\n+            TerminatorKind::if_(tcx, Operand::Consume(cond), loop_body, loop_end),\n+            is_cleanup\n+        );\n+    }\n \n-            // BB #3\n-            // `ret[beg] = cloned;`\n-            // `beg = beg + 1;`\n-            // `goto #1`;\n-            let ret_field = ret.clone().index(Operand::Consume(beg.clone()));\n-            let statements = vec![\n-                Statement {\n-                    source_info,\n-                    kind: StatementKind::Assign(\n-                        ret_field,\n-                        Rvalue::Use(Operand::Consume(cloned))\n-                    )\n-                },\n-                Statement {\n-                    source_info,\n-                    kind: StatementKind::Assign(\n-                        beg.clone(),\n-                        Rvalue::BinaryOp(\n-                            BinOp::Add,\n-                            Operand::Consume(beg.clone()),\n-                            Operand::Constant(make_usize(1))\n-                        )\n-                    )\n-                }\n-            ];\n-            block(\n-                &mut blocks,\n-                statements,\n-                TerminatorKind::Goto { target: BasicBlock::new(1) },\n-                false\n-            );\n+    fn make_usize(&self, value: usize) -> Box<Constant<'tcx>> {\n+        let value = ConstUsize::new(value as u64, self.tcx.sess.target.uint_type).unwrap();\n+        box Constant {\n+            span: self.span,\n+            ty: self.tcx.types.usize,\n+            literal: Literal::Value {\n+                value: ConstVal::Integral(ConstInt::Usize(value))\n+            }\n+        }\n+    }\n \n-            // BB #4\n-            // `return ret;`\n-            let ret_statement = Statement {\n-                source_info: source_info,\n-                kind: StatementKind::Assign(\n-                    Lvalue::Local(RETURN_POINTER),\n-                    Rvalue::Use(Operand::Consume(ret.clone())),\n-                )\n-            };\n-            block(&mut blocks, vec![ret_statement], TerminatorKind::Return, false);\n-\n-            // BB #5 (cleanup)\n-            // `let end = beg;`\n-            // `let mut beg = 0;`\n-            // goto #6;\n-            let end = beg;\n-            let beg = make_lvalue(Mutability::Mut, tcx.types.usize, &mut local_decls);\n-            let init = Statement {\n-                source_info,\n-                kind: StatementKind::Assign(\n+    fn array_shim(&mut self, ty: ty::Ty<'tcx>, len: usize) {\n+        let tcx = self.tcx;\n+        let rcvr = Lvalue::Local(Local::new(1+0)).deref();\n+\n+        let beg = self.make_lvalue(Mutability::Mut, tcx.types.usize);\n+        let end = self.make_lvalue(Mutability::Not, tcx.types.usize);\n+        let ret = self.make_lvalue(Mutability::Mut, tcx.mk_array(ty, len));\n+\n+        // BB #0\n+        // `let mut beg = 0;`\n+        // `let end = len;`\n+        // `goto #1;`\n+        let inits = vec![\n+            self.make_statement(\n+                StatementKind::Assign(\n                     beg.clone(),\n-                    Rvalue::Use(Operand::Constant(make_usize(0)))\n+                    Rvalue::Use(Operand::Constant(self.make_usize(0)))\n                 )\n-            };\n-            block(\n-                &mut blocks,\n-                vec![init],\n-                TerminatorKind::Goto { target: BasicBlock::new(6) },\n-                true\n-            );\n-\n-            // BB #6 (cleanup): loop {\n-            //     BB #7;\n-            //     BB #8;\n-            // }\n-            // BB #9;\n-            make_loop(\n-                beg.clone(),\n-                end,\n-                BasicBlock::new(7),\n-                BasicBlock::new(9),\n-                &mut blocks,\n-                &mut local_decls,\n-                true\n-            );\n-\n-            // BB #7 (cleanup)\n-            // `drop(ret[beg])`;\n-            block(&mut blocks, vec![], TerminatorKind::Drop {\n-                location: ret.index(Operand::Consume(beg.clone())),\n-                target: BasicBlock::new(8),\n-                unwind: None,\n-            }, true);\n-\n-            // BB #8 (cleanup)\n-            // `beg = beg + 1;`\n-            // `goto #6;`\n-            let statement = Statement {\n-                source_info,\n-                kind: StatementKind::Assign(\n+            ),\n+            self.make_statement(\n+                StatementKind::Assign(\n+                    end.clone(),\n+                    Rvalue::Use(Operand::Constant(self.make_usize(len)))\n+                )\n+            )\n+        ];\n+        self.block(inits, TerminatorKind::Goto { target: BasicBlock::new(1) }, false);\n+\n+        // BB #1: loop {\n+        //     BB #2;\n+        //     BB #3;\n+        // }\n+        // BB #4;\n+        self.loop_header(beg.clone(), end, BasicBlock::new(2), BasicBlock::new(4), false);\n+\n+        // BB #2\n+        // `let cloned = Clone::clone(rcvr[beg])`;\n+        // Goto #3 if ok, #5 if unwinding happens.\n+        let rcvr_field = rcvr.clone().index(Operand::Consume(beg.clone()));\n+        let cloned = self.make_clone_call(ty, rcvr_field, BasicBlock::new(3), BasicBlock::new(5));\n+\n+        // BB #3\n+        // `ret[beg] = cloned;`\n+        // `beg = beg + 1;`\n+        // `goto #1`;\n+        let ret_field = ret.clone().index(Operand::Consume(beg.clone()));\n+        let statements = vec![\n+            self.make_statement(\n+                StatementKind::Assign(\n+                    ret_field,\n+                    Rvalue::Use(Operand::Consume(cloned))\n+                )\n+            ),\n+            self.make_statement(\n+                StatementKind::Assign(\n                     beg.clone(),\n                     Rvalue::BinaryOp(\n                         BinOp::Add,\n                         Operand::Consume(beg.clone()),\n-                        Operand::Constant(make_usize(1))\n+                        Operand::Constant(self.make_usize(1))\n                     )\n                 )\n-            };\n-            block(\n-                &mut blocks,\n-                vec![statement],\n-                TerminatorKind::Goto { target: BasicBlock::new(6) },\n-                true\n-            );\n+            )\n+        ];\n+        self.block(statements, TerminatorKind::Goto { target: BasicBlock::new(1) }, false);\n \n-            // BB #9 (resume)\n-            block(&mut blocks, vec![], TerminatorKind::Resume, true);\n-        }\n-        ty::TyTuple(tys, _) => {\n-            let mut returns = Vec::new();\n-            for (i, ity) in tys.iter().enumerate() {\n-                let rcvr_field = rcvr.clone().field(Field::new(i), *ity);\n-\n-                // BB #(2i)\n-                // `returns[i] = Clone::clone(&rcvr.i);`\n-                // Goto #(2i + 2) if ok, #(2i + 1) if unwinding happens.\n-                returns.push(call_clone(\n+        // BB #4\n+        // `return ret;`\n+        let ret_statement = self.make_statement(\n+            StatementKind::Assign(\n+                Lvalue::Local(RETURN_POINTER),\n+                Rvalue::Use(Operand::Consume(ret.clone())),\n+            )\n+        );\n+        self.block(vec![ret_statement], TerminatorKind::Return, false);\n+\n+        // BB #5 (cleanup)\n+        // `let end = beg;`\n+        // `let mut beg = 0;`\n+        // goto #6;\n+        let end = beg;\n+        let beg = self.make_lvalue(Mutability::Mut, tcx.types.usize);\n+        let init = self.make_statement(\n+            StatementKind::Assign(\n+                beg.clone(),\n+                Rvalue::Use(Operand::Constant(self.make_usize(0)))\n+            )\n+        );\n+        self.block(vec![init], TerminatorKind::Goto { target: BasicBlock::new(6) }, true);\n+\n+        // BB #6 (cleanup): loop {\n+        //     BB #7;\n+        //     BB #8;\n+        // }\n+        // BB #9;\n+        self.loop_header(beg.clone(), end, BasicBlock::new(7), BasicBlock::new(9), true);\n+\n+        // BB #7 (cleanup)\n+        // `drop(ret[beg])`;\n+        self.block(vec![], TerminatorKind::Drop {\n+            location: ret.index(Operand::Consume(beg.clone())),\n+            target: BasicBlock::new(8),\n+            unwind: None,\n+        }, true);\n+\n+        // BB #8 (cleanup)\n+        // `beg = beg + 1;`\n+        // `goto #6;`\n+        let statement = self.make_statement(\n+            StatementKind::Assign(\n+                beg.clone(),\n+                Rvalue::BinaryOp(\n+                    BinOp::Add,\n+                    Operand::Consume(beg.clone()),\n+                    Operand::Constant(self.make_usize(1))\n+                )\n+            )\n+        );\n+        self.block(vec![statement], TerminatorKind::Goto { target: BasicBlock::new(6) }, true);\n+\n+        // BB #9 (resume)\n+        self.block(vec![], TerminatorKind::Resume, true);\n+    }\n+\n+    fn tuple_shim(&mut self, tys: &ty::Slice<ty::Ty<'tcx>>) {\n+        let rcvr = Lvalue::Local(Local::new(1+0)).deref();\n+\n+        let mut returns = Vec::new();\n+        for (i, ity) in tys.iter().enumerate() {\n+            let rcvr_field = rcvr.clone().field(Field::new(i), *ity);\n+\n+            // BB #(2i)\n+            // `returns[i] = Clone::clone(&rcvr.i);`\n+            // Goto #(2i + 2) if ok, #(2i + 1) if unwinding happens.\n+            returns.push(\n+                self.make_clone_call(\n                     *ity,\n                     rcvr_field,\n                     BasicBlock::new(2 * i + 2),\n                     BasicBlock::new(2 * i + 1),\n-                    &mut blocks,\n-                    &mut local_decls\n-                ));\n-\n-                // BB #(2i + 1) (cleanup)\n-                if i == 0 {\n-                    // Nothing to drop, just resume.\n-                    block(&mut blocks, vec![], TerminatorKind::Resume, true);\n-                } else {\n-                    // Drop previous field and goto previous cleanup block.\n-                    block(&mut blocks, vec![], TerminatorKind::Drop {\n-                        location: returns[i - 1].clone(),\n-                        target: BasicBlock::new(2 * i - 1),\n-                        unwind: None,\n-                    }, true);\n-                }\n-            }\n-\n-            // `return (returns[0], returns[1], ..., returns[tys.len() - 1]);`\n-            let ret_statement = Statement {\n-                source_info,\n-                kind: StatementKind::Assign(\n-                    Lvalue::Local(RETURN_POINTER),\n-                    Rvalue::Aggregate(\n-                        box AggregateKind::Tuple,\n-                        returns.into_iter().map(Operand::Consume).collect()\n-                    )\n                 )\n-            };\n-            block(&mut blocks, vec![ret_statement], TerminatorKind::Return, false);\n-        }\n-        _ => {\n-            bug!(\"clone shim for `{:?}` which is not `Copy` and is not an aggregate\", self_ty);\n+            );\n+\n+            // BB #(2i + 1) (cleanup)\n+            if i == 0 {\n+                // Nothing to drop, just resume.\n+                self.block(vec![], TerminatorKind::Resume, true);\n+            } else {\n+                // Drop previous field and goto previous cleanup block.\n+                self.block(vec![], TerminatorKind::Drop {\n+                    location: returns[i - 1].clone(),\n+                    target: BasicBlock::new(2 * i - 1),\n+                    unwind: None,\n+                }, true);\n+            }\n         }\n-    };\n \n-    let mir = Mir::new(\n-        blocks,\n-        IndexVec::from_elem_n(\n-            VisibilityScopeData { span: span, parent_scope: None }, 1\n-        ),\n-        IndexVec::new(),\n-        sig.output(),\n-        local_decls,\n-        sig.inputs().len(),\n-        vec![],\n-        span\n-    );\n-    mir\n+        // `return (returns[0], returns[1], ..., returns[tys.len() - 1]);`\n+        let ret_statement = self.make_statement(\n+            StatementKind::Assign(\n+                Lvalue::Local(RETURN_POINTER),\n+                Rvalue::Aggregate(\n+                    box AggregateKind::Tuple,\n+                    returns.into_iter().map(Operand::Consume).collect()\n+                )\n+            )\n+        );\n+       self.block(vec![ret_statement], TerminatorKind::Return, false);\n+    }\n }\n \n /// Build a \"call\" shim for `def_id`. The shim calls the"}, {"sha": "90a411352869ccf09bc42faa68970554750c2ccc", "filename": "src/test/run-pass/builtin-clone-unwind.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d58b40e16b9466ba4e049fe0dae8b8d08df1d44d/src%2Ftest%2Frun-pass%2Fbuiltin-clone-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d58b40e16b9466ba4e049fe0dae8b8d08df1d44d/src%2Ftest%2Frun-pass%2Fbuiltin-clone-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-clone-unwind.rs?ref=d58b40e16b9466ba4e049fe0dae8b8d08df1d44d", "patch": "@@ -12,13 +12,13 @@\n // in case of unwinding.\n \n use std::thread;\n-use std::sync::Arc;\n+use std::rc::Rc;\n \n-struct S(Arc<()>);\n+struct S(Rc<()>);\n \n impl Clone for S {\n     fn clone(&self) -> Self {\n-        if Arc::strong_count(&self.0) == 7 {\n+        if Rc::strong_count(&self.0) == 7 {\n             panic!(\"oops\");\n         }\n \n@@ -27,11 +27,11 @@ impl Clone for S {\n }\n \n fn main() {\n-    let counter = Arc::new(());\n+    let counter = Rc::new(());\n \n     // Unwinding with tuples...\n     let ccounter = counter.clone();\n-    let child = thread::spawn(move || {\n+    let result = std::panic::catch_unwind(move || {\n         let _ = (\n             S(ccounter.clone()),\n             S(ccounter.clone()),\n@@ -40,15 +40,15 @@ fn main() {\n         ).clone();\n     });\n \n-    assert!(child.join().is_err());\n+    assert!(result.is_err());\n     assert_eq!(\n         1,\n-        Arc::strong_count(&counter)\n+        Rc::strong_count(&counter)\n     );\n \n     // ... and with arrays.\n     let ccounter = counter.clone();\n-    let child = thread::spawn(move || {\n+    let child = std::panic::catch_unwind(move || {\n         let _ = [\n             S(ccounter.clone()),\n             S(ccounter.clone()),\n@@ -57,9 +57,9 @@ fn main() {\n         ].clone();\n     });\n \n-    assert!(child.join().is_err());\n+    assert!(result.is_err());\n     assert_eq!(\n         1,\n-        Arc::strong_count(&counter)\n+        Rc::strong_count(&counter)\n     );\n }"}]}