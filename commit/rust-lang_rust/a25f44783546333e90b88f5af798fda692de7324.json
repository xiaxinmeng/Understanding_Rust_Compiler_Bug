{"sha": "a25f44783546333e90b88f5af798fda692de7324", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNWY0NDc4MzU0NjMzM2U5MGI4OGY1YWY3OThmZGE2OTJkZTczMjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-19T02:11:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-19T02:11:48Z"}, "message": "auto merge of #12245 : nick29581/rust/priv2, r=alexcrichton\n\ncloses #4110", "tree": {"sha": "65b310d144b7b75af450b7eaf71ed2f814b34399", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65b310d144b7b75af450b7eaf71ed2f814b34399"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a25f44783546333e90b88f5af798fda692de7324", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a25f44783546333e90b88f5af798fda692de7324", "html_url": "https://github.com/rust-lang/rust/commit/a25f44783546333e90b88f5af798fda692de7324", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a25f44783546333e90b88f5af798fda692de7324/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee8f45ef95aae4ec45099199bb34666d7bfe6824", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee8f45ef95aae4ec45099199bb34666d7bfe6824", "html_url": "https://github.com/rust-lang/rust/commit/ee8f45ef95aae4ec45099199bb34666d7bfe6824"}, {"sha": "df1686dbf18e7c9ecba8d868dbdfa1be8886f855", "url": "https://api.github.com/repos/rust-lang/rust/commits/df1686dbf18e7c9ecba8d868dbdfa1be8886f855", "html_url": "https://github.com/rust-lang/rust/commit/df1686dbf18e7c9ecba8d868dbdfa1be8886f855"}], "stats": {"total": 657, "additions": 549, "deletions": 108}, "files": [{"sha": "1ab5ebc6d61004b90f260cab2b39fd48432e610f", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 118, "deletions": 38, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/a25f44783546333e90b88f5af798fda692de7324/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25f44783546333e90b88f5af798fda692de7324/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=a25f44783546333e90b88f5af798fda692de7324", "patch": "@@ -41,6 +41,11 @@ pub type ExportedItems = HashSet<ast::NodeId>;\n /// reexporting a public struct doesn't inline the doc).\n pub type PublicItems = HashSet<ast::NodeId>;\n \n+/// Result of a checking operation - None => no errors were found. Some => an\n+/// error and contains the span and message for reporting that error and\n+/// optionally the same for a note about the error.\n+type CheckResult = Option<(Span, ~str, Option<(Span, ~str)>)>;\n+\n ////////////////////////////////////////////////////////////////////////////////\n /// The parent visitor, used to determine what's the parent of what (node-wise)\n ////////////////////////////////////////////////////////////////////////////////\n@@ -510,40 +515,50 @@ impl<'a> PrivacyVisitor<'a> {\n         }\n     }\n \n-    /// Guarantee that a particular definition is public, possibly emitting an\n-    /// error message if it's not.\n+    fn report_error(&self, result: CheckResult) -> bool {\n+        match result {\n+            None => true,\n+            Some((span, msg, note)) => {\n+                self.tcx.sess.span_err(span, msg);\n+                match note {\n+                    Some((span, msg)) => self.tcx.sess.span_note(span, msg),\n+                    None => {},\n+                }\n+                false\n+            },\n+        }\n+    }\n+\n+    /// Guarantee that a particular definition is public. Returns a CheckResult\n+    /// which contains any errors found. These can be reported using `report_error`.\n+    /// If the result is `None`, no errors were found.\n     fn ensure_public(&self, span: Span, to_check: ast::DefId,\n-                     source_did: Option<ast::DefId>, msg: &str) -> bool {\n+                     source_did: Option<ast::DefId>, msg: &str) -> CheckResult {\n         match self.def_privacy(to_check) {\n-            ExternallyDenied => {\n-                self.tcx.sess.span_err(span, format!(\"{} is private\", msg))\n-            }\n+            ExternallyDenied => Some((span, format!(\"{} is private\", msg), None)),\n             DisallowedBy(id) => {\n-                if id == source_did.unwrap_or(to_check).node {\n-                    self.tcx.sess.span_err(span, format!(\"{} is private\", msg));\n-                    return false;\n+                let (err_span, err_msg) = if id == source_did.unwrap_or(to_check).node {\n+                    return Some((span, format!(\"{} is private\", msg), None));\n                 } else {\n-                    self.tcx.sess.span_err(span, format!(\"{} is inaccessible\",\n-                                                         msg));\n-                }\n+                    (span, format!(\"{} is inaccessible\", msg))\n+                };\n                 match self.tcx.map.find(id) {\n                     Some(ast_map::NodeItem(item)) => {\n                         let desc = match item.node {\n                             ast::ItemMod(..) => \"module\",\n                             ast::ItemTrait(..) => \"trait\",\n-                            _ => return false,\n+                            _ => return Some((err_span, err_msg, None)),\n                         };\n                         let msg = format!(\"{} `{}` is private\",\n                                           desc,\n                                           token::get_ident(item.ident));\n-                        self.tcx.sess.span_note(span, msg);\n-                    }\n-                    Some(..) | None => {}\n+                        Some((err_span, err_msg, Some((span, msg))))\n+                    },\n+                    _ => Some((err_span, err_msg, None)),\n                 }\n-            }\n-            Allowable => return true\n+            },\n+            Allowable => None,\n         }\n-        return false;\n     }\n \n     // Checks that a field is in scope.\n@@ -613,34 +628,99 @@ impl<'a> PrivacyVisitor<'a> {\n         let method_id = ty::method(self.tcx, method_id).provided_source\n                                                        .unwrap_or(method_id);\n \n-        self.ensure_public(span,\n-                           method_id,\n-                           None,\n-                           format!(\"method `{}`\", token::get_ident(name)));\n+        let string = token::get_ident(name);\n+        self.report_error(self.ensure_public(span,\n+                                             method_id,\n+                                             None,\n+                                             format!(\"method `{}`\", string)));\n     }\n \n     // Checks that a path is in scope.\n     fn check_path(&mut self, span: Span, path_id: ast::NodeId, path: &ast::Path) {\n         debug!(\"privacy - path {}\", self.nodestr(path_id));\n         let def_map = self.tcx.def_map.borrow();\n-        let def = def_map.get().get_copy(&path_id);\n+        let orig_def = def_map.get().get_copy(&path_id);\n         let ck = |tyname: &str| {\n-            let origdid = def_id_of_def(def);\n+            let ck_public = |def: ast::DefId| {\n+                let name = token::get_ident(path.segments\n+                                                .last()\n+                                                .unwrap()\n+                                                .identifier);\n+                let origdid = def_id_of_def(orig_def);\n+                self.ensure_public(span,\n+                                   def,\n+                                   Some(origdid),\n+                                   format!(\"{} `{}`\",\n+                                           tyname,\n+                                           name))\n+            };\n+\n             match *self.last_private_map.get(&path_id) {\n-                resolve::AllPublic => {},\n-                resolve::DependsOn(def) => {\n-                    let name = token::get_ident(path.segments\n-                                                    .last()\n-                                                    .unwrap()\n-                                                    .identifier);\n-                    self.ensure_public(span,\n-                                       def,\n-                                       Some(origdid),\n-                                       format!(\"{} `{}`\",\n-                                               tyname, name));\n-                }\n+                resolve::LastMod(resolve::AllPublic) => {},\n+                resolve::LastMod(resolve::DependsOn(def)) => {\n+                    self.report_error(ck_public(def));\n+                },\n+                resolve::LastImport{value_priv: value_priv,\n+                                    value_used: check_value,\n+                                    type_priv: type_priv,\n+                                    type_used: check_type} => {\n+                    // This dance with found_error is because we don't want to report\n+                    // a privacy error twice for the same directive.\n+                    let found_error = match (type_priv, check_type) {\n+                        (Some(resolve::DependsOn(def)), resolve::Used) => {\n+                            !self.report_error(ck_public(def))\n+                        },\n+                        _ => false,\n+                    };\n+                    if !found_error {\n+                        match (value_priv, check_value) {\n+                            (Some(resolve::DependsOn(def)), resolve::Used) => {\n+                                self.report_error(ck_public(def));\n+                            },\n+                            _ => {},\n+                        }\n+                    }\n+                    // If an import is not used in either namespace, we still want to check\n+                    // that it could be legal. Therefore we check in both namespaces and only\n+                    // report an error if both would be illegal. We only report one error,\n+                    // even if it is illegal to import from both namespaces.\n+                    match (value_priv, check_value, type_priv, check_type) {\n+                        (Some(p), resolve::Unused, None, _) |\n+                        (None, _, Some(p), resolve::Unused) => {\n+                            let p = match p {\n+                                resolve::AllPublic => None,\n+                                resolve::DependsOn(def) => ck_public(def),\n+                            };\n+                            if p.is_some() {\n+                                self.report_error(p);\n+                            }\n+                        },\n+                        (Some(v), resolve::Unused, Some(t), resolve::Unused) => {\n+                            let v = match v {\n+                                resolve::AllPublic => None,\n+                                resolve::DependsOn(def) => ck_public(def),\n+                            };\n+                            let t = match t {\n+                                resolve::AllPublic => None,\n+                                resolve::DependsOn(def) => ck_public(def),\n+                            };\n+                            match (v, t) {\n+                                (Some(_), Some(t)) => {\n+                                    self.report_error(Some(t));\n+                                },\n+                                _ => {},\n+                            }\n+                        },\n+                        _ => {},\n+                    }\n+                },\n             }\n         };\n+        // FIXME(#12334) Imports can refer to definitions in both the type and\n+        // value namespaces. The privacy information is aware of this, but the\n+        // def map is not. Therefore the names we work out below will not always\n+        // be accurate and we can get slightly wonky error messages (but type\n+        // checking is always correct).\n         let def_map = self.tcx.def_map.borrow();\n         match def_map.get().get_copy(&path_id) {\n             ast::DefStaticMethod(..) => ck(\"static method\"),\n@@ -668,7 +748,7 @@ impl<'a> PrivacyVisitor<'a> {\n             // is whether the trait itself is accessible or not.\n             method_param(method_param { trait_id: trait_id, .. }) |\n             method_object(method_object { trait_id: trait_id, .. }) => {\n-                self.ensure_public(span, trait_id, None, \"source trait\");\n+                self.report_error(self.ensure_public(span, trait_id, None, \"source trait\"));\n             }\n         }\n     }"}, {"sha": "327001fcd27036ec38635f96adb9d8a80537e850", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 150, "deletions": 70, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/a25f44783546333e90b88f5af798fda692de7324/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25f44783546333e90b88f5af798fda692de7324/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=a25f44783546333e90b88f5af798fda692de7324", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use driver::session::Session;\n use metadata::csearch;\n use metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n@@ -64,14 +63,34 @@ pub type ExternalExports = HashSet<DefId>;\n pub type LastPrivateMap = HashMap<NodeId, LastPrivate>;\n \n pub enum LastPrivate {\n+    LastMod(PrivateDep),\n+    // `use` directives (imports) can refer to two separate definitions in the\n+    // type and value namespaces. We record here the last private node for each\n+    // and whether the import is in fact used for each.\n+    // If the Option<PrivateDep> fields are None, it means there is no defintion\n+    // in that namespace.\n+    LastImport{value_priv: Option<PrivateDep>,\n+               value_used: ImportUse,\n+               type_priv: Option<PrivateDep>,\n+               type_used: ImportUse},\n+}\n+\n+pub enum PrivateDep {\n     AllPublic,\n     DependsOn(DefId),\n }\n \n+// How an import is used.\n+#[deriving(Eq)]\n+pub enum ImportUse {\n+    Unused,       // The import is not used.\n+    Used,         // The import is used.\n+}\n+\n impl LastPrivate {\n     fn or(self, other: LastPrivate) -> LastPrivate {\n         match (self, other) {\n-            (me, AllPublic) => me,\n+            (me, LastMod(AllPublic)) => me,\n             (_, other) => other,\n         }\n     }\n@@ -84,7 +103,7 @@ enum PatternBindingMode {\n     ArgumentIrrefutableMode,\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n enum Namespace {\n     TypeNS,\n     ValueNS\n@@ -869,7 +888,7 @@ struct Resolver {\n     // so as to avoid printing duplicate errors\n     emit_errors: bool,\n \n-    used_imports: HashSet<NodeId>,\n+    used_imports: HashSet<(NodeId, Namespace)>,\n }\n \n struct BuildReducedGraphVisitor<'a> {\n@@ -904,7 +923,7 @@ impl<'a> Visitor<ReducedGraphParent> for BuildReducedGraphVisitor<'a> {\n \n }\n \n-struct UnusedImportCheckVisitor<'a> { resolver: &'a Resolver }\n+struct UnusedImportCheckVisitor<'a> { resolver: &'a mut Resolver }\n \n impl<'a> Visitor<()> for UnusedImportCheckVisitor<'a> {\n     fn visit_view_item(&mut self, vi: &ViewItem, _: ()) {\n@@ -2152,7 +2171,7 @@ impl Resolver {\n         // First, resolve the module path for the directive, if necessary.\n         let container = if module_path.len() == 0 {\n             // Use the crate root.\n-            Some((self.graph_root.get_module(), AllPublic))\n+            Some((self.graph_root.get_module(), LastMod(AllPublic)))\n         } else {\n             match self.resolve_module_path(module_,\n                                            *module_path,\n@@ -2257,6 +2276,12 @@ impl Resolver {\n                directive.id,\n                lp);\n \n+        let lp = match lp {\n+            LastMod(lp) => lp,\n+            LastImport{..} => self.session.span_bug(directive.span,\n+                                                    \"Not expecting Import here, must be LastMod\"),\n+        };\n+\n         // We need to resolve both namespaces for this to succeed.\n         //\n \n@@ -2287,7 +2312,8 @@ impl Resolver {\n \n         // Unless we managed to find a result in both namespaces (unlikely),\n         // search imports as well.\n-        let mut used_reexport = false;\n+        let mut value_used_reexport = false;\n+        let mut type_used_reexport = false;\n         match (value_result, type_result) {\n             (BoundResult(..), BoundResult(..)) => {} // Continue.\n             _ => {\n@@ -2342,7 +2368,7 @@ impl Resolver {\n                                 }\n                                 Some(target) => {\n                                     let id = import_resolution.id(namespace);\n-                                    this.used_imports.insert(id);\n+                                    this.used_imports.insert((id, namespace));\n                                     return BoundResult(target.target_module,\n                                                        target.bindings);\n                                 }\n@@ -2354,12 +2380,12 @@ impl Resolver {\n                         if value_result.is_unknown() {\n                             value_result = get_binding(self, *import_resolution,\n                                                        ValueNS);\n-                            used_reexport = import_resolution.is_public.get();\n+                            value_used_reexport = import_resolution.is_public.get();\n                         }\n                         if type_result.is_unknown() {\n                             type_result = get_binding(self, *import_resolution,\n                                                       TypeNS);\n-                            used_reexport = import_resolution.is_public.get();\n+                            type_used_reexport = import_resolution.is_public.get();\n                         }\n \n                     }\n@@ -2375,7 +2401,8 @@ impl Resolver {\n \n         // If we didn't find a result in the type namespace, search the\n         // external modules.\n-        let mut used_public = false;\n+        let mut value_used_public = false;\n+        let mut type_used_public = false;\n         match type_result {\n             BoundResult(..) => {}\n             _ => {\n@@ -2393,7 +2420,7 @@ impl Resolver {\n                                 module);\n                         type_result = BoundResult(containing_module,\n                                                   name_bindings);\n-                        used_public = true;\n+                        type_used_public = true;\n                     }\n                 }\n             }\n@@ -2412,7 +2439,7 @@ impl Resolver {\n                 import_resolution.value_target.set(\n                     Some(Target::new(target_module, name_bindings)));\n                 import_resolution.value_id.set(directive.id);\n-                used_public = name_bindings.defined_in_public_namespace(ValueNS);\n+                value_used_public = name_bindings.defined_in_public_namespace(ValueNS);\n             }\n             UnboundResult => { /* Continue. */ }\n             UnknownResult => {\n@@ -2426,7 +2453,7 @@ impl Resolver {\n                 import_resolution.type_target.set(\n                     Some(Target::new(target_module, name_bindings)));\n                 import_resolution.type_id.set(directive.id);\n-                used_public = name_bindings.defined_in_public_namespace(TypeNS);\n+                type_used_public = name_bindings.defined_in_public_namespace(TypeNS);\n             }\n             UnboundResult => { /* Continue. */ }\n             UnknownResult => {\n@@ -2443,7 +2470,8 @@ impl Resolver {\n             self.resolve_error(directive.span, msg);\n             return Failed;\n         }\n-        let used_public = used_reexport || used_public;\n+        let value_used_public = value_used_reexport || value_used_public;\n+        let type_used_public = type_used_reexport || type_used_public;\n \n         assert!(import_resolution.outstanding_references.get() >= 1);\n         import_resolution.outstanding_references.set(\n@@ -2452,28 +2480,33 @@ impl Resolver {\n         // record what this import resolves to for later uses in documentation,\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n-        match import_resolution.value_target.get() {\n+        let value_private = match import_resolution.value_target.get() {\n             Some(target) => {\n                 let def = target.bindings.def_for_namespace(ValueNS).unwrap();\n                 let mut def_map = self.def_map.borrow_mut();\n                 def_map.get().insert(directive.id, def);\n                 let did = def_id_of_def(def);\n-                self.last_private.insert(directive.id,\n-                    if used_public {lp} else {DependsOn(did)});\n-            }\n-            None => {}\n-        }\n-        match import_resolution.type_target.get() {\n+                if value_used_public {Some(lp)} else {Some(DependsOn(did))}\n+            },\n+            // AllPublic here and below is a dummy value, it should never be used because\n+            // _exists is false.\n+            None => None,\n+        };\n+        let type_private = match import_resolution.type_target.get() {\n             Some(target) => {\n                 let def = target.bindings.def_for_namespace(TypeNS).unwrap();\n                 let mut def_map = self.def_map.borrow_mut();\n                 def_map.get().insert(directive.id, def);\n                 let did = def_id_of_def(def);\n-                self.last_private.insert(directive.id,\n-                    if used_public {lp} else {DependsOn(did)});\n-            }\n-            None => {}\n-        }\n+                if type_used_public {Some(lp)} else {Some(DependsOn(did))}\n+            },\n+            None => None,\n+        };\n+\n+        self.last_private.insert(directive.id, LastImport{value_priv: value_private,\n+                                                          value_used: Used,\n+                                                          type_priv: type_private,\n+                                                          type_used: Used});\n \n         debug!(\"(resolving single import) successfully resolved import\");\n         return Success(());\n@@ -2732,7 +2765,7 @@ impl Resolver {\n                                                                    .get() {\n                                                     Some(did) => {\n                                                         closest_private =\n-                                                            DependsOn(did);\n+                                                            LastMod(DependsOn(did));\n                                                     }\n                                                     None => {}\n                                                 }\n@@ -2817,7 +2850,7 @@ impl Resolver {\n                         // resolution process at index zero.\n                         search_module = self.graph_root.get_module();\n                         start_index = 0;\n-                        last_private = AllPublic;\n+                        last_private = LastMod(AllPublic);\n                     }\n                     UseLexicalScope => {\n                         // This is not a crate-relative path. We resolve the\n@@ -2839,7 +2872,7 @@ impl Resolver {\n                             Success(containing_module) => {\n                                 search_module = containing_module;\n                                 start_index = 1;\n-                                last_private = AllPublic;\n+                                last_private = LastMod(AllPublic);\n                             }\n                         }\n                     }\n@@ -2848,9 +2881,9 @@ impl Resolver {\n             Success(PrefixFound(containing_module, index)) => {\n                 search_module = containing_module;\n                 start_index = index;\n-                last_private = DependsOn(containing_module.def_id\n-                                                          .get()\n-                                                          .unwrap());\n+                last_private = LastMod(DependsOn(containing_module.def_id\n+                                                                  .get()\n+                                                                  .unwrap()));\n             }\n         }\n \n@@ -2914,7 +2947,7 @@ impl Resolver {\n                     Some(target) => {\n                         debug!(\"(resolving item in lexical scope) using \\\n                                 import resolution\");\n-                        self.used_imports.insert(import_resolution.id(namespace));\n+                        self.used_imports.insert((import_resolution.id(namespace), namespace));\n                         return Success((target, false));\n                     }\n                 }\n@@ -3199,7 +3232,7 @@ impl Resolver {\n                     Some(target) => {\n                         debug!(\"(resolving name in module) resolved to \\\n                                 import\");\n-                        self.used_imports.insert(import_resolution.id(namespace));\n+                        self.used_imports.insert((import_resolution.id(namespace), namespace));\n                         return Success((target, true));\n                     }\n                 }\n@@ -3808,7 +3841,7 @@ impl Resolver {\n                     // Associate this type parameter with\n                     // the item that bound it\n                     self.record_def(type_parameter.id,\n-                                    (DefTyParamBinder(node_id), AllPublic));\n+                                    (DefTyParamBinder(node_id), LastMod(AllPublic)));\n                     // plain insert (no renaming)\n                     let mut bindings = function_type_rib.bindings\n                                                         .borrow_mut();\n@@ -4269,7 +4302,7 @@ impl Resolver {\n \n                         Some(&primitive_type) => {\n                             result_def =\n-                                Some((DefPrimTy(primitive_type), AllPublic));\n+                                Some((DefPrimTy(primitive_type), LastMod(AllPublic)));\n \n                             if path.segments\n                                    .iter()\n@@ -4438,7 +4471,7 @@ impl Resolver {\n                             // will be able to distinguish variants from\n                             // locals in patterns.\n \n-                            self.record_def(pattern.id, (def, AllPublic));\n+                            self.record_def(pattern.id, (def, LastMod(AllPublic)));\n \n                             // Add the binding to the local ribs, if it\n                             // doesn't already exist in the bindings list. (We\n@@ -4632,10 +4665,10 @@ impl Resolver {\n                         // the lookup happened only within the current module.\n                         match def.def {\n                             def @ DefVariant(..) | def @ DefStruct(..) => {\n-                                return FoundStructOrEnumVariant(def, AllPublic);\n+                                return FoundStructOrEnumVariant(def, LastMod(AllPublic));\n                             }\n                             def @ DefStatic(_, false) => {\n-                                return FoundConst(def, AllPublic);\n+                                return FoundConst(def, LastMod(AllPublic));\n                             }\n                             _ => {\n                                 return BareIdentifierPatternUnresolved;\n@@ -4711,7 +4744,7 @@ impl Resolver {\n                                                       namespace,\n                                                       span) {\n                 Some(def) => {\n-                    return Some((def, AllPublic));\n+                    return Some((def, LastMod(AllPublic)));\n                 }\n                 None => {\n                     // Continue.\n@@ -4741,8 +4774,8 @@ impl Resolver {\n                             // Found it. Stop the search here.\n                             let p = child_name_bindings.defined_in_public_namespace(\n                                             namespace);\n-                            let lp = if p {AllPublic} else {\n-                                DependsOn(def_id_of_def(def))\n+                            let lp = if p {LastMod(AllPublic)} else {\n+                                LastMod(DependsOn(def_id_of_def(def)))\n                             };\n                             return ChildNameDefinition(def, lp);\n                         }\n@@ -4764,8 +4797,8 @@ impl Resolver {\n                             Some(def) => {\n                                 // Found it.\n                                 let id = import_resolution.id(namespace);\n-                                self.used_imports.insert(id);\n-                                return ImportNameDefinition(def, AllPublic);\n+                                self.used_imports.insert((id, namespace));\n+                                return ImportNameDefinition(def, LastMod(AllPublic));\n                             }\n                             None => {\n                                 // This can happen with external impls, due to\n@@ -4792,8 +4825,8 @@ impl Resolver {\n                     match module.def_id.get() {\n                         None => {} // Continue.\n                         Some(def_id) => {\n-                            let lp = if module.is_public {AllPublic} else {\n-                                DependsOn(def_id)\n+                            let lp = if module.is_public {LastMod(AllPublic)} else {\n+                                LastMod(DependsOn(def_id))\n                             };\n                             return ChildNameDefinition(DefMod(def_id), lp);\n                         }\n@@ -4887,7 +4920,7 @@ impl Resolver {\n                                                  0,\n                                                  path.span,\n                                                  PathSearch,\n-                                                 AllPublic) {\n+                                                 LastMod(AllPublic)) {\n             Failed => {\n                 let msg = format!(\"use of undeclared module `::{}`\",\n                                   self.idents_to_str(module_path_idents));\n@@ -4983,7 +5016,7 @@ impl Resolver {\n                         // This lookup is \"all public\" because it only searched\n                         // for one identifier in the current module (couldn't\n                         // have passed through reexports or anything like that.\n-                        return Some((def, AllPublic));\n+                        return Some((def, LastMod(AllPublic)));\n                     }\n                 }\n             }\n@@ -5194,8 +5227,8 @@ impl Resolver {\n                                               format!(\"use of undeclared label `{}`\",\n                                                    token::get_name(label))),\n                     Some(DlDef(def @ DefLabel(_))) => {\n-                        // FIXME: is AllPublic correct?\n-                        self.record_def(expr.id, (def, AllPublic))\n+                        // Since this def is a label, it is never read.\n+                        self.record_def(expr.id, (def, LastMod(AllPublic)))\n                     }\n                     Some(_) => {\n                         self.session.span_bug(expr.span,\n@@ -5353,7 +5386,7 @@ impl Resolver {\n                     };\n                     if candidate_traits.contains(&did) {\n                         self.add_trait_info(&mut found_traits, did, name);\n-                        self.used_imports.insert(import.type_id.get());\n+                        self.used_imports.insert((import.type_id.get(), TypeNS));\n                     }\n                 }\n \n@@ -5395,6 +5428,8 @@ impl Resolver {\n     fn record_def(&mut self, node_id: NodeId, (def, lp): (Def, LastPrivate)) {\n         debug!(\"(recording def) recording {:?} for {:?}, last private {:?}\",\n                 def, node_id, lp);\n+        assert!(match lp {LastImport{..} => false, _ => true},\n+                \"Import should only be used for `use` directives\");\n         self.last_private.insert(node_id, lp);\n         let mut def_map = self.def_map.borrow_mut();\n         def_map.get().insert_or_update_with(node_id, def, |_, old_value| {\n@@ -5426,16 +5461,17 @@ impl Resolver {\n     //\n     // Unused import checking\n     //\n-    // Although this is a lint pass, it lives in here because it depends on\n-    // resolve data structures.\n+    // Although this is mostly a lint pass, it lives in here because it depends on\n+    // resolve data structures and because it finalises the privacy information for\n+    // `use` directives.\n     //\n \n-    fn check_for_unused_imports(&self, krate: &ast::Crate) {\n+    fn check_for_unused_imports(&mut self, krate: &ast::Crate) {\n         let mut visitor = UnusedImportCheckVisitor{ resolver: self };\n         visit::walk_crate(&mut visitor, krate, ());\n     }\n \n-    fn check_for_item_unused_imports(&self, vi: &ViewItem) {\n+    fn check_for_item_unused_imports(&mut self, vi: &ViewItem) {\n         // Ignore is_public import statements because there's no way to be sure\n         // whether they're used or not. Also ignore imports with a dummy span\n         // because this means that they were generated in some fashion by the\n@@ -5448,29 +5484,73 @@ impl Resolver {\n             ViewItemUse(ref path) => {\n                 for p in path.iter() {\n                     match p.node {\n-                        ViewPathSimple(_, _, id) | ViewPathGlob(_, id) => {\n-                            if !self.used_imports.contains(&id) {\n-                                self.session.add_lint(UnusedImports,\n-                                                      id, p.span,\n-                                                      ~\"unused import\");\n-                            }\n-                        }\n-\n+                        ViewPathSimple(_, _, id) => self.finalize_import(id, p.span),\n                         ViewPathList(_, ref list, _) => {\n                             for i in list.iter() {\n-                                if !self.used_imports.contains(&i.node.id) {\n-                                    self.session.add_lint(UnusedImports,\n-                                                          i.node.id, i.span,\n-                                                          ~\"unused import\");\n-                                }\n+                                self.finalize_import(i.node.id, i.span);\n                             }\n-                        }\n+                        },\n+                        ViewPathGlob(_, id) => {\n+                            if !self.used_imports.contains(&(id, TypeNS)) &&\n+                               !self.used_imports.contains(&(id, ValueNS)) {\n+                                self.session.add_lint(UnusedImports, id, p.span, ~\"unused import\");\n+                            }\n+                        },\n                     }\n                 }\n             }\n         }\n     }\n \n+    // We have information about whether `use` (import) directives are actually used now.\n+    // If an import is not used at all, we signal a lint error. If an import is only used\n+    // for a single namespace, we remove the other namespace from the recorded privacy\n+    // information. That means in privacy.rs, we will only check imports and namespaces\n+    // which are used. In particular, this means that if an import could name either a\n+    // public or private item, we will check the correct thing, dependent on how the import\n+    // is used.\n+    fn finalize_import(&mut self, id: NodeId, span: Span) {\n+        debug!(\"finalizing import uses for {}\", self.session.codemap.span_to_snippet(span));\n+\n+        if !self.used_imports.contains(&(id, TypeNS)) &&\n+           !self.used_imports.contains(&(id, ValueNS)) {\n+            self.session.add_lint(UnusedImports, id, span, ~\"unused import\");\n+        }\n+\n+        let (v_priv, t_priv) = match self.last_private.find(&id) {\n+            Some(&LastImport{value_priv: v,\n+                             value_used: _,\n+                             type_priv: t,\n+                             type_used: _}) => (v, t),\n+            Some(_) => fail!(\"We should only have LastImport for `use` directives\"),\n+            _ => return,\n+        };\n+\n+        let mut v_used = if self.used_imports.contains(&(id, ValueNS)) {\n+            Used\n+        } else {\n+            Unused\n+        };\n+        let t_used = if self.used_imports.contains(&(id, TypeNS)) {\n+            Used\n+        } else {\n+            Unused\n+        };\n+\n+        match (v_priv, t_priv) {\n+            // Since some items may be both in the value _and_ type namespaces (e.g., structs)\n+            // we might have two LastPrivates pointing at the same thing. There is no point\n+            // checking both, so lets not check the value one.\n+            (Some(DependsOn(def_v)), Some(DependsOn(def_t))) if def_v == def_t => v_used = Unused,\n+            _ => {},\n+        }\n+\n+        self.last_private.insert(id, LastImport{value_priv: v_priv,\n+                                                value_used: v_used,\n+                                                type_priv: t_priv,\n+                                                type_used: t_used});\n+    }\n+\n     //\n     // Diagnostics\n     //"}, {"sha": "541356f65999b1f41557dfbfe049cf46dc523974", "filename": "src/test/compile-fail/privacy-ns1.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a25f44783546333e90b88f5af798fda692de7324/src%2Ftest%2Fcompile-fail%2Fprivacy-ns1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25f44783546333e90b88f5af798fda692de7324/src%2Ftest%2Fcompile-fail%2Fprivacy-ns1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy-ns1.rs?ref=a25f44783546333e90b88f5af798fda692de7324", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check we do the correct privacy checks when we import a name and there is an\n+// item with that name in both the value and type namespaces.\n+\n+#[feature(globs)];\n+#[allow(dead_code)];\n+#[allow(unused_imports)];\n+\n+// public type, private value\n+pub mod foo1 {\n+    pub trait Bar {\n+    }\n+    pub struct Baz;\n+\n+    fn Bar() { }\n+}\n+\n+fn test_glob1() {\n+    use foo1::*;\n+\n+    Bar();  //~ ERROR unresolved name `Bar`.\n+}\n+\n+// private type, public value\n+pub mod foo2 {\n+    trait Bar {\n+    }\n+    pub struct Baz;\n+\n+    pub fn Bar() { }\n+}\n+\n+fn test_glob2() {\n+    use foo2::*;\n+\n+    let _x: ~Bar;  //~ ERROR use of undeclared type name `Bar`\n+}\n+\n+// neither public\n+pub mod foo3 {\n+    trait Bar {\n+    }\n+    pub struct Baz;\n+\n+    fn Bar() { }\n+}\n+\n+fn test_glob3() {\n+    use foo3::*;\n+\n+    Bar();  //~ ERROR unresolved name `Bar`.\n+    let _x: ~Bar;  //~ ERROR  use of undeclared type name `Bar`\n+}\n+\n+fn main() {\n+}\n+"}, {"sha": "e293153e9da2d921bd59228cb13301a48671f4fc", "filename": "src/test/compile-fail/privacy-ns2.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/a25f44783546333e90b88f5af798fda692de7324/src%2Ftest%2Fcompile-fail%2Fprivacy-ns2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25f44783546333e90b88f5af798fda692de7324/src%2Ftest%2Fcompile-fail%2Fprivacy-ns2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy-ns2.rs?ref=a25f44783546333e90b88f5af798fda692de7324", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check we do the correct privacy checks when we import a name and there is an\n+// item with that name in both the value and type namespaces.\n+\n+#[feature(globs)];\n+#[allow(dead_code)];\n+#[allow(unused_imports)];\n+\n+// public type, private value\n+pub mod foo1 {\n+    pub trait Bar {\n+    }\n+    pub struct Baz;\n+\n+    fn Bar() { }\n+}\n+\n+fn test_single1() {\n+    // In an ideal world, these would be private instead of inaccessible.\n+    use foo1::Bar;  //~ ERROR `Bar` is inaccessible\n+\n+    Bar();\n+}\n+\n+fn test_list1() {\n+    use foo1::{Bar,Baz};  //~ ERROR `Bar` is inaccessible\n+\n+    Bar();\n+}\n+\n+// private type, public value\n+pub mod foo2 {\n+    trait Bar {\n+    }\n+    pub struct Baz;\n+\n+    pub fn Bar() { }\n+}\n+\n+fn test_single2() {\n+    use foo2::Bar;  //~ ERROR `Bar` is private\n+\n+    let _x : ~Bar;\n+}\n+\n+fn test_list2() {\n+    use foo2::{Bar,Baz};  //~ ERROR `Bar` is private\n+\n+    let _x: ~Bar;\n+}\n+\n+// neither public\n+pub mod foo3 {\n+    trait Bar {\n+    }\n+    pub struct Baz;\n+\n+    fn Bar() { }\n+}\n+\n+fn test_unused3() {\n+    use foo3::Bar;  //~ ERROR `Bar` is private\n+    use foo3::{Bar,Baz};  //~ ERROR `Bar` is private\n+}\n+\n+fn test_single3() {\n+    use foo3::Bar;  //~ ERROR `Bar` is private\n+\n+    Bar();\n+    let _x: ~Bar;\n+}\n+\n+fn test_list3() {\n+    use foo3::{Bar,Baz};  //~ ERROR `Bar` is private\n+\n+    Bar();\n+    let _x: ~Bar;\n+}\n+\n+fn main() {\n+}\n+"}, {"sha": "c933e5bc919d20ca0e9d46dc259831b984f7af0d", "filename": "src/test/run-pass/privacy-ns.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/a25f44783546333e90b88f5af798fda692de7324/src%2Ftest%2Frun-pass%2Fprivacy-ns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25f44783546333e90b88f5af798fda692de7324/src%2Ftest%2Frun-pass%2Fprivacy-ns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprivacy-ns.rs?ref=a25f44783546333e90b88f5af798fda692de7324", "patch": "@@ -0,0 +1,124 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-fast\n+\n+// Check we do the correct privacy checks when we import a name and there is an\n+// item with that name in both the value and type namespaces.\n+\n+#[feature(globs)];\n+#[allow(dead_code)];\n+#[allow(unused_imports)];\n+\n+// public type, private value\n+pub mod foo1 {\n+    pub trait Bar {\n+    }\n+    pub struct Baz;\n+\n+    fn Bar() { }\n+}\n+\n+fn test_unused1() {\n+    use foo1::Bar;\n+    use foo1::{Bar,Baz};\n+    use foo1::*;\n+}\n+\n+fn test_single1() {\n+    use foo1::Bar;\n+\n+    let _x: ~Bar;\n+}\n+\n+fn test_list1() {\n+    use foo1::{Bar,Baz};\n+\n+    let _x: ~Bar;\n+}\n+\n+fn test_glob1() {\n+    use foo1::*;\n+\n+    let _x: ~Bar;\n+}\n+\n+// private type, public value\n+pub mod foo2 {\n+    trait Bar {\n+    }\n+    pub struct Baz;\n+\n+    pub fn Bar() { }\n+}\n+\n+fn test_unused2() {\n+    use foo2::Bar;\n+    use foo2::{Bar,Baz};\n+    use foo2::*;\n+}\n+\n+fn test_single2() {\n+    use foo2::Bar;\n+\n+    Bar();\n+}\n+\n+fn test_list2() {\n+    use foo2::{Bar,Baz};\n+\n+    Bar();\n+}\n+\n+fn test_glob2() {\n+    use foo2::*;\n+\n+    Bar();\n+}\n+\n+// public type, public value\n+pub mod foo3 {\n+    pub trait Bar {\n+    }\n+    pub struct Baz;\n+\n+    pub fn Bar() { }\n+}\n+\n+fn test_unused3() {\n+    use foo3::Bar;\n+    use foo3::{Bar,Baz};\n+    use foo3::*;\n+}\n+\n+fn test_single3() {\n+    use foo3::Bar;\n+\n+    Bar();\n+    let _x: ~Bar;\n+}\n+\n+fn test_list3() {\n+    use foo3::{Bar,Baz};\n+\n+    Bar();\n+    let _x: ~Bar;\n+}\n+\n+fn test_glob3() {\n+    use foo3::*;\n+\n+    Bar();\n+    let _x: ~Bar;\n+}\n+\n+fn main() {\n+}\n+"}]}