{"sha": "8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjMjhmZTg5YzdkMzM5NTM4NDFlOGMyMTBlNzY5YmE4Y2U1Y2VlZGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-18T01:29:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-18T01:29:28Z"}, "message": "Auto merge of #68330 - tmandry:rollup-5v29y9r, r=tmandry\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #66660 (Don't warn about snake case for field puns.)\n - #68093 (Fix deref impl typedef)\n - #68204 (Use named fields for `{ast,hir}::ItemKind::Impl`)\n - #68256 (Do not ICE on malformed suggestion spans)\n - #68279 (Clean up E0198 explanation)\n - #68291 (Update sanitizer tests)\n - #68312 (Add regression test for integer literals in generic arguments in where clauses)\n - #68314 (Stop treating `FalseEdges` and `FalseUnwind` as having semantic value for const eval)\n - #68317 (Clean up E0199 explanation)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "8903e14709f4326a22a1bde4654cc3253bc1f1aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8903e14709f4326a22a1bde4654cc3253bc1f1aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "html_url": "https://github.com/rust-lang/rust/commit/8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c", "html_url": "https://github.com/rust-lang/rust/commit/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c"}, {"sha": "14d779c3f0c824ced78f7381c49074cc07c9d602", "url": "https://api.github.com/repos/rust-lang/rust/commits/14d779c3f0c824ced78f7381c49074cc07c9d602", "html_url": "https://github.com/rust-lang/rust/commit/14d779c3f0c824ced78f7381c49074cc07c9d602"}], "stats": {"total": 1034, "additions": 642, "deletions": 392}, "files": [{"sha": "5a4d7ceea2734125cd8f4ec2b9e907e8b18562d5", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -112,7 +112,7 @@ impl Target {\n             ItemKind::Union(..) => Target::Union,\n             ItemKind::Trait(..) => Target::Trait,\n             ItemKind::TraitAlias(..) => Target::TraitAlias,\n-            ItemKind::Impl(..) => Target::Impl,\n+            ItemKind::Impl { .. } => Target::Impl,\n         }\n     }\n \n@@ -144,7 +144,7 @@ impl Target {\n                 let parent_hir_id = tcx.hir().get_parent_item(impl_item.hir_id);\n                 let containing_item = tcx.hir().expect_item(parent_hir_id);\n                 let containing_impl_is_for_trait = match &containing_item.kind {\n-                    hir::ItemKind::Impl(_, _, _, _, tr, _, _) => tr.is_some(),\n+                    hir::ItemKind::Impl { ref of_trait, .. } => of_trait.is_some(),\n                     _ => bug!(\"parent of an ImplItem must be an Impl\"),\n                 };\n                 if containing_impl_is_for_trait {"}, {"sha": "6d7f53133a66644717a88dff7490abe35d5b9fb8", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -341,7 +341,7 @@ impl<'hir> Map<'hir> {\n                 | ItemKind::Use(..)\n                 | ItemKind::ForeignMod(..)\n                 | ItemKind::GlobalAsm(..)\n-                | ItemKind::Impl(..) => return None,\n+                | ItemKind::Impl { .. } => return None,\n             },\n             Node::ForeignItem(item) => match item.kind {\n                 ForeignItemKind::Fn(..) => DefKind::Fn,\n@@ -604,7 +604,7 @@ impl<'hir> Map<'hir> {\n                 | ItemKind::Union(_, ref generics)\n                 | ItemKind::Trait(_, _, ref generics, ..)\n                 | ItemKind::TraitAlias(ref generics, _)\n-                | ItemKind::Impl(_, _, _, ref generics, ..) => Some(generics),\n+                | ItemKind::Impl { ref generics, .. } => Some(generics),\n                 _ => None,\n             },\n             _ => None,\n@@ -821,7 +821,7 @@ impl<'hir> Map<'hir> {\n                     | ItemKind::Struct(..)\n                     | ItemKind::Union(..)\n                     | ItemKind::Trait(..)\n-                    | ItemKind::Impl(..) => true,\n+                    | ItemKind::Impl { .. } => true,\n                     _ => false,\n                 },\n                 Node::ForeignItem(fi) => match fi.kind {\n@@ -1332,7 +1332,7 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n                 ItemKind::Union(..) => \"union\",\n                 ItemKind::Trait(..) => \"trait\",\n                 ItemKind::TraitAlias(..) => \"trait alias\",\n-                ItemKind::Impl(..) => \"impl\",\n+                ItemKind::Impl { .. } => \"impl\",\n             };\n             format!(\"{} {}{}\", item_str, path_str(), id_str)\n         }"}, {"sha": "a2009461fa568e22d24c822d05da7380aafdd19c", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -254,7 +254,7 @@ fn emit_msg_span(\n \n fn item_scope_tag(item: &hir::Item<'_>) -> &'static str {\n     match item.kind {\n-        hir::ItemKind::Impl(..) => \"impl\",\n+        hir::ItemKind::Impl { .. } => \"impl\",\n         hir::ItemKind::Struct(..) => \"struct\",\n         hir::ItemKind::Union(..) => \"union\",\n         hir::ItemKind::Enum(..) => \"enum\","}, {"sha": "c09fd3079731c33af533e5c963f27cbcbeab37c1", "filename": "src/librustc/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -88,8 +88,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     ..\n                 })\n                 | hir::Node::Item(hir::Item {\n-                    kind: hir::ItemKind::Impl(_, _, _, generics, ..),\n-                    ..\n+                    kind: hir::ItemKind::Impl { generics, .. }, ..\n                 }) if projection.is_some() => {\n                     // Missing associated type bound.\n                     suggest_restriction(&generics, \"the associated type\", err);\n@@ -115,7 +114,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     ..\n                 })\n                 | hir::Node::Item(hir::Item {\n-                    kind: hir::ItemKind::Impl(_, _, _, generics, ..),\n+                    kind: hir::ItemKind::Impl { generics, .. },\n                     span,\n                     ..\n                 })"}, {"sha": "f058a4d2df24a60ed4626126e74092c8dc0a92ee", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -651,7 +651,7 @@ pub fn impl_is_default(tcx: TyCtxt<'_>, node_item_def_id: DefId) -> bool {\n     match tcx.hir().as_local_hir_id(node_item_def_id) {\n         Some(hir_id) => {\n             let item = tcx.hir().expect_item(hir_id);\n-            if let hir::ItemKind::Impl(_, _, defaultness, ..) = item.kind {\n+            if let hir::ItemKind::Impl { defaultness, .. } = item.kind {\n                 defaultness.is_default()\n             } else {\n                 false"}, {"sha": "869ba5315c1aee3c5fab435e6e723be9b05bdfad", "filename": "src/librustc/traits/wf.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fwf.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -229,9 +229,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         //      |\n                         //      = note: expected type `u32`\n                         //                 found type `()`\n-                        if let Some(hir::ItemKind::Impl(.., impl_items)) = item.map(|i| &i.kind) {\n+                        if let Some(hir::ItemKind::Impl { items, .. }) = item.map(|i| &i.kind) {\n                             let trait_assoc_item = tcx.associated_item(proj.projection_def_id());\n-                            if let Some(impl_item) = impl_items\n+                            if let Some(impl_item) = items\n                                 .iter()\n                                 .filter(|item| item.ident == trait_assoc_item.ident)\n                                 .next()\n@@ -279,14 +279,14 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         //      |     ^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `bool`\n                         if let (\n                             ty::Projection(ty::ProjectionTy { item_def_id, .. }),\n-                            Some(hir::ItemKind::Impl(.., impl_items)),\n+                            Some(hir::ItemKind::Impl { items, .. }),\n                         ) = (&proj.skip_binder().self_ty().kind, item.map(|i| &i.kind))\n                         {\n                             if let Some((impl_item, trait_assoc_item)) = trait_assoc_items\n                                 .filter(|i| i.def_id == *item_def_id)\n                                 .next()\n                                 .and_then(|trait_assoc_item| {\n-                                    impl_items\n+                                    items\n                                         .iter()\n                                         .filter(|i| i.ident == trait_assoc_item.ident)\n                                         .next()"}, {"sha": "6da2d457f3c3b5692d103736cd74d7cb4d9a66b3", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -67,14 +67,15 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n         if let Some(hir_id) = item_hir_id {\n             self.lctx.with_parent_item_lifetime_defs(hir_id, |this| {\n                 let this = &mut ItemLowerer { lctx: this };\n-                if let ItemKind::Impl(.., ref opt_trait_ref, _, _) = item.kind {\n-                    if opt_trait_ref.as_ref().map(|tr| tr.constness.is_some()).unwrap_or(false) {\n+                if let ItemKind::Impl { ref of_trait, .. } = item.kind {\n+                    if of_trait.as_ref().map(|tr| tr.constness.is_some()).unwrap_or(false) {\n+                        this.with_trait_impl_ref(of_trait, |this| visit::walk_item(this, item));\n                         this.lctx\n                             .diagnostic()\n                             .span_err(item.span, \"const trait impls are not yet implemented\");\n                     }\n \n-                    this.with_trait_impl_ref(opt_trait_ref, |this| visit::walk_item(this, item));\n+                    this.with_trait_impl_ref(of_trait, |this| visit::walk_item(this, item));\n                 } else {\n                     visit::walk_item(this, item);\n                 }\n@@ -118,7 +119,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let old_len = self.in_scope_lifetimes.len();\n \n         let parent_generics = match self.items.get(&parent_hir_id).unwrap().kind {\n-            hir::ItemKind::Impl(_, _, _, ref generics, ..)\n+            hir::ItemKind::Impl { ref generics, .. }\n             | hir::ItemKind::Trait(_, _, ref generics, ..) => &generics.params[..],\n             _ => &[],\n         };\n@@ -173,7 +174,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 vec\n             }\n             ItemKind::MacroDef(..) => SmallVec::new(),\n-            ItemKind::Fn(..) | ItemKind::Impl(.., None, _, _) => smallvec![i.id],\n+            ItemKind::Fn(..) | ItemKind::Impl { of_trait: None, .. } => smallvec![i.id],\n             ItemKind::Static(ref ty, ..) => {\n                 let mut ids = smallvec![i.id];\n                 if self.sess.features_untracked().impl_trait_in_bindings {\n@@ -361,15 +362,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     self.lower_generics(generics, ImplTraitContext::disallowed()),\n                 )\n             }\n-            ItemKind::Impl(\n+            ItemKind::Impl {\n                 unsafety,\n                 polarity,\n                 defaultness,\n-                ref ast_generics,\n-                ref trait_ref,\n-                ref ty,\n-                ref impl_items,\n-            ) => {\n+                generics: ref ast_generics,\n+                of_trait: ref trait_ref,\n+                self_ty: ref ty,\n+                items: ref impl_items,\n+            } => {\n                 let def_id = self.resolver.definitions().local_def_id(id);\n \n                 // Lower the \"impl header\" first. This ordering is important\n@@ -417,15 +418,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         )\n                     });\n \n-                hir::ItemKind::Impl(\n+                hir::ItemKind::Impl {\n                     unsafety,\n                     polarity,\n-                    self.lower_defaultness(defaultness, true /* [1] */),\n+                    defaultness: self.lower_defaultness(defaultness, true /* [1] */),\n                     generics,\n-                    trait_ref,\n-                    lowered_ty,\n-                    new_impl_items,\n-                )\n+                    of_trait: trait_ref,\n+                    self_ty: lowered_ty,\n+                    items: new_impl_items,\n+                }\n             }\n             ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref items) => {\n                 let bounds = self.lower_param_bounds(bounds, ImplTraitContext::disallowed());"}, {"sha": "23701459025ae3dd8b12fcb967135ed613f3f6db", "filename": "src/librustc_ast_passes/ast_validation.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_ast_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_ast_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fast_validation.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -612,9 +612,17 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         }\n \n         match item.kind {\n-            ItemKind::Impl(unsafety, polarity, _, _, Some(..), ref ty, ref impl_items) => {\n+            ItemKind::Impl {\n+                unsafety,\n+                polarity,\n+                defaultness: _,\n+                generics: _,\n+                of_trait: Some(_),\n+                ref self_ty,\n+                ref items,\n+            } => {\n                 self.invalid_visibility(&item.vis, None);\n-                if let TyKind::Err = ty.kind {\n+                if let TyKind::Err = self_ty.kind {\n                     self.err_handler()\n                         .struct_span_err(item.span, \"`impl Trait for .. {}` is an obsolete syntax\")\n                         .help(\"use `auto trait Trait {}` instead\")\n@@ -629,15 +637,23 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     )\n                     .emit();\n                 }\n-                for impl_item in impl_items {\n+                for impl_item in items {\n                     self.invalid_visibility(&impl_item.vis, None);\n                     if let AssocItemKind::Fn(ref sig, _) = impl_item.kind {\n                         self.check_trait_fn_not_const(sig.header.constness);\n                         self.check_trait_fn_not_async(impl_item.span, sig.header.asyncness.node);\n                     }\n                 }\n             }\n-            ItemKind::Impl(unsafety, polarity, defaultness, _, None, _, _) => {\n+            ItemKind::Impl {\n+                unsafety,\n+                polarity,\n+                defaultness,\n+                generics: _,\n+                of_trait: None,\n+                self_ty: _,\n+                items: _,\n+            } => {\n                 self.invalid_visibility(\n                     &item.vis,\n                     Some(\"place qualifiers on individual impl items instead\"),"}, {"sha": "71cd66ddef409a517e49e188db621a442524de61", "filename": "src/librustc_ast_passes/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Ffeature_gate.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -339,7 +339,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 }\n             }\n \n-            ast::ItemKind::Impl(_, polarity, defaultness, ..) => {\n+            ast::ItemKind::Impl { polarity, defaultness, .. } => {\n                 if polarity == ast::ImplPolarity::Negative {\n                     gate_feature_post!(\n                         &self,"}, {"sha": "d346dbc8b4ee71a91aa6908c83b7338b09c54bef", "filename": "src/librustc_builtin_macros/deriving/generic/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -705,15 +705,15 @@ impl<'a> TraitDef<'a> {\n             self.span,\n             Ident::invalid(),\n             a,\n-            ast::ItemKind::Impl(\n+            ast::ItemKind::Impl {\n                 unsafety,\n-                ast::ImplPolarity::Positive,\n-                ast::Defaultness::Final,\n-                trait_generics,\n-                opt_trait_ref,\n-                self_type,\n-                methods.into_iter().chain(associated_types).collect(),\n-            ),\n+                polarity: ast::ImplPolarity::Positive,\n+                defaultness: ast::Defaultness::Final,\n+                generics: trait_generics,\n+                of_trait: opt_trait_ref,\n+                self_ty: self_type,\n+                items: methods.into_iter().chain(associated_types).collect(),\n+            },\n         )\n     }\n "}, {"sha": "9aa7623dc9f77cd1e3f856869b7b5aeee471792f", "filename": "src/librustc_builtin_macros/deriving/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -156,15 +156,15 @@ fn inject_impl_of_structural_trait(\n         span,\n         ast::Ident::invalid(),\n         attrs,\n-        ItemKind::Impl(\n-            ast::Unsafety::Normal,\n-            ast::ImplPolarity::Positive,\n-            ast::Defaultness::Final,\n+        ItemKind::Impl {\n+            unsafety: ast::Unsafety::Normal,\n+            polarity: ast::ImplPolarity::Positive,\n+            defaultness: ast::Defaultness::Final,\n             generics,\n-            Some(trait_ref),\n-            self_type,\n-            Vec::new(),\n-        ),\n+            of_trait: Some(trait_ref),\n+            self_ty: self_type,\n+            items: Vec::new(),\n+        },\n     );\n \n     push(Annotatable::Item(newitem));"}, {"sha": "687214a205096ff62c0c5454062938714c309ea7", "filename": "src/librustc_error_codes/error_codes/E0198.md", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_error_codes%2Ferror_codes%2FE0198.md", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_error_codes%2Ferror_codes%2FE0198.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0198.md?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -1,17 +1,18 @@\n-A negative implementation is one that excludes a type from implementing a\n-particular trait. Not being able to use a trait is always a safe operation,\n-so negative implementations are always safe and never need to be marked as\n-unsafe.\n+A negative implementation was marked as unsafe.\n \n-```compile_fail\n-#![feature(optin_builtin_traits)]\n+Erroneous code example:\n \n+```compile_fail\n struct Foo;\n \n-// unsafe is unnecessary\n-unsafe impl !Clone for Foo { }\n+unsafe impl !Clone for Foo { } // error!\n ```\n \n+A negative implementation is one that excludes a type from implementing a\n+particular trait. Not being able to use a trait is always a safe operation,\n+so negative implementations are always safe and never need to be marked as\n+unsafe.\n+\n This will compile:\n \n ```ignore (ignore auto_trait future compatibility warning)"}, {"sha": "88130e8e5e596540c2c10b02bb8ff41baca5cf27", "filename": "src/librustc_error_codes/error_codes/E0199.md", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_error_codes%2Ferror_codes%2FE0199.md", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_error_codes%2Ferror_codes%2FE0199.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0199.md?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -1,14 +1,23 @@\n+A trait implementation was marked as unsafe while the trait is safe.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0199\n+struct Foo;\n+\n+trait Bar { }\n+\n+unsafe impl Bar for Foo { } // error!\n+```\n+\n Safe traits should not have unsafe implementations, therefore marking an\n implementation for a safe trait unsafe will cause a compiler error. Removing\n-the unsafe marker on the trait noted in the error will resolve this problem.\n+the unsafe marker on the trait noted in the error will resolve this problem:\n \n-```compile_fail,E0199\n+```\n struct Foo;\n \n trait Bar { }\n \n-// this won't compile because Bar is safe\n-unsafe impl Bar for Foo { }\n-// this will compile\n-impl Bar for Foo { }\n+impl Bar for Foo { } // ok!\n ```"}, {"sha": "b0e0cb611afaffb60711b97e46c21e669ff2d4dc", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -1476,6 +1476,15 @@ impl EmitterWriter {\n             None => return Ok(()),\n         };\n \n+        // Render the replacements for each suggestion\n+        let suggestions = suggestion.splice_lines(&**sm);\n+\n+        if suggestions.is_empty() {\n+            // Suggestions coming from macros can have malformed spans. This is a heavy handed\n+            // approach to avoid ICEs by ignoring the suggestion outright.\n+            return Ok(());\n+        }\n+\n         let mut buffer = StyledBuffer::new();\n \n         // Render the suggestion message\n@@ -1492,9 +1501,6 @@ impl EmitterWriter {\n             Some(Style::HeaderMsg),\n         );\n \n-        // Render the replacements for each suggestion\n-        let suggestions = suggestion.splice_lines(&**sm);\n-\n         let mut row_num = 2;\n         let mut notice_capitalization = false;\n         for (complete, parts, only_capitalization) in suggestions.iter().take(MAX_SUGGESTIONS) {\n@@ -1505,7 +1511,9 @@ impl EmitterWriter {\n             let show_underline = !(parts.len() == 1 && parts[0].snippet.trim() == complete.trim())\n                 && complete.lines().count() == 1;\n \n-            let lines = sm.span_to_lines(parts[0].span).unwrap();\n+            let lines = sm\n+                .span_to_lines(parts[0].span)\n+                .expect(\"span_to_lines failed when emitting suggestion\");\n \n             assert!(!lines.lines.is_empty());\n "}, {"sha": "827e9b831f32d711978c1b0c960fc90aabc4ab49", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -10,6 +10,7 @@\n \n pub use emitter::ColorConfig;\n \n+use log::debug;\n use Level::*;\n \n use emitter::{is_case_difference, Emitter, EmitterWriter};\n@@ -174,6 +175,15 @@ impl CodeSuggestion {\n \n         self.substitutions\n             .iter()\n+            .filter(|subst| {\n+                // Suggestions coming from macros can have malformed spans. This is a heavy\n+                // handed approach to avoid ICEs by ignoring the suggestion outright.\n+                let invalid = subst.parts.iter().any(|item| cm.is_valid_span(item.span).is_err());\n+                if invalid {\n+                    debug!(\"splice_lines: suggestion contains an invalid span: {:?}\", subst);\n+                }\n+                !invalid\n+            })\n             .cloned()\n             .map(|mut substitution| {\n                 // Assumption: all spans are in the same file, and all spans"}, {"sha": "1fef871b5140e41ad2b24b94b3cec134c0ef493c", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -2436,15 +2436,18 @@ pub enum ItemKind<'hir> {\n     TraitAlias(Generics<'hir>, GenericBounds<'hir>),\n \n     /// An implementation, e.g., `impl<A> Trait for Foo { .. }`.\n-    Impl(\n-        Unsafety,\n-        ImplPolarity,\n-        Defaultness,\n-        Generics<'hir>,\n-        Option<TraitRef<'hir>>, // (optional) trait this impl implements\n-        &'hir Ty<'hir>,         // self\n-        &'hir [ImplItemRef<'hir>],\n-    ),\n+    Impl {\n+        unsafety: Unsafety,\n+        polarity: ImplPolarity,\n+        defaultness: Defaultness,\n+        generics: Generics<'hir>,\n+\n+        /// The trait being implemented, if any.\n+        of_trait: Option<TraitRef<'hir>>,\n+\n+        self_ty: &'hir Ty<'hir>,\n+        items: &'hir [ImplItemRef<'hir>],\n+    },\n }\n \n impl ItemKind<'_> {\n@@ -2465,7 +2468,7 @@ impl ItemKind<'_> {\n             ItemKind::Union(..) => \"union\",\n             ItemKind::Trait(..) => \"trait\",\n             ItemKind::TraitAlias(..) => \"trait alias\",\n-            ItemKind::Impl(..) => \"impl\",\n+            ItemKind::Impl { .. } => \"impl\",\n         }\n     }\n \n@@ -2478,7 +2481,7 @@ impl ItemKind<'_> {\n             | ItemKind::Struct(_, ref generics)\n             | ItemKind::Union(_, ref generics)\n             | ItemKind::Trait(_, _, ref generics, _, _)\n-            | ItemKind::Impl(_, _, _, ref generics, _, _, _) => generics,\n+            | ItemKind::Impl { ref generics, .. } => generics,\n             _ => return None,\n         })\n     }"}, {"sha": "1a73e41db9da54c71d92d2a72d22239ac9c562bb", "filename": "src/librustc_hir/intravisit.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_hir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_hir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fintravisit.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -566,12 +566,20 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n             // `visit_enum_def()` takes care of visiting the `Item`'s `HirId`.\n             visitor.visit_enum_def(enum_definition, generics, item.hir_id, item.span)\n         }\n-        ItemKind::Impl(.., ref generics, ref opt_trait_reference, ref typ, impl_item_refs) => {\n+        ItemKind::Impl {\n+            unsafety: _,\n+            defaultness: _,\n+            polarity: _,\n+            ref generics,\n+            ref of_trait,\n+            ref self_ty,\n+            items,\n+        } => {\n             visitor.visit_id(item.hir_id);\n             visitor.visit_generics(generics);\n-            walk_list!(visitor, visit_trait_ref, opt_trait_reference);\n-            visitor.visit_ty(typ);\n-            walk_list!(visitor, visit_impl_item_ref, impl_item_refs);\n+            walk_list!(visitor, visit_trait_ref, of_trait);\n+            visitor.visit_ty(self_ty);\n+            walk_list!(visitor, visit_impl_item_ref, items);\n         }\n         ItemKind::Struct(ref struct_definition, ref generics)\n         | ItemKind::Union(ref struct_definition, ref generics) => {"}, {"sha": "6c7d419395317b950a713df4949ed62c17aa3d2f", "filename": "src/librustc_hir/print.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_hir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_hir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fprint.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -627,15 +627,15 @@ impl<'a> State<'a> {\n                 self.head(visibility_qualified(&item.vis, \"union\"));\n                 self.print_struct(struct_def, generics, item.ident.name, item.span, true);\n             }\n-            hir::ItemKind::Impl(\n+            hir::ItemKind::Impl {\n                 unsafety,\n                 polarity,\n                 defaultness,\n                 ref generics,\n-                ref opt_trait,\n-                ref ty,\n-                impl_items,\n-            ) => {\n+                ref of_trait,\n+                ref self_ty,\n+                items,\n+            } => {\n                 self.head(\"\");\n                 self.print_visibility(&item.vis);\n                 self.print_defaultness(defaultness);\n@@ -651,19 +651,19 @@ impl<'a> State<'a> {\n                     self.s.word(\"!\");\n                 }\n \n-                if let Some(ref t) = opt_trait {\n+                if let Some(ref t) = of_trait {\n                     self.print_trait_ref(t);\n                     self.s.space();\n                     self.word_space(\"for\");\n                 }\n \n-                self.print_type(&ty);\n+                self.print_type(&self_ty);\n                 self.print_where_clause(&generics.where_clause);\n \n                 self.s.space();\n                 self.bopen();\n                 self.print_inner_attributes(&item.attrs);\n-                for impl_item in impl_items {\n+                for impl_item in items {\n                     self.ann.nested(self, Nested::ImplItem(impl_item.id));\n                 }\n                 self.bclose(item.span);"}, {"sha": "c5e74868bda4a705352197c4a08eb0da0674ca27", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -315,7 +315,7 @@ impl DirtyCleanVisitor<'tcx> {\n                     //HirItem::Trait(..) => (\"ItemTrait\", LABELS_TRAIT),\n \n                     // An implementation, eg `impl<A> Trait for Foo { .. }`\n-                    HirItem::Impl(..) => (\"ItemKind::Impl\", LABELS_IMPL),\n+                    HirItem::Impl { .. } => (\"ItemKind::Impl\", LABELS_IMPL),\n \n                     _ => self.tcx.sess.span_fatal(\n                         attr.span,"}, {"sha": "c8d3d5f9c83d8d18ac7f44fcbef9c9c29c57318e", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -251,7 +251,7 @@ impl EarlyLintPass for UnsafeCode {\n                 self.report_unsafe(cx, it.span, \"declaration of an `unsafe` trait\")\n             }\n \n-            ast::ItemKind::Impl(ast::Unsafety::Unsafe, ..) => {\n+            ast::ItemKind::Impl { unsafety: ast::Unsafety::Unsafe, .. } => {\n                 self.report_unsafe(cx, it.span, \"implementation of an `unsafe` trait\")\n             }\n \n@@ -431,15 +431,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                 \"a trait\"\n             }\n             hir::ItemKind::TyAlias(..) => \"a type alias\",\n-            hir::ItemKind::Impl(.., Some(ref trait_ref), _, impl_item_refs) => {\n+            hir::ItemKind::Impl { of_trait: Some(ref trait_ref), items, .. } => {\n                 // If the trait is private, add the impl items to `private_traits` so they don't get\n                 // reported for missing docs.\n                 let real_trait = trait_ref.path.res.def_id();\n                 if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(real_trait) {\n                     match cx.tcx.hir().find(hir_id) {\n                         Some(Node::Item(item)) => {\n                             if let hir::VisibilityKind::Inherited = item.vis.node {\n-                                for impl_item_ref in impl_item_refs {\n+                                for impl_item_ref in items {\n                                     self.private_traits.insert(impl_item_ref.id.hir_id);\n                                 }\n                             }"}, {"sha": "91aeccbb5e334457e44b6ce9e0ed4cfabdc79e52", "filename": "src/librustc_lint/internal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_lint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_lint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Finternal.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -221,7 +221,7 @@ declare_lint_pass!(LintPassImpl => [LINT_PASS_IMPL_WITHOUT_MACRO]);\n \n impl EarlyLintPass for LintPassImpl {\n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n-        if let ItemKind::Impl(_, _, _, _, Some(lint_pass), _, _) = &item.kind {\n+        if let ItemKind::Impl { of_trait: Some(lint_pass), .. } = &item.kind {\n             if let Some(last) = lint_pass.path.segments.last() {\n                 if last.ident.name == sym::LintPass {\n                     let expn_data = lint_pass.path.span.ctxt().outer_expn_data();"}, {"sha": "394da4a5bb0c151942a897913b39d92468a8c77d", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -350,7 +350,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n     }\n \n     fn check_pat(&mut self, cx: &LateContext<'_, '_>, p: &hir::Pat<'_>) {\n-        if let &PatKind::Binding(_, _, ident, _) = &p.kind {\n+        if let &PatKind::Binding(_, hid, ident, _) = &p.kind {\n+            if let hir::Node::Pat(parent_pat) = cx.tcx.hir().get(cx.tcx.hir().get_parent_node(hid))\n+            {\n+                if let PatKind::Struct(_, field_pats, _) = &parent_pat.kind {\n+                    for field in field_pats.iter() {\n+                        if field.ident != ident {\n+                            // Only check if a new name has been introduced, to avoid warning\n+                            // on both the struct definition and this pattern.\n+                            self.check_snake_case(cx, \"variable\", &ident);\n+                        }\n+                    }\n+                    return;\n+                }\n+            }\n             self.check_snake_case(cx, \"variable\", &ident);\n         }\n     }"}, {"sha": "9d2bea28c8c2ebf88da381576bb93becd9c8ad9c", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -1073,7 +1073,7 @@ impl EncodeContext<'tcx> {\n                     ctor: None,\n                 }), adt_def.repr)\n             }\n-            hir::ItemKind::Impl(_, _, defaultness, ..) => {\n+            hir::ItemKind::Impl { defaultness, .. } => {\n                 let trait_ref = self.tcx.impl_trait_ref(def_id);\n                 let polarity = self.tcx.impl_polarity(def_id);\n                 let parent = if let Some(trait_ref) = trait_ref {\n@@ -1149,7 +1149,7 @@ impl EncodeContext<'tcx> {\n                     })\n                 )\n             }\n-            hir::ItemKind::Impl(..) | hir::ItemKind::Trait(..) => {\n+            hir::ItemKind::Impl { .. } | hir::ItemKind::Trait(..) => {\n                 let associated_item_def_ids = self.tcx.associated_item_def_ids(def_id);\n                 record!(self.per_def.children[def_id] <-\n                     associated_item_def_ids.iter().map(|&def_id| {\n@@ -1172,13 +1172,13 @@ impl EncodeContext<'tcx> {\n             | hir::ItemKind::Enum(..)\n             | hir::ItemKind::Struct(..)\n             | hir::ItemKind::Union(..)\n-            | hir::ItemKind::Impl(..) => self.encode_item_type(def_id),\n+            | hir::ItemKind::Impl { .. } => self.encode_item_type(def_id),\n             _ => {}\n         }\n         if let hir::ItemKind::Fn(..) = item.kind {\n             record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n         }\n-        if let hir::ItemKind::Impl(..) = item.kind {\n+        if let hir::ItemKind::Impl { .. } = item.kind {\n             if let Some(trait_ref) = self.tcx.impl_trait_ref(def_id) {\n                 record!(self.per_def.impl_trait_ref[def_id] <- trait_ref);\n             }\n@@ -1199,7 +1199,7 @@ impl EncodeContext<'tcx> {\n             | hir::ItemKind::Enum(..)\n             | hir::ItemKind::Struct(..)\n             | hir::ItemKind::Union(..)\n-            | hir::ItemKind::Impl(..)\n+            | hir::ItemKind::Impl { .. }\n             | hir::ItemKind::OpaqueTy(..)\n             | hir::ItemKind::Trait(..)\n             | hir::ItemKind::TraitAlias(..) => {\n@@ -1645,7 +1645,7 @@ impl EncodeContext<'tcx> {\n             hir::ItemKind::Union(..) => {\n                 self.encode_fields(def_id);\n             }\n-            hir::ItemKind::Impl(..) => {\n+            hir::ItemKind::Impl { .. } => {\n                 for &trait_item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n                     self.encode_info_for_impl_item(trait_item_def_id);\n                 }\n@@ -1666,7 +1666,7 @@ struct ImplVisitor<'tcx> {\n \n impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        if let hir::ItemKind::Impl(..) = item.kind {\n+        if let hir::ItemKind::Impl { .. } = item.kind {\n             let impl_id = self.tcx.hir().local_def_id(item.hir_id);\n             if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_id) {\n                 self.impls.entry(trait_ref.def_id).or_default().push(impl_id.index);"}, {"sha": "f4611c32e0a32a21bcb40794d66e3d0442d84ed4", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -954,7 +954,7 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n                 // Nothing to do, just keep recursing.\n             }\n \n-            hir::ItemKind::Impl(..) => {\n+            hir::ItemKind::Impl { .. } => {\n                 if self.mode == MonoItemCollectionMode::Eager {\n                     create_mono_items_for_default_impls(self.tcx, item, self.output);\n                 }\n@@ -1098,7 +1098,7 @@ fn create_mono_items_for_default_impls<'tcx>(\n     output: &mut Vec<MonoItem<'tcx>>,\n ) {\n     match item.kind {\n-        hir::ItemKind::Impl(_, _, _, ref generics, .., ref impl_item_refs) => {\n+        hir::ItemKind::Impl { ref generics, ref items, .. } => {\n             for param in generics.params {\n                 match param.kind {\n                     hir::GenericParamKind::Lifetime { .. } => {}\n@@ -1119,7 +1119,7 @@ fn create_mono_items_for_default_impls<'tcx>(\n                 let param_env = ty::ParamEnv::reveal_all();\n                 let trait_ref = tcx.normalize_erasing_regions(param_env, trait_ref);\n                 let overridden_methods: FxHashSet<_> =\n-                    impl_item_refs.iter().map(|iiref| iiref.ident.modern()).collect();\n+                    items.iter().map(|iiref| iiref.ident.modern()).collect();\n                 for method in tcx.provided_trait_methods(trait_ref.def_id) {\n                     if overridden_methods.contains(&method.ident.modern()) {\n                         continue;"}, {"sha": "d927553c72e8b4afdc1bd9eb2b31ba70688d9555", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -309,21 +309,22 @@ fn check_terminator(\n ) -> McfResult {\n     let span = terminator.source_info.span;\n     match &terminator.kind {\n-        TerminatorKind::Goto { .. } | TerminatorKind::Return | TerminatorKind::Resume => Ok(()),\n+        TerminatorKind::FalseEdges { .. }\n+        | TerminatorKind::FalseUnwind { .. }\n+        | TerminatorKind::Goto { .. }\n+        | TerminatorKind::Return\n+        | TerminatorKind::Resume => Ok(()),\n \n         TerminatorKind::Drop { location, .. } => check_place(tcx, location, span, def_id, body),\n         TerminatorKind::DropAndReplace { location, value, .. } => {\n             check_place(tcx, location, span, def_id, body)?;\n             check_operand(tcx, value, span, def_id, body)\n         }\n \n-        TerminatorKind::FalseEdges { .. } | TerminatorKind::SwitchInt { .. }\n-            if !feature_allowed(tcx, def_id, sym::const_if_match) =>\n-        {\n+        TerminatorKind::SwitchInt { .. } if !feature_allowed(tcx, def_id, sym::const_if_match) => {\n             Err((span, \"loops and conditional expressions are not stable in const fn\".into()))\n         }\n \n-        TerminatorKind::FalseEdges { .. } => Ok(()),\n         TerminatorKind::SwitchInt { discr, switch_ty: _, values: _, targets: _ } => {\n             check_operand(tcx, discr, span, def_id, body)\n         }\n@@ -367,13 +368,5 @@ fn check_terminator(\n         TerminatorKind::Assert { cond, expected: _, msg: _, target: _, cleanup: _ } => {\n             check_operand(tcx, cond, span, def_id, body)\n         }\n-\n-        TerminatorKind::FalseUnwind { .. } if feature_allowed(tcx, def_id, sym::const_loop) => {\n-            Ok(())\n-        }\n-\n-        TerminatorKind::FalseUnwind { .. } => {\n-            Err((span, \"loops are not allowed in const fn\".into()))\n-        }\n     }\n }"}, {"sha": "1921a6c8506891d7da017a1abad514b0b6709522", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -634,15 +634,15 @@ impl<'a> Parser<'a> {\n                 let constness = constness.map(|c| c.node);\n                 let trait_ref = TraitRef { path, constness, ref_id: ty_first.id };\n \n-                ItemKind::Impl(\n+                ItemKind::Impl {\n                     unsafety,\n                     polarity,\n                     defaultness,\n                     generics,\n-                    Some(trait_ref),\n-                    ty_second,\n-                    impl_items,\n-                )\n+                    of_trait: Some(trait_ref),\n+                    self_ty: ty_second,\n+                    items: impl_items,\n+                }\n             }\n             None => {\n                 // Reject `impl const Type {}` here\n@@ -653,15 +653,15 @@ impl<'a> Parser<'a> {\n                 }\n \n                 // impl Type\n-                ItemKind::Impl(\n+                ItemKind::Impl {\n                     unsafety,\n                     polarity,\n                     defaultness,\n                     generics,\n-                    None,\n-                    ty_first,\n-                    impl_items,\n-                )\n+                    of_trait: None,\n+                    self_ty: ty_first,\n+                    items: impl_items,\n+                }\n             }\n         };\n "}, {"sha": "2ff9d744f2c4d771c782d03bd5854905d64e3dad", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -405,10 +405,10 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ItemKind::Impl(.., ref opt_trait, _, impl_item_refs) => {\n-                for impl_item_ref in impl_item_refs {\n+            hir::ItemKind::Impl { ref of_trait, items, .. } => {\n+                for impl_item_ref in items {\n                     let impl_item = self.krate.impl_item(impl_item_ref.id);\n-                    if opt_trait.is_some()\n+                    if of_trait.is_some()\n                         || has_allow_dead_code_or_lang_attr(\n                             self.tcx,\n                             impl_item.hir_id,\n@@ -586,7 +586,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n                 | hir::ItemKind::Struct(..)\n                 | hir::ItemKind::Union(..)\n                 | hir::ItemKind::Trait(..)\n-                | hir::ItemKind::Impl(..) => {\n+                | hir::ItemKind::Impl { .. } => {\n                     // FIXME(66095): Because item.span is annotated with things\n                     // like expansion data, and ident.span isn't, we use the\n                     // def_span method if it's part of a macro invocation"}, {"sha": "667898046ac3623dfedcf05b7a331e5ecc5d8b76", "filename": "src/librustc_passes/reachable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_passes%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_passes%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Freachable.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -35,7 +35,7 @@ fn item_might_be_inlined(tcx: TyCtxt<'tcx>, item: &hir::Item<'_>, attrs: Codegen\n         hir::ItemKind::Fn(ref sig, ..) if sig.header.is_const() => {\n             return true;\n         }\n-        hir::ItemKind::Impl(..) | hir::ItemKind::Fn(..) => {\n+        hir::ItemKind::Impl { .. } | hir::ItemKind::Fn(..) => {\n             let generics = tcx.generics_of(tcx.hir().local_def_id(item.hir_id));\n             generics.requires_monomorphization(tcx)\n         }\n@@ -181,7 +181,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                             // does too.\n                             let impl_hir_id = self.tcx.hir().as_local_hir_id(impl_did).unwrap();\n                             match self.tcx.hir().expect_item(impl_hir_id).kind {\n-                                hir::ItemKind::Impl(..) => {\n+                                hir::ItemKind::Impl { .. } => {\n                                     let generics = self.tcx.generics_of(impl_did);\n                                     generics.requires_monomorphization(self.tcx)\n                                 }\n@@ -266,7 +266,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     | hir::ItemKind::Static(..)\n                     | hir::ItemKind::Mod(..)\n                     | hir::ItemKind::ForeignMod(..)\n-                    | hir::ItemKind::Impl(..)\n+                    | hir::ItemKind::Impl { .. }\n                     | hir::ItemKind::Trait(..)\n                     | hir::ItemKind::TraitAlias(..)\n                     | hir::ItemKind::Struct(..)\n@@ -349,9 +349,9 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx\n         }\n \n         // We need only trait impls here, not inherent impls, and only non-exported ones\n-        if let hir::ItemKind::Impl(.., Some(ref trait_ref), _, ref impl_item_refs) = item.kind {\n+        if let hir::ItemKind::Impl { of_trait: Some(ref trait_ref), ref items, .. } = item.kind {\n             if !self.access_levels.is_reachable(item.hir_id) {\n-                self.worklist.extend(impl_item_refs.iter().map(|ii_ref| ii_ref.id.hir_id));\n+                self.worklist.extend(items.iter().map(|ii_ref| ii_ref.id.hir_id));\n \n                 let trait_def_id = match trait_ref.path.res {\n                     Res::Def(DefKind::Trait, def_id) => def_id,"}, {"sha": "b649f36f2fc589671854ed51b238d475b733f5ed", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -219,11 +219,11 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n             // they don't have their own stability. They still can be annotated as unstable\n             // and propagate this unstability to children, but this annotation is completely\n             // optional. They inherit stability from their parents when unannotated.\n-            hir::ItemKind::Impl(.., None, _, _) | hir::ItemKind::ForeignMod(..) => {\n+            hir::ItemKind::Impl { of_trait: None, .. } | hir::ItemKind::ForeignMod(..) => {\n                 self.in_trait_impl = false;\n                 kind = AnnotationKind::Container;\n             }\n-            hir::ItemKind::Impl(.., Some(_), _, _) => {\n+            hir::ItemKind::Impl { of_trait: Some(_), .. } => {\n                 self.in_trait_impl = true;\n             }\n             hir::ItemKind::Struct(ref sd, _) => {\n@@ -308,7 +308,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n             // they don't have their own stability. They still can be annotated as unstable\n             // and propagate this unstability to children, but this annotation is completely\n             // optional. They inherit stability from their parents when unannotated.\n-            hir::ItemKind::Impl(.., None, _, _) | hir::ItemKind::ForeignMod(..) => {}\n+            hir::ItemKind::Impl { of_trait: None, .. } | hir::ItemKind::ForeignMod(..) => {}\n \n             _ => self.check_missing_stability(i.hir_id, i.span, i.kind.descriptive_variant()),\n         }\n@@ -463,9 +463,9 @@ impl Visitor<'tcx> for Checker<'tcx> {\n             // For implementations of traits, check the stability of each item\n             // individually as it's possible to have a stable trait with unstable\n             // items.\n-            hir::ItemKind::Impl(.., Some(ref t), _, impl_item_refs) => {\n+            hir::ItemKind::Impl { of_trait: Some(ref t), items, .. } => {\n                 if let Res::Def(DefKind::Trait, trait_did) = t.path.res {\n-                    for impl_item_ref in impl_item_refs {\n+                    for impl_item_ref in items {\n                         let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                         let trait_item_def_id = self\n                             .tcx"}, {"sha": "90a422a4dcf6cba48b0e96d031c9c006032f279a", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -255,8 +255,8 @@ fn def_id_visibility<'tcx>(\n                 Node::ImplItem(impl_item) => {\n                     match tcx.hir().get(tcx.hir().get_parent_item(hir_id)) {\n                         Node::Item(item) => match &item.kind {\n-                            hir::ItemKind::Impl(.., None, _, _) => &impl_item.vis,\n-                            hir::ItemKind::Impl(.., Some(trait_ref), _, _) => {\n+                            hir::ItemKind::Impl { of_trait: None, .. } => &impl_item.vis,\n+                            hir::ItemKind::Impl { of_trait: Some(trait_ref), .. } => {\n                                 return def_id_visibility(tcx, trait_ref.path.res.def_id());\n                             }\n                             kind => bug!(\"unexpected item kind: {:?}\", kind),\n@@ -686,7 +686,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         let inherited_item_level = match item.kind {\n-            hir::ItemKind::Impl(..) => {\n+            hir::ItemKind::Impl { .. } => {\n                 Option::<AccessLevel>::of_impl(item.hir_id, self.tcx, &self.access_levels)\n             }\n             // Foreign modules inherit level from parents.\n@@ -730,9 +730,9 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     }\n                 }\n             }\n-            hir::ItemKind::Impl(.., ref trait_ref, _, impl_item_refs) => {\n-                for impl_item_ref in impl_item_refs {\n-                    if trait_ref.is_some() || impl_item_ref.vis.node.is_pub() {\n+            hir::ItemKind::Impl { ref of_trait, items, .. } => {\n+                for impl_item_ref in items {\n+                    if of_trait.is_some() || impl_item_ref.vis.node.is_pub() {\n                         self.update(impl_item_ref.id.hir_id, item_level);\n                     }\n                 }\n@@ -827,11 +827,11 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                 }\n             }\n             // Visit everything except for private impl items.\n-            hir::ItemKind::Impl(.., impl_item_refs) => {\n+            hir::ItemKind::Impl { items, .. } => {\n                 if item_level.is_some() {\n                     self.reach(item.hir_id, item_level).generics().predicates().ty().trait_ref();\n \n-                    for impl_item_ref in impl_item_refs {\n+                    for impl_item_ref in items {\n                         let impl_item_level = self.get(impl_item_ref.id.hir_id);\n                         if impl_item_level.is_some() {\n                             self.reach(impl_item_ref.id.hir_id, impl_item_level)\n@@ -1510,7 +1510,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             // (i.e., we could just return here to not check them at\n             // all, or some worse estimation of whether an impl is\n             // publicly visible).\n-            hir::ItemKind::Impl(.., ref g, ref trait_ref, ref self_, impl_item_refs) => {\n+            hir::ItemKind::Impl { generics: ref g, ref of_trait, ref self_ty, items, .. } => {\n                 // `impl [... for] Private` is never visible.\n                 let self_contains_private;\n                 // `impl [... for] Public<...>`, but not `impl [... for]\n@@ -1525,15 +1525,15 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                         at_outer_type: true,\n                         outer_type_is_public_path: false,\n                     };\n-                    visitor.visit_ty(&self_);\n+                    visitor.visit_ty(&self_ty);\n                     self_contains_private = visitor.contains_private;\n                     self_is_public_path = visitor.outer_type_is_public_path;\n                 }\n \n                 // Miscellaneous info about the impl:\n \n                 // `true` iff this is `impl Private for ...`.\n-                let not_private_trait = trait_ref.as_ref().map_or(\n+                let not_private_trait = of_trait.as_ref().map_or(\n                     true, // no trait counts as public trait\n                     |tr| {\n                         let did = tr.path.res.def_id();\n@@ -1554,8 +1554,8 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                 // directly because we might have `impl<T: Foo<Private>> ...`,\n                 // and we shouldn't warn about the generics if all the methods\n                 // are private (because `T` won't be visible externally).\n-                let trait_or_some_public_method = trait_ref.is_some()\n-                    || impl_item_refs.iter().any(|impl_item_ref| {\n+                let trait_or_some_public_method = of_trait.is_some()\n+                    || items.iter().any(|impl_item_ref| {\n                         let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                         match impl_item.kind {\n                             hir::ImplItemKind::Const(..) | hir::ImplItemKind::Method(..) => {\n@@ -1570,9 +1570,9 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                 if !self_contains_private && not_private_trait && trait_or_some_public_method {\n                     intravisit::walk_generics(self, g);\n \n-                    match *trait_ref {\n+                    match of_trait {\n                         None => {\n-                            for impl_item_ref in impl_item_refs {\n+                            for impl_item_ref in items {\n                                 // This is where we choose whether to walk down\n                                 // further into the impl to check its items. We\n                                 // should only walk into public items so that we\n@@ -1594,7 +1594,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                                 }\n                             }\n                         }\n-                        Some(ref tr) => {\n+                        Some(tr) => {\n                             // Any private types in a trait impl fall into three\n                             // categories.\n                             // 1. mentioned in the trait definition\n@@ -1611,19 +1611,19 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                             intravisit::walk_path(self, &tr.path);\n \n                             // Those in 3. are warned with this call.\n-                            for impl_item_ref in impl_item_refs {\n+                            for impl_item_ref in items {\n                                 let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                                 if let hir::ImplItemKind::TyAlias(ref ty) = impl_item.kind {\n                                     self.visit_ty(ty);\n                                 }\n                             }\n                         }\n                     }\n-                } else if trait_ref.is_none() && self_is_public_path {\n+                } else if of_trait.is_none() && self_is_public_path {\n                     // `impl Public<Private> { ... }`. Any public static\n                     // methods will be visible as `Public::foo`.\n                     let mut found_pub_static = false;\n-                    for impl_item_ref in impl_item_refs {\n+                    for impl_item_ref in items {\n                         if self.item_is_public(&impl_item_ref.id.hir_id, &impl_item_ref.vis) {\n                             let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                             match impl_item_ref.kind {\n@@ -1997,12 +1997,12 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             // Subitems of inherent impls have their own publicity.\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity.\n-            hir::ItemKind::Impl(.., ref trait_ref, _, impl_item_refs) => {\n+            hir::ItemKind::Impl { ref of_trait, items, .. } => {\n                 let impl_vis = ty::Visibility::of_impl(item.hir_id, tcx, &Default::default());\n                 self.check(item.hir_id, impl_vis).generics().predicates();\n-                for impl_item_ref in impl_item_refs {\n+                for impl_item_ref in items {\n                     let impl_item = tcx.hir().impl_item(impl_item_ref.id);\n-                    let impl_item_vis = if trait_ref.is_none() {\n+                    let impl_item_vis = if of_trait.is_none() {\n                         min(\n                             ty::Visibility::from_hir(&impl_item.vis, item.hir_id, tcx),\n                             impl_vis,"}, {"sha": "40a89ef06745874dd99f89b16278d92355f9763f", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -815,7 +815,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             }\n \n             // These items do not add names to modules.\n-            ItemKind::Impl(..) | ItemKind::ForeignMod(..) | ItemKind::GlobalAsm(..) => {}\n+            ItemKind::Impl { .. } | ItemKind::ForeignMod(..) | ItemKind::GlobalAsm(..) => {}\n \n             ItemKind::MacroDef(..) | ItemKind::Mac(_) => unreachable!(),\n         }"}, {"sha": "696ba0e994c7dbd095481e2c47cdd8c60befc9a1", "filename": "src/librustc_resolve/def_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_resolve%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_resolve%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdef_collector.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -104,7 +104,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         // Pick the def data. This need not be unique, but the more\n         // information we encapsulate into, the better\n         let def_data = match &i.kind {\n-            ItemKind::Impl(..) => DefPathData::Impl,\n+            ItemKind::Impl { .. } => DefPathData::Impl,\n             ItemKind::Mod(..) if i.ident.name == kw::Invalid => {\n                 return visit::walk_item(self, i);\n             }"}, {"sha": "08cd9c4d1d53a54e424a7b46dd8c448b552fbf93", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -797,14 +797,14 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                 self.resolve_adt(item, generics);\n             }\n \n-            ItemKind::Impl(.., ref generics, ref opt_trait_ref, ref self_type, ref impl_items) => {\n-                self.resolve_implementation(\n-                    generics,\n-                    opt_trait_ref,\n-                    &self_type,\n-                    item.id,\n-                    impl_items,\n-                )\n+            ItemKind::Impl {\n+                ref generics,\n+                ref of_trait,\n+                ref self_ty,\n+                items: ref impl_items,\n+                ..\n+            } => {\n+                self.resolve_implementation(generics, of_trait, &self_ty, item.id, impl_items);\n             }\n \n             ItemKind::Trait(.., ref generics, ref bounds, ref trait_items) => {"}, {"sha": "5fae8f33187435d06d4edda9d3db4ba12f9026a9", "filename": "src/librustc_resolve/lifetimes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_resolve%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_resolve%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flifetimes.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -416,11 +416,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             | hir::ItemKind::Union(_, ref generics)\n             | hir::ItemKind::Trait(_, _, ref generics, ..)\n             | hir::ItemKind::TraitAlias(ref generics, ..)\n-            | hir::ItemKind::Impl(_, _, _, ref generics, ..) => {\n+            | hir::ItemKind::Impl { ref generics, .. } => {\n                 // Impls permit `'_` to be used and it is equivalent to \"some fresh lifetime name\".\n                 // This is not true for other kinds of items.x\n                 let track_lifetime_uses = match item.kind {\n-                    hir::ItemKind::Impl(..) => true,\n+                    hir::ItemKind::Impl { .. } => true,\n                     _ => false,\n                 };\n                 // These kinds of items have only early-bound lifetime parameters.\n@@ -1638,7 +1638,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n             match parent.kind {\n                 hir::ItemKind::Trait(_, _, ref generics, ..)\n-                | hir::ItemKind::Impl(_, _, _, ref generics, ..) => {\n+                | hir::ItemKind::Impl { ref generics, .. } => {\n                     index += generics.params.len() as u32;\n                 }\n                 _ => {}\n@@ -2067,12 +2067,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n \n             Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Method(_, body), .. }) => {\n-                if let hir::ItemKind::Impl(.., ref self_ty, ref impl_items) =\n+                if let hir::ItemKind::Impl { ref self_ty, ref items, .. } =\n                     self.tcx.hir().expect_item(self.tcx.hir().get_parent_item(parent)).kind\n                 {\n                     impl_self = Some(self_ty);\n                     assoc_item_kind =\n-                        impl_items.iter().find(|ii| ii.id.hir_id == parent).map(|ii| ii.kind);\n+                        items.iter().find(|ii| ii.id.hir_id == parent).map(|ii| ii.kind);\n                 }\n                 Some(body)\n             }"}, {"sha": "d252fc542c325ca4bc1553a5695cf48b85617e51", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -1300,8 +1300,8 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                 self.process_struct(item, def, ty_params)\n             }\n             Enum(ref def, ref ty_params) => self.process_enum(item, def, ty_params),\n-            Impl(.., ref ty_params, ref trait_ref, ref typ, ref impl_items) => {\n-                self.process_impl(item, ty_params, trait_ref, &typ, impl_items)\n+            Impl { ref generics, ref of_trait, ref self_ty, ref items, .. } => {\n+                self.process_impl(item, generics, of_trait, &self_ty, items)\n             }\n             Trait(_, _, ref generics, ref trait_refs, ref methods) => {\n                 self.process_trait(item, generics, trait_refs, methods)"}, {"sha": "537fe198a0c39f944cbd17924e644bf8c455d14d", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -305,8 +305,8 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     attributes: lower_attributes(item.attrs.clone(), self),\n                 }))\n             }\n-            ast::ItemKind::Impl(.., ref trait_ref, ref typ, ref impls) => {\n-                if let ast::TyKind::Path(None, ref path) = typ.kind {\n+            ast::ItemKind::Impl { ref of_trait, ref self_ty, ref items, .. } => {\n+                if let ast::TyKind::Path(None, ref path) = self_ty.kind {\n                     // Common case impl for a struct or something basic.\n                     if generated_code(path.span) {\n                         return None;\n@@ -317,29 +317,29 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     let impl_id = self.next_impl_id();\n                     let span = self.span_from_span(sub_span);\n \n-                    let type_data = self.lookup_def_id(typ.id);\n+                    let type_data = self.lookup_def_id(self_ty.id);\n                     type_data.map(|type_data| {\n                         Data::RelationData(\n                             Relation {\n                                 kind: RelationKind::Impl { id: impl_id },\n                                 span: span.clone(),\n                                 from: id_from_def_id(type_data),\n-                                to: trait_ref\n+                                to: of_trait\n                                     .as_ref()\n                                     .and_then(|t| self.lookup_def_id(t.ref_id))\n                                     .map(id_from_def_id)\n                                     .unwrap_or_else(|| null_id()),\n                             },\n                             Impl {\n                                 id: impl_id,\n-                                kind: match *trait_ref {\n+                                kind: match *of_trait {\n                                     Some(_) => ImplKind::Direct,\n                                     None => ImplKind::Inherent,\n                                 },\n                                 span: span,\n                                 value: String::new(),\n                                 parent: None,\n-                                children: impls\n+                                children: items\n                                     .iter()\n                                     .map(|i| id_from_node_id(i.id, self))\n                                     .collect(),\n@@ -405,9 +405,9 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         {\n             Some(impl_id) => match self.tcx.hir().get_if_local(impl_id) {\n                 Some(Node::Item(item)) => match item.kind {\n-                    hir::ItemKind::Impl(.., ref ty, _) => {\n+                    hir::ItemKind::Impl { ref self_ty, .. } => {\n                         let mut qualname = String::from(\"<\");\n-                        qualname.push_str(&self.tcx.hir().hir_to_pretty_string(ty.hir_id));\n+                        qualname.push_str(&self.tcx.hir().hir_to_pretty_string(self_ty.hir_id));\n \n                         let trait_id = self.tcx.trait_id_of_impl(impl_id);\n                         let mut decl_id = None;"}, {"sha": "779d3f55018d56f88980ead8dac6f8cbe25fa11f", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -482,15 +482,15 @@ impl Sig for ast::Item {\n \n                 Ok(sig)\n             }\n-            ast::ItemKind::Impl(\n+            ast::ItemKind::Impl {\n                 unsafety,\n                 polarity,\n                 defaultness,\n                 ref generics,\n-                ref opt_trait,\n-                ref ty,\n-                _,\n-            ) => {\n+                ref of_trait,\n+                ref self_ty,\n+                items: _,\n+            } => {\n                 let mut text = String::new();\n                 if let ast::Defaultness::Default = defaultness {\n                     text.push_str(\"default \");\n@@ -505,7 +505,7 @@ impl Sig for ast::Item {\n \n                 text.push(' ');\n \n-                let trait_sig = if let Some(ref t) = *opt_trait {\n+                let trait_sig = if let Some(ref t) = *of_trait {\n                     if polarity == ast::ImplPolarity::Negative {\n                         text.push('!');\n                     }\n@@ -517,7 +517,7 @@ impl Sig for ast::Item {\n                     text_sig(String::new())\n                 };\n \n-                let ty_sig = ty.make(offset + text.len(), id, scx)?;\n+                let ty_sig = self_ty.make(offset + text.len(), id, scx)?;\n                 text.push_str(&ty_sig.text);\n \n                 text.push_str(\" {}\");"}, {"sha": "9c7c0f0c8b0eca79346dd05357cf2fede430baa2", "filename": "src/librustc_span/source_map.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_span%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_span%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsource_map.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -473,20 +473,23 @@ impl SourceMap {\n         lo.line != hi.line\n     }\n \n-    pub fn span_to_lines(&self, sp: Span) -> FileLinesResult {\n-        debug!(\"span_to_lines(sp={:?})\", sp);\n-\n+    pub fn is_valid_span(&self, sp: Span) -> Result<(Loc, Loc), SpanLinesError> {\n         let lo = self.lookup_char_pos(sp.lo());\n         debug!(\"span_to_lines: lo={:?}\", lo);\n         let hi = self.lookup_char_pos(sp.hi());\n         debug!(\"span_to_lines: hi={:?}\", hi);\n-\n         if lo.file.start_pos != hi.file.start_pos {\n             return Err(SpanLinesError::DistinctSources(DistinctSources {\n                 begin: (lo.file.name.clone(), lo.file.start_pos),\n                 end: (hi.file.name.clone(), hi.file.start_pos),\n             }));\n         }\n+        Ok((lo, hi))\n+    }\n+\n+    pub fn span_to_lines(&self, sp: Span) -> FileLinesResult {\n+        debug!(\"span_to_lines(sp={:?})\", sp);\n+        let (lo, hi) = self.is_valid_span(sp)?;\n         assert!(hi.line >= lo.line);\n \n         let mut lines = Vec::with_capacity(hi.line - lo.line + 1);"}, {"sha": "7df27e67d5b1c2a64adcc75942be2295cf512d99", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -195,8 +195,8 @@ crate fn environment(tcx: TyCtxt<'_>, def_id: DefId) -> Environment<'_> {\n         },\n \n         Node::Item(item) => match item.kind {\n-            ItemKind::Impl(.., Some(..), _, _) => NodeKind::TraitImpl,\n-            ItemKind::Impl(.., None, _, _) => NodeKind::InherentImpl,\n+            ItemKind::Impl { of_trait: Some(_), .. } => NodeKind::TraitImpl,\n+            ItemKind::Impl { of_trait: None, .. } => NodeKind::InherentImpl,\n             ItemKind::Fn(..) => NodeKind::Fn,\n             _ => NodeKind::Other,\n         },"}, {"sha": "d47e54366b55018b386d3324d7c66f7ca3af73b1", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -128,8 +128,8 @@ fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n     let parent_def_id = tcx.hir().local_def_id(parent_id);\n     let parent_item = tcx.hir().expect_item(parent_id);\n     match parent_item.kind {\n-        hir::ItemKind::Impl(.., ref impl_item_refs) => {\n-            if let Some(impl_item_ref) = impl_item_refs.iter().find(|i| i.id.hir_id == id) {\n+        hir::ItemKind::Impl { ref items, .. } => {\n+            if let Some(impl_item_ref) = items.iter().find(|i| i.id.hir_id == id) {\n                 let assoc_item =\n                     associated_item_from_impl_item_ref(tcx, parent_def_id, impl_item_ref);\n                 debug_assert_eq!(assoc_item.def_id, def_id);\n@@ -194,8 +194,8 @@ fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n                 .map(|trait_item_ref| trait_item_ref.id)\n                 .map(|id| tcx.hir().local_def_id(id.hir_id)),\n         ),\n-        hir::ItemKind::Impl(.., ref impl_item_refs) => tcx.arena.alloc_from_iter(\n-            impl_item_refs\n+        hir::ItemKind::Impl { ref items, .. } => tcx.arena.alloc_from_iter(\n+            items\n                 .iter()\n                 .map(|impl_item_ref| impl_item_ref.id)\n                 .map(|id| tcx.hir().local_def_id(id.hir_id)),"}, {"sha": "4affdc4a9d64e7d8eca6a8ccf948f07d523a924c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -1709,17 +1709,11 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n             check_enum(tcx, it.span, &enum_definition.variants, it.hir_id);\n         }\n         hir::ItemKind::Fn(..) => {} // entirely within check_item_body\n-        hir::ItemKind::Impl(.., ref impl_item_refs) => {\n+        hir::ItemKind::Impl { ref items, .. } => {\n             debug!(\"ItemKind::Impl {} with id {}\", it.ident, it.hir_id);\n             let impl_def_id = tcx.hir().local_def_id(it.hir_id);\n             if let Some(impl_trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n-                check_impl_items_against_trait(\n-                    tcx,\n-                    it.span,\n-                    impl_def_id,\n-                    impl_trait_ref,\n-                    impl_item_refs,\n-                );\n+                check_impl_items_against_trait(tcx, it.span, impl_def_id, impl_trait_ref, items);\n                 let trait_def_id = impl_trait_ref.def_id;\n                 check_on_unimplemented(tcx, trait_def_id, it);\n             }"}, {"sha": "5e91e98a7dfa500063533ef9322f81950e07c51a", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -97,7 +97,7 @@ pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: DefId) {\n         //\n         // won't be allowed unless there's an *explicit* implementation of `Send`\n         // for `T`\n-        hir::ItemKind::Impl(_, _, defaultness, _, ref trait_ref, ref self_ty, _) => {\n+        hir::ItemKind::Impl { defaultness, ref of_trait, ref self_ty, .. } => {\n             let is_auto = tcx\n                 .impl_trait_ref(tcx.hir().local_def_id(item.hir_id))\n                 .map_or(false, |trait_ref| tcx.trait_is_auto(trait_ref.def_id));\n@@ -107,11 +107,11 @@ pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: DefId) {\n             }\n             match polarity {\n                 ty::ImplPolarity::Positive => {\n-                    check_impl(tcx, item, self_ty, trait_ref);\n+                    check_impl(tcx, item, self_ty, of_trait);\n                 }\n                 ty::ImplPolarity::Negative => {\n                     // FIXME(#27579): what amount of WF checking do we need for neg impls?\n-                    if trait_ref.is_some() && !is_auto {\n+                    if of_trait.is_some() && !is_auto {\n                         struct_span_err!(\n                             tcx.sess,\n                             item.span,"}, {"sha": "516dc16d46bd8f122febc4a96672efd8a7250f55", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -57,7 +57,7 @@ fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: DefId) {\n \n     let impl_hir_id = tcx.hir().as_local_hir_id(impl_did).expect(\"foreign Drop impl on non-ADT\");\n     let sp = match tcx.hir().expect_item(impl_hir_id).kind {\n-        ItemKind::Impl(.., ty, _) => ty.span,\n+        ItemKind::Impl { self_ty, .. } => self_ty.span,\n         _ => bug!(\"expected Drop impl item\"),\n     };\n \n@@ -94,7 +94,7 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: DefId) {\n         Ok(()) => {}\n         Err(CopyImplementationError::InfrigingFields(fields)) => {\n             let item = tcx.hir().expect_item(impl_hir_id);\n-            let span = if let ItemKind::Impl(.., Some(ref tr), _, _) = item.kind {\n+            let span = if let ItemKind::Impl { of_trait: Some(ref tr), .. } = item.kind {\n                 tr.path.span\n             } else {\n                 span\n@@ -113,7 +113,8 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: DefId) {\n         }\n         Err(CopyImplementationError::NotAnAdt) => {\n             let item = tcx.hir().expect_item(impl_hir_id);\n-            let span = if let ItemKind::Impl(.., ref ty, _) = item.kind { ty.span } else { span };\n+            let span =\n+                if let ItemKind::Impl { self_ty, .. } = item.kind { self_ty.span } else { span };\n \n             struct_span_err!(\n                 tcx.sess,\n@@ -490,7 +491,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n                     return err_info;\n                 } else if diff_fields.len() > 1 {\n                     let item = tcx.hir().expect_item(impl_hir_id);\n-                    let span = if let ItemKind::Impl(.., Some(ref t), _, _) = item.kind {\n+                    let span = if let ItemKind::Impl { of_trait: Some(ref t), .. } = item.kind {\n                         t.path.span\n                     } else {\n                         tcx.hir().span(impl_hir_id)"}, {"sha": "d313e32fc20e0fb6333af31ea4f62d9602ff436d", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -47,7 +47,7 @@ struct InherentCollect<'tcx> {\n impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n         let ty = match item.kind {\n-            hir::ItemKind::Impl(.., None, ref ty, _) => ty,\n+            hir::ItemKind::Impl { of_trait: None, ref self_ty, .. } => self_ty,\n             _ => return,\n         };\n "}, {"sha": "9ba8fa4247f269f5e3dc6554071d499e88fc851a", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -27,7 +27,7 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n         let def_id = self.tcx.hir().local_def_id(item.hir_id);\n         // \"Trait\" impl\n-        if let hir::ItemKind::Impl(.., generics, Some(tr), impl_ty, _) = &item.kind {\n+        if let hir::ItemKind::Impl { generics, of_trait: Some(ref tr), self_ty, .. } = &item.kind {\n             debug!(\n                 \"coherence2::orphan check: trait impl {}\",\n                 self.tcx.hir().node_to_string(item.hir_id)\n@@ -72,7 +72,7 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n                         let msg = format!(\"{} is not defined in the current crate{}\", ty, postfix);\n                         if *is_target_ty {\n                             // Point at `D<A>` in `impl<A, B> for C<B> in D<A>`\n-                            err.span_label(impl_ty.span, &msg);\n+                            err.span_label(self_ty.span, &msg);\n                         } else {\n                             // Point at `C<B>` in `impl<A, B> for C<B> in D<A>`\n                             err.span_label(tr.path.span, &msg);"}, {"sha": "48b96886d3a7184dcd95c4041f8049938ec6b0fa", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -88,7 +88,7 @@ impl UnsafetyChecker<'tcx> {\n \n impl ItemLikeVisitor<'v> for UnsafetyChecker<'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item<'v>) {\n-        if let hir::ItemKind::Impl(unsafety, polarity, _, ref generics, ..) = item.kind {\n+        if let hir::ItemKind::Impl { unsafety, polarity, ref generics, .. } = item.kind {\n             self.check_unsafety_coherence(item, Some(generics), unsafety, polarity);\n         }\n     }"}, {"sha": "a03b9f747372e49939164edb22690a6fc7ea3508", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -184,7 +184,7 @@ fn reject_placeholder_type_signatures_in_item(tcx: TyCtxt<'tcx>, item: &'tcx hir\n         | hir::ItemKind::Enum(_, generics)\n         | hir::ItemKind::TraitAlias(generics, _)\n         | hir::ItemKind::Trait(_, _, generics, ..)\n-        | hir::ItemKind::Impl(_, _, _, generics, ..)\n+        | hir::ItemKind::Impl { generics, .. }\n         | hir::ItemKind::Struct(_, generics) => (generics, true),\n         hir::ItemKind::OpaqueTy(hir::OpaqueTy { generics, .. })\n         | hir::ItemKind::TyAlias(_, generics) => (generics, false),\n@@ -401,7 +401,7 @@ fn type_param_predicates(\n         Node::Item(item) => {\n             match item.kind {\n                 ItemKind::Fn(.., ref generics, _)\n-                | ItemKind::Impl(_, _, _, ref generics, ..)\n+                | ItemKind::Impl { ref generics, .. }\n                 | ItemKind::TyAlias(_, ref generics)\n                 | ItemKind::OpaqueTy(OpaqueTy { ref generics, impl_trait_fn: None, .. })\n                 | ItemKind::Enum(_, ref generics)\n@@ -531,7 +531,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n             tcx.predicates_of(def_id);\n             convert_enum_variant_types(tcx, def_id, &enum_definition.variants);\n         }\n-        hir::ItemKind::Impl(..) => {\n+        hir::ItemKind::Impl { .. } => {\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n             tcx.impl_trait_ref(def_id);\n@@ -1052,9 +1052,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n \n         Node::Item(item) => {\n             match item.kind {\n-                ItemKind::Fn(.., ref generics, _) | ItemKind::Impl(_, _, _, ref generics, ..) => {\n-                    generics\n-                }\n+                ItemKind::Fn(.., ref generics, _) | ItemKind::Impl { ref generics, .. } => generics,\n \n                 ItemKind::TyAlias(_, ref generics)\n                 | ItemKind::Enum(_, ref generics)\n@@ -1338,7 +1336,9 @@ fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                         icx.to_ty(ty)\n                     }\n                 }\n-                ItemKind::TyAlias(ref ty, _) | ItemKind::Impl(.., ref ty, _) => icx.to_ty(ty),\n+                ItemKind::TyAlias(ref self_ty, _) | ItemKind::Impl { ref self_ty, .. } => {\n+                    icx.to_ty(self_ty)\n+                }\n                 ItemKind::Fn(..) => {\n                     let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                     tcx.mk_fn_def(def_id, substs)\n@@ -1956,12 +1956,10 @@ fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::TraitRef<'_>> {\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     match tcx.hir().expect_item(hir_id).kind {\n-        hir::ItemKind::Impl(.., ref opt_trait_ref, _, _) => {\n-            opt_trait_ref.as_ref().map(|ast_trait_ref| {\n-                let selfty = tcx.type_of(def_id);\n-                AstConv::instantiate_mono_trait_ref(&icx, ast_trait_ref, selfty)\n-            })\n-        }\n+        hir::ItemKind::Impl { ref of_trait, .. } => of_trait.as_ref().map(|ast_trait_ref| {\n+            let selfty = tcx.type_of(def_id);\n+            AstConv::instantiate_mono_trait_ref(&icx, ast_trait_ref, selfty)\n+        }),\n         _ => bug!(),\n     }\n }\n@@ -1971,19 +1969,21 @@ fn impl_polarity(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ImplPolarity {\n     let is_rustc_reservation = tcx.has_attr(def_id, sym::rustc_reservation_impl);\n     let item = tcx.hir().expect_item(hir_id);\n     match &item.kind {\n-        hir::ItemKind::Impl(_, hir::ImplPolarity::Negative, ..) => {\n+        hir::ItemKind::Impl { polarity: hir::ImplPolarity::Negative, .. } => {\n             if is_rustc_reservation {\n                 tcx.sess.span_err(item.span, \"reservation impls can't be negative\");\n             }\n             ty::ImplPolarity::Negative\n         }\n-        hir::ItemKind::Impl(_, hir::ImplPolarity::Positive, _, _, None, _, _) => {\n+        hir::ItemKind::Impl { polarity: hir::ImplPolarity::Positive, of_trait: None, .. } => {\n             if is_rustc_reservation {\n                 tcx.sess.span_err(item.span, \"reservation impls can't be inherent\");\n             }\n             ty::ImplPolarity::Positive\n         }\n-        hir::ItemKind::Impl(_, hir::ImplPolarity::Positive, _, _, Some(_tr), _, _) => {\n+        hir::ItemKind::Impl {\n+            polarity: hir::ImplPolarity::Positive, of_trait: Some(_), ..\n+        } => {\n             if is_rustc_reservation {\n                 ty::ImplPolarity::Reservation\n             } else {\n@@ -2142,7 +2142,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n \n         Node::Item(item) => {\n             match item.kind {\n-                ItemKind::Impl(_, _, defaultness, ref generics, ..) => {\n+                ItemKind::Impl { defaultness, ref generics, .. } => {\n                     if defaultness.is_default() {\n                         is_default_impl_trait = tcx.impl_trait_ref(def_id);\n                     }\n@@ -2359,7 +2359,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n     // before uses of `U`.  This avoids false ambiguity errors\n     // in trait checking. See `setup_constraining_predicates`\n     // for details.\n-    if let Node::Item(&Item { kind: ItemKind::Impl(..), .. }) = node {\n+    if let Node::Item(&Item { kind: ItemKind::Impl { .. }, .. }) = node {\n         let self_ty = tcx.type_of(def_id);\n         let trait_ref = tcx.impl_trait_ref(def_id);\n         cgp::setup_constraining_predicates("}, {"sha": "9ee4e7c48190d57af455d5e5f46666f9fc0a1dbc", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -75,10 +75,10 @@ struct ImplWfCheck<'tcx> {\n \n impl ItemLikeVisitor<'tcx> for ImplWfCheck<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        if let hir::ItemKind::Impl(.., ref impl_item_refs) = item.kind {\n+        if let hir::ItemKind::Impl { ref items, .. } = item.kind {\n             let impl_def_id = self.tcx.hir().local_def_id(item.hir_id);\n-            enforce_impl_params_are_constrained(self.tcx, impl_def_id, impl_item_refs);\n-            enforce_impl_items_are_distinct(self.tcx, impl_item_refs);\n+            enforce_impl_params_are_constrained(self.tcx, impl_def_id, items);\n+            enforce_impl_items_are_distinct(self.tcx, items);\n         }\n     }\n "}, {"sha": "8a6abe036dc14b9305901af1892cd7c573401317", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -273,6 +273,22 @@ fn build_type_alias(cx: &DocContext<'_>, did: DefId) -> clean::Typedef {\n     clean::Typedef {\n         type_: cx.tcx.type_of(did).clean(cx),\n         generics: (cx.tcx.generics_of(did), predicates).clean(cx),\n+        item_type: build_type_alias_type(cx, did),\n+    }\n+}\n+\n+fn build_type_alias_type(cx: &DocContext<'_>, did: DefId) -> Option<clean::Type> {\n+    let type_ = cx.tcx.type_of(did).clean(cx);\n+    type_.def_id().and_then(|did| build_ty(cx, did))\n+}\n+\n+pub fn build_ty(cx: &DocContext, did: DefId) -> Option<clean::Type> {\n+    match cx.tcx.def_kind(did)? {\n+        DefKind::Struct | DefKind::Union | DefKind::Enum | DefKind::Const | DefKind::Static => {\n+            Some(cx.tcx.type_of(did).clean(cx))\n+        }\n+        DefKind::TyAlias => build_type_alias_type(cx, did),\n+        _ => None,\n     }\n }\n \n@@ -331,7 +347,7 @@ pub fn build_impl(\n \n     let for_ = if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n         match tcx.hir().expect_item(hir_id).kind {\n-            hir::ItemKind::Impl(.., ref t, _) => t.clean(cx),\n+            hir::ItemKind::Impl { self_ty, .. } => self_ty.clean(cx),\n             _ => panic!(\"did given to build_impl was not an impl\"),\n         }\n     } else {\n@@ -351,9 +367,9 @@ pub fn build_impl(\n     let predicates = tcx.explicit_predicates_of(did);\n     let (trait_items, generics) = if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n         match tcx.hir().expect_item(hir_id).kind {\n-            hir::ItemKind::Impl(.., ref gen, _, _, ref item_ids) => (\n-                item_ids.iter().map(|ii| tcx.hir().impl_item(ii.id).clean(cx)).collect::<Vec<_>>(),\n-                gen.clean(cx),\n+            hir::ItemKind::Impl { ref generics, ref items, .. } => (\n+                items.iter().map(|item| tcx.hir().impl_item(item.id).clean(cx)).collect::<Vec<_>>(),\n+                generics.clean(cx),\n             ),\n             _ => panic!(\"did given to build_impl was not an impl\"),\n         }"}, {"sha": "20a5a6c54984d0bed6dd310df67780dbdd35cc8e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -1122,7 +1122,9 @@ impl Clean<Item> for hir::ImplItem<'_> {\n                 MethodItem((sig, &self.generics, body, Some(self.defaultness)).clean(cx))\n             }\n             hir::ImplItemKind::TyAlias(ref ty) => {\n-                TypedefItem(Typedef { type_: ty.clean(cx), generics: Generics::default() }, true)\n+                let type_ = ty.clean(cx);\n+                let item_type = type_.def_id().and_then(|did| inline::build_ty(cx, did));\n+                TypedefItem(Typedef { type_, generics: Generics::default(), item_type }, true)\n             }\n             hir::ImplItemKind::OpaqueTy(ref bounds) => OpaqueTyItem(\n                 OpaqueTy { bounds: bounds.clean(cx), generics: Generics::default() },\n@@ -1282,10 +1284,13 @@ impl Clean<Item> for ty::AssocItem {\n \n                     AssocTypeItem(bounds, ty.clean(cx))\n                 } else {\n+                    let type_ = cx.tcx.type_of(self.def_id).clean(cx);\n+                    let item_type = type_.def_id().and_then(|did| inline::build_ty(cx, did));\n                     TypedefItem(\n                         Typedef {\n-                            type_: cx.tcx.type_of(self.def_id).clean(cx),\n+                            type_,\n                             generics: Generics { params: Vec::new(), where_predicates: Vec::new() },\n+                            item_type,\n                         },\n                         true,\n                     )\n@@ -1989,6 +1994,8 @@ impl Clean<String> for ast::Name {\n \n impl Clean<Item> for doctree::Typedef<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n+        let type_ = self.ty.clean(cx);\n+        let item_type = type_.def_id().and_then(|did| inline::build_ty(cx, did));\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -1997,10 +2004,7 @@ impl Clean<Item> for doctree::Typedef<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            inner: TypedefItem(\n-                Typedef { type_: self.ty.clean(cx), generics: self.gen.clean(cx) },\n-                false,\n-            ),\n+            inner: TypedefItem(Typedef { type_, generics: self.gen.clean(cx), item_type }, false),\n         }\n     }\n }\n@@ -2101,7 +2105,7 @@ impl Clean<Vec<Item>> for doctree::Impl<'_> {\n             build_deref_target_impls(cx, &items, &mut ret);\n         }\n \n-        let provided = trait_\n+        let provided: FxHashSet<String> = trait_\n             .def_id()\n             .map(|did| {\n                 cx.tcx\n@@ -2112,7 +2116,12 @@ impl Clean<Vec<Item>> for doctree::Impl<'_> {\n             })\n             .unwrap_or_default();\n \n-        ret.push(Item {\n+        let for_ = self.for_.clean(cx);\n+        let type_alias = for_.def_id().and_then(|did| match cx.tcx.def_kind(did) {\n+            Some(DefKind::TyAlias) => Some(cx.tcx.type_of(did).clean(cx)),\n+            _ => None,\n+        });\n+        let make_item = |trait_: Option<Type>, for_: Type, items: Vec<Item>| Item {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n@@ -2123,15 +2132,19 @@ impl Clean<Vec<Item>> for doctree::Impl<'_> {\n             inner: ImplItem(Impl {\n                 unsafety: self.unsafety,\n                 generics: self.generics.clean(cx),\n-                provided_trait_methods: provided,\n+                provided_trait_methods: provided.clone(),\n                 trait_,\n-                for_: self.for_.clean(cx),\n+                for_,\n                 items,\n                 polarity: Some(cx.tcx.impl_polarity(def_id).clean(cx)),\n                 synthetic: false,\n                 blanket_impl: None,\n             }),\n-        });\n+        };\n+        if let Some(type_alias) = type_alias {\n+            ret.push(make_item(trait_.clone(), type_alias, items.clone()));\n+        }\n+        ret.push(make_item(trait_, for_, items));\n         ret\n     }\n }"}, {"sha": "79a078ca7a991abdaf58ccdf8728d6e22b466fbf", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -1406,6 +1406,14 @@ pub struct PathSegment {\n pub struct Typedef {\n     pub type_: Type,\n     pub generics: Generics,\n+    // Type of target item.\n+    pub item_type: Option<Type>,\n+}\n+\n+impl GetDefId for Typedef {\n+    fn def_id(&self) -> Option<DefId> {\n+        self.type_.def_id()\n+    }\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "9406803825350e82abb50b9987f47f73dfc8dbc2", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -3469,20 +3469,23 @@ fn render_deref_methods(\n     deref_mut: bool,\n ) {\n     let deref_type = impl_.inner_impl().trait_.as_ref().unwrap();\n-    let target = impl_\n+    let (target, real_target) = impl_\n         .inner_impl()\n         .items\n         .iter()\n         .filter_map(|item| match item.inner {\n-            clean::TypedefItem(ref t, true) => Some(&t.type_),\n+            clean::TypedefItem(ref t, true) => Some(match *t {\n+                clean::Typedef { item_type: Some(ref type_), .. } => (type_, &t.type_),\n+                _ => (&t.type_, &t.type_),\n+            }),\n             _ => None,\n         })\n         .next()\n         .expect(\"Expected associated type binding\");\n     let what =\n-        AssocItemRender::DerefFor { trait_: deref_type, type_: target, deref_mut_: deref_mut };\n+        AssocItemRender::DerefFor { trait_: deref_type, type_: real_target, deref_mut_: deref_mut };\n     if let Some(did) = target.def_id() {\n-        render_assoc_items(w, cx, container_item, did, what)\n+        render_assoc_items(w, cx, container_item, did, what);\n     } else {\n         if let Some(prim) = target.primitive_type() {\n             if let Some(&did) = cx.cache.primitive_locations.get(&prim) {\n@@ -4123,12 +4126,15 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n                 .filter(|i| i.inner_impl().trait_.is_some())\n                 .find(|i| i.inner_impl().trait_.def_id() == c.deref_trait_did)\n             {\n-                if let Some(target) = impl_\n+                if let Some((target, real_target)) = impl_\n                     .inner_impl()\n                     .items\n                     .iter()\n                     .filter_map(|item| match item.inner {\n-                        clean::TypedefItem(ref t, true) => Some(&t.type_),\n+                        clean::TypedefItem(ref t, true) => Some(match *t {\n+                            clean::Typedef { item_type: Some(ref type_), .. } => (type_, &t.type_),\n+                            _ => (&t.type_, &t.type_),\n+                        }),\n                         _ => None,\n                     })\n                     .next()\n@@ -4147,7 +4153,7 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n                                 \"{:#}\",\n                                 impl_.inner_impl().trait_.as_ref().unwrap().print()\n                             )),\n-                            Escape(&format!(\"{:#}\", target.print()))\n+                            Escape(&format!(\"{:#}\", real_target.print()))\n                         ));\n                         out.push_str(\"</a>\");\n                         let mut ret = impls"}, {"sha": "f1f83acdda59e81cb16f0593ae59ea5b5970a684", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -277,7 +277,7 @@ impl DocFolder for Cache {\n                 | clean::StructFieldItem(..)\n                 | clean::VariantItem(..) => (\n                     (\n-                        Some(*self.parent_stack.last().unwrap()),\n+                        Some(*self.parent_stack.last().expect(\"parent_stack is empty\")),\n                         Some(&self.stack[..self.stack.len() - 1]),\n                     ),\n                     false,\n@@ -286,7 +286,7 @@ impl DocFolder for Cache {\n                     if self.parent_stack.is_empty() {\n                         ((None, None), false)\n                     } else {\n-                        let last = self.parent_stack.last().unwrap();\n+                        let last = self.parent_stack.last().expect(\"parent_stack is empty 2\");\n                         let did = *last;\n                         let path = match self.paths.get(&did) {\n                             // The current stack not necessarily has correlation\n@@ -468,7 +468,7 @@ impl DocFolder for Cache {\n                         self.impls.entry(did).or_insert(vec![]).push(impl_item.clone());\n                     }\n                 } else {\n-                    let trait_did = impl_item.trait_did().unwrap();\n+                    let trait_did = impl_item.trait_did().expect(\"no trait did\");\n                     self.orphan_trait_impls.push((trait_did, dids, impl_item));\n                 }\n                 None\n@@ -478,10 +478,10 @@ impl DocFolder for Cache {\n         });\n \n         if pushed {\n-            self.stack.pop().unwrap();\n+            self.stack.pop().expect(\"stack already empty\");\n         }\n         if parent_pushed {\n-            self.parent_stack.pop().unwrap();\n+            self.parent_stack.pop().expect(\"parent stack already empty\");\n         }\n         self.stripped_mod = orig_stripped_mod;\n         self.parent_is_trait_impl = orig_parent_is_trait_impl;\n@@ -594,7 +594,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     for item in search_index {\n         item.parent_idx = item.parent.map(|nodeid| {\n             if nodeid_to_pathid.contains_key(&nodeid) {\n-                *nodeid_to_pathid.get(&nodeid).unwrap()\n+                *nodeid_to_pathid.get(&nodeid).expect(\"no pathid\")\n             } else {\n                 let pathid = lastpathid;\n                 nodeid_to_pathid.insert(nodeid, pathid);\n@@ -639,7 +639,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n             items: crate_items,\n             paths: crate_paths,\n         })\n-        .unwrap()\n+        .expect(\"failed serde conversion\")\n     )\n }\n "}, {"sha": "05d41415689813e42a00df41028d3a020a953042", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -905,8 +905,8 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n     }\n \n     fn visit_item(&mut self, item: &'hir hir::Item) {\n-        let name = if let hir::ItemKind::Impl(.., ref ty, _) = item.kind {\n-            self.map.hir_to_pretty_string(ty.hir_id)\n+        let name = if let hir::ItemKind::Impl { ref self_ty, .. } = item.kind {\n+            self.map.hir_to_pretty_string(self_ty.hir_id)\n         } else {\n             item.ident.to_string()\n         };"}, {"sha": "fdff18779e7954364834429ac03cec4a16d267da", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -558,27 +558,27 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 om.trait_aliases.push(t);\n             }\n \n-            hir::ItemKind::Impl(\n+            hir::ItemKind::Impl {\n                 unsafety,\n                 polarity,\n                 defaultness,\n                 ref generics,\n-                ref trait_,\n-                for_,\n-                ref item_ids,\n-            ) => {\n+                ref of_trait,\n+                self_ty,\n+                ref items,\n+            } => {\n                 // Don't duplicate impls when inlining or if it's implementing a trait, we'll pick\n                 // them up regardless of where they're located.\n-                if !self.inlining && trait_.is_none() {\n+                if !self.inlining && of_trait.is_none() {\n                     let items =\n-                        item_ids.iter().map(|ii| self.cx.tcx.hir().impl_item(ii.id)).collect();\n+                        items.iter().map(|item| self.cx.tcx.hir().impl_item(item.id)).collect();\n                     let i = Impl {\n                         unsafety,\n                         polarity,\n                         defaultness,\n                         generics,\n-                        trait_,\n-                        for_,\n+                        trait_: of_trait,\n+                        for_: self_ty,\n                         items,\n                         attrs: &item.attrs,\n                         id: item.hir_id,"}, {"sha": "a5a4eb1583bedc10cb14aff332471431e2930b49", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -2614,15 +2614,18 @@ pub enum ItemKind {\n     /// An implementation.\n     ///\n     /// E.g., `impl<A> Foo<A> { .. }` or `impl<A> Trait for Foo<A> { .. }`.\n-    Impl(\n-        Unsafety,\n-        ImplPolarity,\n-        Defaultness,\n-        Generics,\n-        Option<TraitRef>, // (optional) trait this impl implements\n-        P<Ty>,            // self\n-        Vec<AssocItem>,\n-    ),\n+    Impl {\n+        unsafety: Unsafety,\n+        polarity: ImplPolarity,\n+        defaultness: Defaultness,\n+        generics: Generics,\n+\n+        /// The trait being implemented, if any.\n+        of_trait: Option<TraitRef>,\n+\n+        self_ty: P<Ty>,\n+        items: Vec<AssocItem>,\n+    },\n     /// A macro invocation.\n     ///\n     /// E.g., `foo!(..)`.\n@@ -2649,7 +2652,7 @@ impl ItemKind {\n             ItemKind::Union(..) => \"union\",\n             ItemKind::Trait(..) => \"trait\",\n             ItemKind::TraitAlias(..) => \"trait alias\",\n-            ItemKind::Mac(..) | ItemKind::MacroDef(..) | ItemKind::Impl(..) => \"item\",\n+            ItemKind::Mac(..) | ItemKind::MacroDef(..) | ItemKind::Impl { .. } => \"item\",\n         }\n     }\n }"}, {"sha": "750d054e8a0f2d4891709681bb960be492545b91", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -918,10 +918,18 @@ pub fn noop_visit_item_kind<T: MutVisitor>(kind: &mut ItemKind, vis: &mut T) {\n             vis.visit_variant_data(variant_data);\n             vis.visit_generics(generics);\n         }\n-        ItemKind::Impl(_unsafety, _polarity, _defaultness, generics, trait_ref, ty, items) => {\n+        ItemKind::Impl {\n+            unsafety: _,\n+            polarity: _,\n+            defaultness: _,\n+            generics,\n+            of_trait,\n+            self_ty,\n+            items,\n+        } => {\n             vis.visit_generics(generics);\n-            visit_opt(trait_ref, |trait_ref| vis.visit_trait_ref(trait_ref));\n-            vis.visit_ty(ty);\n+            visit_opt(of_trait, |trait_ref| vis.visit_trait_ref(trait_ref));\n+            vis.visit_ty(self_ty);\n             items.flat_map_in_place(|item| vis.flat_map_impl_item(item));\n         }\n         ItemKind::Trait(_is_auto, _unsafety, generics, bounds, items) => {"}, {"sha": "bc67980c454c0c4093e868a882d8c9d1ba345bc3", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -1226,15 +1226,15 @@ impl<'a> State<'a> {\n                 self.head(visibility_qualified(&item.vis, \"union\"));\n                 self.print_struct(struct_def, generics, item.ident, item.span, true);\n             }\n-            ast::ItemKind::Impl(\n+            ast::ItemKind::Impl {\n                 unsafety,\n                 polarity,\n                 defaultness,\n                 ref generics,\n-                ref opt_trait,\n-                ref ty,\n-                ref impl_items,\n-            ) => {\n+                ref of_trait,\n+                ref self_ty,\n+                ref items,\n+            } => {\n                 self.head(\"\");\n                 self.print_visibility(&item.vis);\n                 self.print_defaultness(defaultness);\n@@ -1250,19 +1250,19 @@ impl<'a> State<'a> {\n                     self.s.word(\"!\");\n                 }\n \n-                if let Some(ref t) = *opt_trait {\n+                if let Some(ref t) = *of_trait {\n                     self.print_trait_ref(t);\n                     self.s.space();\n                     self.word_space(\"for\");\n                 }\n \n-                self.print_type(ty);\n+                self.print_type(self_ty);\n                 self.print_where_clause(&generics.where_clause);\n \n                 self.s.space();\n                 self.bopen();\n                 self.print_inner_attributes(&item.attrs);\n-                for impl_item in impl_items {\n+                for impl_item in items {\n                     self.print_assoc_item(impl_item);\n                 }\n                 self.bclose(item.span);"}, {"sha": "d03a9dfc167588b0f83930e2a0c108e0fff781d1", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -308,11 +308,19 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n             visitor.visit_generics(generics);\n             visitor.visit_enum_def(enum_definition, generics, item.id, item.span)\n         }\n-        ItemKind::Impl(_, _, _, ref generics, ref opt_trait_reference, ref typ, ref impl_items) => {\n+        ItemKind::Impl {\n+            unsafety: _,\n+            polarity: _,\n+            defaultness: _,\n+            ref generics,\n+            ref of_trait,\n+            ref self_ty,\n+            ref items,\n+        } => {\n             visitor.visit_generics(generics);\n-            walk_list!(visitor, visit_trait_ref, opt_trait_reference);\n-            visitor.visit_ty(typ);\n-            walk_list!(visitor, visit_impl_item, impl_items);\n+            walk_list!(visitor, visit_trait_ref, of_trait);\n+            visitor.visit_ty(self_ty);\n+            walk_list!(visitor, visit_impl_item, items);\n         }\n         ItemKind::Struct(ref struct_definition, ref generics)\n         | ItemKind::Union(ref struct_definition, ref generics) => {"}, {"sha": "7f5e9049b2f77e3acd72cb1bef34b33ef39e377e", "filename": "src/test/run-make-fulldeps/sanitizer-address/Makefile", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-address%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-address%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-address%2FMakefile?ref=d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c", "patch": "@@ -1,30 +0,0 @@\n-# needs-sanitizer-support\n-\n--include ../tools.mk\n-\n-LOG := $(TMPDIR)/log.txt\n-\n-# NOTE the address sanitizer only supports x86_64 linux and macOS\n-\n-ifeq ($(TARGET),x86_64-apple-darwin)\n-EXTRA_RUSTFLAG=-C rpath\n-else\n-ifeq ($(TARGET),x86_64-unknown-linux-gnu)\n-\n-# Apparently there are very specific Linux kernels, notably the one that's\n-# currently on Travis CI, which contain a buggy commit that triggers failures in\n-# the ASan implementation, detailed at google/sanitizers#837. As noted in\n-# google/sanitizers#856 the \"fix\" is to avoid using PIE binaries, so we pass a\n-# different relocation model to avoid generating a PIE binary. Once Travis is no\n-# longer running kernel 4.4.0-93 we can remove this and pass an empty set of\n-# flags again.\n-EXTRA_RUSTFLAG=-C relocation-model=dynamic-no-pic\n-endif\n-endif\n-\n-all:\n-\t$(RUSTC) -g -Z sanitizer=address -Z print-link-args $(EXTRA_RUSTFLAG) overflow.rs | $(CGREP) rustc_rt.asan\n-\t# Verify that stack buffer overflow is detected:\n-\t$(TMPDIR)/overflow 2>&1 | $(CGREP) stack-buffer-overflow\n-\t# Verify that variable name is included in address sanitizer report:\n-\t$(TMPDIR)/overflow 2>&1 | $(CGREP) \"'xs'\""}, {"sha": "b997a74cc3eb4ac0d810076e9a298ff51f8131b7", "filename": "src/test/run-make-fulldeps/sanitizer-address/overflow.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-address%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-address%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-address%2Foverflow.rs?ref=d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c", "patch": "@@ -1,4 +0,0 @@\n-fn main() {\n-    let xs = [0, 1, 2, 3];\n-    let _y = unsafe { *xs.as_ptr().offset(4) };\n-}"}, {"sha": "2a23f0fe3d4ef1d5465db9e0b7ecf59ac0c44b9c", "filename": "src/test/run-make-fulldeps/sanitizer-invalid-target/Makefile", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-invalid-target%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-invalid-target%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-invalid-target%2FMakefile?ref=d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c", "patch": "@@ -1,5 +0,0 @@\n--include ../tools.mk\n-\n-all:\n-\t$(RUSTC) -Z sanitizer=leak --target i686-unknown-linux-gnu hello.rs 2>&1 | \\\n-\t\t$(CGREP) 'LeakSanitizer only works with the `x86_64-unknown-linux-gnu` or `x86_64-apple-darwin` target'"}, {"sha": "d3dd5ed03d9548e1015db5a13d339fc7971be813", "filename": "src/test/run-make-fulldeps/sanitizer-invalid-target/hello.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-invalid-target%2Fhello.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-invalid-target%2Fhello.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-invalid-target%2Fhello.rs?ref=d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c", "patch": "@@ -1,3 +0,0 @@\n-#![feature(no_core)]\n-#![no_core]\n-#![no_main]"}, {"sha": "da370335ca91814ddf9f68862a52e48cdff5aa73", "filename": "src/test/run-make-fulldeps/sanitizer-leak/Makefile", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-leak%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-leak%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-leak%2FMakefile?ref=d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c", "patch": "@@ -1,7 +0,0 @@\n--include ../tools.mk\n-\n-# needs-sanitizer-support\n-\n-all:\n-\t$(RUSTC) -O -Z sanitizer=leak -Z print-link-args leak.rs | $(CGREP) rustc_rt.lsan\n-\t$(TMPDIR)/leak 2>&1 | $(CGREP) 'detected memory leaks'"}, {"sha": "8bc9df1b4baebbaa5d23d2521e1891439df19d97", "filename": "src/test/run-make-fulldeps/sanitizer-memory/Makefile", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-memory%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-memory%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-memory%2FMakefile?ref=d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c", "patch": "@@ -1,11 +0,0 @@\n--include ../tools.mk\n-\n-# needs-sanitizer-support\n-# only-linux\n-# only-x86_64\n-\n-all:\n-\t$(RUSTC) -g -Z sanitizer=memory -Z print-link-args uninit.rs | $(CGREP) rustc_rt.msan\n-\t$(TMPDIR)/uninit 2>&1 | $(CGREP) use-of-uninitialized-value\n-\t$(RUSTC) -g -Z sanitizer=memory -Z print-link-args maybeuninit.rs | $(CGREP) rustc_rt.msan\n-\t$(TMPDIR)/maybeuninit 2>&1 | $(CGREP) use-of-uninitialized-value"}, {"sha": "a9ae85f57639e8d8e78f38d19cc83fc2ef829c04", "filename": "src/test/run-make-fulldeps/sanitizer-memory/maybeuninit.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-memory%2Fmaybeuninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-memory%2Fmaybeuninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-memory%2Fmaybeuninit.rs?ref=d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c", "patch": "@@ -1,8 +0,0 @@\n-use std::mem::MaybeUninit;\n-\n-fn main() {\n-    // This is technically not sound -- but we're literally trying to test\n-    // that the sanitizer catches this, so I guess \"intentionally unsound\"?\n-    let xs: [u8; 4] = unsafe { MaybeUninit::uninit().assume_init() };\n-    let y = xs[0] + xs[1];\n-}"}, {"sha": "eae52508f658543ee92825830af6aebe13176880", "filename": "src/test/run-make-fulldeps/sanitizer-memory/uninit.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-memory%2Funinit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-memory%2Funinit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-memory%2Funinit.rs?ref=d8dcb6345bfac471aadc1e674aef8ddc78ad5c1c", "patch": "@@ -1,7 +0,0 @@\n-fn main() {\n-    // This is technically not sound -- but we're literally trying to test\n-    // that the sanitizer catches this, so I guess \"intentionally unsound\"?\n-    #[allow(deprecated)]\n-    let xs: [u8; 4] = unsafe { std::mem::uninitialized() };\n-    let y = xs[0] + xs[1];\n-}"}, {"sha": "770f8d7289c3bb2ce26a7c3698f6999a9afc7cc3", "filename": "src/test/rustdoc/deref-typedef.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Ftest%2Frustdoc%2Fderef-typedef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Ftest%2Frustdoc%2Fderef-typedef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fderef-typedef.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -0,0 +1,33 @@\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/struct.Bar.html'\n+// @has '-' '//*[@id=\"deref-methods\"]' 'Methods from Deref<Target = FooC>'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.foo_a\"]' 'pub fn foo_a(&self)'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.foo_b\"]' 'pub fn foo_b(&self)'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.foo_c\"]' 'pub fn foo_c(&self)'\n+// @has '-' '//*[@class=\"sidebar-title\"]' 'Methods from Deref<Target=FooC>'\n+// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.foo_a\"]' 'foo_a'\n+// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.foo_b\"]' 'foo_b'\n+// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.foo_c\"]' 'foo_c'\n+\n+pub struct FooA;\n+pub type FooB = FooA;\n+pub type FooC = FooB;\n+\n+impl FooA {\n+    pub fn foo_a(&self) {}\n+}\n+\n+impl FooB {\n+    pub fn foo_b(&self) {}\n+}\n+\n+impl FooC {\n+    pub fn foo_c(&self) {}\n+}\n+\n+pub struct Bar;\n+impl std::ops::Deref for Bar {\n+    type Target = FooC;\n+    fn deref(&self) -> &Self::Target { unimplemented!() }\n+}"}, {"sha": "30fbfda112c557a470c6aa2183990f2938e57c6e", "filename": "src/test/ui/const-generics/integer-literal-generic-arg-in-where-clause.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Ftest%2Fui%2Fconst-generics%2Finteger-literal-generic-arg-in-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Ftest%2Fui%2Fconst-generics%2Finteger-literal-generic-arg-in-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finteger-literal-generic-arg-in-where-clause.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+fn takes_closure_of_array_3<F>(f: F) where F: Fn([i32; 3]) {\n+    f([1, 2, 3]);\n+}\n+\n+fn takes_closure_of_array_3_apit(f: impl Fn([i32; 3])) {\n+    f([1, 2, 3]);\n+}\n+\n+fn returns_closure_of_array_3() -> impl Fn([i32; 3]) {\n+    |_| {}\n+}\n+\n+fn main() {}"}, {"sha": "7f37f3e2791eca32581b8641b24ea3645acd76ec", "filename": "src/test/ui/const-generics/integer-literal-generic-arg-in-where-clause.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Ftest%2Fui%2Fconst-generics%2Finteger-literal-generic-arg-in-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Ftest%2Fui%2Fconst-generics%2Finteger-literal-generic-arg-in-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finteger-literal-generic-arg-in-where-clause.stderr?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -0,0 +1,8 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/integer-literal-generic-arg-in-where-clause.rs:3:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+"}, {"sha": "0d7fb845a40eeffb1cba2bc8193a1c8455e27d92", "filename": "src/test/ui/consts/miri_unleashed/mutable_const2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const2.stderr?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -10,7 +10,7 @@ error: internal compiler error: mutable allocation in constant\n LL | const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-thread 'rustc' panicked at 'no errors encountered even though `delay_span_bug` issued', src/librustc_errors/lib.rs:346:17\n+thread 'rustc' panicked at 'no errors encountered even though `delay_span_bug` issued', src/librustc_errors/lib.rs:356:17\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n \n error: internal compiler error: unexpected panic"}, {"sha": "c2b81959f2cb81297184b217787b056408119655", "filename": "src/test/ui/lint/issue-66362-no-snake-case-warning-for-field-puns.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Ftest%2Fui%2Flint%2Fissue-66362-no-snake-case-warning-for-field-puns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Ftest%2Fui%2Flint%2Fissue-66362-no-snake-case-warning-for-field-puns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-66362-no-snake-case-warning-for-field-puns.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -0,0 +1,29 @@\n+#![deny(non_snake_case)]\n+#![allow(unused_variables)]\n+#![allow(dead_code)]\n+\n+enum Foo {\n+    Bad {\n+        lowerCamelCaseName: bool,\n+        //~^ ERROR structure field `lowerCamelCaseName` should have a snake case name\n+    },\n+    Good {\n+        snake_case_name: bool,\n+    },\n+}\n+\n+fn main() {\n+    let b = Foo::Bad { lowerCamelCaseName: true };\n+\n+    match b {\n+        Foo::Bad { lowerCamelCaseName } => {}\n+        Foo::Good { snake_case_name: lowerCamelCaseBinding } => { }\n+        //~^ ERROR variable `lowerCamelCaseBinding` should have a snake case name\n+    }\n+\n+    if let Foo::Good { snake_case_name: anotherLowerCamelCaseBinding } = b { }\n+    //~^ ERROR variable `anotherLowerCamelCaseBinding` should have a snake case name\n+\n+    if let Foo::Bad { lowerCamelCaseName: yetAnotherLowerCamelCaseBinding } = b { }\n+    //~^ ERROR variable `yetAnotherLowerCamelCaseBinding` should have a snake case name\n+}"}, {"sha": "68956f21e8f1b68096494deb3dc8842a0dbb83fe", "filename": "src/test/ui/lint/issue-66362-no-snake-case-warning-for-field-puns.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Ftest%2Fui%2Flint%2Fissue-66362-no-snake-case-warning-for-field-puns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Ftest%2Fui%2Flint%2Fissue-66362-no-snake-case-warning-for-field-puns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-66362-no-snake-case-warning-for-field-puns.stderr?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -0,0 +1,32 @@\n+error: structure field `lowerCamelCaseName` should have a snake case name\n+  --> $DIR/issue-66362-no-snake-case-warning-for-field-puns.rs:7:9\n+   |\n+LL |         lowerCamelCaseName: bool,\n+   |         ^^^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `lower_camel_case_name`\n+   |\n+note: lint level defined here\n+  --> $DIR/issue-66362-no-snake-case-warning-for-field-puns.rs:1:9\n+   |\n+LL | #![deny(non_snake_case)]\n+   |         ^^^^^^^^^^^^^^\n+\n+error: variable `lowerCamelCaseBinding` should have a snake case name\n+  --> $DIR/issue-66362-no-snake-case-warning-for-field-puns.rs:20:38\n+   |\n+LL |         Foo::Good { snake_case_name: lowerCamelCaseBinding } => { }\n+   |                                      ^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `lower_camel_case_binding`\n+\n+error: variable `anotherLowerCamelCaseBinding` should have a snake case name\n+  --> $DIR/issue-66362-no-snake-case-warning-for-field-puns.rs:24:41\n+   |\n+LL |     if let Foo::Good { snake_case_name: anotherLowerCamelCaseBinding } = b { }\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `another_lower_camel_case_binding`\n+\n+error: variable `yetAnotherLowerCamelCaseBinding` should have a snake case name\n+  --> $DIR/issue-66362-no-snake-case-warning-for-field-puns.rs:27:43\n+   |\n+LL |     if let Foo::Bad { lowerCamelCaseName: yetAnotherLowerCamelCaseBinding } = b { }\n+   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `yet_another_lower_camel_case_binding`\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "d27a30a2dc55f9e65db391fb888dd49fa0f2f1ef", "filename": "src/test/ui/sanitizer-address.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Ftest%2Fui%2Fsanitizer-address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Ftest%2Fui%2Fsanitizer-address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitizer-address.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -0,0 +1,21 @@\n+// needs-sanitizer-support\n+// only-x86_64\n+//\n+// compile-flags: -Z sanitizer=address -O\n+//\n+// run-fail\n+// error-pattern: AddressSanitizer: stack-buffer-overflow\n+// error-pattern: 'xs' <== Memory access at offset\n+\n+#![feature(test)]\n+\n+use std::hint::black_box;\n+use std::mem;\n+\n+fn main() {\n+    let xs = [0, 1, 2, 3];\n+    // Avoid optimizing everything out.\n+    let xs = black_box(xs.as_ptr());\n+    let code = unsafe { *xs.offset(4) };\n+    std::process::exit(code);\n+}"}, {"sha": "5c2f2cb4e868bb0012a960f21a61e7f85f044017", "filename": "src/test/ui/sanitizer-leak.rs", "status": "renamed", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Ftest%2Fui%2Fsanitizer-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Ftest%2Fui%2Fsanitizer-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitizer-leak.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -1,3 +1,11 @@\n+// needs-sanitizer-support\n+// only-x86_64\n+//\n+// compile-flags: -Z sanitizer=leak -O\n+//\n+// run-fail\n+// error-pattern: LeakSanitizer: detected memory leaks\n+\n #![feature(test)]\n \n use std::hint::black_box;", "previous_filename": "src/test/run-make-fulldeps/sanitizer-leak/leak.rs"}, {"sha": "3e1cf4509a31ff953cc9a914b9caef79083e729b", "filename": "src/test/ui/sanitizer-memory.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Ftest%2Fui%2Fsanitizer-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Ftest%2Fui%2Fsanitizer-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitizer-memory.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -0,0 +1,44 @@\n+// needs-sanitizer-support\n+// only-linux\n+// only-x86_64\n+//\n+// compile-flags: -Z sanitizer=memory -Zsanitizer-memory-track-origins -O\n+//\n+// run-fail\n+// error-pattern: MemorySanitizer: use-of-uninitialized-value\n+// error-pattern: Uninitialized value was created by an allocation\n+// error-pattern: in the stack frame of function 'random'\n+//\n+// This test case intentionally limits the usage of the std,\n+// since it will be linked with an uninstrumented version of it.\n+\n+#![feature(core_intrinsics)]\n+#![feature(start)]\n+#![feature(test)]\n+\n+use std::hint::black_box;\n+use std::mem::MaybeUninit;\n+\n+#[inline(never)]\n+#[no_mangle]\n+fn random() -> [isize; 32] {\n+    let r = unsafe { MaybeUninit::uninit().assume_init() };\n+    // Avoid optimizing everything out.\n+    black_box(r)\n+}\n+\n+#[inline(never)]\n+#[no_mangle]\n+fn xor(a: &[isize]) -> isize {\n+    let mut s = 0;\n+    for i in 0..a.len() {\n+        s = s ^ a[i];\n+    }\n+    s\n+}\n+\n+#[start]\n+fn main(_: isize, _: *const *const u8) -> isize {\n+    let r = random();\n+    xor(&r)\n+}"}, {"sha": "444333c3f01e22a3413e6e8875193e7b8102c819", "filename": "src/test/ui/sanitizer-unsupported-target.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Ftest%2Fui%2Fsanitizer-unsupported-target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Ftest%2Fui%2Fsanitizer-unsupported-target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitizer-unsupported-target.rs?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -0,0 +1,7 @@\n+// ignore-tidy-linelength\n+// compile-flags: -Z sanitizer=leak --target i686-unknown-linux-gnu\n+// error-pattern: error: LeakSanitizer only works with the `x86_64-unknown-linux-gnu` or `x86_64-apple-darwin` target\n+\n+#![feature(no_core)]\n+#![no_core]\n+#![no_main]"}, {"sha": "38be58dd4b36598babb4049de8cfdee4352c1af1", "filename": "src/test/ui/sanitizer-unsupported-target.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Ftest%2Fui%2Fsanitizer-unsupported-target.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c28fe89c7d33953841e8c210e769ba8ce5ceedb/src%2Ftest%2Fui%2Fsanitizer-unsupported-target.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsanitizer-unsupported-target.stderr?ref=8c28fe89c7d33953841e8c210e769ba8ce5ceedb", "patch": "@@ -0,0 +1,4 @@\n+error: LeakSanitizer only works with the `x86_64-unknown-linux-gnu` or `x86_64-apple-darwin` target\n+\n+error: aborting due to previous error\n+"}]}