{"sha": "cb58b19f023f95614e4a2bc3c812614d0938a9f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiNThiMTlmMDIzZjk1NjE0ZTRhMmJjM2M4MTI2MTRkMDkzOGE5ZjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-23T18:13:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-23T18:13:54Z"}, "message": "auto merge of #7319 : thestinger/rust/hashmap-iterator, r=thestinger\n\n#7277", "tree": {"sha": "1a808373bec4162f0f59313d7ffe177d2b889d0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a808373bec4162f0f59313d7ffe177d2b889d0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb58b19f023f95614e4a2bc3c812614d0938a9f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb58b19f023f95614e4a2bc3c812614d0938a9f2", "html_url": "https://github.com/rust-lang/rust/commit/cb58b19f023f95614e4a2bc3c812614d0938a9f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb58b19f023f95614e4a2bc3c812614d0938a9f2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c17ff80e01d326028366e9268248628e4667dfcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/c17ff80e01d326028366e9268248628e4667dfcd", "html_url": "https://github.com/rust-lang/rust/commit/c17ff80e01d326028366e9268248628e4667dfcd"}, {"sha": "ac2e167e7ed73cdb8863075d09633bb91ca0028f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac2e167e7ed73cdb8863075d09633bb91ca0028f", "html_url": "https://github.com/rust-lang/rust/commit/ac2e167e7ed73cdb8863075d09633bb91ca0028f"}], "stats": {"total": 138, "additions": 109, "deletions": 29}, "files": [{"sha": "7d55947e81881e2c629f4b052e622e17ce1c198c", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 106, "deletions": 27, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/cb58b19f023f95614e4a2bc3c812614d0938a9f2/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb58b19f023f95614e4a2bc3c812614d0938a9f2/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=cb58b19f023f95614e4a2bc3c812614d0938a9f2", "patch": "@@ -18,15 +18,13 @@\n use container::{Container, Mutable, Map, Set};\n use cmp::{Eq, Equiv};\n use hash::Hash;\n-use old_iter::BaseIter;\n-use old_iter;\n-use iterator::IteratorUtil;\n+use iterator::{Iterator, IteratorUtil};\n use option::{None, Option, Some};\n use rand::RngUtil;\n use rand;\n use uint;\n use vec;\n-use vec::ImmutableVector;\n+use vec::{ImmutableVector, MutableVector};\n use kinds::Copy;\n use util::{replace, unreachable};\n \n@@ -311,24 +309,17 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n \n     /// Visit all key-value pairs\n     fn each<'a>(&'a self, blk: &fn(&K, &'a V) -> bool) -> bool {\n-        for self.buckets.iter().advance |bucket| {\n-            for bucket.iter().advance |pair| {\n-                if !blk(&pair.key, &pair.value) {\n-                    return false;\n-                }\n-            }\n-        }\n-        return true;\n+        self.iter().advance(|(k, v)| blk(k, v))\n     }\n \n     /// Visit all keys\n     fn each_key(&self, blk: &fn(k: &K) -> bool) -> bool {\n-        self.each(|k, _| blk(k))\n+        self.iter().advance(|(k, _)| blk(k))\n     }\n \n     /// Visit all values\n     fn each_value<'a>(&'a self, blk: &fn(v: &'a V) -> bool) -> bool {\n-        self.each(|_, v| blk(v))\n+        self.iter().advance(|(_, v)| blk(v))\n     }\n \n     /// Iterate over the map and mutate the contained values\n@@ -524,6 +515,19 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n             TableFull | FoundHole(_) => None,\n         }\n     }\n+\n+    /// An iterator visiting all key-value pairs in arbitrary order.\n+    /// Iterator element type is (&'a K, &'a V).\n+    pub fn iter<'a>(&'a self) -> HashMapIterator<'a, K, V> {\n+        HashMapIterator { iter: self.buckets.iter() }\n+    }\n+\n+    /// An iterator visiting all key-value pairs in arbitrary order,\n+    /// with mutable references to the values.\n+    /// Iterator element type is (&'a K, &'a mut V).\n+    pub fn mut_iter<'a>(&'a mut self) -> HashMapMutIterator<'a, K, V> {\n+        HashMapMutIterator { iter: self.buckets.mut_iter() }\n+    }\n }\n \n impl<K: Hash + Eq, V: Copy> HashMap<K, V> {\n@@ -542,7 +546,7 @@ impl<K:Hash + Eq,V:Eq> Eq for HashMap<K, V> {\n     fn eq(&self, other: &HashMap<K, V>) -> bool {\n         if self.len() != other.len() { return false; }\n \n-        for self.each |key, value| {\n+        for self.iter().advance |(key, value)| {\n             match other.find(key) {\n                 None => return false,\n                 Some(v) => if value != v { return false },\n@@ -555,19 +559,68 @@ impl<K:Hash + Eq,V:Eq> Eq for HashMap<K, V> {\n     fn ne(&self, other: &HashMap<K, V>) -> bool { !self.eq(other) }\n }\n \n+/// HashMap iterator\n+pub struct HashMapIterator<'self, K, V> {\n+    priv iter: vec::VecIterator<'self, Option<Bucket<K, V>>>,\n+}\n+\n+/// HashMap mutable values iterator\n+pub struct HashMapMutIterator<'self, K, V> {\n+    priv iter: vec::VecMutIterator<'self, Option<Bucket<K, V>>>,\n+}\n+\n+/// HashSet iterator\n+pub struct HashSetIterator<'self, K> {\n+    priv iter: vec::VecIterator<'self, Option<Bucket<K, ()>>>,\n+}\n+\n+impl<'self, K, V> Iterator<(&'self K, &'self V)> for HashMapIterator<'self, K, V> {\n+    #[inline]\n+    fn next(&mut self) -> Option<(&'self K, &'self V)> {\n+        for self.iter.advance |elt| {\n+            match elt {\n+                &Some(ref bucket) => return Some((&bucket.key, &bucket.value)),\n+                &None => {},\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+impl<'self, K, V> Iterator<(&'self K, &'self mut V)> for HashMapMutIterator<'self, K, V> {\n+    #[inline]\n+    fn next(&mut self) -> Option<(&'self K, &'self mut V)> {\n+        for self.iter.advance |elt| {\n+            match elt {\n+                &Some(ref mut bucket) => return Some((&bucket.key, &mut bucket.value)),\n+                &None => {},\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+impl<'self, K> Iterator<&'self K> for HashSetIterator<'self, K> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'self K> {\n+        for self.iter.advance |elt| {\n+            match elt {\n+                &Some(ref bucket) => return Some(&bucket.key),\n+                &None => {},\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+\n /// An implementation of a hash set using the underlying representation of a\n /// HashMap where the value is (). As with the `HashMap` type, a `HashSet`\n /// requires that the elements implement the `Eq` and `Hash` traits.\n pub struct HashSet<T> {\n     priv map: HashMap<T, ()>\n }\n \n-impl<T:Hash + Eq> BaseIter<T> for HashSet<T> {\n-    /// Visit all values in order\n-    fn each(&self, f: &fn(&T) -> bool) -> bool { self.map.each_key(f) }\n-    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n-}\n-\n impl<T:Hash + Eq> Eq for HashSet<T> {\n     fn eq(&self, other: &HashSet<T>) -> bool { self.map == other.map }\n     fn ne(&self, other: &HashSet<T>) -> bool { self.map != other.map }\n@@ -601,12 +654,12 @@ impl<T:Hash + Eq> Set<T> for HashSet<T> {\n     /// Return true if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n     fn is_disjoint(&self, other: &HashSet<T>) -> bool {\n-        old_iter::all(self, |v| !other.contains(v))\n+        self.iter().all(|v| !other.contains(v))\n     }\n \n     /// Return true if the set is a subset of another\n     fn is_subset(&self, other: &HashSet<T>) -> bool {\n-        old_iter::all(self, |v| other.contains(v))\n+        self.iter().all(|v| other.contains(v))\n     }\n \n     /// Return true if the set is a superset of another\n@@ -616,7 +669,7 @@ impl<T:Hash + Eq> Set<T> for HashSet<T> {\n \n     /// Visit the values representing the difference\n     fn difference(&self, other: &HashSet<T>, f: &fn(&T) -> bool) -> bool {\n-        self.each(|v| other.contains(v) || f(v))\n+        self.iter().advance(|v| other.contains(v) || f(v))\n     }\n \n     /// Visit the values representing the symmetric difference\n@@ -628,12 +681,12 @@ impl<T:Hash + Eq> Set<T> for HashSet<T> {\n \n     /// Visit the values representing the intersection\n     fn intersection(&self, other: &HashSet<T>, f: &fn(&T) -> bool) -> bool {\n-        self.each(|v| !other.contains(v) || f(v))\n+        self.iter().advance(|v| !other.contains(v) || f(v))\n     }\n \n     /// Visit the values representing the union\n     fn union(&self, other: &HashSet<T>, f: &fn(&T) -> bool) -> bool {\n-        self.each(f) && other.each(|v| self.contains(v) || f(v))\n+        self.iter().advance(f) && other.iter().advance(|v| self.contains(v) || f(v))\n     }\n }\n \n@@ -664,6 +717,18 @@ impl<T:Hash + Eq> HashSet<T> {\n     pub fn contains_equiv<Q:Hash + Equiv<T>>(&self, value: &Q) -> bool {\n       self.map.contains_key_equiv(value)\n     }\n+\n+    /// Visit all elements in arbitrary order\n+    /// FIXME: #6978: Remove when all callers are converted\n+    pub fn each(&self, f: &fn(&T) -> bool) -> bool {\n+        self.iter().advance(f)\n+    }\n+\n+    /// An iterator visiting all elements in arbitrary order.\n+    /// Iterator element type is &'a T.\n+    pub fn iter<'a>(&'a self) -> HashSetIterator<'a, T> {\n+        HashSetIterator { iter: self.map.buckets.iter() }\n+    }\n }\n \n #[cfg(test)]\n@@ -808,7 +873,7 @@ mod test_map {\n             assert!(m.insert(i, i*2));\n         }\n         let mut observed = 0;\n-        for m.each |k, v| {\n+        for m.iter().advance |(k, v)| {\n             assert_eq!(*v, *k * 2);\n             observed |= (1 << *k);\n         }\n@@ -885,6 +950,7 @@ mod test_set {\n     use super::*;\n     use container::{Container, Map, Set};\n     use vec;\n+    use uint;\n \n     #[test]\n     fn test_disjoint() {\n@@ -937,6 +1003,19 @@ mod test_set {\n         assert!(b.is_superset(&a));\n     }\n \n+    #[test]\n+    fn test_iterate() {\n+        let mut a = HashSet::new();\n+        for uint::range(0, 32) |i| {\n+            assert!(a.insert(i));\n+        }\n+        let mut observed = 0;\n+        for a.iter().advance |k| {\n+            observed |= (1 << *k);\n+        }\n+        assert_eq!(observed, 0xFFFF_FFFF);\n+    }\n+\n     #[test]\n     fn test_intersection() {\n         let mut a = HashSet::new();"}, {"sha": "56078a69f28f3e2d9193cfda6287d2d11130c023", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb58b19f023f95614e4a2bc3c812614d0938a9f2/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb58b19f023f95614e4a2bc3c812614d0938a9f2/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=cb58b19f023f95614e4a2bc3c812614d0938a9f2", "patch": "@@ -23,6 +23,7 @@ use hash::Hash;\n use cmp::Eq;\n use old_iter::BaseIter;\n use vec::ImmutableVector;\n+use iterator::IteratorUtil;\n \n /// A generic trait for converting a value to a string\n pub trait ToStr {\n@@ -56,7 +57,7 @@ impl<A:ToStr+Hash+Eq, B:ToStr+Hash+Eq> ToStr for HashMap<A, B> {\n     #[inline]\n     fn to_str(&self) -> ~str {\n         let mut (acc, first) = (~\"{\", true);\n-        for self.each |key, value| {\n+        for self.iter().advance |(key, value)| {\n             if first {\n                 first = false;\n             }\n@@ -76,7 +77,7 @@ impl<A:ToStr+Hash+Eq> ToStr for HashSet<A> {\n     #[inline]\n     fn to_str(&self) -> ~str {\n         let mut (acc, first) = (~\"{\", true);\n-        for self.each |element| {\n+        for self.iter().advance |element| {\n             if first {\n                 first = false;\n             }"}]}