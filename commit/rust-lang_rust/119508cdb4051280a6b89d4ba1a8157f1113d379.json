{"sha": "119508cdb4051280a6b89d4ba1a8157f1113d379", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExOTUwOGNkYjQwNTEyODBhNmI4OWQ0YmExYTgxNTdmMTExM2QzNzk=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-23T07:39:30Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-24T10:23:37Z"}, "message": "Remove drop flags from structs and enums implementing Drop.", "tree": {"sha": "eaa0cb8e2df53fad235592948a07f400b2b93a87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eaa0cb8e2df53fad235592948a07f400b2b93a87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/119508cdb4051280a6b89d4ba1a8157f1113d379", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/119508cdb4051280a6b89d4ba1a8157f1113d379", "html_url": "https://github.com/rust-lang/rust/commit/119508cdb4051280a6b89d4ba1a8157f1113d379", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/119508cdb4051280a6b89d4ba1a8157f1113d379/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0654ae5e53124273340624aa2e25f5a9aa9ecb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0654ae5e53124273340624aa2e25f5a9aa9ecb3", "html_url": "https://github.com/rust-lang/rust/commit/d0654ae5e53124273340624aa2e25f5a9aa9ecb3"}], "stats": {"total": 1238, "additions": 304, "deletions": 934}, "files": [{"sha": "9c9f1e7b9de07768d93c2c7c78809eed917796c0", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -121,7 +121,7 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// }\n /// ```\n \n-#[unsafe_no_drop_flag]\n+#[cfg_attr(stage0, unsafe_no_drop_flag)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Arc<T: ?Sized> {\n     ptr: Shared<ArcInner<T>>,\n@@ -147,7 +147,7 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n /// nodes behind strong `Arc<T>` pointers, and then storing the parent pointers\n /// as `Weak<T>` pointers.\n \n-#[unsafe_no_drop_flag]\n+#[cfg_attr(stage0, unsafe_no_drop_flag)]\n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n     ptr: Shared<ArcInner<T>>,\n@@ -559,15 +559,6 @@ impl<T: ?Sized> Drop for Arc<T> {\n     #[unsafe_destructor_blind_to_params]\n     #[inline]\n     fn drop(&mut self) {\n-        // This structure has #[unsafe_no_drop_flag], so this drop glue may run\n-        // more than once (but it is guaranteed to be zeroed after the first if\n-        // it's run more than once)\n-        let thin = *self.ptr as *const ();\n-\n-        if thin as usize == mem::POST_DROP_USIZE {\n-            return;\n-        }\n-\n         // Because `fetch_sub` is already atomic, we do not need to synchronize\n         // with other threads unless we are going to delete the object. This\n         // same logic applies to the below `fetch_sub` to the `weak` count.\n@@ -755,12 +746,6 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// ```\n     fn drop(&mut self) {\n         let ptr = *self.ptr;\n-        let thin = ptr as *const ();\n-\n-        // see comments above for why this check is here\n-        if thin as usize == mem::POST_DROP_USIZE {\n-            return;\n-        }\n \n         // If we find out that we were the last weak pointer, then its time to\n         // deallocate the data entirely. See the discussion in Arc::drop() about"}, {"sha": "d9fd2d92710dc5c75b873e4577a62c28b11c2755", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -88,7 +88,7 @@\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(unique)]\n-#![feature(unsafe_no_drop_flag, filling_drop)]\n+#![cfg_attr(stage0, feature(unsafe_no_drop_flag))]\n #![feature(unsize)]\n \n #![cfg_attr(not(test), feature(fused, raw, fn_traits, placement_new_protocol))]"}, {"sha": "23542215fa890a7f4ddffb236a6cc714bc4a7ca2", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -44,7 +44,7 @@ use core::cmp;\n /// `shrink_to_fit`, and `from_box` will actually set RawVec's private capacity\n /// field. This allows zero-sized types to not be special-cased by consumers of\n /// this type.\n-#[unsafe_no_drop_flag]\n+#[cfg_attr(stage0, unsafe_no_drop_flag)]\n pub struct RawVec<T> {\n     ptr: Unique<T>,\n     cap: usize,\n@@ -546,21 +546,14 @@ impl<T> RawVec<T> {\n         mem::forget(self);\n         output\n     }\n-\n-    /// This is a stupid name in the hopes that someone will find this in the\n-    /// not too distant future and remove it with the rest of\n-    /// #[unsafe_no_drop_flag]\n-    pub fn unsafe_no_drop_flag_needs_drop(&self) -> bool {\n-        self.cap != mem::POST_DROP_USIZE\n-    }\n }\n \n impl<T> Drop for RawVec<T> {\n     #[unsafe_destructor_blind_to_params]\n     /// Frees the memory owned by the RawVec *without* trying to Drop its contents.\n     fn drop(&mut self) {\n         let elem_size = mem::size_of::<T>();\n-        if elem_size != 0 && self.cap != 0 && self.unsafe_no_drop_flag_needs_drop() {\n+        if elem_size != 0 && self.cap != 0 {\n             let align = mem::align_of::<T>();\n \n             let num_bytes = elem_size * self.cap;"}, {"sha": "8e43e9eec16085c44f16282f35c3cce7d46749d4", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -182,7 +182,7 @@ struct RcBox<T: ?Sized> {\n /// A reference-counted pointer type over an immutable value.\n ///\n /// See the [module level documentation](./index.html) for more details.\n-#[unsafe_no_drop_flag]\n+#[cfg_attr(stage0, unsafe_no_drop_flag)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T: ?Sized> {\n     ptr: Shared<RcBox<T>>,\n@@ -466,21 +466,18 @@ impl<T: ?Sized> Drop for Rc<T> {\n     fn drop(&mut self) {\n         unsafe {\n             let ptr = *self.ptr;\n-            let thin = ptr as *const ();\n \n-            if thin as usize != mem::POST_DROP_USIZE {\n-                self.dec_strong();\n-                if self.strong() == 0 {\n-                    // destroy the contained object\n-                    ptr::drop_in_place(&mut (*ptr).value);\n+            self.dec_strong();\n+            if self.strong() == 0 {\n+                // destroy the contained object\n+                ptr::drop_in_place(&mut (*ptr).value);\n \n-                    // remove the implicit \"strong weak\" pointer now that we've\n-                    // destroyed the contents.\n-                    self.dec_weak();\n+                // remove the implicit \"strong weak\" pointer now that we've\n+                // destroyed the contents.\n+                self.dec_weak();\n \n-                    if self.weak() == 0 {\n-                        deallocate(ptr as *mut u8, size_of_val(&*ptr), align_of_val(&*ptr))\n-                    }\n+                if self.weak() == 0 {\n+                    deallocate(ptr as *mut u8, size_of_val(&*ptr), align_of_val(&*ptr))\n                 }\n             }\n         }\n@@ -724,7 +721,7 @@ impl<T> From<T> for Rc<T> {\n /// dropped.\n ///\n /// See the [module level documentation](./index.html) for more.\n-#[unsafe_no_drop_flag]\n+#[cfg_attr(stage0, unsafe_no_drop_flag)]\n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n     ptr: Shared<RcBox<T>>,\n@@ -825,15 +822,12 @@ impl<T: ?Sized> Drop for Weak<T> {\n     fn drop(&mut self) {\n         unsafe {\n             let ptr = *self.ptr;\n-            let thin = ptr as *const ();\n \n-            if thin as usize != mem::POST_DROP_USIZE {\n-                self.dec_weak();\n-                // the weak count starts at 1, and will only go to zero if all\n-                // the strong pointers have disappeared.\n-                if self.weak() == 0 {\n-                    deallocate(ptr as *mut u8, size_of_val(&*ptr), align_of_val(&*ptr))\n-                }\n+            self.dec_weak();\n+            // the weak count starts at 1, and will only go to zero if all\n+            // the strong pointers have disappeared.\n+            if self.weak() == 0 {\n+                deallocate(ptr as *mut u8, size_of_val(&*ptr), align_of_val(&*ptr))\n             }\n         }\n     }"}, {"sha": "c5a921693475a60e7ec1abfef9f78274ef742c11", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -52,7 +52,7 @@\n #![feature(step_by)]\n #![feature(unicode)]\n #![feature(unique)]\n-#![feature(unsafe_no_drop_flag)]\n+#![cfg_attr(stage0, feature(unsafe_no_drop_flag))]\n #![cfg_attr(test, feature(rand, test))]\n \n #![no_std]"}, {"sha": "876314613f523fa675cf4dee5dbb801cea160bb9", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -268,7 +268,7 @@ use super::range::RangeArgument;\n /// Vec does not currently guarantee the order in which elements are dropped\n /// (the order has changed in the past, and may change again).\n ///\n-#[unsafe_no_drop_flag]\n+#[cfg_attr(stage0, unsafe_no_drop_flag)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Vec<T> {\n     buf: RawVec<T>,\n@@ -1600,11 +1600,9 @@ impl<T: Ord> Ord for Vec<T> {\n impl<T> Drop for Vec<T> {\n     #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n-        if self.buf.unsafe_no_drop_flag_needs_drop() {\n-            unsafe {\n-                // use drop for [T]\n-                ptr::drop_in_place(&mut self[..]);\n-            }\n+        unsafe {\n+            // use drop for [T]\n+            ptr::drop_in_place(&mut self[..]);\n         }\n         // RawVec handles deallocation\n     }"}, {"sha": "3c2c5abcb2821ce7ccb81be4838e6a43facb869b", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -244,19 +244,6 @@ extern \"rust-intrinsic\" {\n     /// crate it is invoked in.\n     pub fn type_id<T: ?Sized + 'static>() -> u64;\n \n-    /// Creates a value initialized to so that its drop flag,\n-    /// if any, says that it has been dropped.\n-    ///\n-    /// `init_dropped` is unsafe because it returns a datum with all\n-    /// of its bytes set to the drop flag, which generally does not\n-    /// correspond to a valid value.\n-    ///\n-    /// This intrinsic is likely to be deprecated in the future when\n-    /// Rust moves to non-zeroing dynamic drop (and thus removes the\n-    /// embedded drop flags that are being established by this\n-    /// intrinsic).\n-    pub fn init_dropped<T>() -> T;\n-\n     /// Creates a value initialized to zero.\n     ///\n     /// `init` is unsafe because it returns a zeroed-out datum,"}, {"sha": "6ebbe97d064a2c23521f247dc4e4e31bdea0af52", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -241,27 +241,6 @@ pub unsafe fn zeroed<T>() -> T {\n     intrinsics::init()\n }\n \n-/// Creates a value initialized to an unspecified series of bytes.\n-///\n-/// The byte sequence usually indicates that the value at the memory\n-/// in question has been dropped. Thus, *if* T carries a drop flag,\n-/// any associated destructor will not be run when the value falls out\n-/// of scope.\n-///\n-/// Some code at one time used the `zeroed` function above to\n-/// accomplish this goal.\n-///\n-/// This function is expected to be deprecated with the transition\n-/// to non-zeroing drop.\n-#[inline]\n-#[unstable(feature = \"filling_drop\", issue = \"5016\")]\n-pub unsafe fn dropped<T>() -> T {\n-    #[inline(always)]\n-    unsafe fn dropped_impl<T>() -> T { intrinsics::init_dropped() }\n-\n-    dropped_impl()\n-}\n-\n /// Bypasses Rust's normal memory-initialization checks by pretending to\n /// produce a value of type T, while doing nothing at all.\n ///\n@@ -518,56 +497,6 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn drop<T>(_x: T) { }\n \n-macro_rules! repeat_u8_as_u16 {\n-    ($name:expr) => { (($name as u16) <<  8 |\n-                       ($name as u16)) }\n-}\n-macro_rules! repeat_u8_as_u32 {\n-    ($name:expr) => { (($name as u32) << 24 |\n-                       ($name as u32) << 16 |\n-                       ($name as u32) <<  8 |\n-                       ($name as u32)) }\n-}\n-macro_rules! repeat_u8_as_u64 {\n-    ($name:expr) => { ((repeat_u8_as_u32!($name) as u64) << 32 |\n-                       (repeat_u8_as_u32!($name) as u64)) }\n-}\n-\n-// NOTE: Keep synchronized with values used in librustc_trans::trans::adt.\n-//\n-// In particular, the POST_DROP_U8 marker must never equal the\n-// DTOR_NEEDED_U8 marker.\n-//\n-// For a while pnkfelix was using 0xc1 here.\n-// But having the sign bit set is a pain, so 0x1d is probably better.\n-//\n-// And of course, 0x00 brings back the old world of zero'ing on drop.\n-#[unstable(feature = \"filling_drop\", issue = \"5016\")]\n-#[allow(missing_docs)]\n-pub const POST_DROP_U8: u8 = 0x1d;\n-#[unstable(feature = \"filling_drop\", issue = \"5016\")]\n-#[allow(missing_docs)]\n-pub const POST_DROP_U16: u16 = repeat_u8_as_u16!(POST_DROP_U8);\n-#[unstable(feature = \"filling_drop\", issue = \"5016\")]\n-#[allow(missing_docs)]\n-pub const POST_DROP_U32: u32 = repeat_u8_as_u32!(POST_DROP_U8);\n-#[unstable(feature = \"filling_drop\", issue = \"5016\")]\n-#[allow(missing_docs)]\n-pub const POST_DROP_U64: u64 = repeat_u8_as_u64!(POST_DROP_U8);\n-\n-#[cfg(target_pointer_width = \"16\")]\n-#[unstable(feature = \"filling_drop\", issue = \"5016\")]\n-#[allow(missing_docs)]\n-pub const POST_DROP_USIZE: usize = POST_DROP_U16 as usize;\n-#[cfg(target_pointer_width = \"32\")]\n-#[unstable(feature = \"filling_drop\", issue = \"5016\")]\n-#[allow(missing_docs)]\n-pub const POST_DROP_USIZE: usize = POST_DROP_U32 as usize;\n-#[cfg(target_pointer_width = \"64\")]\n-#[unstable(feature = \"filling_drop\", issue = \"5016\")]\n-#[allow(missing_docs)]\n-pub const POST_DROP_USIZE: usize = POST_DROP_U64 as usize;\n-\n /// Interprets `src` as `&U`, and then reads `src` without moving the contained\n /// value.\n ///"}, {"sha": "dd76843793332f407514e850087cffde7494a039", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -140,21 +140,6 @@ pub unsafe fn read<T>(src: *const T) -> T {\n     tmp\n }\n \n-#[allow(missing_docs)]\n-#[inline(always)]\n-#[unstable(feature = \"filling_drop\",\n-           reason = \"may play a larger role in std::ptr future extensions\",\n-           issue = \"5016\")]\n-pub unsafe fn read_and_drop<T>(dest: *mut T) -> T {\n-    // Copy the data out from `dest`:\n-    let tmp = read(&*dest);\n-\n-    // Now mark `dest` as dropped:\n-    write_bytes(dest, mem::POST_DROP_U8, 1);\n-\n-    tmp\n-}\n-\n /// Overwrites a memory location with the given value without reading or\n /// dropping the old value.\n ///"}, {"sha": "a991a1a9ba4b53a36b9be93d06a2f95e214e7b37", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -889,8 +889,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"adds unstable command line options to rustc interface\"),\n     force_overflow_checks: Option<bool> = (None, parse_opt_bool, [TRACKED],\n           \"force overflow checks on or off\"),\n-    force_dropflag_checks: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-          \"force drop flag checks on or off\"),\n     trace_macros: bool = (false, parse_bool, [UNTRACKED],\n           \"for every macro invocation, print its name and arguments\"),\n     enable_nonzeroing_move_hints: bool = (false, parse_bool, [TRACKED],\n@@ -2427,10 +2425,6 @@ mod tests {\n         opts.debugging_opts.force_overflow_checks = Some(true);\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n \n-        opts = reference.clone();\n-        opts.debugging_opts.force_dropflag_checks = Some(true);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n         opts = reference.clone();\n         opts.debugging_opts.enable_nonzeroing_move_hints = true;\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());"}, {"sha": "1ede8545e08e873a5ffa95dd9c236f097e67d8ba", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 8, "deletions": 31, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -891,17 +891,6 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 let mut st = Struct::new(dl, packed);\n                 st.extend(dl, fields, ty)?;\n \n-                // FIXME(16758) don't add a drop flag to unsized structs, as it\n-                // won't actually be in the location we say it is because it'll be after\n-                // the unsized field. Several other pieces of code assume that the unsized\n-                // field is definitely the last one.\n-                if def.dtor_kind().has_drop_flag() &&\n-                   ty.is_sized(tcx, &infcx.parameter_environment, DUMMY_SP) {\n-                    st.extend(dl, Some(Ok(&Scalar {\n-                        value: Int(I8),\n-                        non_zero: false\n-                    })).into_iter(), ty)?;\n-                }\n                 Univariant {\n                     variant: st,\n                     non_zero: Some(def.did) == tcx.lang_items.non_zero()\n@@ -911,24 +900,18 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 let hint = *tcx.lookup_repr_hints(def.did).get(0)\n                     .unwrap_or(&attr::ReprAny);\n \n-                let dtor = def.dtor_kind().has_drop_flag();\n-                let drop_flag = if dtor {\n-                    Some(Scalar { value: Int(I8), non_zero: false })\n-                } else {\n-                    None\n-                };\n-\n                 if def.variants.is_empty() {\n                     // Uninhabitable; represent as unit\n                     // (Typechecking will reject discriminant-sizing attrs.)\n                     assert_eq!(hint, attr::ReprAny);\n \n-                    let mut st = Struct::new(dl, false);\n-                    st.extend(dl, drop_flag.iter().map(Ok), ty)?;\n-                    return success(Univariant { variant: st, non_zero: false });\n+                    return success(Univariant {\n+                        variant: Struct::new(dl, false),\n+                        non_zero: false\n+                    });\n                 }\n \n-                if !dtor && def.variants.iter().all(|v| v.fields.is_empty()) {\n+                if def.variants.iter().all(|v| v.fields.is_empty()) {\n                     // All bodies empty -> intlike\n                     let (mut min, mut max) = (i64::MAX, i64::MIN);\n                     for v in &def.variants {\n@@ -964,7 +947,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         field.ty(tcx, substs).layout(infcx)\n                     });\n                     let mut st = Struct::new(dl, false);\n-                    st.extend(dl, fields.chain(drop_flag.iter().map(Ok)), ty)?;\n+                    st.extend(dl, fields, ty)?;\n                     return success(Univariant { variant: st, non_zero: false });\n                 }\n \n@@ -973,7 +956,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     v.fields.iter().map(|field| field.ty(tcx, substs)).collect::<Vec<_>>()\n                 }).collect::<Vec<_>>();\n \n-                if !dtor && variants.len() == 2 && hint == attr::ReprAny {\n+                if variants.len() == 2 && hint == attr::ReprAny {\n                     // Nullable pointer optimization\n                     for discr in 0..2 {\n                         let other_fields = variants[1 - discr].iter().map(|ty| {\n@@ -1045,8 +1028,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         Ok(field)\n                     });\n                     let mut st = Struct::new(dl, false);\n-                    st.extend(dl, discr.iter().map(Ok).chain(fields)\n-                                              .chain(drop_flag.iter().map(Ok)), ty)?;\n+                    st.extend(dl, discr.iter().map(Ok).chain(fields), ty)?;\n                     size = cmp::max(size, st.min_size());\n                     align = align.max(st.align);\n                     Ok(st)\n@@ -1277,11 +1259,6 @@ impl<'a, 'gcx, 'tcx> SizeSkeleton<'gcx> {\n                     return Err(err);\n                 }\n \n-                // If there's a drop flag, it can't be just a pointer.\n-                if def.dtor_kind().has_drop_flag() {\n-                    return Err(err);\n-                }\n-\n                 // Get a zero-sized variant or a pointer newtype.\n                 let zero_or_ptr_variant = |i: usize| {\n                     let fields = def.variants[i].fields.iter().map(|field| {"}, {"sha": "6c82157c8ca7c900039325e6e015a378e48cd16c", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -122,23 +122,16 @@ pub struct CrateAnalysis<'a> {\n #[derive(Copy, Clone)]\n pub enum DtorKind {\n     NoDtor,\n-    TraitDtor(bool)\n+    TraitDtor\n }\n \n impl DtorKind {\n     pub fn is_present(&self) -> bool {\n         match *self {\n-            TraitDtor(..) => true,\n+            TraitDtor => true,\n             _ => false\n         }\n     }\n-\n-    pub fn has_drop_flag(&self) -> bool {\n-        match self {\n-            &NoDtor => false,\n-            &TraitDtor(flag) => flag\n-        }\n-    }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n@@ -1440,7 +1433,6 @@ bitflags! {\n         const IS_PHANTOM_DATA     = 1 << 3,\n         const IS_SIMD             = 1 << 4,\n         const IS_FUNDAMENTAL      = 1 << 5,\n-        const IS_NO_DROP_FLAG     = 1 << 6,\n     }\n }\n \n@@ -1558,9 +1550,6 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n         if attr::contains_name(&attrs, \"fundamental\") {\n             flags = flags | AdtFlags::IS_FUNDAMENTAL;\n         }\n-        if attr::contains_name(&attrs, \"unsafe_no_drop_flag\") {\n-            flags = flags | AdtFlags::IS_NO_DROP_FLAG;\n-        }\n         if tcx.lookup_simd(did) {\n             flags = flags | AdtFlags::IS_SIMD;\n         }\n@@ -1627,10 +1616,7 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n \n     /// Returns whether this type has a destructor.\n     pub fn has_dtor(&self) -> bool {\n-        match self.dtor_kind() {\n-            NoDtor => false,\n-            TraitDtor(..) => true\n-        }\n+        self.dtor_kind().is_present()\n     }\n \n     /// Asserts this is a struct and returns the struct's unique\n@@ -1710,9 +1696,7 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n \n     pub fn dtor_kind(&self) -> DtorKind {\n         match self.destructor.get() {\n-            Some(_) => {\n-                TraitDtor(!self.flags.get().intersects(AdtFlags::IS_NO_DROP_FLAG))\n-            }\n+            Some(_) => TraitDtor,\n             None => NoDtor,\n         }\n     }"}, {"sha": "b4a2648b5dca7022c756bedbde457dc51d55e5cd", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 54, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -45,7 +45,7 @@ use std::collections::HashSet;\n \n use syntax::{ast};\n use syntax::attr::{self, AttrMetaMethods, AttributeMethods};\n-use syntax_pos::{self, Span};\n+use syntax_pos::Span;\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::intravisit::FnKind;\n@@ -1154,56 +1154,3 @@ impl LateLintPass for UnstableFeatures {\n         }\n     }\n }\n-\n-/// Lints for attempts to impl Drop on types that have `#[repr(C)]`\n-/// attribute (see issue #24585).\n-#[derive(Copy, Clone)]\n-pub struct DropWithReprExtern;\n-\n-declare_lint! {\n-    DROP_WITH_REPR_EXTERN,\n-    Warn,\n-    \"use of #[repr(C)] on a type that implements Drop\"\n-}\n-\n-impl LintPass for DropWithReprExtern {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(DROP_WITH_REPR_EXTERN)\n-    }\n-}\n-\n-impl LateLintPass for DropWithReprExtern {\n-    fn check_crate(&mut self, ctx: &LateContext, _: &hir::Crate) {\n-        let drop_trait = match ctx.tcx.lang_items.drop_trait() {\n-            Some(id) => ctx.tcx.lookup_trait_def(id), None => { return }\n-        };\n-        drop_trait.for_each_impl(ctx.tcx, |drop_impl_did| {\n-            if !drop_impl_did.is_local() {\n-                return;\n-            }\n-            let dtor_self_type = ctx.tcx.lookup_item_type(drop_impl_did).ty;\n-\n-            match dtor_self_type.sty {\n-                ty::TyEnum(self_type_def, _) |\n-                ty::TyStruct(self_type_def, _) => {\n-                    let self_type_did = self_type_def.did;\n-                    let hints = ctx.tcx.lookup_repr_hints(self_type_did);\n-                    if hints.iter().any(|attr| *attr == attr::ReprExtern) &&\n-                        self_type_def.dtor_kind().has_drop_flag() {\n-                        let drop_impl_span = ctx.tcx.map.def_id_span(drop_impl_did,\n-                                                                     syntax_pos::DUMMY_SP);\n-                        let self_defn_span = ctx.tcx.map.def_id_span(self_type_did,\n-                                                                     syntax_pos::DUMMY_SP);\n-                        ctx.span_lint_note(DROP_WITH_REPR_EXTERN,\n-                                           drop_impl_span,\n-                                           \"implementing Drop adds hidden state to types, \\\n-                                            possibly conflicting with `#[repr(C)]`\",\n-                                            self_defn_span,\n-                                            \"the `#[repr(C)]` attribute is attached here\");\n-                    }\n-                }\n-                _ => {}\n-            }\n-        })\n-    }\n-}"}, {"sha": "1a4330f58c3cd7012d4c91c700f61dd5a238e84e", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -127,7 +127,6 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                  UnconditionalRecursion,\n                  InvalidNoMangleItems,\n                  PluginAsLibrary,\n-                 DropWithReprExtern,\n                  MutableTransmutes,\n                  );\n \n@@ -218,4 +217,5 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n     // This was renamed to raw_pointer_derive, which was then removed,\n     // so it is also considered removed\n     store.register_removed(\"raw_pointer_deriving\", \"using derive with raw pointers is ok\");\n+    store.register_removed(\"drop_with_repr_extern\", \"drop flags have been removed\");\n }"}, {"sha": "2fb7a69d36186a45e45646112300e6cd690e1a88", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 42, "deletions": 125, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -72,48 +72,16 @@ pub enum BranchKind {\n \n type Hint = attr::ReprAttr;\n \n-// Representation of the context surrounding an unsized type. I want\n-// to be able to track the drop flags that are injected by trans.\n-#[derive(Clone, Copy, PartialEq, Debug)]\n-pub struct TypeContext {\n-    prefix: Type,\n-    needs_drop_flag: bool,\n-}\n-\n-impl TypeContext {\n-    pub fn prefix(&self) -> Type { self.prefix }\n-    pub fn needs_drop_flag(&self) -> bool { self.needs_drop_flag }\n-\n-    fn direct(t: Type) -> TypeContext {\n-        TypeContext { prefix: t, needs_drop_flag: false }\n-    }\n-    fn may_need_drop_flag(t: Type, needs_drop_flag: bool) -> TypeContext {\n-        TypeContext { prefix: t, needs_drop_flag: needs_drop_flag }\n-    }\n-}\n-\n /// Representations.\n #[derive(Eq, PartialEq, Debug)]\n pub enum Repr<'tcx> {\n     /// C-like enums; basically an int.\n     CEnum(IntType, Disr, Disr), // discriminant range (signedness based on the IntType)\n     /// Single-case variants, and structs/tuples/records.\n-    ///\n-    /// Structs with destructors need a dynamic destroyedness flag to\n-    /// avoid running the destructor too many times; this is included\n-    /// in the `Struct` if present.\n-    /// (The flag if nonzero, represents the initialization value to use;\n-    ///  if zero, then use no flag at all.)\n-    Univariant(Struct<'tcx>, u8),\n+    Univariant(Struct<'tcx>),\n     /// General-case enums: for each case there is a struct, and they\n     /// all start with a field for the discriminant.\n-    ///\n-    /// Types with destructors need a dynamic destroyedness flag to\n-    /// avoid running the destructor too many times; the last argument\n-    /// indicates whether such a flag is present.\n-    /// (The flag, if nonzero, represents the initialization value to use;\n-    ///  if zero, then use no flag at all.)\n-    General(IntType, Vec<Struct<'tcx>>, u8),\n+    General(IntType, Vec<Struct<'tcx>>),\n     /// Two cases distinguished by a nullable pointer: the case with discriminant\n     /// `nndiscr` must have single field which is known to be nonnull due to its type.\n     /// The other case is known to be zero sized. Hence we represent the enum\n@@ -194,57 +162,36 @@ pub fn represent_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     repr\n }\n \n-fn dtor_to_init_u8(dtor: bool) -> u8 {\n-    if dtor { 1 } else { 0 }\n-}\n-\n-pub trait GetDtorType<'tcx> { fn dtor_type(self) -> Ty<'tcx>; }\n-impl<'a, 'tcx> GetDtorType<'tcx> for TyCtxt<'a, 'tcx, 'tcx> {\n-    fn dtor_type(self) -> Ty<'tcx> { self.types.u8 }\n-}\n-\n fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                      t: Ty<'tcx>) -> Repr<'tcx> {\n     match t.sty {\n         ty::TyTuple(ref elems) => {\n-            Univariant(mk_struct(cx, &elems[..], false, t), 0)\n+            Univariant(mk_struct(cx, &elems[..], false, t))\n         }\n         ty::TyStruct(def, substs) => {\n-            let mut ftys = def.struct_variant().fields.iter().map(|field| {\n+            let ftys = def.struct_variant().fields.iter().map(|field| {\n                 monomorphize::field_ty(cx.tcx(), substs, field)\n             }).collect::<Vec<_>>();\n             let packed = cx.tcx().lookup_packed(def.did);\n-            // FIXME(16758) don't add a drop flag to unsized structs, as it\n-            // won't actually be in the location we say it is because it'll be after\n-            // the unsized field. Several other pieces of code assume that the unsized\n-            // field is definitely the last one.\n-            let dtor = def.dtor_kind().has_drop_flag() && type_is_sized(cx.tcx(), t);\n-            if dtor {\n-                ftys.push(cx.tcx().dtor_type());\n-            }\n \n-            Univariant(mk_struct(cx, &ftys[..], packed, t), dtor_to_init_u8(dtor))\n+            Univariant(mk_struct(cx, &ftys[..], packed, t))\n         }\n         ty::TyClosure(_, ref substs) => {\n-            Univariant(mk_struct(cx, &substs.upvar_tys, false, t), 0)\n+            Univariant(mk_struct(cx, &substs.upvar_tys, false, t))\n         }\n         ty::TyEnum(def, substs) => {\n             let cases = get_cases(cx.tcx(), def, substs);\n             let hint = *cx.tcx().lookup_repr_hints(def.did).get(0)\n                 .unwrap_or(&attr::ReprAny);\n \n-            let dtor = def.dtor_kind().has_drop_flag();\n-\n             if cases.is_empty() {\n                 // Uninhabitable; represent as unit\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n-                let ftys = if dtor { vec!(cx.tcx().dtor_type()) } else { vec!() };\n-                return Univariant(mk_struct(cx, &ftys[..], false, t),\n-                                  dtor_to_init_u8(dtor));\n+                return Univariant(mk_struct(cx, &[], false, t));\n             }\n \n-            if !dtor && cases.iter().all(|c| c.tys.is_empty()) {\n+            if cases.iter().all(|c| c.tys.is_empty()) {\n                 // All bodies empty -> intlike\n                 let discrs: Vec<_> = cases.iter().map(|c| Disr::from(c.discr)).collect();\n                 let bounds = IntBounds {\n@@ -266,13 +213,10 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             if cases.len() == 1 && hint == attr::ReprAny {\n                 // Equivalent to a struct/tuple/newtype.\n-                let mut ftys = cases[0].tys.clone();\n-                if dtor { ftys.push(cx.tcx().dtor_type()); }\n-                return Univariant(mk_struct(cx, &ftys[..], false, t),\n-                                  dtor_to_init_u8(dtor));\n+                return Univariant(mk_struct(cx, &cases[0].tys, false, t));\n             }\n \n-            if !dtor && cases.len() == 2 && hint == attr::ReprAny {\n+            if cases.len() == 2 && hint == attr::ReprAny {\n                 // Nullable pointer optimization\n                 let mut discr = 0;\n                 while discr < 2 {\n@@ -315,7 +259,6 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let fields : Vec<_> = cases.iter().map(|c| {\n                 let mut ftys = vec!(ty_of_inttype(cx.tcx(), min_ity));\n                 ftys.extend_from_slice(&c.tys);\n-                if dtor { ftys.push(cx.tcx().dtor_type()); }\n                 mk_struct(cx, &ftys, false, t)\n             }).collect();\n \n@@ -377,13 +320,12 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let fields : Vec<_> = cases.iter().map(|c| {\n                 let mut ftys = vec!(ty_of_inttype(cx.tcx(), ity));\n                 ftys.extend_from_slice(&c.tys);\n-                if dtor { ftys.push(cx.tcx().dtor_type()); }\n                 mk_struct(cx, &ftys[..], false, t)\n             }).collect();\n \n             ensure_enum_fits_in_address_space(cx, &fields[..], t);\n \n-            General(ity, fields, dtor_to_init_u8(dtor))\n+            General(ity, fields)\n         }\n         _ => bug!(\"adt::represent_type called on non-ADT type: {}\", t)\n     }\n@@ -681,9 +623,7 @@ fn ensure_enum_fits_in_address_space<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n /// and fill in the actual contents in a second pass to prevent\n /// unbounded recursion; see also the comments in `trans::type_of`.\n pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>) -> Type {\n-    let c = generic_type_of(cx, r, None, false, false, false);\n-    assert!(!c.needs_drop_flag);\n-    c.prefix\n+    generic_type_of(cx, r, None, false, false)\n }\n \n \n@@ -692,25 +632,19 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>) -> Type {\n // are going to get the wrong type (it will not include the unsized parts of it).\n pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                 r: &Repr<'tcx>, dst: bool) -> Type {\n-    let c = generic_type_of(cx, r, None, true, dst, false);\n-    assert!(!c.needs_drop_flag);\n-    c.prefix\n-}\n-pub fn sizing_type_context_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                        r: &Repr<'tcx>, dst: bool) -> TypeContext {\n-    generic_type_of(cx, r, None, true, dst, true)\n+    generic_type_of(cx, r, None, true, dst)\n }\n+\n pub fn incomplete_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                     r: &Repr<'tcx>, name: &str) -> Type {\n-    let c = generic_type_of(cx, r, Some(name), false, false, false);\n-    assert!(!c.needs_drop_flag);\n-    c.prefix\n+    generic_type_of(cx, r, Some(name), false, false)\n }\n+\n pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                 r: &Repr<'tcx>, llty: &mut Type) {\n     match *r {\n         CEnum(..) | General(..) | RawNullablePointer { .. } => { }\n-        Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } =>\n+        Univariant(ref st) | StructWrappedNullablePointer { nonnull: ref st, .. } =>\n             llty.set_struct_body(&struct_llfields(cx, st, false, false),\n                                  st.packed)\n     }\n@@ -720,50 +654,40 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                              r: &Repr<'tcx>,\n                              name: Option<&str>,\n                              sizing: bool,\n-                             dst: bool,\n-                             delay_drop_flag: bool) -> TypeContext {\n-    debug!(\"adt::generic_type_of r: {:?} name: {:?} sizing: {} dst: {} delay_drop_flag: {}\",\n-           r, name, sizing, dst, delay_drop_flag);\n+                             dst: bool) -> Type {\n+    debug!(\"adt::generic_type_of r: {:?} name: {:?} sizing: {} dst: {}\",\n+           r, name, sizing, dst);\n     match *r {\n-        CEnum(ity, _, _) => TypeContext::direct(ll_inttype(cx, ity)),\n+        CEnum(ity, _, _) => ll_inttype(cx, ity),\n         RawNullablePointer { nnty, .. } =>\n-            TypeContext::direct(type_of::sizing_type_of(cx, nnty)),\n+            type_of::sizing_type_of(cx, nnty),\n         StructWrappedNullablePointer { nonnull: ref st, .. } => {\n             match name {\n                 None => {\n-                    TypeContext::direct(\n-                        Type::struct_(cx, &struct_llfields(cx, st, sizing, dst),\n-                                      st.packed))\n+                    Type::struct_(cx, &struct_llfields(cx, st, sizing, dst),\n+                                  st.packed)\n                 }\n                 Some(name) => {\n                     assert_eq!(sizing, false);\n-                    TypeContext::direct(Type::named_struct(cx, name))\n+                    Type::named_struct(cx, name)\n                 }\n             }\n         }\n-        Univariant(ref st, dtor_needed) => {\n-            let dtor_needed = dtor_needed != 0;\n+        Univariant(ref st) => {\n             match name {\n                 None => {\n-                    let mut fields = struct_llfields(cx, st, sizing, dst);\n-                    if delay_drop_flag && dtor_needed {\n-                        fields.pop();\n-                    }\n-                    TypeContext::may_need_drop_flag(\n-                        Type::struct_(cx, &fields,\n-                                      st.packed),\n-                        delay_drop_flag && dtor_needed)\n+                    let fields = struct_llfields(cx, st, sizing, dst);\n+                    Type::struct_(cx, &fields, st.packed)\n                 }\n                 Some(name) => {\n                     // Hypothesis: named_struct's can never need a\n                     // drop flag. (... needs validation.)\n                     assert_eq!(sizing, false);\n-                    TypeContext::direct(Type::named_struct(cx, name))\n+                    Type::named_struct(cx, name)\n                 }\n             }\n         }\n-        General(ity, ref sts, dtor_needed) => {\n-            let dtor_needed = dtor_needed != 0;\n+        General(ity, ref sts) => {\n             // We need a representation that has:\n             // * The alignment of the most-aligned field\n             // * The size of the largest variant (rounded up to that alignment)\n@@ -795,25 +719,18 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             };\n             assert_eq!(machine::llalign_of_min(cx, fill_ty), align);\n             assert_eq!(padded_discr_size % discr_size, 0); // Ensure discr_ty can fill pad evenly\n-            let mut fields: Vec<Type> =\n+            let fields: Vec<Type> =\n                 [discr_ty,\n                  Type::array(&discr_ty, (padded_discr_size - discr_size)/discr_size),\n                  fill_ty].iter().cloned().collect();\n-            if delay_drop_flag && dtor_needed {\n-                fields.pop();\n-            }\n             match name {\n                 None => {\n-                    TypeContext::may_need_drop_flag(\n-                        Type::struct_(cx, &fields[..], false),\n-                        delay_drop_flag && dtor_needed)\n+                    Type::struct_(cx, &fields[..], false)\n                 }\n                 Some(name) => {\n                     let mut llty = Type::named_struct(cx, name);\n                     llty.set_struct_body(&fields[..], false);\n-                    TypeContext::may_need_drop_flag(\n-                        llty,\n-                        delay_drop_flag && dtor_needed)\n+                    llty\n                 }\n             }\n         }\n@@ -852,7 +769,7 @@ pub fn trans_switch<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn is_discr_signed<'tcx>(r: &Repr<'tcx>) -> bool {\n     match *r {\n         CEnum(ity, _, _) => ity.is_signed(),\n-        General(ity, _, _) => ity.is_signed(),\n+        General(ity, _) => ity.is_signed(),\n         Univariant(..) => false,\n         RawNullablePointer { .. } => false,\n         StructWrappedNullablePointer { .. } => false,\n@@ -869,7 +786,7 @@ pub fn trans_get_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n         CEnum(ity, min, max) => {\n             load_discr(bcx, ity, scrutinee, min, max, range_assert)\n         }\n-        General(ity, ref cases, _) => {\n+        General(ity, ref cases) => {\n             let ptr = StructGEP(bcx, scrutinee, 0);\n             load_discr(bcx, ity, ptr, Disr(0), Disr(cases.len() as u64 - 1),\n                        range_assert)\n@@ -933,7 +850,7 @@ pub fn trans_case<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr, discr: Disr)\n         CEnum(ity, _, _) => {\n             C_integral(ll_inttype(bcx.ccx(), ity), discr.0, true)\n         }\n-        General(ity, _, _) => {\n+        General(ity, _) => {\n             C_integral(ll_inttype(bcx.ccx(), ity), discr.0, true)\n         }\n         Univariant(..) => {\n@@ -957,11 +874,11 @@ pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n             Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr.0, true),\n                   val);\n         }\n-        General(ity, _, _) => {\n+        General(ity, _) => {\n             Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr.0, true),\n                   StructGEP(bcx, val, 0));\n         }\n-        Univariant(_, _) => {\n+        Univariant(_) => {\n             assert_eq!(discr, Disr(0));\n         }\n         RawNullablePointer { nndiscr, nnty, ..} => {\n@@ -1012,11 +929,11 @@ pub fn trans_field_ptr_builder<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n         CEnum(..) => {\n             bug!(\"element access in C-like enum\")\n         }\n-        Univariant(ref st, _dtor) => {\n+        Univariant(ref st) => {\n             assert_eq!(discr, Disr(0));\n             struct_field_ptr(bcx, st, val, ix, false)\n         }\n-        General(_, ref cases, _) => {\n+        General(_, ref cases) => {\n             struct_field_ptr(bcx, &cases[discr.0 as usize], val, ix + 1, true)\n         }\n         RawNullablePointer { nndiscr, ref nullfields, .. } |\n@@ -1170,7 +1087,7 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n             assert_discr_in_range(ity, min, max, discr);\n             C_integral(ll_inttype(ccx, ity), discr.0, true)\n         }\n-        General(ity, ref cases, _) => {\n+        General(ity, ref cases) => {\n             let case = &cases[discr.0 as usize];\n             let (max_sz, _) = union_size_and_align(&cases[..]);\n             let lldiscr = C_integral(ll_inttype(ccx, ity), discr.0 as u64, true);\n@@ -1180,7 +1097,7 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n             contents.extend_from_slice(&[padding(ccx, max_sz - case.size)]);\n             C_struct(ccx, &contents[..], false)\n         }\n-        Univariant(ref st, _dro) => {\n+        Univariant(ref st) => {\n             assert_eq!(discr, Disr(0));\n             let contents = build_const_struct(ccx, st, vals);\n             C_struct(ccx, &contents[..], st.packed)"}, {"sha": "e33c04f7e82ed577f54b0cb19af8695b5ecf3595", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 4, "deletions": 154, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -57,8 +57,8 @@ use callee::{Callee};\n use common::{Block, C_bool, C_bytes_in_context, C_i32, C_uint};\n use collector::{self, TransItemCollectionMode};\n use common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n-use common::{CrateContext, Field, FunctionContext};\n-use common::{Result, VariantInfo};\n+use common::{CrateContext, FunctionContext};\n+use common::{Result};\n use common::{fulfill_obligation};\n use common::{type_is_zero_size, val_ty};\n use common;\n@@ -76,7 +76,6 @@ use partitioning::{self, PartitioningStrategy, CodegenUnit};\n use symbol_map::SymbolMap;\n use symbol_names_test;\n use trans_item::TransItem;\n-use tvec;\n use type_::Type;\n use type_of;\n use value::Value;\n@@ -386,155 +385,6 @@ pub fn compare_simd_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     SExt(bcx, ICmp(bcx, cmp, lhs, rhs, debug_loc), ret_ty)\n }\n \n-// Iterates through the elements of a structural type.\n-pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n-                                         av: ValueRef,\n-                                         t: Ty<'tcx>,\n-                                         mut f: F)\n-                                         -> Block<'blk, 'tcx>\n-    where F: FnMut(Block<'blk, 'tcx>, ValueRef, Ty<'tcx>) -> Block<'blk, 'tcx>\n-{\n-    let _icx = push_ctxt(\"iter_structural_ty\");\n-\n-    fn iter_variant<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n-                                   repr: &adt::Repr<'tcx>,\n-                                   av: adt::MaybeSizedValue,\n-                                   variant: ty::VariantDef<'tcx>,\n-                                   substs: &Substs<'tcx>,\n-                                   f: &mut F)\n-                                   -> Block<'blk, 'tcx>\n-        where F: FnMut(Block<'blk, 'tcx>, ValueRef, Ty<'tcx>) -> Block<'blk, 'tcx>\n-    {\n-        let _icx = push_ctxt(\"iter_variant\");\n-        let tcx = cx.tcx();\n-        let mut cx = cx;\n-\n-        for (i, field) in variant.fields.iter().enumerate() {\n-            let arg = monomorphize::field_ty(tcx, substs, field);\n-            cx = f(cx,\n-                   adt::trans_field_ptr(cx, repr, av, Disr::from(variant.disr_val), i),\n-                   arg);\n-        }\n-        return cx;\n-    }\n-\n-    let value = if common::type_is_sized(cx.tcx(), t) {\n-        adt::MaybeSizedValue::sized(av)\n-    } else {\n-        let data = Load(cx, get_dataptr(cx, av));\n-        let info = Load(cx, get_meta(cx, av));\n-        adt::MaybeSizedValue::unsized_(data, info)\n-    };\n-\n-    let mut cx = cx;\n-    match t.sty {\n-        ty::TyStruct(..) => {\n-            let repr = adt::represent_type(cx.ccx(), t);\n-            let VariantInfo { fields, discr } = VariantInfo::from_ty(cx.tcx(), t, None);\n-            for (i, &Field(_, field_ty)) in fields.iter().enumerate() {\n-                let llfld_a = adt::trans_field_ptr(cx, &repr, value, Disr::from(discr), i);\n-\n-                let val = if common::type_is_sized(cx.tcx(), field_ty) {\n-                    llfld_a\n-                } else {\n-                    let scratch = alloc_ty(cx, field_ty, \"__fat_ptr_iter\");\n-                    Store(cx, llfld_a, get_dataptr(cx, scratch));\n-                    Store(cx, value.meta, get_meta(cx, scratch));\n-                    scratch\n-                };\n-                cx = f(cx, val, field_ty);\n-            }\n-        }\n-        ty::TyClosure(_, ref substs) => {\n-            let repr = adt::represent_type(cx.ccx(), t);\n-            for (i, upvar_ty) in substs.upvar_tys.iter().enumerate() {\n-                let llupvar = adt::trans_field_ptr(cx, &repr, value, Disr(0), i);\n-                cx = f(cx, llupvar, upvar_ty);\n-            }\n-        }\n-        ty::TyArray(_, n) => {\n-            let base = get_dataptr(cx, value.value);\n-            let len = C_uint(cx.ccx(), n);\n-            let unit_ty = t.sequence_element_type(cx.tcx());\n-            cx = tvec::iter_vec_raw(cx, base, unit_ty, len, f);\n-        }\n-        ty::TySlice(_) | ty::TyStr => {\n-            let unit_ty = t.sequence_element_type(cx.tcx());\n-            cx = tvec::iter_vec_raw(cx, value.value, unit_ty, value.meta, f);\n-        }\n-        ty::TyTuple(ref args) => {\n-            let repr = adt::represent_type(cx.ccx(), t);\n-            for (i, arg) in args.iter().enumerate() {\n-                let llfld_a = adt::trans_field_ptr(cx, &repr, value, Disr(0), i);\n-                cx = f(cx, llfld_a, *arg);\n-            }\n-        }\n-        ty::TyEnum(en, substs) => {\n-            let fcx = cx.fcx;\n-            let ccx = fcx.ccx;\n-\n-            let repr = adt::represent_type(ccx, t);\n-            let n_variants = en.variants.len();\n-\n-            // NB: we must hit the discriminant first so that structural\n-            // comparison know not to proceed when the discriminants differ.\n-\n-            match adt::trans_switch(cx, &repr, av, false) {\n-                (adt::BranchKind::Single, None) => {\n-                    if n_variants != 0 {\n-                        assert!(n_variants == 1);\n-                        cx = iter_variant(cx, &repr, adt::MaybeSizedValue::sized(av),\n-                                          &en.variants[0], substs, &mut f);\n-                    }\n-                }\n-                (adt::BranchKind::Switch, Some(lldiscrim_a)) => {\n-                    cx = f(cx, lldiscrim_a, cx.tcx().types.isize);\n-\n-                    // Create a fall-through basic block for the \"else\" case of\n-                    // the switch instruction we're about to generate. Note that\n-                    // we do **not** use an Unreachable instruction here, even\n-                    // though most of the time this basic block will never be hit.\n-                    //\n-                    // When an enum is dropped it's contents are currently\n-                    // overwritten to DTOR_DONE, which means the discriminant\n-                    // could have changed value to something not within the actual\n-                    // range of the discriminant. Currently this function is only\n-                    // used for drop glue so in this case we just return quickly\n-                    // from the outer function, and any other use case will only\n-                    // call this for an already-valid enum in which case the `ret\n-                    // void` will never be hit.\n-                    let ret_void_cx = fcx.new_block(\"enum-iter-ret-void\");\n-                    RetVoid(ret_void_cx, DebugLoc::None);\n-                    let llswitch = Switch(cx, lldiscrim_a, ret_void_cx.llbb, n_variants);\n-                    let next_cx = fcx.new_block(\"enum-iter-next\");\n-\n-                    for variant in &en.variants {\n-                        let variant_cx = fcx.new_block(&format!(\"enum-iter-variant-{}\",\n-                                                                     &variant.disr_val\n-                                                                             .to_string()));\n-                        let case_val = adt::trans_case(cx, &repr, Disr::from(variant.disr_val));\n-                        AddCase(llswitch, case_val, variant_cx.llbb);\n-                        let variant_cx = iter_variant(variant_cx,\n-                                                      &repr,\n-                                                      value,\n-                                                      variant,\n-                                                      substs,\n-                                                      &mut f);\n-                        Br(variant_cx, next_cx.llbb, DebugLoc::None);\n-                    }\n-                    cx = next_cx;\n-                }\n-                _ => ccx.sess().unimpl(\"value from adt::trans_switch in iter_structural_ty\"),\n-            }\n-        }\n-        _ => {\n-            cx.sess().unimpl(&format!(\"type in iter_structural_ty: {}\", t))\n-        }\n-    }\n-    return cx;\n-}\n-\n-\n /// Retrieve the information we are losing (making dynamic) in an unsizing\n /// adjustment.\n ///\n@@ -626,12 +476,12 @@ pub fn coerce_unsized_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n             let src_repr = adt::represent_type(bcx.ccx(), src_ty);\n             let src_fields = match &*src_repr {\n-                &adt::Repr::Univariant(ref s, _) => &s.fields,\n+                &adt::Repr::Univariant(ref s) => &s.fields,\n                 _ => bug!(\"struct has non-univariant repr\"),\n             };\n             let dst_repr = adt::represent_type(bcx.ccx(), dst_ty);\n             let dst_fields = match &*dst_repr {\n-                &adt::Repr::Univariant(ref s, _) => &s.fields,\n+                &adt::Repr::Univariant(ref s) => &s.fields,\n                 _ => bug!(\"struct has non-univariant repr\"),\n             };\n "}, {"sha": "3a456b1dd79687bd39c60a3e6de780a5eef364bb", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -783,19 +783,6 @@ pub fn C_u64(ccx: &CrateContext, i: u64) -> ValueRef {\n     C_integral(Type::i64(ccx), i, false)\n }\n \n-pub fn C_int<I: AsI64>(ccx: &CrateContext, i: I) -> ValueRef {\n-    let v = i.as_i64();\n-\n-    let bit_size = machine::llbitsize_of_real(ccx, ccx.int_type());\n-\n-    if bit_size < 64 {\n-        // make sure it doesn't overflow\n-        assert!(v < (1<<(bit_size-1)) && v >= -(1<<(bit_size-1)));\n-    }\n-\n-    C_integral(ccx.int_type(), v as u64, true)\n-}\n-\n pub fn C_uint<I: AsU64>(ccx: &CrateContext, i: I) -> ValueRef {\n     let v = i.as_u64();\n "}, {"sha": "bd984a71badeafc3f8bb36da1dd23ea8d50f5aca", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -1247,7 +1247,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                                       -> Vec<MemberDescription> {\n         let adt = &self.enum_type.ty_adt_def().unwrap();\n         match *self.type_rep {\n-            adt::General(_, ref struct_defs, _) => {\n+            adt::General(_, ref struct_defs) => {\n                 let discriminant_info = RegularDiscriminant(self.discriminant_type_metadata\n                     .expect(\"\"));\n                 struct_defs\n@@ -1281,7 +1281,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                         }\n                     }).collect()\n             },\n-            adt::Univariant(ref struct_def, _) => {\n+            adt::Univariant(ref struct_def) => {\n                 assert!(adt.variants.len() <= 1);\n \n                 if adt.variants.is_empty() {\n@@ -1631,7 +1631,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         adt::RawNullablePointer { .. }           |\n         adt::StructWrappedNullablePointer { .. } |\n         adt::Univariant(..)                      => None,\n-        adt::General(inttype, _, _) => Some(discriminant_type_metadata(inttype)),\n+        adt::General(inttype, _) => Some(discriminant_type_metadata(inttype)),\n     };\n \n     let enum_llvm_type = type_of::type_of(cx, enum_type);"}, {"sha": "ed61f1f589a0302cbaf2290854ecc8d47dd89111", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 154, "deletions": 27, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -29,9 +29,11 @@ use debuginfo::DebugLoc;\n use machine::*;\n use monomorphize;\n use trans_item::TransItem;\n+use tvec;\n use type_of::{type_of, sizing_type_of, align_of};\n use type_::Type;\n use value::Value;\n+use Disr;\n \n use arena::TypedArena;\n use syntax_pos::DUMMY_SP;\n@@ -343,10 +345,10 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n             // Don't use type_of::sizing_type_of because that expects t to be sized.\n             assert!(!t.is_simd());\n             let repr = adt::represent_type(ccx, t);\n-            let sizing_type = adt::sizing_type_context_of(ccx, &repr, true);\n+            let sizing_type = adt::sizing_type_of(ccx, &repr, true);\n             debug!(\"DST {} sizing_type: {:?}\", t, sizing_type);\n-            let sized_size = llsize_of_alloc(ccx, sizing_type.prefix());\n-            let sized_align = llalign_of_min(ccx, sizing_type.prefix());\n+            let sized_size = llsize_of_alloc(ccx, sizing_type);\n+            let sized_align = llalign_of_min(ccx, sizing_type);\n             debug!(\"DST {} statically sized prefix size: {} align: {}\",\n                    t, sized_size, sized_align);\n             let sized_size = C_uint(ccx, sized_size);\n@@ -366,15 +368,7 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n             // here. But this is where the add would go.)\n \n             // Return the sum of sizes and max of aligns.\n-            let mut size = bcx.add(sized_size, unsized_size);\n-\n-            // Issue #27023: If there is a drop flag, *now* we add 1\n-            // to the size.  (We can do this without adding any\n-            // padding because drop flags do not have any alignment\n-            // constraints.)\n-            if sizing_type.needs_drop_flag() {\n-                size = bcx.add(size, C_uint(bcx.ccx(), 1_u64));\n-            }\n+            let size = bcx.add(sized_size, unsized_size);\n \n             // Choose max of two known alignments (combined value must\n             // be aligned according to more restrictive of the two).\n@@ -471,17 +465,6 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueK\n                 trans_exchange_free_ty(bcx, llbox, content_ty, DebugLoc::None)\n             }\n         }\n-        ty::TyStruct(def, _) | ty::TyEnum(def, _) => {\n-            match (def.dtor_kind(), skip_dtor) {\n-                (ty::TraitDtor(_), false) => {\n-                    trans_struct_drop(bcx, t, v0)\n-                }\n-                (ty::NoDtor, _) | (_, true) => {\n-                    // No dtor? Just the default case\n-                    iter_structural_ty(bcx, v0, t, |bb, vv, tt| drop_ty(bb, vv, tt, DebugLoc::None))\n-                }\n-            }\n-        }\n         ty::TyTrait(..) => {\n             // No support in vtable for distinguishing destroying with\n             // versus without calling Drop::drop. Assert caller is\n@@ -496,15 +479,159 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueK\n                  DebugLoc::None);\n             bcx\n         }\n+        ty::TyStruct(def, _) | ty::TyEnum(def, _)\n+                if def.dtor_kind().is_present() && !skip_dtor => {\n+            trans_struct_drop(bcx, t, v0)\n+        }\n         _ => {\n             if bcx.fcx.type_needs_drop(t) {\n-                iter_structural_ty(bcx,\n-                                   v0,\n-                                   t,\n-                                   |bb, vv, tt| drop_ty(bb, vv, tt, DebugLoc::None))\n+                drop_structural_ty(bcx, v0, t)\n             } else {\n                 bcx\n             }\n         }\n     }\n }\n+\n+// Iterates through the elements of a structural type, dropping them.\n+fn drop_structural_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                                  av: ValueRef,\n+                                  t: Ty<'tcx>)\n+                                  -> Block<'blk, 'tcx> {\n+    let _icx = push_ctxt(\"drop_structural_ty\");\n+\n+    fn iter_variant<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                                repr: &adt::Repr<'tcx>,\n+                                av: adt::MaybeSizedValue,\n+                                variant: ty::VariantDef<'tcx>,\n+                                substs: &Substs<'tcx>)\n+                                -> Block<'blk, 'tcx> {\n+        let _icx = push_ctxt(\"iter_variant\");\n+        let tcx = cx.tcx();\n+        let mut cx = cx;\n+\n+        for (i, field) in variant.fields.iter().enumerate() {\n+            let arg = monomorphize::field_ty(tcx, substs, field);\n+            cx = drop_ty(cx,\n+                         adt::trans_field_ptr(cx, repr, av, Disr::from(variant.disr_val), i),\n+                         arg, DebugLoc::None);\n+        }\n+        return cx;\n+    }\n+\n+    let value = if type_is_sized(cx.tcx(), t) {\n+        adt::MaybeSizedValue::sized(av)\n+    } else {\n+        let data = Load(cx, get_dataptr(cx, av));\n+        let info = Load(cx, get_meta(cx, av));\n+        adt::MaybeSizedValue::unsized_(data, info)\n+    };\n+\n+    let mut cx = cx;\n+    match t.sty {\n+        ty::TyStruct(..) => {\n+            let repr = adt::represent_type(cx.ccx(), t);\n+            let VariantInfo { fields, discr } = VariantInfo::from_ty(cx.tcx(), t, None);\n+            for (i, &Field(_, field_ty)) in fields.iter().enumerate() {\n+                let llfld_a = adt::trans_field_ptr(cx, &repr, value, Disr::from(discr), i);\n+\n+                let val = if type_is_sized(cx.tcx(), field_ty) {\n+                    llfld_a\n+                } else {\n+                    let scratch = alloc_ty(cx, field_ty, \"__fat_ptr_iter\");\n+                    Store(cx, llfld_a, get_dataptr(cx, scratch));\n+                    Store(cx, value.meta, get_meta(cx, scratch));\n+                    scratch\n+                };\n+                cx = drop_ty(cx, val, field_ty, DebugLoc::None);\n+            }\n+        }\n+        ty::TyClosure(_, ref substs) => {\n+            let repr = adt::represent_type(cx.ccx(), t);\n+            for (i, upvar_ty) in substs.upvar_tys.iter().enumerate() {\n+                let llupvar = adt::trans_field_ptr(cx, &repr, value, Disr(0), i);\n+                cx = drop_ty(cx, llupvar, upvar_ty, DebugLoc::None);\n+            }\n+        }\n+        ty::TyArray(_, n) => {\n+            let base = get_dataptr(cx, value.value);\n+            let len = C_uint(cx.ccx(), n);\n+            let unit_ty = t.sequence_element_type(cx.tcx());\n+            cx = tvec::slice_for_each(cx, base, unit_ty, len,\n+                |bb, vv| drop_ty(bb, vv, unit_ty, DebugLoc::None));\n+        }\n+        ty::TySlice(_) | ty::TyStr => {\n+            let unit_ty = t.sequence_element_type(cx.tcx());\n+            cx = tvec::slice_for_each(cx, value.value, unit_ty, value.meta,\n+                |bb, vv| drop_ty(bb, vv, unit_ty, DebugLoc::None));\n+        }\n+        ty::TyTuple(ref args) => {\n+            let repr = adt::represent_type(cx.ccx(), t);\n+            for (i, arg) in args.iter().enumerate() {\n+                let llfld_a = adt::trans_field_ptr(cx, &repr, value, Disr(0), i);\n+                cx = drop_ty(cx, llfld_a, *arg, DebugLoc::None);\n+            }\n+        }\n+        ty::TyEnum(en, substs) => {\n+            let fcx = cx.fcx;\n+            let ccx = fcx.ccx;\n+\n+            let repr = adt::represent_type(ccx, t);\n+            let n_variants = en.variants.len();\n+\n+            // NB: we must hit the discriminant first so that structural\n+            // comparison know not to proceed when the discriminants differ.\n+\n+            match adt::trans_switch(cx, &repr, av, false) {\n+                (adt::BranchKind::Single, None) => {\n+                    if n_variants != 0 {\n+                        assert!(n_variants == 1);\n+                        cx = iter_variant(cx, &repr, adt::MaybeSizedValue::sized(av),\n+                                          &en.variants[0], substs);\n+                    }\n+                }\n+                (adt::BranchKind::Switch, Some(lldiscrim_a)) => {\n+                    cx = drop_ty(cx, lldiscrim_a, cx.tcx().types.isize, DebugLoc::None);\n+\n+                    // Create a fall-through basic block for the \"else\" case of\n+                    // the switch instruction we're about to generate. Note that\n+                    // we do **not** use an Unreachable instruction here, even\n+                    // though most of the time this basic block will never be hit.\n+                    //\n+                    // When an enum is dropped it's contents are currently\n+                    // overwritten to DTOR_DONE, which means the discriminant\n+                    // could have changed value to something not within the actual\n+                    // range of the discriminant. Currently this function is only\n+                    // used for drop glue so in this case we just return quickly\n+                    // from the outer function, and any other use case will only\n+                    // call this for an already-valid enum in which case the `ret\n+                    // void` will never be hit.\n+                    let ret_void_cx = fcx.new_block(\"enum-iter-ret-void\");\n+                    RetVoid(ret_void_cx, DebugLoc::None);\n+                    let llswitch = Switch(cx, lldiscrim_a, ret_void_cx.llbb, n_variants);\n+                    let next_cx = fcx.new_block(\"enum-iter-next\");\n+\n+                    for variant in &en.variants {\n+                        let variant_cx = fcx.new_block(&format!(\"enum-iter-variant-{}\",\n+                                                                     &variant.disr_val\n+                                                                             .to_string()));\n+                        let case_val = adt::trans_case(cx, &repr, Disr::from(variant.disr_val));\n+                        AddCase(llswitch, case_val, variant_cx.llbb);\n+                        let variant_cx = iter_variant(variant_cx,\n+                                                      &repr,\n+                                                      value,\n+                                                      variant,\n+                                                      substs);\n+                        Br(variant_cx, next_cx.llbb, DebugLoc::None);\n+                    }\n+                    cx = next_cx;\n+                }\n+                _ => ccx.sess().unimpl(\"value from adt::trans_switch in drop_structural_ty\"),\n+            }\n+        }\n+        _ => {\n+            cx.sess().unimpl(&format!(\"type in drop_structural_ty: {}\", t))\n+        }\n+    }\n+    return cx;\n+}"}, {"sha": "afe258f68e49f20fee85d879a3fbf5c9286dba69", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -206,9 +206,6 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, \"type_id\") => {\n             C_u64(ccx, ccx.tcx().type_id_hash(substs.types[0]))\n         }\n-        (_, \"init_dropped\") => {\n-            span_bug!(span, \"init_dropped intrinsic unsupported\");\n-        }\n         (_, \"init\") => {\n             let tp_ty = substs.types[0];\n             if !type_is_zero_size(ccx, tp_ty) {"}, {"sha": "13484cb7a4ece286527df91b0bdc17313cf523d9", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -100,7 +100,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let size = C_uint(bcx.ccx(), size);\n                 let base = get_dataptr(&bcx, dest.llval);\n                 let bcx = bcx.map_block(|block| {\n-                    tvec::iter_vec_raw(block, base, tr_elem.ty, size, |block, llslot, _| {\n+                    tvec::slice_for_each(block, base, tr_elem.ty, size, |block, llslot| {\n                         self.store_operand_direct(block, llslot, tr_elem);\n                         block\n                     })"}, {"sha": "7e4719870cd83a426f458c65d5c680971c7d9bc7", "filename": "src/librustc_trans/tvec.rs", "status": "modified", "additions": 36, "deletions": 49, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc_trans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc_trans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftvec.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -18,59 +18,46 @@ use common::*;\n use debuginfo::DebugLoc;\n use rustc::ty::Ty;\n \n-pub fn iter_vec_raw<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n-                                   data_ptr: ValueRef,\n-                                   unit_ty: Ty<'tcx>,\n-                                   len: ValueRef,\n-                                   f: F)\n-                                   -> Block<'blk, 'tcx> where\n-    F: FnOnce(Block<'blk, 'tcx>, ValueRef, Ty<'tcx>) -> Block<'blk, 'tcx>,\n+pub fn slice_for_each<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n+                                     data_ptr: ValueRef,\n+                                     unit_ty: Ty<'tcx>,\n+                                     len: ValueRef,\n+                                     f: F)\n+                                     -> Block<'blk, 'tcx> where\n+    F: FnOnce(Block<'blk, 'tcx>, ValueRef) -> Block<'blk, 'tcx>,\n {\n-    let _icx = push_ctxt(\"tvec::iter_vec_raw\");\n+    let _icx = push_ctxt(\"tvec::slice_for_each\");\n     let fcx = bcx.fcx;\n \n-    if type_is_zero_size(bcx.ccx(), unit_ty) {\n-        // Special-case vectors with elements of size 0  so they don't go out of bounds (#9890)\n-        if bcx.unreachable.get() {\n-            return bcx;\n-        }\n-\n-        let loop_bcx = fcx.new_block(\"expr_repeat\");\n-        let next_bcx = fcx.new_block(\"expr_repeat: next\");\n-\n-        Br(bcx, loop_bcx.llbb, DebugLoc::None);\n-\n-        let loop_counter = Phi(loop_bcx, bcx.ccx().int_type(),\n-                            &[C_uint(bcx.ccx(), 0 as usize)], &[bcx.llbb]);\n-\n-        let bcx = loop_bcx;\n-        let bcx = f(bcx, data_ptr, unit_ty);\n-        let plusone = Add(bcx, loop_counter, C_uint(bcx.ccx(), 1usize), DebugLoc::None);\n-        AddIncomingToPhi(loop_counter, plusone, bcx.llbb);\n+    // Special-case vectors with elements of size 0  so they don't go out of bounds (#9890)\n+    let zst = type_is_zero_size(bcx.ccx(), unit_ty);\n+    let add = |bcx, a, b| if zst {\n+        Add(bcx, a, b, DebugLoc::None)\n+    } else {\n+        InBoundsGEP(bcx, a, &[b])\n+    };\n \n-        let cond_val = ICmp(bcx, llvm::IntULT, plusone, len, DebugLoc::None);\n-        CondBr(bcx, cond_val, loop_bcx.llbb, next_bcx.llbb, DebugLoc::None);\n+    let header_bcx = fcx.new_block(\"slice_loop_header\");\n+    let body_bcx = fcx.new_block(\"slice_loop_body\");\n+    let next_bcx = fcx.new_block(\"slice_loop_next\");\n \n-        next_bcx\n+    let start = if zst {\n+        C_uint(bcx.ccx(), 0 as usize)\n     } else {\n-        // Calculate the last pointer address we want to handle.\n-        let data_end_ptr = InBoundsGEP(bcx, data_ptr, &[len]);\n-\n-        // Now perform the iteration.\n-        let header_bcx = fcx.new_block(\"iter_vec_loop_header\");\n-        Br(bcx, header_bcx.llbb, DebugLoc::None);\n-        let data_ptr =\n-            Phi(header_bcx, val_ty(data_ptr), &[data_ptr], &[bcx.llbb]);\n-        let not_yet_at_end =\n-            ICmp(header_bcx, llvm::IntULT, data_ptr, data_end_ptr, DebugLoc::None);\n-        let body_bcx = fcx.new_block(\"iter_vec_loop_body\");\n-        let next_bcx = fcx.new_block(\"iter_vec_next\");\n-        CondBr(header_bcx, not_yet_at_end, body_bcx.llbb, next_bcx.llbb, DebugLoc::None);\n-        let body_bcx = f(body_bcx, data_ptr, unit_ty);\n-        AddIncomingToPhi(data_ptr, InBoundsGEP(body_bcx, data_ptr,\n-                                               &[C_int(bcx.ccx(), 1)]),\n-                         body_bcx.llbb);\n-        Br(body_bcx, header_bcx.llbb, DebugLoc::None);\n-        next_bcx\n-    }\n+        data_ptr\n+    };\n+    let end = add(bcx, start, len);\n+\n+    Br(bcx, header_bcx.llbb, DebugLoc::None);\n+    let current = Phi(header_bcx, val_ty(start), &[start], &[bcx.llbb]);\n+\n+    let keep_going =\n+        ICmp(header_bcx, llvm::IntULT, current, end, DebugLoc::None);\n+    CondBr(header_bcx, keep_going, body_bcx.llbb, next_bcx.llbb, DebugLoc::None);\n+\n+    let body_bcx = f(body_bcx, if zst { data_ptr } else { current });\n+    let next = add(body_bcx, current, C_uint(bcx.ccx(), 1usize));\n+    AddIncomingToPhi(current, next, body_bcx.llbb);\n+    Br(body_bcx, header_bcx.llbb, DebugLoc::None);\n+    next_bcx\n }"}, {"sha": "7f9e715b7fafc634798dc1090f7b238ef6c9e99c", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -122,7 +122,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n                  ], ccx.tcx.types.usize)\n             }\n             \"rustc_peek\" => (1, vec![param(ccx, 0)], param(ccx, 0)),\n-            \"init\" | \"init_dropped\" => (1, Vec::new(), param(ccx, 0)),\n+            \"init\" => (1, Vec::new(), param(ccx, 0)),\n             \"uninit\" => (1, Vec::new(), param(ccx, 0)),\n             \"forget\" => (1, vec!( param(ccx, 0) ), tcx.mk_nil()),\n             \"transmute\" => (2, vec!( param(ccx, 0) ), param(ccx, 1)),"}, {"sha": "8f02c9c7d3de0334ca6403101bc4fc0c525c1a26", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -59,7 +59,7 @@ const EMPTY_BUCKET: u64 = 0;\n /// around just the \"table\" part of the hashtable. It enforces some\n /// invariants at the type level and employs some performance trickery,\n /// but in general is just a tricked out `Vec<Option<u64, K, V>>`.\n-#[unsafe_no_drop_flag]\n+#[cfg_attr(stage0, unsafe_no_drop_flag)]\n pub struct RawTable<K, V> {\n     capacity: usize,\n     size: usize,\n@@ -1042,7 +1042,7 @@ impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n impl<K, V> Drop for RawTable<K, V> {\n     #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n-        if self.capacity == 0 || self.capacity == mem::POST_DROP_USIZE {\n+        if self.capacity == 0 {\n             return;\n         }\n "}, {"sha": "2b15f3dd9455c5c5cadd9b8faef1195a1ea9ad27", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -275,7 +275,7 @@\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(unique)]\n-#![feature(unsafe_no_drop_flag, filling_drop)]\n+#![cfg_attr(stage0, feature(unsafe_no_drop_flag))]\n #![feature(unwind_attributes)]\n #![feature(vec_push_all)]\n #![feature(zero_one)]"}, {"sha": "d746f8e21141f4001d3e7823c4561474f68a8803", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -164,10 +164,6 @@ declare_features! (\n     // Allows using `box` in patterns; RFC 469\n     (active, box_patterns, \"1.0.0\", Some(29641)),\n \n-    // Allows using the unsafe_no_drop_flag attribute (unlikely to\n-    // switch to Accepted; see RFC 320)\n-    (active, unsafe_no_drop_flag, \"1.0.0\", None),\n-\n     // Allows using the unsafe_destructor_blind_to_params attribute;\n     // RFC 1238\n     (active, dropck_parametricity, \"1.3.0\", Some(28498)),\n@@ -300,7 +296,8 @@ declare_features! (\n     (removed, quad_precision_float, \"1.0.0\", None),\n     (removed, struct_inherit, \"1.0.0\", None),\n     (removed, test_removed_feature, \"1.0.0\", None),\n-    (removed, visible_private_types, \"1.0.0\", None)\n+    (removed, visible_private_types, \"1.0.0\", None),\n+    (removed, unsafe_no_drop_flag, \"1.0.0\", None)\n );\n \n declare_features! (\n@@ -565,10 +562,6 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n                                                         attribute is just used for the Rust test \\\n                                                         suite\",\n                                                        cfg_fn!(omit_gdb_pretty_printer_section))),\n-    (\"unsafe_no_drop_flag\", Whitelisted, Gated(\"unsafe_no_drop_flag\",\n-                                               \"unsafe_no_drop_flag has unstable semantics \\\n-                                                and may be removed in the future\",\n-                                               cfg_fn!(unsafe_no_drop_flag))),\n     (\"unsafe_destructor_blind_to_params\",\n      Normal,\n      Gated(\"dropck_parametricity\","}, {"sha": "65bc9f34c9061ed55d5074cc5d4024d647b62b4f", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -26,7 +26,6 @@\n \n #![feature(associated_consts)]\n #![feature(const_fn)]\n-#![feature(filling_drop)]\n #![feature(libc)]\n #![feature(rustc_private)]\n #![feature(staged_api)]"}, {"sha": "c3f8a977a659b572a63dc14be1aba96cd6e36975", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -39,7 +39,7 @@\n use std::fmt::{self, Display, Debug};\n use std::iter::FromIterator;\n use std::ops::Deref;\n-use std::{ptr, slice, vec};\n+use std::{mem, ptr, slice, vec};\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n@@ -74,12 +74,22 @@ impl<T: 'static> P<T> {\n     pub fn map<F>(mut self, f: F) -> P<T> where\n         F: FnOnce(T) -> T,\n     {\n+        let p: *mut T = &mut *self.ptr;\n+\n+        // Leak self in case of panic.\n+        // FIXME(eddyb) Use some sort of \"free guard\" that\n+        // only deallocates, without dropping the pointee,\n+        // in case the call the `f` below ends in a panic.\n+        mem::forget(self);\n+\n         unsafe {\n-            let p = &mut *self.ptr;\n-            // FIXME(#5016) this shouldn't need to drop-fill to be safe.\n-            ptr::write(p, f(ptr::read_and_drop(p)));\n+            ptr::write(p, f(ptr::read(p)));\n+\n+            // Recreate self from the raw pointer.\n+            P {\n+                ptr: Box::from_raw(p)\n+            }\n         }\n-        self\n     }\n }\n "}, {"sha": "91e5065517dcc9c4acb776d019a12da69ba20768", "filename": "src/test/compile-fail/lint-no-drop-on-repr-extern.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d0654ae5e53124273340624aa2e25f5a9aa9ecb3/src%2Ftest%2Fcompile-fail%2Flint-no-drop-on-repr-extern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0654ae5e53124273340624aa2e25f5a9aa9ecb3/src%2Ftest%2Fcompile-fail%2Flint-no-drop-on-repr-extern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-no-drop-on-repr-extern.rs?ref=d0654ae5e53124273340624aa2e25f5a9aa9ecb3", "patch": "@@ -1,61 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Check we reject structs that mix a `Drop` impl with `#[repr(C)]`.\n-//\n-// As a special case, also check that we do not warn on such structs\n-// if they also are declared with `#[unsafe_no_drop_flag]`\n-\n-#![feature(unsafe_no_drop_flag)]\n-#![deny(drop_with_repr_extern)]\n-//~^ NOTE lint level defined here\n-//~| NOTE lint level defined here\n-\n-#[repr(C)] struct As { x: Box<i8> }\n-#[repr(C)] enum Ae { Ae(Box<i8>), _None }\n-\n-struct Bs { x: Box<i8> }\n-enum Be { Be(Box<i8>), _None }\n-\n-#[repr(C)] struct Cs { x: Box<i8> }\n-//~^ NOTE the `#[repr(C)]` attribute is attached here\n-\n-impl Drop for Cs { fn drop(&mut self) { } }\n-//~^ ERROR implementing Drop adds hidden state to types, possibly conflicting with `#[repr(C)]`\n-\n-#[repr(C)] enum Ce { Ce(Box<i8>), _None }\n-//~^ NOTE the `#[repr(C)]` attribute is attached here\n-\n-impl Drop for Ce { fn drop(&mut self) { } }\n-//~^ ERROR implementing Drop adds hidden state to types, possibly conflicting with `#[repr(C)]`\n-\n-#[unsafe_no_drop_flag]\n-#[repr(C)] struct Ds { x: Box<i8> }\n-\n-impl Drop for Ds { fn drop(&mut self) { } }\n-\n-#[unsafe_no_drop_flag]\n-#[repr(C)] enum De { De(Box<i8>), _None }\n-\n-impl Drop for De { fn drop(&mut self) { } }\n-\n-fn main() {\n-    let a = As { x: Box::new(3) };\n-    let b = Bs { x: Box::new(3) };\n-    let c = Cs { x: Box::new(3) };\n-    let d = Ds { x: Box::new(3) };\n-\n-    println!(\"{:?}\", (*a.x, *b.x, *c.x, *d.x));\n-\n-    let _a = Ae::Ae(Box::new(3));\n-    let _b = Be::Be(Box::new(3));\n-    let _c = Ce::Ce(Box::new(3));\n-    let _d = De::De(Box::new(3));\n-}"}, {"sha": "542698fd15295f13260cacc029234fabda8f4cd1", "filename": "src/test/compile-fail/unsafe_no_drop_flag-gate.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d0654ae5e53124273340624aa2e25f5a9aa9ecb3/src%2Ftest%2Fcompile-fail%2Funsafe_no_drop_flag-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0654ae5e53124273340624aa2e25f5a9aa9ecb3/src%2Ftest%2Fcompile-fail%2Funsafe_no_drop_flag-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe_no_drop_flag-gate.rs?ref=d0654ae5e53124273340624aa2e25f5a9aa9ecb3", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub struct T;\n-\n-#[unsafe_no_drop_flag]\n-//~^ ERROR unsafe_no_drop_flag has unstable semantics and may be removed\n-pub struct S {\n-    pub x: T,\n-}\n-\n-impl Drop for S {\n-    fn drop(&mut self) {}\n-}\n-\n-pub fn main() {}"}, {"sha": "ed42ad6e875273237792d9c3b799007d09ab3699", "filename": "src/test/run-pass/auxiliary/issue-10028.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue-10028.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue-10028.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue-10028.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unsafe_no_drop_flag)]\n-\n-#[unsafe_no_drop_flag]\n pub struct ZeroLengthThingWithDestructor;\n impl Drop for ZeroLengthThingWithDestructor {\n     fn drop(&mut self) {}"}, {"sha": "a8014768d78470c14b7196c26d3410a031ba66a1", "filename": "src/test/run-pass/drop-flag-sanity-check.rs", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d0654ae5e53124273340624aa2e25f5a9aa9ecb3/src%2Ftest%2Frun-pass%2Fdrop-flag-sanity-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0654ae5e53124273340624aa2e25f5a9aa9ecb3/src%2Ftest%2Frun-pass%2Fdrop-flag-sanity-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-flag-sanity-check.rs?ref=d0654ae5e53124273340624aa2e25f5a9aa9ecb3", "patch": "@@ -1,68 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z force-dropflag-checks=on\n-// ignore-emscripten\n-\n-// Quick-and-dirty test to ensure -Z force-dropflag-checks=on works as\n-// expected. Note that the inlined drop-flag is slated for removal\n-// (RFC 320); when that happens, the -Z flag and this test should\n-// simply be removed.\n-//\n-// See also drop-flag-skip-sanity-check.rs.\n-\n-use std::env;\n-use std::process::Command;\n-\n-fn main() {\n-    let args: Vec<String> = env::args().collect();\n-    if args.len() > 1 && args[1] == \"test\" {\n-        return test();\n-    }\n-\n-    let mut p = Command::new(&args[0]).arg(\"test\").spawn().unwrap();\n-    // The invocation should fail due to the drop-flag sanity check.\n-    assert!(!p.wait().unwrap().success());\n-}\n-\n-#[derive(Debug)]\n-struct Corrupted {\n-    x: u8\n-}\n-\n-impl Drop for Corrupted {\n-    fn drop(&mut self) { println!(\"dropping\"); }\n-}\n-\n-fn test() {\n-    {\n-        let mut c1 = Corrupted { x: 1 };\n-        let mut c2 = Corrupted { x: 2 };\n-        unsafe {\n-            let p1 = &mut c1 as *mut Corrupted as *mut u8;\n-            let p2 = &mut c2 as *mut Corrupted as *mut u8;\n-            for i in 0..std::mem::size_of::<Corrupted>() {\n-                // corrupt everything, *including the drop flag.\n-                //\n-                // (We corrupt via two different means to safeguard\n-                // against the hypothetical assignment of the\n-                // dtor_needed/dtor_done values to v and v+k.  that\n-                // happen to match with one of the corruption values\n-                // below.)\n-                *p1.offset(i as isize) += 2;\n-                *p2.offset(i as isize) += 3;\n-            }\n-        }\n-        // Here, at the end of the scope of `c1` and `c2`, the\n-        // drop-glue should detect the corruption of (at least one of)\n-        // the drop-flags.\n-    }\n-    println!(\"We should never get here.\");\n-}"}, {"sha": "07a10c8d45443892151490ea3b7e50d315ac427b", "filename": "src/test/run-pass/drop-flag-skip-sanity-check.rs", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/d0654ae5e53124273340624aa2e25f5a9aa9ecb3/src%2Ftest%2Frun-pass%2Fdrop-flag-skip-sanity-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0654ae5e53124273340624aa2e25f5a9aa9ecb3/src%2Ftest%2Frun-pass%2Fdrop-flag-skip-sanity-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-flag-skip-sanity-check.rs?ref=d0654ae5e53124273340624aa2e25f5a9aa9ecb3", "patch": "@@ -1,67 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z force-dropflag-checks=off\n-// ignore-emscripten no threads support\n-\n-// Quick-and-dirty test to ensure -Z force-dropflag-checks=off works as\n-// expected. Note that the inlined drop-flag is slated for removal\n-// (RFC 320); when that happens, the -Z flag and this test should\n-// simply be removed.\n-//\n-// See also drop-flag-sanity-check.rs.\n-\n-use std::env;\n-use std::process::Command;\n-\n-fn main() {\n-    let args: Vec<String> = env::args().collect();\n-    if args.len() > 1 && args[1] == \"test\" {\n-        return test();\n-    }\n-\n-    let s = Command::new(&args[0]).arg(\"test\").status().unwrap();\n-    // Invocatinn should succeed as drop-flag sanity check is skipped.\n-    assert!(s.success());\n-}\n-\n-#[derive(Debug)]\n-struct Corrupted {\n-    x: u8\n-}\n-\n-impl Drop for Corrupted {\n-    fn drop(&mut self) { println!(\"dropping\"); }\n-}\n-\n-fn test() {\n-    {\n-        let mut c1 = Corrupted { x: 1 };\n-        let mut c2 = Corrupted { x: 2 };\n-        unsafe {\n-            let p1 = &mut c1 as *mut Corrupted as *mut u8;\n-            let p2 = &mut c2 as *mut Corrupted as *mut u8;\n-            for i in 0..std::mem::size_of::<Corrupted>() {\n-                // corrupt everything, *including the drop flag.\n-                //\n-                // (We corrupt via two different means to safeguard\n-                // against the hypothetical assignment of the\n-                // dtor_needed/dtor_done values to v and v+k.  that\n-                // happen to match with one of the corruption values\n-                // below.)\n-                *p1.offset(i as isize) += 2;\n-                *p2.offset(i as isize) += 3;\n-            }\n-        }\n-        // Here, at the end of the scope of `c1` and `c2`, the\n-        // drop-glue should detect the corruption of (at least one of)\n-        // the drop-flags.\n-    }\n-}"}, {"sha": "ea42b59f1f2b84045a973bce147501e596d31056", "filename": "src/test/run-pass/intrinsic-move-val.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -55,15 +55,6 @@ pub fn main() {\n         // compiler is hidden.\n         rusti::move_val_init(&mut y, x);\n \n-        // In particular, it may be tracked via a drop-flag embedded\n-        // in the value, or via a null pointer, or via\n-        // mem::POST_DROP_USIZE, or (most preferably) via a\n-        // stack-local drop flag.\n-        //\n-        // (This test used to build-in knowledge of how it was\n-        // tracked, and check that the underlying stack slot had been\n-        // set to `mem::POST_DROP_USIZE`.)\n-\n         // But what we *can* observe is how many times the destructor\n         // for `D` is invoked, and what the last value we saw was\n         // during such a destructor call. We do so after the end of"}, {"sha": "a521e5d4b6c34b04488b4f2db023e05655702167", "filename": "src/test/run-pass/issue-10734.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Ftest%2Frun-pass%2Fissue-10734.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Ftest%2Frun-pass%2Fissue-10734.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10734.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -8,12 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-#![feature(unsafe_no_drop_flag)]\n-\n static mut drop_count: usize = 0;\n \n-#[unsafe_no_drop_flag]\n struct Foo {\n     dropped: bool\n }"}, {"sha": "b0fd0e148c8c26f690e55faa7f01ae419a67f88a", "filename": "src/test/run-pass/issue-2895.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Ftest%2Frun-pass%2Fissue-2895.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Ftest%2Frun-pass%2Fissue-2895.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2895.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -26,11 +26,11 @@ impl Drop for Kitty {\n #[cfg(target_pointer_width = \"64\")]\n pub fn main() {\n     assert_eq!(mem::size_of::<Cat>(), 8 as usize);\n-    assert_eq!(mem::size_of::<Kitty>(), 16 as usize);\n+    assert_eq!(mem::size_of::<Kitty>(), 8 as usize);\n }\n \n #[cfg(target_pointer_width = \"32\")]\n pub fn main() {\n     assert_eq!(mem::size_of::<Cat>(), 4 as usize);\n-    assert_eq!(mem::size_of::<Kitty>(), 8 as usize);\n+    assert_eq!(mem::size_of::<Kitty>(), 4 as usize);\n }"}, {"sha": "2cb975b98d2dc5b17c718f312acbb34de5f03644", "filename": "src/test/run-pass/mir_cross_crate.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d0654ae5e53124273340624aa2e25f5a9aa9ecb3/src%2Ftest%2Frun-pass%2Fmir_cross_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0654ae5e53124273340624aa2e25f5a9aa9ecb3/src%2Ftest%2Frun-pass%2Fmir_cross_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_cross_crate.rs?ref=d0654ae5e53124273340624aa2e25f5a9aa9ecb3", "patch": "@@ -1,27 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Tests that MIR trans is used for functions from other crates.\n-\n-#![feature(unsafe_no_drop_flag)]\n-\n-#[unsafe_no_drop_flag]\n-struct Foo;\n-\n-impl Drop for Foo {\n-    fn drop(&mut self) {\n-        panic!(\"MIR trans is not enabled for mem::forget\");\n-    }\n-}\n-\n-fn main() {\n-    let x = Foo;\n-    std::mem::forget(x);\n-}"}, {"sha": "a606a8a9f4b3b9b5f0720fb61ab18fef33cfa4ab", "filename": "src/test/run-pass/no-drop-flag-size.rs", "status": "renamed", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Ftest%2Frun-pass%2Fno-drop-flag-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Ftest%2Frun-pass%2Fno-drop-flag-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fno-drop-flag-size.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,11 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unsafe_no_drop_flag)]\n-\n use std::mem::size_of;\n \n-#[unsafe_no_drop_flag]\n struct Test<T> {\n     a: T\n }", "previous_filename": "src/test/run-pass/attr-no-drop-flag-size.rs"}, {"sha": "18b6c372a5ec2a0ae0e93e437ec9eda5857bdad1", "filename": "src/test/run-pass/zero-size-type-destructors.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Ftest%2Frun-pass%2Fzero-size-type-destructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Ftest%2Frun-pass%2Fzero-size-type-destructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fzero-size-type-destructors.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -8,14 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unsafe_no_drop_flag)]\n-\n-// ignore-pretty : (#23623) problems when  ending with // comments\n-\n static mut destructions : isize = 3;\n \n pub fn foo() {\n-    #[unsafe_no_drop_flag]\n     struct Foo;\n \n     impl Drop for Foo {"}]}