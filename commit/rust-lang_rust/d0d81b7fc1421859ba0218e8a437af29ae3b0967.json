{"sha": "d0d81b7fc1421859ba0218e8a437af29ae3b0967", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwZDgxYjdmYzE0MjE4NTliYTAyMThlOGE0MzdhZjI5YWUzYjA5Njc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-21T20:33:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-21T20:33:31Z"}, "message": "Auto merge of #53471 - petrochenkov:biattr2, r=oli-obk\n\nresolve: Some macro resolution refactoring\n\nWork towards completing https://github.com/rust-lang/rust/pull/50911#issuecomment-411605393\n\nThe last commit also fixes https://github.com/rust-lang/rust/issues/53269 by not using `def_id()` on `Def::Err` and also fixes https://github.com/rust-lang/rust/issues/53512.", "tree": {"sha": "a9708466f9330e1ebc110f2e82a62905665de54b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9708466f9330e1ebc110f2e82a62905665de54b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0d81b7fc1421859ba0218e8a437af29ae3b0967", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0d81b7fc1421859ba0218e8a437af29ae3b0967", "html_url": "https://github.com/rust-lang/rust/commit/d0d81b7fc1421859ba0218e8a437af29ae3b0967", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0d81b7fc1421859ba0218e8a437af29ae3b0967/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d6d3acf4f6f405af1fcf178300a0728496de138", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d6d3acf4f6f405af1fcf178300a0728496de138", "html_url": "https://github.com/rust-lang/rust/commit/2d6d3acf4f6f405af1fcf178300a0728496de138"}, {"sha": "82619ea2bdb3e1107a1832a31aabcf1b3dd9126c", "url": "https://api.github.com/repos/rust-lang/rust/commits/82619ea2bdb3e1107a1832a31aabcf1b3dd9126c", "html_url": "https://github.com/rust-lang/rust/commit/82619ea2bdb3e1107a1832a31aabcf1b3dd9126c"}], "stats": {"total": 811, "additions": 423, "deletions": 388}, "files": [{"sha": "c79a4a93f2708c69b3b46ac79eb84789d1113d78", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 48, "deletions": 27, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d0d81b7fc1421859ba0218e8a437af29ae3b0967", "patch": "@@ -80,7 +80,7 @@ use std::mem::replace;\n use rustc_data_structures::sync::Lrc;\n \n use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution, ImportResolver};\n-use macros::{InvocationData, LegacyBinding, MacroBinding};\n+use macros::{InvocationData, LegacyBinding};\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n@@ -1399,7 +1399,7 @@ pub struct Resolver<'a, 'b: 'a> {\n     proc_mac_errors: Vec<macros::ProcMacError>,\n     /// crate-local macro expanded `macro_export` referred to by a module-relative path\n     macro_expanded_macro_export_errors: BTreeSet<(Span, Span)>,\n-\n+    /// macro-expanded `macro_rules` shadowing existing macros\n     disallowed_shadowing: Vec<&'a LegacyBinding<'a>>,\n \n     arenas: &'a ResolverArenas<'a>,\n@@ -3529,7 +3529,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             } else if opt_ns == Some(MacroNS) {\n                 assert!(ns == TypeNS);\n                 self.resolve_lexical_macro_path_segment(ident, ns, record_used, record_used,\n-                                                        false, path_span).map(MacroBinding::binding)\n+                                                        false, path_span).map(|(b, _)| b)\n             } else {\n                 let record_used_id =\n                     if record_used { crate_lint.node_id().or(Some(CRATE_NODE_ID)) } else { None };\n@@ -4431,6 +4431,42 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         vis.is_accessible_from(module.normal_ancestor_id, self)\n     }\n \n+    fn report_ambiguity_error(\n+        &self, name: Name, span: Span, _lexical: bool,\n+        def1: Def, is_import1: bool, is_glob1: bool, from_expansion1: bool, span1: Span,\n+        def2: Def, is_import2: bool, _is_glob2: bool, _from_expansion2: bool, span2: Span,\n+    ) {\n+        let participle = |is_import: bool| if is_import { \"imported\" } else { \"defined\" };\n+        let msg1 = format!(\"`{}` could refer to the name {} here\", name, participle(is_import1));\n+        let msg2 =\n+            format!(\"`{}` could also refer to the name {} here\", name, participle(is_import2));\n+        let note = if from_expansion1 {\n+            Some(if let Def::Macro(..) = def1 {\n+                format!(\"macro-expanded {} do not shadow\",\n+                        if is_import1 { \"macro imports\" } else { \"macros\" })\n+            } else {\n+                format!(\"macro-expanded {} do not shadow when used in a macro invocation path\",\n+                        if is_import1 { \"imports\" } else { \"items\" })\n+            })\n+        } else if is_glob1 {\n+            Some(format!(\"consider adding an explicit import of `{}` to disambiguate\", name))\n+        } else {\n+            None\n+        };\n+\n+        let mut err = struct_span_err!(self.session, span, E0659, \"`{}` is ambiguous\", name);\n+        err.span_note(span1, &msg1);\n+        match def2 {\n+            Def::Macro(..) if span2.is_dummy() =>\n+                err.note(&format!(\"`{}` is also a builtin macro\", name)),\n+            _ => err.span_note(span2, &msg2),\n+        };\n+        if let Some(note) = note {\n+            err.note(&note);\n+        }\n+        err.emit();\n+    }\n+\n     fn report_errors(&mut self, krate: &Crate) {\n         self.report_shadowing_errors();\n         self.report_with_use_injections(krate);\n@@ -4446,30 +4482,15 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         }\n \n         for &AmbiguityError { span, name, b1, b2, lexical } in &self.ambiguity_errors {\n-            if !reported_spans.insert(span) { continue }\n-            let participle = |binding: &NameBinding| {\n-                if binding.is_import() { \"imported\" } else { \"defined\" }\n-            };\n-            let msg1 = format!(\"`{}` could refer to the name {} here\", name, participle(b1));\n-            let msg2 = format!(\"`{}` could also refer to the name {} here\", name, participle(b2));\n-            let note = if b1.expansion == Mark::root() || !lexical && b1.is_glob_import() {\n-                format!(\"consider adding an explicit import of `{}` to disambiguate\", name)\n-            } else if let Def::Macro(..) = b1.def() {\n-                format!(\"macro-expanded {} do not shadow\",\n-                        if b1.is_import() { \"macro imports\" } else { \"macros\" })\n-            } else {\n-                format!(\"macro-expanded {} do not shadow when used in a macro invocation path\",\n-                        if b1.is_import() { \"imports\" } else { \"items\" })\n-            };\n-\n-            let mut err = struct_span_err!(self.session, span, E0659, \"`{}` is ambiguous\", name);\n-            err.span_note(b1.span, &msg1);\n-            match b2.def() {\n-                Def::Macro(..) if b2.span.is_dummy() =>\n-                    err.note(&format!(\"`{}` is also a builtin macro\", name)),\n-                _ => err.span_note(b2.span, &msg2),\n-            };\n-            err.note(&note).emit();\n+            if reported_spans.insert(span) {\n+                self.report_ambiguity_error(\n+                    name, span, lexical,\n+                    b1.def(), b1.is_import(), b1.is_glob_import(),\n+                    b1.expansion != Mark::root(), b1.span,\n+                    b2.def(), b2.is_import(), b2.is_glob_import(),\n+                    b2.expansion != Mark::root(), b2.span,\n+                );\n+            }\n         }\n \n         for &PrivacyError(span, name, binding) in &self.privacy_errors {"}, {"sha": "1161d57417b1890865c4590a6da8f698c96bea7e", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 208, "deletions": 266, "changes": 474, "blob_url": "https://github.com/rust-lang/rust/blob/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=d0d81b7fc1421859ba0218e8a437af29ae3b0967", "patch": "@@ -43,6 +43,9 @@ use std::cell::Cell;\n use std::mem;\n use rustc_data_structures::sync::Lrc;\n \n+crate struct FromPrelude(bool);\n+crate struct FromExpansion(bool);\n+\n #[derive(Clone)]\n pub struct InvocationData<'a> {\n     pub module: Cell<Module<'a>>,\n@@ -80,6 +83,12 @@ pub struct LegacyBinding<'a> {\n     pub span: Span,\n }\n \n+impl<'a> LegacyBinding<'a> {\n+    fn def(&self) -> Def {\n+        Def::Macro(self.def_id, MacroKind::Bang)\n+    }\n+}\n+\n pub struct ProcMacError {\n     crate_name: Symbol,\n     name: Symbol,\n@@ -88,37 +97,6 @@ pub struct ProcMacError {\n     warn_msg: &'static str,\n }\n \n-#[derive(Copy, Clone)]\n-pub enum MacroBinding<'a> {\n-    Legacy(&'a LegacyBinding<'a>),\n-    Global(&'a NameBinding<'a>),\n-    Modern(&'a NameBinding<'a>),\n-}\n-\n-impl<'a> MacroBinding<'a> {\n-    pub fn span(self) -> Span {\n-        match self {\n-            MacroBinding::Legacy(binding) => binding.span,\n-            MacroBinding::Global(binding) | MacroBinding::Modern(binding) => binding.span,\n-        }\n-    }\n-\n-    pub fn binding(self) -> &'a NameBinding<'a> {\n-        match self {\n-            MacroBinding::Global(binding) | MacroBinding::Modern(binding) => binding,\n-            MacroBinding::Legacy(_) => panic!(\"unexpected MacroBinding::Legacy\"),\n-        }\n-    }\n-\n-    pub fn def_ignoring_ambiguity(self) -> Def {\n-        match self {\n-            MacroBinding::Legacy(binding) => Def::Macro(binding.def_id, MacroKind::Bang),\n-            MacroBinding::Global(binding) | MacroBinding::Modern(binding) =>\n-                binding.def_ignoring_ambiguity(),\n-        }\n-    }\n-}\n-\n impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n     fn next_node_id(&mut self) -> ast::NodeId {\n         self.session.next_node_id()\n@@ -319,94 +297,38 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n         None\n     }\n \n-    fn resolve_invoc(&mut self, invoc: &Invocation, scope: Mark, force: bool)\n-                     -> Result<Option<Lrc<SyntaxExtension>>, Determinacy> {\n-        let def = match invoc.kind {\n-            InvocationKind::Attr { attr: None, .. } => return Ok(None),\n-            _ => self.resolve_invoc_to_def(invoc, scope, force)?,\n+    fn resolve_macro_invocation(&mut self, invoc: &Invocation, scope: Mark, force: bool)\n+                                -> Result<Option<Lrc<SyntaxExtension>>, Determinacy> {\n+        let (path, kind, derives_in_scope) = match invoc.kind {\n+            InvocationKind::Attr { attr: None, .. } =>\n+                return Ok(None),\n+            InvocationKind::Attr { attr: Some(ref attr), ref traits, .. } =>\n+                (&attr.path, MacroKind::Attr, &traits[..]),\n+            InvocationKind::Bang { ref mac, .. } =>\n+                (&mac.node.path, MacroKind::Bang, &[][..]),\n+            InvocationKind::Derive { ref path, .. } =>\n+                (path, MacroKind::Derive, &[][..]),\n         };\n-        if let Def::Macro(_, MacroKind::ProcMacroStub) = def {\n-            self.report_proc_macro_stub(invoc.span());\n-            return Err(Determinacy::Determined);\n-        } else if let Def::NonMacroAttr(attr_kind) = def {\n-            // Note that not only attributes, but anything in macro namespace can result in a\n-            // `Def::NonMacroAttr` definition (e.g. `inline!()`), so we must report the error\n-            // below for these cases.\n-            let is_attr_invoc =\n-                if let InvocationKind::Attr { .. } = invoc.kind { true } else { false };\n-            let path = invoc.path().expect(\"no path for non-macro attr\");\n-            match attr_kind {\n-                NonMacroAttrKind::Tool | NonMacroAttrKind::DeriveHelper |\n-                NonMacroAttrKind::Custom if is_attr_invoc => {\n-                    let features = self.session.features_untracked();\n-                    if attr_kind == NonMacroAttrKind::Tool &&\n-                       !features.tool_attributes {\n-                        feature_err(&self.session.parse_sess, \"tool_attributes\",\n-                                    invoc.span(), GateIssue::Language,\n-                                    \"tool attributes are unstable\").emit();\n-                    }\n-                    if attr_kind == NonMacroAttrKind::Custom {\n-                        assert!(path.segments.len() == 1);\n-                        let name = path.segments[0].ident.name.as_str();\n-                        if name.starts_with(\"rustc_\") {\n-                            if !features.rustc_attrs {\n-                                let msg = \"unless otherwise specified, attributes with the prefix \\\n-                                        `rustc_` are reserved for internal compiler diagnostics\";\n-                                feature_err(&self.session.parse_sess, \"rustc_attrs\", invoc.span(),\n-                                            GateIssue::Language, &msg).emit();\n-                            }\n-                        } else if name.starts_with(\"derive_\") {\n-                            if !features.custom_derive {\n-                                feature_err(&self.session.parse_sess, \"custom_derive\", invoc.span(),\n-                                            GateIssue::Language, EXPLAIN_DERIVE_UNDERSCORE).emit();\n-                            }\n-                        } else if !features.custom_attribute {\n-                            let msg = format!(\"The attribute `{}` is currently unknown to the \\\n-                                               compiler and may have meaning added to it in the \\\n-                                               future\", path);\n-                            feature_err(&self.session.parse_sess, \"custom_attribute\", invoc.span(),\n-                                        GateIssue::Language, &msg).emit();\n-                        }\n-                    }\n \n-                    return Ok(Some(Lrc::new(SyntaxExtension::NonMacroAttr {\n-                        mark_used: attr_kind == NonMacroAttrKind::Tool,\n-                    })));\n-                }\n-                _ => {\n-                    self.report_non_macro_attr(path.span, def);\n-                    return Err(Determinacy::Determined);\n-                }\n-            }\n+        let (def, ext) = self.resolve_macro_to_def(path, kind, scope, derives_in_scope, force)?;\n+\n+        if let Def::Macro(def_id, _) = def {\n+            self.macro_defs.insert(invoc.expansion_data.mark, def_id);\n+            let normal_module_def_id =\n+                self.macro_def_scope(invoc.expansion_data.mark).normal_ancestor_id;\n+            self.definitions.add_parent_module_of_macro_def(invoc.expansion_data.mark,\n+                                                            normal_module_def_id);\n+            invoc.expansion_data.mark.set_default_transparency(ext.default_transparency());\n+            invoc.expansion_data.mark.set_is_builtin(def_id.krate == BUILTIN_MACROS_CRATE);\n         }\n-        let def_id = def.def_id();\n-\n-        self.macro_defs.insert(invoc.expansion_data.mark, def_id);\n-        let normal_module_def_id =\n-            self.macro_def_scope(invoc.expansion_data.mark).normal_ancestor_id;\n-        self.definitions.add_parent_module_of_macro_def(invoc.expansion_data.mark,\n-                                                        normal_module_def_id);\n-\n-        self.unused_macros.remove(&def_id);\n-        let ext = self.get_macro(def);\n-        invoc.expansion_data.mark.set_default_transparency(ext.default_transparency());\n-        invoc.expansion_data.mark.set_is_builtin(def_id.krate == BUILTIN_MACROS_CRATE);\n+\n         Ok(Some(ext))\n     }\n \n-    fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n-                     -> Result<Lrc<SyntaxExtension>, Determinacy> {\n-        self.resolve_macro_to_def(scope, path, kind, force).and_then(|def| {\n-            if let Def::Macro(_, MacroKind::ProcMacroStub) = def {\n-                self.report_proc_macro_stub(path.span);\n-                return Err(Determinacy::Determined);\n-            } else if let Def::NonMacroAttr(..) = def {\n-                self.report_non_macro_attr(path.span, def);\n-                return Err(Determinacy::Determined);\n-            }\n-            self.unused_macros.remove(&def.def_id());\n-            Ok(self.get_macro(def))\n-        })\n+    fn resolve_macro_path(&mut self, path: &ast::Path, kind: MacroKind, scope: Mark,\n+                          derives_in_scope: &[ast::Path], force: bool)\n+                          -> Result<Lrc<SyntaxExtension>, Determinacy> {\n+        Ok(self.resolve_macro_to_def(path, kind, scope, derives_in_scope, force)?.1)\n     }\n \n     fn check_unused_macros(&self) {\n@@ -428,95 +350,91 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n }\n \n impl<'a, 'cl> Resolver<'a, 'cl> {\n-    fn report_proc_macro_stub(&self, span: Span) {\n-        self.session.span_err(span,\n-                              \"can't use a procedural macro from the same crate that defines it\");\n-    }\n+    fn resolve_macro_to_def(&mut self, path: &ast::Path, kind: MacroKind, scope: Mark,\n+                            derives_in_scope: &[ast::Path], force: bool)\n+                            -> Result<(Def, Lrc<SyntaxExtension>), Determinacy> {\n+        let def = self.resolve_macro_to_def_inner(path, kind, scope, derives_in_scope, force);\n \n-    fn report_non_macro_attr(&self, span: Span, def: Def) {\n-        self.session.span_err(span, &format!(\"expected a macro, found {}\", def.kind_name()));\n-    }\n-\n-    fn resolve_invoc_to_def(&mut self, invoc: &Invocation, scope: Mark, force: bool)\n-                            -> Result<Def, Determinacy> {\n-        let (attr, traits) = match invoc.kind {\n-            InvocationKind::Attr { ref attr, ref traits, .. } => (attr, traits),\n-            InvocationKind::Bang { ref mac, .. } => {\n-                return self.resolve_macro_to_def(scope, &mac.node.path, MacroKind::Bang, force);\n-            }\n-            InvocationKind::Derive { ref path, .. } => {\n-                return self.resolve_macro_to_def(scope, path, MacroKind::Derive, force);\n+        // Report errors and enforce feature gates for the resolved macro.\n+        if def != Err(Determinacy::Undetermined) {\n+            // Do not report duplicated errors on every undetermined resolution.\n+            for segment in &path.segments {\n+                if let Some(args) = &segment.args {\n+                    self.session.span_err(args.span(), \"generic arguments in macro path\");\n+                }\n             }\n-        };\n-\n-        let path = attr.as_ref().unwrap().path.clone();\n-        let def = self.resolve_macro_to_def(scope, &path, MacroKind::Attr, force);\n-        if let Ok(Def::NonMacroAttr(NonMacroAttrKind::Custom)) = def {} else {\n-            return def;\n         }\n \n-        // At this point we've found that the `attr` is determinately unresolved and thus can be\n-        // interpreted as a custom attribute. Normally custom attributes are feature gated, but\n-        // it may be a custom attribute whitelisted by a derive macro and they do not require\n-        // a feature gate.\n-        //\n-        // So here we look through all of the derive annotations in scope and try to resolve them.\n-        // If they themselves successfully resolve *and* one of the resolved derive macros\n-        // whitelists this attribute's name, then this is a registered attribute and we can convert\n-        // it from a \"generic custom attrite\" into a \"known derive helper attribute\".\n-        enum ConvertToDeriveHelper { Yes, No, DontKnow }\n-        let mut convert_to_derive_helper = ConvertToDeriveHelper::No;\n-        let attr_name = path.segments[0].ident.name;\n-        for path in traits {\n-            match self.resolve_macro(scope, path, MacroKind::Derive, force) {\n-                Ok(ext) => if let SyntaxExtension::ProcMacroDerive(_, ref inert_attrs, _) = *ext {\n-                    if inert_attrs.contains(&attr_name) {\n-                        convert_to_derive_helper = ConvertToDeriveHelper::Yes;\n-                        break\n-                    }\n-                },\n-                Err(Determinacy::Undetermined) =>\n-                    convert_to_derive_helper = ConvertToDeriveHelper::DontKnow,\n-                Err(Determinacy::Determined) => {}\n-            }\n-        }\n+        let def = def?;\n \n-        match convert_to_derive_helper {\n-            ConvertToDeriveHelper::Yes => Ok(Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper)),\n-            ConvertToDeriveHelper::No => def,\n-            ConvertToDeriveHelper::DontKnow => Err(Determinacy::determined(force)),\n+        if path.segments.len() > 1 {\n+            if kind != MacroKind::Bang {\n+                if def != Def::NonMacroAttr(NonMacroAttrKind::Tool) &&\n+                   !self.session.features_untracked().proc_macro_path_invoc {\n+                    let msg = format!(\"non-ident {} paths are unstable\", kind.descr());\n+                    emit_feature_err(&self.session.parse_sess, \"proc_macro_path_invoc\",\n+                                     path.span, GateIssue::Language, &msg);\n+                }\n+            }\n         }\n-    }\n \n-    fn resolve_macro_to_def(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n-                            -> Result<Def, Determinacy> {\n-        let def = self.resolve_macro_to_def_inner(scope, path, kind, force);\n-        if def != Err(Determinacy::Undetermined) {\n-            // Do not report duplicated errors on every undetermined resolution.\n-            path.segments.iter().find(|segment| segment.args.is_some()).map(|segment| {\n-                self.session.span_err(segment.args.as_ref().unwrap().span(),\n-                                      \"generic arguments in macro path\");\n-            });\n-        }\n-        if kind != MacroKind::Bang && path.segments.len() > 1 &&\n-           def != Ok(Def::NonMacroAttr(NonMacroAttrKind::Tool)) {\n-            if !self.session.features_untracked().proc_macro_path_invoc {\n-                emit_feature_err(\n-                    &self.session.parse_sess,\n-                    \"proc_macro_path_invoc\",\n-                    path.span,\n-                    GateIssue::Language,\n-                    \"paths of length greater than one in macro invocations are \\\n-                     currently unstable\",\n-                );\n+        match def {\n+            Def::Macro(def_id, macro_kind) => {\n+                self.unused_macros.remove(&def_id);\n+                if macro_kind == MacroKind::ProcMacroStub {\n+                    let msg = \"can't use a procedural macro from the same crate that defines it\";\n+                    self.session.span_err(path.span, msg);\n+                    return Err(Determinacy::Determined);\n+                }\n+            }\n+            Def::NonMacroAttr(attr_kind) => {\n+                if kind == MacroKind::Attr {\n+                    let features = self.session.features_untracked();\n+                    if attr_kind == NonMacroAttrKind::Tool && !features.tool_attributes {\n+                        feature_err(&self.session.parse_sess, \"tool_attributes\", path.span,\n+                                    GateIssue::Language, \"tool attributes are unstable\").emit();\n+                    }\n+                    if attr_kind == NonMacroAttrKind::Custom {\n+                        assert!(path.segments.len() == 1);\n+                        let name = path.segments[0].ident.name.as_str();\n+                        if name.starts_with(\"rustc_\") {\n+                            if !features.rustc_attrs {\n+                                let msg = \"unless otherwise specified, attributes with the prefix \\\n+                                           `rustc_` are reserved for internal compiler diagnostics\";\n+                                feature_err(&self.session.parse_sess, \"rustc_attrs\", path.span,\n+                                            GateIssue::Language, &msg).emit();\n+                            }\n+                        } else if name.starts_with(\"derive_\") {\n+                            if !features.custom_derive {\n+                                feature_err(&self.session.parse_sess, \"custom_derive\", path.span,\n+                                            GateIssue::Language, EXPLAIN_DERIVE_UNDERSCORE).emit();\n+                            }\n+                        } else if !features.custom_attribute {\n+                            let msg = format!(\"The attribute `{}` is currently unknown to the \\\n+                                               compiler and may have meaning added to it in the \\\n+                                               future\", path);\n+                            feature_err(&self.session.parse_sess, \"custom_attribute\", path.span,\n+                                        GateIssue::Language, &msg).emit();\n+                        }\n+                    }\n+                } else {\n+                    // Not only attributes, but anything in macro namespace can result in\n+                    // `Def::NonMacroAttr` definition (e.g. `inline!()`), so we must report\n+                    // an error for those cases.\n+                    let msg = format!(\"expected a macro, found {}\", def.kind_name());\n+                    self.session.span_err(path.span, &msg);\n+                    return Err(Determinacy::Determined);\n+                }\n             }\n+            _ => panic!(\"expected `Def::Macro` or `Def::NonMacroAttr`\"),\n         }\n-        def\n+\n+        Ok((def, self.get_macro(def)))\n     }\n \n-    pub fn resolve_macro_to_def_inner(&mut self, scope: Mark, path: &ast::Path,\n-                                  kind: MacroKind, force: bool)\n-                                  -> Result<Def, Determinacy> {\n+    pub fn resolve_macro_to_def_inner(&mut self, path: &ast::Path, kind: MacroKind, scope: Mark,\n+                                      derives_in_scope: &[ast::Path], force: bool)\n+                                      -> Result<Def, Determinacy> {\n         let ast::Path { ref segments, span } = *path;\n         let mut path: Vec<_> = segments.iter().map(|seg| seg.ident).collect();\n         let invocation = self.invocations[&scope];\n@@ -558,12 +476,12 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n \n         let legacy_resolution = self.resolve_legacy_scope(&invocation.legacy_scope, path[0], false);\n-        let result = if let Some(MacroBinding::Legacy(binding)) = legacy_resolution {\n-            Ok(Def::Macro(binding.def_id, MacroKind::Bang))\n+        let result = if let Some((legacy_binding, _)) = legacy_resolution {\n+            Ok(legacy_binding.def())\n         } else {\n             match self.resolve_lexical_macro_path_segment(path[0], MacroNS, false, force,\n                                                           kind == MacroKind::Attr, span) {\n-                Ok(binding) => Ok(binding.binding().def_ignoring_ambiguity()),\n+                Ok((binding, _)) => Ok(binding.def_ignoring_ambiguity()),\n                 Err(Determinacy::Undetermined) => return Err(Determinacy::Undetermined),\n                 Err(Determinacy::Determined) => {\n                     self.found_unresolved_macro = true;\n@@ -575,21 +493,56 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         self.current_module.nearest_item_scope().legacy_macro_resolutions.borrow_mut()\n             .push((scope, path[0], kind, result.ok()));\n \n-        result\n+        if let Ok(Def::NonMacroAttr(NonMacroAttrKind::Custom)) = result {} else {\n+            return result;\n+        }\n+\n+        // At this point we've found that the `attr` is determinately unresolved and thus can be\n+        // interpreted as a custom attribute. Normally custom attributes are feature gated, but\n+        // it may be a custom attribute whitelisted by a derive macro and they do not require\n+        // a feature gate.\n+        //\n+        // So here we look through all of the derive annotations in scope and try to resolve them.\n+        // If they themselves successfully resolve *and* one of the resolved derive macros\n+        // whitelists this attribute's name, then this is a registered attribute and we can convert\n+        // it from a \"generic custom attrite\" into a \"known derive helper attribute\".\n+        assert!(kind == MacroKind::Attr);\n+        enum ConvertToDeriveHelper { Yes, No, DontKnow }\n+        let mut convert_to_derive_helper = ConvertToDeriveHelper::No;\n+        for derive in derives_in_scope {\n+            match self.resolve_macro_path(derive, MacroKind::Derive, scope, &[], force) {\n+                Ok(ext) => if let SyntaxExtension::ProcMacroDerive(_, ref inert_attrs, _) = *ext {\n+                    if inert_attrs.contains(&path[0].name) {\n+                        convert_to_derive_helper = ConvertToDeriveHelper::Yes;\n+                        break\n+                    }\n+                },\n+                Err(Determinacy::Undetermined) =>\n+                    convert_to_derive_helper = ConvertToDeriveHelper::DontKnow,\n+                Err(Determinacy::Determined) => {}\n+            }\n+        }\n+\n+        match convert_to_derive_helper {\n+            ConvertToDeriveHelper::Yes => Ok(Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper)),\n+            ConvertToDeriveHelper::No => result,\n+            ConvertToDeriveHelper::DontKnow => Err(Determinacy::determined(force)),\n+        }\n     }\n \n     // Resolve the initial segment of a non-global macro path\n     // (e.g. `foo` in `foo::bar!(); or `foo!();`).\n     // This is a variation of `fn resolve_ident_in_lexical_scope` that can be run during\n     // expansion and import resolution (perhaps they can be merged in the future).\n-    pub fn resolve_lexical_macro_path_segment(&mut self,\n-                                              mut ident: Ident,\n-                                              ns: Namespace,\n-                                              record_used: bool,\n-                                              force: bool,\n-                                              is_attr: bool,\n-                                              path_span: Span)\n-                                              -> Result<MacroBinding<'a>, Determinacy> {\n+    crate fn resolve_lexical_macro_path_segment(\n+        &mut self,\n+        mut ident: Ident,\n+        ns: Namespace,\n+        record_used: bool,\n+        force: bool,\n+        is_attr: bool,\n+        path_span: Span\n+    ) -> Result<(&'a NameBinding<'a>, FromPrelude), Determinacy> {\n         // General principles:\n         // 1. Not controlled (user-defined) names should have higher priority than controlled names\n         //    built into the language or standard library. This way we can add new names into the\n@@ -629,7 +582,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         //     m::mac!();\n         // }\n         // This includes names from globs and from macro expansions.\n-        let mut potentially_ambiguous_result: Option<MacroBinding> = None;\n+        let mut potentially_ambiguous_result: Option<(&NameBinding, FromPrelude)> = None;\n \n         enum WhereToResolve<'a> {\n             Module(Module<'a>),\n@@ -657,11 +610,11 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         path_span,\n                     );\n                     self.current_module = orig_current_module;\n-                    binding.map(MacroBinding::Modern)\n+                    binding.map(|binding| (binding, FromPrelude(false)))\n                 }\n                 WhereToResolve::MacroPrelude => {\n                     match self.macro_prelude.get(&ident.name).cloned() {\n-                        Some(binding) => Ok(MacroBinding::Global(binding)),\n+                        Some(binding) => Ok((binding, FromPrelude(true))),\n                         None => Err(Determinacy::Determined),\n                     }\n                 }\n@@ -673,7 +626,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         let binding = (Def::NonMacroAttr(NonMacroAttrKind::Builtin),\n                                        ty::Visibility::Public, ident.span, Mark::root())\n                                        .to_name_binding(self.arenas);\n-                        Ok(MacroBinding::Global(binding))\n+                        Ok((binding, FromPrelude(true)))\n                     } else {\n                         Err(Determinacy::Determined)\n                     }\n@@ -696,7 +649,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n                         let binding = (crate_root, ty::Visibility::Public,\n                                        ident.span, Mark::root()).to_name_binding(self.arenas);\n-                        Ok(MacroBinding::Global(binding))\n+                        Ok((binding, FromPrelude(true)))\n                     } else {\n                         Err(Determinacy::Determined)\n                     }\n@@ -705,7 +658,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     if use_prelude && is_known_tool(ident.name) {\n                         let binding = (Def::ToolMod, ty::Visibility::Public,\n                                        ident.span, Mark::root()).to_name_binding(self.arenas);\n-                        Ok(MacroBinding::Global(binding))\n+                        Ok((binding, FromPrelude(true)))\n                     } else {\n                         Err(Determinacy::Determined)\n                     }\n@@ -722,7 +675,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                                 false,\n                                 path_span,\n                             ) {\n-                                result = Ok(MacroBinding::Global(binding));\n+                                result = Ok((binding, FromPrelude(true)));\n                             }\n                         }\n                     }\n@@ -733,7 +686,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                             self.primitive_type_table.primitive_types.get(&ident.name).cloned() {\n                         let binding = (Def::PrimTy(prim_ty), ty::Visibility::Public,\n                                        ident.span, Mark::root()).to_name_binding(self.arenas);\n-                        Ok(MacroBinding::Global(binding))\n+                        Ok((binding, FromPrelude(true)))\n                     } else {\n                         Err(Determinacy::Determined)\n                     }\n@@ -772,18 +725,16 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         return Ok(result);\n                     }\n \n-                    let binding = result.binding();\n-\n                     // Found a solution that is ambiguous with a previously found solution.\n                     // Push an ambiguity error for later reporting and\n                     // return something for better recovery.\n                     if let Some(previous_result) = potentially_ambiguous_result {\n-                        if binding.def() != previous_result.binding().def() {\n+                        if result.0.def() != previous_result.0.def() {\n                             self.ambiguity_errors.push(AmbiguityError {\n                                 span: path_span,\n                                 name: ident.name,\n-                                b1: previous_result.binding(),\n-                                b2: binding,\n+                                b1: previous_result.0,\n+                                b2: result.0,\n                                 lexical: true,\n                             });\n                             return Ok(previous_result);\n@@ -793,7 +744,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     // Found a solution that's not an ambiguity yet, but is \"suspicious\" and\n                     // can participate in ambiguities later on.\n                     // Remember it and go search for other solutions in outer scopes.\n-                    if binding.is_glob_import() || binding.expansion != Mark::root() {\n+                    if result.0.is_glob_import() || result.0.expansion != Mark::root() {\n                         potentially_ambiguous_result = Some(result);\n \n                         continue_search!();\n@@ -823,20 +774,19 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             let binding = (Def::NonMacroAttr(NonMacroAttrKind::Custom),\n                            ty::Visibility::Public, ident.span, Mark::root())\n                            .to_name_binding(self.arenas);\n-            Ok(MacroBinding::Global(binding))\n+            Ok((binding, FromPrelude(true)))\n         } else {\n             Err(determinacy)\n         }\n     }\n \n-    pub fn resolve_legacy_scope(&mut self,\n-                                mut scope: &'a Cell<LegacyScope<'a>>,\n-                                ident: Ident,\n-                                record_used: bool)\n-                                -> Option<MacroBinding<'a>> {\n+    crate fn resolve_legacy_scope(&mut self,\n+                                  mut scope: &'a Cell<LegacyScope<'a>>,\n+                                  ident: Ident,\n+                                  record_used: bool)\n+                                  -> Option<(&'a LegacyBinding<'a>, FromExpansion)> {\n         let ident = ident.modern();\n         let mut relative_depth: u32 = 0;\n-        let mut binding = None;\n         loop {\n             match scope.get() {\n                 LegacyScope::Empty => break,\n@@ -861,23 +811,14 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         if record_used && relative_depth > 0 {\n                             self.disallowed_shadowing.push(potential_binding);\n                         }\n-                        binding = Some(potential_binding);\n-                        break\n+                        return Some((potential_binding, FromExpansion(relative_depth > 0)));\n                     }\n                     scope = &potential_binding.parent;\n                 }\n             };\n         }\n \n-        let binding = if let Some(binding) = binding {\n-            MacroBinding::Legacy(binding)\n-        } else if let Some(binding) = self.macro_prelude.get(&ident.name).cloned() {\n-            MacroBinding::Global(binding)\n-        } else {\n-            return None;\n-        };\n-\n-        Some(binding)\n+        None\n     }\n \n     pub fn finalize_current_module_macro_resolutions(&mut self) {\n@@ -899,10 +840,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             let resolution = self.resolve_lexical_macro_path_segment(ident, MacroNS, true, true,\n                                                                      kind == MacroKind::Attr, span);\n \n-            let check_consistency = |this: &Self, binding: MacroBinding| {\n+            let check_consistency = |this: &Self, new_def: Def| {\n                 if let Some(def) = def {\n                     if this.ambiguity_errors.is_empty() && this.disallowed_shadowing.is_empty() &&\n-                       binding.def_ignoring_ambiguity() != def {\n+                       new_def != def && new_def != Def::Err {\n                         // Make sure compilation does not succeed if preferred macro resolution\n                         // has changed after the macro had been expanded. In theory all such\n                         // situations should be reported as ambiguity errors, so this is span-bug.\n@@ -921,17 +862,6 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             };\n \n             match (legacy_resolution, resolution) {\n-                (Some(MacroBinding::Legacy(legacy_binding)), Ok(MacroBinding::Modern(binding))) => {\n-                    if legacy_binding.def_id != binding.def_ignoring_ambiguity().def_id() {\n-                        let msg1 = format!(\"`{}` could refer to the macro defined here\", ident);\n-                        let msg2 =\n-                            format!(\"`{}` could also refer to the macro imported here\", ident);\n-                        self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", ident))\n-                            .span_note(legacy_binding.span, &msg1)\n-                            .span_note(binding.span, &msg2)\n-                            .emit();\n-                    }\n-                },\n                 (None, Err(_)) => {\n                     assert!(def.is_none());\n                     let bang = if kind == MacroKind::Bang { \"!\" } else { \"\" };\n@@ -941,26 +871,34 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     self.suggest_macro_name(&ident.as_str(), kind, &mut err, span);\n                     err.emit();\n                 },\n-                (Some(MacroBinding::Modern(_)), _) | (_, Ok(MacroBinding::Legacy(_))) => {\n-                    span_bug!(span, \"impossible macro resolution result\");\n-                }\n+                (Some((legacy_binding, FromExpansion(from_expansion))),\n+                 Ok((binding, FromPrelude(false)))) |\n+                (Some((legacy_binding, FromExpansion(from_expansion @ true))),\n+                 Ok((binding, FromPrelude(true)))) => {\n+                    if legacy_binding.def() != binding.def_ignoring_ambiguity() {\n+                        self.report_ambiguity_error(\n+                            ident.name, span, true,\n+                            legacy_binding.def(), false, false,\n+                            from_expansion, legacy_binding.span,\n+                            binding.def(), binding.is_import(), binding.is_glob_import(),\n+                            binding.expansion != Mark::root(), binding.span,\n+                        );\n+                    }\n+                },\n+                // OK, non-macro-expanded legacy wins over macro prelude even if defs are different\n+                (Some((legacy_binding, FromExpansion(false))), Ok((_, FromPrelude(true)))) |\n                 // OK, unambiguous resolution\n-                (Some(binding), Err(_)) | (None, Ok(binding)) |\n-                // OK, legacy wins over global even if their definitions are different\n-                (Some(binding @ MacroBinding::Legacy(_)), Ok(MacroBinding::Global(_))) |\n-                // OK, modern wins over global even if their definitions are different\n-                (Some(MacroBinding::Global(_)), Ok(binding @ MacroBinding::Modern(_))) => {\n-                    check_consistency(self, binding);\n+                (Some((legacy_binding, _)), Err(_)) => {\n+                    check_consistency(self, legacy_binding.def());\n                 }\n-                (Some(MacroBinding::Global(binding1)), Ok(MacroBinding::Global(binding2))) => {\n-                    if binding1.def() != binding2.def() {\n-                        span_bug!(span, \"mismatch between same global macro resolutions\");\n+                // OK, unambiguous resolution\n+                (None, Ok((binding, FromPrelude(from_prelude)))) => {\n+                    check_consistency(self, binding.def_ignoring_ambiguity());\n+                    if from_prelude {\n+                        self.record_use(ident, MacroNS, binding, span);\n+                        self.err_if_macro_use_proc_macro(ident.name, span, binding);\n                     }\n-                    check_consistency(self, MacroBinding::Global(binding1));\n-\n-                    self.record_use(ident, MacroNS, binding1, span);\n-                    self.err_if_macro_use_proc_macro(ident.name, span, binding1);\n-                },\n+                }\n             };\n         }\n     }\n@@ -1082,7 +1020,11 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n     /// Error if `ext` is a Macros 1.1 procedural macro being imported by `#[macro_use]`\n     fn err_if_macro_use_proc_macro(&mut self, name: Name, use_span: Span,\n                                    binding: &NameBinding<'a>) {\n-        let krate = binding.def().def_id().krate;\n+        let krate = match binding.def() {\n+            Def::NonMacroAttr(..) | Def::Err => return,\n+            Def::Macro(def_id, _) => def_id.krate,\n+            _ => unreachable!(),\n+        };\n \n         // Plugin-based syntax extensions are exempt from this check\n         if krate == BUILTIN_MACROS_CRATE { return; }"}, {"sha": "c00d67aaab6b44f2ecb682ad6bfcbea45be21137", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=d0d81b7fc1421859ba0218e8a437af29ae3b0967", "patch": "@@ -403,9 +403,7 @@ fn macro_resolve(cx: &DocContext, path_str: &str) -> Option<Def> {\n     let path = ast::Path { segments: vec![segment], span: DUMMY_SP };\n     let mut resolver = cx.resolver.borrow_mut();\n     let mark = Mark::root();\n-    let res = resolver\n-        .resolve_macro_to_def_inner(mark, &path, MacroKind::Bang, false);\n-    if let Ok(def) = res {\n+    if let Ok(def) = resolver.resolve_macro_to_def_inner(&path, MacroKind::Bang, mark, &[], false) {\n         if let SyntaxExtension::DeclMacro { .. } = *resolver.get_macro(def) {\n             return Some(def);\n         }"}, {"sha": "c9925b41498cff95d32e8f1ebb2af21085b40758", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=d0d81b7fc1421859ba0218e8a437af29ae3b0967", "patch": "@@ -727,10 +727,12 @@ pub trait Resolver {\n     fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<Attribute>, allow_derive: bool)\n                               -> Option<Attribute>;\n \n-    fn resolve_invoc(&mut self, invoc: &Invocation, scope: Mark, force: bool)\n-                     -> Result<Option<Lrc<SyntaxExtension>>, Determinacy>;\n-    fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n-                     -> Result<Lrc<SyntaxExtension>, Determinacy>;\n+    fn resolve_macro_invocation(&mut self, invoc: &Invocation, scope: Mark, force: bool)\n+                                -> Result<Option<Lrc<SyntaxExtension>>, Determinacy>;\n+    fn resolve_macro_path(&mut self, path: &ast::Path, kind: MacroKind, scope: Mark,\n+                          derives_in_scope: &[ast::Path], force: bool)\n+                          -> Result<Lrc<SyntaxExtension>, Determinacy>;\n+\n     fn check_unused_macros(&self);\n }\n \n@@ -761,12 +763,13 @@ impl Resolver for DummyResolver {\n     fn resolve_imports(&mut self) {}\n     fn find_legacy_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>, _allow_derive: bool)\n                               -> Option<Attribute> { None }\n-    fn resolve_invoc(&mut self, _invoc: &Invocation, _scope: Mark, _force: bool)\n-                     -> Result<Option<Lrc<SyntaxExtension>>, Determinacy> {\n+    fn resolve_macro_invocation(&mut self, _invoc: &Invocation, _scope: Mark, _force: bool)\n+                                -> Result<Option<Lrc<SyntaxExtension>>, Determinacy> {\n         Err(Determinacy::Determined)\n     }\n-    fn resolve_macro(&mut self, _scope: Mark, _path: &ast::Path, _kind: MacroKind,\n-                     _force: bool) -> Result<Lrc<SyntaxExtension>, Determinacy> {\n+    fn resolve_macro_path(&mut self, _path: &ast::Path, _kind: MacroKind, _scope: Mark,\n+                          _derives_in_scope: &[ast::Path], _force: bool)\n+                          -> Result<Lrc<SyntaxExtension>, Determinacy> {\n         Err(Determinacy::Determined)\n     }\n     fn check_unused_macros(&self) {}"}, {"sha": "97279e00869c682a7a6902d486f0556b55f8f8f2", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d0d81b7fc1421859ba0218e8a437af29ae3b0967", "patch": "@@ -243,15 +243,6 @@ impl Invocation {\n             InvocationKind::Derive { ref path, .. } => path.span,\n         }\n     }\n-\n-    pub fn path(&self) -> Option<&Path> {\n-        match self.kind {\n-            InvocationKind::Bang { ref mac, .. } => Some(&mac.node.path),\n-            InvocationKind::Attr { attr: Some(ref attr), .. } => Some(&attr.path),\n-            InvocationKind::Attr { attr: None, .. } => None,\n-            InvocationKind::Derive { ref path, .. } => Some(path),\n-        }\n-    }\n }\n \n pub struct MacroExpander<'a, 'b:'a> {\n@@ -343,7 +334,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n             let scope =\n                 if self.monotonic { invoc.expansion_data.mark } else { orig_expansion_data.mark };\n-            let ext = match self.cx.resolver.resolve_invoc(&invoc, scope, force) {\n+            let ext = match self.cx.resolver.resolve_macro_invocation(&invoc, scope, force) {\n                 Ok(ext) => Some(ext),\n                 Err(Determinacy::Determined) => None,\n                 Err(Determinacy::Undetermined) => {\n@@ -393,8 +384,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     for path in &traits {\n                         let mark = Mark::fresh(self.cx.current_expansion.mark);\n                         derives.push(mark);\n-                        let item = match self.cx.resolver.resolve_macro(\n-                                Mark::root(), path, MacroKind::Derive, false) {\n+                        let item = match self.cx.resolver.resolve_macro_path(\n+                                path, MacroKind::Derive, Mark::root(), &[], false) {\n                             Ok(ext) => match *ext {\n                                 BuiltinDerive(..) => item_with_markers.clone(),\n                                 _ => item.clone(),"}, {"sha": "96f68341db7a7ff5632e8409abca46ae9ec7f1d8", "filename": "src/test/compile-fail-fulldeps/proc-macro/proc-macro-gates.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-gates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-gates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-gates.rs?ref=d0d81b7fc1421859ba0218e8a437af29ae3b0967", "patch": "@@ -22,7 +22,7 @@ extern crate proc_macro_gates as foo;\n \n use foo::*;\n \n-#[foo::a] //~ ERROR: paths of length greater than one\n+#[foo::a] //~ ERROR: non-ident attribute macro paths are unstable\n fn _test() {}\n \n fn _test_inner() {"}, {"sha": "9def03e94506a529ed964209c5a847153198444c", "filename": "src/test/ui-fulldeps/proc-macro/macro-namespace-reserved-2.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fmacro-namespace-reserved-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fmacro-namespace-reserved-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fmacro-namespace-reserved-2.stderr?ref=d0d81b7fc1421859ba0218e8a437af29ae3b0967", "patch": "@@ -2,37 +2,37 @@ error: can't use a procedural macro from the same crate that defines it\n   --> $DIR/macro-namespace-reserved-2.rs:34:5\n    |\n LL |     my_macro!(); //~ ERROR can't use a procedural macro from the same crate that defines it\n-   |     ^^^^^^^^^^^^\n+   |     ^^^^^^^^\n \n error: can't use a procedural macro from the same crate that defines it\n   --> $DIR/macro-namespace-reserved-2.rs:37:5\n    |\n LL |     my_macro_attr!(); //~ ERROR can't use a procedural macro from the same crate that defines it\n-   |     ^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^\n \n error: can't use a procedural macro from the same crate that defines it\n   --> $DIR/macro-namespace-reserved-2.rs:40:5\n    |\n LL |     MyTrait!(); //~ ERROR can't use a procedural macro from the same crate that defines it\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^\n \n error: can't use a procedural macro from the same crate that defines it\n-  --> $DIR/macro-namespace-reserved-2.rs:43:1\n+  --> $DIR/macro-namespace-reserved-2.rs:43:3\n    |\n LL | #[my_macro] //~ ERROR can't use a procedural macro from the same crate that defines it\n-   | ^^^^^^^^^^^\n+   |   ^^^^^^^^\n \n error: can't use a procedural macro from the same crate that defines it\n-  --> $DIR/macro-namespace-reserved-2.rs:45:1\n+  --> $DIR/macro-namespace-reserved-2.rs:45:3\n    |\n LL | #[my_macro_attr] //~ ERROR can't use a procedural macro from the same crate that defines it\n-   | ^^^^^^^^^^^^^^^^\n+   |   ^^^^^^^^^^^^^\n \n error: can't use a procedural macro from the same crate that defines it\n-  --> $DIR/macro-namespace-reserved-2.rs:47:1\n+  --> $DIR/macro-namespace-reserved-2.rs:47:3\n    |\n LL | #[MyTrait] //~ ERROR can't use a procedural macro from the same crate that defines it\n-   | ^^^^^^^^^^\n+   |   ^^^^^^^\n \n error: can't use a procedural macro from the same crate that defines it\n   --> $DIR/macro-namespace-reserved-2.rs:50:10"}, {"sha": "0f51c7d68c642f2a81c8cdbf954973345906510f", "filename": "src/test/ui/cfg-attr-unknown-attribute-macro-expansion.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Fcfg-attr-unknown-attribute-macro-expansion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Fcfg-attr-unknown-attribute-macro-expansion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcfg-attr-unknown-attribute-macro-expansion.stderr?ref=d0d81b7fc1421859ba0218e8a437af29ae3b0967", "patch": "@@ -2,7 +2,7 @@ error[E0658]: The attribute `unknown` is currently unknown to the compiler and m\n   --> $DIR/cfg-attr-unknown-attribute-macro-expansion.rs:13:27\n    |\n LL |         #[cfg_attr(all(), unknown)] //~ ERROR `unknown` is currently unknown\n-   |                           ^^^^^^^^\n+   |                           ^^^^^^^\n ...\n LL | foo!();\n    | ------- in this macro invocation"}, {"sha": "6ecad7d79b86772d649cdf8dbf37aecf4ba390b7", "filename": "src/test/ui/custom_attribute.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Fcustom_attribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Fcustom_attribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom_attribute.stderr?ref=d0d81b7fc1421859ba0218e8a437af29ae3b0967", "patch": "@@ -1,24 +1,24 @@\n error[E0658]: The attribute `foo` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n-  --> $DIR/custom_attribute.rs:13:1\n+  --> $DIR/custom_attribute.rs:13:3\n    |\n LL | #[foo] //~ ERROR The attribute `foo`\n-   | ^^^^^^\n+   |   ^^^\n    |\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n \n error[E0658]: The attribute `foo` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n-  --> $DIR/custom_attribute.rs:15:5\n+  --> $DIR/custom_attribute.rs:15:7\n    |\n LL |     #[foo] //~ ERROR The attribute `foo`\n-   |     ^^^^^^\n+   |       ^^^\n    |\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n \n error[E0658]: The attribute `foo` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n-  --> $DIR/custom_attribute.rs:17:5\n+  --> $DIR/custom_attribute.rs:17:7\n    |\n LL |     #[foo] //~ ERROR The attribute `foo`\n-   |     ^^^^^^\n+   |       ^^^\n    |\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n "}, {"sha": "e60e9a342a99c39bf88f225d53eb70678f3f19d9", "filename": "src/test/ui/feature-gates/feature-gate-custom_attribute.stderr", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-custom_attribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-custom_attribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-custom_attribute.stderr?ref=d0d81b7fc1421859ba0218e8a437af29ae3b0967", "patch": "@@ -1,104 +1,104 @@\n error[E0658]: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n-  --> $DIR/feature-gate-custom_attribute.rs:17:1\n+  --> $DIR/feature-gate-custom_attribute.rs:17:3\n    |\n LL | #[fake_attr] //~ ERROR attribute `fake_attr` is currently unknown\n-   | ^^^^^^^^^^^^\n+   |   ^^^^^^^^^\n    |\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n \n error[E0658]: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n-  --> $DIR/feature-gate-custom_attribute.rs:18:1\n+  --> $DIR/feature-gate-custom_attribute.rs:18:3\n    |\n LL | #[fake_attr(100)] //~ ERROR attribute `fake_attr` is currently unknown\n-   | ^^^^^^^^^^^^^^^^^\n+   |   ^^^^^^^^^\n    |\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n \n error[E0658]: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n-  --> $DIR/feature-gate-custom_attribute.rs:19:1\n+  --> $DIR/feature-gate-custom_attribute.rs:19:3\n    |\n LL | #[fake_attr(1, 2, 3)] //~ ERROR attribute `fake_attr` is currently unknown\n-   | ^^^^^^^^^^^^^^^^^^^^^\n+   |   ^^^^^^^^^\n    |\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n \n error[E0658]: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n-  --> $DIR/feature-gate-custom_attribute.rs:20:1\n+  --> $DIR/feature-gate-custom_attribute.rs:20:3\n    |\n LL | #[fake_attr(\"hello\")] //~ ERROR attribute `fake_attr` is currently unknown\n-   | ^^^^^^^^^^^^^^^^^^^^^\n+   |   ^^^^^^^^^\n    |\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n \n error[E0658]: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n-  --> $DIR/feature-gate-custom_attribute.rs:21:1\n+  --> $DIR/feature-gate-custom_attribute.rs:21:3\n    |\n LL | #[fake_attr(name = \"hello\")] //~ ERROR attribute `fake_attr` is currently unknown\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |   ^^^^^^^^^\n    |\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n \n error[E0658]: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n-  --> $DIR/feature-gate-custom_attribute.rs:22:1\n+  --> $DIR/feature-gate-custom_attribute.rs:22:3\n    |\n LL | #[fake_attr(1, \"hi\", key = 12, true, false)] //~ ERROR attribute `fake_attr` is currently unknown\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |   ^^^^^^^^^\n    |\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n \n error[E0658]: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n-  --> $DIR/feature-gate-custom_attribute.rs:23:1\n+  --> $DIR/feature-gate-custom_attribute.rs:23:3\n    |\n LL | #[fake_attr(key = \"hello\", val = 10)] //~ ERROR attribute `fake_attr` is currently unknown\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |   ^^^^^^^^^\n    |\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n \n error[E0658]: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n-  --> $DIR/feature-gate-custom_attribute.rs:24:1\n+  --> $DIR/feature-gate-custom_attribute.rs:24:3\n    |\n LL | #[fake_attr(key(\"hello\"), val(10))] //~ ERROR attribute `fake_attr` is currently unknown\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |   ^^^^^^^^^\n    |\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n \n error[E0658]: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n-  --> $DIR/feature-gate-custom_attribute.rs:25:1\n+  --> $DIR/feature-gate-custom_attribute.rs:25:3\n    |\n LL | #[fake_attr(enabled = true, disabled = false)] //~ ERROR attribute `fake_attr` is currently unknown\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |   ^^^^^^^^^\n    |\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n \n error[E0658]: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n-  --> $DIR/feature-gate-custom_attribute.rs:26:1\n+  --> $DIR/feature-gate-custom_attribute.rs:26:3\n    |\n LL | #[fake_attr(true)] //~ ERROR attribute `fake_attr` is currently unknown\n-   | ^^^^^^^^^^^^^^^^^^\n+   |   ^^^^^^^^^\n    |\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n \n error[E0658]: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n-  --> $DIR/feature-gate-custom_attribute.rs:27:1\n+  --> $DIR/feature-gate-custom_attribute.rs:27:3\n    |\n LL | #[fake_attr(pi = 3.14159)] //~ ERROR attribute `fake_attr` is currently unknown\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |   ^^^^^^^^^\n    |\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n \n error[E0658]: The attribute `fake_attr` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n-  --> $DIR/feature-gate-custom_attribute.rs:28:1\n+  --> $DIR/feature-gate-custom_attribute.rs:28:3\n    |\n LL | #[fake_attr(b\"hi\")] //~ ERROR attribute `fake_attr` is currently unknown\n-   | ^^^^^^^^^^^^^^^^^^^\n+   |   ^^^^^^^^^\n    |\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n \n error[E0658]: The attribute `fake_doc` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n-  --> $DIR/feature-gate-custom_attribute.rs:29:1\n+  --> $DIR/feature-gate-custom_attribute.rs:29:3\n    |\n LL | #[fake_doc(r\"doc\")] //~ ERROR attribute `fake_doc` is currently unknown\n-   | ^^^^^^^^^^^^^^^^^^^\n+   |   ^^^^^^^^\n    |\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n "}, {"sha": "0979372daea3066d56029ca486e5b861a4b58ede", "filename": "src/test/ui/feature-gates/feature-gate-custom_derive.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-custom_derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-custom_derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-custom_derive.stderr?ref=d0d81b7fc1421859ba0218e8a437af29ae3b0967", "patch": "@@ -1,8 +1,8 @@\n error[E0658]: attributes of the form `#[derive_*]` are reserved for the compiler (see issue #29644)\n-  --> $DIR/feature-gate-custom_derive.rs:11:1\n+  --> $DIR/feature-gate-custom_derive.rs:11:3\n    |\n LL | #[derive_Clone]\n-   | ^^^^^^^^^^^^^^^\n+   |   ^^^^^^^^^^^^\n    |\n    = help: add #![feature(custom_derive)] to the crate attributes to enable\n "}, {"sha": "882549c1eafbadbab9c00b059756ed0f1b43ec02", "filename": "src/test/ui/feature-gates/feature-gate-rustc-attrs.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.stderr?ref=d0d81b7fc1421859ba0218e8a437af29ae3b0967", "patch": "@@ -1,8 +1,8 @@\n error[E0658]: unless otherwise specified, attributes with the prefix `rustc_` are reserved for internal compiler diagnostics (see issue #29642)\n-  --> $DIR/feature-gate-rustc-attrs.rs:15:1\n+  --> $DIR/feature-gate-rustc-attrs.rs:15:3\n    |\n LL | #[rustc_foo]\n-   | ^^^^^^^^^^^^\n+   |   ^^^^^^^^^\n    |\n    = help: add #![feature(rustc_attrs)] to the crate attributes to enable\n "}, {"sha": "b024059d4501424b9720683b5f154e9fa6ccf0d0", "filename": "src/test/ui/feature-gates/feature-gate-tool_attributes.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-tool_attributes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-tool_attributes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-tool_attributes.stderr?ref=d0d81b7fc1421859ba0218e8a437af29ae3b0967", "patch": "@@ -1,8 +1,8 @@\n error[E0658]: tool attributes are unstable (see issue #44690)\n-  --> $DIR/feature-gate-tool_attributes.rs:12:5\n+  --> $DIR/feature-gate-tool_attributes.rs:12:7\n    |\n LL |     #[rustfmt::skip] //~ ERROR tool attributes are unstable\n-   |     ^^^^^^^^^^^^^^^^\n+   |       ^^^^^^^^^^^^^\n    |\n    = help: add #![feature(tool_attributes)] to the crate attributes to enable\n "}, {"sha": "1b21e3ba5f3a7fe70d5c5bc0883baa56e0979590", "filename": "src/test/ui/imports/issue-53269.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Fimports%2Fissue-53269.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Fimports%2Fissue-53269.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-53269.rs?ref=d0d81b7fc1421859ba0218e8a437af29ae3b0967", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Ambiguity between a `macro_rules` macro and a non-existent import recovered as `Def::Err`\n+\n+macro_rules! mac { () => () }\n+\n+mod m {\n+    use nonexistent_module::mac; //~ ERROR unresolved import `nonexistent_module`\n+\n+    mac!(); //~ ERROR `mac` is ambiguous\n+}\n+\n+fn main() {}"}, {"sha": "0036d71107a95f57d8b024a86d6bcb158fcfaf1c", "filename": "src/test/ui/imports/issue-53269.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Fimports%2Fissue-53269.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Fimports%2Fissue-53269.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-53269.stderr?ref=d0d81b7fc1421859ba0218e8a437af29ae3b0967", "patch": "@@ -0,0 +1,27 @@\n+error[E0432]: unresolved import `nonexistent_module`\n+  --> $DIR/issue-53269.rs:16:9\n+   |\n+LL |     use nonexistent_module::mac; //~ ERROR unresolved import `nonexistent_module`\n+   |         ^^^^^^^^^^^^^^^^^^ Maybe a missing `extern crate nonexistent_module;`?\n+\n+error[E0659]: `mac` is ambiguous\n+  --> $DIR/issue-53269.rs:18:5\n+   |\n+LL |     mac!(); //~ ERROR `mac` is ambiguous\n+   |     ^^^\n+   |\n+note: `mac` could refer to the name defined here\n+  --> $DIR/issue-53269.rs:13:1\n+   |\n+LL | macro_rules! mac { () => () }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: `mac` could also refer to the name imported here\n+  --> $DIR/issue-53269.rs:16:9\n+   |\n+LL |     use nonexistent_module::mac; //~ ERROR unresolved import `nonexistent_module`\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors occurred: E0432, E0659.\n+For more information about an error, try `rustc --explain E0432`."}, {"sha": "82ae75e8198ac438b0a56bdaa2976144ae214ffb", "filename": "src/test/ui/imports/issue-53512.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Fimports%2Fissue-53512.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Fimports%2Fissue-53512.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-53512.rs?ref=d0d81b7fc1421859ba0218e8a437af29ae3b0967", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Macro from prelude is shadowed by non-existent import recovered as `Def::Err`.\n+\n+use std::assert; //~ ERROR unresolved import `std::assert`\n+\n+fn main() {\n+    assert!(true);\n+}"}, {"sha": "e79e759f6c69fc06105454d47169d2ddeff0c386", "filename": "src/test/ui/imports/issue-53512.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Fimports%2Fissue-53512.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Fimports%2Fissue-53512.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-53512.stderr?ref=d0d81b7fc1421859ba0218e8a437af29ae3b0967", "patch": "@@ -0,0 +1,9 @@\n+error[E0432]: unresolved import `std::assert`\n+  --> $DIR/issue-53512.rs:13:5\n+   |\n+LL | use std::assert; //~ ERROR unresolved import `std::assert`\n+   |     ^^^^^^^^^^^ no `assert` in the root\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0432`."}, {"sha": "2c0c4642067ac5f3dc4bb77815d130f1cd91736c", "filename": "src/test/ui/imports/macros.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Fimports%2Fmacros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Fimports%2Fmacros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fmacros.stderr?ref=d0d81b7fc1421859ba0218e8a437af29ae3b0967", "patch": "@@ -1,15 +1,15 @@\n-error: `m` is ambiguous\n+error[E0659]: `m` is ambiguous\n   --> $DIR/macros.rs:48:5\n    |\n LL |     m!(); //~ ERROR ambiguous\n    |     ^\n    |\n-note: `m` could refer to the macro defined here\n+note: `m` could refer to the name defined here\n   --> $DIR/macros.rs:46:5\n    |\n LL |     macro_rules! m { () => {} }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: `m` could also refer to the macro imported here\n+note: `m` could also refer to the name imported here\n   --> $DIR/macros.rs:47:9\n    |\n LL |     use two_macros::m;"}, {"sha": "ec3f4107e38fcd7dd0c8afe3d1079fbaf79080aa", "filename": "src/test/ui/imports/shadow_builtin_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.rs?ref=d0d81b7fc1421859ba0218e8a437af29ae3b0967", "patch": "@@ -37,10 +37,10 @@ mod m4 {\n \n mod m5 {\n     macro_rules! m { () => {\n-        macro_rules! panic { () => {} } //~ ERROR `panic` is already in scope\n+        macro_rules! panic { () => {} }\n     } }\n     m!();\n-    panic!();\n+    panic!(); //~ ERROR `panic` is ambiguous\n }\n \n #[macro_use(n)]"}, {"sha": "5c7f15b6fe26f898e4b65f66a4884970e9a54abe", "filename": "src/test/ui/imports/shadow_builtin_macros.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr?ref=d0d81b7fc1421859ba0218e8a437af29ae3b0967", "patch": "@@ -1,13 +1,19 @@\n-error: `panic` is already in scope\n+error[E0659]: `panic` is ambiguous\n+  --> $DIR/shadow_builtin_macros.rs:43:5\n+   |\n+LL |     panic!(); //~ ERROR `panic` is ambiguous\n+   |     ^^^^^\n+   |\n+note: `panic` could refer to the name defined here\n   --> $DIR/shadow_builtin_macros.rs:40:9\n    |\n-LL |         macro_rules! panic { () => {} } //~ ERROR `panic` is already in scope\n+LL |         macro_rules! panic { () => {} }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |     } }\n LL |     m!();\n    |     ----- in this macro invocation\n-   |\n-   = note: macro-expanded `macro_rules!`s may not shadow existing macros (see RFC 1560)\n+   = note: `panic` is also a builtin macro\n+   = note: macro-expanded macros do not shadow\n \n error[E0659]: `panic` is ambiguous\n   --> $DIR/shadow_builtin_macros.rs:25:14"}, {"sha": "f930217fe9ef5e0d311c84a9524cb8a194e81e9c", "filename": "src/test/ui/issues/issue-32655.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Fissues%2Fissue-32655.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Fissues%2Fissue-32655.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-32655.stderr?ref=d0d81b7fc1421859ba0218e8a437af29ae3b0967", "patch": "@@ -1,19 +1,19 @@\n error[E0658]: attributes of the form `#[derive_*]` are reserved for the compiler (see issue #29644)\n-  --> $DIR/issue-32655.rs:16:9\n+  --> $DIR/issue-32655.rs:16:11\n    |\n LL |         #[derive_Clone] //~ ERROR attributes of the form\n-   |         ^^^^^^^^^^^^^^^\n+   |           ^^^^^^^^^^^^\n ...\n LL | foo!();\n    | ------- in this macro invocation\n    |\n    = help: add #![feature(custom_derive)] to the crate attributes to enable\n \n error[E0658]: attributes of the form `#[derive_*]` are reserved for the compiler (see issue #29644)\n-  --> $DIR/issue-32655.rs:28:5\n+  --> $DIR/issue-32655.rs:28:7\n    |\n LL |     #[derive_Clone] //~ ERROR attributes of the form\n-   |     ^^^^^^^^^^^^^^^\n+   |       ^^^^^^^^^^^^\n    |\n    = help: add #![feature(custom_derive)] to the crate attributes to enable\n "}, {"sha": "6c9d1eac3568436aa9788aa2dc7e1bf31db2324a", "filename": "src/test/ui/issues/issue-49074.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Fissues%2Fissue-49074.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Fissues%2Fissue-49074.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-49074.stderr?ref=d0d81b7fc1421859ba0218e8a437af29ae3b0967", "patch": "@@ -1,8 +1,8 @@\n error[E0658]: The attribute `marco_use` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n-  --> $DIR/issue-49074.rs:13:1\n+  --> $DIR/issue-49074.rs:13:3\n    |\n LL | #[marco_use] // typo\n-   | ^^^^^^^^^^^^\n+   |   ^^^^^^^^^\n    |\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n "}, {"sha": "8f954158a6315cad8a815ffd46e8bc849fe59f26", "filename": "src/test/ui/macros/macro-reexport-removed.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Fmacros%2Fmacro-reexport-removed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Fmacros%2Fmacro-reexport-removed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-reexport-removed.stderr?ref=d0d81b7fc1421859ba0218e8a437af29ae3b0967", "patch": "@@ -11,10 +11,10 @@ LL | #![feature(macro_reexport)] //~ ERROR feature has been removed\n    |            ^^^^^^^^^^^^^^\n \n error[E0658]: The attribute `macro_reexport` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n-  --> $DIR/macro-reexport-removed.rs:15:1\n+  --> $DIR/macro-reexport-removed.rs:15:3\n    |\n LL | #[macro_reexport(macro_one)] //~ ERROR attribute `macro_reexport` is currently unknown\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |   ^^^^^^^^^^^^^^\n    |\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n "}, {"sha": "efcd1ec67d7e9491a5d88a53edee7a984bfd8bab", "filename": "src/test/ui/reserved/reserved-attr-on-macro.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Freserved%2Freserved-attr-on-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Freserved%2Freserved-attr-on-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freserved%2Freserved-attr-on-macro.stderr?ref=d0d81b7fc1421859ba0218e8a437af29ae3b0967", "patch": "@@ -1,8 +1,8 @@\n error[E0658]: unless otherwise specified, attributes with the prefix `rustc_` are reserved for internal compiler diagnostics (see issue #29642)\n-  --> $DIR/reserved-attr-on-macro.rs:11:1\n+  --> $DIR/reserved-attr-on-macro.rs:11:3\n    |\n LL | #[rustc_attribute_should_be_reserved] //~ ERROR attributes with the prefix `rustc_` are reserved\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add #![feature(rustc_attrs)] to the crate attributes to enable\n "}, {"sha": "e7dd8e7aa8fa073c1510131cb506e1b48a54624d", "filename": "src/test/ui/span/issue-36530.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Fspan%2Fissue-36530.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d0d81b7fc1421859ba0218e8a437af29ae3b0967/src%2Ftest%2Fui%2Fspan%2Fissue-36530.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-36530.stderr?ref=d0d81b7fc1421859ba0218e8a437af29ae3b0967", "patch": "@@ -1,16 +1,16 @@\n error[E0658]: The attribute `foo` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n-  --> $DIR/issue-36530.rs:11:1\n+  --> $DIR/issue-36530.rs:11:3\n    |\n LL | #[foo] //~ ERROR is currently unknown to the compiler\n-   | ^^^^^^\n+   |   ^^^\n    |\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n \n error[E0658]: The attribute `foo` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n-  --> $DIR/issue-36530.rs:13:5\n+  --> $DIR/issue-36530.rs:13:8\n    |\n LL |     #![foo] //~ ERROR is currently unknown to the compiler\n-   |     ^^^^^^^\n+   |        ^^^\n    |\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n "}]}