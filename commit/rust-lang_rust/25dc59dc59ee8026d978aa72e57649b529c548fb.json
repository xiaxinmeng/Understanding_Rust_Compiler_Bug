{"sha": "25dc59dc59ee8026d978aa72e57649b529c548fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1ZGM1OWRjNTllZTgwMjZkOTc4YWE3MmU1NzY0OWI1MjljNTQ4ZmI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-08T22:50:29Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-09T03:04:21Z"}, "message": "libsyntax: Parse and report errors for a few obsolete syntaxes", "tree": {"sha": "8eefb3cab9fd4ea1f863c2c932fc1fda24c869ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8eefb3cab9fd4ea1f863c2c932fc1fda24c869ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25dc59dc59ee8026d978aa72e57649b529c548fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25dc59dc59ee8026d978aa72e57649b529c548fb", "html_url": "https://github.com/rust-lang/rust/commit/25dc59dc59ee8026d978aa72e57649b529c548fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25dc59dc59ee8026d978aa72e57649b529c548fb/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2508c2427652528e65cbc5d613fee09af498acbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/2508c2427652528e65cbc5d613fee09af498acbc", "html_url": "https://github.com/rust-lang/rust/commit/2508c2427652528e65cbc5d613fee09af498acbc"}], "stats": {"total": 267, "additions": 253, "deletions": 14}, "files": [{"sha": "5d2e081354e6ae645ec1bd5d4c4481ca482b362f", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25dc59dc59ee8026d978aa72e57649b529c548fb/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25dc59dc59ee8026d978aa72e57649b529c548fb/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=25dc59dc59ee8026d978aa72e57649b529c548fb", "patch": "@@ -78,6 +78,7 @@ fn parse_crate_from_crate_file(input: &Path, cfg: ast::crate_cfg,\n         cx, cdirs, &prefix, &companionmod);\n     let mut hi = p.span.hi;\n     p.expect(token::EOF);\n+    p.abort_if_errors();\n     return @ast_util::respan(ast_util::mk_sp(lo, hi),\n                           {directives: cdirs,\n                            module: m,\n@@ -100,6 +101,7 @@ fn parse_crate_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n     let (p, rdr) = new_parser_etc_from_source_str(sess, cfg, name,\n                                                   codemap::fss_none, source);\n     let r = p.parse_crate_mod(cfg);\n+    p.abort_if_errors();\n     sess.chpos = rdr.chpos;\n     sess.byte_pos = sess.byte_pos + rdr.pos;\n     return r;\n@@ -110,6 +112,7 @@ fn parse_expr_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n     let (p, rdr) = new_parser_etc_from_source_str(sess, cfg, name,\n                                                   codemap::fss_none, source);\n     let r = p.parse_expr();\n+    p.abort_if_errors();\n     sess.chpos = rdr.chpos;\n     sess.byte_pos = sess.byte_pos + rdr.pos;\n     return r;\n@@ -121,6 +124,7 @@ fn parse_item_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n     let (p, rdr) = new_parser_etc_from_source_str(sess, cfg, name,\n                                                   codemap::fss_none, source);\n     let r = p.parse_item(attrs);\n+    p.abort_if_errors();\n     sess.chpos = rdr.chpos;\n     sess.byte_pos = sess.byte_pos + rdr.pos;\n     return r;\n@@ -132,6 +136,7 @@ fn parse_stmt_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n     let (p, rdr) = new_parser_etc_from_source_str(sess, cfg, name,\n                                                   codemap::fss_none, source);\n     let r = p.parse_stmt(attrs);\n+    p.abort_if_errors();\n     sess.chpos = rdr.chpos;\n     sess.byte_pos = sess.byte_pos + rdr.pos;\n     return r;\n@@ -149,6 +154,7 @@ fn parse_from_source_str<T>(f: fn (p: parser) -> T,\n     if !p.reader.is_eof() {\n         p.reader.fatal(~\"expected end-of-string\");\n     }\n+    p.abort_if_errors();\n     sess.chpos = rdr.chpos;\n     sess.byte_pos = sess.byte_pos + rdr.pos;\n     return r;"}, {"sha": "1a4c08747bfa63d8039e34e60f2e0422ef89f15f", "filename": "src/libsyntax/parse/obsolete.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/25dc59dc59ee8026d978aa72e57649b529c548fb/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25dc59dc59ee8026d978aa72e57649b529c548fb/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=25dc59dc59ee8026d978aa72e57649b529c548fb", "patch": "@@ -0,0 +1,145 @@\n+/*!\n+Support for parsing unsupported, old syntaxes, for the\n+purpose of reporting errors. Parsing of these syntaxes\n+is tested by compile-test/obsolete-syntax.rs.\n+\n+Obsolete syntax that becomes too hard to parse can be\n+removed.\n+*/\n+\n+use codemap::span;\n+use ast::{expr, expr_lit, lit_nil};\n+use ast_util::{respan};\n+use token::token;\n+\n+/// The specific types of unsupported syntax\n+pub enum ObsoleteSyntax {\n+    ObsoleteLowerCaseKindBounds,\n+    ObsoleteLet,\n+    ObsoleteFieldTerminator,\n+    ObsoleteStructCtor,\n+    ObsoleteWith\n+}\n+\n+impl ObsoleteSyntax : cmp::Eq {\n+    pure fn eq(&&other: ObsoleteSyntax) -> bool {\n+        self as uint == other as uint\n+    }\n+    pure fn ne(&&other: ObsoleteSyntax) -> bool {\n+        !self.eq(other)\n+    }\n+}\n+\n+impl ObsoleteSyntax: to_bytes::IterBytes {\n+    #[inline(always)]\n+    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        (self as uint).iter_bytes(lsb0, f);\n+    }\n+}\n+\n+pub trait ObsoleteReporter {\n+    fn obsolete(sp: span, kind: ObsoleteSyntax);\n+    fn obsolete_expr(sp: span, kind: ObsoleteSyntax) -> @expr;\n+}\n+\n+impl parser : ObsoleteReporter {\n+    /// Reports an obsolete syntax non-fatal error.\n+    fn obsolete(sp: span, kind: ObsoleteSyntax) {\n+        let (kind_str, desc) = match kind {\n+            ObsoleteLowerCaseKindBounds => (\n+                \"lower-case kind bounds\",\n+                \"the `send`, `copy`, `const`, and `owned` \\\n+                 kinds are represented as traits now, and \\\n+                 should be camel cased\"\n+            ),\n+            ObsoleteLet => (\n+                \"`let` in field declaration\",\n+                \"declare fields as `field: Type`\"\n+            ),\n+            ObsoleteFieldTerminator => (\n+                \"field declaration terminated with semicolon\",\n+                \"fields are now separated by commas\"\n+            ),\n+            ObsoleteStructCtor => (\n+                \"struct constructor\",\n+                \"structs are now constructed with `MyStruct { foo: val }` \\\n+                 syntax. Structs with private fields cannot be created \\\n+                 outside of their defining module\"\n+            ),\n+            ObsoleteWith => (\n+                \"with\",\n+                \"record update is done with `..`, e.g. \\\n+                 `MyStruct { foo: bar, .. baz }`\"\n+            ),\n+        };\n+\n+        self.report(sp, kind, kind_str, desc);\n+    }\n+\n+    // Reports an obsolete syntax non-fatal error, and returns\n+    // a placeholder expression\n+    fn obsolete_expr(sp: span, kind: ObsoleteSyntax) -> @expr {\n+        self.obsolete(sp, kind);\n+        self.mk_expr(sp.lo, sp.hi, expr_lit(@respan(sp, lit_nil)))\n+    }\n+\n+    priv fn report(sp: span, kind: ObsoleteSyntax, kind_str: &str,\n+                   desc: &str) {\n+        self.span_err(sp, fmt!(\"obsolete syntax: %s\", kind_str));\n+\n+        if !self.obsolete_set.contains_key(kind) {\n+            self.sess.span_diagnostic.handler().note(fmt!(\"%s\", desc));\n+            self.obsolete_set.insert(kind, ());\n+        }\n+    }\n+\n+    fn token_is_obsolete_ident(ident: &str, token: token) -> bool {\n+        match token {\n+            token::IDENT(copy sid, _) => {\n+                str::eq_slice(*self.id_to_str(sid), ident)\n+            }\n+            _ => false\n+        }\n+    }\n+\n+    fn is_obsolete_ident(ident: &str) -> bool {\n+        self.token_is_obsolete_ident(ident, copy self.token)\n+    }\n+\n+    fn eat_obsolete_ident(ident: &str) -> bool {\n+        if self.is_obsolete_ident(ident) {\n+            self.bump();\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn try_parse_obsolete_struct_ctor() -> bool {\n+        if self.eat_obsolete_ident(\"new\") {\n+            self.obsolete(copy self.last_span, ObsoleteStructCtor);\n+            self.parse_fn_decl(|p| p.parse_arg());\n+            self.parse_block();\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn try_parse_obsolete_with() -> bool {\n+        if self.token == token::COMMA\n+            && self.token_is_obsolete_ident(\"with\",\n+                                            self.look_ahead(1u)) {\n+            self.bump();\n+        }\n+        if self.eat_obsolete_ident(\"with\") {\n+            self.obsolete(copy self.last_span, ObsoleteWith);\n+            self.parse_expr();\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+}\n+"}, {"sha": "73ff35481d4ad6b9a16e95a295fe11b14570f2e1", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 59, "deletions": 14, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/25dc59dc59ee8026d978aa72e57649b529c548fb/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25dc59dc59ee8026d978aa72e57649b529c548fb/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=25dc59dc59ee8026d978aa72e57649b529c548fb", "patch": "@@ -15,6 +15,12 @@ use common::{seq_sep_trailing_disallowed, seq_sep_trailing_allowed,\n                 seq_sep_none, token_to_str};\n use dvec::DVec;\n use vec::{push};\n+use obsolete::{\n+    ObsoleteReporter, ObsoleteSyntax,\n+    ObsoleteLowerCaseKindBounds, ObsoleteLet,\n+    ObsoleteFieldTerminator, ObsoleteStructCtor,\n+    ObsoleteWith\n+};\n use ast::{_mod, add, alt_check, alt_exhaustive, arg, arm, attribute,\n              bind_by_ref, bind_by_implicit_ref, bind_by_value, bind_by_move,\n              bitand, bitor, bitxor, blk, blk_check_mode, bound_const,\n@@ -208,7 +214,8 @@ fn parser(sess: parse_sess, cfg: ast::crate_cfg,\n         restriction: UNRESTRICTED,\n         quote_depth: 0u,\n         keywords: token::keyword_table(),\n-        restricted_keywords: token::restricted_keyword_table()\n+        restricted_keywords: token::restricted_keyword_table(),\n+        obsolete_set: std::map::hashmap(),\n     }\n }\n \n@@ -228,6 +235,9 @@ struct parser {\n     interner: interner<@~str>,\n     keywords: hashmap<~str, ()>,\n     restricted_keywords: hashmap<~str, ()>,\n+    /// The set of seen errors about obsolete syntax. Used to suppress\n+    /// extra detail when the same error is seen twice\n+    obsolete_set: hashmap<ObsoleteSyntax, ()>,\n \n     drop {} /* do not copy the parser; its state is tied to outside state */\n \n@@ -276,6 +286,12 @@ struct parser {\n     fn warn(m: ~str) {\n         self.sess.span_diagnostic.span_warn(copy self.span, m)\n     }\n+    fn span_err(sp: span, m: ~str) {\n+        self.sess.span_diagnostic.span_err(sp, m)\n+    }\n+    fn abort_if_errors() {\n+        self.sess.span_diagnostic.handler().abort_if_errors();\n+    }\n     fn get_id() -> node_id { next_node_id(self.sess) }\n \n     pure fn id_to_str(id: ident) -> @~str { self.sess.interner.get(id) }\n@@ -1004,24 +1020,28 @@ struct parser {\n                     // It's a struct literal.\n                     self.bump();\n                     let mut fields = ~[];\n+                    let mut base = None;\n                     vec::push(fields, self.parse_field(token::COLON));\n                     while self.token != token::RBRACE {\n+\n+                        if self.try_parse_obsolete_with() {\n+                            break;\n+                        }\n+\n                         self.expect(token::COMMA);\n-                        if self.token == token::RBRACE ||\n-                                self.token == token::DOTDOT {\n+\n+                        if self.eat(token::DOTDOT) {\n+                            base = Some(self.parse_expr());\n+                            break;\n+                        }\n+\n+                        if self.token == token::RBRACE {\n                             // Accept an optional trailing comma.\n                             break;\n                         }\n                         vec::push(fields, self.parse_field(token::COLON));\n                     }\n \n-                    let base;\n-                    if self.eat(token::DOTDOT) {\n-                        base = Some(self.parse_expr());\n-                    } else {\n-                        base = None;\n-                    }\n-\n                     hi = pth.span.hi;\n                     self.expect(token::RBRACE);\n                     ex = expr_struct(pth, fields, base);\n@@ -1664,6 +1684,10 @@ struct parser {\n                 base = Some(self.parse_expr()); break;\n             }\n \n+            if self.try_parse_obsolete_with() {\n+                break;\n+            }\n+\n             self.expect(token::COMMA);\n             if self.token == token::RBRACE {\n                 // record ends by an optional trailing comma\n@@ -2281,12 +2305,22 @@ struct parser {\n                 if is_ident(self.token) {\n                     // XXX: temporary until kinds become traits\n                     let maybe_bound = match self.token {\n-                      token::IDENT(sid, _) => {\n+                      token::IDENT(copy sid, _) => {\n                         match *self.id_to_str(sid) {\n                           ~\"Send\" => Some(bound_send),\n                           ~\"Copy\" => Some(bound_copy),\n                           ~\"Const\" => Some(bound_const),\n                           ~\"Owned\" => Some(bound_owned),\n+\n+                          ~\"send\"\n+                          | ~\"copy\"\n+                          | ~\"const\"\n+                          | ~\"owned\" => {\n+                            self.obsolete(copy self.span,\n+                                          ObsoleteLowerCaseKindBounds);\n+                            None\n+                          }\n+\n                           _ => None\n                         }\n                       }\n@@ -2737,11 +2771,18 @@ struct parser {\n     }\n \n     fn parse_single_class_item(vis: visibility) -> @class_member {\n-        if (self.token_is_keyword(~\"mut\", copy self.token) ||\n-                !self.is_any_keyword(copy self.token)) &&\n-                !self.token_is_pound_or_doc_comment(self.token) {\n+        let obsolete_let = self.eat_obsolete_ident(\"let\");\n+        if obsolete_let { self.obsolete(copy self.last_span, ObsoleteLet) }\n+\n+        if (obsolete_let || self.token_is_keyword(~\"mut\", copy self.token) ||\n+            !self.is_any_keyword(copy self.token)) &&\n+            !self.token_is_pound_or_doc_comment(self.token) {\n             let a_var = self.parse_instance_var(vis);\n             match self.token {\n+                token::SEMI => {\n+                    self.obsolete(copy self.span, ObsoleteFieldTerminator);\n+                    self.bump();\n+                }\n                 token::COMMA => {\n                     self.bump();\n                 }\n@@ -2792,6 +2833,10 @@ struct parser {\n \n         let attrs = self.parse_outer_attributes();\n \n+        if self.try_parse_obsolete_struct_ctor() {\n+            return members(~[]);\n+        }\n+\n         if self.eat_keyword(~\"drop\") {\n            return self.parse_dtor(attrs);\n         }"}, {"sha": "a7b606dc2a2be28af8f786247bfb73f3c7c60cff", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/25dc59dc59ee8026d978aa72e57649b529c548fb/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/25dc59dc59ee8026d978aa72e57649b529c548fb/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=25dc59dc59ee8026d978aa72e57649b529c548fb", "patch": "@@ -52,6 +52,9 @@ mod parse {\n \n     /// Routines the parser uses to classify AST nodes\n     mod classify;\n+\n+    /// Reporting obsolete syntax\n+    mod obsolete;\n }\n \n mod print {"}, {"sha": "a6665ddbfd57cb928da6091014d5ea36deff58dd", "filename": "src/test/compile-fail/obsolete-syntax.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/25dc59dc59ee8026d978aa72e57649b529c548fb/src%2Ftest%2Fcompile-fail%2Fobsolete-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25dc59dc59ee8026d978aa72e57649b529c548fb/src%2Ftest%2Fcompile-fail%2Fobsolete-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobsolete-syntax.rs?ref=25dc59dc59ee8026d978aa72e57649b529c548fb", "patch": "@@ -0,0 +1,40 @@\n+fn f1<T: copy>() -> T { }\n+//~^ ERROR obsolete syntax: lower-case kind bounds\n+\n+fn f1<T: send>() -> T { }\n+//~^ ERROR obsolete syntax: lower-case kind bounds\n+\n+fn f1<T: const>() -> T { }\n+//~^ ERROR obsolete syntax: lower-case kind bounds\n+\n+fn f1<T: owned>() -> T { }\n+//~^ ERROR obsolete syntax: lower-case kind bounds\n+\n+struct s {\n+    let foo: (),\n+    //~^ ERROR obsolete syntax: `let` in field declaration\n+    bar: ();\n+    //~^ ERROR obsolete syntax: field declaration terminated with semicolon\n+    new() { }\n+    //~^ ERROR obsolete syntax: struct constructor\n+}\n+\n+fn obsolete_with() {\n+    struct S {\n+        foo: (),\n+        bar: (),\n+    }\n+\n+    let a = S { foo: (), bar: () };\n+    let b = S { foo: () with a };\n+    //~^ ERROR obsolete syntax: with\n+    let c = S { foo: (), with a };\n+    //~^ ERROR obsolete syntax: with\n+    let a = { foo: (), bar: () };\n+    let b = { foo: () with a };\n+    //~^ ERROR obsolete syntax: with\n+    let c = { foo: (), with a };\n+    //~^ ERROR obsolete syntax: with\n+}\n+\n+fn main() { }"}]}