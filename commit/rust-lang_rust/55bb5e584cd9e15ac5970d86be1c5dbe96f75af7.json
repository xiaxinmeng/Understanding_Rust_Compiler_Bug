{"sha": "55bb5e584cd9e15ac5970d86be1c5dbe96f75af7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1YmI1ZTU4NGNkOWUxNWFjNTk3MGQ4NmJlMWM1ZGJlOTZmNzVhZjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-06T13:56:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-06T13:56:52Z"}, "message": "auto merge of #11327 : nielsle/rust/rustpkg_argparse, r=alexcrichton\n\nRearrange some code in rustpkg:\r\n\r\n* Move command line argument parsing to  parse_args.rs\r\n* Introduce an enum to descibe commands such as Build, Install, and Clean.\r\n* Move sysroot from Context to BuildContext, to make parse_args  more modular.\r\n\r\nThis is my first pull request, so please tell me if there is anything I need to do.", "tree": {"sha": "2db6d5c57fd5739345206a5357eec20628abe41f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2db6d5c57fd5739345206a5357eec20628abe41f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7", "html_url": "https://github.com/rust-lang/rust/commit/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03a38b9afff51a92b1523cb489854a5c3ad9f84a", "url": "https://api.github.com/repos/rust-lang/rust/commits/03a38b9afff51a92b1523cb489854a5c3ad9f84a", "html_url": "https://github.com/rust-lang/rust/commit/03a38b9afff51a92b1523cb489854a5c3ad9f84a"}, {"sha": "4140b2950bf21a0a06c35f953f275087d4e9d5c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/4140b2950bf21a0a06c35f953f275087d4e9d5c9", "html_url": "https://github.com/rust-lang/rust/commit/4140b2950bf21a0a06c35f953f275087d4e9d5c9"}], "stats": {"total": 605, "additions": 331, "deletions": 274}, "files": [{"sha": "45c37a93e3e1e767efd036ec8d3ac7230f23b86c", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=55bb5e584cd9e15ac5970d86be1c5dbe96f75af7", "patch": "@@ -49,8 +49,8 @@ pub fn new_default_context(c: workcache::Context, p: Path) -> BuildContext {\n             cfgs: ~[],\n             rustc_flags: RustcFlags::default(),\n             use_rust_path_hack: false,\n-            sysroot: p\n         },\n+        sysroot: p,\n         workcache_context: c\n     }\n }"}, {"sha": "681ae1dc8078022e97b8e29c52e1d3667567930d", "filename": "src/librustpkg/context.rs", "status": "modified", "additions": 69, "deletions": 44, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7/src%2Flibrustpkg%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7/src%2Flibrustpkg%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcontext.rs?ref=55bb5e584cd9e15ac5970d86be1c5dbe96f75af7", "patch": "@@ -27,25 +27,35 @@ pub struct Context {\n     // FOO/src/bar-0.1 instead of FOO). The flag doesn't affect where\n     // rustpkg stores build artifacts.\n     use_rust_path_hack: bool,\n-    // The root directory containing the Rust standard libraries\n-    sysroot: Path\n }\n \n #[deriving(Clone)]\n pub struct BuildContext {\n     // Context for workcache\n     workcache_context: workcache::Context,\n-    // Everything else\n-    context: Context\n+    // Parsed command line options\n+    context: Context,\n+    // The root directory containing the Rust standard libraries\n+    sysroot: Path\n }\n \n impl BuildContext {\n     pub fn sysroot(&self) -> Path {\n-        self.context.sysroot.clone()\n+        self.sysroot.clone()\n     }\n \n+    // Hack so that rustpkg can run either out of a rustc target dir,\n+    // or the host dir\n     pub fn sysroot_to_use(&self) -> Path {\n-        self.context.sysroot_to_use()\n+        if !in_target(&self.sysroot) {\n+            self.sysroot.clone()\n+        } else {\n+            let mut p = self.sysroot.clone();\n+            p.pop();\n+            p.pop();\n+            p.pop();\n+            p\n+        }\n     }\n \n     /// Returns the flags to pass to rustc, as a vector of strings\n@@ -132,28 +142,6 @@ pub enum StopBefore {\n }\n \n impl Context {\n-    pub fn sysroot(&self) -> Path {\n-        self.sysroot.clone()\n-    }\n-\n-    /// Debugging\n-    pub fn sysroot_str(&self) -> ~str {\n-        self.sysroot.as_str().unwrap().to_owned()\n-    }\n-\n-    // Hack so that rustpkg can run either out of a rustc target dir,\n-    // or the host dir\n-    pub fn sysroot_to_use(&self) -> Path {\n-        if !in_target(&self.sysroot) {\n-            self.sysroot.clone()\n-        } else {\n-            let mut p = self.sysroot.clone();\n-            p.pop();\n-            p.pop();\n-            p.pop();\n-            p\n-        }\n-    }\n \n     /// Returns the flags to pass to rustc, as a vector of strings\n     pub fn flag_strs(&self) -> ~[~str] {\n@@ -235,85 +223,122 @@ impl RustcFlags {\n     }\n }\n \n+\n+#[deriving(Eq)]\n+pub enum Command {\n+    BuildCmd,\n+    CleanCmd,\n+    DoCmd,\n+    InfoCmd,\n+    InstallCmd,\n+    ListCmd,\n+    PreferCmd,\n+    TestCmd,\n+    InitCmd,\n+    UninstallCmd,\n+    UnpreferCmd,\n+}\n+\n+impl FromStr for Command {\n+\n+    fn from_str(s: &str) -> Option<Command>  {\n+       match s {\n+            &\"build\" => Some(BuildCmd),\n+            &\"clean\" => Some(CleanCmd),\n+            &\"do\" => Some(DoCmd),\n+            &\"info\" => Some(InfoCmd),\n+            &\"install\" => Some(InstallCmd),\n+            &\"list\"    => Some(ListCmd),\n+            &\"prefer\" => Some(PreferCmd),\n+            &\"test\" => Some(TestCmd),\n+            &\"init\" => Some(InitCmd),\n+            &\"uninstall\" => Some(UninstallCmd),\n+            &\"unprefer\" => Some(UnpreferCmd),\n+            _ => None\n+        }\n+    }\n+}\n+\n /// Returns true if any of the flags given are incompatible with the cmd\n pub fn flags_forbidden_for_cmd(flags: &RustcFlags,\n                         cfgs: &[~str],\n-                        cmd: &str, user_supplied_opt_level: bool) -> bool {\n+                        cmd: Command, user_supplied_opt_level: bool) -> bool {\n     let complain = |s| {\n         println!(\"The {} option can only be used with the `build` command:\n                   rustpkg [options..] build {} [package-ID]\", s, s);\n     };\n \n-    if flags.linker.is_some() && cmd != \"build\" && cmd != \"install\" {\n+    if flags.linker.is_some() && cmd != BuildCmd && cmd != InstallCmd {\n         println(\"The --linker option can only be used with the build or install commands.\");\n         return true;\n     }\n-    if flags.link_args.is_some() && cmd != \"build\" && cmd != \"install\" {\n+    if flags.link_args.is_some() && cmd != BuildCmd && cmd != InstallCmd {\n         println(\"The --link-args option can only be used with the build or install commands.\");\n         return true;\n     }\n \n-    if !cfgs.is_empty() && cmd != \"build\" && cmd != \"install\" && cmd != \"test\" {\n+    if !cfgs.is_empty() && cmd != BuildCmd && cmd != InstallCmd && cmd != TestCmd {\n         println(\"The --cfg option can only be used with the build, test, or install commands.\");\n         return true;\n     }\n \n-    if user_supplied_opt_level && cmd != \"build\" && cmd != \"install\" {\n+    if user_supplied_opt_level && cmd != BuildCmd && cmd != InstallCmd {\n         println(\"The -O and --opt-level options can only be used with the build \\\n                     or install commands.\");\n         return true;\n     }\n \n-    if flags.save_temps  && cmd != \"build\" && cmd != \"install\" {\n+    if flags.save_temps  && cmd != BuildCmd && cmd != InstallCmd {\n         println(\"The --save-temps option can only be used with the build \\\n                     or install commands.\");\n         return true;\n     }\n \n-    if flags.target.is_some()  && cmd != \"build\" && cmd != \"install\" {\n+    if flags.target.is_some()  && cmd != BuildCmd && cmd != InstallCmd {\n         println(\"The --target option can only be used with the build \\\n                     or install commands.\");\n         return true;\n     }\n-    if flags.target_cpu.is_some()  && cmd != \"build\" && cmd != \"install\" {\n+    if flags.target_cpu.is_some()  && cmd != BuildCmd && cmd != InstallCmd {\n         println(\"The --target-cpu option can only be used with the build \\\n                     or install commands.\");\n         return true;\n     }\n-    if flags.experimental_features.is_some() && cmd != \"build\" && cmd != \"install\" {\n+    if flags.experimental_features.is_some() && cmd != BuildCmd && cmd != InstallCmd {\n         println(\"The -Z option can only be used with the build or install commands.\");\n         return true;\n     }\n \n     match flags.compile_upto {\n-        Link if cmd != \"build\" => {\n+        Link if cmd != BuildCmd => {\n             complain(\"--no-link\");\n             true\n         }\n-        Trans if cmd != \"build\" => {\n+        Trans if cmd != BuildCmd => {\n             complain(\"--no-trans\");\n             true\n         }\n-        Assemble if cmd != \"build\" => {\n+        Assemble if cmd != BuildCmd => {\n             complain(\"-S\");\n             true\n         }\n-        Pretty if cmd != \"build\" => {\n+        Pretty if cmd != BuildCmd => {\n             complain(\"--pretty\");\n             true\n         }\n-        Analysis if cmd != \"build\" => {\n+        Analysis if cmd != BuildCmd => {\n             complain(\"--parse-only\");\n             true\n         }\n-        LLVMCompileBitcode if cmd != \"build\" => {\n+        LLVMCompileBitcode if cmd != BuildCmd => {\n             complain(\"--emit-llvm\");\n             true\n         }\n-        LLVMAssemble if cmd != \"build\" => {\n+        LLVMAssemble if cmd != BuildCmd => {\n             complain(\"--emit-llvm\");\n             true\n         }\n         _ => false\n     }\n }\n+"}, {"sha": "99cf14f0d96247f62c40f5a5f6cd71c7f6b4c5f8", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 44, "deletions": 193, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=55bb5e584cd9e15ac5970d86be1c5dbe96f75af7", "patch": "@@ -20,9 +20,8 @@ extern mod extra;\n extern mod rustc;\n extern mod syntax;\n \n-use std::{os, result, run, str, task};\n+use std::{os, run, str, task};\n use std::io::process;\n-use std::hashmap::HashSet;\n use std::io;\n use std::io::fs;\n pub use std::path::Path;\n@@ -32,25 +31,26 @@ use rustc::driver::{driver, session};\n use rustc::metadata::filesearch;\n use rustc::metadata::filesearch::rust_path;\n use rustc::util::sha2;\n-use extra::{getopts};\n use syntax::{ast, diagnostic};\n use messages::{error, warn, note};\n+use parse_args::{ParseResult, parse_args};\n use path_util::{build_pkg_id_in_workspace, built_test_in_workspace};\n use path_util::in_rust_path;\n use path_util::{built_executable_in_workspace, built_library_in_workspace, default_workspace};\n use path_util::{target_executable_in_workspace, target_library_in_workspace, dir_has_crate_file};\n use source_control::{CheckedOutSources, is_git_dir, make_read_only};\n use workspace::{each_pkg_parent_workspace, pkg_parent_workspaces, cwd_to_workspace};\n use workspace::determine_destination;\n-use context::{Context, BuildContext,\n-                       RustcFlags, Trans, Link, Nothing, Pretty, Analysis, Assemble,\n-                       LLVMAssemble, LLVMCompileBitcode};\n+use context::{BuildContext, Trans, Nothing, Pretty, Analysis,\n+              LLVMAssemble, LLVMCompileBitcode};\n+use context::{Command, BuildCmd, CleanCmd, DoCmd, InfoCmd, InstallCmd, ListCmd,\n+    PreferCmd, TestCmd, InitCmd, UninstallCmd, UnpreferCmd};\n use crate_id::CrateId;\n use package_source::PkgSrc;\n use target::{WhatToBuild, Everything, is_lib, is_main, is_test, is_bench};\n use target::{Main, Tests, MaybeCustom, Inferred, JustOne};\n use workcache_support::digest_only_date;\n-use exit_codes::{COPY_FAILED_CODE, BAD_FLAG_CODE};\n+use exit_codes::{COPY_FAILED_CODE};\n \n pub mod api;\n mod conditions;\n@@ -61,6 +61,7 @@ mod installed_packages;\n mod messages;\n pub mod crate_id;\n pub mod package_source;\n+mod parse_args;\n mod path_util;\n mod source_control;\n mod target;\n@@ -207,7 +208,7 @@ impl<'a> PkgScript<'a> {\n }\n \n pub trait CtxMethods {\n-    fn run(&self, cmd: &str, args: ~[~str]);\n+    fn run(&self, cmd: Command, args: ~[~str]);\n     fn do_cmd(&self, _cmd: &str, _pkgname: &str);\n     /// Returns a pair of the selected package ID, and the destination workspace\n     fn build_args(&self, args: ~[~str], what: &WhatToBuild) -> Option<(CrateId, Path)>;\n@@ -283,13 +284,13 @@ impl CtxMethods for BuildContext {\n             Some((crateid, dest_ws))\n         }\n     }\n-    fn run(&self, cmd: &str, args: ~[~str]) {\n+    fn run(&self, cmd: Command, args: ~[~str]) {\n         let cwd = os::getcwd();\n         match cmd {\n-            \"build\" => {\n+            BuildCmd => {\n                 self.build_args(args, &WhatToBuild::new(MaybeCustom, Everything));\n             }\n-            \"clean\" => {\n+            CleanCmd => {\n                 if args.len() < 1 {\n                     match cwd_to_workspace() {\n                         None => { usage::clean(); return }\n@@ -306,17 +307,17 @@ impl CtxMethods for BuildContext {\n                     self.clean(&cwd, &crateid); // tjc: should use workspace, not cwd\n                 }\n             }\n-            \"do\" => {\n+            DoCmd => {\n                 if args.len() < 2 {\n                     return usage::do_cmd();\n                 }\n \n                 self.do_cmd(args[0].clone(), args[1].clone());\n             }\n-            \"info\" => {\n+            InfoCmd => {\n                 self.info();\n             }\n-            \"install\" => {\n+            InstallCmd => {\n                if args.len() < 1 {\n                     match cwd_to_workspace() {\n                         None if dir_has_crate_file(&cwd) => {\n@@ -362,21 +363,21 @@ impl CtxMethods for BuildContext {\n                     }\n                 }\n             }\n-            \"list\" => {\n+            ListCmd => {\n                 println(\"Installed packages:\");\n                 installed_packages::list_installed_packages(|pkg_id| {\n                     pkg_id.path.display().with_str(|s| println(s));\n                     true\n                 });\n             }\n-            \"prefer\" => {\n+            PreferCmd => {\n                 if args.len() < 1 {\n                     return usage::uninstall();\n                 }\n \n                 self.prefer(args[0], None);\n             }\n-            \"test\" => {\n+            TestCmd => {\n                 // Build the test executable\n                 let maybe_id_and_workspace = self.build_args(args,\n                                                              &WhatToBuild::new(MaybeCustom, Tests));\n@@ -390,14 +391,14 @@ impl CtxMethods for BuildContext {\n                     }\n                 }\n             }\n-            \"init\" => {\n+            InitCmd => {\n                 if args.len() != 0 {\n                     return usage::init();\n                 } else {\n                     self.init();\n                 }\n             }\n-            \"uninstall\" => {\n+            UninstallCmd => {\n                 if args.len() < 1 {\n                     return usage::uninstall();\n                 }\n@@ -419,14 +420,13 @@ impl CtxMethods for BuildContext {\n                     });\n                 }\n             }\n-            \"unprefer\" => {\n+            UnpreferCmd => {\n                 if args.len() < 1 {\n                     return usage::unprefer();\n                 }\n \n                 self.unprefer(args[0], None);\n             }\n-            _ => fail!(\"I don't know the command `{}`\", cmd)\n         }\n     }\n \n@@ -752,192 +752,43 @@ pub fn main() {\n }\n \n pub fn main_args(args: &[~str]) -> int {\n-    let opts = ~[getopts::optflag(\"h\"), getopts::optflag(\"help\"),\n-                                        getopts::optflag(\"no-link\"),\n-                                        getopts::optflag(\"no-trans\"),\n-                 // n.b. Ignores different --pretty options for now\n-                                        getopts::optflag(\"pretty\"),\n-                                        getopts::optflag(\"parse-only\"),\n-                 getopts::optflag(\"S\"), getopts::optflag(\"assembly\"),\n-                 getopts::optmulti(\"c\"), getopts::optmulti(\"cfg\"),\n-                 getopts::optflag(\"v\"), getopts::optflag(\"version\"),\n-                 getopts::optflag(\"r\"), getopts::optflag(\"rust-path-hack\"),\n-                                        getopts::optopt(\"sysroot\"),\n-                                        getopts::optflag(\"emit-llvm\"),\n-                                        getopts::optopt(\"linker\"),\n-                                        getopts::optopt(\"link-args\"),\n-                                        getopts::optopt(\"opt-level\"),\n-                 getopts::optflag(\"O\"),\n-                                        getopts::optflag(\"save-temps\"),\n-                                        getopts::optopt(\"target\"),\n-                                        getopts::optopt(\"target-cpu\"),\n-                 getopts::optmulti(\"Z\")                                   ];\n-    let matches = &match getopts::getopts(args, opts) {\n-        result::Ok(m) => m,\n-        result::Err(f) => {\n-            error(format!(\"{}\", f.to_err_msg()));\n-\n-            return 1;\n-        }\n-    };\n-    let help = matches.opt_present(\"h\") ||\n-                   matches.opt_present(\"help\");\n-    let no_link = matches.opt_present(\"no-link\");\n-    let no_trans = matches.opt_present(\"no-trans\");\n-    let supplied_sysroot = matches.opt_str(\"sysroot\");\n-    let generate_asm = matches.opt_present(\"S\") ||\n-        matches.opt_present(\"assembly\");\n-    let parse_only = matches.opt_present(\"parse-only\");\n-    let pretty = matches.opt_present(\"pretty\");\n-    let emit_llvm = matches.opt_present(\"emit-llvm\");\n-\n-    if matches.opt_present(\"v\") ||\n-       matches.opt_present(\"version\") {\n-        rustc::version(args[0]);\n-        return 0;\n-    }\n \n-    let use_rust_path_hack = matches.opt_present(\"r\") ||\n-                             matches.opt_present(\"rust-path-hack\");\n-\n-    let linker = matches.opt_str(\"linker\");\n-    let link_args = matches.opt_str(\"link-args\");\n-    let cfgs = matches.opt_strs(\"cfg\") + matches.opt_strs(\"c\");\n-    let mut user_supplied_opt_level = true;\n-    let opt_level = match matches.opt_str(\"opt-level\") {\n-        Some(~\"0\") => session::No,\n-        Some(~\"1\") => session::Less,\n-        Some(~\"2\") => session::Default,\n-        Some(~\"3\") => session::Aggressive,\n-        _ if matches.opt_present(\"O\") => session::Default,\n-        _ => {\n-            user_supplied_opt_level = false;\n-            session::No\n-        }\n-    };\n-\n-    let save_temps = matches.opt_present(\"save-temps\");\n-    let target     = matches.opt_str(\"target\");\n-    let target_cpu = matches.opt_str(\"target-cpu\");\n-    let experimental_features = {\n-        let strs = matches.opt_strs(\"Z\");\n-        if matches.opt_present(\"Z\") {\n-            Some(strs)\n-        }\n-        else {\n-            None\n+    let (command, args, context, supplied_sysroot) = match parse_args(args) {\n+        Ok(ParseResult {\n+            command: cmd,\n+            args: args,\n+            context: ctx,\n+            sysroot: sroot}) => (cmd, args, ctx, sroot),\n+        Err(error_code) => {\n+            debug!(\"Parsing failed. Returning error code {}\", error_code);\n+            return error_code\n         }\n     };\n-\n-    let mut args = matches.free.clone();\n-    args.shift();\n-\n-    if (args.len() < 1) {\n-        usage::general();\n-        return 1;\n-    }\n-\n-    let rustc_flags = RustcFlags {\n-        linker: linker,\n-        link_args: link_args,\n-        optimization_level: opt_level,\n-        compile_upto: if no_trans {\n-            Trans\n-        } else if no_link {\n-            Link\n-        } else if pretty {\n-            Pretty\n-        } else if parse_only {\n-            Analysis\n-        } else if emit_llvm && generate_asm {\n-            LLVMAssemble\n-        } else if generate_asm {\n-            Assemble\n-        } else if emit_llvm {\n-            LLVMCompileBitcode\n-        } else {\n-            Nothing\n-        },\n-        save_temps: save_temps,\n-        target: target,\n-        target_cpu: target_cpu,\n-        additional_library_paths:\n-            HashSet::new(), // No way to set this from the rustpkg command line\n-        experimental_features: experimental_features\n-    };\n-\n-    let mut cmd_opt = None;\n-    for a in args.iter() {\n-        if util::is_cmd(*a) {\n-            cmd_opt = Some(a);\n-            break;\n-        }\n-    }\n-    let cmd = match cmd_opt {\n-        None => {\n-            usage::general();\n-            return 0;\n-        }\n-        Some(cmd) => {\n-            let bad_option = context::flags_forbidden_for_cmd(&rustc_flags,\n-                                                              cfgs,\n-                                                              *cmd,\n-                                                              user_supplied_opt_level);\n-            if help || bad_option {\n-                match *cmd {\n-                    ~\"build\" => usage::build(),\n-                    ~\"clean\" => usage::clean(),\n-                    ~\"do\" => usage::do_cmd(),\n-                    ~\"info\" => usage::info(),\n-                    ~\"install\" => usage::install(),\n-                    ~\"list\"    => usage::list(),\n-                    ~\"prefer\" => usage::prefer(),\n-                    ~\"test\" => usage::test(),\n-                    ~\"init\" => usage::init(),\n-                    ~\"uninstall\" => usage::uninstall(),\n-                    ~\"unprefer\" => usage::unprefer(),\n-                    _ => usage::general()\n-                };\n-                if bad_option {\n-                    return BAD_FLAG_CODE;\n-                }\n-                else {\n-                    return 0;\n-                }\n-            } else {\n-                cmd\n-            }\n-        }\n-    };\n-\n-    // Pop off all flags, plus the command\n-    let remaining_args = args.iter().skip_while(|s| !util::is_cmd(**s));\n-    // I had to add this type annotation to get the code to typecheck\n-    let mut remaining_args: ~[~str] = remaining_args.map(|s| (*s).clone()).collect();\n-    remaining_args.shift();\n-    let sroot = match supplied_sysroot {\n+    debug!(\"Finished parsing commandline args {:?}\", args);\n+    debug!(\"  Using command: {:?}\", command);\n+    debug!(\"  Using args {:?}\", args);\n+    debug!(\"  Using cflags: {:?}\", context.rustc_flags);\n+    debug!(\"  Using rust_path_hack {:b}\", context.use_rust_path_hack);\n+    debug!(\"  Using cfgs: {:?}\", context.cfgs);\n+    debug!(\"  Using supplied_sysroot: {:?}\", supplied_sysroot);\n+\n+    let sysroot = match supplied_sysroot {\n         Some(s) => Path::new(s),\n         _ => filesearch::get_or_default_sysroot()\n     };\n \n-    debug!(\"Using sysroot: {}\", sroot.display());\n+    debug!(\"Using sysroot: {}\", sysroot.display());\n     let ws = default_workspace();\n     debug!(\"Will store workcache in {}\", ws.display());\n \n-    let rm_args = remaining_args.clone();\n-    let sub_cmd = cmd.clone();\n     // Wrap the rest in task::try in case of a condition failure in a task\n     let result = do task::try {\n         BuildContext {\n-            context: Context {\n-                cfgs: cfgs.clone(),\n-                rustc_flags: rustc_flags.clone(),\n-                use_rust_path_hack: use_rust_path_hack,\n-                sysroot: sroot.clone(), // Currently, only tests override this\n-            },\n-            workcache_context: api::default_context(sroot.clone(),\n+            context: context,\n+            sysroot: sysroot.clone(), // Currently, only tests override this\n+            workcache_context: api::default_context(sysroot.clone(),\n                                                     default_workspace()).workcache_context\n-        }.run(sub_cmd, rm_args.clone())\n+        }.run(command, args.clone())\n     };\n     // FIXME #9262: This is using the same error code for all errors,\n     // and at least one test case succeeds if rustpkg returns COPY_FAILED_CODE,"}, {"sha": "8f21c6d3bfa68f65494197283068b5b8f4e3483d", "filename": "src/librustpkg/parse_args.rs", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7/src%2Flibrustpkg%2Fparse_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7/src%2Flibrustpkg%2Fparse_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fparse_args.rs?ref=55bb5e584cd9e15ac5970d86be1c5dbe96f75af7", "patch": "@@ -0,0 +1,190 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use context::{Context, RustcFlags, Trans, Link, Nothing, Pretty, Analysis, Assemble,\n+                       LLVMAssemble, LLVMCompileBitcode};\n+use context::{Command, flags_forbidden_for_cmd};\n+use rustc::version;\n+use exit_codes::{BAD_FLAG_CODE};\n+use rustc::driver::{session};\n+\n+use usage;\n+\n+use extra::{getopts};\n+use std::{result};\n+use std::hashmap::HashSet;\n+\n+///  Result of parsing command line arguments\n+pub struct ParseResult {\n+    // Command\n+    command: Command,\n+    // Args\n+    args: ~[~str],\n+    // Parsed command line flags\n+    context: Context,\n+    // Path to system root\n+    sysroot: Option<~str>\n+}\n+\n+/// Parses command line arguments of rustpkg.\n+/// Returns a triplet (command, remaining_args, context)\n+pub fn parse_args(args: &[~str]) -> Result<ParseResult, int> {\n+    let opts = ~[ getopts::optflag(\"no-link\"),\n+                                        getopts::optflag(\"no-trans\"),\n+                 // n.b. Ignores different --pretty options for now\n+                                        getopts::optflag(\"pretty\"),\n+                                        getopts::optflag(\"parse-only\"),\n+                 getopts::optflag(\"S\"), getopts::optflag(\"assembly\"),\n+                 getopts::optmulti(\"c\"), getopts::optmulti(\"cfg\"),\n+                 getopts::optflag(\"v\"), getopts::optflag(\"version\"),\n+                 getopts::optflag(\"r\"), getopts::optflag(\"rust-path-hack\"),\n+                                        getopts::optopt(\"sysroot\"),\n+                                        getopts::optflag(\"emit-llvm\"),\n+                                        getopts::optopt(\"linker\"),\n+                                        getopts::optopt(\"link-args\"),\n+                                        getopts::optopt(\"opt-level\"),\n+                 getopts::optflag(\"O\"),\n+                                        getopts::optflag(\"save-temps\"),\n+                                        getopts::optopt(\"target\"),\n+                                        getopts::optopt(\"target-cpu\"),\n+                 getopts::optmulti(\"Z\")                                   ];\n+    let matches = &match getopts::getopts(args, opts) {\n+        result::Ok(m) => m,\n+        result::Err(f) => {\n+            error!(\"{}\", f.to_err_msg());\n+            return Err(1);\n+        }\n+    };\n+    let no_link = matches.opt_present(\"no-link\");\n+    let no_trans = matches.opt_present(\"no-trans\");\n+    let supplied_sysroot = matches.opt_str(\"sysroot\");\n+    let generate_asm = matches.opt_present(\"S\") ||\n+        matches.opt_present(\"assembly\");\n+    let parse_only = matches.opt_present(\"parse-only\");\n+    let pretty = matches.opt_present(\"pretty\");\n+    let emit_llvm = matches.opt_present(\"emit-llvm\");\n+\n+    if matches.opt_present(\"v\") ||\n+       matches.opt_present(\"version\") {\n+        version(args[0]);\n+        return Err(0);\n+    }\n+\n+    let use_rust_path_hack = matches.opt_present(\"r\") ||\n+                             matches.opt_present(\"rust-path-hack\");\n+\n+    let linker = matches.opt_str(\"linker\");\n+    let link_args = matches.opt_str(\"link-args\");\n+    let cfgs = matches.opt_strs(\"cfg\") + matches.opt_strs(\"c\");\n+    let mut user_supplied_opt_level = true;\n+    let opt_level = match matches.opt_str(\"opt-level\") {\n+        Some(~\"0\") => session::No,\n+        Some(~\"1\") => session::Less,\n+        Some(~\"2\") => session::Default,\n+        Some(~\"3\") => session::Aggressive,\n+        _ if matches.opt_present(\"O\") => session::Default,\n+        _ => {\n+            user_supplied_opt_level = false;\n+            session::No\n+        }\n+    };\n+\n+    let save_temps = matches.opt_present(\"save-temps\");\n+    let target     = matches.opt_str(\"target\");\n+    let target_cpu = matches.opt_str(\"target-cpu\");\n+    let experimental_features = {\n+        let strs = matches.opt_strs(\"Z\");\n+        if matches.opt_present(\"Z\") {\n+            Some(strs)\n+        }\n+        else {\n+            None\n+        }\n+    };\n+\n+    let mut args = matches.free.clone();\n+    args.shift();\n+\n+    if (args.len() < 1) {\n+        usage::general();\n+        return Err(1);\n+    }\n+\n+    let rustc_flags = RustcFlags {\n+        linker: linker,\n+        link_args: link_args,\n+        optimization_level: opt_level,\n+        compile_upto: if no_trans {\n+            Trans\n+        } else if no_link {\n+            Link\n+        } else if pretty {\n+            Pretty\n+        } else if parse_only {\n+            Analysis\n+        } else if emit_llvm && generate_asm {\n+            LLVMAssemble\n+        } else if generate_asm {\n+            Assemble\n+        } else if emit_llvm {\n+            LLVMCompileBitcode\n+        } else {\n+            Nothing\n+        },\n+        save_temps: save_temps,\n+        target: target,\n+        target_cpu: target_cpu,\n+        additional_library_paths:\n+            HashSet::new(), // No way to set this from the rustpkg command line\n+        experimental_features: experimental_features\n+    };\n+\n+    let cmd_opt = args.iter().filter_map( |s| from_str(s.clone())).next();\n+    let command = match(cmd_opt){\n+        None => {\n+            debug!(\"No legal command. Returning 0\");\n+            usage::general();\n+            return Err(0);\n+        }\n+        Some(cmd) => {\n+            let bad_option = flags_forbidden_for_cmd(&rustc_flags,\n+                                                              cfgs,\n+                                                              cmd,\n+                                                              user_supplied_opt_level);\n+            if bad_option {\n+                usage::usage_for_command(cmd);\n+                debug!(\"Bad  option, returning BAD_FLAG_CODE\");\n+                return Err(BAD_FLAG_CODE);\n+            } else {\n+                cmd\n+            }\n+        }\n+    };\n+\n+    // Pop off all flags, plus the command\n+    let mut remaining_args: ~[~str] = args.iter().skip_while(|&s| {\n+        let maybe_command: Option<Command> = from_str(*s);\n+        maybe_command.is_none()\n+    }).map(|s| s.clone()).collect();\n+    remaining_args.shift();\n+\n+    let context = Context{\n+        rustc_flags: rustc_flags,\n+        cfgs: cfgs,\n+        use_rust_path_hack: use_rust_path_hack,\n+    };\n+    Ok(ParseResult {\n+        command:  command,\n+        args: remaining_args,\n+        context: context,\n+        sysroot: supplied_sysroot\n+    })\n+}\n+"}, {"sha": "a9f3a87dfdc07c8ac470353736d343d17010fb9f", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=55bb5e584cd9e15ac5970d86be1c5dbe96f75af7", "patch": "@@ -54,8 +54,8 @@ fn fake_ctxt(sysroot: Path, workspace: &Path) -> BuildContext {\n             rustc_flags: RustcFlags::default(),\n \n             use_rust_path_hack: false,\n-            sysroot: sysroot\n-        }\n+        },\n+        sysroot: sysroot\n     }\n }\n "}, {"sha": "85ddd3e58d4831dcc6b084b727035e56bd5e8c0e", "filename": "src/librustpkg/testsuite/pass/src/c-dependencies/pkg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs?ref=55bb5e584cd9e15ac5970d86be1c5dbe96f75af7", "patch": "@@ -58,7 +58,7 @@ pub fn main() {\n                                                            [~\"-c\"],\n                                                            [~\"foo.c\"],\n                                                            \"foo\");\n-            let out_p = Path::new(out_path);\n+            let out_p = Path::new(out_path.unwrap());\n             out_p.as_str().unwrap().to_owned()\n         };\n         out_path"}, {"sha": "63743160d12e1f7be52e761144a7bd44c6bb0807", "filename": "src/librustpkg/testsuite/pass/src/foo/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffoo%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffoo%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffoo%2Flib.rs?ref=55bb5e584cd9e15ac5970d86be1c5dbe96f75af7", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f() {}\n+pub fn f() {}"}, {"sha": "1d18a3aaa431597326d4193d23caa8fa77bc742a", "filename": "src/librustpkg/testsuite/pass/src/hello-world/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fhello-world%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fhello-world%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fhello-world%2Fmain.rs?ref=55bb5e584cd9e15ac5970d86be1c5dbe96f75af7", "patch": "@@ -19,5 +19,5 @@ The test runner should check that, after `rustpkg build hello-world`:\n */\n \n fn main() {\n-    println(~\"Hello world!\");\n+    println(\"Hello world!\");\n }"}, {"sha": "a886a7e0079d9b9730e1ca193151bed9539fafbe", "filename": "src/librustpkg/testsuite/pass/src/install-paths/bench.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Fbench.rs?ref=55bb5e584cd9e15ac5970d86be1c5dbe96f75af7", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #[bench]\n-fn g() {\n+pub fn g() {\n     let mut x = 0;\n     while(x < 1000) {\n         x += 1;"}, {"sha": "a41e99f6d663d461099883a7202e3ca4ef62fb25", "filename": "src/librustpkg/usage.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7/src%2Flibrustpkg%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7/src%2Flibrustpkg%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fusage.rs?ref=55bb5e584cd9e15ac5970d86be1c5dbe96f75af7", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use context::Command;\n+\n pub fn general() {\n     println(\"Usage: rustpkg [options] <cmd> [args..]\n \n@@ -154,3 +156,22 @@ This will turn the current working directory into a workspace. The first\n command you run when starting off a new project.\n \");\n }\n+\n+pub fn usage_for_command(command: Command){\n+    match command {\n+        BuildCmd => build(),\n+        CleanCmd => clean(),\n+        DoCmd => do_cmd(),\n+        InfoCmd => info(),\n+        InstallCmd => install(),\n+        ListCmd => list(),\n+        PreferCmd => prefer(),\n+        TestCmd => test(),\n+        InitCmd => init(),\n+        UninstallCmd => uninstall(),\n+        UnpreferCmd => unprefer(),\n+    };\n+}\n+\n+\n+"}, {"sha": "4c533860c5702b37a294c0ff5b0735d70ec89cab", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55bb5e584cd9e15ac5970d86be1c5dbe96f75af7/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=55bb5e584cd9e15ac5970d86be1c5dbe96f75af7", "patch": "@@ -41,13 +41,6 @@ pub use target::{lib_name_of, lib_crate_filename, WhatToBuild, MaybeCustom, Infe\n use workcache_support::{digest_file_with_date, digest_only_date};\n use messages::error;\n \n-// It would be nice to have the list of commands in just one place -- for example,\n-// you could update the match in rustpkg.rc but forget to update this list. I think\n-// that should be fixed.\n-static COMMANDS: &'static [&'static str] =\n-    &[\"build\", \"clean\", \"do\", \"info\", \"init\", \"install\", \"list\", \"prefer\", \"test\", \"uninstall\",\n-      \"unprefer\"];\n-\n \n pub type ExitCode = int; // For now\n \n@@ -63,10 +56,6 @@ impl ToStr for Pkg {\n     }\n }\n \n-pub fn is_cmd(cmd: &str) -> bool {\n-    COMMANDS.iter().any(|&c| c == cmd)\n-}\n-\n struct ListenerFn {\n     cmds: ~[~str],\n     span: codemap::Span,\n@@ -636,25 +625,6 @@ pub fn mk_string_lit(s: @str) -> ast::lit {\n     }\n }\n \n-#[cfg(test)]\n-mod test {\n-    use super::is_cmd;\n-\n-    #[test]\n-    fn test_is_cmd() {\n-        assert!(is_cmd(\"build\"));\n-        assert!(is_cmd(\"clean\"));\n-        assert!(is_cmd(\"do\"));\n-        assert!(is_cmd(\"info\"));\n-        assert!(is_cmd(\"install\"));\n-        assert!(is_cmd(\"prefer\"));\n-        assert!(is_cmd(\"test\"));\n-        assert!(is_cmd(\"uninstall\"));\n-        assert!(is_cmd(\"unprefer\"));\n-    }\n-\n-}\n-\n pub fn option_to_vec<T>(x: Option<T>) -> ~[T] {\n     match x {\n        Some(y) => ~[y],"}]}