{"sha": "d8d3ab96aa94423f1bdfbb605098a506ab5edc7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4ZDNhYjk2YWE5NDQyM2YxYmRmYmI2MDUwOThhNTA2YWI1ZWRjN2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-18T08:44:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-18T08:44:50Z"}, "message": "Auto merge of #80090 - jyn514:tcx-in-render, r=GuillaumeGomez\n\nPass a `TyCtxt` through to `FormatRender`\n\nThis is the next step after https://github.com/rust-lang/rust/pull/79957 for https://github.com/rust-lang/rust/issues/76382. Eventually I plan to use this to remove `stability`, `const_stability`, and `deprecation` from `Item`, but that needs more extensive changes (in particular, https://github.com/rust-lang/rust/pull/75355 or something like it).\n\nThis has no actual changes to behavior, it's just moving types around.\n\nccc https://github.com/rust-lang/rust/pull/80014#issuecomment-746810284", "tree": {"sha": "2936a3802e2b60ed442868598dfaab61b4005128", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2936a3802e2b60ed442868598dfaab61b4005128"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8d3ab96aa94423f1bdfbb605098a506ab5edc7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8d3ab96aa94423f1bdfbb605098a506ab5edc7e", "html_url": "https://github.com/rust-lang/rust/commit/d8d3ab96aa94423f1bdfbb605098a506ab5edc7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8d3ab96aa94423f1bdfbb605098a506ab5edc7e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fee693d08e98d25f566075cbed73e12236c05abd", "url": "https://api.github.com/repos/rust-lang/rust/commits/fee693d08e98d25f566075cbed73e12236c05abd", "html_url": "https://github.com/rust-lang/rust/commit/fee693d08e98d25f566075cbed73e12236c05abd"}, {"sha": "0c2f76a4bf515a9c1bdb930ffb7f32b7ba6bd726", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c2f76a4bf515a9c1bdb930ffb7f32b7ba6bd726", "html_url": "https://github.com/rust-lang/rust/commit/0c2f76a4bf515a9c1bdb930ffb7f32b7ba6bd726"}], "stats": {"total": 405, "additions": 226, "deletions": 179}, "files": [{"sha": "7e85342ac7d5d536502a9a7d9fcf59b12ba91a22", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 45, "deletions": 77, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/d8d3ab96aa94423f1bdfbb605098a506ab5edc7e/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d3ab96aa94423f1bdfbb605098a506ab5edc7e/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=d8d3ab96aa94423f1bdfbb605098a506ab5edc7e", "patch": "@@ -11,7 +11,7 @@ use rustc_hir::{\n     intravisit::{self, NestedVisitorMap, Visitor},\n     Path,\n };\n-use rustc_interface::interface;\n+use rustc_interface::{interface, Queries};\n use rustc_middle::hir::map::Map;\n use rustc_middle::middle::privacy::AccessLevels;\n use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n@@ -273,12 +273,9 @@ where\n     (lint_opts, lint_caps)\n }\n \n-crate fn run_core(\n-    options: RustdocOptions,\n-) -> (clean::Crate, RenderInfo, RenderOptions, Lrc<Session>) {\n-    // Parse, resolve, and typecheck the given crate.\n-\n-    let RustdocOptions {\n+/// Parse, resolve, and typecheck the given crate.\n+crate fn create_config(\n+    RustdocOptions {\n         input,\n         crate_name,\n         proc_macro_crate,\n@@ -294,21 +291,10 @@ crate fn run_core(\n         lint_opts,\n         describe_lints,\n         lint_cap,\n-        default_passes,\n-        manual_passes,\n         display_warnings,\n-        render_options,\n-        output_format,\n         ..\n-    } = options;\n-\n-    let extern_names: Vec<String> = externs\n-        .iter()\n-        .filter(|(_, entry)| entry.add_prelude)\n-        .map(|(name, _)| name)\n-        .cloned()\n-        .collect();\n-\n+    }: RustdocOptions,\n+) -> rustc_interface::Config {\n     // Add the doc cfg into the doc build.\n     cfgs.push(\"doc\".to_string());\n \n@@ -374,7 +360,7 @@ crate fn run_core(\n         ..Options::default()\n     };\n \n-    let config = interface::Config {\n+    interface::Config {\n         opts: sessopts,\n         crate_cfg: interface::parse_cfgspecs(cfgs),\n         input,\n@@ -417,68 +403,50 @@ crate fn run_core(\n         }),\n         make_codegen_backend: None,\n         registry: rustc_driver::diagnostics_registry(),\n-    };\n-\n-    interface::create_compiler_and_run(config, |compiler| {\n-        compiler.enter(|queries| {\n-            let sess = compiler.session();\n-\n-            // We need to hold on to the complete resolver, so we cause everything to be\n-            // cloned for the analysis passes to use. Suboptimal, but necessary in the\n-            // current architecture.\n-            let resolver = {\n-                let parts = abort_on_err(queries.expansion(), sess).peek();\n-                let resolver = parts.1.borrow();\n-\n-                // Before we actually clone it, let's force all the extern'd crates to\n-                // actually be loaded, just in case they're only referred to inside\n-                // intra-doc-links\n-                resolver.borrow_mut().access(|resolver| {\n-                    sess.time(\"load_extern_crates\", || {\n-                        for extern_name in &extern_names {\n-                            debug!(\"loading extern crate {}\", extern_name);\n-                            resolver\n-                                .resolve_str_path_error(\n-                                    DUMMY_SP,\n-                                    extern_name,\n-                                    TypeNS,\n-                                    LocalDefId { local_def_index: CRATE_DEF_INDEX }.to_def_id(),\n-                                )\n-                                .unwrap_or_else(|()| {\n-                                    panic!(\"Unable to resolve external crate {}\", extern_name)\n-                                });\n-                        }\n-                    });\n-                });\n+    }\n+}\n \n-                // Now we're good to clone the resolver because everything should be loaded\n-                resolver.clone()\n-            };\n+crate fn create_resolver<'a>(\n+    externs: config::Externs,\n+    queries: &Queries<'a>,\n+    sess: &Session,\n+) -> Rc<RefCell<interface::BoxedResolver>> {\n+    let extern_names: Vec<String> = externs\n+        .iter()\n+        .filter(|(_, entry)| entry.add_prelude)\n+        .map(|(name, _)| name)\n+        .cloned()\n+        .collect();\n \n-            if sess.has_errors() {\n-                sess.fatal(\"Compilation failed, aborting rustdoc\");\n+    let parts = abort_on_err(queries.expansion(), sess).peek();\n+    let resolver = parts.1.borrow();\n+\n+    // Before we actually clone it, let's force all the extern'd crates to\n+    // actually be loaded, just in case they're only referred to inside\n+    // intra-doc-links\n+    resolver.borrow_mut().access(|resolver| {\n+        sess.time(\"load_extern_crates\", || {\n+            for extern_name in &extern_names {\n+                debug!(\"loading extern crate {}\", extern_name);\n+                resolver\n+                    .resolve_str_path_error(\n+                        DUMMY_SP,\n+                        extern_name,\n+                        TypeNS,\n+                        LocalDefId { local_def_index: CRATE_DEF_INDEX }.to_def_id(),\n+                    )\n+                    .unwrap_or_else(|()| {\n+                        panic!(\"Unable to resolve external crate {}\", extern_name)\n+                    });\n             }\n+        });\n+    });\n \n-            let mut global_ctxt = abort_on_err(queries.global_ctxt(), sess).take();\n-\n-            let (krate, render_info, opts) = sess.time(\"run_global_ctxt\", || {\n-                global_ctxt.enter(|tcx| {\n-                    run_global_ctxt(\n-                        tcx,\n-                        resolver,\n-                        default_passes,\n-                        manual_passes,\n-                        render_options,\n-                        output_format,\n-                    )\n-                })\n-            });\n-            (krate, render_info, opts, Lrc::clone(sess))\n-        })\n-    })\n+    // Now we're good to clone the resolver because everything should be loaded\n+    resolver.clone()\n }\n \n-fn run_global_ctxt(\n+crate fn run_global_ctxt(\n     tcx: TyCtxt<'_>,\n     resolver: Rc<RefCell<interface::BoxedResolver>>,\n     mut default_passes: passes::DefaultPassOption,"}, {"sha": "fbbd3c1ccf5140530fd73a8975dae619219e8bb8", "filename": "src/librustdoc/formats/renderer.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d8d3ab96aa94423f1bdfbb605098a506ab5edc7e/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d3ab96aa94423f1bdfbb605098a506ab5edc7e/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Frenderer.rs?ref=d8d3ab96aa94423f1bdfbb605098a506ab5edc7e", "patch": "@@ -1,7 +1,6 @@\n use std::sync::Arc;\n \n-use rustc_data_structures::sync::Lrc;\n-use rustc_session::Session;\n+use rustc_middle::ty;\n use rustc_span::edition::Edition;\n \n use crate::clean;\n@@ -12,7 +11,7 @@ use crate::formats::cache::{Cache, CACHE_KEY};\n /// Allows for different backends to rustdoc to be used with the `run_format()` function. Each\n /// backend renderer has hooks for initialization, documenting an item, entering and exiting a\n /// module, and cleanup/finalizing output.\n-crate trait FormatRenderer: Clone {\n+crate trait FormatRenderer<'tcx>: Clone {\n     /// Sets up any state required for the renderer. When this is called the cache has already been\n     /// populated.\n     fn init(\n@@ -21,7 +20,7 @@ crate trait FormatRenderer: Clone {\n         render_info: RenderInfo,\n         edition: Edition,\n         cache: &mut Cache,\n-        sess: Lrc<Session>,\n+        tcx: ty::TyCtxt<'tcx>,\n     ) -> Result<(Self, clean::Crate), Error>;\n \n     /// Renders a single non-module item. This means no recursive sub-item rendering is required.\n@@ -46,13 +45,13 @@ crate trait FormatRenderer: Clone {\n }\n \n /// Main method for rendering a crate.\n-crate fn run_format<T: FormatRenderer>(\n+crate fn run_format<'tcx, T: FormatRenderer<'tcx>>(\n     krate: clean::Crate,\n     options: RenderOptions,\n     render_info: RenderInfo,\n     diag: &rustc_errors::Handler,\n     edition: Edition,\n-    sess: Lrc<Session>,\n+    tcx: ty::TyCtxt<'tcx>,\n ) -> Result<(), Error> {\n     let (krate, mut cache) = Cache::from_krate(\n         render_info.clone(),\n@@ -63,7 +62,7 @@ crate fn run_format<T: FormatRenderer>(\n     );\n \n     let (mut format_renderer, mut krate) =\n-        T::init(krate, options, render_info, edition, &mut cache, sess)?;\n+        T::init(krate, options, render_info, edition, &mut cache, tcx)?;\n \n     let cache = Arc::new(cache);\n     // Freeze the cache now that the index has been built. Put an Arc into TLS for future"}, {"sha": "67ccc3d4cf8d45e4968e262ba4b7462da47ad97d", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 77, "deletions": 48, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/d8d3ab96aa94423f1bdfbb605098a506ab5edc7e/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d3ab96aa94423f1bdfbb605098a506ab5edc7e/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=d8d3ab96aa94423f1bdfbb605098a506ab5edc7e", "patch": "@@ -52,11 +52,12 @@ use rustc_ast_pretty::pprust;\n use rustc_attr::{Deprecation, StabilityLevel};\n use rustc_data_structures::flock;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::Mutability;\n use rustc_middle::middle::stability;\n+use rustc_middle::ty;\n+use rustc_middle::ty::TyCtxt;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::MacroKind;\n@@ -102,7 +103,7 @@ crate fn ensure_trailing_slash(v: &str) -> impl fmt::Display + '_ {\n /// easily cloned because it is cloned per work-job (about once per item in the\n /// rustdoc tree).\n #[derive(Clone)]\n-crate struct Context {\n+crate struct Context<'tcx> {\n     /// Current hierarchy of components leading down to what's currently being\n     /// rendered\n     crate current: Vec<String>,\n@@ -115,15 +116,15 @@ crate struct Context {\n     crate render_redirect_pages: bool,\n     /// The map used to ensure all generated 'id=' attributes are unique.\n     id_map: Rc<RefCell<IdMap>>,\n-    crate shared: Arc<SharedContext>,\n+    crate shared: Arc<SharedContext<'tcx>>,\n     all: Rc<RefCell<AllTypes>>,\n     /// Storage for the errors produced while generating documentation so they\n     /// can be printed together at the end.\n     crate errors: Rc<Receiver<String>>,\n }\n \n-crate struct SharedContext {\n-    crate sess: Lrc<Session>,\n+crate struct SharedContext<'tcx> {\n+    crate tcx: TyCtxt<'tcx>,\n     /// The path to the crate root source minus the file name.\n     /// Used for simplifying paths to the highlighted source code files.\n     crate src_root: PathBuf,\n@@ -163,7 +164,7 @@ crate struct SharedContext {\n     playground: Option<markdown::Playground>,\n }\n \n-impl Context {\n+impl Context<'_> {\n     fn path(&self, filename: &str) -> PathBuf {\n         // We use splitn vs Path::extension here because we might get a filename\n         // like `style.min.css` and we want to process that into\n@@ -176,11 +177,11 @@ impl Context {\n     }\n \n     fn sess(&self) -> &Session {\n-        &self.shared.sess\n+        &self.shared.tcx.sess\n     }\n }\n \n-impl SharedContext {\n+impl SharedContext<'_> {\n     crate fn ensure_dir(&self, dst: &Path) -> Result<(), Error> {\n         let mut dirs = self.created_dirs.borrow_mut();\n         if !dirs.contains(dst) {\n@@ -381,15 +382,15 @@ crate fn initial_ids() -> Vec<String> {\n }\n \n /// Generates the documentation for `crate` into the directory `dst`\n-impl FormatRenderer for Context {\n+impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n     fn init(\n         mut krate: clean::Crate,\n         options: RenderOptions,\n         _render_info: RenderInfo,\n         edition: Edition,\n         cache: &mut Cache,\n-        sess: Lrc<Session>,\n-    ) -> Result<(Context, clean::Crate), Error> {\n+        tcx: ty::TyCtxt<'tcx>,\n+    ) -> Result<(Self, clean::Crate), Error> {\n         // need to save a copy of the options for rendering the index page\n         let md_opts = options.clone();\n         let RenderOptions {\n@@ -462,7 +463,7 @@ impl FormatRenderer for Context {\n         }\n         let (sender, receiver) = channel();\n         let mut scx = SharedContext {\n-            sess,\n+            tcx,\n             collapsed: krate.collapsed,\n             src_root,\n             include_sources,\n@@ -688,7 +689,7 @@ impl FormatRenderer for Context {\n }\n \n fn write_shared(\n-    cx: &Context,\n+    cx: &Context<'_>,\n     krate: &clean::Crate,\n     search_index: String,\n     options: &RenderOptions,\n@@ -1205,7 +1206,7 @@ fn write_minify(\n     }\n }\n \n-fn write_srclink(cx: &Context, item: &clean::Item, buf: &mut Buffer, cache: &Cache) {\n+fn write_srclink(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer, cache: &Cache) {\n     if let Some(l) = cx.src_href(item, cache) {\n         write!(\n             buf,\n@@ -1516,7 +1517,7 @@ fn settings(root_path: &str, suffix: &str, themes: &[StylePath]) -> Result<Strin\n     ))\n }\n \n-impl Context {\n+impl Context<'_> {\n     fn derive_id(&self, id: String) -> String {\n         let mut map = self.id_map.borrow_mut();\n         map.derive(id)\n@@ -1701,7 +1702,7 @@ where\n     write!(w, \"</div>\")\n }\n \n-fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer, cache: &Cache) {\n+fn print_item(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer, cache: &Cache) {\n     debug_assert!(!item.is_stripped());\n     // Write the breadcrumb trail header for the top\n     write!(buf, \"<h1 class=\\\"fqn\\\"><span class=\\\"out-of-band\\\">\");\n@@ -1816,14 +1817,14 @@ fn item_path(ty: ItemType, name: &str) -> String {\n     }\n }\n \n-fn full_path(cx: &Context, item: &clean::Item) -> String {\n+fn full_path(cx: &Context<'_>, item: &clean::Item) -> String {\n     let mut s = cx.current.join(\"::\");\n     s.push_str(\"::\");\n     s.push_str(&item.name.unwrap().as_str());\n     s\n }\n \n-fn document(w: &mut Buffer, cx: &Context, item: &clean::Item, parent: Option<&clean::Item>) {\n+fn document(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, parent: Option<&clean::Item>) {\n     if let Some(ref name) = item.name {\n         info!(\"Documenting {}\", name);\n     }\n@@ -1834,7 +1835,7 @@ fn document(w: &mut Buffer, cx: &Context, item: &clean::Item, parent: Option<&cl\n /// Render md_text as markdown.\n fn render_markdown(\n     w: &mut Buffer,\n-    cx: &Context,\n+    cx: &Context<'_>,\n     md_text: &str,\n     links: Vec<RenderedLink>,\n     prefix: &str,\n@@ -1863,7 +1864,7 @@ fn render_markdown(\n fn document_short(\n     w: &mut Buffer,\n     item: &clean::Item,\n-    cx: &Context,\n+    cx: &Context<'_>,\n     link: AssocItemLink<'_>,\n     prefix: &str,\n     is_hidden: bool,\n@@ -1904,7 +1905,13 @@ fn document_short(\n     }\n }\n \n-fn document_full(w: &mut Buffer, item: &clean::Item, cx: &Context, prefix: &str, is_hidden: bool) {\n+fn document_full(\n+    w: &mut Buffer,\n+    item: &clean::Item,\n+    cx: &Context<'_>,\n+    prefix: &str,\n+    is_hidden: bool,\n+) {\n     if let Some(s) = cx.shared.maybe_collapsed_doc_value(item) {\n         debug!(\"Doc block: =====\\n{}\\n=====\", s);\n         render_markdown(w, cx, &*s, item.links(), prefix, is_hidden);\n@@ -1925,7 +1932,7 @@ fn document_full(w: &mut Buffer, item: &clean::Item, cx: &Context, prefix: &str,\n /// * Required features (through the `doc_cfg` feature)\n fn document_item_info(\n     w: &mut Buffer,\n-    cx: &Context,\n+    cx: &Context<'_>,\n     item: &clean::Item,\n     is_hidden: bool,\n     parent: Option<&clean::Item>,\n@@ -2029,7 +2036,7 @@ crate fn compare_names(mut lhs: &str, mut rhs: &str) -> Ordering {\n     Ordering::Equal\n }\n \n-fn item_module(w: &mut Buffer, cx: &Context, item: &clean::Item, items: &[clean::Item]) {\n+fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[clean::Item]) {\n     document(w, cx, item, None);\n \n     let mut indices = (0..items.len()).filter(|i| !items[*i].is_stripped()).collect::<Vec<usize>>();\n@@ -2271,7 +2278,11 @@ fn portability(item: &clean::Item, parent: Option<&clean::Item>) -> Option<Strin\n \n /// Render the stability, deprecation and portability information that is displayed at the top of\n /// the item's documentation.\n-fn short_item_info(item: &clean::Item, cx: &Context, parent: Option<&clean::Item>) -> Vec<String> {\n+fn short_item_info(\n+    item: &clean::Item,\n+    cx: &Context<'_>,\n+    parent: Option<&clean::Item>,\n+) -> Vec<String> {\n     let mut extra_info = vec![];\n     let error_codes = cx.shared.codes;\n \n@@ -2361,7 +2372,7 @@ fn short_item_info(item: &clean::Item, cx: &Context, parent: Option<&clean::Item\n     extra_info\n }\n \n-fn item_constant(w: &mut Buffer, cx: &Context, it: &clean::Item, c: &clean::Constant) {\n+fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::Constant) {\n     write!(w, \"<pre class=\\\"rust const\\\">\");\n     render_attributes(w, it, false);\n \n@@ -2396,7 +2407,7 @@ fn item_constant(w: &mut Buffer, cx: &Context, it: &clean::Item, c: &clean::Cons\n     document(w, cx, it, None)\n }\n \n-fn item_static(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Static) {\n+fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Static) {\n     write!(w, \"<pre class=\\\"rust static\\\">\");\n     render_attributes(w, it, false);\n     write!(\n@@ -2410,7 +2421,7 @@ fn item_static(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Static\n     document(w, cx, it, None)\n }\n \n-fn item_function(w: &mut Buffer, cx: &Context, it: &clean::Item, f: &clean::Function) {\n+fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::Function) {\n     let header_len = format!(\n         \"{}{}{}{}{:#}fn {}{:#}\",\n         it.visibility.print_with_space(),\n@@ -2444,7 +2455,7 @@ fn item_function(w: &mut Buffer, cx: &Context, it: &clean::Item, f: &clean::Func\n }\n \n fn render_implementor(\n-    cx: &Context,\n+    cx: &Context<'_>,\n     implementor: &Impl,\n     parent: &clean::Item,\n     w: &mut Buffer,\n@@ -2481,7 +2492,7 @@ fn render_implementor(\n }\n \n fn render_impls(\n-    cx: &Context,\n+    cx: &Context<'_>,\n     w: &mut Buffer,\n     traits: &[&&Impl],\n     containing_item: &clean::Item,\n@@ -2540,7 +2551,7 @@ fn compare_impl<'a, 'b>(lhs: &'a &&Impl, rhs: &'b &&Impl) -> Ordering {\n     compare_names(&lhs, &rhs)\n }\n \n-fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait, cache: &Cache) {\n+fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Trait, cache: &Cache) {\n     let bounds = bounds(&t.bounds, false);\n     let types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n     let consts = t.items.iter().filter(|m| m.is_associated_const()).collect::<Vec<_>>();\n@@ -2636,7 +2647,13 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait,\n         write!(w, \"{}<span class=\\\"loading-content\\\">Loading content...</span>\", extra_content)\n     }\n \n-    fn trait_item(w: &mut Buffer, cx: &Context, m: &clean::Item, t: &clean::Item, cache: &Cache) {\n+    fn trait_item(\n+        w: &mut Buffer,\n+        cx: &Context<'_>,\n+        m: &clean::Item,\n+        t: &clean::Item,\n+        cache: &Cache,\n+    ) {\n         let name = m.name.as_ref().unwrap();\n         info!(\"Documenting {} on {:?}\", name, t.name);\n         let item_type = m.type_();\n@@ -3039,7 +3056,13 @@ fn render_assoc_item(\n     }\n }\n \n-fn item_struct(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Struct, cache: &Cache) {\n+fn item_struct(\n+    w: &mut Buffer,\n+    cx: &Context<'_>,\n+    it: &clean::Item,\n+    s: &clean::Struct,\n+    cache: &Cache,\n+) {\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class=\\\"rust struct\\\">\");\n         render_attributes(w, it, true);\n@@ -3089,7 +3112,7 @@ fn item_struct(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Struct\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n-fn item_union(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Union, cache: &Cache) {\n+fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Union, cache: &Cache) {\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class=\\\"rust union\\\">\");\n         render_attributes(w, it, true);\n@@ -3135,7 +3158,7 @@ fn item_union(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Union,\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n-fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum, cache: &Cache) {\n+fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum, cache: &Cache) {\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class=\\\"rust enum\\\">\");\n         render_attributes(w, it, true);\n@@ -3443,7 +3466,7 @@ impl<'a> AssocItemLink<'a> {\n \n fn render_assoc_items(\n     w: &mut Buffer,\n-    cx: &Context,\n+    cx: &Context<'_>,\n     containing_item: &clean::Item,\n     it: DefId,\n     what: AssocItemRender<'_>,\n@@ -3559,7 +3582,7 @@ fn render_assoc_items(\n \n fn render_deref_methods(\n     w: &mut Buffer,\n-    cx: &Context,\n+    cx: &Context<'_>,\n     impl_: &Impl,\n     container_item: &clean::Item,\n     deref_mut: bool,\n@@ -3675,7 +3698,7 @@ fn spotlight_decl(decl: &clean::FnDecl) -> String {\n \n fn render_impl(\n     w: &mut Buffer,\n-    cx: &Context,\n+    cx: &Context<'_>,\n     i: &Impl,\n     parent: &clean::Item,\n     link: AssocItemLink<'_>,\n@@ -3769,7 +3792,7 @@ fn render_impl(\n \n     fn doc_impl_item(\n         w: &mut Buffer,\n-        cx: &Context,\n+        cx: &Context<'_>,\n         item: &clean::Item,\n         parent: &clean::Item,\n         link: AssocItemLink<'_>,\n@@ -3906,7 +3929,7 @@ fn render_impl(\n \n     fn render_default_items(\n         w: &mut Buffer,\n-        cx: &Context,\n+        cx: &Context<'_>,\n         t: &clean::Trait,\n         i: &clean::Impl,\n         parent: &clean::Item,\n@@ -3966,7 +3989,7 @@ fn render_impl(\n \n fn item_opaque_ty(\n     w: &mut Buffer,\n-    cx: &Context,\n+    cx: &Context<'_>,\n     it: &clean::Item,\n     t: &clean::OpaqueTy,\n     cache: &Cache,\n@@ -3993,7 +4016,7 @@ fn item_opaque_ty(\n \n fn item_trait_alias(\n     w: &mut Buffer,\n-    cx: &Context,\n+    cx: &Context<'_>,\n     it: &clean::Item,\n     t: &clean::TraitAlias,\n     cache: &Cache,\n@@ -4018,7 +4041,13 @@ fn item_trait_alias(\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n-fn item_typedef(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Typedef, cache: &Cache) {\n+fn item_typedef(\n+    w: &mut Buffer,\n+    cx: &Context<'_>,\n+    it: &clean::Item,\n+    t: &clean::Typedef,\n+    cache: &Cache,\n+) {\n     write!(w, \"<pre class=\\\"rust typedef\\\">\");\n     render_attributes(w, it, false);\n     write!(\n@@ -4039,7 +4068,7 @@ fn item_typedef(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Typed\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n-fn item_foreign_type(w: &mut Buffer, cx: &Context, it: &clean::Item, cache: &Cache) {\n+fn item_foreign_type(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, cache: &Cache) {\n     writeln!(w, \"<pre class=\\\"rust foreigntype\\\">extern {{\");\n     render_attributes(w, it, false);\n     write!(\n@@ -4054,7 +4083,7 @@ fn item_foreign_type(w: &mut Buffer, cx: &Context, it: &clean::Item, cache: &Cac\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n-fn print_sidebar(cx: &Context, it: &clean::Item, buffer: &mut Buffer, cache: &Cache) {\n+fn print_sidebar(cx: &Context<'_>, it: &clean::Item, buffer: &mut Buffer, cache: &Cache) {\n     let parentlen = cx.current.len() - if it.is_mod() { 1 } else { 0 };\n \n     if it.is_struct()\n@@ -4685,7 +4714,7 @@ fn sidebar_foreign_type(buf: &mut Buffer, it: &clean::Item) {\n     }\n }\n \n-fn item_macro(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Macro) {\n+fn item_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Macro) {\n     wrap_into_docblock(w, |w| {\n         w.write_str(&highlight::render_with_highlighting(\n             t.source.clone(),\n@@ -4697,7 +4726,7 @@ fn item_macro(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Macro)\n     document(w, cx, it, None)\n }\n \n-fn item_proc_macro(w: &mut Buffer, cx: &Context, it: &clean::Item, m: &clean::ProcMacro) {\n+fn item_proc_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, m: &clean::ProcMacro) {\n     let name = it.name.as_ref().expect(\"proc-macros always have names\");\n     match m.kind {\n         MacroKind::Bang => {\n@@ -4727,12 +4756,12 @@ fn item_proc_macro(w: &mut Buffer, cx: &Context, it: &clean::Item, m: &clean::Pr\n     document(w, cx, it, None)\n }\n \n-fn item_primitive(w: &mut Buffer, cx: &Context, it: &clean::Item, cache: &Cache) {\n+fn item_primitive(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, cache: &Cache) {\n     document(w, cx, it, None);\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n-fn item_keyword(w: &mut Buffer, cx: &Context, it: &clean::Item) {\n+fn item_keyword(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n     document(w, cx, it, None)\n }\n "}, {"sha": "87934c8a0e50ea82df2165d2a5675bf15c6c3405", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d8d3ab96aa94423f1bdfbb605098a506ab5edc7e/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d3ab96aa94423f1bdfbb605098a506ab5edc7e/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=d8d3ab96aa94423f1bdfbb605098a506ab5edc7e", "patch": "@@ -15,7 +15,7 @@ use std::path::{Component, Path, PathBuf};\n \n crate fn render(\n     dst: &Path,\n-    scx: &mut SharedContext,\n+    scx: &mut SharedContext<'_>,\n     krate: clean::Crate,\n ) -> Result<clean::Crate, Error> {\n     info!(\"emitting source files\");\n@@ -26,14 +26,14 @@ crate fn render(\n }\n \n /// Helper struct to render all source code to HTML pages\n-struct SourceCollector<'a> {\n-    scx: &'a mut SharedContext,\n+struct SourceCollector<'a, 'tcx> {\n+    scx: &'a mut SharedContext<'tcx>,\n \n     /// Root destination to place all HTML output into\n     dst: PathBuf,\n }\n \n-impl<'a> DocFolder for SourceCollector<'a> {\n+impl DocFolder for SourceCollector<'_, '_> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         // If we're not rendering sources, there's nothing to do.\n         // If we're including source files, and we haven't seen this file yet,\n@@ -69,9 +69,9 @@ impl<'a> DocFolder for SourceCollector<'a> {\n     }\n }\n \n-impl<'a> SourceCollector<'a> {\n+impl SourceCollector<'_, '_> {\n     fn sess(&self) -> &Session {\n-        &self.scx.sess\n+        &self.scx.tcx.sess\n     }\n \n     /// Renders the given filename into its corresponding HTML source file."}, {"sha": "99587f4ec64e9280744bc392f26cb2ab57e83097", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8d3ab96aa94423f1bdfbb605098a506ab5edc7e/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d3ab96aa94423f1bdfbb605098a506ab5edc7e/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=d8d3ab96aa94423f1bdfbb605098a506ab5edc7e", "patch": "@@ -14,7 +14,7 @@ use crate::formats::item_type::ItemType;\n use crate::json::types::*;\n use crate::json::JsonRenderer;\n \n-impl JsonRenderer {\n+impl JsonRenderer<'_> {\n     pub(super) fn convert_item(&self, item: clean::Item) -> Option<Item> {\n         let item_type = ItemType::from(&item);\n         let clean::Item {\n@@ -57,10 +57,10 @@ impl JsonRenderer {\n     }\n \n     fn convert_span(&self, span: clean::Span) -> Option<Span> {\n-        match span.filename(&self.sess) {\n+        match span.filename(self.sess()) {\n             rustc_span::FileName::Real(name) => {\n-                let hi = span.hi(&self.sess);\n-                let lo = span.lo(&self.sess);\n+                let hi = span.hi(self.sess());\n+                let lo = span.lo(self.sess());\n                 Some(Span {\n                     filename: match name {\n                         rustc_span::RealFileName::Named(path) => path,"}, {"sha": "dc2bc14e7ceb9074a73b54b6ecf9c42bf72509e8", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d8d3ab96aa94423f1bdfbb605098a506ab5edc7e/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d3ab96aa94423f1bdfbb605098a506ab5edc7e/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=d8d3ab96aa94423f1bdfbb605098a506ab5edc7e", "patch": "@@ -13,7 +13,7 @@ use std::path::PathBuf;\n use std::rc::Rc;\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::Lrc;\n+use rustc_middle::ty;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n \n@@ -25,16 +25,20 @@ use crate::formats::FormatRenderer;\n use crate::html::render::cache::ExternalLocation;\n \n #[derive(Clone)]\n-crate struct JsonRenderer {\n-    sess: Lrc<Session>,\n+crate struct JsonRenderer<'tcx> {\n+    tcx: ty::TyCtxt<'tcx>,\n     /// A mapping of IDs that contains all local items for this crate which gets output as a top\n     /// level field of the JSON blob.\n     index: Rc<RefCell<FxHashMap<types::Id, types::Item>>>,\n     /// The directory where the blob will be written to.\n     out_path: PathBuf,\n }\n \n-impl JsonRenderer {\n+impl JsonRenderer<'_> {\n+    fn sess(&self) -> &Session {\n+        self.tcx.sess\n+    }\n+\n     fn get_trait_implementors(\n         &mut self,\n         id: rustc_span::def_id::DefId,\n@@ -120,19 +124,19 @@ impl JsonRenderer {\n     }\n }\n \n-impl FormatRenderer for JsonRenderer {\n+impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n     fn init(\n         krate: clean::Crate,\n         options: RenderOptions,\n         _render_info: RenderInfo,\n         _edition: Edition,\n         _cache: &mut Cache,\n-        sess: Lrc<Session>,\n+        tcx: ty::TyCtxt<'tcx>,\n     ) -> Result<(Self, clean::Crate), Error> {\n         debug!(\"Initializing json renderer\");\n         Ok((\n             JsonRenderer {\n-                sess,\n+                tcx,\n                 index: Rc::new(RefCell::new(FxHashMap::default())),\n                 out_path: options.output,\n             },"}, {"sha": "72f1b817d5d87ee7adc1ea33664a24795c7b5f0d", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 77, "deletions": 30, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/d8d3ab96aa94423f1bdfbb605098a506ab5edc7e/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8d3ab96aa94423f1bdfbb605098a506ab5edc7e/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=d8d3ab96aa94423f1bdfbb605098a506ab5edc7e", "patch": "@@ -62,11 +62,12 @@ use std::default::Default;\n use std::env;\n use std::process;\n \n-use rustc_data_structures::sync::Lrc;\n+use rustc_driver::abort_on_err;\n use rustc_errors::ErrorReported;\n+use rustc_interface::interface;\n+use rustc_middle::ty;\n use rustc_session::config::{make_crate_type_option, ErrorOutputType, RustcOptGroup};\n use rustc_session::getopts;\n-use rustc_session::Session;\n use rustc_session::{early_error, early_warn};\n \n #[macro_use]\n@@ -468,15 +469,15 @@ fn wrap_return(diag: &rustc_errors::Handler, res: Result<(), String>) -> MainRes\n     }\n }\n \n-fn run_renderer<T: formats::FormatRenderer>(\n+fn run_renderer<'tcx, T: formats::FormatRenderer<'tcx>>(\n     krate: clean::Crate,\n     renderopts: config::RenderOptions,\n     render_info: config::RenderInfo,\n     diag: &rustc_errors::Handler,\n     edition: rustc_span::edition::Edition,\n-    sess: Lrc<Session>,\n+    tcx: ty::TyCtxt<'tcx>,\n ) -> MainResult {\n-    match formats::run_format::<T>(krate, renderopts, render_info, &diag, edition, sess) {\n+    match formats::run_format::<T>(krate, renderopts, render_info, &diag, edition, tcx) {\n         Ok(_) => Ok(()),\n         Err(e) => {\n             let mut msg = diag.struct_err(&format!(\"couldn't generate documentation: {}\", e.error));\n@@ -520,34 +521,80 @@ fn main_options(options: config::Options) -> MainResult {\n     // then generated from the cleaned AST of the crate. This runs all the\n     // plug/cleaning passes.\n     let crate_version = options.crate_version.clone();\n+\n+    let default_passes = options.default_passes;\n     let output_format = options.output_format;\n-    let (mut krate, renderinfo, renderopts, sess) = core::run_core(options);\n+    // FIXME: fix this clone (especially render_options)\n+    let externs = options.externs.clone();\n+    let manual_passes = options.manual_passes.clone();\n+    let render_options = options.render_options.clone();\n+    let config = core::create_config(options);\n \n-    info!(\"finished with rustc\");\n+    interface::create_compiler_and_run(config, |compiler| {\n+        compiler.enter(|queries| {\n+            let sess = compiler.session();\n \n-    krate.version = crate_version;\n+            // We need to hold on to the complete resolver, so we cause everything to be\n+            // cloned for the analysis passes to use. Suboptimal, but necessary in the\n+            // current architecture.\n+            let resolver = core::create_resolver(externs, queries, &sess);\n \n-    if show_coverage {\n-        // if we ran coverage, bail early, we don't need to also generate docs at this point\n-        // (also we didn't load in any of the useful passes)\n-        return Ok(());\n-    } else if run_check {\n-        // Since we're in \"check\" mode, no need to generate anything beyond this point.\n-        return Ok(());\n-    }\n+            if sess.has_errors() {\n+                sess.fatal(\"Compilation failed, aborting rustdoc\");\n+            }\n \n-    info!(\"going to format\");\n-    let (error_format, edition, debugging_options) = diag_opts;\n-    let diag = core::new_handler(error_format, None, &debugging_options);\n-    let sess_time = sess.clone();\n-    match output_format {\n-        None | Some(config::OutputFormat::Html) => sess_time.time(\"render_html\", || {\n-            run_renderer::<html::render::Context>(\n-                krate, renderopts, renderinfo, &diag, edition, sess,\n-            )\n-        }),\n-        Some(config::OutputFormat::Json) => sess_time.time(\"render_json\", || {\n-            run_renderer::<json::JsonRenderer>(krate, renderopts, renderinfo, &diag, edition, sess)\n-        }),\n-    }\n+            let mut global_ctxt = abort_on_err(queries.global_ctxt(), sess).take();\n+\n+            global_ctxt.enter(|tcx| {\n+                let (mut krate, render_info, render_opts) = sess.time(\"run_global_ctxt\", || {\n+                    core::run_global_ctxt(\n+                        tcx,\n+                        resolver,\n+                        default_passes,\n+                        manual_passes,\n+                        render_options,\n+                        output_format,\n+                    )\n+                });\n+                info!(\"finished with rustc\");\n+\n+                krate.version = crate_version;\n+\n+                if show_coverage {\n+                    // if we ran coverage, bail early, we don't need to also generate docs at this point\n+                    // (also we didn't load in any of the useful passes)\n+                    return Ok(());\n+                } else if run_check {\n+                    // Since we're in \"check\" mode, no need to generate anything beyond this point.\n+                    return Ok(());\n+                }\n+\n+                info!(\"going to format\");\n+                let (error_format, edition, debugging_options) = diag_opts;\n+                let diag = core::new_handler(error_format, None, &debugging_options);\n+                match output_format {\n+                    None | Some(config::OutputFormat::Html) => sess.time(\"render_html\", || {\n+                        run_renderer::<html::render::Context<'_>>(\n+                            krate,\n+                            render_opts,\n+                            render_info,\n+                            &diag,\n+                            edition,\n+                            tcx,\n+                        )\n+                    }),\n+                    Some(config::OutputFormat::Json) => sess.time(\"render_json\", || {\n+                        run_renderer::<json::JsonRenderer<'_>>(\n+                            krate,\n+                            render_opts,\n+                            render_info,\n+                            &diag,\n+                            edition,\n+                            tcx,\n+                        )\n+                    }),\n+                }\n+            })\n+        })\n+    })\n }"}]}