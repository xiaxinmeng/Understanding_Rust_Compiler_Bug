{"sha": "bd8497884c2863a10b6d67855bd90d40783ce2da", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkODQ5Nzg4NGMyODYzYTEwYjZkNjc4NTViZDkwZDQwNzgzY2UyZGE=", "commit": {"author": {"name": "johnthagen", "email": "johnthagen@users.noreply.github.com", "date": "2017-10-16T21:56:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-10-16T21:56:12Z"}, "message": "Merge branch 'master' into future_imports", "tree": {"sha": "5fe9ffe7f65dbea1130217b5136264d4dbc7b513", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5fe9ffe7f65dbea1130217b5136264d4dbc7b513"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd8497884c2863a10b6d67855bd90d40783ce2da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd8497884c2863a10b6d67855bd90d40783ce2da", "html_url": "https://github.com/rust-lang/rust/commit/bd8497884c2863a10b6d67855bd90d40783ce2da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd8497884c2863a10b6d67855bd90d40783ce2da/comments", "author": {"login": "johnthagen", "id": 10340167, "node_id": "MDQ6VXNlcjEwMzQwMTY3", "avatar_url": "https://avatars.githubusercontent.com/u/10340167?v=4", "gravatar_id": "", "url": "https://api.github.com/users/johnthagen", "html_url": "https://github.com/johnthagen", "followers_url": "https://api.github.com/users/johnthagen/followers", "following_url": "https://api.github.com/users/johnthagen/following{/other_user}", "gists_url": "https://api.github.com/users/johnthagen/gists{/gist_id}", "starred_url": "https://api.github.com/users/johnthagen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/johnthagen/subscriptions", "organizations_url": "https://api.github.com/users/johnthagen/orgs", "repos_url": "https://api.github.com/users/johnthagen/repos", "events_url": "https://api.github.com/users/johnthagen/events{/privacy}", "received_events_url": "https://api.github.com/users/johnthagen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49a73d0901a60b1b77452b92372fd8629f636c2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/49a73d0901a60b1b77452b92372fd8629f636c2a", "html_url": "https://github.com/rust-lang/rust/commit/49a73d0901a60b1b77452b92372fd8629f636c2a"}, {"sha": "4e9527cf6f2d3749554d07a96fe14967f5470ef6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e9527cf6f2d3749554d07a96fe14967f5470ef6", "html_url": "https://github.com/rust-lang/rust/commit/4e9527cf6f2d3749554d07a96fe14967f5470ef6"}], "stats": {"total": 12831, "additions": 8886, "deletions": 3945}, "files": [{"sha": "4fc003036e9b3601a79f18815dd48385d3e97f04", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -16,6 +16,7 @@ Read [\"Installation\"] from [The Book].\n ## Building from Source\n [building-from-source]: #building-from-source\n \n+### Building on *nix\n 1. Make sure you have installed the dependencies:\n \n    * `g++` 4.7 or later or `clang++` 3.x or later\n@@ -193,7 +194,7 @@ Snapshot binaries are currently built and tested on several platforms:\n You may find that other platforms work, but these are our officially\n supported build environments that are most likely to work.\n \n-Rust currently needs between 600MiB and 1.5GiB to build, depending on platform.\n+Rust currently needs between 600MiB and 1.5GiB of RAM to build, depending on platform.\n If it hits swap, it will take a very long time to build.\n \n There is more advice about hacking on Rust in [CONTRIBUTING.md]."}, {"sha": "194745d9caad4062dbf1593703c72f0a76aeabb6", "filename": "RELEASES.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -3,19 +3,19 @@ Version 1.21.0 (2017-10-12)\n \n Language\n --------\n-- [Relaxed path syntax. You can now add type parameters to values][43540]\n-  Example:\n-  ```rust\n-  my_macro!(Vec<i32>::new); // Always worked\n-  my_macro!(Vec::<i32>::new); // Now works\n-  ```\n - [You can now use static references for literals.][43838]\n   Example:\n   ```rust\n   fn main() {\n       let x: &'static u32 = &0;\n   }\n   ```\n+- [Relaxed path syntax. Optional `::` before `<` is now allowed in all contexts.][43540]\n+  Example:\n+  ```rust\n+  my_macro!(Vec<i32>::new); // Always worked\n+  my_macro!(Vec::<i32>::new); // Now works\n+  ```\n \n Compiler\n --------"}, {"sha": "f50543e18a764845d76fab7ef6eb990d850f1fb1", "filename": "config.toml.example", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -250,14 +250,11 @@\n # Whether or not `panic!`s generate backtraces (RUST_BACKTRACE)\n #backtrace = true\n \n-# The default linker that will be used by the generated compiler. Note that this\n-# is not the linker used to link said compiler.\n+# The default linker that will be hard-coded into the generated compiler for\n+# targets that don't specify linker explicitly in their target specifications.\n+# Note that this is not the linker used to link said compiler.\n #default-linker = \"cc\"\n \n-# The default ar utility that will be used by the generated compiler if LLVM\n-# cannot be used. Note that this is not used to assemble said compiler.\n-#default-ar = \"ar\"\n-\n # The \"channel\" for the Rust build to produce. The stable/beta channels only\n # allow using stable features, whereas the nightly and dev channels allow using\n # nightly features\n@@ -303,7 +300,7 @@\n # =============================================================================\n [target.x86_64-unknown-linux-gnu]\n \n-# C compiler to be used to compiler C code and link Rust code. Note that the\n+# C compiler to be used to compiler C code. Note that the\n # default value is platform specific, and if not specified it may also depend on\n # what platform is crossing to what platform.\n #cc = \"cc\"\n@@ -312,6 +309,15 @@\n # This is only used for host targets.\n #cxx = \"c++\"\n \n+# Archiver to be used to assemble static libraries compiled from C/C++ code.\n+# Note: an absolute path should be used, otherwise LLVM build will break.\n+#ar = \"ar\"\n+\n+# Linker to be used to link Rust code. Note that the\n+# default value is platform specific, and if not specified it may also depend on\n+# what platform is crossing to what platform.\n+#linker = \"cc\"\n+\n # Path to the `llvm-config` binary of the installation of a custom LLVM to link\n # against. Note that if this is specifed we don't compile LLVM at all for this\n # target."}, {"sha": "328ce353e2a139351cf0c4ab75b55c0b9dc0eaa0", "filename": "src/Cargo.lock", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -42,7 +42,7 @@ dependencies = [\n  \"alloc 0.0.0\",\n  \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n  \"libc 0.0.0\",\n ]\n@@ -99,7 +99,7 @@ name = \"backtrace-sys\"\n version = \"0.1.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -136,7 +136,7 @@ name = \"bootstrap\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cmake 0.1.26 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -199,7 +199,7 @@ dependencies = [\n  \"hex 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"home 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ignore 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"jobserver 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"jobserver 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libgit2-sys 0.6.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -246,7 +246,7 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.0\"\n+version = \"1.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -275,7 +275,7 @@ name = \"cmake\"\n version = \"0.1.26\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -290,7 +290,7 @@ dependencies = [\n name = \"compiler_builtins\"\n version = \"0.0.0\"\n dependencies = [\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n ]\n \n@@ -407,7 +407,7 @@ name = \"curl-sys\"\n version = \"0.3.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libz-sys 1.0.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-sys 0.9.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -759,7 +759,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"jobserver\"\n-version = \"0.1.6\"\n+version = \"0.1.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -833,7 +833,7 @@ name = \"libgit2-sys\"\n version = \"0.6.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cmake 0.1.26 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"curl-sys 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -860,7 +860,7 @@ name = \"libz-sys\"\n version = \"1.0.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"vcpkg 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -880,7 +880,7 @@ name = \"lzma-sys\"\n version = \"0.1.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -968,7 +968,7 @@ name = \"miniz-sys\"\n version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1104,7 +1104,7 @@ name = \"openssl-sys\"\n version = \"0.9.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"vcpkg 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1208,7 +1208,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n name = \"profiler_builtins\"\n version = \"0.0.0\"\n dependencies = [\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n ]\n \n@@ -1429,7 +1429,7 @@ dependencies = [\n  \"flate2 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fmt_macros 0.0.0\",\n  \"graphviz 0.0.0\",\n- \"jobserver 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"jobserver 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_back 0.0.0\",\n@@ -1504,6 +1504,7 @@ dependencies = [\n  \"graphviz 0.0.0\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n+ \"rustc_back 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_mir 0.0.0\",\n  \"syntax 0.0.0\",\n@@ -1611,7 +1612,6 @@ version = \"0.0.0\"\n dependencies = [\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n- \"rustc_back 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n@@ -1623,7 +1623,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"bitflags 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"build_helper 0.1.0\",\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_cratesio_shim 0.0.0\",\n ]\n \n@@ -1755,9 +1755,9 @@ name = \"rustc_trans\"\n version = \"0.0.0\"\n dependencies = [\n  \"bitflags 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"jobserver 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"jobserver 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1824,7 +1824,7 @@ name = \"rustdoc\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"html-diff 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1994,7 +1994,6 @@ dependencies = [\n  \"alloc_jemalloc 0.0.0\",\n  \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n- \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"collections 0.0.0\",\n  \"compiler_builtins 0.0.0\",\n  \"core 0.0.0\",\n@@ -2485,7 +2484,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum bitflags 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4efd02e230a02e18f92fc2735f44597385ed02ad8f831e7c1c1156ee5e1ab3a5\"\n \"checksum bitflags 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f5cde24d1b2e2216a726368b2363a273739c91f4e3eb4e0dd12d672d396ad989\"\n \"checksum bufstream 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f2f382711e76b9de6c744cc00d0497baba02fb00a787f088c879f01d09468e32\"\n-\"checksum cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7db2f146208d7e0fbee761b09cd65a7f51ccc38705d4e7262dad4d73b12a76b1\"\n+\"checksum cc 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2c674f0870e3dbd4105184ea035acb1c32c8ae69939c9e228d2b11bbfe29efad\"\n \"checksum cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d4c819a1287eb618df47cc647173c5c4c66ba19d888a6e50d605672aed3140de\"\n \"checksum clap 2.26.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3451e409013178663435d6f15fdb212f14ee4424a3d74f979d081d0a66b6f1f2\"\n \"checksum cmake 0.1.26 (registry+https://github.com/rust-lang/crates.io-index)\" = \"357c07e7a1fc95732793c1edb5901e1a1f305cfcf63a90eb12dbd22bdb6b789d\"\n@@ -2530,7 +2529,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum idna 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"014b298351066f1512874135335d62a789ffe78a9974f94b43ed5621951eaf7d\"\n \"checksum ignore 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b3fcaf2365eb14b28ec7603c98c06cc531f19de9eb283d89a3dff8417c8c99f5\"\n \"checksum itoa 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8324a32baf01e2ae060e9de58ed0bc2320c9a2833491ee36cd3b4c414de4db8c\"\n-\"checksum jobserver 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"443ae8bc0af6c106e6e8b77e04684faecc1a5ce94e058f4c2b0a037b0ea1b133\"\n+\"checksum jobserver 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"094f87ed101b6832def8632f43db43dc204d27897eb95aca69b26ce2e4011e84\"\n \"checksum jsonrpc-core 7.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b1acd0f9934da94466d2370f36832b9b19271b4abdfdb5e69f0bcd991ebcd515\"\n \"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n \"checksum kuchiki 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ef2ea4f2f7883cd7c6772b06c14abca01a2cc1f75c426cebffcf6b3b925ef9fc\""}, {"sha": "bbbbf0e1915555c419039a827eb1703a8c267c4e", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -34,7 +34,7 @@ cmake = \"0.1.23\"\n filetime = \"0.1\"\n num_cpus = \"1.0\"\n getopts = \"0.2\"\n-cc = \"1.0\"\n+cc = \"1.0.1\"\n libc = \"0.2\"\n serde = \"1.0.8\"\n serde_derive = \"1.0.8\""}, {"sha": "6eb074605fc1493e70919edf5e94a728c3be3aef", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -39,7 +39,7 @@ The script accepts commands, flags, and arguments to determine what to do:\n   ```\n \n   If files are dirty that would normally be rebuilt from stage 0, that can be\n-  overidden using `--keep-stage 0`. Using `--keep-stage n` will skip all steps\n+  overridden using `--keep-stage 0`. Using `--keep-stage n` will skip all steps\n   that belong to stage n or earlier:\n \n   ```\n@@ -126,7 +126,7 @@ install a nightly, presumably using `rustup`. You will then want to\n configure your directory to use this build, like so:\n \n ```\n-# configure to use local rust instead of downloding a beta.\n+# configure to use local rust instead of downloading a beta.\n # `--local-rust-root` is optional here. If elided, we will\n # use whatever rustc we find on your PATH.\n > configure --enable-rustbuild --local-rust-root=~/.cargo/ --enable-local-rebuild"}, {"sha": "aeeda85e924ef1657825aa28993741867561f2c6", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -31,8 +31,6 @@ extern crate bootstrap;\n \n use std::env;\n use std::ffi::OsString;\n-use std::io;\n-use std::io::prelude::*;\n use std::str::FromStr;\n use std::path::PathBuf;\n use std::process::{Command, ExitStatus};\n@@ -122,19 +120,14 @@ fn main() {\n             cmd.arg(\"-L\").arg(&root);\n         }\n \n-        // Pass down extra flags, commonly used to configure `-Clinker` when\n-        // cross compiling.\n-        if let Ok(s) = env::var(\"RUSTC_FLAGS\") {\n-            cmd.args(&s.split(\" \").filter(|s| !s.is_empty()).collect::<Vec<_>>());\n+        // Override linker if necessary.\n+        if let Ok(target_linker) = env::var(\"RUSTC_TARGET_LINKER\") {\n+            cmd.arg(format!(\"-Clinker={}\", target_linker));\n         }\n \n         // Pass down incremental directory, if any.\n         if let Ok(dir) = env::var(\"RUSTC_INCREMENTAL\") {\n             cmd.arg(format!(\"-Zincremental={}\", dir));\n-\n-            if verbose > 0 {\n-                cmd.arg(\"-Zincremental-info\");\n-            }\n         }\n \n         let crate_name = args.windows(2)\n@@ -258,6 +251,11 @@ fn main() {\n         if env::var_os(\"RUSTC_FORCE_UNSTABLE\").is_some() {\n             cmd.arg(\"-Z\").arg(\"force-unstable-if-unmarked\");\n         }\n+    } else {\n+        // Override linker if necessary.\n+        if let Ok(host_linker) = env::var(\"RUSTC_HOST_LINKER\") {\n+            cmd.arg(format!(\"-Clinker={}\", host_linker));\n+        }\n     }\n \n     let color = match env::var(\"RUSTC_COLOR\") {\n@@ -270,7 +268,7 @@ fn main() {\n     }\n \n     if verbose > 1 {\n-        writeln!(&mut io::stderr(), \"rustc command: {:?}\", cmd).unwrap();\n+        eprintln!(\"rustc command: {:?}\", cmd);\n     }\n \n     // Actually run the compiler!"}, {"sha": "4e975adc9721cdef87aac309521056c7816ba39c", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -47,6 +47,17 @@ fn main() {\n     if env::var_os(\"RUSTC_FORCE_UNSTABLE\").is_some() {\n         cmd.arg(\"-Z\").arg(\"force-unstable-if-unmarked\");\n     }\n+    if let Some(linker) = env::var_os(\"RUSTC_TARGET_LINKER\") {\n+        cmd.arg(\"--linker\").arg(linker).arg(\"-Z\").arg(\"unstable-options\");\n+    }\n+\n+    // Bootstrap's Cargo-command builder sets this variable to the current Rust version; let's pick\n+    // it up so we can make rustdoc print this into the docs\n+    if let Some(version) = env::var_os(\"RUSTDOC_CRATE_VERSION\") {\n+        // This \"unstable-options\" can be removed when `--crate-version` is stabilized\n+        cmd.arg(\"-Z\").arg(\"unstable-options\")\n+           .arg(\"--crate-version\").arg(version);\n+    }\n \n     std::process::exit(match cmd.status() {\n         Ok(s) => s.code().unwrap_or(1),"}, {"sha": "842144ff1ea00cbe24ca9b33c308ad72508d5ece", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -302,6 +302,7 @@ def default_build_triple():\n \n     return \"{}-{}\".format(cputype, ostype)\n \n+\n class RustBuild(object):\n     \"\"\"Provide all the methods required to build Rust\"\"\"\n     def __init__(self):\n@@ -498,7 +499,7 @@ def get_toml(self, key):\n \n         If the key does not exists, the result is None:\n \n-        >>> rb.get_toml(\"key3\") == None\n+        >>> rb.get_toml(\"key3\") is None\n         True\n         \"\"\"\n         for line in self.config_toml.splitlines():"}, {"sha": "6480b5a619c03c48d51138fc394229ebfb2b9bc2", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 44, "deletions": 14, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -413,12 +413,15 @@ impl<'a> Builder<'a> {\n     pub fn rustdoc_cmd(&self, host: Interned<String>) -> Command {\n         let mut cmd = Command::new(&self.out.join(\"bootstrap/debug/rustdoc\"));\n         let compiler = self.compiler(self.top_stage, host);\n-        cmd\n-            .env(\"RUSTC_STAGE\", compiler.stage.to_string())\n-            .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n-            .env(\"RUSTC_LIBDIR\", self.sysroot_libdir(compiler, self.build.build))\n-            .env(\"CFG_RELEASE_CHANNEL\", &self.build.config.channel)\n-            .env(\"RUSTDOC_REAL\", self.rustdoc(host));\n+        cmd.env(\"RUSTC_STAGE\", compiler.stage.to_string())\n+           .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n+           .env(\"RUSTC_LIBDIR\", self.sysroot_libdir(compiler, self.build.build))\n+           .env(\"CFG_RELEASE_CHANNEL\", &self.build.config.channel)\n+           .env(\"RUSTDOC_REAL\", self.rustdoc(host))\n+           .env(\"RUSTDOC_CRATE_VERSION\", self.build.rust_version());\n+        if let Some(linker) = self.build.linker(host) {\n+            cmd.env(\"RUSTC_TARGET_LINKER\", linker);\n+        }\n         cmd\n     }\n \n@@ -481,8 +484,14 @@ impl<'a> Builder<'a> {\n              } else {\n                  PathBuf::from(\"/path/to/nowhere/rustdoc/not/required\")\n              })\n-             .env(\"TEST_MIRI\", self.config.test_miri.to_string())\n-             .env(\"RUSTC_FLAGS\", self.rustc_flags(target).join(\" \"));\n+             .env(\"TEST_MIRI\", self.config.test_miri.to_string());\n+\n+        if let Some(host_linker) = self.build.linker(compiler.host) {\n+            cargo.env(\"RUSTC_HOST_LINKER\", host_linker);\n+        }\n+        if let Some(target_linker) = self.build.linker(target) {\n+            cargo.env(\"RUSTC_TARGET_LINKER\", target_linker);\n+        }\n \n         if mode != Mode::Tool {\n             // Tools don't get debuginfo right now, e.g. cargo and rls don't\n@@ -556,24 +565,45 @@ impl<'a> Builder<'a> {\n \n         cargo.env(\"RUSTC_VERBOSE\", format!(\"{}\", self.verbosity));\n \n-        // Specify some various options for build scripts used throughout\n-        // the build.\n+        // Throughout the build Cargo can execute a number of build scripts\n+        // compiling C/C++ code and we need to pass compilers, archivers, flags, etc\n+        // obtained previously to those build scripts.\n+        // Build scripts use either the `cc` crate or `configure/make` so we pass\n+        // the options through environment variables that are fetched and understood by both.\n         //\n         // FIXME: the guard against msvc shouldn't need to be here\n         if !target.contains(\"msvc\") {\n-            cargo.env(format!(\"CC_{}\", target), self.cc(target))\n-                 .env(format!(\"AR_{}\", target), self.ar(target).unwrap()) // only msvc is None\n-                 .env(format!(\"CFLAGS_{}\", target), self.cflags(target).join(\" \"));\n+            let cc = self.cc(target);\n+            cargo.env(format!(\"CC_{}\", target), cc)\n+                 .env(\"CC\", cc);\n+\n+            let cflags = self.cflags(target).join(\" \");\n+            cargo.env(format!(\"CFLAGS_{}\", target), cflags.clone())\n+                 .env(\"CFLAGS\", cflags.clone());\n+\n+            if let Some(ar) = self.ar(target) {\n+                let ranlib = format!(\"{} s\", ar.display());\n+                cargo.env(format!(\"AR_{}\", target), ar)\n+                     .env(\"AR\", ar)\n+                     .env(format!(\"RANLIB_{}\", target), ranlib.clone())\n+                     .env(\"RANLIB\", ranlib);\n+            }\n \n             if let Ok(cxx) = self.cxx(target) {\n-                 cargo.env(format!(\"CXX_{}\", target), cxx);\n+                cargo.env(format!(\"CXX_{}\", target), cxx)\n+                     .env(\"CXX\", cxx)\n+                     .env(format!(\"CXXFLAGS_{}\", target), cflags.clone())\n+                     .env(\"CXXFLAGS\", cflags);\n             }\n         }\n \n         if mode == Mode::Libstd && self.config.extended && compiler.is_final_stage(self) {\n             cargo.env(\"RUSTC_SAVE_ANALYSIS\", \"api\".to_string());\n         }\n \n+        // For `cargo doc` invocations, make rustdoc print the Rust version into the docs\n+        cargo.env(\"RUSTDOC_CRATE_VERSION\", self.build.rust_version());\n+\n         // Environment variables *required* throughout the build\n         //\n         // FIXME: should update code to not require this env var"}, {"sha": "6e3e3c920291d00e51738f284ce8498e699bb8d5", "filename": "src/bootstrap/cc_detect.rs", "status": "modified", "additions": 45, "deletions": 7, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Fcc_detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Fcc_detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc_detect.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -31,20 +31,51 @@\n //! ever be probed for. Instead the compilers found here will be used for\n //! everything.\n \n+use std::collections::HashSet;\n+use std::{env, iter};\n+use std::path::{Path, PathBuf};\n use std::process::Command;\n-use std::iter;\n \n-use build_helper::{cc2ar, output};\n+use build_helper::output;\n use cc;\n \n use Build;\n use config::Target;\n use cache::Interned;\n \n+// The `cc` crate doesn't provide a way to obtain a path to the detected archiver,\n+// so use some simplified logic here. First we respect the environment variable `AR`, then\n+// try to infer the archiver path from the C compiler path.\n+// In the future this logic should be replaced by calling into the `cc` crate.\n+fn cc2ar(cc: &Path, target: &str) -> Option<PathBuf> {\n+    if let Some(ar) = env::var_os(\"AR\") {\n+        Some(PathBuf::from(ar))\n+    } else if target.contains(\"msvc\") {\n+        None\n+    } else if target.contains(\"musl\") {\n+        Some(PathBuf::from(\"ar\"))\n+    } else if target.contains(\"openbsd\") {\n+        Some(PathBuf::from(\"ar\"))\n+    } else {\n+        let parent = cc.parent().unwrap();\n+        let file = cc.file_name().unwrap().to_str().unwrap();\n+        for suffix in &[\"gcc\", \"cc\", \"clang\"] {\n+            if let Some(idx) = file.rfind(suffix) {\n+                let mut file = file[..idx].to_owned();\n+                file.push_str(\"ar\");\n+                return Some(parent.join(&file));\n+            }\n+        }\n+        Some(parent.join(file))\n+    }\n+}\n+\n pub fn find(build: &mut Build) {\n     // For all targets we're going to need a C compiler for building some shims\n     // and such as well as for being a linker for Rust code.\n-    for target in build.targets.iter().chain(&build.hosts).cloned().chain(iter::once(build.build)) {\n+    let targets = build.targets.iter().chain(&build.hosts).cloned().chain(iter::once(build.build))\n+                               .collect::<HashSet<_>>();\n+    for target in targets.into_iter() {\n         let mut cfg = cc::Build::new();\n         cfg.cargo_metadata(false).opt_level(0).warnings(false).debug(false)\n            .target(&target).host(&build.build);\n@@ -57,16 +88,23 @@ pub fn find(build: &mut Build) {\n         }\n \n         let compiler = cfg.get_compiler();\n-        let ar = cc2ar(compiler.path(), &target);\n+        let ar = if let ar @ Some(..) = config.and_then(|c| c.ar.clone()) {\n+            ar\n+        } else {\n+            cc2ar(compiler.path(), &target)\n+        };\n+\n         build.verbose(&format!(\"CC_{} = {:?}\", &target, compiler.path()));\n-        if let Some(ref ar) = ar {\n+        build.cc.insert(target, compiler);\n+        if let Some(ar) = ar {\n             build.verbose(&format!(\"AR_{} = {:?}\", &target, ar));\n+            build.ar.insert(target, ar);\n         }\n-        build.cc.insert(target, (compiler, ar));\n     }\n \n     // For all host triples we need to find a C++ compiler as well\n-    for host in build.hosts.iter().cloned().chain(iter::once(build.build)) {\n+    let hosts = build.hosts.iter().cloned().chain(iter::once(build.build)).collect::<HashSet<_>>();\n+    for host in hosts.into_iter() {\n         let mut cfg = cc::Build::new();\n         cfg.cargo_metadata(false).opt_level(0).warnings(false).debug(false).cpp(true)\n            .target(&host).host(&build.build);"}, {"sha": "d9ee63eef8cdd95ceb2b35fd1ca1d672c1c57431", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -246,8 +246,11 @@ impl Step for Rls {\n         let compiler = builder.compiler(stage, host);\n \n         builder.ensure(tool::Rls { compiler, target: self.host });\n-        let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-        cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/rls/Cargo.toml\"));\n+        let mut cargo = tool::prepare_tool_cargo(builder,\n+                                                 compiler,\n+                                                 host,\n+                                                 \"test\",\n+                                                 \"src/tools/rls\");\n \n         // Don't build tests dynamically, just a pain to work with\n         cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n@@ -291,8 +294,11 @@ impl Step for Rustfmt {\n         let compiler = builder.compiler(stage, host);\n \n         builder.ensure(tool::Rustfmt { compiler, target: self.host });\n-        let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-        cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/rustfmt/Cargo.toml\"));\n+        let mut cargo = tool::prepare_tool_cargo(builder,\n+                                                 compiler,\n+                                                 host,\n+                                                 \"test\",\n+                                                 \"src/tools/rustfmt\");\n \n         // Don't build tests dynamically, just a pain to work with\n         cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n@@ -358,6 +364,7 @@ impl Step for Miri {\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Clippy {\n+    stage: u32,\n     host: Interned<String>,\n }\n \n@@ -372,24 +379,28 @@ impl Step for Clippy {\n \n     fn make_run(run: RunConfig) {\n         run.builder.ensure(Clippy {\n+            stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n \n     /// Runs `cargo test` for clippy.\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n+        let stage = self.stage;\n         let host = self.host;\n-        let compiler = builder.compiler(1, host);\n+        let compiler = builder.compiler(stage, host);\n \n-        let _clippy = builder.ensure(tool::Clippy { compiler, target: self.host });\n+        let clippy = builder.ensure(tool::Clippy { compiler, target: self.host });\n         let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n         cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/clippy/Cargo.toml\"));\n \n         // Don't build tests dynamically, just a pain to work with\n         cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n         // clippy tests need to know about the stage sysroot\n         cargo.env(\"SYSROOT\", builder.sysroot(compiler));\n+        // clippy tests need to find the driver\n+        cargo.env(\"CLIPPY_DRIVER_PATH\", clippy);\n \n         builder.add_rustc_lib_path(compiler, &mut cargo);\n \n@@ -736,12 +747,14 @@ impl Step for Compiletest {\n             flags.push(\"-g\".to_string());\n         }\n \n-        let mut hostflags = build.rustc_flags(compiler.host);\n-        hostflags.extend(flags.clone());\n+        if let Some(linker) = build.linker(target) {\n+            cmd.arg(\"--linker\").arg(linker);\n+        }\n+\n+        let hostflags = flags.clone();\n         cmd.arg(\"--host-rustcflags\").arg(hostflags.join(\" \"));\n \n-        let mut targetflags = build.rustc_flags(target);\n-        targetflags.extend(flags);\n+        let mut targetflags = flags.clone();\n         targetflags.push(format!(\"-Lnative={}\",\n                                  build.test_helpers_out(target).display()));\n         cmd.arg(\"--target-rustcflags\").arg(targetflags.join(\" \"));\n@@ -795,6 +808,9 @@ impl Step for Compiletest {\n                 .arg(\"--cflags\").arg(build.cflags(target).join(\" \"))\n                 .arg(\"--llvm-components\").arg(llvm_components.trim())\n                 .arg(\"--llvm-cxxflags\").arg(llvm_cxxflags.trim());\n+                if let Some(ar) = build.ar(target) {\n+                    cmd.arg(\"--ar\").arg(ar);\n+                }\n             }\n         }\n         if suite == \"run-make\" && !build.config.llvm_enabled {\n@@ -820,7 +836,7 @@ impl Step for Compiletest {\n         // Note that if we encounter `PATH` we make sure to append to our own `PATH`\n         // rather than stomp over it.\n         if target.contains(\"msvc\") {\n-            for &(ref k, ref v) in build.cc[&target].0.env() {\n+            for &(ref k, ref v) in build.cc[&target].env() {\n                 if k != \"PATH\" {\n                     cmd.env(k, v);\n                 }"}, {"sha": "b1c630a8de9e504e811d415ddc105bc69b69c82c", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -560,9 +560,6 @@ pub fn rustc_cargo(build: &Build,\n     if let Some(ref s) = build.config.rustc_default_linker {\n         cargo.env(\"CFG_DEFAULT_LINKER\", s);\n     }\n-    if let Some(ref s) = build.config.rustc_default_ar {\n-        cargo.env(\"CFG_DEFAULT_AR\", s);\n-    }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]"}, {"sha": "69e0f58f1cd068f8639cb4737bdf6ae73461cd79", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -88,7 +88,6 @@ pub struct Config {\n     pub rust_debuginfo_only_std: bool,\n     pub rust_rpath: bool,\n     pub rustc_default_linker: Option<String>,\n-    pub rustc_default_ar: Option<String>,\n     pub rust_optimize_tests: bool,\n     pub rust_debuginfo_tests: bool,\n     pub rust_dist_src: bool,\n@@ -144,6 +143,8 @@ pub struct Target {\n     pub jemalloc: Option<PathBuf>,\n     pub cc: Option<PathBuf>,\n     pub cxx: Option<PathBuf>,\n+    pub ar: Option<PathBuf>,\n+    pub linker: Option<PathBuf>,\n     pub ndk: Option<PathBuf>,\n     pub crt_static: Option<bool>,\n     pub musl_root: Option<PathBuf>,\n@@ -262,7 +263,6 @@ struct Rust {\n     use_jemalloc: Option<bool>,\n     backtrace: Option<bool>,\n     default_linker: Option<String>,\n-    default_ar: Option<String>,\n     channel: Option<String>,\n     musl_root: Option<String>,\n     rpath: Option<bool>,\n@@ -284,6 +284,8 @@ struct TomlTarget {\n     jemalloc: Option<String>,\n     cc: Option<String>,\n     cxx: Option<String>,\n+    ar: Option<String>,\n+    linker: Option<String>,\n     android_ndk: Option<String>,\n     crt_static: Option<bool>,\n     musl_root: Option<String>,\n@@ -464,7 +466,6 @@ impl Config {\n             set(&mut config.quiet_tests, rust.quiet_tests);\n             set(&mut config.test_miri, rust.test_miri);\n             config.rustc_default_linker = rust.default_linker.clone();\n-            config.rustc_default_ar = rust.default_ar.clone();\n             config.musl_root = rust.musl_root.clone().map(PathBuf::from);\n \n             match rust.codegen_units {\n@@ -487,8 +488,10 @@ impl Config {\n                 if let Some(ref s) = cfg.android_ndk {\n                     target.ndk = Some(env::current_dir().unwrap().join(s));\n                 }\n-                target.cxx = cfg.cxx.clone().map(PathBuf::from);\n                 target.cc = cfg.cc.clone().map(PathBuf::from);\n+                target.cxx = cfg.cxx.clone().map(PathBuf::from);\n+                target.ar = cfg.ar.clone().map(PathBuf::from);\n+                target.linker = cfg.linker.clone().map(PathBuf::from);\n                 target.crt_static = cfg.crt_static.clone();\n                 target.musl_root = cfg.musl_root.clone().map(PathBuf::from);\n                 target.qemu_rootfs = cfg.qemu_rootfs.clone().map(PathBuf::from);"}, {"sha": "42425a164a20ef3f2335aa304f9fef6aee6d1eef", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -20,21 +20,26 @@\n sys.path.append(os.path.join(rust_dir, \"src\", \"bootstrap\"))\n import bootstrap\n \n+\n class Option(object):\n     def __init__(self, name, rustbuild, desc, value):\n         self.name = name\n         self.rustbuild = rustbuild\n         self.desc = desc\n         self.value = value\n \n+\n options = []\n \n+\n def o(*args):\n     options.append(Option(*args, value=False))\n \n+\n def v(*args):\n     options.append(Option(*args, value=True))\n \n+\n o(\"debug\", \"rust.debug\", \"debug mode; disables optimization unless `--enable-optimize` given\")\n o(\"docs\", \"build.docs\", \"build standard library documentation\")\n o(\"compiler-docs\", \"build.compiler-docs\", \"build compiler documentation\")\n@@ -120,9 +125,8 @@ def v(*args):\n   \"experimental LLVM targets to build\")\n v(\"release-channel\", \"rust.channel\", \"the name of the release channel to build\")\n \n-# Used on systems where \"cc\" and \"ar\" are unavailable\n+# Used on systems where \"cc\" is unavailable\n v(\"default-linker\", \"rust.default-linker\", \"the default linker\")\n-v(\"default-ar\", \"rust.default-ar\", \"the default ar\")\n \n # Many of these are saved below during the \"writing configuration\" step\n # (others are conditionally saved).\n@@ -137,13 +141,16 @@ def v(*args):\n \n v(\"set\", None, \"set arbitrary key/value pairs in TOML configuration\")\n \n+\n def p(msg):\n     print(\"configure: \" + msg)\n \n+\n def err(msg):\n     print(\"configure: error: \" + msg)\n     sys.exit(1)\n \n+\n if '--help' in sys.argv or '-h' in sys.argv:\n     print('Usage: ./configure [options]')\n     print('')\n@@ -209,7 +216,7 @@ def err(msg):\n                 continue\n \n         found = True\n-        if not option.name in known_args:\n+        if option.name not in known_args:\n             known_args[option.name] = []\n         known_args[option.name].append((option, value))\n         break\n@@ -228,27 +235,30 @@ def err(msg):\n # TOML we're going to write out\n config = {}\n \n+\n def build():\n     if 'build' in known_args:\n         return known_args['build'][0][1]\n     return bootstrap.default_build_triple()\n \n+\n def set(key, value):\n-      s = \"{:20} := {}\".format(key, value)\n-      if len(s) < 70:\n-          p(s)\n-      else:\n-          p(s[:70] + \" ...\")\n-\n-      arr = config\n-      parts = key.split('.')\n-      for i, part in enumerate(parts):\n-          if i == len(parts) - 1:\n-              arr[part] = value\n-          else:\n-              if not part in arr:\n-                  arr[part] = {}\n-              arr = arr[part]\n+    s = \"{:20} := {}\".format(key, value)\n+    if len(s) < 70:\n+        p(s)\n+    else:\n+        p(s[:70] + \" ...\")\n+\n+    arr = config\n+    parts = key.split('.')\n+    for i, part in enumerate(parts):\n+        if i == len(parts) - 1:\n+            arr[part] = value\n+        else:\n+            if part not in arr:\n+                arr[part] = {}\n+            arr = arr[part]\n+\n \n for key in known_args:\n     # The `set` option is special and can be passed a bunch of times\n@@ -346,8 +356,9 @@ def set(key, value):\n     targets[target] = sections['target'][:]\n     targets[target][0] = targets[target][0].replace(\"x86_64-unknown-linux-gnu\", target)\n \n+\n # Here we walk through the constructed configuration we have from the parsed\n-# command line arguemnts. We then apply each piece of configuration by\n+# command line arguments. We then apply each piece of configuration by\n # basically just doing a `sed` to change the various configuration line to what\n # we've got configure.\n def to_toml(value):\n@@ -361,7 +372,8 @@ def to_toml(value):\n     elif isinstance(value, str):\n         return \"'\" + value + \"'\"\n     else:\n-        raise 'no toml'\n+        raise RuntimeError('no toml')\n+\n \n def configure_section(lines, config):\n     for key in config:\n@@ -376,10 +388,11 @@ def configure_section(lines, config):\n         if not found:\n             raise RuntimeError(\"failed to find config line for {}\".format(key))\n \n+\n for section_key in config:\n     section_config = config[section_key]\n-    if not section_key in sections:\n-        raise RuntimeError(\"config key {} not in sections\".format(key))\n+    if section_key not in sections:\n+        raise RuntimeError(\"config key {} not in sections\".format(section_key))\n \n     if section_key == 'target':\n         for target in section_config:\n@@ -408,11 +421,6 @@ def configure_section(lines, config):\n     contents = contents.replace(\"$(CFG_PYTHON)\", sys.executable)\n     f.write(contents)\n \n-# Finally, clean up with a bit of a help message\n-relpath = os.path.dirname(__file__)\n-if relpath == '':\n-    relpath = '.'\n-\n p(\"\")\n-p(\"run `python {}/x.py --help`\".format(relpath))\n+p(\"run `python {}/x.py --help`\".format(rust_dir))\n p(\"\")"}, {"sha": "02dfa04d9203a35c9106e6404b89752e09085710", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 109, "deletions": 89, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -176,7 +176,7 @@ fn make_win_dist(\n         }\n     }\n \n-    let target_tools = [\"gcc.exe\", \"ld.exe\", \"ar.exe\", \"dlltool.exe\", \"libwinpthread-1.dll\"];\n+    let target_tools = [\"gcc.exe\", \"ld.exe\", \"dlltool.exe\", \"libwinpthread-1.dll\"];\n     let mut rustc_dlls = vec![\"libstdc++-6.dll\", \"libwinpthread-1.dll\"];\n     if target_triple.starts_with(\"i686-\") {\n         rustc_dlls.push(\"libgcc_s_dw2-1.dll\");\n@@ -1035,7 +1035,7 @@ pub struct Rls {\n }\n \n impl Step for Rls {\n-    type Output = PathBuf;\n+    type Output = Option<PathBuf>;\n     const ONLY_BUILD_TARGETS: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -1050,12 +1050,17 @@ impl Step for Rls {\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n         let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n         assert!(build.config.extended);\n \n+        if !builder.config.toolstate.rls.testing() {\n+            println!(\"skipping Dist RLS stage{} ({})\", stage, target);\n+            return None\n+        }\n+\n         println!(\"Dist RLS stage{} ({})\", stage, target);\n         let src = build.src.join(\"src/tools/rls\");\n         let release_num = build.release_num(\"rls\");\n@@ -1102,7 +1107,7 @@ impl Step for Rls {\n            .arg(\"--component-name=rls-preview\");\n \n         build.run(&mut cmd);\n-        distdir(build).join(format!(\"{}-{}.tar.gz\", name, target))\n+        Some(distdir(build).join(format!(\"{}-{}.tar.gz\", name, target)))\n     }\n }\n \n@@ -1202,8 +1207,12 @@ impl Step for Extended {\n         // upgrades rustc was upgraded before rust-std. To avoid rustc clobbering\n         // the std files during uninstall. To do this ensure that rustc comes\n         // before rust-std in the list below.\n-        let mut tarballs = vec![rustc_installer, cargo_installer, rls_installer,\n-                                analysis_installer, std_installer];\n+        let mut tarballs = Vec::new();\n+        tarballs.push(rustc_installer);\n+        tarballs.push(cargo_installer);\n+        tarballs.extend(rls_installer.clone());\n+        tarballs.push(analysis_installer);\n+        tarballs.push(std_installer);\n         if build.config.docs {\n             tarballs.push(docs_installer);\n         }\n@@ -1245,35 +1254,38 @@ impl Step for Extended {\n         }\n         rtf.push_str(\"}\");\n \n+        fn filter(contents: &str, marker: &str) -> String {\n+            let start = format!(\"tool-{}-start\", marker);\n+            let end = format!(\"tool-{}-end\", marker);\n+            let mut lines = Vec::new();\n+            let mut omitted = false;\n+            for line in contents.lines() {\n+                if line.contains(&start) {\n+                    omitted = true;\n+                } else if line.contains(&end) {\n+                    omitted = false;\n+                } else if !omitted {\n+                    lines.push(line);\n+                }\n+            }\n+\n+            lines.join(\"\\n\")\n+        }\n+\n+        let xform = |p: &Path| {\n+            let mut contents = String::new();\n+            t!(t!(File::open(p)).read_to_string(&mut contents));\n+            if rls_installer.is_none() {\n+                contents = filter(&contents, \"rls\");\n+            }\n+            let ret = tmp.join(p.file_name().unwrap());\n+            t!(t!(File::create(&ret)).write_all(contents.as_bytes()));\n+            return ret\n+        };\n+\n         if target.contains(\"apple-darwin\") {\n             let pkg = tmp.join(\"pkg\");\n             let _ = fs::remove_dir_all(&pkg);\n-            t!(fs::create_dir_all(pkg.join(\"rustc\")));\n-            t!(fs::create_dir_all(pkg.join(\"cargo\")));\n-            t!(fs::create_dir_all(pkg.join(\"rust-docs\")));\n-            t!(fs::create_dir_all(pkg.join(\"rust-std\")));\n-            t!(fs::create_dir_all(pkg.join(\"rls\")));\n-            t!(fs::create_dir_all(pkg.join(\"rust-analysis\")));\n-\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rustc\"), target)),\n-                    &pkg.join(\"rustc\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"cargo\"), target)),\n-                    &pkg.join(\"cargo\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-docs\"), target)),\n-                    &pkg.join(\"rust-docs\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-std\"), target)),\n-                    &pkg.join(\"rust-std\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rls\"), target)),\n-                    &pkg.join(\"rls\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-analysis\"), target)),\n-                    &pkg.join(\"rust-analysis\"));\n-\n-            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"rustc\"), 0o755);\n-            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"cargo\"), 0o755);\n-            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"rust-docs\"), 0o755);\n-            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"rust-std\"), 0o755);\n-            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"rls\"), 0o755);\n-            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"rust-analysis\"), 0o755);\n \n             let pkgbuild = |component: &str| {\n                 let mut cmd = Command::new(\"pkgbuild\");\n@@ -1283,12 +1295,23 @@ impl Step for Extended {\n                     .arg(pkg.join(component).with_extension(\"pkg\"));\n                 build.run(&mut cmd);\n             };\n-            pkgbuild(\"rustc\");\n-            pkgbuild(\"cargo\");\n-            pkgbuild(\"rust-docs\");\n-            pkgbuild(\"rust-std\");\n-            pkgbuild(\"rls\");\n-            pkgbuild(\"rust-analysis\");\n+\n+            let prepare = |name: &str| {\n+                t!(fs::create_dir_all(pkg.join(name)));\n+                cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, name), target)),\n+                        &pkg.join(name));\n+                install(&etc.join(\"pkg/postinstall\"), &pkg.join(name), 0o755);\n+                pkgbuild(name);\n+            };\n+            prepare(\"rustc\");\n+            prepare(\"cargo\");\n+            prepare(\"rust-docs\");\n+            prepare(\"rust-std\");\n+            prepare(\"rust-analysis\");\n+\n+            if rls_installer.is_some() {\n+                prepare(\"rls\");\n+            }\n \n             // create an 'uninstall' package\n             install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"uninstall\"), 0o755);\n@@ -1298,7 +1321,7 @@ impl Step for Extended {\n             t!(t!(File::create(pkg.join(\"res/LICENSE.txt\"))).write_all(license.as_bytes()));\n             install(&etc.join(\"gfx/rust-logo.png\"), &pkg.join(\"res\"), 0o644);\n             let mut cmd = Command::new(\"productbuild\");\n-            cmd.arg(\"--distribution\").arg(etc.join(\"pkg/Distribution.xml\"))\n+            cmd.arg(\"--distribution\").arg(xform(&etc.join(\"pkg/Distribution.xml\")))\n                 .arg(\"--resources\").arg(pkg.join(\"res\"))\n                 .arg(distdir(build).join(format!(\"{}-{}.pkg\",\n                                                     pkgname(build, \"rust\"),\n@@ -1310,46 +1333,34 @@ impl Step for Extended {\n         if target.contains(\"windows\") {\n             let exe = tmp.join(\"exe\");\n             let _ = fs::remove_dir_all(&exe);\n-            t!(fs::create_dir_all(exe.join(\"rustc\")));\n-            t!(fs::create_dir_all(exe.join(\"cargo\")));\n-            t!(fs::create_dir_all(exe.join(\"rls\")));\n-            t!(fs::create_dir_all(exe.join(\"rust-analysis\")));\n-            t!(fs::create_dir_all(exe.join(\"rust-docs\")));\n-            t!(fs::create_dir_all(exe.join(\"rust-std\")));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rustc\"), target))\n-                        .join(\"rustc\"),\n-                    &exe.join(\"rustc\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"cargo\"), target))\n-                        .join(\"cargo\"),\n-                    &exe.join(\"cargo\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-docs\"), target))\n-                        .join(\"rust-docs\"),\n-                    &exe.join(\"rust-docs\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-std\"), target))\n-                        .join(format!(\"rust-std-{}\", target)),\n-                    &exe.join(\"rust-std\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rls\"), target)).join(\"rls-preview\"),\n-                 &exe.join(\"rls\"));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-analysis\"), target))\n-                        .join(format!(\"rust-analysis-{}\", target)),\n-                    &exe.join(\"rust-analysis\"));\n-\n-            t!(fs::remove_file(exe.join(\"rustc/manifest.in\")));\n-            t!(fs::remove_file(exe.join(\"cargo/manifest.in\")));\n-            t!(fs::remove_file(exe.join(\"rust-docs/manifest.in\")));\n-            t!(fs::remove_file(exe.join(\"rust-std/manifest.in\")));\n-            t!(fs::remove_file(exe.join(\"rls/manifest.in\")));\n-            t!(fs::remove_file(exe.join(\"rust-analysis/manifest.in\")));\n \n+            let prepare = |name: &str| {\n+                t!(fs::create_dir_all(exe.join(name)));\n+                let dir = if name == \"rust-std\" || name == \"rust-analysis\" {\n+                    format!(\"{}-{}\", name, target)\n+                } else if name == \"rls\" {\n+                    \"rls-preview\".to_string()\n+                } else {\n+                    name.to_string()\n+                };\n+                cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, name), target))\n+                            .join(dir),\n+                        &exe.join(name));\n+                t!(fs::remove_file(exe.join(name).join(\"manifest.in\")));\n+            };\n+            prepare(\"rustc\");\n+            prepare(\"cargo\");\n+            prepare(\"rust-analysis\");\n+            prepare(\"rust-docs\");\n+            prepare(\"rust-std\");\n+            if rls_installer.is_some() {\n+                prepare(\"rls\");\n+            }\n             if target.contains(\"windows-gnu\") {\n-                t!(fs::create_dir_all(exe.join(\"rust-mingw\")));\n-                cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-mingw\"), target))\n-                            .join(\"rust-mingw\"),\n-                        &exe.join(\"rust-mingw\"));\n-                t!(fs::remove_file(exe.join(\"rust-mingw/manifest.in\")));\n+                prepare(\"rust-mingw\");\n             }\n \n-            install(&etc.join(\"exe/rust.iss\"), &exe, 0o644);\n+            install(&xform(&etc.join(\"exe/rust.iss\")), &exe, 0o644);\n             install(&etc.join(\"exe/modpath.iss\"), &exe, 0o644);\n             install(&etc.join(\"exe/upgrade.iss\"), &exe, 0o644);\n             install(&etc.join(\"gfx/rust-logo.ico\"), &exe, 0o644);\n@@ -1413,16 +1424,18 @@ impl Step for Extended {\n                             .arg(\"-dr\").arg(\"Std\")\n                             .arg(\"-var\").arg(\"var.StdDir\")\n                             .arg(\"-out\").arg(exe.join(\"StdGroup.wxs\")));\n-            build.run(Command::new(&heat)\n-                            .current_dir(&exe)\n-                            .arg(\"dir\")\n-                            .arg(\"rls\")\n-                            .args(&heat_flags)\n-                            .arg(\"-cg\").arg(\"RlsGroup\")\n-                            .arg(\"-dr\").arg(\"Rls\")\n-                            .arg(\"-var\").arg(\"var.RlsDir\")\n-                            .arg(\"-out\").arg(exe.join(\"RlsGroup.wxs\"))\n-                            .arg(\"-t\").arg(etc.join(\"msi/remove-duplicates.xsl\")));\n+            if rls_installer.is_some() {\n+                build.run(Command::new(&heat)\n+                                .current_dir(&exe)\n+                                .arg(\"dir\")\n+                                .arg(\"rls\")\n+                                .args(&heat_flags)\n+                                .arg(\"-cg\").arg(\"RlsGroup\")\n+                                .arg(\"-dr\").arg(\"Rls\")\n+                                .arg(\"-var\").arg(\"var.RlsDir\")\n+                                .arg(\"-out\").arg(exe.join(\"RlsGroup.wxs\"))\n+                                .arg(\"-t\").arg(etc.join(\"msi/remove-duplicates.xsl\")));\n+            }\n             build.run(Command::new(&heat)\n                             .current_dir(&exe)\n                             .arg(\"dir\")\n@@ -1456,26 +1469,30 @@ impl Step for Extended {\n                     .arg(\"-dDocsDir=rust-docs\")\n                     .arg(\"-dCargoDir=cargo\")\n                     .arg(\"-dStdDir=rust-std\")\n-                    .arg(\"-dRlsDir=rls\")\n                     .arg(\"-dAnalysisDir=rust-analysis\")\n                     .arg(\"-arch\").arg(&arch)\n                     .arg(\"-out\").arg(&output)\n                     .arg(&input);\n                 add_env(build, &mut cmd, target);\n \n+                if rls_installer.is_some() {\n+                    cmd.arg(\"-dRlsDir=rls\");\n+                }\n                 if target.contains(\"windows-gnu\") {\n                     cmd.arg(\"-dGccDir=rust-mingw\");\n                 }\n                 build.run(&mut cmd);\n             };\n-            candle(&etc.join(\"msi/rust.wxs\"));\n+            candle(&xform(&etc.join(\"msi/rust.wxs\")));\n             candle(&etc.join(\"msi/ui.wxs\"));\n             candle(&etc.join(\"msi/rustwelcomedlg.wxs\"));\n             candle(\"RustcGroup.wxs\".as_ref());\n             candle(\"DocsGroup.wxs\".as_ref());\n             candle(\"CargoGroup.wxs\".as_ref());\n             candle(\"StdGroup.wxs\".as_ref());\n-            candle(\"RlsGroup.wxs\".as_ref());\n+            if rls_installer.is_some() {\n+                candle(\"RlsGroup.wxs\".as_ref());\n+            }\n             candle(\"AnalysisGroup.wxs\".as_ref());\n \n             if target.contains(\"windows-gnu\") {\n@@ -1499,10 +1516,13 @@ impl Step for Extended {\n                 .arg(\"DocsGroup.wixobj\")\n                 .arg(\"CargoGroup.wixobj\")\n                 .arg(\"StdGroup.wixobj\")\n-                .arg(\"RlsGroup.wixobj\")\n                 .arg(\"AnalysisGroup.wixobj\")\n                 .current_dir(&exe);\n \n+            if rls_installer.is_some() {\n+                cmd.arg(\"RlsGroup.wixobj\");\n+            }\n+\n             if target.contains(\"windows-gnu\") {\n                 cmd.arg(\"GccGroup.wixobj\");\n             }"}, {"sha": "6ac919d3fbdda544922e5cf1ef678d9e75e53991", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -240,10 +240,11 @@ pub struct Build {\n     lldb_python_dir: Option<String>,\n \n     // Runtime state filled in later on\n-    // target -> (cc, ar)\n-    cc: HashMap<Interned<String>, (cc::Tool, Option<PathBuf>)>,\n-    // host -> (cc, ar)\n+    // C/C++ compilers and archiver for all targets\n+    cc: HashMap<Interned<String>, cc::Tool>,\n     cxx: HashMap<Interned<String>, cc::Tool>,\n+    ar: HashMap<Interned<String>, PathBuf>,\n+    // Misc\n     crates: HashMap<Interned<String>, Crate>,\n     is_sudo: bool,\n     ci_env: CiEnv,\n@@ -324,6 +325,7 @@ impl Build {\n             rls_info,\n             cc: HashMap::new(),\n             cxx: HashMap::new(),\n+            ar: HashMap::new(),\n             crates: HashMap::new(),\n             lldb_version: None,\n             lldb_python_dir: None,\n@@ -612,15 +614,15 @@ impl Build {\n \n     /// Returns the path to the C compiler for the target specified.\n     fn cc(&self, target: Interned<String>) -> &Path {\n-        self.cc[&target].0.path()\n+        self.cc[&target].path()\n     }\n \n     /// Returns a list of flags to pass to the C compiler for the target\n     /// specified.\n     fn cflags(&self, target: Interned<String>) -> Vec<String> {\n         // Filter out -O and /O (the optimization flags) that we picked up from\n         // cc-rs because the build scripts will determine that for themselves.\n-        let mut base = self.cc[&target].0.args().iter()\n+        let mut base = self.cc[&target].args().iter()\n                            .map(|s| s.to_string_lossy().into_owned())\n                            .filter(|s| !s.starts_with(\"-O\") && !s.starts_with(\"/O\"))\n                            .collect::<Vec<_>>();\n@@ -644,7 +646,7 @@ impl Build {\n \n     /// Returns the path to the `ar` archive utility for the target specified.\n     fn ar(&self, target: Interned<String>) -> Option<&Path> {\n-        self.cc[&target].1.as_ref().map(|p| &**p)\n+        self.ar.get(&target).map(|p| &**p)\n     }\n \n     /// Returns the path to the C++ compiler for the target specified.\n@@ -657,21 +659,17 @@ impl Build {\n         }\n     }\n \n-    /// Returns flags to pass to the compiler to generate code for `target`.\n-    fn rustc_flags(&self, target: Interned<String>) -> Vec<String> {\n-        // New flags should be added here with great caution!\n-        //\n-        // It's quite unfortunate to **require** flags to generate code for a\n-        // target, so it should only be passed here if absolutely necessary!\n-        // Most default configuration should be done through target specs rather\n-        // than an entry here.\n-\n-        let mut base = Vec::new();\n-        if target != self.config.build && !target.contains(\"msvc\") &&\n-            !target.contains(\"emscripten\") {\n-            base.push(format!(\"-Clinker={}\", self.cc(target).display()));\n+    /// Returns the path to the linker for the given target if it needs to be overriden.\n+    fn linker(&self, target: Interned<String>) -> Option<&Path> {\n+        if let Some(linker) = self.config.target_config.get(&target)\n+                                                       .and_then(|c| c.linker.as_ref()) {\n+            Some(linker)\n+        } else if target != self.config.build &&\n+                  !target.contains(\"msvc\") && !target.contains(\"emscripten\") {\n+            Some(self.cc(target))\n+        } else {\n+            None\n         }\n-        base\n     }\n \n     /// Returns if this target should statically link the C runtime, if specified"}, {"sha": "941ea96bbec23c8b327acf9a6a3471a11c6c21fe", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 44, "deletions": 20, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -227,6 +227,13 @@ impl Step for Llvm {\n             cfg.build_arg(\"-j\").build_arg(build.jobs().to_string());\n             cfg.define(\"CMAKE_C_FLAGS\", build.cflags(target).join(\" \"));\n             cfg.define(\"CMAKE_CXX_FLAGS\", build.cflags(target).join(\" \"));\n+            if let Some(ar) = build.ar(target) {\n+                if ar.is_absolute() {\n+                    // LLVM build breaks if `CMAKE_AR` is a relative path, for some reason it\n+                    // tries to resolve this path in the LLVM build directory.\n+                    cfg.define(\"CMAKE_AR\", sanitize_cc(ar));\n+                }\n+            }\n         };\n \n         configure_compilers(&mut cfg);\n@@ -352,34 +359,51 @@ impl Step for Openssl {\n             // originally from https://www.openssl.org/source/...\n             let url = format!(\"https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/{}\",\n                               name);\n-            let mut ok = false;\n+            let mut last_error = None;\n             for _ in 0..3 {\n                 let status = Command::new(\"curl\")\n                                 .arg(\"-o\").arg(&tmp)\n+                                .arg(\"-f\")  // make curl fail if the URL does not return HTTP 200\n                                 .arg(&url)\n                                 .status()\n                                 .expect(\"failed to spawn curl\");\n-                if status.success() {\n-                    ok = true;\n-                    break\n+\n+                // Retry if download failed.\n+                if !status.success() {\n+                    last_error = Some(status.to_string());\n+                    continue;\n                 }\n+\n+                // Ensure the hash is correct.\n+                let mut shasum = if target.contains(\"apple\") || build.build.contains(\"netbsd\") {\n+                    let mut cmd = Command::new(\"shasum\");\n+                    cmd.arg(\"-a\").arg(\"256\");\n+                    cmd\n+                } else {\n+                    Command::new(\"sha256sum\")\n+                };\n+                let output = output(&mut shasum.arg(&tmp));\n+                let found = output.split_whitespace().next().unwrap();\n+\n+                // If the hash is wrong, probably the download is incomplete or S3 served an error\n+                // page. In any case, retry.\n+                if found != OPENSSL_SHA256 {\n+                    last_error = Some(format!(\n+                        \"downloaded openssl sha256 different\\n\\\n+                         expected: {}\\n\\\n+                         found:    {}\\n\",\n+                        OPENSSL_SHA256,\n+                        found\n+                    ));\n+                    continue;\n+                }\n+\n+                // Everything is fine, so exit the retry loop.\n+                last_error = None;\n+                break;\n             }\n-            if !ok {\n-                panic!(\"failed to download openssl source\")\n-            }\n-            let mut shasum = if target.contains(\"apple\") || build.build.contains(\"netbsd\") {\n-                let mut cmd = Command::new(\"shasum\");\n-                cmd.arg(\"-a\").arg(\"256\");\n-                cmd\n-            } else {\n-                Command::new(\"sha256sum\")\n-            };\n-            let output = output(&mut shasum.arg(&tmp));\n-            let found = output.split_whitespace().next().unwrap();\n-            if found != OPENSSL_SHA256 {\n-                panic!(\"downloaded openssl sha256 different\\n\\\n-                        expected: {}\\n\\\n-                        found:    {}\\n\", OPENSSL_SHA256, found);\n+            if let Some(error) = last_error {\n+                panic!(\"failed to download openssl source: {}\", error);\n             }\n             t!(fs::rename(&tmp, &tarball));\n         }"}, {"sha": "662c56d728dfe9f0d7b34aa80adf77a4b456e9a9", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -387,7 +387,7 @@ pub struct Clippy {\n \n impl Step for Clippy {\n     type Output = PathBuf;\n-    const DEFAULT: bool = false;\n+    const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n@@ -411,7 +411,7 @@ impl Step for Clippy {\n         builder.ensure(ToolBuild {\n             compiler: self.compiler,\n             target: self.target,\n-            tool: \"clippy\",\n+            tool: \"clippy-driver\",\n             mode: Mode::Librustc,\n             path: \"src/tools/clippy\",\n             expectation: builder.build.config.toolstate.clippy.passes(ToolState::Compiling),\n@@ -561,7 +561,7 @@ impl<'a> Builder<'a> {\n         if compiler.host.contains(\"msvc\") {\n             let curpaths = env::var_os(\"PATH\").unwrap_or_default();\n             let curpaths = env::split_paths(&curpaths).collect::<Vec<_>>();\n-            for &(ref k, ref v) in self.cc[&compiler.host].0.env() {\n+            for &(ref k, ref v) in self.cc[&compiler.host].env() {\n                 if k != \"PATH\" {\n                     continue\n                 }"}, {"sha": "328cbf0e5d7102e35fdd143131994719935bbe4f", "filename": "src/bootstrap/toolstate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Ftoolstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbootstrap%2Ftoolstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftoolstate.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -31,6 +31,13 @@ impl ToolState {\n             BuildExpectation::Failing\n         }\n     }\n+\n+    pub fn testing(&self) -> bool {\n+        match *self {\n+            ToolState::Testing => true,\n+            _ => false,\n+        }\n+    }\n }\n \n impl Default for ToolState {"}, {"sha": "97723e260f6cb4404aa04618a546f474db70b024", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -138,27 +138,6 @@ pub fn gnu_target(target: &str) -> String {\n     }\n }\n \n-pub fn cc2ar(cc: &Path, target: &str) -> Option<PathBuf> {\n-    if target.contains(\"msvc\") {\n-        None\n-    } else if target.contains(\"musl\") {\n-        Some(PathBuf::from(\"ar\"))\n-    } else if target.contains(\"openbsd\") {\n-        Some(PathBuf::from(\"ar\"))\n-    } else {\n-        let parent = cc.parent().unwrap();\n-        let file = cc.file_name().unwrap().to_str().unwrap();\n-        for suffix in &[\"gcc\", \"cc\", \"clang\"] {\n-            if let Some(idx) = file.rfind(suffix) {\n-                let mut file = file[..idx].to_owned();\n-                file.push_str(\"ar\");\n-                return Some(parent.join(&file));\n-            }\n-        }\n-        Some(parent.join(file))\n-    }\n-}\n-\n pub fn make(host: &str) -> PathBuf {\n     if host.contains(\"bitrig\") || host.contains(\"dragonfly\") ||\n         host.contains(\"freebsd\") || host.contains(\"netbsd\") ||"}, {"sha": "cc260382f494628102f7c2f59bc7f8f56ea5f4fc", "filename": "src/ci/docker/cross2/Dockerfile", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fci%2Fdocker%2Fcross2%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fci%2Fdocker%2Fcross2%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fcross2%2FDockerfile?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -5,6 +5,7 @@ RUN sh /scripts/cross-apt-packages.sh\n \n RUN apt-get build-dep -y clang llvm && apt-get install -y --no-install-recommends \\\n   build-essential \\\n+  gcc-multilib \\\n   libedit-dev \\\n   libgmp-dev \\\n   libisl-dev \\\n@@ -36,17 +37,18 @@ ENV \\\n     AR_aarch64_unknown_fuchsia=aarch64-unknown-fuchsia-ar \\\n     CC_aarch64_unknown_fuchsia=aarch64-unknown-fuchsia-clang \\\n     CXX_aarch64_unknown_fuchsia=aarch64-unknown-fuchsia-clang++ \\\n-    AR_sparcv9_sun_solaris=sparcv9-sun-solaris2.11-ar \\\n-    CC_sparcv9_sun_solaris=sparcv9-sun-solaris2.11-gcc \\\n-    CXX_sparcv9_sun_solaris=sparcv9-sun-solaris2.11-g++ \\\n-    AR_x86_64_sun_solaris=x86_64-sun-solaris2.11-ar \\\n-    CC_x86_64_sun_solaris=x86_64-sun-solaris2.11-gcc \\\n-    CXX_x86_64_sun_solaris=x86_64-sun-solaris2.11-g++\n+    AR_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-ar \\\n+    CC_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-gcc \\\n+    CXX_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-g++ \\\n+    AR_x86_64_sun_solaris=x86_64-sun-solaris2.10-ar \\\n+    CC_x86_64_sun_solaris=x86_64-sun-solaris2.10-gcc \\\n+    CXX_x86_64_sun_solaris=x86_64-sun-solaris2.10-g++\n \n ENV TARGETS=x86_64-unknown-fuchsia\n ENV TARGETS=$TARGETS,aarch64-unknown-fuchsia\n ENV TARGETS=$TARGETS,sparcv9-sun-solaris\n ENV TARGETS=$TARGETS,x86_64-sun-solaris\n+ENV TARGETS=$TARGETS,x86_64-unknown-linux-gnux32\n \n ENV RUST_CONFIGURE_ARGS --target=$TARGETS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --target $TARGETS"}, {"sha": "935cbe5d61b58eff77992c5df1cee66d300425c8", "filename": "src/ci/docker/cross2/build-solaris-toolchain.sh", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fci%2Fdocker%2Fcross2%2Fbuild-solaris-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fci%2Fdocker%2Fcross2%2Fbuild-solaris-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fcross2%2Fbuild-solaris-toolchain.sh?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -25,7 +25,7 @@ cd binutils\n curl https://ftp.gnu.org/gnu/binutils/binutils-$BINUTILS.tar.xz | tar xJf -\n mkdir binutils-build\n cd binutils-build\n-hide_output ../binutils-$BINUTILS/configure --target=$ARCH-sun-solaris2.11\n+hide_output ../binutils-$BINUTILS/configure --target=$ARCH-sun-solaris2.10\n hide_output make -j10\n hide_output make install\n \n@@ -58,13 +58,17 @@ for deb in *$APT_ARCH.deb; do\n   dpkg -x $deb .\n done\n \n-mkdir                  /usr/local/$ARCH-sun-solaris2.11/usr\n-mv usr/include         /usr/local/$ARCH-sun-solaris2.11/usr/include\n-mv usr/lib/$LIB_ARCH/* /usr/local/$ARCH-sun-solaris2.11/lib\n-mv     lib/$LIB_ARCH/* /usr/local/$ARCH-sun-solaris2.11/lib\n+# Strip Solaris 11 functions that are optionally used by libbacktrace.\n+# This is for Solaris 10 compatibility.\n+$ARCH-sun-solaris2.10-strip -N dl_iterate_phdr -N strnlen lib/$LIB_ARCH/libc.so\n \n-ln -s /usr/local/$ARCH-sun-solaris2.11/usr/include /usr/local/$ARCH-sun-solaris2.11/sys-include\n-ln -s /usr/local/$ARCH-sun-solaris2.11/usr/include /usr/local/$ARCH-sun-solaris2.11/include\n+mkdir                  /usr/local/$ARCH-sun-solaris2.10/usr\n+mv usr/include         /usr/local/$ARCH-sun-solaris2.10/usr/include\n+mv usr/lib/$LIB_ARCH/* /usr/local/$ARCH-sun-solaris2.10/lib\n+mv     lib/$LIB_ARCH/* /usr/local/$ARCH-sun-solaris2.10/lib\n+\n+ln -s /usr/local/$ARCH-sun-solaris2.10/usr/include /usr/local/$ARCH-sun-solaris2.10/sys-include\n+ln -s /usr/local/$ARCH-sun-solaris2.10/usr/include /usr/local/$ARCH-sun-solaris2.10/include\n \n cd ..\n rm -rf solaris\n@@ -80,7 +84,7 @@ mkdir ../gcc-build\n cd ../gcc-build\n hide_output ../gcc-$GCC/configure \\\n   --enable-languages=c,c++        \\\n-  --target=$ARCH-sun-solaris2.11  \\\n+  --target=$ARCH-sun-solaris2.10  \\\n   --with-gnu-as                   \\\n   --with-gnu-ld                   \\\n   --disable-multilib              \\\n@@ -94,7 +98,7 @@ hide_output ../gcc-$GCC/configure \\\n   --disable-libsanitizer          \\\n   --disable-libquadmath-support   \\\n   --disable-lto                   \\\n-  --with-sysroot=/usr/local/$ARCH-sun-solaris2.11\n+  --with-sysroot=/usr/local/$ARCH-sun-solaris2.10\n \n hide_output make -j10\n hide_output make install"}, {"sha": "3aa2b9d58d57afe921423acea218aef31f4f994a", "filename": "src/ci/docker/scripts/android-sdk.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fci%2Fdocker%2Fscripts%2Fandroid-sdk.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fci%2Fdocker%2Fscripts%2Fandroid-sdk.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fandroid-sdk.sh?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -31,7 +31,7 @@ download_sysimage() {\n     # Keep printing yes to accept the licenses\n     while true; do echo yes; sleep 10; done | \\\n         /android/sdk/tools/android update sdk -a --no-ui \\\n-            --filter \"$filter\"\n+            --filter \"$filter\" --no-https\n }\n \n create_avd() {"}, {"sha": "0bb41cee2c518fbed9a7196bd2eb2f1cd373cc4c", "filename": "src/doc/man/rustc.1", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fdoc%2Fman%2Frustc.1", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fdoc%2Fman%2Frustc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fman%2Frustc.1?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -152,9 +152,6 @@ never colorize output.\n \n .SH CODEGEN OPTIONS\n \n-.TP\n-\\fBar\\fR=\\fI/path/to/ar\\fR\n-Path to the archive utility to use when assembling archives.\n .TP\n \\fBlinker\\fR=\\fI/path/to/cc\\fR\n Path to the linker utility to use when linking libraries, executables, and"}, {"sha": "efb5495fe26acf32334ddd188aaa9db53c644a0b", "filename": "src/doc/unstable-book/src/language-features/non-ascii-idents.md", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-ascii-idents.md", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-ascii-idents.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-ascii-idents.md?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -15,4 +15,34 @@ The `non_ascii_idents` feature adds support for non-ASCII identifiers.\n \n const \u03b5: f64 = 0.00001f64;\n const \u03a0: f64 = 3.14f64;\n-```\n\\ No newline at end of file\n+```\n+\n+## Changes to the language reference\n+\n+> **<sup>Lexer:<sup>**  \n+> IDENTIFIER :  \n+> &nbsp;&nbsp; &nbsp;&nbsp; XID_start XID_continue<sup>\\*</sup>  \n+> &nbsp;&nbsp; | `_` XID_continue<sup>+</sup>  \n+\n+An identifier is any nonempty Unicode string of the following form:\n+\n+Either\n+\n+   * The first character has property [`XID_start`]\n+   * The remaining characters have property [`XID_continue`]\n+\n+Or\n+\n+   * The first character is `_`\n+   * The identifier is more than one character, `_` alone is not an identifier\n+   * The remaining characters have property [`XID_continue`]\n+\n+that does _not_ occur in the set of [strict keywords].\n+\n+> **Note**: [`XID_start`] and [`XID_continue`] as character properties cover the\n+> character ranges used to form the more familiar C and Java language-family\n+> identifiers.\n+\n+[`XID_start`]:  http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Start%3A%5D&abb=on&g=&i=\n+[`XID_continue`]: http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Continue%3A%5D&abb=on&g=&i=\n+[strict keywords]: ../reference/keywords.html#strict-keywords"}, {"sha": "ee24dd87d90c38a5438f1ec96c1027697c16cb06", "filename": "src/doc/unstable-book/src/language-features/optin-builtin-traits.md", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Foptin-builtin-traits.md", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Foptin-builtin-traits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Foptin-builtin-traits.md?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -0,0 +1,47 @@\n+# `optin_builtin_traits`\n+\n+The tracking issue for this feature is [#13231] \n+\n+[#13231]: https://github.com/rust-lang/rust/issues/13231\n+\n+----\n+\n+The `optin_builtin_traits` feature gate allows you to define auto traits.\n+\n+Auto traits, like [`Send`] or [`Sync`] in the standard library, are marker traits\n+that are automatically implemented for every type, unless the type, or a type it contains, \n+has explictly opted out via a negative impl. \n+\n+[`Send`]: https://doc.rust-lang.org/std/marker/trait.Send.html\n+[`Sync`]: https://doc.rust-lang.org/std/marker/trait.Sync.html\n+\n+```rust,ignore\n+impl !Type for Trait\n+```\n+\n+Example:\n+\n+```rust\n+#![feature(optin_builtin_traits)]\n+\n+trait Valid {}\n+\n+impl Valid for .. {}\n+\n+struct True;\n+struct False;\n+\n+impl !Valid for False {}\n+\n+struct MaybeValid<T>(T);\n+\n+fn must_be_valid<T: Valid>(_t: T) { }\n+\n+fn main() {\n+    // works\n+    must_be_valid( MaybeValid(True) );\n+                \n+    // compiler error - trait bound not satisfied\n+    // must_be_valid( MaybeValid(False) );\n+}\n+```"}, {"sha": "0eaed7a1989c5ba0304b31c56fbfaa0fa4ad1aa3", "filename": "src/doc/unstable-book/src/language-features/unboxed-closures.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funboxed-closures.md", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funboxed-closures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funboxed-closures.md?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -0,0 +1,25 @@\n+# `unboxed_closures`\n+\n+The tracking issue for this feature is [#29625]\n+\n+See Also: [`fn_traits`](library-features/fn-traits.html)\n+\n+[#29625]: https://github.com/rust-lang/rust/issues/29625\n+\n+----\n+\n+The `unboxed_closures` feature allows you to write functions using the `\"rust-call\"` ABI,\n+required for implmenting the [`Fn*`] family of traits. `\"rust-call\"` functions must have \n+exactly one (non self) argument, a tuple representing the argument list.\n+\n+[`Fn*`]: https://doc.rust-lang.org/std/ops/trait.Fn.html\n+\n+```rust\n+#![feature(unboxed_closures)]\n+\n+extern \"rust-call\" fn add_args(args: (u32, u32)) -> u32 {\n+    args.0 + args.1\n+}\n+\n+fn main() {}\n+```"}, {"sha": "72a3f36c10b69ed1d6acc28e9577c085d71e9cd1", "filename": "src/doc/unstable-book/src/library-features/fn-traits.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffn-traits.md", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffn-traits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffn-traits.md?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -0,0 +1,35 @@\n+# `fn_traits`\n+\n+The tracking issue for this feature is [#29625]\n+\n+See Also: [`unboxed_closures`](language-features/unboxed-closures.html)\n+\n+[#29625]: https://github.com/rust-lang/rust/issues/29625\n+\n+----\n+\n+The `fn_traits` feature allows for implementation of the [`Fn*`] traits\n+for creating custom closure-like types.\n+\n+[`Fn*`]: https://doc.rust-lang.org/std/ops/trait.Fn.html\n+\n+```rust\n+#![feature(unboxed_closures)]\n+#![feature(fn_traits)]\n+\n+struct Adder {\n+    a: u32\n+}\n+\n+impl FnOnce<(u32, )> for Adder {\n+    type Output = u32;\n+    extern \"rust-call\" fn call_once(self, b: (u32, )) -> Self::Output {\n+        self.a + b.0\n+    }\n+}\n+\n+fn main() {\n+    let adder = Adder { a: 3 };\n+    assert_eq!(adder(2), 5);\n+}\n+```"}, {"sha": "0612873e28153b445964ccaffb52021098ddf915", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -248,7 +248,10 @@ def __init__(self, val):\n     def to_string(self):\n         (length, data_ptr) = rustpp.extract_length_and_ptr_from_slice(self.__val)\n         raw_ptr = data_ptr.get_wrapped_value()\n-        return '\"%s\"' % raw_ptr.string(encoding=\"utf-8\", length=length)\n+        return raw_ptr.lazy_string(encoding=\"utf-8\", length=length)\n+\n+    def display_hint(self):\n+        return \"string\"\n \n \n class RustStdVecPrinter(object):\n@@ -278,9 +281,11 @@ def __init__(self, val):\n     def to_string(self):\n         vec = self.__val.get_child_at_index(0)\n         (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(vec)\n-        return '\"%s\"' % data_ptr.get_wrapped_value().string(encoding=\"utf-8\",\n-                                                            length=length)\n+        return data_ptr.get_wrapped_value().lazy_string(encoding=\"utf-8\",\n+                                                        length=length)\n \n+    def display_hint(self):\n+        return \"string\"\n \n class RustOsStringPrinter(object):\n     def __init__(self, val):\n@@ -294,8 +299,10 @@ def to_string(self):\n \n         (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(\n             vec)\n-        return '\"%s\"' % data_ptr.get_wrapped_value().string(length=length)\n+        return data_ptr.get_wrapped_value().lazy_string(length=length)\n \n+    def display_hint(self):\n+        return \"string\"\n \n class RustCStyleVariantPrinter(object):\n     def __init__(self, val):"}, {"sha": "c22d60b6c5df1031313c4ed4e30c3c6e9e6d69de", "filename": "src/etc/installer/exe/rust.iss", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fetc%2Finstaller%2Fexe%2Frust.iss", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fetc%2Finstaller%2Fexe%2Frust.iss", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstaller%2Fexe%2Frust.iss?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -46,7 +46,9 @@ Name: gcc; Description: \"Linker and platform libraries\"; Types: full\n Name: docs; Description: \"HTML documentation\"; Types: full\n Name: cargo; Description: \"Cargo, the Rust package manager\"; Types: full\n Name: std; Description: \"The Rust Standard Library\"; Types: full\n+// tool-rls-start\n Name: rls; Description: \"RLS, the Rust Language Server\"\n+// tool-rls-end\n \n [Files]\n Source: \"rustc/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: rust\n@@ -56,8 +58,10 @@ Source: \"rust-mingw/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs;\n Source: \"rust-docs/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: docs\n Source: \"cargo/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: cargo\n Source: \"rust-std/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: std\n+// tool-rls-start\n Source: \"rls/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: rls\n Source: \"rust-analysis/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: rls\n+// tool-rls-end\n \n [Code]\n const"}, {"sha": "d95b096d732f41ede7743ff8d08341b2d54392fc", "filename": "src/etc/installer/msi/rust.wxs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fetc%2Finstaller%2Fmsi%2Frust.wxs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fetc%2Finstaller%2Fmsi%2Frust.wxs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstaller%2Fmsi%2Frust.wxs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -170,8 +170,10 @@\n                     <Directory Id=\"Docs\" Name=\".\" />\n                     <Directory Id=\"Cargo\" Name=\".\" />\n                     <Directory Id=\"Std\" Name=\".\" />\n+                    <!-- tool-rls-start -->\n                     <Directory Id=\"Rls\" Name=\".\" />\n                     <Directory Id=\"Analysis\" Name=\".\" />\n+                    <!-- tool-rls-end -->\n                 </Directory>\n             </Directory>\n \n@@ -275,6 +277,7 @@\n                  <ComponentRef Id=\"PathEnvPerMachine\" />\n                  <ComponentRef Id=\"PathEnvPerUser\" />\n         </Feature>\n+        <!-- tool-rls-start -->\n         <Feature Id=\"RLS\"\n                  Title=\"RLS, the Rust Language Server\"\n                  Display=\"7\"\n@@ -283,6 +286,7 @@\n                  <ComponentGroupRef Id=\"RlsGroup\" />\n                  <ComponentGroupRef Id=\"AnalysisGroup\" />\n         </Feature>\n+        <!-- tool-rls-end -->\n \n         <UIRef Id=\"RustUI\" />\n     </Product>"}, {"sha": "077ee17511655b9018ee0fe5e2270d911edb805a", "filename": "src/etc/installer/pkg/Distribution.xml", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fetc%2Finstaller%2Fpkg%2FDistribution.xml", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fetc%2Finstaller%2Fpkg%2FDistribution.xml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstaller%2Fpkg%2FDistribution.xml?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -16,7 +16,9 @@\n       <line choice=\"rust-std\"/>\n       <line choice=\"cargo\"/>\n       <line choice=\"rust-docs\"/>\n+      <!-- tool-rls-start -->\n       <line choice=\"rls\"/>\n+      <!-- tool-rls-end -->\n       </line>\n       <line choice=\"uninstall\" />\n     </choices-outline>\n@@ -62,6 +64,7 @@\n         >\n         <pkg-ref id=\"org.rust-lang.rust-docs\"/>\n     </choice>\n+    <!-- tool-rls-start -->\n     <choice id=\"rls\" visible=\"true\"\n         title=\"RLS\" description=\"RLS, the Rust Language Server\"\n         selected=\"(!choices.uninstall.selected &amp;&amp; choices['rls'].selected) || (choices.uninstall.selected &amp;&amp; choices.install.selected)\"\n@@ -70,11 +73,14 @@\n         <pkg-ref id=\"org.rust-lang.rls\"/>\n         <pkg-ref id=\"org.rust-lang.rust-analysis\"/>\n     </choice>\n+    <!-- tool-rls-end -->\n     <pkg-ref id=\"org.rust-lang.rustc\" version=\"0\" onConclusion=\"none\">rustc.pkg</pkg-ref>\n     <pkg-ref id=\"org.rust-lang.cargo\" version=\"0\" onConclusion=\"none\">cargo.pkg</pkg-ref>\n     <pkg-ref id=\"org.rust-lang.rust-docs\" version=\"0\" onConclusion=\"none\">rust-docs.pkg</pkg-ref>\n     <pkg-ref id=\"org.rust-lang.rust-std\" version=\"0\" onConclusion=\"none\">rust-std.pkg</pkg-ref>\n+    <!-- tool-rls-start -->\n     <pkg-ref id=\"org.rust-lang.rls\" version=\"0\" onConclusion=\"none\">rls.pkg</pkg-ref>\n+    <!-- tool-rls-end -->\n     <pkg-ref id=\"org.rust-lang.rust-analysis\" version=\"0\" onConclusion=\"none\">rust-analysis.pkg</pkg-ref>\n     <pkg-ref id=\"org.rust-lang.uninstall\" version=\"0\" onConclusion=\"none\">uninstall.pkg</pkg-ref>\n     <background file=\"rust-logo.png\" mime-type=\"image/png\""}, {"sha": "24a0ce0ac3611270cd6630a26b1595d48afcc40d", "filename": "src/etc/lldb_batchmode.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fetc%2Flldb_batchmode.py", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fetc%2Flldb_batchmode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_batchmode.py?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -81,7 +81,7 @@ def execute_command(command_interpreter, command):\n \n     if res.Succeeded():\n         if res.HasResult():\n-            print(normalize_whitespace(res.GetOutput()), end='\\n')\n+            print(normalize_whitespace(res.GetOutput() or ''), end='\\n')\n \n         # If the command introduced any breakpoints, make sure to register\n         # them with the breakpoint"}, {"sha": "2f282c8281d6eeba11b412101461aef4a2f3baa3", "filename": "src/grammar/lexer.l", "status": "modified", "additions": 45, "deletions": 28, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fgrammar%2Flexer.l", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fgrammar%2Flexer.l", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Flexer.l?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -85,43 +85,60 @@ ident [a-zA-Z\\x80-\\xff_][a-zA-Z0-9\\x80-\\xff_]*\n <blockcomment>(.|\\n)   { }\n \n _        { return UNDERSCORE; }\n+abstract { return ABSTRACT; }\n+alignof  { return ALIGNOF; }\n as       { return AS; }\n+become   { return BECOME; }\n box      { return BOX; }\n break    { return BREAK; }\n+catch    { return CATCH; }\n const    { return CONST; }\n continue { return CONTINUE; }\n crate    { return CRATE; }\n+default  { return DEFAULT; }\n+do       { return DO; }\n else     { return ELSE; }\n enum     { return ENUM; }\n extern   { return EXTERN; }\n false    { return FALSE; }\n+final    { return FINAL; }\n fn       { return FN; }\n for      { return FOR; }\n if       { return IF; }\n impl     { return IMPL; }\n in       { return IN; }\n let      { return LET; }\n loop     { return LOOP; }\n+macro    { return MACRO; }\n match    { return MATCH; }\n mod      { return MOD; }\n move     { return MOVE; }\n mut      { return MUT; }\n+offsetof { return OFFSETOF; }\n+override { return OVERRIDE; }\n priv     { return PRIV; }\n proc     { return PROC; }\n+pure     { return PURE; }\n pub      { return PUB; }\n ref      { return REF; }\n return   { return RETURN; }\n self     { return SELF; }\n+sizeof   { return SIZEOF; }\n static   { return STATIC; }\n struct   { return STRUCT; }\n+super    { return SUPER; }\n trait    { return TRAIT; }\n true     { return TRUE; }\n type     { return TYPE; }\n typeof   { return TYPEOF; }\n+union    { return UNION; }\n unsafe   { return UNSAFE; }\n+unsized  { return UNSIZED; }\n use      { return USE; }\n+virtual  { return VIRTUAL; }\n where    { return WHERE; }\n while    { return WHILE; }\n+yield    { return YIELD; }\n \n {ident}  { return IDENT; }\n \n@@ -189,25 +206,25 @@ while    { return WHILE; }\n \\>\\>= { return SHREQ; }\n \\>    { return '>'; }\n \n-\\x27                                  { BEGIN(ltorchar); yymore(); }\n-<ltorchar>static                      { BEGIN(INITIAL); return STATIC_LIFETIME; }\n-<ltorchar>{ident}                     { BEGIN(INITIAL); return LIFETIME; }\n-<ltorchar>\\\\[nrt\\\\\\x27\\x220]\\x27      { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>\\\\x[0-9a-fA-F]{2}\\x27       { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>\\\\u\\{[0-9a-fA-F]?{6}\\}\\x27  { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>.\\x27                       { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>[\\x80-\\xff]{2,4}\\x27        { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar><<EOF>>                     { BEGIN(INITIAL); return -1; }\n+\\x27                                      { BEGIN(ltorchar); yymore(); }\n+<ltorchar>static                          { BEGIN(INITIAL); return STATIC_LIFETIME; }\n+<ltorchar>{ident}                         { BEGIN(INITIAL); return LIFETIME; }\n+<ltorchar>\\\\[nrt\\\\\\x27\\x220]\\x27          { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>\\\\x[0-9a-fA-F]{2}\\x27           { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>\\\\u\\{([0-9a-fA-F]_*){1,6}\\}\\x27 { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>.\\x27                           { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>[\\x80-\\xff]{2,4}\\x27            { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar><<EOF>>                         { BEGIN(INITIAL); return -1; }\n \n b\\x22              { BEGIN(bytestr); yymore(); }\n <bytestr>\\x22      { BEGIN(suffix); return LIT_BYTE_STR; }\n \n-<bytestr><<EOF>>                { return -1; }\n-<bytestr>\\\\[n\\nrt\\\\\\x27\\x220]   { yymore(); }\n-<bytestr>\\\\x[0-9a-fA-F]{2}      { yymore(); }\n-<bytestr>\\\\u\\{[0-9a-fA-F]?{6}\\} { yymore(); }\n-<bytestr>\\\\[^n\\nrt\\\\\\x27\\x220]  { return -1; }\n-<bytestr>(.|\\n)                 { yymore(); }\n+<bytestr><<EOF>>                     { return -1; }\n+<bytestr>\\\\[n\\nrt\\\\\\x27\\x220]        { yymore(); }\n+<bytestr>\\\\x[0-9a-fA-F]{2}           { yymore(); }\n+<bytestr>\\\\u\\{([0-9a-fA-F]_*){1,6}\\} { yymore(); }\n+<bytestr>\\\\[^n\\nrt\\\\\\x27\\x220]       { return -1; }\n+<bytestr>(.|\\n)                      { yymore(); }\n \n br\\x22                      { BEGIN(rawbytestr_nohash); yymore(); }\n <rawbytestr_nohash>\\x22     { BEGIN(suffix); return LIT_BYTE_STR_RAW; }\n@@ -252,13 +269,13 @@ br/# {\n }\n <rawbytestr><<EOF>> { return -1; }\n \n-b\\x27                        { BEGIN(byte); yymore(); }\n-<byte>\\\\[nrt\\\\\\x27\\x220]\\x27 { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>\\\\x[0-9a-fA-F]{2}\\x27  { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>\\\\u[0-9a-fA-F]{4}\\x27  { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>\\\\U[0-9a-fA-F]{8}\\x27  { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>.\\x27                  { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte><<EOF>>                { BEGIN(INITIAL); return -1; }\n+b\\x27                           { BEGIN(byte); yymore(); }\n+<byte>\\\\[nrt\\\\\\x27\\x220]\\x27    { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>\\\\x[0-9a-fA-F]{2}\\x27     { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>\\\\u([0-9a-fA-F]_*){4}\\x27 { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>\\\\U([0-9a-fA-F]_*){8}\\x27 { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>.\\x27                     { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte><<EOF>>                   { BEGIN(INITIAL); return -1; }\n \n r\\x22           { BEGIN(rawstr); yymore(); }\n <rawstr>\\x22    { BEGIN(suffix); return LIT_STR_RAW; }\n@@ -310,12 +327,12 @@ r/#             {\n \\x22                     { BEGIN(str); yymore(); }\n <str>\\x22                { BEGIN(suffix); return LIT_STR; }\n \n-<str><<EOF>>                { return -1; }\n-<str>\\\\[n\\nr\\rt\\\\\\x27\\x220] { yymore(); }\n-<str>\\\\x[0-9a-fA-F]{2}      { yymore(); }\n-<str>\\\\u\\{[0-9a-fA-F]?{6}\\} { yymore(); }\n-<str>\\\\[^n\\nrt\\\\\\x27\\x220]  { return -1; }\n-<str>(.|\\n)                 { yymore(); }\n+<str><<EOF>>                     { return -1; }\n+<str>\\\\[n\\nr\\rt\\\\\\x27\\x220]      { yymore(); }\n+<str>\\\\x[0-9a-fA-F]{2}           { yymore(); }\n+<str>\\\\u\\{([0-9a-fA-F]_*){1,6}\\} { yymore(); }\n+<str>\\\\[^n\\nrt\\\\\\x27\\x220]       { return -1; }\n+<str>(.|\\n)                      { yymore(); }\n \n \\<-  { return LARROW; }\n -\\>  { return RARROW; }"}, {"sha": "de1f96aac504653db2d440a8426ea623143abc29", "filename": "src/grammar/parser-lalr.y", "status": "modified", "additions": 208, "deletions": 158, "changes": 366, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr.y?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -62,33 +62,49 @@ extern char *yytext;\n // keywords\n %token SELF\n %token STATIC\n+%token ABSTRACT\n+%token ALIGNOF\n %token AS\n+%token BECOME\n %token BREAK\n+%token CATCH\n %token CRATE\n+%token DO\n %token ELSE\n %token ENUM\n %token EXTERN\n %token FALSE\n+%token FINAL\n %token FN\n %token FOR\n %token IF\n %token IMPL\n %token IN\n %token LET\n %token LOOP\n+%token MACRO\n %token MATCH\n %token MOD\n %token MOVE\n %token MUT\n+%token OFFSETOF\n+%token OVERRIDE\n %token PRIV\n %token PUB\n+%token PURE\n %token REF\n %token RETURN\n+%token SIZEOF\n %token STRUCT\n+%token SUPER\n+%token UNION\n+%token UNSIZED\n %token TRUE\n %token TRAIT\n %token TYPE\n %token UNSAFE\n+%token VIRTUAL\n+%token YIELD\n %token DEFAULT\n %token USE\n %token WHILE\n@@ -141,6 +157,10 @@ extern char *yytext;\n // 'foo:bar . <' is shifted (in a trait reference occurring in a\n // bounds list), parsing as foo:(bar<baz>) rather than (foo:bar)<baz>.\n %precedence IDENT\n+ // Put the weak keywords that can be used as idents here as well\n+%precedence CATCH\n+%precedence DEFAULT\n+%precedence UNION\n \n // A couple fake-precedence symbols to use in rules associated with +\n // and < in trailing type contexts. These come up when you have a type\n@@ -161,13 +181,13 @@ extern char *yytext;\n %precedence FOR\n \n // Binops & unops, and their precedences\n+%precedence '?'\n %precedence BOX\n-%precedence BOXPLACE\n %nonassoc DOTDOT\n \n // RETURN needs to be lower-precedence than tokens that start\n // prefix_exprs\n-%precedence RETURN\n+%precedence RETURN YIELD\n \n %right '=' SHLEQ SHREQ MINUSEQ ANDEQ OREQ PLUSEQ STAREQ SLASHEQ CARETEQ PERCENTEQ\n %right LARROW\n@@ -321,6 +341,8 @@ view_path\n | path_no_types_allowed MOD_SEP '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 2, $1, $4); }\n |                       MOD_SEP '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 1, $3); }\n | path_no_types_allowed MOD_SEP '*'                        { $$ = mk_node(\"ViewPathGlob\", 1, $1); }\n+|                       MOD_SEP '*'                        { $$ = mk_atom(\"ViewPathGlob\"); }\n+|                               '*'                        { $$ = mk_atom(\"ViewPathGlob\"); }\n |                               '{'                '}'     { $$ = mk_atom(\"ViewPathListEmpty\"); }\n |                               '{' idents_or_self '}'     { $$ = mk_node(\"ViewPathList\", 1, $2); }\n |                               '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 1, $2); }\n@@ -334,6 +356,7 @@ block_item\n | item_foreign_mod          { $$ = mk_node(\"ItemForeignMod\", 1, $1); }\n | item_struct\n | item_enum\n+| item_union\n | item_trait\n | item_impl\n ;\n@@ -387,6 +410,7 @@ struct_decl_field\n struct_tuple_fields\n : struct_tuple_field                          { $$ = mk_node(\"StructFields\", 1, $1); }\n | struct_tuple_fields ',' struct_tuple_field  { $$ = ext_node($1, 1, $3); }\n+| %empty                                      { $$ = mk_none(); }\n ;\n \n struct_tuple_field\n@@ -417,6 +441,11 @@ enum_args\n | %empty                         { $$ = mk_none(); }\n ;\n \n+// unions\n+item_union\n+: UNION ident generic_params maybe_where_clause '{' struct_decl_fields '}'     { $$ = mk_node(\"ItemUnion\", 0); }\n+| UNION ident generic_params maybe_where_clause '{' struct_decl_fields ',' '}' { $$ = mk_node(\"ItemUnion\", 0); }\n+\n item_mod\n : MOD ident ';'                                 { $$ = mk_node(\"ItemMod\", 1, $2); }\n | MOD ident '{' maybe_mod_items '}'             { $$ = mk_node(\"ItemMod\", 2, $2, $4); }\n@@ -475,7 +504,7 @@ visibility\n \n idents_or_self\n : ident_or_self                    { $$ = mk_node(\"IdentsOrSelf\", 1, $1); }\n-| ident_or_self AS ident           { $$ = mk_node(\"IdentsOrSelf\", 2, $1, $3); }\n+| idents_or_self AS ident          { $$ = mk_node(\"IdentsOrSelf\", 2, $1, $3); }\n | idents_or_self ',' ident_or_self { $$ = ext_node($1, 1, $3); }\n ;\n \n@@ -515,6 +544,7 @@ trait_item\n : trait_const\n | trait_type\n | trait_method\n+| maybe_outer_attrs item_macro { $$ = mk_node(\"TraitMacroItem\", 2, $1, $2); }\n ;\n \n trait_const\n@@ -547,36 +577,48 @@ trait_method\n ;\n \n type_method\n-: attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n+: maybe_outer_attrs maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n {\n   $$ = mk_node(\"TypeMethod\", 6, $1, $2, $4, $5, $6, $7);\n }\n-| attrs_and_vis maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n+| maybe_outer_attrs CONST maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n+{\n+  $$ = mk_node(\"TypeMethod\", 6, $1, $3, $5, $6, $7, $8);\n+}\n+| maybe_outer_attrs maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n {\n   $$ = mk_node(\"TypeMethod\", 7, $1, $2, $4, $6, $7, $8, $9);\n }\n ;\n \n method\n-: attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n+: maybe_outer_attrs maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n {\n   $$ = mk_node(\"Method\", 7, $1, $2, $4, $5, $6, $7, $8);\n }\n-| attrs_and_vis maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n+| maybe_outer_attrs CONST maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"Method\", 7, $1, $3, $5, $6, $7, $8, $9);\n+}\n+| maybe_outer_attrs maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n {\n   $$ = mk_node(\"Method\", 8, $1, $2, $4, $6, $7, $8, $9, $10);\n }\n ;\n \n impl_method\n-: attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n+: attrs_and_vis maybe_default maybe_unsafe FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n {\n-  $$ = mk_node(\"Method\", 7, $1, $2, $4, $5, $6, $7, $8);\n+  $$ = mk_node(\"Method\", 8, $1, $2, $3, $5, $6, $7, $8, $9);\n }\n-| attrs_and_vis maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n+| attrs_and_vis maybe_default CONST maybe_unsafe FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n {\n   $$ = mk_node(\"Method\", 8, $1, $2, $4, $6, $7, $8, $9, $10);\n }\n+| attrs_and_vis maybe_default maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"Method\", 9, $1, $2, $3, $5, $7, $8, $9, $10, $11);\n+}\n ;\n \n // There are two forms of impl:\n@@ -638,26 +680,39 @@ impl_item\n | impl_type\n ;\n \n+maybe_default\n+: DEFAULT { $$ = mk_atom(\"Default\"); }\n+| %empty { $$ = mk_none(); }\n+;\n+\n impl_const\n-: attrs_and_vis item_const { $$ = mk_node(\"ImplConst\", 1, $1, $2); }\n+: attrs_and_vis maybe_default item_const { $$ = mk_node(\"ImplConst\", 3, $1, $2, $3); }\n ;\n \n impl_type\n-: attrs_and_vis TYPE ident generic_params '=' ty_sum ';'  { $$ = mk_node(\"ImplType\", 4, $1, $3, $4, $6); }\n+: attrs_and_vis maybe_default TYPE ident generic_params '=' ty_sum ';'  { $$ = mk_node(\"ImplType\", 5, $1, $2, $4, $5, $7); }\n ;\n \n item_fn\n : FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n {\n   $$ = mk_node(\"ItemFn\", 5, $2, $3, $4, $5, $6);\n }\n+| CONST FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"ItemFn\", 5, $3, $4, $5, $6, $7);\n+}\n ;\n \n item_unsafe_fn\n : UNSAFE FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n {\n   $$ = mk_node(\"ItemUnsafeFn\", 5, $3, $4, $5, $6, $7);\n }\n+| CONST UNSAFE FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"ItemUnsafeFn\", 5, $4, $5, $6, $7, $8);\n+}\n | UNSAFE EXTERN maybe_abi FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n {\n   $$ = mk_node(\"ItemUnsafeFn\", 6, $3, $5, $6, $7, $8, $9);\n@@ -723,12 +778,6 @@ inferrable_param\n : pat maybe_ty_ascription { $$ = mk_node(\"InferrableParam\", 2, $1, $2); }\n ;\n \n-maybe_unboxed_closure_kind\n-: %empty\n-| ':'\n-| '&' maybe_mut ':'\n-;\n-\n maybe_comma_params\n : ','            { $$ = mk_none(); }\n | ',' params     { $$ = $2; }\n@@ -784,7 +833,8 @@ ret_ty\n ;\n \n generic_params\n-: '<' lifetimes '>'                   { $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n+: '<' '>'                             { $$ = mk_node(\"Generics\", 2, mk_none(), mk_none()); }\n+| '<' lifetimes '>'                   { $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n | '<' lifetimes ',' '>'               { $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n | '<' lifetimes SHR                   { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n | '<' lifetimes ',' SHR               { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n@@ -837,6 +887,8 @@ path_no_types_allowed\n | MOD_SEP ident                       { $$ = mk_node(\"ViewPath\", 1, $2); }\n | SELF                                { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Self\")); }\n | MOD_SEP SELF                        { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Self\")); }\n+| SUPER                               { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Super\")); }\n+| MOD_SEP SUPER                       { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Super\")); }\n | path_no_types_allowed MOD_SEP ident { $$ = ext_node($1, 1, $3); }\n ;\n \n@@ -882,7 +934,7 @@ generic_args\n ;\n \n generic_values\n-: maybe_lifetimes maybe_ty_sums_and_or_bindings { $$ = mk_node(\"GenericValues\", 2, $1, $2); }\n+: maybe_ty_sums_and_or_bindings { $$ = mk_node(\"GenericValues\", 1, $1); }\n ;\n \n maybe_ty_sums_and_or_bindings\n@@ -910,12 +962,11 @@ pat\n | ANDAND pat                                      { $$ = mk_node(\"PatRegion\", 1, mk_node(\"PatRegion\", 1, $2)); }\n | '(' ')'                                         { $$ = mk_atom(\"PatUnit\"); }\n | '(' pat_tup ')'                                 { $$ = mk_node(\"PatTup\", 1, $2); }\n-| '(' pat_tup ',' ')'                             { $$ = mk_node(\"PatTup\", 1, $2); }\n | '[' pat_vec ']'                                 { $$ = mk_node(\"PatVec\", 1, $2); }\n | lit_or_path\n | lit_or_path DOTDOTDOT lit_or_path               { $$ = mk_node(\"PatRange\", 2, $1, $3); }\n | path_expr '{' pat_struct '}'                    { $$ = mk_node(\"PatStruct\", 2, $1, $3); }\n-| path_expr '(' DOTDOT ')'                        { $$ = mk_node(\"PatEnum\", 1, $1); }\n+| path_expr '(' ')'                               { $$ = mk_node(\"PatEnum\", 2, $1, mk_none()); }\n | path_expr '(' pat_tup ')'                       { $$ = mk_node(\"PatEnum\", 2, $1, $3); }\n | path_expr '!' maybe_ident delimited_token_trees { $$ = mk_node(\"PatMac\", 3, $1, $3, $4); }\n | binding_mode ident                              { $$ = mk_node(\"PatIdent\", 2, $1, $2); }\n@@ -953,6 +1004,7 @@ pat_field\n | BOX binding_mode ident        { $$ = mk_node(\"PatField\", 3, mk_atom(\"box\"), $2, $3); }\n |              ident ':' pat    { $$ = mk_node(\"PatField\", 2, $1, $3); }\n | binding_mode ident ':' pat    { $$ = mk_node(\"PatField\", 3, $1, $2, $4); }\n+|        LIT_INTEGER ':' pat    { $$ = mk_node(\"PatField\", 2, mk_atom(yytext), $3); }\n ;\n \n pat_fields\n@@ -965,11 +1017,26 @@ pat_struct\n | pat_fields ','             { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"false\")); }\n | pat_fields ',' DOTDOT      { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"true\")); }\n | DOTDOT                     { $$ = mk_node(\"PatStruct\", 1, mk_atom(\"true\")); }\n+| %empty                     { $$ = mk_node(\"PatStruct\", 1, mk_none()); }\n ;\n \n pat_tup\n-: pat               { $$ = mk_node(\"pat_tup\", 1, $1); }\n-| pat_tup ',' pat   { $$ = ext_node($1, 1, $3); }\n+: pat_tup_elts                                  { $$ = mk_node(\"PatTup\", 2, $1, mk_none()); }\n+| pat_tup_elts                             ','  { $$ = mk_node(\"PatTup\", 2, $1, mk_none()); }\n+| pat_tup_elts     DOTDOT                       { $$ = mk_node(\"PatTup\", 2, $1, mk_none()); }\n+| pat_tup_elts ',' DOTDOT                       { $$ = mk_node(\"PatTup\", 2, $1, mk_none()); }\n+| pat_tup_elts     DOTDOT ',' pat_tup_elts      { $$ = mk_node(\"PatTup\", 2, $1, $4); }\n+| pat_tup_elts     DOTDOT ',' pat_tup_elts ','  { $$ = mk_node(\"PatTup\", 2, $1, $4); }\n+| pat_tup_elts ',' DOTDOT ',' pat_tup_elts      { $$ = mk_node(\"PatTup\", 2, $1, $5); }\n+| pat_tup_elts ',' DOTDOT ',' pat_tup_elts ','  { $$ = mk_node(\"PatTup\", 2, $1, $5); }\n+|                  DOTDOT ',' pat_tup_elts      { $$ = mk_node(\"PatTup\", 2, mk_none(), $3); }\n+|                  DOTDOT ',' pat_tup_elts ','  { $$ = mk_node(\"PatTup\", 2, mk_none(), $3); }\n+|                  DOTDOT                       { $$ = mk_node(\"PatTup\", 2, mk_none(), mk_none()); }\n+;\n+\n+pat_tup_elts\n+: pat                    { $$ = mk_node(\"PatTupElts\", 1, $1); }\n+| pat_tup_elts ',' pat   { $$ = ext_node($1, 1, $3); }\n ;\n \n pat_vec\n@@ -1007,24 +1074,25 @@ ty\n ;\n \n ty_prim\n-: %prec IDENT path_generic_args_without_colons              { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"false\")), $1); }\n-| %prec IDENT MOD_SEP path_generic_args_without_colons      { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"true\")), $2); }\n-| %prec IDENT SELF MOD_SEP path_generic_args_without_colons { $$ = mk_node(\"TyPath\", 2, mk_node(\"self\", 1, mk_atom(\"true\")), $3); }\n-| BOX ty                                                    { $$ = mk_node(\"TyBox\", 1, $2); }\n-| '*' maybe_mut_or_const ty                                 { $$ = mk_node(\"TyPtr\", 2, $2, $3); }\n-| '&' ty                                                    { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2); }\n-| '&' MUT ty                                                { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3); }\n-| ANDAND ty                                                 { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2)); }\n-| ANDAND MUT ty                                             { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3)); }\n-| '&' lifetime maybe_mut ty                                 { $$ = mk_node(\"TyRptr\", 3, $2, $3, $4); }\n-| ANDAND lifetime maybe_mut ty                              { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 3, $2, $3, $4)); }\n-| '[' ty ']'                                                { $$ = mk_node(\"TyVec\", 1, $2); }\n-| '[' ty ',' DOTDOT expr ']'                                { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $5); }\n-| '[' ty ';' expr ']'                                       { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $4); }\n-| TYPEOF '(' expr ')'                                       { $$ = mk_node(\"TyTypeof\", 1, $3); }\n-| UNDERSCORE                                                { $$ = mk_atom(\"TyInfer\"); }\n+: %prec IDENT path_generic_args_without_colons                                               { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"false\")), $1); }\n+| %prec IDENT MOD_SEP path_generic_args_without_colons                                       { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"true\")), $2); }\n+| %prec IDENT SELF MOD_SEP path_generic_args_without_colons                                  { $$ = mk_node(\"TyPath\", 2, mk_node(\"self\", 1, mk_atom(\"true\")), $3); }\n+| %prec IDENT path_generic_args_without_colons '!' maybe_ident delimited_token_trees         { $$ = mk_node(\"TyMacro\", 3, $1, $3, $4); }\n+| %prec IDENT MOD_SEP path_generic_args_without_colons '!' maybe_ident delimited_token_trees { $$ = mk_node(\"TyMacro\", 3, $2, $4, $5); }\n+| BOX ty                                                                                     { $$ = mk_node(\"TyBox\", 1, $2); }\n+| '*' maybe_mut_or_const ty                                                                  { $$ = mk_node(\"TyPtr\", 2, $2, $3); }\n+| '&' ty                                                                                     { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2); }\n+| '&' MUT ty                                                                                 { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3); }\n+| ANDAND ty                                                                                  { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2)); }\n+| ANDAND MUT ty                                                                              { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3)); }\n+| '&' lifetime maybe_mut ty                                                                  { $$ = mk_node(\"TyRptr\", 3, $2, $3, $4); }\n+| ANDAND lifetime maybe_mut ty                                                               { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 3, $2, $3, $4)); }\n+| '[' ty ']'                                                                                 { $$ = mk_node(\"TyVec\", 1, $2); }\n+| '[' ty ',' DOTDOT expr ']'                                                                 { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $5); }\n+| '[' ty ';' expr ']'                                                                        { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $4); }\n+| TYPEOF '(' expr ')'                                                                        { $$ = mk_node(\"TyTypeof\", 1, $3); }\n+| UNDERSCORE                                                                                 { $$ = mk_atom(\"TyInfer\"); }\n | ty_bare_fn\n-| ty_proc\n | for_in_type\n ;\n \n@@ -1046,17 +1114,12 @@ ty_closure\n |        OROR maybe_bounds ret_ty                { $$ = mk_node(\"TyClosure\", 2, $2, $3); }\n ;\n \n-ty_proc\n-: PROC generic_params fn_params maybe_bounds ret_ty { $$ = mk_node(\"TyProc\", 4, $2, $3, $4, $5); }\n-;\n-\n for_in_type\n : FOR '<' maybe_lifetimes '>' for_in_type_suffix { $$ = mk_node(\"ForInType\", 2, $3, $5); }\n ;\n \n for_in_type_suffix\n-: ty_proc\n-| ty_bare_fn\n+: ty_bare_fn\n | trait_ref\n | ty_closure\n ;\n@@ -1100,13 +1163,23 @@ ty_sums\n ;\n \n ty_sum\n-: ty                     { $$ = mk_node(\"TySum\", 1, $1); }\n-| ty '+' ty_param_bounds { $$ = mk_node(\"TySum\", 2, $1, $3); }\n+: ty_sum_elt            { $$ = mk_node(\"TySum\", 1, $1); }\n+| ty_sum '+' ty_sum_elt { $$ = ext_node($1, 1, $3); }\n+;\n+\n+ty_sum_elt\n+: ty\n+| lifetime\n ;\n \n ty_prim_sum\n-: ty_prim                     { $$ = mk_node(\"TySum\", 1, $1); }\n-| ty_prim '+' ty_param_bounds { $$ = mk_node(\"TySum\", 2, $1, $3); }\n+: ty_prim_sum_elt                 { $$ = mk_node(\"TySum\", 1, $1); }\n+| ty_prim_sum '+' ty_prim_sum_elt { $$ = ext_node($1, 1, $3); }\n+;\n+\n+ty_prim_sum_elt\n+: ty_prim\n+| lifetime\n ;\n \n maybe_ty_param_bounds\n@@ -1127,6 +1200,7 @@ boundseq\n polybound\n : FOR '<' maybe_lifetimes '>' bound { $$ = mk_node(\"PolyBound\", 2, $3, $5); }\n | bound\n+| '?' FOR '<' maybe_lifetimes '>' bound { $$ = mk_node(\"PolyBound\", 2, $4, $6); }\n | '?' bound { $$ = $2; }\n ;\n \n@@ -1244,26 +1318,22 @@ maybe_stmts\n // block, nonblock-prefix, and nonblock-nonprefix.\n //\n // In non-stmts contexts, expr can relax this trichotomy.\n-//\n-// There is also one other expr subtype: nonparen_expr disallows exprs\n-// surrounded by parens (including tuple expressions), this is\n-// necessary for BOX (place) expressions, so a parens expr following\n-// the BOX is always parsed as the place.\n \n stmts\n : stmt           { $$ = mk_node(\"stmts\", 1, $1); }\n | stmts stmt     { $$ = ext_node($1, 1, $2); }\n ;\n \n stmt\n-: let\n+: maybe_outer_attrs let     { $$ = $2; }\n |                 stmt_item\n |             PUB stmt_item { $$ = $2; }\n | outer_attrs     stmt_item { $$ = $2; }\n | outer_attrs PUB stmt_item { $$ = $3; }\n | full_block_expr\n-| block\n-| nonblock_expr ';'\n+| maybe_outer_attrs block   { $$ = $2; }\n+|             nonblock_expr ';'\n+| outer_attrs nonblock_expr ';' { $$ = $2; }\n | ';'                   { $$ = mk_none(); }\n ;\n \n@@ -1296,7 +1366,9 @@ path_expr\n // expressions.\n path_generic_args_with_colons\n : ident                                              { $$ = mk_node(\"components\", 1, $1); }\n+| SUPER                                              { $$ = mk_atom(\"Super\"); }\n | path_generic_args_with_colons MOD_SEP ident        { $$ = ext_node($1, 1, $3); }\n+| path_generic_args_with_colons MOD_SEP SUPER        { $$ = ext_node($1, 1, mk_atom(\"Super\")); }\n | path_generic_args_with_colons MOD_SEP generic_args { $$ = ext_node($1, 1, $3); }\n ;\n \n@@ -1313,6 +1385,7 @@ nonblock_expr\n | SELF                                                          { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n | macro_expr                                                    { $$ = mk_node(\"ExprMac\", 1, $1); }\n | path_expr '{' struct_expr_fields '}'                          { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n+| nonblock_expr '?'                                             { $$ = mk_node(\"ExprTry\", 1, $1); }\n | nonblock_expr '.' path_generic_args_with_colons               { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n | nonblock_expr '.' LIT_INTEGER                                 { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n | nonblock_expr '[' maybe_expr ']'                              { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n@@ -1325,6 +1398,8 @@ nonblock_expr\n | RETURN expr                                                   { $$ = mk_node(\"ExprRet\", 1, $2); }\n | BREAK                                                         { $$ = mk_node(\"ExprBreak\", 0); }\n | BREAK lifetime                                                { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| YIELD                                                         { $$ = mk_node(\"ExprYield\", 0); }\n+| YIELD expr                                                    { $$ = mk_node(\"ExprYield\", 1, $2); }\n | nonblock_expr LARROW expr                                     { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n | nonblock_expr '=' expr                                        { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n | nonblock_expr SHLEQ expr                                      { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n@@ -1360,8 +1435,8 @@ nonblock_expr\n |               DOTDOT expr                                     { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n |               DOTDOT                                          { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n | nonblock_expr AS ty                                           { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| BOX nonparen_expr                                             { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| %prec BOXPLACE BOX '(' maybe_expr ')' nonblock_expr           { $$ = mk_node(\"ExprBox\", 2, $3, $5); }\n+| nonblock_expr ':' ty                                          { $$ = mk_node(\"ExprTypeAscr\", 2, $1, $3); }\n+| BOX expr                                                      { $$ = mk_node(\"ExprBox\", 1, $2); }\n | expr_qualified_path\n | nonblock_prefix_expr\n ;\n@@ -1373,6 +1448,7 @@ expr\n | SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n | macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n | path_expr '{' struct_expr_fields '}'                { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n+| expr '?'                                            { $$ = mk_node(\"ExprTry\", 1, $1); }\n | expr '.' path_generic_args_with_colons              { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n | expr '.' LIT_INTEGER                                { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n | expr '[' maybe_expr ']'                             { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n@@ -1385,6 +1461,8 @@ expr\n | RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n | BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n | BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| YIELD                                               { $$ = mk_node(\"ExprYield\", 0); }\n+| YIELD expr                                          { $$ = mk_node(\"ExprYield\", 1, $2); }\n | expr LARROW expr                                    { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n | expr '=' expr                                       { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n | expr SHLEQ expr                                     { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n@@ -1420,69 +1498,8 @@ expr\n |      DOTDOT expr                                    { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n |      DOTDOT                                         { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n | expr AS ty                                          { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| %prec BOXPLACE BOX '(' maybe_expr ')' expr          { $$ = mk_node(\"ExprBox\", 2, $3, $5); }\n-| expr_qualified_path\n-| block_expr\n-| block\n-| nonblock_prefix_expr\n-;\n-\n-nonparen_expr\n-: lit                                                 { $$ = mk_node(\"ExprLit\", 1, $1); }\n-| %prec IDENT\n-  path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n-| SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n-| macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n-| path_expr '{' struct_expr_fields '}'                { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n-| nonparen_expr '.' path_generic_args_with_colons     { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| nonparen_expr '.' LIT_INTEGER                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n-| nonparen_expr '[' maybe_expr ']'                    { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n-| nonparen_expr '(' maybe_exprs ')'                   { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n-| '[' vec_expr ']'                                    { $$ = mk_node(\"ExprVec\", 1, $2); }\n-| CONTINUE                                            { $$ = mk_node(\"ExprAgain\", 0); }\n-| CONTINUE ident                                      { $$ = mk_node(\"ExprAgain\", 1, $2); }\n-| RETURN                                              { $$ = mk_node(\"ExprRet\", 0); }\n-| RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n-| BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n-| BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n-| nonparen_expr LARROW nonparen_expr                  { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n-| nonparen_expr '=' nonparen_expr                     { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n-| nonparen_expr SHLEQ nonparen_expr                   { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n-| nonparen_expr SHREQ nonparen_expr                   { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n-| nonparen_expr MINUSEQ nonparen_expr                 { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n-| nonparen_expr ANDEQ nonparen_expr                   { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n-| nonparen_expr OREQ nonparen_expr                    { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n-| nonparen_expr PLUSEQ nonparen_expr                  { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n-| nonparen_expr STAREQ nonparen_expr                  { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n-| nonparen_expr SLASHEQ nonparen_expr                 { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n-| nonparen_expr CARETEQ nonparen_expr                 { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n-| nonparen_expr PERCENTEQ nonparen_expr               { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n-| nonparen_expr OROR nonparen_expr                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n-| nonparen_expr ANDAND nonparen_expr                  { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n-| nonparen_expr EQEQ nonparen_expr                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n-| nonparen_expr NE nonparen_expr                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n-| nonparen_expr '<' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n-| nonparen_expr '>' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n-| nonparen_expr LE nonparen_expr                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n-| nonparen_expr GE nonparen_expr                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n-| nonparen_expr '|' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n-| nonparen_expr '^' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n-| nonparen_expr '&' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n-| nonparen_expr SHL nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n-| nonparen_expr SHR nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n-| nonparen_expr '+' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n-| nonparen_expr '-' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n-| nonparen_expr '*' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n-| nonparen_expr '/' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n-| nonparen_expr '%' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n-| nonparen_expr DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n-| nonparen_expr DOTDOT nonparen_expr                  { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n-|               DOTDOT nonparen_expr                  { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n-|               DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n-| nonparen_expr AS ty                                 { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| %prec BOXPLACE BOX '(' maybe_expr ')' expr          { $$ = mk_node(\"ExprBox\", 1, $3, $5); }\n+| expr ':' ty                                         { $$ = mk_node(\"ExprTypeAscr\", 2, $1, $3); }\n+| BOX expr                                            { $$ = mk_node(\"ExprBox\", 1, $2); }\n | expr_qualified_path\n | block_expr\n | block\n@@ -1495,6 +1512,7 @@ expr_nostruct\n   path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n | SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n | macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n+| expr_nostruct '?'                                   { $$ = mk_node(\"ExprTry\", 1, $1); }\n | expr_nostruct '.' path_generic_args_with_colons     { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n | expr_nostruct '.' LIT_INTEGER                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n | expr_nostruct '[' maybe_expr ']'                    { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n@@ -1507,6 +1525,8 @@ expr_nostruct\n | RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n | BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n | BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| YIELD                                               { $$ = mk_node(\"ExprYield\", 0); }\n+| YIELD expr                                          { $$ = mk_node(\"ExprYield\", 1, $2); }\n | expr_nostruct LARROW expr_nostruct                  { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n | expr_nostruct '=' expr_nostruct                     { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n | expr_nostruct SHLEQ expr_nostruct                   { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n@@ -1542,8 +1562,8 @@ expr_nostruct\n |               DOTDOT expr_nostruct                  { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n |               DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n | expr_nostruct AS ty                                 { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| %prec BOXPLACE BOX '(' maybe_expr ')' expr_nostruct { $$ = mk_node(\"ExprBox\", 1, $3, $5); }\n+| expr_nostruct ':' ty                                { $$ = mk_node(\"ExprTypeAscr\", 2, $1, $3); }\n+| BOX expr                                            { $$ = mk_node(\"ExprBox\", 1, $2); }\n | expr_qualified_path\n | block_expr\n | block\n@@ -1558,7 +1578,6 @@ nonblock_prefix_expr_nostruct\n | ANDAND maybe_mut expr_nostruct            { $$ = mk_node(\"ExprAddrOf\", 1, mk_node(\"ExprAddrOf\", 2, $2, $3)); }\n | lambda_expr_nostruct\n | MOVE lambda_expr_nostruct                 { $$ = $2; }\n-| proc_expr_nostruct\n ;\n \n nonblock_prefix_expr\n@@ -1569,7 +1588,6 @@ nonblock_prefix_expr\n | ANDAND maybe_mut expr            { $$ = mk_node(\"ExprAddrOf\", 1, mk_node(\"ExprAddrOf\", 2, $2, $3)); }\n | lambda_expr\n | MOVE lambda_expr                 { $$ = $2; }\n-| proc_expr\n ;\n \n expr_qualified_path\n@@ -1606,43 +1624,42 @@ maybe_as_trait_ref\n \n lambda_expr\n : %prec LAMBDA\n-  OROR ret_ty expr                                        { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $2, $3); }\n-| %prec LAMBDA\n-  '|' maybe_unboxed_closure_kind '|' ret_ty expr          { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $4, $5); }\n+  OROR ret_ty expr                                    { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $2, $3); }\n | %prec LAMBDA\n-  '|' inferrable_params '|' ret_ty expr                   { $$ = mk_node(\"ExprFnBlock\", 3, $2, $4, $5); }\n+  '|' '|' ret_ty expr                                 { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $3, $4); }\n | %prec LAMBDA\n-  '|' '&' maybe_mut ':' inferrable_params '|' ret_ty expr { $$ = mk_node(\"ExprFnBlock\", 3, $5, $7, $8); }\n+  '|' inferrable_params '|' ret_ty expr               { $$ = mk_node(\"ExprFnBlock\", 3, $2, $4, $5); }\n | %prec LAMBDA\n-  '|' ':' inferrable_params '|' ret_ty expr               { $$ = mk_node(\"ExprFnBlock\", 3, $3, $5, $6); }\n+  '|' inferrable_params OROR lambda_expr_no_first_bar { $$ = mk_node(\"ExprFnBlock\", 3, $2, mk_none(), $4); }\n ;\n \n-lambda_expr_nostruct\n+lambda_expr_no_first_bar\n : %prec LAMBDA\n-  OROR expr_nostruct                                        { $$ = mk_node(\"ExprFnBlock\", 2, mk_none(), $2); }\n-| %prec LAMBDA\n-  '|' maybe_unboxed_closure_kind '|'  expr_nostruct         { $$ = mk_node(\"ExprFnBlock\", 2, mk_none(), $4); }\n+  '|' ret_ty expr                                 { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $2, $3); }\n | %prec LAMBDA\n-  '|' inferrable_params '|' expr_nostruct                   { $$ = mk_node(\"ExprFnBlock\", 2, $2, $4); }\n+  inferrable_params '|' ret_ty expr               { $$ = mk_node(\"ExprFnBlock\", 3, $1, $3, $4); }\n | %prec LAMBDA\n-  '|' '&' maybe_mut ':' inferrable_params '|' expr_nostruct { $$ = mk_node(\"ExprFnBlock\", 2, $5, $7); }\n-| %prec LAMBDA\n-  '|' ':' inferrable_params '|' expr_nostruct               { $$ = mk_node(\"ExprFnBlock\", 2, $3, $5); }\n-\n+  inferrable_params OROR lambda_expr_no_first_bar { $$ = mk_node(\"ExprFnBlock\", 3, $1, mk_none(), $3); }\n ;\n \n-proc_expr\n+lambda_expr_nostruct\n : %prec LAMBDA\n-  PROC '(' ')' expr                         { $$ = mk_node(\"ExprProc\", 2, mk_none(), $4); }\n+  OROR expr_nostruct                                           { $$ = mk_node(\"ExprFnBlock\", 2, mk_none(), $2); }\n+| %prec LAMBDA\n+  '|' '|' ret_ty expr_nostruct                                 { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $3, $4); }\n | %prec LAMBDA\n-  PROC '(' inferrable_params ')' expr       { $$ = mk_node(\"ExprProc\", 2, $3, $5); }\n+  '|' inferrable_params '|' expr_nostruct                      { $$ = mk_node(\"ExprFnBlock\", 2, $2, $4); }\n+| %prec LAMBDA\n+  '|' inferrable_params OROR lambda_expr_nostruct_no_first_bar { $$ = mk_node(\"ExprFnBlock\", 3, $2, mk_none(), $4); }\n ;\n \n-proc_expr_nostruct\n+lambda_expr_nostruct_no_first_bar\n : %prec LAMBDA\n-  PROC '(' ')' expr_nostruct                     { $$ = mk_node(\"ExprProc\", 2, mk_none(), $4); }\n+  '|' ret_ty expr_nostruct                                 { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $2, $3); }\n+| %prec LAMBDA\n+  inferrable_params '|' ret_ty expr_nostruct               { $$ = mk_node(\"ExprFnBlock\", 3, $1, $3, $4); }\n | %prec LAMBDA\n-  PROC '(' inferrable_params ')' expr_nostruct   { $$ = mk_node(\"ExprProc\", 2, $3, $5); }\n+  inferrable_params OROR lambda_expr_nostruct_no_first_bar { $$ = mk_node(\"ExprFnBlock\", 3, $1, mk_none(), $3); }\n ;\n \n vec_expr\n@@ -1654,6 +1671,7 @@ struct_expr_fields\n : field_inits\n | field_inits ','\n | maybe_field_inits default_field_init { $$ = ext_node($1, 1, $2); }\n+| %empty                               { $$ = mk_none(); }\n ;\n \n maybe_field_inits\n@@ -1668,7 +1686,9 @@ field_inits\n ;\n \n field_init\n-: ident ':' expr   { $$ = mk_node(\"FieldInit\", 2, $1, $3); }\n+: ident                { $$ = mk_node(\"FieldInit\", 1, $1); }\n+| ident ':' expr       { $$ = mk_node(\"FieldInit\", 2, $1, $3); }\n+| LIT_INTEGER ':' expr { $$ = mk_node(\"FieldInit\", 2, mk_atom(yytext), $3); }\n ;\n \n default_field_init\n@@ -1689,10 +1709,18 @@ block_expr\n \n full_block_expr\n : block_expr\n-| full_block_expr '.' path_generic_args_with_colons %prec IDENT         { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| full_block_expr '.' path_generic_args_with_colons '[' maybe_expr ']'  { $$ = mk_node(\"ExprIndex\", 3, $1, $3, $5); }\n-| full_block_expr '.' path_generic_args_with_colons '(' maybe_exprs ')' { $$ = mk_node(\"ExprCall\", 3, $1, $3, $5); }\n-| full_block_expr '.' LIT_INTEGER                                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n+| block_expr_dot\n+;\n+\n+block_expr_dot\n+: block_expr     '.' path_generic_args_with_colons %prec IDENT         { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n+| block_expr_dot '.' path_generic_args_with_colons %prec IDENT         { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n+| block_expr     '.' path_generic_args_with_colons '[' maybe_expr ']'  { $$ = mk_node(\"ExprIndex\", 3, $1, $3, $5); }\n+| block_expr_dot '.' path_generic_args_with_colons '[' maybe_expr ']'  { $$ = mk_node(\"ExprIndex\", 3, $1, $3, $5); }\n+| block_expr     '.' path_generic_args_with_colons '(' maybe_exprs ')' { $$ = mk_node(\"ExprCall\", 3, $1, $3, $5); }\n+| block_expr_dot '.' path_generic_args_with_colons '(' maybe_exprs ')' { $$ = mk_node(\"ExprCall\", 3, $1, $3, $5); }\n+| block_expr     '.' LIT_INTEGER                                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n+| block_expr_dot '.' LIT_INTEGER                                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n ;\n \n expr_match\n@@ -1714,12 +1742,13 @@ match_clause\n ;\n \n nonblock_match_clause\n-: maybe_outer_attrs pats_or maybe_guard FAT_ARROW nonblock_expr   { $$ = mk_node(\"Arm\", 4, $1, $2, $3, $5); }\n-| maybe_outer_attrs pats_or maybe_guard FAT_ARROW full_block_expr { $$ = mk_node(\"Arm\", 4, $1, $2, $3, $5); }\n+: maybe_outer_attrs pats_or maybe_guard FAT_ARROW nonblock_expr  { $$ = mk_node(\"ArmNonblock\", 4, $1, $2, $3, $5); }\n+| maybe_outer_attrs pats_or maybe_guard FAT_ARROW block_expr_dot { $$ = mk_node(\"ArmNonblock\", 4, $1, $2, $3, $5); }\n ;\n \n block_match_clause\n-: maybe_outer_attrs pats_or maybe_guard FAT_ARROW block { $$ = mk_node(\"Arm\", 4, $1, $2, $3, $5); }\n+: maybe_outer_attrs pats_or maybe_guard FAT_ARROW block      { $$ = mk_node(\"ArmBlock\", 4, $1, $2, $3, $5); }\n+| maybe_outer_attrs pats_or maybe_guard FAT_ARROW block_expr { $$ = mk_node(\"ArmBlock\", 4, $1, $2, $3, $5); }\n ;\n \n maybe_guard\n@@ -1796,6 +1825,10 @@ maybe_ident\n \n ident\n : IDENT                      { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n+// Weak keywords that can be used as identifiers\n+| CATCH                      { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n+| DEFAULT                    { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n+| UNION                      { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n ;\n \n unpaired_token\n@@ -1836,35 +1869,52 @@ unpaired_token\n | LIFETIME                   { $$ = mk_atom(yytext); }\n | SELF                       { $$ = mk_atom(yytext); }\n | STATIC                     { $$ = mk_atom(yytext); }\n+| ABSTRACT                   { $$ = mk_atom(yytext); }\n+| ALIGNOF                    { $$ = mk_atom(yytext); }\n | AS                         { $$ = mk_atom(yytext); }\n+| BECOME                     { $$ = mk_atom(yytext); }\n | BREAK                      { $$ = mk_atom(yytext); }\n+| CATCH                      { $$ = mk_atom(yytext); }\n | CRATE                      { $$ = mk_atom(yytext); }\n+| DEFAULT                    { $$ = mk_atom(yytext); }\n+| DO                         { $$ = mk_atom(yytext); }\n | ELSE                       { $$ = mk_atom(yytext); }\n | ENUM                       { $$ = mk_atom(yytext); }\n | EXTERN                     { $$ = mk_atom(yytext); }\n | FALSE                      { $$ = mk_atom(yytext); }\n+| FINAL                      { $$ = mk_atom(yytext); }\n | FN                         { $$ = mk_atom(yytext); }\n | FOR                        { $$ = mk_atom(yytext); }\n | IF                         { $$ = mk_atom(yytext); }\n | IMPL                       { $$ = mk_atom(yytext); }\n | IN                         { $$ = mk_atom(yytext); }\n | LET                        { $$ = mk_atom(yytext); }\n | LOOP                       { $$ = mk_atom(yytext); }\n+| MACRO                      { $$ = mk_atom(yytext); }\n | MATCH                      { $$ = mk_atom(yytext); }\n | MOD                        { $$ = mk_atom(yytext); }\n | MOVE                       { $$ = mk_atom(yytext); }\n | MUT                        { $$ = mk_atom(yytext); }\n+| OFFSETOF                   { $$ = mk_atom(yytext); }\n+| OVERRIDE                   { $$ = mk_atom(yytext); }\n | PRIV                       { $$ = mk_atom(yytext); }\n | PUB                        { $$ = mk_atom(yytext); }\n+| PURE                       { $$ = mk_atom(yytext); }\n | REF                        { $$ = mk_atom(yytext); }\n | RETURN                     { $$ = mk_atom(yytext); }\n | STRUCT                     { $$ = mk_atom(yytext); }\n+| SIZEOF                     { $$ = mk_atom(yytext); }\n+| SUPER                      { $$ = mk_atom(yytext); }\n | TRUE                       { $$ = mk_atom(yytext); }\n | TRAIT                      { $$ = mk_atom(yytext); }\n | TYPE                       { $$ = mk_atom(yytext); }\n+| UNION                      { $$ = mk_atom(yytext); }\n | UNSAFE                     { $$ = mk_atom(yytext); }\n+| UNSIZED                    { $$ = mk_atom(yytext); }\n | USE                        { $$ = mk_atom(yytext); }\n+| VIRTUAL                    { $$ = mk_atom(yytext); }\n | WHILE                      { $$ = mk_atom(yytext); }\n+| YIELD                      { $$ = mk_atom(yytext); }\n | CONTINUE                   { $$ = mk_atom(yytext); }\n | PROC                       { $$ = mk_atom(yytext); }\n | BOX                        { $$ = mk_atom(yytext); }\n@@ -1942,4 +1992,4 @@ brackets_delimited_token_trees\n                $2,\n                mk_node(\"TTTok\", 1, mk_atom(\"]\")));\n }\n-;\n\\ No newline at end of file\n+;"}, {"sha": "15ea738ed0057edd741da93228106a9c3aa8fca8", "filename": "src/grammar/tokens.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fgrammar%2Ftokens.h", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fgrammar%2Ftokens.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Ftokens.h?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -30,6 +30,7 @@ enum Token {\n   DOTDOT,\n   DOTDOTDOT,\n   MOD_SEP,\n+  LARROW,\n   RARROW,\n   FAT_ARROW,\n   LIT_BYTE,\n@@ -47,35 +48,52 @@ enum Token {\n   // keywords\n   SELF,\n   STATIC,\n+  ABSTRACT,\n+  ALIGNOF,\n   AS,\n+  BECOME,\n   BREAK,\n+  CATCH,\n   CRATE,\n+  DEFAULT,\n+  DO,\n   ELSE,\n   ENUM,\n   EXTERN,\n   FALSE,\n+  FINAL,\n   FN,\n   FOR,\n   IF,\n   IMPL,\n   IN,\n   LET,\n   LOOP,\n+  MACRO,\n   MATCH,\n   MOD,\n   MOVE,\n   MUT,\n+  OFFSETOF,\n+  OVERRIDE,\n   PRIV,\n   PUB,\n+  PURE,\n   REF,\n   RETURN,\n+  SIZEOF,\n   STRUCT,\n+  SUPER,\n+  UNION,\n   TRUE,\n   TRAIT,\n   TYPE,\n   UNSAFE,\n+  UNSIZED,\n   USE,\n+  VIRTUAL,\n   WHILE,\n+  YIELD,\n   CONTINUE,\n   PROC,\n   BOX,"}, {"sha": "79292d390e5d25b71059656be8383835b13a9cfe", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -269,7 +269,38 @@ impl<T: ?Sized> Box<T> {\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub unsafe fn from_raw(raw: *mut T) -> Self {\n-        mem::transmute(raw)\n+        Box::from_unique(Unique::new_unchecked(raw))\n+    }\n+\n+    /// Constructs a `Box` from a `Unique<T>` pointer.\n+    ///\n+    /// After calling this function, the memory is owned by a `Box` and `T` can\n+    /// then be destroyed and released upon drop.\n+    ///\n+    /// # Safety\n+    ///\n+    /// A `Unique<T>` can be safely created via [`Unique::new`] and thus doesn't\n+    /// necessarily own the data pointed to nor is the data guaranteed to live\n+    /// as long as the pointer.\n+    ///\n+    /// [`Unique::new`]: ../../core/ptr/struct.Unique.html#method.new\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(unique)]\n+    ///\n+    /// fn main() {\n+    ///     let x = Box::new(5);\n+    ///     let ptr = Box::into_unique(x);\n+    ///     let x = unsafe { Box::from_unique(ptr) };\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unique\", reason = \"needs an RFC to flesh out design\",\n+               issue = \"27730\")]\n+    #[inline]\n+    pub unsafe fn from_unique(u: Unique<T>) -> Self {\n+        mem::transmute(u)\n     }\n \n     /// Consumes the `Box`, returning the wrapped raw pointer.\n@@ -295,21 +326,26 @@ impl<T: ?Sized> Box<T> {\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub fn into_raw(b: Box<T>) -> *mut T {\n-        unsafe { mem::transmute(b) }\n+        Box::into_unique(b).as_ptr()\n     }\n \n     /// Consumes the `Box`, returning the wrapped pointer as `Unique<T>`.\n     ///\n     /// After calling this function, the caller is responsible for the\n     /// memory previously managed by the `Box`. In particular, the\n     /// caller should properly destroy `T` and release the memory. The\n-    /// proper way to do so is to convert the raw pointer back into a\n-    /// `Box` with the [`Box::from_raw`] function.\n+    /// proper way to do so is to either convert the `Unique<T>` pointer:\n+    ///\n+    /// - Into a `Box` with the [`Box::from_unique`] function.\n+    ///\n+    /// - Into a raw pointer and back into a `Box` with the [`Box::from_raw`]\n+    ///   function.\n     ///\n     /// Note: this is an associated function, which means that you have\n     /// to call it as `Box::into_unique(b)` instead of `b.into_unique()`. This\n     /// is so that there is no conflict with a method on the inner type.\n     ///\n+    /// [`Box::from_unique`]: struct.Box.html#method.from_unique\n     /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n     ///\n     /// # Examples"}, {"sha": "0cbfc9e9dacbb3f04d7f9f30f3c89e0d44d9bf4b", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -121,6 +121,7 @@\n #![feature(unique)]\n #![feature(unsize)]\n #![feature(allocator_internals)]\n+#![feature(on_unimplemented)]\n \n #![cfg_attr(not(test), feature(fused, fn_traits, placement_new_protocol, swap_with_slice, i128))]\n #![cfg_attr(test, feature(test, box_heap))]"}, {"sha": "cf34e195dea76fe1d8262d412eab2823cb965e87", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -1543,6 +1543,7 @@ impl<T: Hash> Hash for Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> Index<usize> for Vec<T> {\n     type Output = T;\n \n@@ -1554,6 +1555,7 @@ impl<T> Index<usize> for Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> IndexMut<usize> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, index: usize) -> &mut T {\n@@ -1562,8 +1564,8 @@ impl<T> IndexMut<usize> for Vec<T> {\n     }\n }\n \n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::Index<ops::Range<usize>> for Vec<T> {\n     type Output = [T];\n \n@@ -1572,7 +1574,9 @@ impl<T> ops::Index<ops::Range<usize>> for Vec<T> {\n         Index::index(&**self, index)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::Index<ops::RangeTo<usize>> for Vec<T> {\n     type Output = [T];\n \n@@ -1581,7 +1585,9 @@ impl<T> ops::Index<ops::RangeTo<usize>> for Vec<T> {\n         Index::index(&**self, index)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::Index<ops::RangeFrom<usize>> for Vec<T> {\n     type Output = [T];\n \n@@ -1590,7 +1596,9 @@ impl<T> ops::Index<ops::RangeFrom<usize>> for Vec<T> {\n         Index::index(&**self, index)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::Index<ops::RangeFull> for Vec<T> {\n     type Output = [T];\n \n@@ -1599,7 +1607,9 @@ impl<T> ops::Index<ops::RangeFull> for Vec<T> {\n         self\n     }\n }\n+\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::Index<ops::RangeInclusive<usize>> for Vec<T> {\n     type Output = [T];\n \n@@ -1608,7 +1618,9 @@ impl<T> ops::Index<ops::RangeInclusive<usize>> for Vec<T> {\n         Index::index(&**self, index)\n     }\n }\n+\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::Index<ops::RangeToInclusive<usize>> for Vec<T> {\n     type Output = [T];\n \n@@ -1619,41 +1631,52 @@ impl<T> ops::Index<ops::RangeToInclusive<usize>> for Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::IndexMut<ops::Range<usize>> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::IndexMut<ops::RangeTo<usize>> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::IndexMut<ops::RangeFrom<usize>> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::IndexMut<ops::RangeFull> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, _index: ops::RangeFull) -> &mut [T] {\n         self\n     }\n }\n+\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::IndexMut<ops::RangeInclusive<usize>> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n+\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n impl<T> ops::IndexMut<ops::RangeToInclusive<usize>> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut [T] {"}, {"sha": "6d7d83dd99388aa10145a78c4b7b663dd38af802", "filename": "src/liballoc_jemalloc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fliballoc_jemalloc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fliballoc_jemalloc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2FCargo.toml?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -19,7 +19,7 @@ libc = { path = \"../rustc/libc_shim\" }\n \n [build-dependencies]\n build_helper = { path = \"../build_helper\" }\n-cc = \"1.0\"\n+cc = \"1.0.1\"\n \n [features]\n debug = []"}, {"sha": "65e035d4ffdef39bde2246c1fb80d36dd31806f3", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -63,24 +63,13 @@ fn main() {\n         _ => return,\n     };\n \n-    let compiler = cc::Build::new().get_compiler();\n-    // only msvc returns None for ar so unwrap is okay\n-    let ar = build_helper::cc2ar(compiler.path(), &target).unwrap();\n-    let cflags = compiler.args()\n-        .iter()\n-        .map(|s| s.to_str().unwrap())\n-        .collect::<Vec<_>>()\n-        .join(\" \");\n-\n     let mut cmd = Command::new(\"sh\");\n     cmd.arg(native.src_dir.join(\"configure\")\n                           .to_str()\n                           .unwrap()\n                           .replace(\"C:\\\\\", \"/c/\")\n                           .replace(\"\\\\\", \"/\"))\n        .current_dir(&native.out_dir)\n-       .env(\"CC\", compiler.path())\n-       .env(\"EXTRA_CFLAGS\", cflags.clone())\n        // jemalloc generates Makefile deps using GCC's \"-MM\" flag. This means\n        // that GCC will run the preprocessor, and only the preprocessor, over\n        // jemalloc's source files. If we don't specify CPPFLAGS, then at least\n@@ -89,9 +78,7 @@ fn main() {\n        // passed to GCC, and then GCC won't define the\n        // \"__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4\" macro that jemalloc needs to\n        // select an atomic operation implementation.\n-       .env(\"CPPFLAGS\", cflags.clone())\n-       .env(\"AR\", &ar)\n-       .env(\"RANLIB\", format!(\"{} s\", ar.display()));\n+       .env(\"CPPFLAGS\", env::var_os(\"CFLAGS\").unwrap_or_default());\n \n     if target.contains(\"ios\") {\n         cmd.arg(\"--disable-tls\");"}, {"sha": "79767b37601f8e91c55d8b1a3f34dd95cda7ced1", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 114, "deletions": 72, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -2059,14 +2059,23 @@ pub trait Iterator {\n         let mut other = other.into_iter();\n \n         loop {\n-            match (self.next(), other.next()) {\n-                (None, None) => return Ordering::Equal,\n-                (None, _   ) => return Ordering::Less,\n-                (_   , None) => return Ordering::Greater,\n-                (Some(x), Some(y)) => match x.cmp(&y) {\n-                    Ordering::Equal => (),\n-                    non_eq => return non_eq,\n+            let x = match self.next() {\n+                None => if other.next().is_none() {\n+                    return Ordering::Equal\n+                } else {\n+                    return Ordering::Less\n                 },\n+                Some(val) => val,\n+            };\n+\n+            let y = match other.next() {\n+                None => return Ordering::Greater,\n+                Some(val) => val,\n+            };\n+\n+            match x.cmp(&y) {\n+                Ordering::Equal => (),\n+                non_eq => return non_eq,\n             }\n         }\n     }\n@@ -2082,14 +2091,23 @@ pub trait Iterator {\n         let mut other = other.into_iter();\n \n         loop {\n-            match (self.next(), other.next()) {\n-                (None, None) => return Some(Ordering::Equal),\n-                (None, _   ) => return Some(Ordering::Less),\n-                (_   , None) => return Some(Ordering::Greater),\n-                (Some(x), Some(y)) => match x.partial_cmp(&y) {\n-                    Some(Ordering::Equal) => (),\n-                    non_eq => return non_eq,\n+            let x = match self.next() {\n+                None => if other.next().is_none() {\n+                    return Some(Ordering::Equal)\n+                } else {\n+                    return Some(Ordering::Less)\n                 },\n+                Some(val) => val,\n+            };\n+\n+            let y = match other.next() {\n+                None => return Some(Ordering::Greater),\n+                Some(val) => val,\n+            };\n+\n+            match x.partial_cmp(&y) {\n+                Some(Ordering::Equal) => (),\n+                non_eq => return non_eq,\n             }\n         }\n     }\n@@ -2105,11 +2123,17 @@ pub trait Iterator {\n         let mut other = other.into_iter();\n \n         loop {\n-            match (self.next(), other.next()) {\n-                (None, None) => return true,\n-                (None, _) | (_, None) => return false,\n-                (Some(x), Some(y)) => if x != y { return false },\n-            }\n+            let x = match self.next() {\n+                None => return other.next().is_none(),\n+                Some(val) => val,\n+            };\n+\n+            let y = match other.next() {\n+                None => return false,\n+                Some(val) => val,\n+            };\n+\n+            if x != y { return false }\n         }\n     }\n \n@@ -2124,11 +2148,17 @@ pub trait Iterator {\n         let mut other = other.into_iter();\n \n         loop {\n-            match (self.next(), other.next()) {\n-                (None, None) => return false,\n-                (None, _) | (_, None) => return true,\n-                (Some(x), Some(y)) => if x.ne(&y) { return true },\n-            }\n+            let x = match self.next() {\n+                None => return other.next().is_some(),\n+                Some(val) => val,\n+            };\n+\n+            let y = match other.next() {\n+                None => return true,\n+                Some(val) => val,\n+            };\n+\n+            if x != y { return true }\n         }\n     }\n \n@@ -2143,18 +2173,21 @@ pub trait Iterator {\n         let mut other = other.into_iter();\n \n         loop {\n-            match (self.next(), other.next()) {\n-                (None, None) => return false,\n-                (None, _   ) => return true,\n-                (_   , None) => return false,\n-                (Some(x), Some(y)) => {\n-                    match x.partial_cmp(&y) {\n-                        Some(Ordering::Less) => return true,\n-                        Some(Ordering::Equal) => {}\n-                        Some(Ordering::Greater) => return false,\n-                        None => return false,\n-                    }\n-                },\n+            let x = match self.next() {\n+                None => return other.next().is_some(),\n+                Some(val) => val,\n+            };\n+\n+            let y = match other.next() {\n+                None => return false,\n+                Some(val) => val,\n+            };\n+\n+            match x.partial_cmp(&y) {\n+                Some(Ordering::Less) => return true,\n+                Some(Ordering::Equal) => (),\n+                Some(Ordering::Greater) => return false,\n+                None => return false,\n             }\n         }\n     }\n@@ -2170,18 +2203,21 @@ pub trait Iterator {\n         let mut other = other.into_iter();\n \n         loop {\n-            match (self.next(), other.next()) {\n-                (None, None) => return true,\n-                (None, _   ) => return true,\n-                (_   , None) => return false,\n-                (Some(x), Some(y)) => {\n-                    match x.partial_cmp(&y) {\n-                        Some(Ordering::Less) => return true,\n-                        Some(Ordering::Equal) => {}\n-                        Some(Ordering::Greater) => return false,\n-                        None => return false,\n-                    }\n-                },\n+            let x = match self.next() {\n+                None => { other.next(); return true; },\n+                Some(val) => val,\n+            };\n+\n+            let y = match other.next() {\n+                None => return false,\n+                Some(val) => val,\n+            };\n+\n+            match x.partial_cmp(&y) {\n+                Some(Ordering::Less) => return true,\n+                Some(Ordering::Equal) => (),\n+                Some(Ordering::Greater) => return false,\n+                None => return false,\n             }\n         }\n     }\n@@ -2197,18 +2233,21 @@ pub trait Iterator {\n         let mut other = other.into_iter();\n \n         loop {\n-            match (self.next(), other.next()) {\n-                (None, None) => return false,\n-                (None, _   ) => return false,\n-                (_   , None) => return true,\n-                (Some(x), Some(y)) => {\n-                    match x.partial_cmp(&y) {\n-                        Some(Ordering::Less) => return false,\n-                        Some(Ordering::Equal) => {}\n-                        Some(Ordering::Greater) => return true,\n-                        None => return false,\n-                    }\n-                }\n+            let x = match self.next() {\n+                None => { other.next(); return false; },\n+                Some(val) => val,\n+            };\n+\n+            let y = match other.next() {\n+                None => return true,\n+                Some(val) => val,\n+            };\n+\n+            match x.partial_cmp(&y) {\n+                Some(Ordering::Less) => return false,\n+                Some(Ordering::Equal) => (),\n+                Some(Ordering::Greater) => return true,\n+                None => return false,\n             }\n         }\n     }\n@@ -2224,18 +2263,21 @@ pub trait Iterator {\n         let mut other = other.into_iter();\n \n         loop {\n-            match (self.next(), other.next()) {\n-                (None, None) => return true,\n-                (None, _   ) => return false,\n-                (_   , None) => return true,\n-                (Some(x), Some(y)) => {\n-                    match x.partial_cmp(&y) {\n-                        Some(Ordering::Less) => return false,\n-                        Some(Ordering::Equal) => {}\n-                        Some(Ordering::Greater) => return true,\n-                        None => return false,\n-                    }\n-                },\n+            let x = match self.next() {\n+                None => return other.next().is_none(),\n+                Some(val) => val,\n+            };\n+\n+            let y = match other.next() {\n+                None => return true,\n+                Some(val) => val,\n+            };\n+\n+            match x.partial_cmp(&y) {\n+                Some(Ordering::Less) => return false,\n+                Some(Ordering::Equal) => (),\n+                Some(Ordering::Greater) => return true,\n+                None => return false,\n             }\n         }\n     }"}, {"sha": "16d5fadc53620f60e243d017331c440d6086147a", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -429,9 +429,11 @@ pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n \n /// Returns whether dropping values of type `T` matters.\n ///\n-/// This is purely an optimization hint, and may be implemented conservatively.\n-/// For instance, always returning `true` would be a valid implementation of\n-/// this function.\n+/// This is purely an optimization hint, and may be implemented conservatively:\n+/// it may return `true` for types that don't actually need to be dropped.\n+/// As such always returning `true` would be a valid implementation of\n+/// this function. However if this function actually returns `false`, then you\n+/// can be certain dropping `T` has no side effect.\n ///\n /// Low level implementations of things like collections, which need to manually\n /// drop their data, should use this function to avoid unnecessarily\n@@ -836,7 +838,7 @@ pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n ///\n /// See the `discriminant` function in this module for more information.\n #[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-pub struct Discriminant<T>(u64, PhantomData<*const T>);\n+pub struct Discriminant<T>(u64, PhantomData<fn() -> T>);\n \n // N.B. These trait implementations cannot be derived because we don't want any bounds on T.\n "}, {"sha": "670c2afa66f8597ae24e597cc6dff2faceefaf6e", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -1405,16 +1405,6 @@ impl<'a> DoubleEndedIterator for LinesAny<'a> {\n #[allow(deprecated)]\n impl<'a> FusedIterator for LinesAny<'a> {}\n \n-/*\n-Section: Comparing strings\n-*/\n-\n-/// Bytewise slice equality\n-#[inline]\n-fn eq_slice(a: &str, b: &str) -> bool {\n-    a.as_bytes() == b.as_bytes()\n-}\n-\n /*\n Section: UTF-8 validation\n */\n@@ -1590,7 +1580,6 @@ mod traits {\n     use cmp::Ordering;\n     use ops;\n     use slice::{self, SliceIndex};\n-    use str::eq_slice;\n \n     /// Implements ordering of strings.\n     ///\n@@ -1611,7 +1600,7 @@ mod traits {\n     impl PartialEq for str {\n         #[inline]\n         fn eq(&self, other: &str) -> bool {\n-            eq_slice(self, other)\n+            self.as_bytes() == other.as_bytes()\n         }\n         #[inline]\n         fn ne(&self, other: &str) -> bool { !(*self).eq(other) }"}, {"sha": "f55a1c81463f77ab0a8a6dd7c1946ae3c0c33a4a", "filename": "src/libcore/tests/mem.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibcore%2Ftests%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibcore%2Ftests%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fmem.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -121,3 +121,19 @@ fn test_transmute() {\n     }\n }\n \n+#[test]\n+#[allow(dead_code)]\n+fn test_discriminant_send_sync() {\n+    enum Regular {\n+        A,\n+        B(i32)\n+    }\n+    enum NotSendSync {\n+        A(*const i32)\n+    }\n+\n+    fn is_send_sync<T: Send + Sync>() { }\n+\n+    is_send_sync::<Discriminant<Regular>>();\n+    is_send_sync::<Discriminant<NotSendSync>>();\n+}"}, {"sha": "cf30966fa89715c2ff695069b5ca9f00321df21f", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -488,7 +488,7 @@ impl Literal {\n     pub fn string(string: &str) -> Literal {\n         let mut escaped = String::new();\n         for ch in string.chars() {\n-            escaped.extend(ch.escape_unicode());\n+            escaped.extend(ch.escape_debug());\n         }\n         Literal(token::Literal(token::Lit::Str_(Symbol::intern(&escaped)), None))\n     }"}, {"sha": "04f456917b95703b5eebe33a62e81baa864a36d7", "filename": "src/libprofiler_builtins/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibprofiler_builtins%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibprofiler_builtins%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2FCargo.toml?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -15,4 +15,4 @@ doc = false\n core = { path = \"../libcore\" }\n \n [build-dependencies]\n-cc = \"1.0\"\n+cc = \"1.0.1\""}, {"sha": "4600cdbc692e7f37e51bf1d0a510bc346cb6c979", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -65,7 +65,7 @@ use hir::map::DefPathHash;\n use hir::{HirId, ItemLocalId};\n \n use ich::Fingerprint;\n-use ty::{TyCtxt, Instance, InstanceDef, ParamEnvAnd, Ty};\n+use ty::{TyCtxt, Instance, InstanceDef, ParamEnv, ParamEnvAnd, PolyTraitRef, Ty};\n use ty::subst::Substs;\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use ich::StableHashingContext;\n@@ -505,6 +505,8 @@ define_dep_nodes!( <'tcx>\n     [] InstanceSymbolName { instance: Instance<'tcx> },\n     [] SpecializationGraph(DefId),\n     [] ObjectSafety(DefId),\n+    [] FulfillObligation { param_env: ParamEnv<'tcx>, trait_ref: PolyTraitRef<'tcx> },\n+    [] VtableMethods { trait_ref: PolyTraitRef<'tcx> },\n \n     [] IsCopy { param_env: ParamEnvAnd<'tcx, Ty<'tcx>> },\n     [] IsSized { param_env: ParamEnvAnd<'tcx, Ty<'tcx>> },"}, {"sha": "690db8a552248ddf10d175e0b070a2a311bbef3f", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -19,7 +19,7 @@ mod safe;\n mod serialized;\n \n pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n-pub use self::dep_node::{DepNode, DepKind, DepConstructor, WorkProductId};\n+pub use self::dep_node::{DepNode, DepKind, DepConstructor, WorkProductId, label_strs};\n pub use self::graph::{DepGraph, WorkProduct, DepNodeIndex, DepNodeColor};\n pub use self::prev::PreviousDepGraph;\n pub use self::query::DepGraphQuery;"}, {"sha": "2221ecf07b434913b079643d283b48afeeed7d5f", "filename": "src/librustc/hir/itemlikevisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -41,7 +41,7 @@ use super::intravisit::Visitor;\n ///    - Example: Lifetime resolution, which wants to bring lifetimes declared on the\n ///      impl into scope while visiting the impl-items, and then back out again.\n ///    - How: Implement `intravisit::Visitor` and override the\n-///      `visit_nested_map()` methods to return\n+///      `nested_visit_map()` methods to return\n ///      `NestedVisitorMap::All`. Walk your crate with\n ///      `intravisit::walk_crate()` invoked on `tcx.hir.krate()`.\n ///    - Pro: Visitor methods for any kind of HIR node, not just item-like things."}, {"sha": "54aecb4b00f826580f8d0e683ec2d1e80c7d4650", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -705,7 +705,7 @@ impl<'a> LoweringContext<'a> {\n                 let expr = self.lower_body(None, |this| this.lower_expr(expr));\n                 hir::TyTypeof(expr)\n             }\n-            TyKind::TraitObject(ref bounds) => {\n+            TyKind::TraitObject(ref bounds, ..) => {\n                 let mut lifetime_bound = None;\n                 let bounds = bounds.iter().filter_map(|bound| {\n                     match *bound {"}, {"sha": "f719ce150924f0652d28bdb55657a72923dbaeb5", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -61,6 +61,9 @@ for ty::RegionKind {\n                 def_id.hash_stable(hcx, hasher);\n                 name.hash_stable(hcx, hasher);\n             }\n+            ty::ReLateBound(db, ty::BrEnv) => {\n+                db.depth.hash_stable(hcx, hasher);\n+            }\n             ty::ReEarlyBound(ty::EarlyBoundRegion { def_id, index, name }) => {\n                 def_id.hash_stable(hcx, hasher);\n                 index.hash_stable(hcx, hasher);\n@@ -841,3 +844,129 @@ impl_stable_hash_for!(struct ::util::common::ErrorReported {});\n impl_stable_hash_for!(tuple_struct ::middle::reachable::ReachableSet {\n     reachable_set\n });\n+\n+impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n+for traits::Vtable<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use traits::Vtable::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match self {\n+            &VtableImpl(ref table_impl) => table_impl.hash_stable(hcx, hasher),\n+            &VtableDefaultImpl(ref table_def_impl) => table_def_impl.hash_stable(hcx, hasher),\n+            &VtableParam(ref table_param) => table_param.hash_stable(hcx, hasher),\n+            &VtableObject(ref table_obj) => table_obj.hash_stable(hcx, hasher),\n+            &VtableBuiltin(ref table_builtin) => table_builtin.hash_stable(hcx, hasher),\n+            &VtableClosure(ref table_closure) => table_closure.hash_stable(hcx, hasher),\n+            &VtableFnPointer(ref table_fn_pointer) => table_fn_pointer.hash_stable(hcx, hasher),\n+            &VtableGenerator(ref table_generator) => table_generator.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n+\n+impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n+for traits::VtableImplData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let traits::VtableImplData {\n+            impl_def_id,\n+            substs,\n+            ref nested,\n+        } = *self;\n+        impl_def_id.hash_stable(hcx, hasher);\n+        substs.hash_stable(hcx, hasher);\n+        nested.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n+for traits::VtableDefaultImplData<N> where N: HashStable<StableHashingContext<'gcx>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let traits::VtableDefaultImplData {\n+            trait_def_id,\n+            ref nested,\n+        } = *self;\n+        trait_def_id.hash_stable(hcx, hasher);\n+        nested.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n+for traits::VtableObjectData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let traits::VtableObjectData {\n+            upcast_trait_ref,\n+            vtable_base,\n+            ref nested,\n+        } = *self;\n+        upcast_trait_ref.hash_stable(hcx, hasher);\n+        vtable_base.hash_stable(hcx, hasher);\n+        nested.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n+for traits::VtableBuiltinData<N> where N: HashStable<StableHashingContext<'gcx>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let traits::VtableBuiltinData {\n+            ref nested,\n+        } = *self;\n+        nested.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n+for traits::VtableClosureData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let traits::VtableClosureData {\n+            closure_def_id,\n+            substs,\n+            ref nested,\n+        } = *self;\n+        closure_def_id.hash_stable(hcx, hasher);\n+        substs.hash_stable(hcx, hasher);\n+        nested.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n+for traits::VtableFnPointerData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let traits::VtableFnPointerData {\n+            fn_ty,\n+            ref nested,\n+        } = *self;\n+        fn_ty.hash_stable(hcx, hasher);\n+        nested.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n+for traits::VtableGeneratorData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let traits::VtableGeneratorData {\n+            closure_def_id,\n+            substs,\n+            ref nested,\n+        } = *self;\n+        closure_def_id.hash_stable(hcx, hasher);\n+        substs.hash_stable(hcx, hasher);\n+        nested.hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "ed440849b4826c7c2111b296ec84367f257aa74e", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -106,6 +106,7 @@ pub mod lint;\n \n pub mod middle {\n     pub mod allocator;\n+    pub mod borrowck;\n     pub mod expr_use_visitor;\n     pub mod const_val;\n     pub mod cstore;"}, {"sha": "d28963fc726abf5b6ffd9b89845d27dc12fdbeb3", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -222,6 +222,12 @@ declare_lint! {\n     \"unnecessary use of an `unsafe` block\"\n }\n \n+declare_lint! {\n+    pub UNUSED_MUT,\n+    Warn,\n+    \"detect mut variables which don't need to be mutable\"\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -263,7 +269,8 @@ impl LintPass for HardwiredLints {\n             PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n             LATE_BOUND_LIFETIME_ARGUMENTS,\n             DEPRECATED,\n-            UNUSED_UNSAFE\n+            UNUSED_UNSAFE,\n+            UNUSED_MUT\n         )\n     }\n }"}, {"sha": "c8690422b189302eea4ee2e4e4fed304cbe39eec", "filename": "src/librustc/middle/borrowck.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ich::StableHashingContext;\n+use hir::HirId;\n+use util::nodemap::FxHashSet;\n+\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n+\n+pub struct BorrowCheckResult {\n+    pub used_mut_nodes: FxHashSet<HirId>,\n+}\n+\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for BorrowCheckResult {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let BorrowCheckResult {\n+            ref used_mut_nodes,\n+        } = *self;\n+        used_mut_nodes.hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "bb6213cb5faaf20f07321a8d1f701798db29d916", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -336,6 +336,12 @@ struct CollectPrivateImplItemsVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n+        // Anything which has custom linkage gets thrown on the worklist no\n+        // matter where it is in the crate.\n+        if attr::contains_name(&item.attrs, \"linkage\") {\n+            self.worklist.push(item.id);\n+        }\n+\n         // We need only trait impls here, not inherent impls, and only non-exported ones\n         if let hir::ItemImpl(.., Some(ref trait_ref), _, ref impl_item_refs) = item.node {\n             if !self.access_levels.is_reachable(item.id) {"}, {"sha": "0159a198bc64744db417eb1e329e0ef590434867", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -415,9 +415,11 @@ pub enum BorrowKind {\n ///////////////////////////////////////////////////////////////////////////\n // Variables and temps\n \n-newtype_index!(Local, \"_\");\n-\n-pub const RETURN_POINTER: Local = Local(0);\n+newtype_index!(Local\n+    {\n+        DEBUG_NAME = \"_\",\n+        const RETURN_POINTER = 0,\n+    });\n \n /// Classifies locals into categories. See `Mir::local_kind`.\n #[derive(PartialEq, Eq, Debug)]\n@@ -551,7 +553,7 @@ pub struct UpvarDecl {\n ///////////////////////////////////////////////////////////////////////////\n // BasicBlock\n \n-newtype_index!(BasicBlock, \"bb\");\n+newtype_index!(BasicBlock { DEBUG_NAME = \"bb\" });\n \n ///////////////////////////////////////////////////////////////////////////\n // BasicBlockData and Terminator\n@@ -1131,7 +1133,7 @@ pub type LvalueProjection<'tcx> = Projection<'tcx, Lvalue<'tcx>, Local, Ty<'tcx>\n /// and the index is a local.\n pub type LvalueElem<'tcx> = ProjectionElem<'tcx, Local, Ty<'tcx>>;\n \n-newtype_index!(Field, \"field\");\n+newtype_index!(Field { DEBUG_NAME = \"field\" });\n \n impl<'tcx> Lvalue<'tcx> {\n     pub fn field(self, f: Field, ty: Ty<'tcx>) -> Lvalue<'tcx> {\n@@ -1196,8 +1198,11 @@ impl<'tcx> Debug for Lvalue<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Scopes\n \n-newtype_index!(VisibilityScope, \"scope\");\n-pub const ARGUMENT_VISIBILITY_SCOPE : VisibilityScope = VisibilityScope(0);\n+newtype_index!(VisibilityScope\n+    {\n+        DEBUG_NAME = \"scope\",\n+        const ARGUMENT_VISIBILITY_SCOPE = 0,\n+    });\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct VisibilityScopeData {\n@@ -1522,7 +1527,7 @@ pub struct Constant<'tcx> {\n     pub literal: Literal<'tcx>,\n }\n \n-newtype_index!(Promoted, \"promoted\");\n+newtype_index!(Promoted { DEBUG_NAME = \"promoted\" });\n \n #[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum Literal<'tcx> {"}, {"sha": "f9a4b5bb9a537b113077d79b7aa30025a3c5b65f", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 6, "deletions": 47, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -352,7 +352,7 @@ top_level_options!(\n         actually_rustdoc: bool [TRACKED],\n \n         // Number of object files/codegen units to produce on the backend\n-        codegen_units: usize [UNTRACKED],\n+        cli_forced_codegen_units: Option<usize> [UNTRACKED],\n     }\n );\n \n@@ -505,7 +505,7 @@ pub fn basic_options() -> Options {\n         unstable_features: UnstableFeatures::Disallow,\n         debug_assertions: true,\n         actually_rustdoc: false,\n-        codegen_units: 1,\n+        cli_forced_codegen_units: None,\n     }\n }\n \n@@ -864,8 +864,7 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n          build_codegen_options, \"C\", \"codegen\",\n          CG_OPTIONS, cg_type_desc, cgsetters,\n     ar: Option<String> = (None, parse_opt_string, [UNTRACKED],\n-        \"tool to assemble archives with (has no effect currently, \\\n-         rustc doesn't use an external archiver)\"),\n+        \"this option is deprecated and does nothing\"),\n     linker: Option<String> = (None, parse_opt_string, [UNTRACKED],\n         \"system linker to link outputs with\"),\n     link_arg: Vec<String> = (vec![], parse_string_push, [UNTRACKED],\n@@ -1100,6 +1099,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"generate a graphical HTML report of time spent in trans and LLVM\"),\n     thinlto: bool = (false, parse_bool, [TRACKED],\n         \"enable ThinLTO when possible\"),\n+    inline_in_all_cgus: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"control whether #[inline] functions are in all cgus\"),\n }\n \n pub fn default_lib_output() -> CrateType {\n@@ -1709,48 +1710,6 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n \n     let incremental = debugging_opts.incremental.as_ref().map(|m| PathBuf::from(m));\n \n-    let codegen_units = codegen_units.unwrap_or_else(|| {\n-        match opt_level {\n-            // If we're compiling at `-O0` then default to 16 codegen units.\n-            // The number here shouldn't matter too too much as debug mode\n-            // builds don't rely on performance at all, meaning that lost\n-            // opportunities for inlining through multiple codegen units is\n-            // a non-issue.\n-            //\n-            // Note that the high number here doesn't mean that we'll be\n-            // spawning a large number of threads in parallel. The backend\n-            // of rustc contains global rate limiting through the\n-            // `jobserver` crate so we'll never overload the system with too\n-            // much work, but rather we'll only be optimizing when we're\n-            // otherwise cooperating with other instances of rustc.\n-            //\n-            // Rather the high number here means that we should be able to\n-            // keep a lot of idle cpus busy. By ensuring that no codegen\n-            // unit takes *too* long to build we'll be guaranteed that all\n-            // cpus will finish pretty closely to one another and we should\n-            // make relatively optimal use of system resources\n-            //\n-            // Another note worth mentioning here, however, is that this number\n-            // isn't *too* high. When codegen units are increased that means we\n-            // currently have to codegen `#[inline]` functions into each codegen\n-            // unit, which means the more codegen units we're using the more we\n-            // may be generating. In other words, increasing codegen units may\n-            // increase the overall work the compiler does. If we don't have\n-            // enough cores to make up for this loss then increasing the number\n-            // of codegen units could become an overall loss!\n-            //\n-            // As a result we choose a hopefully conservative value 16, which\n-            // should be more than the number of cpus of most hardware compiling\n-            // Rust but also not too much for 2-4 core machines to have too much\n-            // loss of compile time.\n-            OptLevel::No => 16,\n-\n-            // All other optimization levels default use one codegen unit,\n-            // the historical default in Rust for a Long Time.\n-            _ => 1,\n-        }\n-    });\n-\n     (Options {\n         crate_types,\n         optimize: opt_level,\n@@ -1775,7 +1734,7 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n         unstable_features: UnstableFeatures::from_environment(),\n         debug_assertions,\n         actually_rustdoc: false,\n-        codegen_units,\n+        cli_forced_codegen_units: codegen_units,\n     },\n     cfg)\n }"}, {"sha": "2634ab10007032eb48021aede921626346ee6c76", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 64, "deletions": 27, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -54,24 +54,24 @@ pub mod config;\n pub mod filesearch;\n pub mod search_paths;\n \n-// Represents the data associated with a compilation\n-// session for a single crate.\n+/// Represents the data associated with a compilation\n+/// session for a single crate.\n pub struct Session {\n     pub target: config::Config,\n     pub host: Target,\n     pub opts: config::Options,\n     pub parse_sess: ParseSess,\n-    // For a library crate, this is always none\n+    /// For a library crate, this is always none\n     pub entry_fn: RefCell<Option<(NodeId, Span)>>,\n     pub entry_type: Cell<Option<config::EntryFnType>>,\n     pub plugin_registrar_fn: Cell<Option<ast::NodeId>>,\n     pub derive_registrar_fn: Cell<Option<ast::NodeId>>,\n     pub default_sysroot: Option<PathBuf>,\n-    // The name of the root source file of the crate, in the local file system.\n-    // `None` means that there is no source file.\n+    /// The name of the root source file of the crate, in the local file system.\n+    /// `None` means that there is no source file.\n     pub local_crate_source_file: Option<String>,\n-    // The directory the compiler has been executed in plus a flag indicating\n-    // if the value stored here has been affected by path remapping.\n+    /// The directory the compiler has been executed in plus a flag indicating\n+    /// if the value stored here has been affected by path remapping.\n     pub working_dir: (String, bool),\n     pub lint_store: RefCell<lint::LintStore>,\n     pub buffered_lints: RefCell<Option<lint::LintBuffer>>,\n@@ -83,11 +83,11 @@ pub struct Session {\n     pub plugin_attributes: RefCell<Vec<(String, AttributeType)>>,\n     pub crate_types: RefCell<Vec<config::CrateType>>,\n     pub dependency_formats: RefCell<dependency_format::Dependencies>,\n-    // The crate_disambiguator is constructed out of all the `-C metadata`\n-    // arguments passed to the compiler. Its value together with the crate-name\n-    // forms a unique global identifier for the crate. It is used to allow\n-    // multiple crates with the same name to coexist. See the\n-    // trans::back::symbol_names module for more information.\n+    /// The crate_disambiguator is constructed out of all the `-C metadata`\n+    /// arguments passed to the compiler. Its value together with the crate-name\n+    /// forms a unique global identifier for the crate. It is used to allow\n+    /// multiple crates with the same name to coexist. See the\n+    /// trans::back::symbol_names module for more information.\n     pub crate_disambiguator: RefCell<Option<Symbol>>,\n     pub features: RefCell<feature_gate::Features>,\n \n@@ -143,17 +143,17 @@ pub struct Session {\n }\n \n pub struct PerfStats {\n-    // The accumulated time needed for computing the SVH of the crate\n+    /// The accumulated time needed for computing the SVH of the crate\n     pub svh_time: Cell<Duration>,\n-    // The accumulated time spent on computing incr. comp. hashes\n+    /// The accumulated time spent on computing incr. comp. hashes\n     pub incr_comp_hashes_time: Cell<Duration>,\n-    // The number of incr. comp. hash computations performed\n+    /// The number of incr. comp. hash computations performed\n     pub incr_comp_hashes_count: Cell<u64>,\n-    // The number of bytes hashed when computing ICH values\n+    /// The number of bytes hashed when computing ICH values\n     pub incr_comp_bytes_hashed: Cell<u64>,\n-    // The accumulated time spent on computing symbol hashes\n+    /// The accumulated time spent on computing symbol hashes\n     pub symbol_hash_time: Cell<Duration>,\n-    // The accumulated time spent decoding def path tables from metadata\n+    /// The accumulated time spent decoding def path tables from metadata\n     pub decode_def_path_tables_time: Cell<Duration>,\n }\n \n@@ -636,6 +636,43 @@ impl Session {\n         }\n         ret\n     }\n+\n+    /// Returns the number of codegen units that should be used for this\n+    /// compilation\n+    pub fn codegen_units(&self) -> usize {\n+        if let Some(n) = self.opts.cli_forced_codegen_units {\n+            return n\n+        }\n+        if let Some(n) = self.target.target.options.default_codegen_units {\n+            return n as usize\n+        }\n+\n+        match self.opts.optimize {\n+            // If we're compiling at `-O0` then default to 16 codegen units.\n+            // The number here shouldn't matter too too much as debug mode\n+            // builds don't rely on performance at all, meaning that lost\n+            // opportunities for inlining through multiple codegen units is\n+            // a non-issue.\n+            //\n+            // Note that the high number here doesn't mean that we'll be\n+            // spawning a large number of threads in parallel. The backend\n+            // of rustc contains global rate limiting through the\n+            // `jobserver` crate so we'll never overload the system with too\n+            // much work, but rather we'll only be optimizing when we're\n+            // otherwise cooperating with other instances of rustc.\n+            //\n+            // Rather the high number here means that we should be able to\n+            // keep a lot of idle cpus busy. By ensuring that no codegen\n+            // unit takes *too* long to build we'll be guaranteed that all\n+            // cpus will finish pretty closely to one another and we should\n+            // make relatively optimal use of system resources\n+            config::OptLevel::No => 16,\n+\n+            // All other optimization levels default use one codegen unit,\n+            // the historical default in Rust for a Long Time.\n+            _ => 1,\n+        }\n+    }\n }\n \n pub fn build_session(sopts: config::Options,\n@@ -804,24 +841,24 @@ pub fn build_session_(sopts: config::Options,\n /// Holds data on the current incremental compilation session, if there is one.\n #[derive(Debug)]\n pub enum IncrCompSession {\n-    // This is the state the session will be in until the incr. comp. dir is\n-    // needed.\n+    /// This is the state the session will be in until the incr. comp. dir is\n+    /// needed.\n     NotInitialized,\n-    // This is the state during which the session directory is private and can\n-    // be modified.\n+    /// This is the state during which the session directory is private and can\n+    /// be modified.\n     Active {\n         session_directory: PathBuf,\n         lock_file: flock::Lock,\n         load_dep_graph: bool,\n     },\n-    // This is the state after the session directory has been finalized. In this\n-    // state, the contents of the directory must not be modified any more.\n+    /// This is the state after the session directory has been finalized. In this\n+    /// state, the contents of the directory must not be modified any more.\n     Finalized {\n         session_directory: PathBuf,\n     },\n-    // This is an error state that is reached when some compilation error has\n-    // occurred. It indicates that the contents of the session directory must\n-    // not be used, since they might be invalid.\n+    /// This is an error state that is reached when some compilation error has\n+    /// occurred. It indicates that the contents of the session directory must\n+    /// not be used, since they might be invalid.\n     InvalidBecauseOfErrors {\n         session_directory: PathBuf,\n     }"}, {"sha": "030b7e4f646f924d8360e18af59113a512f282f9", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 172, "deletions": 43, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -711,41 +711,105 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            OutputTypeParameterMismatch(ref expected_trait_ref, ref actual_trait_ref, _) => {\n+            OutputTypeParameterMismatch(ref found_trait_ref, ref expected_trait_ref, _) => {\n+                let found_trait_ref = self.resolve_type_vars_if_possible(&*found_trait_ref);\n                 let expected_trait_ref = self.resolve_type_vars_if_possible(&*expected_trait_ref);\n-                let actual_trait_ref = self.resolve_type_vars_if_possible(&*actual_trait_ref);\n-                if actual_trait_ref.self_ty().references_error() {\n+                if expected_trait_ref.self_ty().references_error() {\n                     return;\n                 }\n-                let expected_trait_ty = expected_trait_ref.self_ty();\n-                let found_span = expected_trait_ty.ty_to_def_id().and_then(|did| {\n+                let found_trait_ty = found_trait_ref.self_ty();\n+\n+                let found_did = found_trait_ty.ty_to_def_id();\n+                let found_span = found_did.and_then(|did| {\n                     self.tcx.hir.span_if_local(did)\n                 });\n \n-                let self_ty_count =\n-                    match expected_trait_ref.skip_binder().substs.type_at(1).sty {\n+                let found_ty_count =\n+                    match found_trait_ref.skip_binder().substs.type_at(1).sty {\n                         ty::TyTuple(ref tys, _) => tys.len(),\n                         _ => 1,\n                     };\n-                let arg_ty_count =\n-                    match actual_trait_ref.skip_binder().substs.type_at(1).sty {\n-                        ty::TyTuple(ref tys, _) => tys.len(),\n-                        _ => 1,\n+                let (expected_tys, expected_ty_count) =\n+                    match expected_trait_ref.skip_binder().substs.type_at(1).sty {\n+                        ty::TyTuple(ref tys, _) =>\n+                            (tys.iter().map(|t| &t.sty).collect(), tys.len()),\n+                        ref sty => (vec![sty], 1),\n                     };\n-                if self_ty_count == arg_ty_count {\n+                if found_ty_count == expected_ty_count {\n                     self.report_closure_arg_mismatch(span,\n                                                      found_span,\n-                                                     expected_trait_ref,\n-                                                     actual_trait_ref)\n+                                                     found_trait_ref,\n+                                                     expected_trait_ref)\n                 } else {\n-                    // Expected `|| { }`, found `|x, y| { }`\n-                    // Expected `fn(x) -> ()`, found `|| { }`\n+                    let expected_tuple = if expected_ty_count == 1 {\n+                        expected_tys.first().and_then(|t| {\n+                            if let &&ty::TyTuple(ref tuptys, _) = t {\n+                                Some(tuptys.len())\n+                            } else {\n+                                None\n+                            }\n+                        })\n+                    } else {\n+                        None\n+                    };\n+\n+                    // FIXME(#44150): Expand this to \"N args expected but a N-tuple found.\"\n+                    // Type of the 1st expected argument is somehow provided as type of a\n+                    // found one in that case.\n+                    //\n+                    // ```\n+                    // [1i32, 2, 3].sort_by(|(a, b)| ..)\n+                    // //                   ^^^^^^^^\n+                    // // expected_trait_ref:  std::ops::FnMut<(&i32, &i32)>\n+                    // //    found_trait_ref:  std::ops::FnMut<(&i32,)>\n+                    // ```\n+\n+                    let (closure_span, closure_args) = found_did\n+                        .and_then(|did| self.tcx.hir.get_if_local(did))\n+                        .and_then(|node| {\n+                            if let hir::map::NodeExpr(\n+                                &hir::Expr {\n+                                    node: hir::ExprClosure(_, ref decl, id, span, _),\n+                                    ..\n+                                }) = node\n+                            {\n+                                let ty_snips = decl.inputs.iter()\n+                                    .map(|ty| {\n+                                        self.tcx.sess.codemap().span_to_snippet(ty.span).ok()\n+                                            .and_then(|snip| {\n+                                                // filter out dummy spans\n+                                                if snip == \",\" || snip == \"|\" {\n+                                                    None\n+                                                } else {\n+                                                    Some(snip)\n+                                                }\n+                                            })\n+                                    })\n+                                    .collect::<Vec<Option<String>>>();\n+\n+                                let body = self.tcx.hir.body(id);\n+                                let pat_snips = body.arguments.iter()\n+                                    .map(|arg|\n+                                        self.tcx.sess.codemap().span_to_snippet(arg.pat.span).ok())\n+                                    .collect::<Option<Vec<String>>>();\n+\n+                                Some((span, pat_snips, ty_snips))\n+                            } else {\n+                                None\n+                            }\n+                        })\n+                        .map(|(span, pat, ty)| (Some(span), Some((pat, ty))))\n+                        .unwrap_or((None, None));\n+                    let closure_args = closure_args.and_then(|(pat, ty)| Some((pat?, ty)));\n+\n                     self.report_arg_count_mismatch(\n                         span,\n-                        found_span,\n-                        arg_ty_count,\n-                        self_ty_count,\n-                        expected_trait_ty.is_closure()\n+                        closure_span.or(found_span),\n+                        expected_ty_count,\n+                        expected_tuple,\n+                        found_ty_count,\n+                        closure_args,\n+                        found_trait_ty.is_closure()\n                     )\n                 }\n             }\n@@ -767,32 +831,97 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         err.emit();\n     }\n \n-    fn report_arg_count_mismatch(&self,\n-                                 span: Span,\n-                                 found_span: Option<Span>,\n-                                 expected: usize,\n-                                 found: usize,\n-                                 is_closure: bool)\n-        -> DiagnosticBuilder<'tcx>\n-    {\n+    fn report_arg_count_mismatch(\n+        &self,\n+        span: Span,\n+        found_span: Option<Span>,\n+        expected: usize,\n+        expected_tuple: Option<usize>,\n+        found: usize,\n+        closure_args: Option<(Vec<String>, Vec<Option<String>>)>,\n+        is_closure: bool\n+    ) -> DiagnosticBuilder<'tcx> {\n+        use std::borrow::Cow;\n+\n+        let kind = if is_closure { \"closure\" } else { \"function\" };\n+\n+        let args_str = |n, distinct| format!(\n+                \"{} {}argument{}\",\n+                n,\n+                if distinct && n >= 2 { \"distinct \" } else { \"\" },\n+                if n == 1 { \"\" } else { \"s\" },\n+            );\n+\n+        let expected_str = if let Some(n) = expected_tuple {\n+            assert!(expected == 1);\n+            if closure_args.as_ref().map(|&(ref pats, _)| pats.len()) == Some(n) {\n+                Cow::from(\"a single tuple as argument\")\n+            } else {\n+                // be verbose when numbers differ\n+                Cow::from(format!(\"a single {}-tuple as argument\", n))\n+            }\n+        } else {\n+            Cow::from(args_str(expected, false))\n+        };\n+\n+        let found_str = if expected_tuple.is_some() {\n+            args_str(found, true)\n+        } else {\n+            args_str(found, false)\n+        };\n+\n+\n         let mut err = struct_span_err!(self.tcx.sess, span, E0593,\n-            \"{} takes {} argument{} but {} argument{} {} required\",\n-            if is_closure { \"closure\" } else { \"function\" },\n-            found,\n-            if found == 1 { \"\" } else { \"s\" },\n-            expected,\n-            if expected == 1 { \"\" } else { \"s\" },\n-            if expected == 1 { \"is\" } else { \"are\" });\n-\n-        err.span_label(span, format!(\"expected {} that takes {} argument{}\",\n-                                      if is_closure { \"closure\" } else { \"function\" },\n-                                      expected,\n-                                      if expected == 1 { \"\" } else { \"s\" }));\n+            \"{} is expected to take {}, but it takes {}\",\n+            kind,\n+            expected_str,\n+            found_str,\n+        );\n+\n+        err.span_label(\n+            span,\n+            format!(\n+                \"expected {} that takes {}\",\n+                kind,\n+                expected_str,\n+            )\n+        );\n+\n         if let Some(span) = found_span {\n-            err.span_label(span, format!(\"takes {} argument{}\",\n-                                          found,\n-                                          if found == 1 { \"\" } else { \"s\" }));\n+            if let (Some(expected_tuple), Some((pats, tys))) = (expected_tuple, closure_args) {\n+                if expected_tuple != found || pats.len() != found {\n+                    err.span_label(span, format!(\"takes {}\", found_str));\n+                } else {\n+                    let sugg = format!(\n+                        \"|({}){}|\",\n+                        pats.join(\", \"),\n+\n+                        // add type annotations if available\n+                        if tys.iter().any(|ty| ty.is_some()) {\n+                            Cow::from(format!(\n+                                \": ({})\",\n+                                tys.into_iter().map(|ty| if let Some(ty) = ty {\n+                                    ty\n+                                } else {\n+                                    \"_\".to_string()\n+                                }).collect::<Vec<String>>().join(\", \")\n+                            ))\n+                        } else {\n+                            Cow::from(\"\")\n+                        },\n+                    );\n+\n+                    err.span_suggestion(\n+                        span,\n+                        \"consider changing the closure to accept a tuple\",\n+                        sugg\n+                    );\n+                }\n+            } else {\n+                err.span_label(span, format!(\"takes {}\", found_str));\n+            }\n         }\n+\n         err\n     }\n "}, {"sha": "1fddb1864175f0752b2043d7101dbb9f3edcd8f7", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 50, "deletions": 44, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -650,53 +650,55 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// Given a trait `trait_ref`, iterates the vtable entries\n /// that come from `trait_ref`, including its supertraits.\n #[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n-pub fn get_vtable_methods<'a, 'tcx>(\n+fn vtable_methods<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>)\n-    -> impl Iterator<Item=Option<(DefId, &'tcx Substs<'tcx>)>> + 'a\n+    -> Rc<Vec<Option<(DefId, &'tcx Substs<'tcx>)>>>\n {\n-    debug!(\"get_vtable_methods({:?})\", trait_ref);\n-\n-    supertraits(tcx, trait_ref).flat_map(move |trait_ref| {\n-        let trait_methods = tcx.associated_items(trait_ref.def_id())\n-            .filter(|item| item.kind == ty::AssociatedKind::Method);\n-\n-        // Now list each method's DefId and Substs (for within its trait).\n-        // If the method can never be called from this object, produce None.\n-        trait_methods.map(move |trait_method| {\n-            debug!(\"get_vtable_methods: trait_method={:?}\", trait_method);\n-            let def_id = trait_method.def_id;\n-\n-            // Some methods cannot be called on an object; skip those.\n-            if !tcx.is_vtable_safe_method(trait_ref.def_id(), &trait_method) {\n-                debug!(\"get_vtable_methods: not vtable safe\");\n-                return None;\n-            }\n-\n-            // the method may have some early-bound lifetimes, add\n-            // regions for those\n-            let substs = Substs::for_item(tcx, def_id,\n-                                          |_, _| tcx.types.re_erased,\n-                                          |def, _| trait_ref.substs().type_for_def(def));\n-\n-            // the trait type may have higher-ranked lifetimes in it;\n-            // so erase them if they appear, so that we get the type\n-            // at some particular call site\n-            let substs = tcx.erase_late_bound_regions_and_normalize(&ty::Binder(substs));\n-\n-            // It's possible that the method relies on where clauses that\n-            // do not hold for this particular set of type parameters.\n-            // Note that this method could then never be called, so we\n-            // do not want to try and trans it, in that case (see #23435).\n-            let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n-            if !normalize_and_test_predicates(tcx, predicates.predicates) {\n-                debug!(\"get_vtable_methods: predicates do not hold\");\n-                return None;\n-            }\n-\n-            Some((def_id, substs))\n-        })\n-    })\n+    debug!(\"vtable_methods({:?})\", trait_ref);\n+\n+    Rc::new(\n+        supertraits(tcx, trait_ref).flat_map(move |trait_ref| {\n+            let trait_methods = tcx.associated_items(trait_ref.def_id())\n+                .filter(|item| item.kind == ty::AssociatedKind::Method);\n+\n+            // Now list each method's DefId and Substs (for within its trait).\n+            // If the method can never be called from this object, produce None.\n+            trait_methods.map(move |trait_method| {\n+                debug!(\"vtable_methods: trait_method={:?}\", trait_method);\n+                let def_id = trait_method.def_id;\n+\n+                // Some methods cannot be called on an object; skip those.\n+                if !tcx.is_vtable_safe_method(trait_ref.def_id(), &trait_method) {\n+                    debug!(\"vtable_methods: not vtable safe\");\n+                    return None;\n+                }\n+\n+                // the method may have some early-bound lifetimes, add\n+                // regions for those\n+                let substs = Substs::for_item(tcx, def_id,\n+                                              |_, _| tcx.types.re_erased,\n+                                              |def, _| trait_ref.substs().type_for_def(def));\n+\n+                // the trait type may have higher-ranked lifetimes in it;\n+                // so erase them if they appear, so that we get the type\n+                // at some particular call site\n+                let substs = tcx.erase_late_bound_regions_and_normalize(&ty::Binder(substs));\n+\n+                // It's possible that the method relies on where clauses that\n+                // do not hold for this particular set of type parameters.\n+                // Note that this method could then never be called, so we\n+                // do not want to try and trans it, in that case (see #23435).\n+                let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n+                if !normalize_and_test_predicates(tcx, predicates.predicates) {\n+                    debug!(\"vtable_methods: predicates do not hold\");\n+                    return None;\n+                }\n+\n+                Some((def_id, substs))\n+            })\n+        }).collect()\n+    )\n }\n \n impl<'tcx,O> Obligation<'tcx,O> {\n@@ -835,6 +837,8 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         is_object_safe: object_safety::is_object_safe_provider,\n         specialization_graph_of: specialize::specialization_graph_provider,\n         specializes: specialize::specializes,\n+        trans_fulfill_obligation: trans::trans_fulfill_obligation,\n+        vtable_methods,\n         ..*providers\n     };\n }\n@@ -844,6 +848,8 @@ pub fn provide_extern(providers: &mut ty::maps::Providers) {\n         is_object_safe: object_safety::is_object_safe_provider,\n         specialization_graph_of: specialize::specialization_graph_provider,\n         specializes: specialize::specializes,\n+        trans_fulfill_obligation: trans::trans_fulfill_obligation,\n+        vtable_methods,\n         ..*providers\n     };\n }"}, {"sha": "aa3179dd01f566d487ee03f97e4629b2780a4bd4", "filename": "src/librustc/traits/trans/mod.rs", "status": "modified", "additions": 64, "deletions": 74, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -17,85 +17,77 @@ use dep_graph::{DepGraph, DepKind, DepTrackingMap, DepTrackingMapConfig};\n use infer::TransNormalize;\n use std::cell::RefCell;\n use std::marker::PhantomData;\n-use syntax::ast;\n-use syntax_pos::Span;\n+use syntax_pos::DUMMY_SP;\n use traits::{FulfillmentContext, Obligation, ObligationCause, SelectionContext, Vtable};\n use ty::{self, Ty, TyCtxt};\n use ty::subst::{Subst, Substs};\n use ty::fold::{TypeFoldable, TypeFolder};\n use util::common::MemoizationMap;\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n-    /// Attempts to resolve an obligation to a vtable.. The result is\n-    /// a shallow vtable resolution -- meaning that we do not\n-    /// (necessarily) resolve all nested obligations on the impl. Note\n-    /// that type check should guarantee to us that all nested\n-    /// obligations *could be* resolved if we wanted to.\n-    /// Assumes that this is run after the entire crate has been successfully type-checked.\n-    pub fn trans_fulfill_obligation(self,\n-                                    span: Span,\n-                                    param_env: ty::ParamEnv<'tcx>,\n-                                    trait_ref: ty::PolyTraitRef<'tcx>)\n-                                    -> Vtable<'tcx, ()>\n-    {\n-        // Remove any references to regions; this helps improve caching.\n-        let trait_ref = self.erase_regions(&trait_ref);\n-\n-        self.trans_trait_caches.trait_cache.memoize((param_env, trait_ref), || {\n-            debug!(\"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n-                   (param_env, trait_ref), trait_ref.def_id());\n-\n-            // Do the initial selection for the obligation. This yields the\n-            // shallow result we are looking for -- that is, what specific impl.\n-            self.infer_ctxt().enter(|infcx| {\n-                let mut selcx = SelectionContext::new(&infcx);\n-\n-                let obligation_cause = ObligationCause::misc(span,\n-                                                             ast::DUMMY_NODE_ID);\n-                let obligation = Obligation::new(obligation_cause,\n-                                                 param_env,\n-                                                 trait_ref.to_poly_trait_predicate());\n-\n-                let selection = match selcx.select(&obligation) {\n-                    Ok(Some(selection)) => selection,\n-                    Ok(None) => {\n-                        // Ambiguity can happen when monomorphizing during trans\n-                        // expands to some humongo type that never occurred\n-                        // statically -- this humongo type can then overflow,\n-                        // leading to an ambiguous result. So report this as an\n-                        // overflow bug, since I believe this is the only case\n-                        // where ambiguity can result.\n-                        debug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n-                                presuming due to overflow\",\n-                               trait_ref);\n-                        self.sess.span_fatal(span,\n-                                            \"reached the recursion limit during monomorphization \\\n-                                             (selection ambiguity)\");\n-                    }\n-                    Err(e) => {\n-                        span_bug!(span, \"Encountered error `{:?}` selecting `{:?}` during trans\",\n-                                  e, trait_ref)\n-                    }\n-                };\n-\n-                debug!(\"fulfill_obligation: selection={:?}\", selection);\n-\n-                // Currently, we use a fulfillment context to completely resolve\n-                // all nested obligations. This is because they can inform the\n-                // inference of the impl's type parameters.\n-                let mut fulfill_cx = FulfillmentContext::new();\n-                let vtable = selection.map(|predicate| {\n-                    debug!(\"fulfill_obligation: register_predicate_obligation {:?}\", predicate);\n-                    fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-                });\n-                let vtable = infcx.drain_fulfillment_cx_or_panic(span, &mut fulfill_cx, &vtable);\n-\n-                info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n-                vtable\n-            })\n-        })\n-    }\n+/// Attempts to resolve an obligation to a vtable.. The result is\n+/// a shallow vtable resolution -- meaning that we do not\n+/// (necessarily) resolve all nested obligations on the impl. Note\n+/// that type check should guarantee to us that all nested\n+/// obligations *could be* resolved if we wanted to.\n+/// Assumes that this is run after the entire crate has been successfully type-checked.\n+pub fn trans_fulfill_obligation<'a, 'tcx>(ty: TyCtxt<'a, 'tcx, 'tcx>,\n+                                          (param_env, trait_ref):\n+                                          (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>))\n+                                          -> Vtable<'tcx, ()>\n+{\n+    // Remove any references to regions; this helps improve caching.\n+    let trait_ref = ty.erase_regions(&trait_ref);\n+\n+    debug!(\"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n+            (param_env, trait_ref), trait_ref.def_id());\n+\n+    // Do the initial selection for the obligation. This yields the\n+    // shallow result we are looking for -- that is, what specific impl.\n+    ty.infer_ctxt().enter(|infcx| {\n+        let mut selcx = SelectionContext::new(&infcx);\n+\n+        let obligation_cause = ObligationCause::dummy();\n+        let obligation = Obligation::new(obligation_cause,\n+                                            param_env,\n+                                            trait_ref.to_poly_trait_predicate());\n+\n+        let selection = match selcx.select(&obligation) {\n+            Ok(Some(selection)) => selection,\n+            Ok(None) => {\n+                // Ambiguity can happen when monomorphizing during trans\n+                // expands to some humongo type that never occurred\n+                // statically -- this humongo type can then overflow,\n+                // leading to an ambiguous result. So report this as an\n+                // overflow bug, since I believe this is the only case\n+                // where ambiguity can result.\n+                bug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n+                        presuming due to overflow\",\n+                        trait_ref)\n+            }\n+            Err(e) => {\n+                bug!(\"Encountered error `{:?}` selecting `{:?}` during trans\",\n+                            e, trait_ref)\n+            }\n+        };\n+\n+        debug!(\"fulfill_obligation: selection={:?}\", selection);\n+\n+        // Currently, we use a fulfillment context to completely resolve\n+        // all nested obligations. This is because they can inform the\n+        // inference of the impl's type parameters.\n+        let mut fulfill_cx = FulfillmentContext::new();\n+        let vtable = selection.map(|predicate| {\n+            debug!(\"fulfill_obligation: register_predicate_obligation {:?}\", predicate);\n+            fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+        });\n+        let vtable = infcx.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &vtable);\n+\n+        info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n+        vtable\n+    })\n+}\n \n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     /// Monomorphizes a type from the AST by first applying the in-scope\n     /// substitutions and then normalizing any associated types.\n     pub fn trans_apply_param_substs<T>(self,\n@@ -149,14 +141,12 @@ impl<'a, 'gcx> TypeFolder<'gcx, 'gcx> for AssociatedTypeNormalizer<'a, 'gcx> {\n /// Specializes caches used in trans -- in particular, they assume all\n /// types are fully monomorphized and that free regions can be erased.\n pub struct TransTraitCaches<'tcx> {\n-    trait_cache: RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>>,\n     project_cache: RefCell<DepTrackingMap<ProjectionCache<'tcx>>>,\n }\n \n impl<'tcx> TransTraitCaches<'tcx> {\n     pub fn new(graph: DepGraph) -> Self {\n         TransTraitCaches {\n-            trait_cache: RefCell::new(DepTrackingMap::new(graph.clone())),\n             project_cache: RefCell::new(DepTrackingMap::new(graph)),\n         }\n     }"}, {"sha": "24ba38cf147796449be3a2883fba992892a54fff", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -898,11 +898,6 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub inhabitedness_cache: RefCell<FxHashMap<Ty<'tcx>, DefIdForest>>,\n \n-    /// Set of nodes which mark locals as mutable which end up getting used at\n-    /// some point. Local variable definitions not in this set can be warned\n-    /// about.\n-    pub used_mut_nodes: RefCell<NodeSet>,\n-\n     /// Caches the results of trait selection. This cache is used\n     /// for things that do not have to do with the parameters in scope.\n     pub selection_cache: traits::SelectionCache<'tcx>,\n@@ -1185,7 +1180,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             rcache: RefCell::new(FxHashMap()),\n             normalized_cache: RefCell::new(FxHashMap()),\n             inhabitedness_cache: RefCell::new(FxHashMap()),\n-            used_mut_nodes: RefCell::new(NodeSet()),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             rvalue_promotable_to_static: RefCell::new(NodeMap()),"}, {"sha": "600b2572f92b858544abdb018f63ab335d90d226", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -13,7 +13,6 @@ use ty::{self, Ty, TypeFoldable, Substs, TyCtxt};\n use ty::subst::{Kind, Subst};\n use traits;\n use syntax::abi::Abi;\n-use syntax::codemap::DUMMY_SP;\n use util::ppaux;\n \n use std::fmt;\n@@ -212,7 +211,7 @@ fn resolve_associated_item<'a, 'tcx>(\n            def_id, trait_id, rcvr_substs);\n \n     let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n-    let vtbl = tcx.trans_fulfill_obligation(DUMMY_SP, param_env, ty::Binder(trait_ref));\n+    let vtbl = tcx.trans_fulfill_obligation((param_env, ty::Binder(trait_ref)));\n \n     // Now that we know which impl is being used, we can dispatch to\n     // the actual function:"}, {"sha": "137039598a55b5601ca6b7d887d6f740d0fd760f", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -221,6 +221,12 @@ impl<'tcx> QueryDescription for queries::is_mir_available<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::trans_fulfill_obligation<'tcx> {\n+    fn describe(tcx: TyCtxt, key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> String {\n+        format!(\"checking if `{}` fulfills its obligations\", tcx.item_path_str(key.1.def_id()))\n+    }\n+}\n+\n impl<'tcx> QueryDescription for queries::trait_impls_of<'tcx> {\n     fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         format!(\"trait impls of `{}`\", tcx.item_path_str(def_id))\n@@ -497,6 +503,12 @@ impl<'tcx> QueryDescription for queries::has_clone_closures<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::vtable_methods<'tcx> {\n+    fn describe(tcx: TyCtxt, key: ty::PolyTraitRef<'tcx> ) -> String {\n+        format!(\"finding all methods for trait {}\", tcx.item_path_str(key.def_id()))\n+    }\n+}\n+\n impl<'tcx> QueryDescription for queries::has_copy_closures<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"seeing if the crate has enabled `Copy` closures\")"}, {"sha": "ee4523d6f3e1ef8b148cc4c7605a9e54cfd041f1", "filename": "src/librustc/ty/maps/keys.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -134,6 +134,24 @@ impl Key for (MirSuite, MirPassIndex, DefId) {\n     }\n }\n \n+impl<'tcx> Key for (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.1.def_id().krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        tcx.def_span(self.1.def_id())\n+    }\n+}\n+\n+impl<'tcx> Key for ty::PolyTraitRef<'tcx>{\n+    fn map_crate(&self) -> CrateNum {\n+        self.def_id().krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        tcx.def_span(self.def_id())\n+    }\n+}\n+\n impl<'tcx> Key for Ty<'tcx> {\n     fn map_crate(&self) -> CrateNum {\n         LOCAL_CRATE"}, {"sha": "58405c261ad7239f73e4bef519aabbc78face5ba", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -15,6 +15,7 @@ use hir::def::{Def, Export};\n use hir::{self, TraitCandidate, ItemLocalId};\n use hir::svh::Svh;\n use lint;\n+use middle::borrowck::BorrowCheckResult;\n use middle::const_val;\n use middle::cstore::{ExternCrate, LinkagePreference, NativeLibrary,\n                      ExternBodyNestedBodies};\n@@ -30,6 +31,7 @@ use middle::trans::{CodegenUnit, Stats};\n use mir;\n use session::CompileResult;\n use session::config::OutputFilenames;\n+use traits::Vtable;\n use traits::specialization_graph;\n use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n use ty::layout::{Layout, LayoutError};\n@@ -182,7 +184,7 @@ define_maps! { <'tcx>\n \n     [] fn coherent_trait: coherent_trait_dep_node((CrateNum, DefId)) -> (),\n \n-    [] fn borrowck: BorrowCheck(DefId) -> (),\n+    [] fn borrowck: BorrowCheck(DefId) -> Rc<BorrowCheckResult>,\n     // FIXME: shouldn't this return a `Result<(), BorrowckErrors>` instead?\n     [] fn mir_borrowck: MirBorrowCheck(DefId) -> (),\n \n@@ -227,7 +229,11 @@ define_maps! { <'tcx>\n     [] fn item_body_nested_bodies: ItemBodyNestedBodies(DefId) -> ExternBodyNestedBodies,\n     [] fn const_is_rvalue_promotable_to_static: ConstIsRvaluePromotableToStatic(DefId) -> bool,\n     [] fn is_mir_available: IsMirAvailable(DefId) -> bool,\n+    [] fn vtable_methods: vtable_methods_node(ty::PolyTraitRef<'tcx>)\n+                          -> Rc<Vec<Option<(DefId, &'tcx Substs<'tcx>)>>>,\n \n+    [] fn trans_fulfill_obligation: fulfill_obligation_dep_node(\n+        (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> Vtable<'tcx, ()>,\n     [] fn trait_impls_of: TraitImpls(DefId) -> Rc<ty::trait_def::TraitImpls>,\n     [] fn specialization_graph_of: SpecializationGraph(DefId) -> Rc<specialization_graph::Graph>,\n     [] fn is_object_safe: ObjectSafety(DefId) -> bool,\n@@ -347,6 +353,14 @@ fn type_param_predicates<'tcx>((item_id, param_id): (DefId, DefId)) -> DepConstr\n     }\n }\n \n+fn fulfill_obligation_dep_node<'tcx>((param_env, trait_ref):\n+    (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> DepConstructor<'tcx> {\n+    DepConstructor::FulfillObligation {\n+        param_env,\n+        trait_ref\n+    }\n+}\n+\n fn coherent_trait_dep_node<'tcx>((_, def_id): (CrateNum, DefId)) -> DepConstructor<'tcx> {\n     DepConstructor::CoherenceCheckTrait(def_id)\n }\n@@ -459,3 +473,7 @@ fn collect_and_partition_translation_items_node<'tcx>(_: CrateNum) -> DepConstru\n fn output_filenames_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::OutputFilenames\n }\n+\n+fn vtable_methods_node<'tcx>(trait_ref: ty::PolyTraitRef<'tcx>) -> DepConstructor<'tcx> {\n+    DepConstructor::VtableMethods{ trait_ref }\n+}"}, {"sha": "d6eaf6d1bc48fef0eee6daabc1b93134e8ca146d", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 99, "deletions": 103, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -344,6 +344,52 @@ macro_rules! define_maps {\n                 }\n             }\n \n+            /// Ensure that either this query has all green inputs or been executed.\n+            /// Executing query::ensure(D) is considered a read of the dep-node D.\n+            ///\n+            /// This function is particularly useful when executing passes for their\n+            /// side-effects -- e.g., in order to report errors for erroneous programs.\n+            ///\n+            /// Note: The optimization is only available during incr. comp.\n+            pub fn ensure(tcx: TyCtxt<'a, $tcx, 'lcx>, key: $K) -> () {\n+                let dep_node = Self::to_dep_node(tcx, &key);\n+\n+                // Ensuring an \"input\" or anonymous query makes no sense\n+                assert!(!dep_node.kind.is_anon());\n+                assert!(!dep_node.kind.is_input());\n+                use dep_graph::DepNodeColor;\n+                match tcx.dep_graph.node_color(&dep_node) {\n+                    Some(DepNodeColor::Green(dep_node_index)) => {\n+                        tcx.dep_graph.read_index(dep_node_index);\n+                    }\n+                    Some(DepNodeColor::Red) => {\n+                        // A DepNodeColor::Red DepNode means that this query was executed\n+                        // before. We can not call `dep_graph.read()` here as we don't have\n+                        // the DepNodeIndex. Instead, We call the query again to issue the\n+                        // appropriate `dep_graph.read()` call. The performance cost this\n+                        // introduces should be negligible as we'll immediately hit the\n+                        // in-memory cache.\n+                        let _ = tcx.$name(key);\n+                    }\n+                    None => {\n+                        // Huh\n+                        if !tcx.dep_graph.is_fully_enabled() {\n+                            let _ = tcx.$name(key);\n+                            return;\n+                        }\n+                        match tcx.dep_graph.try_mark_green(tcx, &dep_node) {\n+                            Some(dep_node_index) => {\n+                                debug_assert!(tcx.dep_graph.is_green(dep_node_index));\n+                                tcx.dep_graph.read_index(dep_node_index);\n+                            }\n+                            None => {\n+                                let _ = tcx.$name(key);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n             fn compute_result(tcx: TyCtxt<'a, $tcx, 'lcx>, key: $K) -> $V {\n                 let provider = tcx.maps.providers[key.map_crate()].$name;\n                 provider(tcx.global_tcx(), key)\n@@ -468,8 +514,7 @@ macro_rules! define_maps {\n \n         define_provider_struct! {\n             tcx: $tcx,\n-            input: ($(([$($modifiers)*] [$name] [$K] [$V]))*),\n-            output: ()\n+            input: ($(([$($modifiers)*] [$name] [$K] [$V]))*)\n         }\n \n         impl<$tcx> Copy for Providers<$tcx> {}\n@@ -480,78 +525,19 @@ macro_rules! define_maps {\n }\n \n macro_rules! define_map_struct {\n-    // Initial state\n     (tcx: $tcx:tt,\n-     input: $input:tt) => {\n-        define_map_struct! {\n-            tcx: $tcx,\n-            input: $input,\n-            output: ()\n-        }\n-    };\n-\n-    // Final output\n-    (tcx: $tcx:tt,\n-     input: (),\n-     output: ($($output:tt)*)) => {\n+     input: ($(([$(modifiers:tt)*] [$($attr:tt)*] [$name:ident]))*)) => {\n         pub struct Maps<$tcx> {\n             providers: IndexVec<CrateNum, Providers<$tcx>>,\n             query_stack: RefCell<Vec<(Span, Query<$tcx>)>>,\n-            $($output)*\n-        }\n-    };\n-\n-    // Field recognized and ready to shift into the output\n-    (tcx: $tcx:tt,\n-     ready: ([$($pub:tt)*] [$($attr:tt)*] [$name:ident]),\n-     input: $input:tt,\n-     output: ($($output:tt)*)) => {\n-        define_map_struct! {\n-            tcx: $tcx,\n-            input: $input,\n-            output: ($($output)*\n-                     $(#[$attr])* $($pub)* $name: RefCell<QueryMap<queries::$name<$tcx>>>,)\n-        }\n-    };\n-\n-    // No modifiers left? This is a private item.\n-    (tcx: $tcx:tt,\n-     input: (([] $attrs:tt $name:tt) $($input:tt)*),\n-     output: $output:tt) => {\n-        define_map_struct! {\n-            tcx: $tcx,\n-            ready: ([] $attrs $name),\n-            input: ($($input)*),\n-            output: $output\n-        }\n-    };\n-\n-    // Skip other modifiers\n-    (tcx: $tcx:tt,\n-     input: (([$other_modifier:tt $($modifiers:tt)*] $($fields:tt)*) $($input:tt)*),\n-     output: $output:tt) => {\n-        define_map_struct! {\n-            tcx: $tcx,\n-            input: (([$($modifiers)*] $($fields)*) $($input)*),\n-            output: $output\n+            $($(#[$attr])*  $name: RefCell<QueryMap<queries::$name<$tcx>>>,)*\n         }\n     };\n }\n \n macro_rules! define_provider_struct {\n-    // Initial state:\n-    (tcx: $tcx:tt, input: $input:tt) => {\n-        define_provider_struct! {\n-            tcx: $tcx,\n-            input: $input,\n-            output: ()\n-        }\n-    };\n-\n-    // Final state:\n     (tcx: $tcx:tt,\n-     input: (),\n-     output: ($(([$name:ident] [$K:ty] [$R:ty]))*)) => {\n+     input: ($(([$($modifiers:tt)*] [$name:ident] [$K:ty] [$R:ty]))*)) => {\n         pub struct Providers<$tcx> {\n             $(pub $name: for<'a> fn(TyCtxt<'a, $tcx, $tcx>, $K) -> $R,)*\n         }\n@@ -566,43 +552,51 @@ macro_rules! define_provider_struct {\n             }\n         }\n     };\n-\n-    // Something ready to shift:\n-    (tcx: $tcx:tt,\n-     ready: ($name:tt $K:tt $V:tt),\n-     input: $input:tt,\n-     output: ($($output:tt)*)) => {\n-        define_provider_struct! {\n-            tcx: $tcx,\n-            input: $input,\n-            output: ($($output)* ($name $K $V))\n-        }\n-    };\n-\n-    // Regular queries produce a `V` only.\n-    (tcx: $tcx:tt,\n-     input: (([] $name:tt $K:tt $V:tt) $($input:tt)*),\n-     output: $output:tt) => {\n-        define_provider_struct! {\n-            tcx: $tcx,\n-            ready: ($name $K $V),\n-            input: ($($input)*),\n-            output: $output\n-        }\n-    };\n-\n-    // Skip modifiers.\n-    (tcx: $tcx:tt,\n-     input: (([$other_modifier:tt $($modifiers:tt)*] $($fields:tt)*) $($input:tt)*),\n-     output: $output:tt) => {\n-        define_provider_struct! {\n-            tcx: $tcx,\n-            input: (([$($modifiers)*] $($fields)*) $($input)*),\n-            output: $output\n-        }\n-    };\n }\n \n+\n+/// The red/green evaluation system will try to mark a specific DepNode in the\n+/// dependency graph as green by recursively trying to mark the dependencies of\n+/// that DepNode as green. While doing so, it will sometimes encounter a DepNode\n+/// where we don't know if it is red or green and we therefore actually have\n+/// to recompute its value in order to find out. Since the only piece of\n+/// information that we have at that point is the DepNode we are trying to\n+/// re-evaluate, we need some way to re-run a query from just that. This is what\n+/// `force_from_dep_node()` implements.\n+///\n+/// In the general case, a DepNode consists of a DepKind and an opaque\n+/// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n+/// is usually constructed by computing a stable hash of the query-key that the\n+/// DepNode corresponds to. Consequently, it is not in general possible to go\n+/// back from hash to query-key (since hash functions are not reversible). For\n+/// this reason `force_from_dep_node()` is expected to fail from time to time\n+/// because we just cannot find out, from the DepNode alone, what the\n+/// corresponding query-key is and therefore cannot re-run the query.\n+///\n+/// The system deals with this case letting `try_mark_green` fail which forces\n+/// the root query to be re-evaluated.\n+///\n+/// Now, if force_from_dep_node() would always fail, it would be pretty useless.\n+/// Fortunately, we can use some contextual information that will allow us to\n+/// reconstruct query-keys for certain kinds of DepNodes. In particular, we\n+/// enforce by construction that the GUID/fingerprint of certain DepNodes is a\n+/// valid DefPathHash. Since we also always build a huge table that maps every\n+/// DefPathHash in the current codebase to the corresponding DefId, we have\n+/// everything we need to re-run the query.\n+///\n+/// Take the `mir_validated` query as an example. Like many other queries, it\n+/// just has a single parameter: the DefId of the item it will compute the\n+/// validated MIR for. Now, when we call `force_from_dep_node()` on a dep-node\n+/// with kind `MirValidated`, we know that the GUID/fingerprint of the dep-node\n+/// is actually a DefPathHash, and can therefore just look up the corresponding\n+/// DefId in `tcx.def_path_hash_to_def_id`.\n+///\n+/// When you implement a new query, it will likely have a corresponding new\n+/// DepKind, and you'll have to support it here in `force_from_dep_node()`. As\n+/// a rule of thumb, if your query takes a DefId or DefIndex as sole parameter,\n+/// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n+/// add it to the \"We don't have enough information to reconstruct...\" group in\n+/// the match below.\n pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n                                            dep_node: &DepNode)\n                                            -> bool {\n@@ -687,16 +681,16 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::Hir |\n \n         // This are anonymous nodes\n+        DepKind::TraitSelect |\n+\n+        // We don't have enough information to reconstruct the query key of\n+        // these\n         DepKind::IsCopy |\n         DepKind::IsSized |\n         DepKind::IsFreeze |\n         DepKind::NeedsDrop |\n         DepKind::Layout |\n-        DepKind::TraitSelect |\n         DepKind::ConstEval |\n-\n-        // We don't have enough information to reconstruct the query key of\n-        // these\n         DepKind::InstanceSymbolName |\n         DepKind::MirShim |\n         DepKind::BorrowCheckKrate |\n@@ -705,6 +699,8 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::TypeParamPredicates |\n         DepKind::CodegenUnit |\n         DepKind::CompileCodegenUnit |\n+        DepKind::FulfillObligation |\n+        DepKind::VtableMethods |\n \n         // These are just odd\n         DepKind::Null |"}, {"sha": "0eb2c19fe44ddeb72a2013ce0e79638691e64a39", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 989, "deletions": 768, "changes": 1757, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -20,6 +20,7 @@ use ty::{TyParam, TyRawPtr, TyRef, TyNever, TyTuple};\n use ty::{TyClosure, TyGenerator, TyProjection, TyAnon};\n use ty::{TyDynamic, TyInt, TyUint, TyInfer};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use util::nodemap::FxHashSet;\n \n use std::cell::Cell;\n use std::fmt;\n@@ -32,310 +33,543 @@ use syntax::ast::CRATE_NODE_ID;\n use syntax::symbol::Symbol;\n use hir;\n \n-pub fn verbose() -> bool {\n-    ty::tls::with(|tcx| tcx.sess.verbose())\n+macro_rules! gen_display_debug_body {\n+    ( $with:path ) => {\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            let mut cx = PrintContext::new();\n+            $with(self, f, &mut cx)\n+        }\n+    };\n }\n-\n-pub fn identify_regions() -> bool {\n-    ty::tls::with(|tcx| tcx.sess.opts.debugging_opts.identify_regions)\n+macro_rules! gen_display_debug {\n+    ( ($($x:tt)+) $target:ty, display yes ) => {\n+        impl<$($x)+> fmt::Display for $target {\n+            gen_display_debug_body! { Print::print_display }\n+        }\n+    };\n+    ( () $target:ty, display yes ) => {\n+        impl fmt::Display for $target {\n+            gen_display_debug_body! { Print::print_display }\n+        }\n+    };\n+    ( ($($x:tt)+) $target:ty, debug yes ) => {\n+        impl<$($x)+> fmt::Debug for $target {\n+            gen_display_debug_body! { Print::print_debug }\n+        }\n+    };\n+    ( () $target:ty, debug yes ) => {\n+        impl fmt::Debug for $target {\n+            gen_display_debug_body! { Print::print_debug }\n+        }\n+    };\n+    ( $generic:tt $target:ty, $t:ident no ) => {};\n }\n-\n-fn fn_sig(f: &mut fmt::Formatter,\n-          inputs: &[Ty],\n-          variadic: bool,\n-          output: Ty)\n-          -> fmt::Result {\n-    write!(f, \"(\")?;\n-    let mut inputs = inputs.iter();\n-    if let Some(&ty) = inputs.next() {\n-        write!(f, \"{}\", ty)?;\n-        for &ty in inputs {\n-            write!(f, \", {}\", ty)?;\n+macro_rules! gen_print_impl {\n+    ( ($($x:tt)+) $target:ty, ($self:ident, $f:ident, $cx:ident) $disp:block $dbg:block ) => {\n+        impl<$($x)+> Print for $target {\n+            fn print<F: fmt::Write>(&$self, $f: &mut F, $cx: &mut PrintContext) -> fmt::Result {\n+                if $cx.is_debug $dbg\n+                else $disp\n+            }\n         }\n-        if variadic {\n-            write!(f, \", ...\")?;\n+    };\n+    ( () $target:ty, ($self:ident, $f:ident, $cx:ident) $disp:block $dbg:block ) => {\n+        impl Print for $target {\n+            fn print<F: fmt::Write>(&$self, $f: &mut F, $cx: &mut PrintContext) -> fmt::Result {\n+                if $cx.is_debug $dbg\n+                else $disp\n+            }\n         }\n+    };\n+    ( $generic:tt $target:ty,\n+      $vars:tt $gendisp:ident $disp:block $gendbg:ident $dbg:block ) => {\n+        gen_print_impl! { $generic $target, $vars $disp $dbg }\n+        gen_display_debug! { $generic $target, display $gendisp }\n+        gen_display_debug! { $generic $target, debug $gendbg }\n     }\n-    write!(f, \")\")?;\n-    if !output.is_nil() {\n-        write!(f, \" -> {}\", output)?;\n+}\n+macro_rules! define_print {\n+    ( $generic:tt $target:ty,\n+      $vars:tt { display $disp:block debug $dbg:block } ) => {\n+        gen_print_impl! { $generic $target, $vars yes $disp yes $dbg }\n+    };\n+    ( $generic:tt $target:ty,\n+      $vars:tt { debug $dbg:block display $disp:block } ) => {\n+        gen_print_impl! { $generic $target, $vars yes $disp yes $dbg }\n+    };\n+    ( $generic:tt $target:ty,\n+      $vars:tt { debug $dbg:block } ) => {\n+        gen_print_impl! { $generic $target, $vars no {\n+            bug!(concat!(\"display not implemented for \", stringify!($target)));\n+        } yes $dbg }\n+    };\n+    ( $generic:tt $target:ty,\n+      ($self:ident, $f:ident, $cx:ident) { display $disp:block } ) => {\n+        gen_print_impl! { $generic $target, ($self, $f, $cx) yes $disp no {\n+            write!($f, \"{:?}\", $self)\n+        } }\n+    };\n+}\n+macro_rules! define_print_multi {\n+    ( [ $($generic:tt $target:ty),* ] $vars:tt $def:tt ) => {\n+        $(define_print! { $generic $target, $vars $def })*\n+    };\n+}\n+macro_rules! print_inner {\n+    ( $f:expr, $cx:expr, write ($($data:expr),+) ) => {\n+        write!($f, $($data),+)\n+    };\n+    ( $f:expr, $cx:expr, $kind:ident ($data:expr) ) => {\n+        $data.$kind($f, $cx)\n+    };\n+}\n+macro_rules! print {\n+    ( $f:expr, $cx:expr $(, $kind:ident $data:tt)+ ) => {\n+        Ok(())$(.and_then(|_| print_inner!($f, $cx, $kind $data)))+\n+    };\n+}\n+\n+\n+struct LateBoundRegionNameCollector(FxHashSet<Symbol>);\n+impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector {\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+        match *r {\n+            ty::ReLateBound(_, ty::BrNamed(_, name)) => {\n+                self.0.insert(name);\n+            },\n+            _ => {},\n+        }\n+        r.super_visit_with(self)\n     }\n+}\n \n-    Ok(())\n+#[derive(Debug)]\n+pub struct PrintContext {\n+    is_debug: bool,\n+    is_verbose: bool,\n+    identify_regions: bool,\n+    used_region_names: Option<FxHashSet<Symbol>>,\n+    region_index: usize,\n+    binder_depth: usize,\n+}\n+impl PrintContext {\n+    fn new() -> Self {\n+        ty::tls::with_opt(|tcx| {\n+            let (is_verbose, identify_regions) = tcx.map(\n+                |tcx| (tcx.sess.verbose(), tcx.sess.opts.debugging_opts.identify_regions)\n+            ).unwrap_or((false, false));\n+            PrintContext {\n+                is_debug: false,\n+                is_verbose: is_verbose,\n+                identify_regions: identify_regions,\n+                used_region_names: None,\n+                region_index: 0,\n+                binder_depth: 0,\n+            }\n+        })\n+    }\n+    fn prepare_late_bound_region_info<'tcx, T>(&mut self, value: &ty::Binder<T>)\n+    where T: TypeFoldable<'tcx>\n+    {\n+        let mut collector = LateBoundRegionNameCollector(FxHashSet());\n+        value.visit_with(&mut collector);\n+        self.used_region_names = Some(collector.0);\n+        self.region_index = 0;\n+    }\n }\n \n-pub fn parameterized(f: &mut fmt::Formatter,\n-                     substs: &subst::Substs,\n-                     mut did: DefId,\n-                     projections: &[ty::ProjectionPredicate])\n-                     -> fmt::Result {\n-    let key = ty::tls::with(|tcx| tcx.def_key(did));\n-    let mut item_name = if let Some(name) = key.disambiguated_data.data.get_opt_name() {\n-        Some(name)\n-    } else {\n-        did.index = key.parent.unwrap_or_else(\n-            || bug!(\"finding type for {:?}, encountered def-id {:?} with no parent\",\n-                    did, did));\n-        parameterized(f, substs, did, projections)?;\n-        return write!(f, \"::{}\", key.disambiguated_data.data.as_interned_str());\n-    };\n+pub trait Print {\n+    fn print<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintContext) -> fmt::Result;\n+    fn print_to_string(&self, cx: &mut PrintContext) -> String {\n+        let mut result = String::new();\n+        let _ = self.print(&mut result, cx);\n+        result\n+    }\n+    fn print_display<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintContext) -> fmt::Result {\n+        let old_debug = cx.is_debug;\n+        cx.is_debug = false;\n+        let result = self.print(f, cx);\n+        cx.is_debug = old_debug;\n+        result\n+    }\n+    fn print_display_to_string(&self, cx: &mut PrintContext) -> String {\n+        let mut result = String::new();\n+        let _ = self.print_display(&mut result, cx);\n+        result\n+    }\n+    fn print_debug<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintContext) -> fmt::Result {\n+        let old_debug = cx.is_debug;\n+        cx.is_debug = true;\n+        let result = self.print(f, cx);\n+        cx.is_debug = old_debug;\n+        result\n+    }\n+    fn print_debug_to_string(&self, cx: &mut PrintContext) -> String {\n+        let mut result = String::new();\n+        let _ = self.print_debug(&mut result, cx);\n+        result\n+    }\n+}\n \n-    let mut verbose = false;\n-    let mut num_supplied_defaults = 0;\n-    let mut has_self = false;\n-    let mut num_regions = 0;\n-    let mut num_types = 0;\n-    let mut is_value_path = false;\n-    let fn_trait_kind = ty::tls::with(|tcx| {\n-        // Unfortunately, some kinds of items (e.g., closures) don't have\n-        // generics. So walk back up the find the closest parent that DOES\n-        // have them.\n-        let mut item_def_id = did;\n-        loop {\n-            let key = tcx.def_key(item_def_id);\n-            match key.disambiguated_data.data {\n-                DefPathData::TypeNs(_) => {\n-                    break;\n-                }\n-                DefPathData::ValueNs(_) | DefPathData::EnumVariant(_) => {\n-                    is_value_path = true;\n-                    break;\n-                }\n-                _ => {\n-                    // if we're making a symbol for something, there ought\n-                    // to be a value or type-def or something in there\n-                    // *somewhere*\n-                    item_def_id.index = key.parent.unwrap_or_else(|| {\n-                        bug!(\"finding type for {:?}, encountered def-id {:?} with no \\\n-                             parent\", did, item_def_id);\n-                    });\n-                }\n+impl PrintContext {\n+    fn fn_sig<F: fmt::Write>(&mut self,\n+                             f: &mut F,\n+                             inputs: &[Ty],\n+                             variadic: bool,\n+                             output: Ty)\n+                             -> fmt::Result {\n+        write!(f, \"(\")?;\n+        let mut inputs = inputs.iter();\n+        if let Some(&ty) = inputs.next() {\n+            print!(f, self, print_display(ty))?;\n+            for &ty in inputs {\n+                print!(f, self, write(\", \"), print_display(ty))?;\n+            }\n+            if variadic {\n+                write!(f, \", ...\")?;\n             }\n         }\n-        let mut generics = tcx.generics_of(item_def_id);\n-        let mut path_def_id = did;\n-        verbose = tcx.sess.verbose();\n-        has_self = generics.has_self;\n-\n-        let mut child_types = 0;\n-        if let Some(def_id) = generics.parent {\n-            // Methods.\n-            assert!(is_value_path);\n-            child_types = generics.types.len();\n-            generics = tcx.generics_of(def_id);\n-            num_regions = generics.regions.len();\n-            num_types = generics.types.len();\n+        write!(f, \")\")?;\n+        if !output.is_nil() {\n+            print!(f, self, write(\" -> \"), print_display(output))?;\n+        }\n \n-            if has_self {\n-                write!(f, \"<{} as \", substs.type_at(0))?;\n-            }\n+        Ok(())\n+    }\n \n-            path_def_id = def_id;\n+    fn parameterized<F: fmt::Write>(&mut self,\n+                                    f: &mut F,\n+                                    substs: &subst::Substs,\n+                                    mut did: DefId,\n+                                    projections: &[ty::ProjectionPredicate])\n+                                    -> fmt::Result {\n+        let key = ty::tls::with(|tcx| tcx.def_key(did));\n+        let mut item_name = if let Some(name) = key.disambiguated_data.data.get_opt_name() {\n+            Some(name)\n         } else {\n-            item_name = None;\n+            did.index = key.parent.unwrap_or_else(\n+                || bug!(\"finding type for {:?}, encountered def-id {:?} with no parent\",\n+                        did, did));\n+            self.parameterized(f, substs, did, projections)?;\n+            return write!(f, \"::{}\", key.disambiguated_data.data.as_interned_str());\n+        };\n \n-            if is_value_path {\n-                // Functions.\n-                assert_eq!(has_self, false);\n-            } else {\n-                // Types and traits.\n+        let verbose = self.is_verbose;\n+        let mut num_supplied_defaults = 0;\n+        let mut has_self = false;\n+        let mut num_regions = 0;\n+        let mut num_types = 0;\n+        let mut is_value_path = false;\n+        let fn_trait_kind = ty::tls::with(|tcx| {\n+            // Unfortunately, some kinds of items (e.g., closures) don't have\n+            // generics. So walk back up the find the closest parent that DOES\n+            // have them.\n+            let mut item_def_id = did;\n+            loop {\n+                let key = tcx.def_key(item_def_id);\n+                match key.disambiguated_data.data {\n+                    DefPathData::TypeNs(_) => {\n+                        break;\n+                    }\n+                    DefPathData::ValueNs(_) | DefPathData::EnumVariant(_) => {\n+                        is_value_path = true;\n+                        break;\n+                    }\n+                    _ => {\n+                        // if we're making a symbol for something, there ought\n+                        // to be a value or type-def or something in there\n+                        // *somewhere*\n+                        item_def_id.index = key.parent.unwrap_or_else(|| {\n+                            bug!(\"finding type for {:?}, encountered def-id {:?} with no \\\n+                                 parent\", did, item_def_id);\n+                        });\n+                    }\n+                }\n+            }\n+            let mut generics = tcx.generics_of(item_def_id);\n+            let mut path_def_id = did;\n+            has_self = generics.has_self;\n+\n+            let mut child_types = 0;\n+            if let Some(def_id) = generics.parent {\n+                // Methods.\n+                assert!(is_value_path);\n+                child_types = generics.types.len();\n+                generics = tcx.generics_of(def_id);\n                 num_regions = generics.regions.len();\n                 num_types = generics.types.len();\n+\n+                if has_self {\n+                    print!(f, self, write(\"<\"), print_display(substs.type_at(0)), write(\" as \"))?;\n+                }\n+\n+                path_def_id = def_id;\n+            } else {\n+                item_name = None;\n+\n+                if is_value_path {\n+                    // Functions.\n+                    assert_eq!(has_self, false);\n+                } else {\n+                    // Types and traits.\n+                    num_regions = generics.regions.len();\n+                    num_types = generics.types.len();\n+                }\n             }\n-        }\n \n-        if !verbose {\n-            if generics.types.last().map_or(false, |def| def.has_default) {\n-                if let Some(substs) = tcx.lift(&substs) {\n-                    let tps = substs.types().rev().skip(child_types);\n-                    for (def, actual) in generics.types.iter().rev().zip(tps) {\n-                        if !def.has_default {\n-                            break;\n-                        }\n-                        if tcx.type_of(def.def_id).subst(tcx, substs) != actual {\n-                            break;\n+            if !verbose {\n+                if generics.types.last().map_or(false, |def| def.has_default) {\n+                    if let Some(substs) = tcx.lift(&substs) {\n+                        let tps = substs.types().rev().skip(child_types);\n+                        for (def, actual) in generics.types.iter().rev().zip(tps) {\n+                            if !def.has_default {\n+                                break;\n+                            }\n+                            if tcx.type_of(def.def_id).subst(tcx, substs) != actual {\n+                                break;\n+                            }\n+                            num_supplied_defaults += 1;\n                         }\n-                        num_supplied_defaults += 1;\n                     }\n                 }\n             }\n-        }\n \n-        write!(f, \"{}\", tcx.item_path_str(path_def_id))?;\n-        Ok(tcx.lang_items().fn_trait_kind(path_def_id))\n-    })?;\n+            print!(f, self, write(\"{}\", tcx.item_path_str(path_def_id)))?;\n+            Ok(tcx.lang_items().fn_trait_kind(path_def_id))\n+        })?;\n \n-    if !verbose && fn_trait_kind.is_some() && projections.len() == 1 {\n-        let projection_ty = projections[0].ty;\n-        if let TyTuple(ref args, _) = substs.type_at(1).sty {\n-            return fn_sig(f, args, false, projection_ty);\n+        if !verbose && fn_trait_kind.is_some() && projections.len() == 1 {\n+            let projection_ty = projections[0].ty;\n+            if let TyTuple(ref args, _) = substs.type_at(1).sty {\n+                return self.fn_sig(f, args, false, projection_ty);\n+            }\n         }\n-    }\n \n-    let empty = Cell::new(true);\n-    let start_or_continue = |f: &mut fmt::Formatter, start: &str, cont: &str| {\n-        if empty.get() {\n-            empty.set(false);\n-            write!(f, \"{}\", start)\n-        } else {\n-            write!(f, \"{}\", cont)\n-        }\n-    };\n+        let empty = Cell::new(true);\n+        let start_or_continue = |f: &mut F, start: &str, cont: &str| {\n+            if empty.get() {\n+                empty.set(false);\n+                write!(f, \"{}\", start)\n+            } else {\n+                write!(f, \"{}\", cont)\n+            }\n+        };\n \n-    let print_regions = |f: &mut fmt::Formatter, start: &str, skip, count| {\n-        // Don't print any regions if they're all erased.\n-        let regions = || substs.regions().skip(skip).take(count);\n-        if regions().all(|r: ty::Region| *r == ty::ReErased) {\n-            return Ok(());\n-        }\n+        let print_regions = |f: &mut F, start: &str, skip, count| {\n+            // Don't print any regions if they're all erased.\n+            let regions = || substs.regions().skip(skip).take(count);\n+            if regions().all(|r: ty::Region| *r == ty::ReErased) {\n+                return Ok(());\n+            }\n \n-        for region in regions() {\n-            let region: ty::Region = region;\n-            start_or_continue(f, start, \", \")?;\n-            if verbose {\n-                write!(f, \"{:?}\", region)?;\n-            } else {\n-                let s = region.to_string();\n-                if s.is_empty() {\n-                    // This happens when the value of the region\n-                    // parameter is not easily serialized. This may be\n-                    // because the user omitted it in the first place,\n-                    // or because it refers to some block in the code,\n-                    // etc. I'm not sure how best to serialize this.\n-                    write!(f, \"'_\")?;\n+            for region in regions() {\n+                let region: ty::Region = region;\n+                start_or_continue(f, start, \", \")?;\n+                if verbose {\n+                    write!(f, \"{:?}\", region)?;\n                 } else {\n-                    write!(f, \"{}\", s)?;\n+                    let s = region.to_string();\n+                    if s.is_empty() {\n+                        // This happens when the value of the region\n+                        // parameter is not easily serialized. This may be\n+                        // because the user omitted it in the first place,\n+                        // or because it refers to some block in the code,\n+                        // etc. I'm not sure how best to serialize this.\n+                        write!(f, \"'_\")?;\n+                    } else {\n+                        write!(f, \"{}\", s)?;\n+                    }\n                 }\n             }\n+\n+            Ok(())\n+        };\n+\n+        print_regions(f, \"<\", 0, num_regions)?;\n+\n+        let tps = substs.types().take(num_types - num_supplied_defaults)\n+                                .skip(has_self as usize);\n+\n+        for ty in tps {\n+            start_or_continue(f, \"<\", \", \")?;\n+            ty.print_display(f, self)?;\n         }\n \n-        Ok(())\n-    };\n+        for projection in projections {\n+            start_or_continue(f, \"<\", \", \")?;\n+            ty::tls::with(|tcx|\n+                print!(f, self,\n+                       write(\"{}=\",\n+                             tcx.associated_item(projection.projection_ty.item_def_id).name),\n+                       print_display(projection.ty))\n+            )?;\n+        }\n \n-    print_regions(f, \"<\", 0, num_regions)?;\n+        start_or_continue(f, \"\", \">\")?;\n \n-    let tps = substs.types().take(num_types - num_supplied_defaults)\n-                            .skip(has_self as usize);\n+        // For values, also print their name and type parameters.\n+        if is_value_path {\n+            empty.set(true);\n \n-    for ty in tps {\n-        start_or_continue(f, \"<\", \", \")?;\n-        write!(f, \"{}\", ty)?;\n-    }\n+            if has_self {\n+                write!(f, \">\")?;\n+            }\n \n-    for projection in projections {\n-        start_or_continue(f, \"<\", \", \")?;\n-        ty::tls::with(|tcx|\n-            write!(f, \"{}={}\",\n-            tcx.associated_item(projection.projection_ty.item_def_id).name,\n-            projection.ty)\n-        )?;\n-    }\n+            if let Some(item_name) = item_name {\n+                write!(f, \"::{}\", item_name)?;\n+            }\n \n-    start_or_continue(f, \"\", \">\")?;\n+            print_regions(f, \"::<\", num_regions, usize::MAX)?;\n \n-    // For values, also print their name and type parameters.\n-    if is_value_path {\n-        empty.set(true);\n+            // FIXME: consider being smart with defaults here too\n+            for ty in substs.types().skip(num_types) {\n+                start_or_continue(f, \"::<\", \", \")?;\n+                ty.print_display(f, self)?;\n+            }\n \n-        if has_self {\n-            write!(f, \">\")?;\n+            start_or_continue(f, \"\", \">\")?;\n         }\n \n-        if let Some(item_name) = item_name {\n-            write!(f, \"::{}\", item_name)?;\n+        Ok(())\n+    }\n+\n+    fn in_binder<'a, 'gcx, 'tcx, T, U, F>(&mut self,\n+                                          f: &mut F,\n+                                          tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                          original: &ty::Binder<T>,\n+                                          lifted: Option<ty::Binder<U>>) -> fmt::Result\n+        where T: Print, U: Print + TypeFoldable<'tcx>, F: fmt::Write\n+    {\n+        fn name_by_region_index(index: usize) -> Symbol {\n+            match index {\n+                0 => Symbol::intern(\"'r\"),\n+                1 => Symbol::intern(\"'s\"),\n+                i => Symbol::intern(&format!(\"'t{}\", i-2)),\n+            }\n         }\n \n-        print_regions(f, \"::<\", num_regions, usize::MAX)?;\n+        // Replace any anonymous late-bound regions with named\n+        // variants, using gensym'd identifiers, so that we can\n+        // clearly differentiate between named and unnamed regions in\n+        // the output. We'll probably want to tweak this over time to\n+        // decide just how much information to give.\n+        let value = if let Some(v) = lifted {\n+            v\n+        } else {\n+            return original.0.print_display(f, self);\n+        };\n \n-        // FIXME: consider being smart with defaults here too\n-        for ty in substs.types().skip(num_types) {\n-            start_or_continue(f, \"::<\", \", \")?;\n-            write!(f, \"{}\", ty)?;\n+        if self.binder_depth == 0 {\n+            self.prepare_late_bound_region_info(&value);\n         }\n \n-        start_or_continue(f, \"\", \">\")?;\n+        let mut empty = true;\n+        let mut start_or_continue = |f: &mut F, start: &str, cont: &str| {\n+            if empty {\n+                empty = false;\n+                write!(f, \"{}\", start)\n+            } else {\n+                write!(f, \"{}\", cont)\n+            }\n+        };\n+\n+        let old_region_index = self.region_index;\n+        let mut region_index = old_region_index;\n+        let new_value = tcx.replace_late_bound_regions(&value, |br| {\n+            let _ = start_or_continue(f, \"for<\", \", \");\n+            let br = match br {\n+                ty::BrNamed(_, name) => {\n+                    let _ = write!(f, \"{}\", name);\n+                    br\n+                }\n+                ty::BrAnon(_) |\n+                ty::BrFresh(_) |\n+                ty::BrEnv => {\n+                    let name = loop {\n+                        let name = name_by_region_index(region_index);\n+                        region_index += 1;\n+                        if !self.is_name_used(&name) {\n+                            break name;\n+                        }\n+                    };\n+                    let _ = write!(f, \"{}\", name);\n+                    ty::BrNamed(tcx.hir.local_def_id(CRATE_NODE_ID),\n+                                name)\n+                }\n+            };\n+            tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1), br))\n+        }).0;\n+        start_or_continue(f, \"\", \"> \")?;\n+\n+        // Push current state to gcx, and restore after writing new_value.\n+        self.binder_depth += 1;\n+        self.region_index = region_index;\n+        let result = new_value.print_display(f, self);\n+        self.region_index = old_region_index;\n+        self.binder_depth -= 1;\n+        result\n     }\n \n-    Ok(())\n+    fn is_name_used(&self, name: &Symbol) -> bool {\n+        match self.used_region_names {\n+            Some(ref names) => names.contains(name),\n+            None => false,\n+        }\n+    }\n }\n \n-fn in_binder<'a, 'gcx, 'tcx, T, U>(f: &mut fmt::Formatter,\n-                                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                   original: &ty::Binder<T>,\n-                                   lifted: Option<ty::Binder<U>>) -> fmt::Result\n-    where T: fmt::Display, U: fmt::Display + TypeFoldable<'tcx>\n-{\n-    // Replace any anonymous late-bound regions with named\n-    // variants, using gensym'd identifiers, so that we can\n-    // clearly differentiate between named and unnamed regions in\n-    // the output. We'll probably want to tweak this over time to\n-    // decide just how much information to give.\n-    let value = if let Some(v) = lifted {\n-        v\n-    } else {\n-        return write!(f, \"{}\", original.0);\n-    };\n+pub fn verbose() -> bool {\n+    ty::tls::with(|tcx| tcx.sess.verbose())\n+}\n \n-    let mut empty = true;\n-    let mut start_or_continue = |f: &mut fmt::Formatter, start: &str, cont: &str| {\n-        if empty {\n-            empty = false;\n-            write!(f, \"{}\", start)\n-        } else {\n-            write!(f, \"{}\", cont)\n-        }\n-    };\n+pub fn identify_regions() -> bool {\n+    ty::tls::with(|tcx| tcx.sess.opts.debugging_opts.identify_regions)\n+}\n \n-    let new_value = tcx.replace_late_bound_regions(&value, |br| {\n-        let _ = start_or_continue(f, \"for<\", \", \");\n-        let br = match br {\n-            ty::BrNamed(_, name) => {\n-                let _ = write!(f, \"{}\", name);\n-                br\n-            }\n-            ty::BrAnon(_) |\n-            ty::BrFresh(_) |\n-            ty::BrEnv => {\n-                let name = Symbol::intern(\"'r\");\n-                let _ = write!(f, \"{}\", name);\n-                ty::BrNamed(tcx.hir.local_def_id(CRATE_NODE_ID),\n-                            name)\n-            }\n-        };\n-        tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1), br))\n-    }).0;\n+pub fn parameterized<F: fmt::Write>(f: &mut F,\n+                                    substs: &subst::Substs,\n+                                    did: DefId,\n+                                    projections: &[ty::ProjectionPredicate])\n+                                    -> fmt::Result {\n+    PrintContext::new().parameterized(f, substs, did, projections)\n+}\n \n-    start_or_continue(f, \"\", \"> \")?;\n-    write!(f, \"{}\", new_value)\n+\n+impl<'a, T: Print> Print for &'a T {\n+    fn print<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintContext) -> fmt::Result {\n+        (*self).print(f, cx)\n+    }\n }\n \n-impl<'tcx> fmt::Display for &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // Generate the main trait ref, including associated types.\n-        ty::tls::with(|tcx| {\n-            // Use a type that can't appear in defaults of type parameters.\n-            let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n-\n-            if let Some(p) = self.principal() {\n-                let principal = tcx.lift(&p).expect(\"could not lift TraitRef for printing\")\n-                    .with_self_ty(tcx, dummy_self);\n-                let projections = self.projection_bounds().map(|p| {\n-                    tcx.lift(&p)\n-                        .expect(\"could not lift projection for printing\")\n-                        .with_self_ty(tcx, dummy_self)\n-                }).collect::<Vec<_>>();\n-                parameterized(f, principal.substs, principal.def_id, &projections)?;\n-            }\n+define_print! {\n+    ('tcx) &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>, (self, f, cx) {\n+        display {\n+            // Generate the main trait ref, including associated types.\n+            ty::tls::with(|tcx| {\n+                // Use a type that can't appear in defaults of type parameters.\n+                let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n+\n+                if let Some(p) = self.principal() {\n+                    let principal = tcx.lift(&p).expect(\"could not lift TraitRef for printing\")\n+                        .with_self_ty(tcx, dummy_self);\n+                    let projections = self.projection_bounds().map(|p| {\n+                        tcx.lift(&p)\n+                            .expect(\"could not lift projection for printing\")\n+                            .with_self_ty(tcx, dummy_self)\n+                    }).collect::<Vec<_>>();\n+                    cx.parameterized(f, principal.substs, principal.def_id, &projections)?;\n+                }\n \n-            // Builtin bounds.\n-            for did in self.auto_traits() {\n-                write!(f, \" + {}\", tcx.item_path_str(did))?;\n-            }\n+                // Builtin bounds.\n+                for did in self.auto_traits() {\n+                    write!(f, \" + {}\", tcx.item_path_str(did))?;\n+                }\n \n-            Ok(())\n-        })?;\n+                Ok(())\n+            })?;\n \n-        Ok(())\n+            Ok(())\n+        }\n     }\n }\n \n@@ -357,42 +591,6 @@ impl fmt::Debug for ty::RegionParameterDef {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::TyS<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", *self)\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::TypeAndMut<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}{}\",\n-               if self.mutbl == hir::MutMutable { \"mut \" } else { \"\" },\n-               self.ty)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::TraitRef<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // when printing out the debug representation, we don't need\n-        // to enumerate the `for<...>` etc because the debruijn index\n-        // tells you everything you need to know.\n-        write!(f, \"<{:?} as {}>\", self.self_ty(), *self)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::ExistentialTraitRef<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| {\n-            let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n-\n-            let trait_ref = tcx.lift(&ty::Binder(*self))\n-                               .expect(\"could not lift TraitRef for printing\")\n-                               .with_self_ty(tcx, dummy_self).0;\n-            parameterized(f, trait_ref.substs, trait_ref.def_id, &[])\n-        })\n-    }\n-}\n-\n impl fmt::Debug for ty::TraitDef {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         ty::tls::with(|tcx| {\n@@ -409,196 +607,226 @@ impl fmt::Debug for ty::AdtDef {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::adjustment::Adjustment<'tcx> {\n+impl<'tcx> fmt::Debug for ty::ClosureUpvar<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{:?} -> {}\", self.kind, self.target)\n+        write!(f, \"ClosureUpvar({:?},{:?})\",\n+               self.def,\n+               self.ty)\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::Predicate<'tcx> {\n+impl fmt::Debug for ty::UpvarId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::Predicate::Trait(ref a) => write!(f, \"{:?}\", a),\n-            ty::Predicate::Equate(ref pair) => write!(f, \"{:?}\", pair),\n-            ty::Predicate::Subtype(ref pair) => write!(f, \"{:?}\", pair),\n-            ty::Predicate::RegionOutlives(ref pair) => write!(f, \"{:?}\", pair),\n-            ty::Predicate::TypeOutlives(ref pair) => write!(f, \"{:?}\", pair),\n-            ty::Predicate::Projection(ref pair) => write!(f, \"{:?}\", pair),\n-            ty::Predicate::WellFormed(ty) => write!(f, \"WF({:?})\", ty),\n-            ty::Predicate::ObjectSafe(trait_def_id) => {\n-                write!(f, \"ObjectSafe({:?})\", trait_def_id)\n-            }\n-            ty::Predicate::ClosureKind(closure_def_id, kind) => {\n-                write!(f, \"ClosureKind({:?}, {:?})\", closure_def_id, kind)\n-            }\n-            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n-            }\n-        }\n+        write!(f, \"UpvarId({:?};`{}`;{:?})\",\n+               self.var_id,\n+               ty::tls::with(|tcx| tcx.hir.name(tcx.hir.hir_to_node_id(self.var_id))),\n+               self.closure_expr_id)\n     }\n }\n \n-impl fmt::Display for ty::BoundRegion {\n+impl<'tcx> fmt::Debug for ty::UpvarBorrow<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if verbose() {\n-            return write!(f, \"{:?}\", *self);\n+        write!(f, \"UpvarBorrow({:?}, {:?})\",\n+               self.kind, self.region)\n+    }\n+}\n+\n+define_print! {\n+    ('tcx) ty::TypeAndMut<'tcx>, (self, f, cx) {\n+        display {\n+            print!(f, cx,\n+                   write(\"{}\", if self.mutbl == hir::MutMutable { \"mut \" } else { \"\" }),\n+                   print(self.ty))\n         }\n+    }\n+}\n \n-        match *self {\n-            BrNamed(_, name) => write!(f, \"{}\", name),\n-            BrAnon(_) | BrFresh(_) | BrEnv => Ok(())\n+define_print! {\n+    ('tcx) ty::ExistentialTraitRef<'tcx>, (self, f, cx) {\n+        debug {\n+            ty::tls::with(|tcx| {\n+                let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n+\n+                let trait_ref = tcx.lift(&ty::Binder(*self))\n+                                   .expect(\"could not lift TraitRef for printing\")\n+                                   .with_self_ty(tcx, dummy_self).0;\n+                cx.parameterized(f, trait_ref.substs, trait_ref.def_id, &[])\n+            })\n         }\n     }\n }\n \n-impl fmt::Debug for ty::BoundRegion {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            BrAnon(n) => write!(f, \"BrAnon({:?})\", n),\n-            BrFresh(n) => write!(f, \"BrFresh({:?})\", n),\n-            BrNamed(did, name) => {\n-                write!(f, \"BrNamed({:?}:{:?}, {:?})\",\n-                       did.krate, did.index, name)\n-            }\n-            BrEnv => \"BrEnv\".fmt(f),\n+define_print! {\n+    ('tcx) ty::adjustment::Adjustment<'tcx>, (self, f, cx) {\n+        debug {\n+            print!(f, cx, write(\"{:?} -> \", self.kind), print(self.target))\n         }\n     }\n }\n \n-impl fmt::Debug for ty::RegionKind {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::ReEarlyBound(ref data) => {\n-                write!(f, \"ReEarlyBound({}, {})\",\n-                       data.index,\n-                       data.name)\n+define_print! {\n+    () ty::BoundRegion, (self, f, cx) {\n+        display {\n+            if cx.is_verbose {\n+                return self.print_debug(f, cx);\n             }\n \n-            ty::ReLateBound(binder_id, ref bound_region) => {\n-                write!(f, \"ReLateBound({:?}, {:?})\",\n-                       binder_id,\n-                       bound_region)\n+            match *self {\n+                BrNamed(_, name) => write!(f, \"{}\", name),\n+                BrAnon(_) | BrFresh(_) | BrEnv => Ok(())\n             }\n+        }\n+        debug {\n+            return match *self {\n+                BrAnon(n) => write!(f, \"BrAnon({:?})\", n),\n+                BrFresh(n) => write!(f, \"BrFresh({:?})\", n),\n+                BrNamed(did, name) => {\n+                    write!(f, \"BrNamed({:?}:{:?}, {:?})\",\n+                           did.krate, did.index, name)\n+                }\n+                BrEnv => write!(f, \"BrEnv\"),\n+            };\n+        }\n+    }\n+}\n \n-            ty::ReFree(ref fr) => write!(f, \"{:?}\", fr),\n-\n-            ty::ReScope(id) => {\n-                write!(f, \"ReScope({:?})\", id)\n+define_print! {\n+    () ty::RegionKind, (self, f, cx) {\n+        display {\n+            if cx.is_verbose {\n+                return self.print_debug(f, cx);\n             }\n \n-            ty::ReStatic => write!(f, \"ReStatic\"),\n-\n-            ty::ReVar(ref vid) => {\n-                write!(f, \"{:?}\", vid)\n+            // These printouts are concise.  They do not contain all the information\n+            // the user might want to diagnose an error, but there is basically no way\n+            // to fit that into a short string.  Hence the recommendation to use\n+            // `explain_region()` or `note_and_explain_region()`.\n+            match *self {\n+                ty::ReEarlyBound(ref data) => {\n+                    write!(f, \"{}\", data.name)\n+                }\n+                ty::ReLateBound(_, br) |\n+                ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n+                ty::ReSkolemized(_, br) => {\n+                    write!(f, \"{}\", br)\n+                }\n+                ty::ReScope(scope) if cx.identify_regions => {\n+                    match scope.data() {\n+                        region::ScopeData::Node(id) =>\n+                            write!(f, \"'{}s\", id.as_usize()),\n+                        region::ScopeData::CallSite(id) =>\n+                            write!(f, \"'{}cs\", id.as_usize()),\n+                        region::ScopeData::Arguments(id) =>\n+                            write!(f, \"'{}as\", id.as_usize()),\n+                        region::ScopeData::Destruction(id) =>\n+                            write!(f, \"'{}ds\", id.as_usize()),\n+                        region::ScopeData::Remainder(BlockRemainder\n+                                                     { block, first_statement_index }) =>\n+                            write!(f, \"'{}_{}rs\", block.as_usize(), first_statement_index.index()),\n+                    }\n+                }\n+                ty::ReVar(region_vid) if cx.identify_regions => {\n+                    write!(f, \"'{}rv\", region_vid.index)\n+                }\n+                ty::ReScope(_) |\n+                ty::ReVar(_) |\n+                ty::ReErased => Ok(()),\n+                ty::ReStatic => write!(f, \"'static\"),\n+                ty::ReEmpty => write!(f, \"'<empty>\"),\n             }\n+        }\n+        debug {\n+            match *self {\n+                ty::ReEarlyBound(ref data) => {\n+                    write!(f, \"ReEarlyBound({}, {})\",\n+                           data.index,\n+                           data.name)\n+                }\n \n-            ty::ReSkolemized(id, ref bound_region) => {\n-                write!(f, \"ReSkolemized({}, {:?})\", id.index, bound_region)\n-            }\n+                ty::ReLateBound(binder_id, ref bound_region) => {\n+                    write!(f, \"ReLateBound({:?}, {:?})\",\n+                           binder_id,\n+                           bound_region)\n+                }\n \n-            ty::ReEmpty => write!(f, \"ReEmpty\"),\n+                ty::ReFree(ref fr) => write!(f, \"{:?}\", fr),\n \n-            ty::ReErased => write!(f, \"ReErased\")\n-        }\n-    }\n-}\n+                ty::ReScope(id) => {\n+                    write!(f, \"ReScope({:?})\", id)\n+                }\n \n-impl<'tcx> fmt::Debug for ty::ClosureUpvar<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"ClosureUpvar({:?},{:?})\",\n-               self.def,\n-               self.ty)\n-    }\n-}\n+                ty::ReStatic => write!(f, \"ReStatic\"),\n \n-impl fmt::Display for ty::RegionKind {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if verbose() {\n-            return write!(f, \"{:?}\", *self);\n-        }\n+                ty::ReVar(ref vid) => {\n+                    write!(f, \"{:?}\", vid)\n+                }\n \n-        // These printouts are concise.  They do not contain all the information\n-        // the user might want to diagnose an error, but there is basically no way\n-        // to fit that into a short string.  Hence the recommendation to use\n-        // `explain_region()` or `note_and_explain_region()`.\n-        match *self {\n-            ty::ReEarlyBound(ref data) => {\n-                write!(f, \"{}\", data.name)\n-            }\n-            ty::ReLateBound(_, br) |\n-            ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n-            ty::ReSkolemized(_, br) => {\n-                write!(f, \"{}\", br)\n-            }\n-            ty::ReScope(scope) if identify_regions() => {\n-                match scope.data() {\n-                    region::ScopeData::Node(id) =>\n-                        write!(f, \"'{}s\", id.as_usize()),\n-                    region::ScopeData::CallSite(id) =>\n-                        write!(f, \"'{}cs\", id.as_usize()),\n-                    region::ScopeData::Arguments(id) =>\n-                        write!(f, \"'{}as\", id.as_usize()),\n-                    region::ScopeData::Destruction(id) =>\n-                        write!(f, \"'{}ds\", id.as_usize()),\n-                    region::ScopeData::Remainder(BlockRemainder { block, first_statement_index }) =>\n-                        write!(f, \"'{}_{}rs\", block.as_usize(), first_statement_index.index()),\n+                ty::ReSkolemized(id, ref bound_region) => {\n+                    write!(f, \"ReSkolemized({}, {:?})\", id.index, bound_region)\n                 }\n+\n+                ty::ReEmpty => write!(f, \"ReEmpty\"),\n+\n+                ty::ReErased => write!(f, \"ReErased\")\n             }\n-            ty::ReVar(region_vid) if identify_regions() => {\n-                write!(f, \"'{}rv\", region_vid.index)\n-            }\n-            ty::ReScope(_) |\n-            ty::ReVar(_) |\n-            ty::ReErased => Ok(()),\n-            ty::ReStatic => write!(f, \"'static\"),\n-            ty::ReEmpty => write!(f, \"'<empty>\"),\n         }\n     }\n }\n \n-impl fmt::Debug for ty::FreeRegion {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"ReFree({:?}, {:?})\",\n-               self.scope, self.bound_region)\n+define_print! {\n+    () ty::FreeRegion, (self, f, cx) {\n+        debug {\n+            write!(f, \"ReFree({:?}, {:?})\", self.scope, self.bound_region)\n+        }\n     }\n }\n \n-impl fmt::Debug for ty::Variance {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(match *self {\n-            ty::Covariant => \"+\",\n-            ty::Contravariant => \"-\",\n-            ty::Invariant => \"o\",\n-            ty::Bivariant => \"*\",\n-        })\n+define_print! {\n+    () ty::Variance, (self, f, cx) {\n+        debug {\n+            f.write_str(match *self {\n+                ty::Covariant => \"+\",\n+                ty::Contravariant => \"-\",\n+                ty::Invariant => \"o\",\n+                ty::Bivariant => \"*\",\n+            })\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::GenericPredicates<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"GenericPredicates({:?})\", self.predicates)\n+define_print! {\n+    ('tcx) ty::GenericPredicates<'tcx>, (self, f, cx) {\n+        debug {\n+            write!(f, \"GenericPredicates({:?})\", self.predicates)\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::InstantiatedPredicates<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"InstantiatedPredicates({:?})\",\n-               self.predicates)\n+define_print! {\n+    ('tcx) ty::InstantiatedPredicates<'tcx>, (self, f, cx) {\n+        debug {\n+            write!(f, \"InstantiatedPredicates({:?})\", self.predicates)\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::FnSig<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if self.unsafety == hir::Unsafety::Unsafe {\n-            write!(f, \"unsafe \")?;\n-        }\n+define_print! {\n+    ('tcx) ty::FnSig<'tcx>, (self, f, cx) {\n+        display {\n+            if self.unsafety == hir::Unsafety::Unsafe {\n+                write!(f, \"unsafe \")?;\n+            }\n \n-        if self.abi != Abi::Rust {\n-            write!(f, \"extern {} \", self.abi)?;\n-        }\n+            if self.abi != Abi::Rust {\n+                write!(f, \"extern {} \", self.abi)?;\n+            }\n \n-        write!(f, \"fn\")?;\n-        fn_sig(f, self.inputs(), self.variadic, self.output())\n+            write!(f, \"fn\")?;\n+            cx.fn_sig(f, self.inputs(), self.variadic, self.output())\n+        }\n+        debug {\n+            write!(f, \"({:?}; variadic: {})->{:?}\", self.inputs(), self.variadic, self.output())\n+        }\n     }\n }\n \n@@ -626,21 +854,27 @@ impl fmt::Debug for ty::RegionVid {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::FnSig<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"({:?}; variadic: {})->{:?}\", self.inputs(), self.variadic, self.output())\n-    }\n-}\n-\n-impl fmt::Debug for ty::InferTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::TyVar(ref v) => v.fmt(f),\n-            ty::IntVar(ref v) => v.fmt(f),\n-            ty::FloatVar(ref v) => v.fmt(f),\n-            ty::FreshTy(v) => write!(f, \"FreshTy({:?})\", v),\n-            ty::FreshIntTy(v) => write!(f, \"FreshIntTy({:?})\", v),\n-            ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({:?})\", v)\n+define_print! {\n+    () ty::InferTy, (self, f, cx) {\n+        display {\n+            match *self {\n+                ty::TyVar(_) => write!(f, \"_\"),\n+                ty::IntVar(_) => write!(f, \"{}\", \"{integer}\"),\n+                ty::FloatVar(_) => write!(f, \"{}\", \"{float}\"),\n+                ty::FreshTy(v) => write!(f, \"FreshTy({})\", v),\n+                ty::FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n+                ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({})\", v)\n+            }\n+        }\n+        debug {\n+            match *self {\n+                ty::TyVar(ref v) => write!(f, \"{:?}\", v),\n+                ty::IntVar(ref v) => write!(f, \"{:?}\", v),\n+                ty::FloatVar(ref v) => write!(f, \"{:?}\", v),\n+                ty::FreshTy(v) => write!(f, \"FreshTy({:?})\", v),\n+                ty::FreshIntTy(v) => write!(f, \"FreshIntTy({:?})\", v),\n+                ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({:?})\", v)\n+            }\n         }\n     }\n }\n@@ -665,406 +899,393 @@ impl fmt::Debug for ty::IntVarValue {\n     }\n }*/\n \n-impl<'tcx> fmt::Display for ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::TraitRef<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::FnSig<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::TraitPredicate<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::EquatePredicate<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::SubtypePredicate<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::ProjectionPredicate<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::OutlivesPredicate<ty::Region<'tcx>,\n-                                                             ty::Region<'tcx>>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n+define_print_multi! {\n+    [\n+    ('tcx) ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>,\n+    ('tcx) ty::Binder<ty::TraitRef<'tcx>>,\n+    ('tcx) ty::Binder<ty::FnSig<'tcx>>,\n+    ('tcx) ty::Binder<ty::TraitPredicate<'tcx>>,\n+    ('tcx) ty::Binder<ty::EquatePredicate<'tcx>>,\n+    ('tcx) ty::Binder<ty::SubtypePredicate<'tcx>>,\n+    ('tcx) ty::Binder<ty::ProjectionPredicate<'tcx>>,\n+    ('tcx) ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>,\n+    ('tcx) ty::Binder<ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>>\n+    ]\n+    (self, f, cx) {\n+        display {\n+            ty::tls::with(|tcx| cx.in_binder(f, tcx, self, tcx.lift(self)))\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::TraitRef<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        parameterized(f, self.substs, self.def_id, &[])\n+define_print! {\n+    ('tcx) ty::TraitRef<'tcx>, (self, f, cx) {\n+        display {\n+            cx.parameterized(f, self.substs, self.def_id, &[])\n+        }\n+        debug {\n+            // when printing out the debug representation, we don't need\n+            // to enumerate the `for<...>` etc because the debruijn index\n+            // tells you everything you need to know.\n+            print!(f, cx,\n+                   write(\"<\"),\n+                   print(self.self_ty()),\n+                   write(\" as \"))?;\n+            cx.parameterized(f, self.substs, self.def_id, &[])?;\n+            write!(f, \">\")\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::GeneratorInterior<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.witness.fmt(f)\n+define_print! {\n+    ('tcx) ty::GeneratorInterior<'tcx>, (self, f, cx) {\n+        display {\n+            self.witness.print(f, cx)\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            TyBool => write!(f, \"bool\"),\n-            TyChar => write!(f, \"char\"),\n-            TyInt(t) => write!(f, \"{}\", t.ty_to_string()),\n-            TyUint(t) => write!(f, \"{}\", t.ty_to_string()),\n-            TyFloat(t) => write!(f, \"{}\", t.ty_to_string()),\n-            TyRawPtr(ref tm) => {\n-                write!(f, \"*{} {}\", match tm.mutbl {\n-                    hir::MutMutable => \"mut\",\n-                    hir::MutImmutable => \"const\",\n-                },  tm.ty)\n-            }\n-            TyRef(r, ref tm) => {\n-                write!(f, \"&\")?;\n-                let s = r.to_string();\n-                write!(f, \"{}\", s)?;\n-                if !s.is_empty() {\n-                    write!(f, \" \")?;\n+define_print! {\n+    ('tcx) ty::TypeVariants<'tcx>, (self, f, cx) {\n+        display {\n+            match *self {\n+                TyBool => write!(f, \"bool\"),\n+                TyChar => write!(f, \"char\"),\n+                TyInt(t) => write!(f, \"{}\", t.ty_to_string()),\n+                TyUint(t) => write!(f, \"{}\", t.ty_to_string()),\n+                TyFloat(t) => write!(f, \"{}\", t.ty_to_string()),\n+                TyRawPtr(ref tm) => {\n+                    write!(f, \"*{} \", match tm.mutbl {\n+                        hir::MutMutable => \"mut\",\n+                        hir::MutImmutable => \"const\",\n+                    })?;\n+                    tm.ty.print(f, cx)\n                 }\n-                write!(f, \"{}\", tm)\n-            }\n-            TyNever => write!(f, \"!\"),\n-            TyTuple(ref tys, _) => {\n-                write!(f, \"(\")?;\n-                let mut tys = tys.iter();\n-                if let Some(&ty) = tys.next() {\n-                    write!(f, \"{},\", ty)?;\n+                TyRef(r, ref tm) => {\n+                    write!(f, \"&\")?;\n+                    let s = r.print_to_string(cx);\n+                    write!(f, \"{}\", s)?;\n+                    if !s.is_empty() {\n+                        write!(f, \" \")?;\n+                    }\n+                    tm.print(f, cx)\n+                }\n+                TyNever => write!(f, \"!\"),\n+                TyTuple(ref tys, _) => {\n+                    write!(f, \"(\")?;\n+                    let mut tys = tys.iter();\n                     if let Some(&ty) = tys.next() {\n-                        write!(f, \" {}\", ty)?;\n-                        for &ty in tys {\n-                            write!(f, \", {}\", ty)?;\n+                        print!(f, cx, print(ty), write(\",\"))?;\n+                        if let Some(&ty) = tys.next() {\n+                            print!(f, cx, write(\" \"), print(ty))?;\n+                            for &ty in tys {\n+                                print!(f, cx, write(\", \"), print(ty))?;\n+                            }\n                         }\n                     }\n+                    write!(f, \")\")\n                 }\n-                write!(f, \")\")\n-            }\n-            TyFnDef(def_id, substs) => {\n-                ty::tls::with(|tcx| {\n-                    let mut sig = tcx.fn_sig(def_id);\n-                    if let Some(substs) = tcx.lift(&substs) {\n-                        sig = sig.subst(tcx, substs);\n+                TyFnDef(def_id, substs) => {\n+                    ty::tls::with(|tcx| {\n+                        let mut sig = tcx.fn_sig(def_id);\n+                        if let Some(substs) = tcx.lift(&substs) {\n+                            sig = sig.subst(tcx, substs);\n+                        }\n+                        print!(f, cx, print(sig), write(\" {{\"))\n+                    })?;\n+                    cx.parameterized(f, substs, def_id, &[])?;\n+                    write!(f, \"}}\")\n+                }\n+                TyFnPtr(ref bare_fn) => {\n+                    bare_fn.print(f, cx)\n+                }\n+                TyInfer(infer_ty) => write!(f, \"{}\", infer_ty),\n+                TyError => write!(f, \"[type error]\"),\n+                TyParam(ref param_ty) => write!(f, \"{}\", param_ty),\n+                TyAdt(def, substs) => cx.parameterized(f, substs, def.did, &[]),\n+                TyDynamic(data, r) => {\n+                    data.print(f, cx)?;\n+                    let r = r.print_to_string(cx);\n+                    if !r.is_empty() {\n+                        write!(f, \" + {}\", r)\n+                    } else {\n+                        Ok(())\n                     }\n-                    write!(f, \"{} {{\", sig.0)\n-                })?;\n-                parameterized(f, substs, def_id, &[])?;\n-                write!(f, \"}}\")\n-            }\n-            TyFnPtr(ref bare_fn) => {\n-                write!(f, \"{}\", bare_fn.0)\n-            }\n-            TyInfer(infer_ty) => write!(f, \"{}\", infer_ty),\n-            TyError => write!(f, \"[type error]\"),\n-            TyParam(ref param_ty) => write!(f, \"{}\", param_ty),\n-            TyAdt(def, substs) => parameterized(f, substs, def.did, &[]),\n-            TyDynamic(data, r) => {\n-                write!(f, \"{}\", data)?;\n-                let r = r.to_string();\n-                if !r.is_empty() {\n-                    write!(f, \" + {}\", r)\n-                } else {\n-                    Ok(())\n                 }\n-            }\n-            TyProjection(ref data) => write!(f, \"{}\", data),\n-            TyAnon(def_id, substs) => {\n-                ty::tls::with(|tcx| {\n-                    // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n-                    // by looking up the projections associated with the def_id.\n-                    let predicates_of = tcx.predicates_of(def_id);\n-                    let substs = tcx.lift(&substs).unwrap_or_else(|| {\n-                        tcx.intern_substs(&[])\n-                    });\n-                    let bounds = predicates_of.instantiate(tcx, substs);\n-\n-                    let mut first = true;\n-                    let mut is_sized = false;\n-                    write!(f, \"impl\")?;\n-                    for predicate in bounds.predicates {\n-                        if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n-                            // Don't print +Sized, but rather +?Sized if absent.\n-                            if Some(trait_ref.def_id()) == tcx.lang_items().sized_trait() {\n-                                is_sized = true;\n-                                continue;\n+                TyProjection(ref data) => data.print(f, cx),\n+                TyAnon(def_id, substs) => {\n+                    ty::tls::with(|tcx| {\n+                        // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n+                        // by looking up the projections associated with the def_id.\n+                        let predicates_of = tcx.predicates_of(def_id);\n+                        let substs = tcx.lift(&substs).unwrap_or_else(|| {\n+                            tcx.intern_substs(&[])\n+                        });\n+                        let bounds = predicates_of.instantiate(tcx, substs);\n+\n+                        let mut first = true;\n+                        let mut is_sized = false;\n+                        write!(f, \"impl\")?;\n+                        for predicate in bounds.predicates {\n+                            if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n+                                // Don't print +Sized, but rather +?Sized if absent.\n+                                if Some(trait_ref.def_id()) == tcx.lang_items().sized_trait() {\n+                                    is_sized = true;\n+                                    continue;\n+                                }\n+\n+                                print!(f, cx,\n+                                       write(\"{}\", if first { \" \" } else { \"+\" }),\n+                                       print(trait_ref))?;\n+                                first = false;\n                             }\n-\n-                            write!(f, \"{}{}\", if first { \" \" } else { \"+\" }, trait_ref)?;\n-                            first = false;\n                         }\n-                    }\n-                    if !is_sized {\n-                        write!(f, \"{}?Sized\", if first { \" \" } else { \"+\" })?;\n-                    }\n-                    Ok(())\n-                })\n-            }\n-            TyStr => write!(f, \"str\"),\n-            TyGenerator(did, substs, interior) => ty::tls::with(|tcx| {\n-                let upvar_tys = substs.upvar_tys(did, tcx);\n-                write!(f, \"[generator\")?;\n-\n-                if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n-                    write!(f, \"@{:?}\", tcx.hir.span(node_id))?;\n-                    let mut sep = \" \";\n-                    tcx.with_freevars(node_id, |freevars| {\n-                        for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n-                            write!(f,\n-                                        \"{}{}:{}\",\n-                                        sep,\n-                                        tcx.hir.name(freevar.var_id()),\n-                                        upvar_ty)?;\n-                            sep = \", \";\n+                        if !is_sized {\n+                            write!(f, \"{}?Sized\", if first { \" \" } else { \"+\" })?;\n                         }\n                         Ok(())\n-                    })?\n-                } else {\n-                    // cross-crate closure types should only be\n-                    // visible in trans bug reports, I imagine.\n-                    write!(f, \"@{:?}\", did)?;\n-                    let mut sep = \" \";\n-                    for (index, upvar_ty) in upvar_tys.enumerate() {\n-                        write!(f, \"{}{}:{}\", sep, index, upvar_ty)?;\n-                        sep = \", \";\n-                    }\n+                    })\n                 }\n+                TyStr => write!(f, \"str\"),\n+                TyGenerator(did, substs, interior) => ty::tls::with(|tcx| {\n+                    let upvar_tys = substs.upvar_tys(did, tcx);\n+                    write!(f, \"[generator\")?;\n \n-                write!(f, \" {}\", interior)?;\n-\n-                write!(f, \"]\")\n-            }),\n-            TyClosure(did, substs) => ty::tls::with(|tcx| {\n-                let upvar_tys = substs.upvar_tys(did, tcx);\n-                write!(f, \"[closure\")?;\n-\n-                if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n-                    if tcx.sess.opts.debugging_opts.span_free_formats {\n-                        write!(f, \"@{:?}\", node_id)?;\n-                    } else {\n+                    if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n                         write!(f, \"@{:?}\", tcx.hir.span(node_id))?;\n-                    }\n-                    let mut sep = \" \";\n-                    tcx.with_freevars(node_id, |freevars| {\n-                        for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n-                            write!(f,\n-                                        \"{}{}:{}\",\n-                                        sep,\n-                                        tcx.hir.name(freevar.var_id()),\n-                                        upvar_ty)?;\n+                        let mut sep = \" \";\n+                        tcx.with_freevars(node_id, |freevars| {\n+                            for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n+                                print!(f, cx,\n+                                       write(\"{}{}:\",\n+                                             sep,\n+                                             tcx.hir.name(freevar.var_id())),\n+                                       print(upvar_ty))?;\n+                                sep = \", \";\n+                            }\n+                            Ok(())\n+                        })?\n+                    } else {\n+                        // cross-crate closure types should only be\n+                        // visible in trans bug reports, I imagine.\n+                        write!(f, \"@{:?}\", did)?;\n+                        let mut sep = \" \";\n+                        for (index, upvar_ty) in upvar_tys.enumerate() {\n+                            print!(f, cx,\n+                                   write(\"{}{}:\", sep, index),\n+                                   print(upvar_ty))?;\n                             sep = \", \";\n                         }\n-                        Ok(())\n-                    })?\n-                } else {\n-                    // cross-crate closure types should only be\n-                    // visible in trans bug reports, I imagine.\n-                    write!(f, \"@{:?}\", did)?;\n-                    let mut sep = \" \";\n-                    for (index, upvar_ty) in upvar_tys.enumerate() {\n-                        write!(f, \"{}{}:{}\", sep, index, upvar_ty)?;\n-                        sep = \", \";\n                     }\n-                }\n \n-                write!(f, \"]\")\n-            }),\n-            TyArray(ty, sz) => {\n-                write!(f, \"[{}; \", ty)?;\n-                match sz.val {\n-                    ConstVal::Integral(ConstInt::Usize(sz)) => {\n-                        write!(f, \"{}\", sz)?;\n-                    }\n-                    ConstVal::Unevaluated(_def_id, substs) => {\n-                        write!(f, \"<unevaluated{:?}>\", &substs[..])?;\n+                    print!(f, cx, write(\" \"), print(interior), write(\"]\"))\n+                }),\n+                TyClosure(did, substs) => ty::tls::with(|tcx| {\n+                    let upvar_tys = substs.upvar_tys(did, tcx);\n+                    write!(f, \"[closure\")?;\n+\n+                    if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n+                        if tcx.sess.opts.debugging_opts.span_free_formats {\n+                            write!(f, \"@{:?}\", node_id)?;\n+                        } else {\n+                            write!(f, \"@{:?}\", tcx.hir.span(node_id))?;\n+                        }\n+                        let mut sep = \" \";\n+                        tcx.with_freevars(node_id, |freevars| {\n+                            for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n+                                print!(f, cx,\n+                                       write(\"{}{}:\",\n+                                             sep,\n+                                             tcx.hir.name(freevar.var_id())),\n+                                       print(upvar_ty))?;\n+                                sep = \", \";\n+                            }\n+                            Ok(())\n+                        })?\n+                    } else {\n+                        // cross-crate closure types should only be\n+                        // visible in trans bug reports, I imagine.\n+                        write!(f, \"@{:?}\", did)?;\n+                        let mut sep = \" \";\n+                        for (index, upvar_ty) in upvar_tys.enumerate() {\n+                            print!(f, cx,\n+                                   write(\"{}{}:\", sep, index),\n+                                   print(upvar_ty))?;\n+                            sep = \", \";\n+                        }\n                     }\n-                    _ => {\n-                        write!(f, \"{:?}\", sz)?;\n+\n+                    write!(f, \"]\")\n+                }),\n+                TyArray(ty, sz) => {\n+                    print!(f, cx, write(\"[\"), print(ty), write(\"; \"))?;\n+                    match sz.val {\n+                        ConstVal::Integral(ConstInt::Usize(sz)) => {\n+                            write!(f, \"{}\", sz)?;\n+                        }\n+                        ConstVal::Unevaluated(_def_id, substs) => {\n+                            write!(f, \"<unevaluated{:?}>\", &substs[..])?;\n+                        }\n+                        _ => {\n+                            write!(f, \"{:?}\", sz)?;\n+                        }\n                     }\n+                    write!(f, \"]\")\n+                }\n+                TySlice(ty) => {\n+                    print!(f, cx, write(\"[\"), print(ty), write(\"]\"))\n                 }\n-                write!(f, \"]\")\n             }\n-            TySlice(ty) => write!(f, \"[{}]\",  ty)\n         }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::TyS<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.sty)\n-    }\n-}\n-\n-impl fmt::Debug for ty::UpvarId {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"UpvarId({:?};`{}`;{:?})\",\n-               self.var_id,\n-               ty::tls::with(|tcx| tcx.hir.name(tcx.hir.hir_to_node_id(self.var_id))),\n-               self.closure_expr_id)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::UpvarBorrow<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"UpvarBorrow({:?}, {:?})\",\n-               self.kind, self.region)\n-    }\n-}\n-\n-impl fmt::Display for ty::InferTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let print_var_ids = verbose();\n-        match *self {\n-            ty::TyVar(ref vid) if print_var_ids => write!(f, \"{:?}\", vid),\n-            ty::IntVar(ref vid) if print_var_ids => write!(f, \"{:?}\", vid),\n-            ty::FloatVar(ref vid) if print_var_ids => write!(f, \"{:?}\", vid),\n-            ty::TyVar(_) => write!(f, \"_\"),\n-            ty::IntVar(_) => write!(f, \"{}\", \"{integer}\"),\n-            ty::FloatVar(_) => write!(f, \"{}\", \"{float}\"),\n-            ty::FreshTy(v) => write!(f, \"FreshTy({})\", v),\n-            ty::FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n-            ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({})\", v)\n+define_print! {\n+    ('tcx) ty::TyS<'tcx>, (self, f, cx) {\n+        display {\n+            self.sty.print(f, cx)\n+        }\n+        debug {\n+            self.sty.print_display(f, cx)\n         }\n     }\n }\n \n-impl fmt::Display for ty::ParamTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.name)\n-    }\n-}\n-\n-impl fmt::Debug for ty::ParamTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}/#{}\", self, self.idx)\n-    }\n-}\n-\n-impl<'tcx, T, U> fmt::Display for ty::OutlivesPredicate<T,U>\n-    where T: fmt::Display, U: fmt::Display\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{} : {}\", self.0, self.1)\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::EquatePredicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{} == {}\", self.0, self.1)\n+define_print! {\n+    () ty::ParamTy, (self, f, cx) {\n+        display {\n+            write!(f, \"{}\", self.name)\n+        }\n+        debug {\n+            write!(f, \"{}/#{}\", self.name, self.idx)\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::SubtypePredicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{} <: {}\", self.a, self.b)\n+define_print! {\n+    ('tcx, T: Print + fmt::Debug, U: Print + fmt::Debug) ty::OutlivesPredicate<T, U>,\n+    (self, f, cx) {\n+        display {\n+            print!(f, cx, print(self.0), write(\" : \"), print(self.1))\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::TraitPredicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"TraitPredicate({:?})\",\n-               self.trait_ref)\n+define_print! {\n+    ('tcx) ty::EquatePredicate<'tcx>, (self, f, cx) {\n+        display {\n+            print!(f, cx, print(self.0), write(\" == \"), print(self.1))\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::TraitPredicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}: {}\", self.trait_ref.self_ty(), self.trait_ref)\n+define_print! {\n+    ('tcx) ty::SubtypePredicate<'tcx>, (self, f, cx) {\n+        display {\n+            print!(f, cx, print(self.a), write(\" <: \"), print(self.b))\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::ProjectionPredicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"ProjectionPredicate({:?}, {:?})\",\n-               self.projection_ty,\n-               self.ty)\n+define_print! {\n+    ('tcx) ty::TraitPredicate<'tcx>, (self, f, cx) {\n+        debug {\n+            write!(f, \"TraitPredicate({:?})\",\n+                   self.trait_ref)\n+        }\n+        display {\n+            print!(f, cx, print(self.trait_ref.self_ty()), write(\": \"), print(self.trait_ref))\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::ProjectionPredicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{} == {}\",\n-               self.projection_ty,\n-               self.ty)\n+define_print! {\n+    ('tcx) ty::ProjectionPredicate<'tcx>, (self, f, cx) {\n+        debug {\n+            print!(f, cx,\n+                   write(\"ProjectionPredicate(\"),\n+                   print(self.projection_ty),\n+                   write(\", \"),\n+                   print(self.ty),\n+                   write(\")\"))\n+        }\n+        display {\n+            print!(f, cx, print(self.projection_ty), write(\" == \"), print(self.ty))\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::ProjectionTy<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // FIXME(tschottdorf): use something like\n-        //   parameterized(f, self.substs, self.item_def_id, &[])\n-        // (which currently ICEs).\n-        let (trait_ref, item_name) = ty::tls::with(|tcx|\n-            (self.trait_ref(tcx), tcx.associated_item(self.item_def_id).name)\n-        );\n-        write!(f, \"{:?}::{}\",\n-               trait_ref,\n-               item_name)\n+define_print! {\n+    ('tcx) ty::ProjectionTy<'tcx>, (self, f, cx) {\n+        display {\n+            // FIXME(tschottdorf): use something like\n+            //   parameterized(f, self.substs, self.item_def_id, &[])\n+            // (which currently ICEs).\n+            let (trait_ref, item_name) = ty::tls::with(|tcx|\n+                (self.trait_ref(tcx), tcx.associated_item(self.item_def_id).name)\n+            );\n+            print!(f, cx, print_debug(trait_ref), write(\"::{}\", item_name))\n+        }\n     }\n }\n \n-impl fmt::Display for ty::ClosureKind {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::ClosureKind::Fn => write!(f, \"Fn\"),\n-            ty::ClosureKind::FnMut => write!(f, \"FnMut\"),\n-            ty::ClosureKind::FnOnce => write!(f, \"FnOnce\"),\n+define_print! {\n+    () ty::ClosureKind, (self, f, cx) {\n+        display {\n+            match *self {\n+                ty::ClosureKind::Fn => write!(f, \"Fn\"),\n+                ty::ClosureKind::FnMut => write!(f, \"FnMut\"),\n+                ty::ClosureKind::FnOnce => write!(f, \"FnOnce\"),\n+            }\n         }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::Predicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::Predicate::Trait(ref data) => write!(f, \"{}\", data),\n-            ty::Predicate::Equate(ref predicate) => write!(f, \"{}\", predicate),\n-            ty::Predicate::Subtype(ref predicate) => write!(f, \"{}\", predicate),\n-            ty::Predicate::RegionOutlives(ref predicate) => write!(f, \"{}\", predicate),\n-            ty::Predicate::TypeOutlives(ref predicate) => write!(f, \"{}\", predicate),\n-            ty::Predicate::Projection(ref predicate) => write!(f, \"{}\", predicate),\n-            ty::Predicate::WellFormed(ty) => write!(f, \"{} well-formed\", ty),\n-            ty::Predicate::ObjectSafe(trait_def_id) =>\n-                ty::tls::with(|tcx| {\n-                    write!(f, \"the trait `{}` is object-safe\", tcx.item_path_str(trait_def_id))\n-                }),\n-            ty::Predicate::ClosureKind(closure_def_id, kind) =>\n-                ty::tls::with(|tcx| {\n-                    write!(f, \"the closure `{}` implements the trait `{}`\",\n-                           tcx.item_path_str(closure_def_id), kind)\n-                }),\n-            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                write!(f, \"the constant `\")?;\n-                parameterized(f, substs, def_id, &[])?;\n-                write!(f, \"` can be evaluated\")\n+define_print! {\n+    ('tcx) ty::Predicate<'tcx>, (self, f, cx) {\n+        display {\n+            match *self {\n+                ty::Predicate::Trait(ref data) => data.print(f, cx),\n+                ty::Predicate::Equate(ref predicate) => predicate.print(f, cx),\n+                ty::Predicate::Subtype(ref predicate) => predicate.print(f, cx),\n+                ty::Predicate::RegionOutlives(ref predicate) => predicate.print(f, cx),\n+                ty::Predicate::TypeOutlives(ref predicate) => predicate.print(f, cx),\n+                ty::Predicate::Projection(ref predicate) => predicate.print(f, cx),\n+                ty::Predicate::WellFormed(ty) => print!(f, cx, print(ty), write(\" well-formed\")),\n+                ty::Predicate::ObjectSafe(trait_def_id) =>\n+                    ty::tls::with(|tcx| {\n+                        write!(f, \"the trait `{}` is object-safe\", tcx.item_path_str(trait_def_id))\n+                    }),\n+                ty::Predicate::ClosureKind(closure_def_id, kind) =>\n+                    ty::tls::with(|tcx| {\n+                        write!(f, \"the closure `{}` implements the trait `{}`\",\n+                               tcx.item_path_str(closure_def_id), kind)\n+                    }),\n+                ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+                    write!(f, \"the constant `\")?;\n+                    cx.parameterized(f, substs, def_id, &[])?;\n+                    write!(f, \"` can be evaluated\")\n+                }\n+            }\n+        }\n+        debug {\n+            match *self {\n+                ty::Predicate::Trait(ref a) => a.print(f, cx),\n+                ty::Predicate::Equate(ref pair) => pair.print(f, cx),\n+                ty::Predicate::Subtype(ref pair) => pair.print(f, cx),\n+                ty::Predicate::RegionOutlives(ref pair) => pair.print(f, cx),\n+                ty::Predicate::TypeOutlives(ref pair) => pair.print(f, cx),\n+                ty::Predicate::Projection(ref pair) => pair.print(f, cx),\n+                ty::Predicate::WellFormed(ty) => ty.print(f, cx),\n+                ty::Predicate::ObjectSafe(trait_def_id) => {\n+                    write!(f, \"ObjectSafe({:?})\", trait_def_id)\n+                }\n+                ty::Predicate::ClosureKind(closure_def_id, kind) => {\n+                    write!(f, \"ClosureKind({:?}, {:?})\", closure_def_id, kind)\n+                }\n+                ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+                    write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n+                }\n             }\n         }\n     }"}, {"sha": "6f6fde1e9e7786155aad5f994a3b14b220f4b469", "filename": "src/librustc_back/build.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_back%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_back%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fbuild.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -11,5 +11,4 @@\n fn main() {\n     println!(\"cargo:rerun-if-changed=build.rs\");\n     println!(\"cargo:rerun-if-env-changed=CFG_DEFAULT_LINKER\");\n-    println!(\"cargo:rerun-if-env-changed=CFG_DEFAULT_AR\");\n }"}, {"sha": "a54627279b02c2a4a7179057e3ceae05dc88324b", "filename": "src/librustc_back/target/asmjs_unknown_emscripten.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -20,7 +20,6 @@ pub fn target() -> Result<Target, String> {\n \n     let opts = TargetOptions {\n         linker: cmd(\"emcc\"),\n-        ar: cmd(\"emar\"),\n \n         dynamic_linking: false,\n         executables: true,"}, {"sha": "a56d067815819c9df04f2f814917a2c9caf00af3", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -135,6 +135,7 @@ macro_rules! supported_targets {\n \n supported_targets! {\n     (\"x86_64-unknown-linux-gnu\", x86_64_unknown_linux_gnu),\n+    (\"x86_64-unknown-linux-gnux32\", x86_64_unknown_linux_gnux32),\n     (\"i686-unknown-linux-gnu\", i686_unknown_linux_gnu),\n     (\"i586-unknown-linux-gnu\", i586_unknown_linux_gnu),\n     (\"mips-unknown-linux-gnu\", mips_unknown_linux_gnu),\n@@ -268,8 +269,6 @@ pub struct TargetOptions {\n \n     /// Linker to invoke. Defaults to \"cc\".\n     pub linker: String,\n-    /// Archive utility to use when managing archives. Defaults to \"ar\".\n-    pub ar: String,\n \n     /// Linker arguments that are unconditionally passed *before* any\n     /// user-defined libraries.\n@@ -430,6 +429,9 @@ pub struct TargetOptions {\n \n     /// The minimum alignment for global symbols.\n     pub min_global_align: Option<u64>,\n+\n+    /// Default number of codegen units to use in debug mode\n+    pub default_codegen_units: Option<u64>,\n }\n \n impl Default for TargetOptions {\n@@ -439,7 +441,6 @@ impl Default for TargetOptions {\n         TargetOptions {\n             is_builtin: false,\n             linker: option_env!(\"CFG_DEFAULT_LINKER\").unwrap_or(\"cc\").to_string(),\n-            ar: option_env!(\"CFG_DEFAULT_AR\").unwrap_or(\"ar\").to_string(),\n             pre_link_args: LinkArgs::new(),\n             post_link_args: LinkArgs::new(),\n             asm_args: Vec::new(),\n@@ -492,6 +493,7 @@ impl Default for TargetOptions {\n             crt_static_respected: false,\n             stack_probes: false,\n             min_global_align: None,\n+            default_codegen_units: None,\n         }\n     }\n }\n@@ -680,7 +682,6 @@ impl Target {\n \n         key!(is_builtin, bool);\n         key!(linker);\n-        key!(ar);\n         key!(pre_link_args, link_args);\n         key!(pre_link_objects_exe, list);\n         key!(pre_link_objects_dll, list);\n@@ -732,6 +733,7 @@ impl Target {\n         key!(crt_static_respected, bool);\n         key!(stack_probes, bool);\n         key!(min_global_align, Option<u64>);\n+        key!(default_codegen_units, Option<u64>);\n \n         if let Some(array) = obj.find(\"abi-blacklist\").and_then(Json::as_array) {\n             for name in array.iter().filter_map(|abi| abi.as_string()) {\n@@ -872,7 +874,6 @@ impl ToJson for Target {\n \n         target_option_val!(is_builtin);\n         target_option_val!(linker);\n-        target_option_val!(ar);\n         target_option_val!(link_args - pre_link_args);\n         target_option_val!(pre_link_objects_exe);\n         target_option_val!(pre_link_objects_dll);\n@@ -924,6 +925,7 @@ impl ToJson for Target {\n         target_option_val!(crt_static_respected);\n         target_option_val!(stack_probes);\n         target_option_val!(min_global_align);\n+        target_option_val!(default_codegen_units);\n \n         if default.abi_blacklist != self.options.abi_blacklist {\n             d.insert(\"abi-blacklist\".to_string(), self.options.abi_blacklist.iter()"}, {"sha": "509a7cf5e03234158d70a61ca70ec53cbb749b74", "filename": "src/librustc_back/target/msp430_none_elf.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_back%2Ftarget%2Fmsp430_none_elf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_back%2Ftarget%2Fmsp430_none_elf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmsp430_none_elf.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -48,6 +48,11 @@ pub fn target() -> TargetResult {\n             // code because of the extra costs it involves.\n             relocation_model: \"static\".to_string(),\n \n+            // Right now we invoke an external assembler and this isn't\n+            // compatible with multiple codegen units, and plus we probably\n+            // don't want to invoke that many gcc instances.\n+            default_codegen_units: Some(1),\n+\n             .. Default::default( )\n         }\n     })"}, {"sha": "a261c982b3f2414d14424a28e2471048040873d9", "filename": "src/librustc_back/target/wasm32_experimental_emscripten.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_back%2Ftarget%2Fwasm32_experimental_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_back%2Ftarget%2Fwasm32_experimental_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwasm32_experimental_emscripten.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -25,7 +25,6 @@ pub fn target() -> Result<Target, String> {\n \n     let opts = TargetOptions {\n         linker: cmd(\"emcc\"),\n-        ar: cmd(\"emar\"),\n \n         dynamic_linking: false,\n         executables: true,"}, {"sha": "197c1f7a4da494c2f9f649f69ea57e3aeee5c092", "filename": "src/librustc_back/target/wasm32_unknown_emscripten.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_emscripten.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -22,7 +22,6 @@ pub fn target() -> Result<Target, String> {\n \n     let opts = TargetOptions {\n         linker: cmd(\"emcc\"),\n-        ar: cmd(\"emar\"),\n \n         dynamic_linking: false,\n         executables: true,"}, {"sha": "64df6624dd1c23df62a5a696aadb3384d3f7611b", "filename": "src/librustc_back/target/windows_msvc_base.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -21,37 +21,6 @@ pub fn opts() -> TargetOptions {\n     TargetOptions {\n         function_sections: true,\n         linker: \"link.exe\".to_string(),\n-        // When taking a look at the value of this `ar` field, one might expect\n-        // `lib.exe` to be the value here! The `lib.exe` program is the default\n-        // tool for managing `.lib` archives on Windows, but unfortunately the\n-        // compiler cannot use it.\n-        //\n-        // To recap, we use `ar` here to manage rlibs (which are just archives).\n-        // LLVM does not expose bindings for modifying archives so we have to\n-        // invoke this utility for write operations (e.g. deleting files, adding\n-        // files, etc). Normally archives only have object files within them,\n-        // but the compiler also uses archives for storing metadata and\n-        // compressed bytecode, so we don't exactly fall within \"normal use\n-        // cases\".\n-        //\n-        // MSVC's `lib.exe` tool by default will choke when adding a non-object\n-        // file to an archive, which we do on a regular basis, making it\n-        // inoperable for us. Luckily, however, LLVM has already rewritten `ar`\n-        // in the form of `llvm-ar` which is built by default when we build\n-        // LLVM. This tool, unlike `lib.exe`, works just fine with non-object\n-        // files, so we use it instead.\n-        //\n-        // Note that there's a few caveats associated with this:\n-        //\n-        // * This still requires that the *linker* (the consumer of rlibs) will\n-        //   ignore non-object files. Thankfully `link.exe` on Windows does\n-        //   indeed ignore non-object files in archives.\n-        // * This requires `llvm-ar.exe` to be distributed with the compiler\n-        //   itself, but we already make sure of this elsewhere.\n-        //\n-        // Perhaps one day we won't even need this tool at all and we'll just be\n-        // able to make library calls into LLVM!\n-        ar: \"llvm-ar.exe\".to_string(),\n         dynamic_linking: true,\n         executables: true,\n         dll_prefix: \"\".to_string(),"}, {"sha": "18f6380b6eedf17e8ced966c880bd4dbade20dd1", "filename": "src/librustc_back/target/x86_64_rumprun_netbsd.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_back%2Ftarget%2Fx86_64_rumprun_netbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_back%2Ftarget%2Fx86_64_rumprun_netbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_rumprun_netbsd.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -16,7 +16,6 @@ pub fn target() -> TargetResult {\n     base.cpu = \"x86-64\".to_string();\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n     base.linker = \"x86_64-rumprun-netbsd-gcc\".to_string();\n-    base.ar = \"x86_64-rumprun-netbsd-ar\".to_string();\n     base.max_atomic_width = Some(64);\n \n     base.dynamic_linking = false;"}, {"sha": "7038203283643e90855d948861f48671375e6ed5", "filename": "src/librustc_back/target/x86_64_unknown_linux_gnux32.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnux32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnux32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnux32.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use LinkerFlavor;\n+use target::{Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::linux_base::opts();\n+    base.cpu = \"x86-64\".to_string();\n+    base.max_atomic_width = Some(64);\n+    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-mx32\".to_string());\n+    base.stack_probes = true;\n+    base.has_elf_tls = false;\n+\n+    Ok(Target {\n+        llvm_target: \"x86_64-unknown-linux-gnux32\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n+        arch: \"x86_64\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: base,\n+    })\n+}"}, {"sha": "4c09a9e003ddb8645645d717ce53a5e9cd53dd15", "filename": "src/librustc_borrowck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_borrowck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_borrowck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2FCargo.toml?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -15,5 +15,6 @@ syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n graphviz = { path = \"../libgraphviz\" }\n rustc = { path = \"../librustc\" }\n+rustc_back = { path = \"../librustc_back\" }\n rustc_mir = { path = \"../librustc_mir\" }\n rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "6ce5afd4bf15f97c81d3a60b41c15e8ba47483ef", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -770,7 +770,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             let lp = opt_loan_path(&assignee_cmt).unwrap();\n             self.move_data.each_assignment_of(assignment_id, &lp, |assign| {\n                 if assignee_cmt.mutbl.is_mutable() {\n-                    self.tcx().used_mut_nodes.borrow_mut().insert(local_id);\n+                    let hir_id = self.bccx.tcx.hir.node_to_hir_id(local_id);\n+                    self.bccx.used_mut_nodes.borrow_mut().insert(hir_id);\n                 } else {\n                     self.bccx.report_reassigned_immutable_variable(\n                         assignment_span,"}, {"sha": "1827ddabe4e2a9d6c7f46e695a96f99166ddbafe", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -442,13 +442,13 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n             wrapped_path = match current_path.kind {\n                 LpVar(local_id) => {\n                     if !through_borrow {\n-                        self.tcx().used_mut_nodes.borrow_mut().insert(local_id);\n+                        let hir_id = self.bccx.tcx.hir.node_to_hir_id(local_id);\n+                        self.bccx.used_mut_nodes.borrow_mut().insert(hir_id);\n                     }\n                     None\n                 }\n                 LpUpvar(ty::UpvarId{ var_id, closure_expr_id: _ }) => {\n-                    let local_id = self.tcx().hir.hir_to_node_id(var_id);\n-                    self.tcx().used_mut_nodes.borrow_mut().insert(local_id);\n+                    self.bccx.used_mut_nodes.borrow_mut().insert(var_id);\n                     None\n                 }\n                 LpExtend(ref base, mc::McInherited, LpDeref(pointer_kind)) |"}, {"sha": "d29250ac57cfbeb10e9450046ab28aaf852912fd", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 79, "deletions": 59, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -20,13 +20,15 @@ pub use self::MovedValueUseKind::*;\n \n use self::InteriorKind::*;\n \n+use rustc::hir::HirId;\n use rustc::hir::map as hir_map;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::cfg;\n use rustc::middle::dataflow::DataFlowContext;\n use rustc::middle::dataflow::BitwiseOperator;\n use rustc::middle::dataflow::DataFlowOperator;\n use rustc::middle::dataflow::KillFrom;\n+use rustc::middle::borrowck::BorrowCheckResult;\n use rustc::hir::def_id::{DefId, DefIndex};\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n@@ -37,7 +39,9 @@ use rustc::middle::free_region::RegionRelations;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc_mir::util::borrowck_errors::{BorrowckErrors, Origin};\n+use rustc::util::nodemap::FxHashSet;\n \n+use std::cell::RefCell;\n use std::fmt;\n use std::rc::Rc;\n use std::hash::{Hash, Hasher};\n@@ -54,6 +58,8 @@ pub mod gather_loans;\n \n pub mod move_data;\n \n+mod unused;\n+\n #[derive(Clone, Copy)]\n pub struct LoanDataFlowOperator;\n \n@@ -79,7 +85,9 @@ pub struct AnalysisData<'a, 'tcx: 'a> {\n     pub move_data: move_data::FlowedMoveData<'a, 'tcx>,\n }\n \n-fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId) {\n+fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n+    -> Rc<BorrowCheckResult>\n+{\n     debug!(\"borrowck(body_owner_def_id={:?})\", owner_def_id);\n \n     let owner_id = tcx.hir.as_local_node_id(owner_def_id).unwrap();\n@@ -91,7 +99,9 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId) {\n             // those things (notably the synthesized constructors from\n             // tuple structs/variants) do not have an associated body\n             // and do not need borrowchecking.\n-            return;\n+            return Rc::new(BorrowCheckResult {\n+                used_mut_nodes: FxHashSet(),\n+            })\n         }\n         _ => { }\n     }\n@@ -100,7 +110,14 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId) {\n     let tables = tcx.typeck_tables_of(owner_def_id);\n     let region_scope_tree = tcx.region_scope_tree(owner_def_id);\n     let body = tcx.hir.body(body_id);\n-    let bccx = &mut BorrowckCtxt { tcx, tables, region_scope_tree, owner_def_id, body };\n+    let mut bccx = BorrowckCtxt {\n+        tcx,\n+        tables,\n+        region_scope_tree,\n+        owner_def_id,\n+        body,\n+        used_mut_nodes: RefCell::new(FxHashSet()),\n+    };\n \n     // Eventually, borrowck will always read the MIR, but at the\n     // moment we do not. So, for now, we always force MIR to be\n@@ -118,14 +135,19 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId) {\n     if let Some(AnalysisData { all_loans,\n                                loans: loan_dfcx,\n                                move_data: flowed_moves }) =\n-        build_borrowck_dataflow_data(bccx, false, body_id,\n+        build_borrowck_dataflow_data(&mut bccx, false, body_id,\n                                      |bccx| {\n                                          cfg = Some(cfg::CFG::new(bccx.tcx, &body));\n                                          cfg.as_mut().unwrap()\n                                      })\n     {\n-        check_loans::check_loans(bccx, &loan_dfcx, &flowed_moves, &all_loans, body);\n+        check_loans::check_loans(&mut bccx, &loan_dfcx, &flowed_moves, &all_loans, body);\n     }\n+    unused::check(&mut bccx, body);\n+\n+    Rc::new(BorrowCheckResult {\n+        used_mut_nodes: bccx.used_mut_nodes.into_inner(),\n+    })\n }\n \n fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(this: &mut BorrowckCtxt<'a, 'tcx>,\n@@ -198,7 +220,14 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n     let tables = tcx.typeck_tables_of(owner_def_id);\n     let region_scope_tree = tcx.region_scope_tree(owner_def_id);\n     let body = tcx.hir.body(body_id);\n-    let mut bccx = BorrowckCtxt { tcx, tables, region_scope_tree, owner_def_id, body };\n+    let mut bccx = BorrowckCtxt {\n+        tcx,\n+        tables,\n+        region_scope_tree,\n+        owner_def_id,\n+        body,\n+        used_mut_nodes: RefCell::new(FxHashSet()),\n+    };\n \n     let dataflow_data = build_borrowck_dataflow_data(&mut bccx, true, body_id, |_| cfg);\n     (bccx, dataflow_data.unwrap())\n@@ -219,6 +248,8 @@ pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n     owner_def_id: DefId,\n \n     body: &'tcx hir::Body,\n+\n+    used_mut_nodes: RefCell<FxHashSet<HirId>>,\n }\n \n impl<'b, 'tcx: 'b> BorrowckErrors for BorrowckCtxt<'b, 'tcx> {\n@@ -614,11 +645,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 let partial = moved_lp.depth() > lp.depth();\n                 let msg = if !has_fork && partial { \"partially \" }\n                           else if has_fork && !has_common { \"collaterally \"}\n-                          else { \"\" };\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess, use_span, E0382,\n-                    \"{} of {}moved value: `{}`\",\n-                    verb, msg, nl);\n+                else { \"\" };\n+                let mut err = self.cannot_act_on_moved_value(use_span,\n+                                                             verb,\n+                                                             msg,\n+                                                             &format!(\"{}\", nl),\n+                                                             Origin::Ast);\n                 let need_note = match lp.ty.sty {\n                     ty::TypeVariants::TyClosure(id, _) => {\n                         let node_id = self.tcx.hir.as_local_node_id(id).unwrap();\n@@ -698,10 +730,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             &self,\n             span: Span,\n             lp: &LoanPath<'tcx>) {\n-        span_err!(\n-            self.tcx.sess, span, E0383,\n-            \"partial reinitialization of uninitialized structure `{}`\",\n-            self.loan_path_to_string(lp));\n+        self.cannot_partially_reinit_an_uninit_struct(span,\n+                                                      &self.loan_path_to_string(lp),\n+                                                      Origin::Ast)\n+            .emit();\n     }\n \n     pub fn report_reassigned_immutable_variable(&self,\n@@ -759,11 +791,24 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n                 let mut db = match err.cause {\n                     MutabilityViolation => {\n-                        self.cannot_assign(error_span, &descr, Origin::Ast)\n+                        let mut db = self.cannot_assign(error_span, &descr, Origin::Ast);\n+                        if let mc::NoteClosureEnv(upvar_id) = err.cmt.note {\n+                            let node_id = self.tcx.hir.hir_to_node_id(upvar_id.var_id);\n+                            let sp = self.tcx.hir.span(node_id);\n+                            match self.tcx.sess.codemap().span_to_snippet(sp) {\n+                                Ok(snippet) => {\n+                                    let msg = &format!(\"consider making `{}` mutable\", snippet);\n+                                    db.span_suggestion(sp, msg, format!(\"mut {}\", snippet));\n+                                }\n+                                _ => {\n+                                    db.span_help(sp, \"consider making this binding mutable\");\n+                                }\n+                            }\n+                        }\n+                        db\n                     }\n                     BorrowViolation(euv::ClosureCapture(_)) => {\n-                        struct_span_err!(self.tcx.sess, error_span, E0595,\n-                                         \"closure cannot assign to {}\", descr)\n+                        self.closure_cannot_assign_to_borrowed(error_span, &descr, Origin::Ast)\n                     }\n                     BorrowViolation(euv::OverloadedOperator) |\n                     BorrowViolation(euv::AddrOf) |\n@@ -772,8 +817,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     BorrowViolation(euv::AutoUnsafe) |\n                     BorrowViolation(euv::ForLoop) |\n                     BorrowViolation(euv::MatchDiscriminant) => {\n-                        struct_span_err!(self.tcx.sess, error_span, E0596,\n-                                         \"cannot borrow {} as mutable\", descr)\n+                        self.cannot_borrow_path_as_mutable(error_span, &descr, Origin::Ast)\n                     }\n                     BorrowViolation(euv::ClosureInvocation) => {\n                         span_bug!(err.span,\n@@ -855,21 +899,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n                 if let Some((yield_span, _)) = maybe_borrow_across_yield {\n                     debug!(\"err_out_of_scope: opt_yield_span = {:?}\", yield_span);\n-                    struct_span_err!(self.tcx.sess,\n-                                     error_span,\n-                                     E0626,\n-                                     \"borrow may still be in use when generator yields\")\n-                        .span_label(yield_span, \"possible yield occurs here\")\n+                    self.cannot_borrow_across_generator_yield(error_span, yield_span, Origin::Ast)\n                         .emit();\n                     return;\n                 }\n \n-                let mut db = struct_span_err!(self.tcx.sess,\n-                                              error_span,\n-                                              E0597,\n-                                              \"{} does not live long enough\",\n-                                              msg);\n-\n+                let mut db = self.path_does_not_live_long_enough(error_span, &msg, Origin::Ast);\n                 let (value_kind, value_msg) = match err.cmt.cat {\n                     mc::Categorization::Rvalue(..) =>\n                         (\"temporary value\", \"temporary value created here\"),\n@@ -978,11 +1013,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n             err_borrowed_pointer_too_short(loan_scope, ptr_scope) => {\n                 let descr = self.cmt_to_path_or_string(&err.cmt);\n-                let mut db = struct_span_err!(self.tcx.sess, error_span, E0598,\n-                                              \"lifetime of {} is too short to guarantee \\\n-                                               its contents can be safely reborrowed\",\n-                                              descr);\n-\n+                let mut db = self.lifetime_too_short_for_reborrow(error_span, &descr, Origin::Ast);\n                 let descr = match opt_loan_path(&err.cmt) {\n                     Some(lp) => {\n                         format!(\"`{}`\", self.loan_path_to_string(&lp))\n@@ -1054,12 +1085,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         let blame = cmt.immutability_blame();\n         let mut err = match blame {\n             Some(ImmutabilityBlame::ClosureEnv(id)) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess, span, E0387,\n-                    \"{} in a captured outer variable in an `Fn` closure\", prefix);\n-\n                 // FIXME: the distinction between these 2 messages looks wrong.\n-                let help = if let BorrowViolation(euv::ClosureCapture(_)) = kind {\n+                let help_msg = if let BorrowViolation(euv::ClosureCapture(_)) = kind {\n                     // The aliasability violation with closure captures can\n                     // happen for nested closures, so we know the enclosing\n                     // closure incorrectly accepts an `Fn` while it needs to\n@@ -1070,15 +1097,15 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     \"consider changing this closure to take self by mutable reference\"\n                 };\n                 let node_id = self.tcx.hir.def_index_to_node_id(id);\n-                err.span_help(self.tcx.hir.span(node_id), help);\n-                err\n+                let help_span = self.tcx.hir.span(node_id);\n+                self.cannot_act_on_capture_in_sharable_fn(span,\n+                                                          prefix,\n+                                                          (help_span, help_msg),\n+                                                          Origin::Ast)\n             }\n             _ =>  {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess, span, E0389,\n-                    \"{} in a `&` reference\", prefix);\n-                err.span_label(span, \"assignment into an immutable reference\");\n-                err\n+                self.cannot_assign_into_immutable_reference(span, prefix,\n+                                                            Origin::Ast)\n             }\n         };\n         self.note_immutability_blame(&mut err, blame);\n@@ -1230,17 +1257,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 Err(_) => format!(\"move |<args>| <body>\")\n             };\n \n-        struct_span_err!(self.tcx.sess, err.span, E0373,\n-                         \"closure may outlive the current function, \\\n-                          but it borrows {}, \\\n-                          which is owned by the current function\",\n-                         cmt_path_or_string)\n-            .span_label(capture_span,\n-                       format!(\"{} is borrowed here\",\n-                                cmt_path_or_string))\n-            .span_label(err.span,\n-                       format!(\"may outlive borrowed value {}\",\n-                                cmt_path_or_string))\n+        self.cannot_capture_in_long_lived_closure(err.span,\n+                                                  &cmt_path_or_string,\n+                                                  capture_span,\n+                                                  Origin::Ast)\n             .span_suggestion(err.span,\n                              &format!(\"to force the closure to take ownership of {} \\\n                                        (and any other referenced variables), \\"}, {"sha": "228824b663d66ed8114ffd37b048f9815836a117", "filename": "src/librustc_borrowck/borrowck/unused.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -0,0 +1,118 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n+use rustc::hir::{self, HirId};\n+use rustc::lint::builtin::UNUSED_MUT;\n+use rustc::ty;\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n+use rustc_back::slice;\n+use syntax::ptr::P;\n+\n+use borrowck::BorrowckCtxt;\n+\n+pub fn check<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>, body: &'tcx hir::Body) {\n+    let mut used_mut = bccx.used_mut_nodes.borrow().clone();\n+    UsedMutFinder {\n+        bccx,\n+        set: &mut used_mut,\n+    }.visit_expr(&body.value);\n+    let mut cx = UnusedMutCx { bccx, used_mut };\n+    for arg in body.arguments.iter() {\n+        cx.check_unused_mut_pat(slice::ref_slice(&arg.pat));\n+    }\n+    cx.visit_expr(&body.value);\n+}\n+\n+struct UsedMutFinder<'a, 'tcx: 'a> {\n+    bccx: &'a BorrowckCtxt<'a, 'tcx>,\n+    set: &'a mut FxHashSet<HirId>,\n+}\n+\n+struct UnusedMutCx<'a, 'tcx: 'a> {\n+    bccx: &'a BorrowckCtxt<'a, 'tcx>,\n+    used_mut: FxHashSet<HirId>,\n+}\n+\n+impl<'a, 'tcx> UnusedMutCx<'a, 'tcx> {\n+    fn check_unused_mut_pat(&self, pats: &[P<hir::Pat>]) {\n+        let tcx = self.bccx.tcx;\n+        let mut mutables = FxHashMap();\n+        for p in pats {\n+            p.each_binding(|_, id, span, path1| {\n+                let name = path1.node;\n+\n+                // Skip anything that looks like `_foo`\n+                if name.as_str().starts_with(\"_\") {\n+                    return\n+                }\n+\n+                // Skip anything that looks like `&foo` or `&mut foo`, only look\n+                // for by-value bindings\n+                let hir_id = tcx.hir.node_to_hir_id(id);\n+                let bm = match self.bccx.tables.pat_binding_modes().get(hir_id) {\n+                    Some(&bm) => bm,\n+                    None => span_bug!(span, \"missing binding mode\"),\n+                };\n+                match bm {\n+                    ty::BindByValue(hir::MutMutable) => {}\n+                    _ => return,\n+                }\n+\n+                mutables.entry(name).or_insert(Vec::new()).push((id, hir_id, span));\n+            });\n+        }\n+\n+        for (_name, ids) in mutables {\n+            // If any id for this name was used mutably then consider them all\n+            // ok, so move on to the next\n+            if ids.iter().any(|&(_, ref id, _)| self.used_mut.contains(id)) {\n+                continue\n+            }\n+\n+            let mut_span = tcx.sess.codemap().span_until_char(ids[0].2, ' ');\n+\n+            // Ok, every name wasn't used mutably, so issue a warning that this\n+            // didn't need to be mutable.\n+            tcx.struct_span_lint_node(UNUSED_MUT,\n+                                      ids[0].0,\n+                                      ids[0].2,\n+                                      \"variable does not need to be mutable\")\n+                .span_suggestion_short(mut_span, \"remove this `mut`\", \"\".to_owned())\n+                .emit();\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for UnusedMutCx<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.bccx.tcx.hir)\n+    }\n+\n+    fn visit_arm(&mut self, arm: &hir::Arm) {\n+        self.check_unused_mut_pat(&arm.pats)\n+    }\n+\n+    fn visit_local(&mut self, local: &hir::Local) {\n+        self.check_unused_mut_pat(slice::ref_slice(&local.pat));\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for UsedMutFinder<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.bccx.tcx.hir)\n+    }\n+\n+    fn visit_nested_body(&mut self, id: hir::BodyId) {\n+        let def_id = self.bccx.tcx.hir.body_owner_def_id(id);\n+        self.set.extend(self.bccx.tcx.borrowck(def_id).used_mut_nodes.iter().cloned());\n+        self.visit_body(self.bccx.tcx.hir.body(id));\n+    }\n+}"}, {"sha": "3fea01443be4b9d34fa31d68024bdea9ed4037dd", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 469, "changes": 469, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -9,472 +9,3 @@\n // except according to those terms.\n \n #![allow(non_snake_case)]\n-\n-register_long_diagnostics! {\n-\n-E0373: r##\"\n-This error occurs when an attempt is made to use data captured by a closure,\n-when that data may no longer exist. It's most commonly seen when attempting to\n-return a closure:\n-\n-```compile_fail,E0373\n-fn foo() -> Box<Fn(u32) -> u32> {\n-    let x = 0u32;\n-    Box::new(|y| x + y)\n-}\n-```\n-\n-Notice that `x` is stack-allocated by `foo()`. By default, Rust captures\n-closed-over data by reference. This means that once `foo()` returns, `x` no\n-longer exists. An attempt to access `x` within the closure would thus be\n-unsafe.\n-\n-Another situation where this might be encountered is when spawning threads:\n-\n-```compile_fail,E0373\n-fn foo() {\n-    let x = 0u32;\n-    let y = 1u32;\n-\n-    let thr = std::thread::spawn(|| {\n-        x + y\n-    });\n-}\n-```\n-\n-Since our new thread runs in parallel, the stack frame containing `x` and `y`\n-may well have disappeared by the time we try to use them. Even if we call\n-`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\n-stack frame won't disappear), we will not succeed: the compiler cannot prove\n-that this behaviour is safe, and so won't let us do it.\n-\n-The solution to this problem is usually to switch to using a `move` closure.\n-This approach moves (or copies, where possible) data into the closure, rather\n-than taking references to it. For example:\n-\n-```\n-fn foo() -> Box<Fn(u32) -> u32> {\n-    let x = 0u32;\n-    Box::new(move |y| x + y)\n-}\n-```\n-\n-Now that the closure has its own copy of the data, there's no need to worry\n-about safety.\n-\"##,\n-\n-E0382: r##\"\n-This error occurs when an attempt is made to use a variable after its contents\n-have been moved elsewhere. For example:\n-\n-```compile_fail,E0382\n-struct MyStruct { s: u32 }\n-\n-fn main() {\n-    let mut x = MyStruct{ s: 5u32 };\n-    let y = x;\n-    x.s = 6;\n-    println!(\"{}\", x.s);\n-}\n-```\n-\n-Since `MyStruct` is a type that is not marked `Copy`, the data gets moved out\n-of `x` when we set `y`. This is fundamental to Rust's ownership system: outside\n-of workarounds like `Rc`, a value cannot be owned by more than one variable.\n-\n-If we own the type, the easiest way to address this problem is to implement\n-`Copy` and `Clone` on it, as shown below. This allows `y` to copy the\n-information in `x`, while leaving the original version owned by `x`. Subsequent\n-changes to `x` will not be reflected when accessing `y`.\n-\n-```\n-#[derive(Copy, Clone)]\n-struct MyStruct { s: u32 }\n-\n-fn main() {\n-    let mut x = MyStruct{ s: 5u32 };\n-    let y = x;\n-    x.s = 6;\n-    println!(\"{}\", x.s);\n-}\n-```\n-\n-Alternatively, if we don't control the struct's definition, or mutable shared\n-ownership is truly required, we can use `Rc` and `RefCell`:\n-\n-```\n-use std::cell::RefCell;\n-use std::rc::Rc;\n-\n-struct MyStruct { s: u32 }\n-\n-fn main() {\n-    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n-    let y = x.clone();\n-    x.borrow_mut().s = 6;\n-    println!(\"{}\", x.borrow().s);\n-}\n-```\n-\n-With this approach, x and y share ownership of the data via the `Rc` (reference\n-count type). `RefCell` essentially performs runtime borrow checking: ensuring\n-that at most one writer or multiple readers can access the data at any one time.\n-\n-If you wish to learn more about ownership in Rust, start with the chapter in the\n-Book:\n-\n-https://doc.rust-lang.org/book/first-edition/ownership.html\n-\"##,\n-\n-E0383: r##\"\n-This error occurs when an attempt is made to partially reinitialize a\n-structure that is currently uninitialized.\n-\n-For example, this can happen when a drop has taken place:\n-\n-```compile_fail,E0383\n-struct Foo {\n-    a: u32,\n-}\n-impl Drop for Foo {\n-    fn drop(&mut self) { /* ... */ }\n-}\n-\n-let mut x = Foo { a: 1 };\n-drop(x); // `x` is now uninitialized\n-x.a = 2; // error, partial reinitialization of uninitialized structure `t`\n-```\n-\n-This error can be fixed by fully reinitializing the structure in question:\n-\n-```\n-struct Foo {\n-    a: u32,\n-}\n-impl Drop for Foo {\n-    fn drop(&mut self) { /* ... */ }\n-}\n-\n-let mut x = Foo { a: 1 };\n-drop(x);\n-x = Foo { a: 2 };\n-```\n-\"##,\n-\n-/*E0386: r##\"\n-This error occurs when an attempt is made to mutate the target of a mutable\n-reference stored inside an immutable container.\n-\n-For example, this can happen when storing a `&mut` inside an immutable `Box`:\n-\n-```compile_fail,E0386\n-let mut x: i64 = 1;\n-let y: Box<_> = Box::new(&mut x);\n-**y = 2; // error, cannot assign to data in an immutable container\n-```\n-\n-This error can be fixed by making the container mutable:\n-\n-```\n-let mut x: i64 = 1;\n-let mut y: Box<_> = Box::new(&mut x);\n-**y = 2;\n-```\n-\n-It can also be fixed by using a type with interior mutability, such as `Cell`\n-or `RefCell`:\n-\n-```\n-use std::cell::Cell;\n-\n-let x: i64 = 1;\n-let y: Box<Cell<_>> = Box::new(Cell::new(x));\n-y.set(2);\n-```\n-\"##,*/\n-\n-E0387: r##\"\n-This error occurs when an attempt is made to mutate or mutably reference data\n-that a closure has captured immutably. Examples of this error are shown below:\n-\n-```compile_fail,E0387\n-// Accepts a function or a closure that captures its environment immutably.\n-// Closures passed to foo will not be able to mutate their closed-over state.\n-fn foo<F: Fn()>(f: F) { }\n-\n-// Attempts to mutate closed-over data. Error message reads:\n-// `cannot assign to data in a captured outer variable...`\n-fn mutable() {\n-    let mut x = 0u32;\n-    foo(|| x = 2);\n-}\n-\n-// Attempts to take a mutable reference to closed-over data.  Error message\n-// reads: `cannot borrow data mutably in a captured outer variable...`\n-fn mut_addr() {\n-    let mut x = 0u32;\n-    foo(|| { let y = &mut x; });\n-}\n-```\n-\n-The problem here is that foo is defined as accepting a parameter of type `Fn`.\n-Closures passed into foo will thus be inferred to be of type `Fn`, meaning that\n-they capture their context immutably.\n-\n-If the definition of `foo` is under your control, the simplest solution is to\n-capture the data mutably. This can be done by defining `foo` to take FnMut\n-rather than Fn:\n-\n-```\n-fn foo<F: FnMut()>(f: F) { }\n-```\n-\n-Alternatively, we can consider using the `Cell` and `RefCell` types to achieve\n-interior mutability through a shared reference. Our example's `mutable`\n-function could be redefined as below:\n-\n-```\n-use std::cell::Cell;\n-\n-fn foo<F: Fn()>(f: F) { }\n-\n-fn mutable() {\n-    let x = Cell::new(0u32);\n-    foo(|| x.set(2));\n-}\n-```\n-\n-You can read more about cell types in the API documentation:\n-\n-https://doc.rust-lang.org/std/cell/\n-\"##,\n-\n-E0388: r##\"\n-E0388 was removed and is no longer issued.\n-\"##,\n-\n-E0389: r##\"\n-An attempt was made to mutate data using a non-mutable reference. This\n-commonly occurs when attempting to assign to a non-mutable reference of a\n-mutable reference (`&(&mut T)`).\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0389\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy = FancyNum{ num: 5 };\n-    let fancy_ref = &(&mut fancy);\n-    fancy_ref.num = 6; // error: cannot assign to data in a `&` reference\n-    println!(\"{}\", fancy_ref.num);\n-}\n-```\n-\n-Here, `&mut fancy` is mutable, but `&(&mut fancy)` is not. Creating an\n-immutable reference to a value borrows it immutably. There can be multiple\n-references of type `&(&mut T)` that point to the same value, so they must be\n-immutable to prevent multiple mutable references to the same value.\n-\n-To fix this, either remove the outer reference:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy = FancyNum{ num: 5 };\n-\n-    let fancy_ref = &mut fancy;\n-    // `fancy_ref` is now &mut FancyNum, rather than &(&mut FancyNum)\n-\n-    fancy_ref.num = 6; // No error!\n-\n-    println!(\"{}\", fancy_ref.num);\n-}\n-```\n-\n-Or make the outer reference mutable:\n-\n-```\n-struct FancyNum {\n-    num: u8\n-}\n-\n-fn main() {\n-    let mut fancy = FancyNum{ num: 5 };\n-\n-    let fancy_ref = &mut (&mut fancy);\n-    // `fancy_ref` is now &mut(&mut FancyNum), rather than &(&mut FancyNum)\n-\n-    fancy_ref.num = 6; // No error!\n-\n-    println!(\"{}\", fancy_ref.num);\n-}\n-```\n-\"##,\n-\n-E0595: r##\"\n-Closures cannot mutate immutable captured variables.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0595\n-let x = 3; // error: closure cannot assign to immutable local variable `x`\n-let mut c = || { x += 1 };\n-```\n-\n-Make the variable binding mutable:\n-\n-```\n-let mut x = 3; // ok!\n-let mut c = || { x += 1 };\n-```\n-\"##,\n-\n-E0596: r##\"\n-This error occurs because you tried to mutably borrow a non-mutable variable.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0596\n-let x = 1;\n-let y = &mut x; // error: cannot borrow mutably\n-```\n-\n-In here, `x` isn't mutable, so when we try to mutably borrow it in `y`, it\n-fails. To fix this error, you need to make `x` mutable:\n-\n-```\n-let mut x = 1;\n-let y = &mut x; // ok!\n-```\n-\"##,\n-\n-E0597: r##\"\n-This error occurs because a borrow was made inside a variable which has a\n-greater lifetime than the borrowed one.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0597\n-struct Foo<'a> {\n-    x: Option<&'a u32>,\n-}\n-\n-let mut x = Foo { x: None };\n-let y = 0;\n-x.x = Some(&y); // error: `y` does not live long enough\n-```\n-\n-In here, `x` is created before `y` and therefore has a greater lifetime. Always\n-keep in mind that values in a scope are dropped in the opposite order they are\n-created. So to fix the previous example, just make the `y` lifetime greater than\n-the `x`'s one:\n-\n-```\n-struct Foo<'a> {\n-    x: Option<&'a u32>,\n-}\n-\n-let y = 0;\n-let mut x = Foo { x: None };\n-x.x = Some(&y);\n-```\n-\"##,\n-\n-E0626: r##\"\n-This error occurs because a borrow in a generator persists across a\n-yield point.\n-\n-```compile_fail,E0626\n-# #![feature(generators, generator_trait)]\n-# use std::ops::Generator;\n-let mut b = || {\n-    let a = &String::new(); // <-- This borrow...\n-    yield (); // ...is still in scope here, when the yield occurs.\n-    println!(\"{}\", a);\n-};\n-b.resume();\n-```\n-\n-At present, it is not permitted to have a yield that occurs while a\n-borrow is still in scope. To resolve this error, the borrow must\n-either be \"contained\" to a smaller scope that does not overlap the\n-yield or else eliminated in another way. So, for example, we might\n-resolve the previous example by removing the borrow and just storing\n-the integer by value:\n-\n-```\n-# #![feature(generators, generator_trait)]\n-# use std::ops::Generator;\n-let mut b = || {\n-    let a = 3;\n-    yield ();\n-    println!(\"{}\", a);\n-};\n-b.resume();\n-```\n-\n-This is a very simple case, of course. In more complex cases, we may\n-wish to have more than one reference to the value that was borrowed --\n-in those cases, something like the `Rc` or `Arc` types may be useful.\n-\n-This error also frequently arises with iteration:\n-\n-```compile_fail,E0626\n-# #![feature(generators, generator_trait)]\n-# use std::ops::Generator;\n-let mut b = || {\n-  let v = vec![1,2,3];\n-  for &x in &v { // <-- borrow of `v` is still in scope...\n-    yield x; // ...when this yield occurs.\n-  }\n-};\n-b.resume();\n-```\n-\n-Such cases can sometimes be resolved by iterating \"by value\" (or using\n-`into_iter()`) to avoid borrowing:\n-\n-```\n-# #![feature(generators, generator_trait)]\n-# use std::ops::Generator;\n-let mut b = || {\n-  let v = vec![1,2,3];\n-  for x in v { // <-- Take ownership of the values instead!\n-    yield x; // <-- Now yield is OK.\n-  }\n-};\n-b.resume();\n-```\n-\n-If taking ownership is not an option, using indices can work too:\n-\n-```\n-# #![feature(generators, generator_trait)]\n-# use std::ops::Generator;\n-let mut b = || {\n-  let v = vec![1,2,3];\n-  let len = v.len(); // (*)\n-  for i in 0..len {\n-    let x = v[i]; // (*)\n-    yield x; // <-- Now yield is OK.\n-  }\n-};\n-b.resume();\n-\n-// (*) -- Unfortunately, these temporaries are currently required.\n-// See <https://github.com/rust-lang/rust/issues/43122>.\n-```\n-\"##,\n-\n-}\n-\n-register_diagnostics! {\n-//    E0385, // {} in an aliasable location\n-    E0598, // lifetime of {} is too short to guarantee its contents can be...\n-}"}, {"sha": "78aacd49f807dafafc8ae37f7f29db8ed6e81e27", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -16,12 +16,12 @@\n #![allow(non_camel_case_types)]\n \n #![feature(quote)]\n-#![feature(rustc_diagnostic_macros)]\n \n #[macro_use] extern crate log;\n-#[macro_use] extern crate syntax;\n+extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc_errors as errors;\n+extern crate rustc_back;\n \n // for \"clarity\", rename the graphviz crate to dot; graphviz within `borrowck`\n // refers to the borrowck-specific graphviz adapter traits.\n@@ -33,14 +33,8 @@ extern crate rustc_mir;\n pub use borrowck::check_crate;\n pub use borrowck::build_borrowck_dataflow_data_for_fn;\n \n-// NB: This module needs to be declared first so diagnostics are\n-// registered before they are used.\n-mod diagnostics;\n-\n mod borrowck;\n \n pub mod graphviz;\n \n pub use borrowck::provide;\n-\n-__build_diagnostic_array! { librustc_borrowck, DIAGNOSTICS }"}, {"sha": "56d5f5ffa3f6c6abe2756878357433892b529e70", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -31,7 +31,7 @@\n //! be indexed by the direction (see the type `Direction`).\n \n use bitvec::BitVector;\n-use std::fmt::{Formatter, Error, Debug};\n+use std::fmt::Debug;\n use std::usize;\n use snapshot_vec::{SnapshotVec, SnapshotVecDelegate};\n \n@@ -48,6 +48,7 @@ pub struct Node<N> {\n     pub data: N,\n }\n \n+#[derive(Debug)]\n pub struct Edge<E> {\n     next_edge: [EdgeIndex; 2], // see module comment\n     source: NodeIndex,\n@@ -69,18 +70,6 @@ impl<N> SnapshotVecDelegate for Edge<N> {\n     fn reverse(_: &mut Vec<Edge<N>>, _: ()) {}\n }\n \n-impl<E: Debug> Debug for Edge<E> {\n-    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n-        write!(f,\n-               \"Edge {{ next_edge: [{:?}, {:?}], source: {:?}, target: {:?}, data: {:?} }}\",\n-               self.next_edge[0],\n-               self.next_edge[1],\n-               self.source,\n-               self.target,\n-               self.data)\n-    }\n-}\n-\n #[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n pub struct NodeIndex(pub usize);\n "}, {"sha": "6c5a37aa1e5750ffb9b39daf67d86d578c585bdf", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 58, "deletions": 17, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -40,39 +40,80 @@ impl Idx for u32 {\n \n #[macro_export]\n macro_rules! newtype_index {\n+    // ---- public rules ----\n+\n+    // Use default constants\n     ($name:ident) => (\n-        newtype_index!($name, unsafe { ::std::intrinsics::type_name::<$name>() });\n+        newtype_index!(\n+            @type[$name]\n+            @max[::std::u32::MAX]\n+            @debug_name[unsafe {::std::intrinsics::type_name::<$name>() }]);\n+    );\n+\n+    // Define any constants\n+    ($name:ident { $($tokens:tt)+ }) => (\n+        newtype_index!(\n+            @type[$name]\n+            @max[::std::u32::MAX]\n+            @debug_name[unsafe {::std::intrinsics::type_name::<$name>() }]\n+            $($tokens)+);\n     );\n \n-    ($name:ident, $debug_name:expr) => (\n+    // ---- private rules ----\n+\n+    // Base case, user-defined constants (if any) have already been defined\n+    (@type[$type:ident] @max[$max:expr] @debug_name[$debug_name:expr]) => (\n         #[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord,\n-         RustcEncodable, RustcDecodable)]\n-        pub struct $name(u32);\n-\n-        impl $name {\n-            // HACK use for constants\n-            #[allow(unused)]\n-            const fn const_new(x: u32) -> Self {\n-                $name(x)\n-            }\n-        }\n+            RustcEncodable, RustcDecodable)]\n+        pub struct $type(u32);\n \n-        impl Idx for $name {\n+        impl Idx for $type {\n             fn new(value: usize) -> Self {\n-                assert!(value < (::std::u32::MAX) as usize);\n-                $name(value as u32)\n+                assert!(value < ($max) as usize);\n+                $type(value as u32)\n             }\n             fn index(self) -> usize {\n                 self.0 as usize\n             }\n         }\n \n-        impl ::std::fmt::Debug for $name {\n+        impl ::std::fmt::Debug for $type {\n             fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n                 write!(fmt, \"{}{}\", $debug_name, self.0)\n             }\n         }\n-    )\n+    );\n+\n+    // Rewrite final without comma to one that includes comma\n+    (@type[$type:ident] @max[$max:expr] @debug_name[$debug_name:expr]\n+            $name:ident = $constant:expr) => (\n+        newtype_index!(@type[$type] @max[$max] @debug_name[$debug_name] $name = $constant,);\n+    );\n+\n+    // Rewrite final const without comma to one that includes comma\n+    (@type[$type:ident] @max[$_max:expr] @debug_name[$debug_name:expr]\n+            const $name:ident = $constant:expr) => (\n+        newtype_index!(@type[$type] @max[$max] @debug_name[$debug_name] const $name = $constant,);\n+    );\n+\n+    // Replace existing default for max\n+    (@type[$type:ident] @max[$_max:expr] @debug_name[$debug_name:expr]\n+            MAX = $max:expr, $($tokens:tt)*) => (\n+        newtype_index!(@type[$type] @max[$max] @debug_name[$debug_name] $(tokens)*);\n+    );\n+\n+    // Replace existing default for debug_name\n+    (@type[$type:ident] @max[$max:expr] @debug_name[$_debug_name:expr]\n+            DEBUG_NAME = $debug_name:expr, $($tokens:tt)*) => (\n+        newtype_index!(@type[$type] @max[$max] @debug_name[$debug_name] $($tokens)*);\n+    );\n+\n+    // Assign a user-defined constant (as final param)\n+    (@type[$type:ident] @max[$max:expr] @debug_name[$debug_name:expr]\n+            const $name:ident = $constant:expr, $($tokens:tt)*) => (\n+        pub const $name: $type = $type($constant);\n+        newtype_index!(@type[$type] @max[$max] @debug_name[$debug_name] $($tokens)*);\n+    );\n }\n \n #[derive(Clone, PartialEq, Eq)]"}, {"sha": "3514302c6c8f3e49ea18c1e6aa700450944b15e1", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -1238,7 +1238,7 @@ pub fn monitor<F: FnOnce() + Send + 'static>(f: F) {\n                              errors::Level::Note);\n             }\n \n-            writeln!(io::stderr(), \"{}\", str::from_utf8(&data.lock().unwrap()).unwrap()).unwrap();\n+            eprintln!(\"{}\", str::from_utf8(&data.lock().unwrap()).unwrap());\n         }\n \n         exit_on_err();\n@@ -1259,7 +1259,6 @@ pub fn diagnostics_registry() -> errors::registry::Registry {\n     let mut all_errors = Vec::new();\n     all_errors.extend_from_slice(&rustc::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_typeck::DIAGNOSTICS);\n-    all_errors.extend_from_slice(&rustc_borrowck::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_resolve::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_privacy::DIAGNOSTICS);\n     #[cfg(feature=\"llvm\")]"}, {"sha": "0cb920a111dd91ff4df0b25a247a75f6982b1dc0", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 393, "deletions": 28, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -13,12 +13,12 @@\n //! we will compare the fingerprint from the current and from the previous\n //! compilation session as appropriate:\n //!\n-//! - `#[rustc_dirty(label=\"TypeckTables\", cfg=\"rev2\")]` if we are\n+//! - `#[rustc_clean(cfg=\"rev2\", except=\"TypeckTables\")]` if we are\n //!   in `#[cfg(rev2)]`, then the fingerprints associated with\n //!   `DepNode::TypeckTables(X)` must be DIFFERENT (`X` is the def-id of the\n //!   current node).\n-//! - `#[rustc_clean(label=\"TypeckTables\", cfg=\"rev2\")]` same as above,\n-//!   except that the fingerprints must be the SAME.\n+//! - `#[rustc_clean(cfg=\"rev2\")]` same as above, except that the\n+//!   fingerprints must be the SAME (along with all other fingerprints).\n //!\n //! Errors are reported if we are in the suitable configuration but\n //! the required condition is not met.\n@@ -40,9 +40,12 @@\n //!\n \n use std::collections::HashSet;\n+use std::iter::FromIterator;\n use std::vec::Vec;\n-use rustc::dep_graph::DepNode;\n+use rustc::dep_graph::{DepNode, label_strs};\n use rustc::hir;\n+use rustc::hir::{Item_ as HirItem, ImplItemKind, TraitItemKind};\n+use rustc::hir::map::Node as HirNode;\n use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::intravisit;\n@@ -53,11 +56,183 @@ use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use syntax_pos::Span;\n use rustc::ty::TyCtxt;\n \n-const LABEL: &'static str = \"label\";\n-const CFG: &'static str = \"cfg\";\n+const EXCEPT: &str = \"except\";\n+const LABEL: &str = \"label\";\n+const CFG: &str = \"cfg\";\n+\n+// Base and Extra labels to build up the labels\n+\n+/// For typedef, constants, and statics\n+const BASE_CONST: &[&str] = &[\n+    label_strs::TypeOfItem,\n+];\n+\n+/// DepNodes for functions + methods\n+const BASE_FN: &[&str] = &[\n+    // Callers will depend on the signature of these items, so we better test\n+    label_strs::FnSignature,\n+    label_strs::GenericsOfItem,\n+    label_strs::PredicatesOfItem,\n+    label_strs::TypeOfItem,\n+\n+    // And a big part of compilation (that we eventually want to cache) is type inference\n+    // information:\n+    label_strs::TypeckTables,\n+];\n+\n+/// DepNodes for Hir, which is pretty much everything\n+const BASE_HIR: &[&str] = &[\n+    // Hir and HirBody should be computed for all nodes\n+    label_strs::Hir,\n+    label_strs::HirBody,\n+];\n+\n+/// `impl` implementation of struct/trait\n+const BASE_IMPL: &[&str] = &[\n+    label_strs::AssociatedItemDefIds,\n+    label_strs::GenericsOfItem,\n+    label_strs::ImplTraitRef,\n+];\n+\n+/// DepNodes for MirValidated/Optimized, which is relevant in \"executable\"\n+/// code, i.e. functions+methods\n+const BASE_MIR: &[&str] = &[\n+    label_strs::MirOptimized,\n+    label_strs::MirValidated,\n+];\n+\n+/// Struct, Enum and Union DepNodes\n+///\n+/// Note that changing the type of a field does not change the type of the struct or enum, but\n+/// adding/removing fields or changing a fields name or visibility does.\n+const BASE_STRUCT: &[&str] = &[\n+    label_strs::GenericsOfItem,\n+    label_strs::PredicatesOfItem,\n+    label_strs::TypeOfItem,\n+];\n+\n+/// Trait Definition DepNodes\n+const BASE_TRAIT_DEF: &[&str] = &[\n+    label_strs::AssociatedItemDefIds,\n+    label_strs::GenericsOfItem,\n+    label_strs::ObjectSafety,\n+    label_strs::PredicatesOfItem,\n+    label_strs::SpecializationGraph,\n+    label_strs::TraitDefOfItem,\n+    label_strs::TraitImpls,\n+];\n+\n+/// extra DepNodes for methods (+fn)\n+const EXTRA_ASSOCIATED: &[&str] = &[\n+    label_strs::AssociatedItems,\n+];\n+\n+const EXTRA_TRAIT: &[&str] = &[\n+    label_strs::TraitOfItem,\n+];\n+\n+// Fully Built Labels\n+\n+const LABELS_CONST: &[&[&str]] = &[\n+    BASE_HIR,\n+    BASE_CONST,\n+];\n+\n+/// Constant/Typedef in an impl\n+const LABELS_CONST_IN_IMPL: &[&[&str]] = &[\n+    BASE_HIR,\n+    BASE_CONST,\n+    EXTRA_ASSOCIATED,\n+];\n+\n+/// Trait-Const/Typedef DepNodes\n+const LABELS_CONST_IN_TRAIT: &[&[&str]] = &[\n+    BASE_HIR,\n+    BASE_CONST,\n+    EXTRA_ASSOCIATED,\n+    EXTRA_TRAIT,\n+];\n+\n+/// Function DepNode\n+const LABELS_FN: &[&[&str]] = &[\n+    BASE_HIR,\n+    BASE_MIR,\n+    BASE_FN,\n+];\n+\n+/// Method DepNodes\n+const LABELS_FN_IN_IMPL: &[&[&str]] = &[\n+    BASE_HIR,\n+    BASE_MIR,\n+    BASE_FN,\n+    EXTRA_ASSOCIATED,\n+];\n+\n+/// Trait-Method DepNodes\n+const LABELS_FN_IN_TRAIT: &[&[&str]] = &[\n+    BASE_HIR,\n+    BASE_MIR,\n+    BASE_FN,\n+    EXTRA_ASSOCIATED,\n+    EXTRA_TRAIT,\n+];\n+\n+/// For generic cases like inline-assemply/mod/etc\n+const LABELS_HIR_ONLY: &[&[&str]] = &[\n+    BASE_HIR,\n+];\n+\n+/// Impl DepNodes\n+const LABELS_IMPL: &[&[&str]] = &[\n+    BASE_HIR,\n+    BASE_IMPL,\n+];\n+\n+/// Abstract Data Type (Struct, Enum, Unions) DepNodes\n+const LABELS_ADT: &[&[&str]] = &[\n+    BASE_HIR,\n+    BASE_STRUCT,\n+];\n+\n+/// Trait Definition DepNodes\n+#[allow(dead_code)]\n+const LABELS_TRAIT: &[&[&str]] = &[\n+    BASE_HIR,\n+    BASE_TRAIT_DEF,\n+];\n+\n+\n+// FIXME: Struct/Enum/Unions Fields (there is currently no way to attach these)\n+//\n+// Fields are kind of separate from their containers, as they can change independently from\n+// them. We should at least check\n+//\n+//     TypeOfItem for these.\n \n type Labels = HashSet<String>;\n \n+/// Represents the requested configuration by rustc_clean/dirty\n+struct Assertion {\n+    clean: Labels,\n+    dirty: Labels,\n+}\n+\n+impl Assertion {\n+    fn from_clean_labels(labels: Labels) -> Assertion {\n+        Assertion {\n+            clean: labels,\n+            dirty: Labels::new(),\n+        }\n+    }\n+\n+    fn from_dirty_labels(labels: Labels) -> Assertion {\n+        Assertion {\n+            clean: Labels::new(),\n+            dirty: labels,\n+        }\n+    }\n+}\n+\n pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // can't add `#[rustc_dirty]` etc without opting in to this feature\n     if !tcx.sess.features.borrow().rustc_attrs {\n@@ -91,14 +266,189 @@ pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n }\n \n impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n-    fn labels(&self, attr: &Attribute) -> Labels {\n+\n+    /// Possibly \"deserialize\" the attribute into a clean/dirty assertion\n+    fn assertion_maybe(&mut self, item_id: ast::NodeId, attr: &Attribute)\n+        -> Option<Assertion>\n+    {\n+        let is_clean = if attr.check_name(ATTR_DIRTY) {\n+            false\n+        } else if attr.check_name(ATTR_CLEAN) {\n+            true\n+        } else {\n+            // skip: not rustc_clean/dirty\n+            return None\n+        };\n+        if !check_config(self.tcx, attr) {\n+            // skip: not the correct `cfg=`\n+            return None;\n+        }\n+        let assertion = if let Some(labels) = self.labels(attr) {\n+            if is_clean {\n+                Assertion::from_clean_labels(labels)\n+            } else {\n+                Assertion::from_dirty_labels(labels)\n+            }\n+        } else {\n+            self.assertion_auto(item_id, attr, is_clean)\n+        };\n+        Some(assertion)\n+    }\n+\n+    /// Get the \"auto\" assertion on pre-validated attr, along with the `except` labels\n+    fn assertion_auto(&mut self, item_id: ast::NodeId, attr: &Attribute, is_clean: bool)\n+        -> Assertion\n+    {\n+        let (name, mut auto) = self.auto_labels(item_id, attr);\n+        let except = self.except(attr);\n+        for e in except.iter() {\n+            if !auto.remove(e) {\n+                let msg = format!(\n+                    \"`except` specified DepNodes that can not be affected for \\\"{}\\\": \\\"{}\\\"\",\n+                    name,\n+                    e\n+                );\n+                self.tcx.sess.span_fatal(attr.span, &msg);\n+            }\n+        }\n+        if is_clean {\n+            Assertion {\n+                clean: auto,\n+                dirty: except,\n+            }\n+        } else {\n+            Assertion {\n+                clean: except,\n+                dirty: auto,\n+            }\n+        }\n+    }\n+\n+    fn labels(&self, attr: &Attribute) -> Option<Labels> {\n         for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n             if item.check_name(LABEL) {\n+                let value = expect_associated_value(self.tcx, &item);\n+                return Some(self.resolve_labels(&item, value.as_str().as_ref()));\n+            }\n+        }\n+        None\n+    }\n+\n+    /// `except=` attribute value\n+    fn except(&self, attr: &Attribute) -> Labels {\n+        for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n+            if item.check_name(EXCEPT) {\n                 let value = expect_associated_value(self.tcx, &item);\n                 return self.resolve_labels(&item, value.as_str().as_ref());\n             }\n         }\n-        self.tcx.sess.span_fatal(attr.span, \"no `label` found\");\n+        // if no `label` or `except` is given, only the node's group are asserted\n+        Labels::new()\n+    }\n+\n+    /// Return all DepNode labels that should be asserted for this item.\n+    /// index=0 is the \"name\" used for error messages\n+    fn auto_labels(&mut self, item_id: ast::NodeId, attr: &Attribute) -> (&'static str, Labels) {\n+        let node = self.tcx.hir.get(item_id);\n+        let (name, labels) = match node {\n+            HirNode::NodeItem(item) => {\n+                match item.node {\n+                    // note: these are in the same order as hir::Item_;\n+                    // FIXME(michaelwoerister): do commented out ones\n+\n+                    // // An `extern crate` item, with optional original crate name,\n+                    // HirItem::ItemExternCrate(..),  // intentionally no assertions\n+\n+                    // // `use foo::bar::*;` or `use foo::bar::baz as quux;`\n+                    // HirItem::ItemUse(..),  // intentionally no assertions\n+\n+                    // A `static` item\n+                    HirItem::ItemStatic(..) => (\"ItemStatic\", LABELS_CONST),\n+\n+                    // A `const` item\n+                    HirItem::ItemConst(..) => (\"ItemConst\", LABELS_CONST),\n+\n+                    // A function declaration\n+                    HirItem::ItemFn(..) => (\"ItemFn\", LABELS_FN),\n+\n+                    // // A module\n+                    HirItem::ItemMod(..) =>(\"ItemMod\", LABELS_HIR_ONLY),\n+\n+                    // // An external module\n+                    HirItem::ItemForeignMod(..) => (\"ItemForeignMod\", LABELS_HIR_ONLY),\n+\n+                    // Module-level inline assembly (from global_asm!)\n+                    HirItem::ItemGlobalAsm(..) => (\"ItemGlobalAsm\", LABELS_HIR_ONLY),\n+\n+                    // A type alias, e.g. `type Foo = Bar<u8>`\n+                    HirItem::ItemTy(..) => (\"ItemTy\", LABELS_HIR_ONLY),\n+\n+                    // An enum definition, e.g. `enum Foo<A, B> {C<A>, D<B>}`\n+                    HirItem::ItemEnum(..) => (\"ItemEnum\", LABELS_ADT),\n+\n+                    // A struct definition, e.g. `struct Foo<A> {x: A}`\n+                    HirItem::ItemStruct(..) => (\"ItemStruct\", LABELS_ADT),\n+\n+                    // A union definition, e.g. `union Foo<A, B> {x: A, y: B}`\n+                    HirItem::ItemUnion(..) => (\"ItemUnion\", LABELS_ADT),\n+\n+                    // Represents a Trait Declaration\n+                    // FIXME(michaelwoerister): trait declaration is buggy because sometimes some of\n+                    // the depnodes don't exist (because they legitametely didn't need to be\n+                    // calculated)\n+                    //\n+                    // michaelwoerister and vitiral came up with a possible solution,\n+                    // to just do this before every query\n+                    // ```\n+                    // ::rustc::ty::maps::plumbing::force_from_dep_node(tcx, dep_node)\n+                    // ```\n+                    //\n+                    // However, this did not seem to work effectively and more bugs were hit.\n+                    // Nebie @vitiral gave up :)\n+                    //\n+                    //HirItem::ItemTrait(..) => (\"ItemTrait\", LABELS_TRAIT),\n+\n+                    // `impl Trait for .. {}`\n+                    HirItem::ItemDefaultImpl(..) => (\"ItemDefaultImpl\", LABELS_IMPL),\n+\n+                    // An implementation, eg `impl<A> Trait for Foo { .. }`\n+                    HirItem::ItemImpl(..) => (\"ItemImpl\", LABELS_IMPL),\n+\n+                    _ => self.tcx.sess.span_fatal(\n+                        attr.span,\n+                        &format!(\n+                            \"clean/dirty auto-assertions not yet defined for NodeItem.node={:?}\",\n+                            item.node\n+                        )\n+                    ),\n+                }\n+            },\n+            HirNode::NodeTraitItem(item) => {\n+                match item.node {\n+                    TraitItemKind::Method(..) => (\"NodeTraitItem\", LABELS_FN_IN_TRAIT),\n+                    TraitItemKind::Const(..) => (\"NodeTraitConst\", LABELS_CONST_IN_TRAIT),\n+                    TraitItemKind::Type(..) => (\"NodeTraitType\", LABELS_CONST_IN_TRAIT),\n+                }\n+            },\n+            HirNode::NodeImplItem(item) => {\n+                match item.node {\n+                    ImplItemKind::Method(..) => (\"NodeImplItem\", LABELS_FN_IN_IMPL),\n+                    ImplItemKind::Const(..) => (\"NodeImplConst\", LABELS_CONST_IN_IMPL),\n+                    ImplItemKind::Type(..) => (\"NodeImplType\", LABELS_CONST_IN_IMPL),\n+                }\n+            },\n+            _ => self.tcx.sess.span_fatal(\n+                attr.span,\n+                &format!(\n+                    \"clean/dirty auto-assertions not yet defined for {:?}\",\n+                    node\n+                )\n+            ),\n+        };\n+        let labels = Labels::from_iter(\n+            labels.iter().flat_map(|s| s.iter().map(|l| l.to_string()))\n+        );\n+        (name, labels)\n     }\n \n     fn resolve_labels(&self, item: &NestedMetaItem, value: &str) -> Labels {\n@@ -174,22 +524,16 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n     fn check_item(&mut self, item_id: ast::NodeId, item_span: Span) {\n         let def_id = self.tcx.hir.local_def_id(item_id);\n         for attr in self.tcx.get_attrs(def_id).iter() {\n-            if attr.check_name(ATTR_DIRTY) {\n-                if check_config(self.tcx, attr) {\n-                    self.checked_attrs.insert(attr.id);\n-                    let labels = self.labels(attr);\n-                    for dep_node in self.dep_nodes(&labels, def_id) {\n-                        self.assert_dirty(item_span, dep_node);\n-                    }\n-                }\n-            } else if attr.check_name(ATTR_CLEAN) {\n-                if check_config(self.tcx, attr) {\n-                    self.checked_attrs.insert(attr.id);\n-                    let labels = self.labels(attr);\n-                    for dep_node in self.dep_nodes(&labels, def_id) {\n-                        self.assert_clean(item_span, dep_node);\n-                    }\n-                }\n+            let assertion = match self.assertion_maybe(item_id, attr) {\n+                Some(a) => a,\n+                None => continue,\n+            };\n+            self.checked_attrs.insert(attr.id);\n+            for dep_node in self.dep_nodes(&assertion.clean, def_id) {\n+                self.assert_clean(item_span, dep_node);\n+            }\n+            for dep_node in self.dep_nodes(&assertion.dirty, def_id) {\n+                self.assert_dirty(item_span, dep_node);\n             }\n         }\n     }\n@@ -363,21 +707,42 @@ impl<'a, 'tcx, 'm> DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {\n /// Given a `#[rustc_dirty]` or `#[rustc_clean]` attribute, scan\n /// for a `cfg=\"foo\"` attribute and check whether we have a cfg\n /// flag called `foo`.\n+///\n+/// Also make sure that the `label` and `except` fields do not\n+/// both exist.\n fn check_config(tcx: TyCtxt, attr: &Attribute) -> bool {\n     debug!(\"check_config(attr={:?})\", attr);\n     let config = &tcx.sess.parse_sess.config;\n     debug!(\"check_config: config={:?}\", config);\n+    let (mut cfg, mut except, mut label) = (None, false, false);\n     for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n         if item.check_name(CFG) {\n             let value = expect_associated_value(tcx, &item);\n             debug!(\"check_config: searching for cfg {:?}\", value);\n-            return config.contains(&(value, None));\n+            cfg = Some(config.contains(&(value, None)));\n+        }\n+        if item.check_name(LABEL) {\n+            label = true;\n+        }\n+        if item.check_name(EXCEPT) {\n+            except = true;\n         }\n     }\n \n-    tcx.sess.span_fatal(\n-        attr.span,\n-        \"no cfg attribute\");\n+    if label && except {\n+        tcx.sess.span_fatal(\n+            attr.span,\n+            \"must specify only one of: `label`, `except`\"\n+        );\n+    }\n+\n+    match cfg {\n+        None => tcx.sess.span_fatal(\n+            attr.span,\n+            \"no cfg attribute\"\n+        ),\n+        Some(c) => c,\n+    }\n }\n \n fn expect_associated_value(tcx: TyCtxt, item: &NestedMetaItem) -> ast::Name {"}, {"sha": "7d1400b6b95a5a423097a361390ed45d63d0e572", "filename": "src/librustc_incremental/persist/file_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -117,7 +117,7 @@ fn report_format_mismatch(sess: &Session, file: &Path, message: &str) {\n     debug!(\"read_file: {}\", message);\n \n     if sess.opts.debugging_opts.incremental_info {\n-        eprintln!(\"incremental: ignoring cache artifact `{}`: {}\",\n+        println!(\"[incremental] ignoring cache artifact `{}`: {}\",\n                   file.file_name().unwrap().to_string_lossy(),\n                   message);\n     }"}, {"sha": "d53ee5c804f601d5190be2d5444568217e71bcc3", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -256,11 +256,12 @@ pub fn prepare_session_directory(sess: &Session,\n         debug!(\"attempting to copy data from source: {}\",\n                source_directory.display());\n \n-        let print_file_copy_stats = sess.opts.debugging_opts.incremental_info;\n+\n \n         // Try copying over all files from the source directory\n-        if let Ok(allows_links) = copy_files(&session_dir, &source_directory,\n-                                             print_file_copy_stats) {\n+        if let Ok(allows_links) = copy_files(sess,\n+                                             &session_dir,\n+                                             &source_directory) {\n             debug!(\"successfully copied data from: {}\",\n                    source_directory.display());\n \n@@ -390,9 +391,9 @@ pub fn delete_all_session_dir_contents(sess: &Session) -> io::Result<()> {\n     Ok(())\n }\n \n-fn copy_files(target_dir: &Path,\n-              source_dir: &Path,\n-              print_stats_on_success: bool)\n+fn copy_files(sess: &Session,\n+              target_dir: &Path,\n+              source_dir: &Path)\n               -> Result<bool, ()> {\n     // We acquire a shared lock on the lock file of the directory, so that\n     // nobody deletes it out from under us while we are reading from it.\n@@ -440,9 +441,11 @@ fn copy_files(target_dir: &Path,\n         }\n     }\n \n-    if print_stats_on_success {\n-        eprintln!(\"incremental: session directory: {} files hard-linked\", files_linked);\n-        eprintln!(\"incremental: session directory: {} files copied\", files_copied);\n+    if sess.opts.debugging_opts.incremental_info {\n+        println!(\"[incremental] session directory: \\\n+                  {} files hard-linked\", files_linked);\n+        println!(\"[incremental] session directory: \\\n+                 {} files copied\", files_copied);\n     }\n \n     Ok(files_linked > 0 || files_copied == 0)"}, {"sha": "63cfbcac1452e0647749f5a9891360f8b5536724", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -177,8 +177,8 @@ pub fn load_dep_graph(sess: &Session) -> PreviousDepGraph {\n \n         if prev_commandline_args_hash != sess.opts.dep_tracking_hash() {\n             if sess.opts.debugging_opts.incremental_info {\n-                eprintln!(\"incremental: completely ignoring cache because of \\\n-                           differing commandline arguments\");\n+                println!(\"[incremental] completely ignoring cache because of \\\n+                          differing commandline arguments\");\n             }\n             // We can't reuse the cache, purge it.\n             debug!(\"load_dep_graph_new: differing commandline arg hashes\");"}, {"sha": "b9f73500e273ba8cbf88ca69c5012c941029da3d", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 72, "deletions": 1, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::dep_graph::DepGraph;\n+use rustc::dep_graph::{DepGraph, DepKind};\n use rustc::hir::def_id::DefId;\n use rustc::hir::svh::Svh;\n use rustc::ich::Fingerprint;\n@@ -170,6 +170,77 @@ fn encode_dep_graph(tcx: TyCtxt,\n \n     // Encode the graph data.\n     let serialized_graph = tcx.dep_graph.serialize();\n+\n+    if tcx.sess.opts.debugging_opts.incremental_info {\n+        #[derive(Clone)]\n+        struct Stat {\n+            kind: DepKind,\n+            node_counter: u64,\n+            edge_counter: u64,\n+        }\n+\n+        let total_node_count = serialized_graph.nodes.len();\n+        let total_edge_count = serialized_graph.edge_list_data.len();\n+\n+        let mut counts: FxHashMap<_, Stat> = FxHashMap();\n+\n+        for (i, &(node, _)) in serialized_graph.nodes.iter_enumerated() {\n+            let stat = counts.entry(node.kind).or_insert(Stat {\n+                kind: node.kind,\n+                node_counter: 0,\n+                edge_counter: 0,\n+            });\n+\n+            stat.node_counter += 1;\n+            let (edge_start, edge_end) = serialized_graph.edge_list_indices[i];\n+            stat.edge_counter += (edge_end - edge_start) as u64;\n+        }\n+\n+        let mut counts: Vec<_> = counts.values().cloned().collect();\n+        counts.sort_by_key(|s| -(s.node_counter as i64));\n+\n+        let percentage_of_all_nodes: Vec<f64> = counts.iter().map(|s| {\n+            (100.0 * (s.node_counter as f64)) / (total_node_count as f64)\n+        }).collect();\n+\n+        let average_edges_per_kind: Vec<f64> = counts.iter().map(|s| {\n+            (s.edge_counter as f64) / (s.node_counter as f64)\n+        }).collect();\n+\n+        println!(\"[incremental]\");\n+        println!(\"[incremental] DepGraph Statistics\");\n+\n+        const SEPARATOR: &str = \"[incremental] --------------------------------\\\n+                                 ----------------------------------------------\\\n+                                 ------------\";\n+\n+        println!(\"{}\", SEPARATOR);\n+        println!(\"[incremental]\");\n+        println!(\"[incremental] Total Node Count: {}\", total_node_count);\n+        println!(\"[incremental] Total Edge Count: {}\", total_edge_count);\n+        println!(\"[incremental]\");\n+        println!(\"[incremental]  {:<36}| {:<17}| {:<12}| {:<17}|\",\n+                 \"Node Kind\",\n+                 \"Node Frequency\",\n+                 \"Node Count\",\n+                 \"Avg. Edge Count\");\n+        println!(\"[incremental] -------------------------------------\\\n+                  |------------------\\\n+                  |-------------\\\n+                  |------------------|\");\n+\n+        for (i, stat) in counts.iter().enumerate() {\n+            println!(\"[incremental]  {:<36}|{:>16.1}% |{:>12} |{:>17.1} |\",\n+                format!(\"{:?}\", stat.kind),\n+                percentage_of_all_nodes[i],\n+                stat.node_counter,\n+                average_edges_per_kind[i]);\n+        }\n+\n+        println!(\"{}\", SEPARATOR);\n+        println!(\"[incremental]\");\n+    }\n+\n     serialized_graph.encode(encoder)?;\n \n     Ok(())"}, {"sha": "cebf52d5af7a9c2cf4f2686617bb3e60fdb5f1cd", "filename": "src/librustc_lint/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2FCargo.toml?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -12,7 +12,6 @@ test = false\n [dependencies]\n log = \"0.3\"\n rustc = { path = \"../librustc\" }\n-rustc_back = { path = \"../librustc_back\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "4ba7f7aa951f75c50de6c82a5c687a1dbe03f482", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -38,7 +38,6 @@ extern crate syntax;\n extern crate rustc;\n #[macro_use]\n extern crate log;\n-extern crate rustc_back;\n extern crate rustc_const_eval;\n extern crate syntax_pos;\n \n@@ -129,7 +128,6 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                  NonUpperCaseGlobals,\n                  NonShorthandFieldPatterns,\n                  UnsafeCode,\n-                 UnusedMut,\n                  UnusedAllocation,\n                  MissingCopyImplementations,\n                  UnstableFeatures,"}, {"sha": "a058f84e58806da255b7b2ade7159e7263301795", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 88, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -11,105 +11,18 @@\n use rustc::hir::def_id::DefId;\n use rustc::ty;\n use rustc::ty::adjustment;\n-use util::nodemap::FxHashMap;\n use lint::{LateContext, EarlyContext, LintContext, LintArray};\n use lint::{LintPass, EarlyLintPass, LateLintPass};\n \n-use std::collections::hash_map::Entry::{Occupied, Vacant};\n-\n use syntax::ast;\n use syntax::attr;\n use syntax::feature_gate::{BUILTIN_ATTRIBUTES, AttributeType};\n-use syntax::symbol::keywords;\n-use syntax::ptr::P;\n use syntax::print::pprust;\n+use syntax::symbol::keywords;\n use syntax::util::parser;\n use syntax_pos::Span;\n \n-use rustc_back::slice;\n use rustc::hir;\n-use rustc::hir::intravisit::FnKind;\n-\n-declare_lint! {\n-    pub UNUSED_MUT,\n-    Warn,\n-    \"detect mut variables which don't need to be mutable\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct UnusedMut;\n-\n-impl UnusedMut {\n-    fn check_unused_mut_pat(&self, cx: &LateContext, pats: &[P<hir::Pat>]) {\n-        // collect all mutable pattern and group their NodeIDs by their Identifier to\n-        // avoid false warnings in match arms with multiple patterns\n-\n-        let mut mutables = FxHashMap();\n-        for p in pats {\n-            p.each_binding(|_, id, span, path1| {\n-                let hir_id = cx.tcx.hir.node_to_hir_id(id);\n-                let bm = match cx.tables.pat_binding_modes().get(hir_id) {\n-                    Some(&bm) => bm,\n-                    None => span_bug!(span, \"missing binding mode\"),\n-                };\n-                let name = path1.node;\n-                if let ty::BindByValue(hir::MutMutable) = bm {\n-                    if !name.as_str().starts_with(\"_\") {\n-                        match mutables.entry(name) {\n-                            Vacant(entry) => {\n-                                entry.insert(vec![id]);\n-                            }\n-                            Occupied(mut entry) => {\n-                                entry.get_mut().push(id);\n-                            }\n-                        }\n-                    }\n-                }\n-            });\n-        }\n-\n-        let used_mutables = cx.tcx.used_mut_nodes.borrow();\n-        for (_, v) in &mutables {\n-            if !v.iter().any(|e| used_mutables.contains(e)) {\n-                let binding_span = cx.tcx.hir.span(v[0]);\n-                let mut_span = cx.tcx.sess.codemap().span_until_char(binding_span, ' ');\n-                let mut err = cx.struct_span_lint(UNUSED_MUT,\n-                                                  binding_span,\n-                                                  \"variable does not need to be mutable\");\n-                err.span_suggestion_short(mut_span, \"remove this `mut`\", \"\".to_owned());\n-                err.emit();\n-            }\n-        }\n-    }\n-}\n-\n-impl LintPass for UnusedMut {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_MUT)\n-    }\n-}\n-\n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedMut {\n-    fn check_arm(&mut self, cx: &LateContext, a: &hir::Arm) {\n-        self.check_unused_mut_pat(cx, &a.pats)\n-    }\n-\n-    fn check_local(&mut self, cx: &LateContext, l: &hir::Local) {\n-        self.check_unused_mut_pat(cx, slice::ref_slice(&l.pat));\n-    }\n-\n-    fn check_fn(&mut self,\n-                cx: &LateContext,\n-                _: FnKind,\n-                _: &hir::FnDecl,\n-                body: &hir::Body,\n-                _: Span,\n-                _: ast::NodeId) {\n-        for a in &body.arguments {\n-            self.check_unused_mut_pat(cx, slice::ref_slice(&a.pat));\n-        }\n-    }\n-}\n \n declare_lint! {\n     pub UNUSED_MUST_USE,"}, {"sha": "a9566c4bcacd7e791d2ac470632e4c46714b7bdb", "filename": "src/librustc_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2FCargo.toml?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -18,4 +18,4 @@ rustc_cratesio_shim = { path = \"../librustc_cratesio_shim\" }\n \n [build-dependencies]\n build_helper = { path = \"../build_helper\" }\n-cc = \"1.0\"\n+cc = \"1.0.1\""}, {"sha": "ff923ce259fb45c904a3d94059657bff8f514feb", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 239, "deletions": 38, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -14,7 +14,7 @@ use rustc::hir::def_id::{DefId};\n use rustc::infer::{InferCtxt};\n use rustc::ty::{self, TyCtxt, ParamEnv};\n use rustc::ty::maps::Providers;\n-use rustc::mir::{AssertMessage, BasicBlock, BorrowKind, Location, Lvalue};\n+use rustc::mir::{AssertMessage, BasicBlock, BorrowKind, Location, Lvalue, Local};\n use rustc::mir::{Mir, Mutability, Operand, Projection, ProjectionElem, Rvalue};\n use rustc::mir::{Statement, StatementKind, Terminator, TerminatorKind};\n use rustc::mir::transform::{MirSource};\n@@ -586,7 +586,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                                                 context: Context,\n                                                 (lvalue, span): (&Lvalue<'gcx>, Span),\n                                                 flow_state: &InProgress<'b, 'gcx>) {\n-        let move_data = flow_state.inits.base_results.operator().move_data();\n+        let move_data = self.move_data;\n \n         // determine if this path has a non-mut owner (and thus needs checking).\n         let mut l = lvalue;\n@@ -611,7 +611,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n             }\n         }\n \n-        if let Some(mpi) = self.move_path_for_lvalue(context, move_data, lvalue) {\n+        if let Some(mpi) = self.move_path_for_lvalue(lvalue) {\n             if flow_state.inits.curr_state.contains(&mpi) {\n                 // may already be assigned before reaching this statement;\n                 // report error.\n@@ -642,29 +642,115 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n         let lvalue = self.base_path(lvalue_span.0);\n \n         let maybe_uninits = &flow_state.uninits;\n-        let move_data = maybe_uninits.base_results.operator().move_data();\n-        if let Some(mpi) = self.move_path_for_lvalue(context, move_data, lvalue) {\n-            if maybe_uninits.curr_state.contains(&mpi) {\n-                // find and report move(s) that could cause this to be uninitialized\n+\n+        // Bad scenarios:\n+        //\n+        // 1. Move of `a.b.c`, use of `a.b.c`\n+        // 2. Move of `a.b.c`, use of `a.b.c.d` (without first reinitializing `a.b.c.d`)\n+        // 3. Move of `a.b.c`, use of `a` or `a.b`\n+        // 4. Uninitialized `(a.b.c: &_)`, use of `*a.b.c`; note that with\n+        //    partial initialization support, one might have `a.x`\n+        //    initialized but not `a.b`.\n+        //\n+        // OK scenarios:\n+        //\n+        // 5. Move of `a.b.c`, use of `a.b.d`\n+        // 6. Uninitialized `a.x`, initialized `a.b`, use of `a.b`\n+        // 7. Copied `(a.b: &_)`, use of `*(a.b).c`; note that `a.b`\n+        //    must have been initialized for the use to be sound.\n+        // 8. Move of `a.b.c` then reinit of `a.b.c.d`, use of `a.b.c.d`\n+\n+        // The dataflow tracks shallow prefixes distinctly (that is,\n+        // field-accesses on P distinctly from P itself), in order to\n+        // track substructure initialization separately from the whole\n+        // structure.\n+        //\n+        // E.g., when looking at (*a.b.c).d, if the closest prefix for\n+        // which we have a MovePath is `a.b`, then that means that the\n+        // initialization state of `a.b` is all we need to inspect to\n+        // know if `a.b.c` is valid (and from that we infer that the\n+        // dereference and `.d` access is also valid, since we assume\n+        // `a.b.c` is assigned a reference to a initialized and\n+        // well-formed record structure.)\n+\n+        // Therefore, if we seek out the *closest* prefix for which we\n+        // have a MovePath, that should capture the initialization\n+        // state for the lvalue scenario.\n+        //\n+        // This code covers scenarios 1, 2, and 4.\n+\n+        debug!(\"check_if_path_is_moved part1 lvalue: {:?}\", lvalue);\n+        match self.move_path_closest_to(lvalue) {\n+            Ok(mpi) => {\n+                if maybe_uninits.curr_state.contains(&mpi) {\n+                    self.report_use_of_moved(context, desired_action, lvalue_span);\n+                    return; // don't bother finding other problems.\n+                }\n+            }\n+            Err(NoMovePathFound::ReachedStatic) => {\n+                // Okay: we do not build MoveData for static variables\n+            }\n+\n+            // Only query longest prefix with a MovePath, not further\n+            // ancestors; dataflow recurs on children when parents\n+            // move (to support partial (re)inits).\n+            //\n+            // (I.e. querying parents breaks scenario 8; but may want\n+            // to do such a query based on partial-init feature-gate.)\n+        }\n+\n+        // A move of any shallow suffix of `lvalue` also interferes\n+        // with an attempt to use `lvalue`. This is scenario 3 above.\n+        //\n+        // (Distinct from handling of scenarios 1+2+4 above because\n+        // `lvalue` does not interfere with suffixes of its prefixes,\n+        // e.g. `a.b.c` does not interfere with `a.b.d`)\n+\n+        debug!(\"check_if_path_is_moved part2 lvalue: {:?}\", lvalue);\n+        if let Some(mpi) = self.move_path_for_lvalue(lvalue) {\n+            if let Some(_) = maybe_uninits.has_any_child_of(mpi) {\n                 self.report_use_of_moved(context, desired_action, lvalue_span);\n-            } else {\n-                // sanity check: initialized on *some* path, right?\n-                assert!(flow_state.inits.curr_state.contains(&mpi));\n+                return; // don't bother finding other problems.\n             }\n         }\n     }\n \n+    /// Currently MoveData does not store entries for all lvalues in\n+    /// the input MIR. For example it will currently filter out\n+    /// lvalues that are Copy; thus we do not track lvalues of shared\n+    /// reference type. This routine will walk up an lvalue along its\n+    /// prefixes, searching for a foundational lvalue that *is*\n+    /// tracked in the MoveData.\n+    ///\n+    /// An Err result includes a tag indicated why the search failed.\n+    /// Currenly this can only occur if the lvalue is built off of a\n+    /// static variable, as we do not track those in the MoveData.\n+    fn move_path_closest_to(&mut self, lvalue: &Lvalue<'gcx>)\n+                            -> Result<MovePathIndex, NoMovePathFound>\n+    {\n+        let mut last_prefix = lvalue;\n+        for prefix in self.prefixes(lvalue, PrefixSet::All) {\n+            if let Some(mpi) = self.move_path_for_lvalue(prefix) {\n+                return Ok(mpi);\n+            }\n+            last_prefix = prefix;\n+        }\n+        match *last_prefix {\n+            Lvalue::Local(_) => panic!(\"should have move path for every Local\"),\n+            Lvalue::Projection(_) => panic!(\"PrefixSet::All meant dont stop for Projection\"),\n+            Lvalue::Static(_) => return Err(NoMovePathFound::ReachedStatic),\n+        }\n+    }\n+\n     fn move_path_for_lvalue(&mut self,\n-                            _context: Context,\n-                            move_data: &MoveData<'gcx>,\n                             lvalue: &Lvalue<'gcx>)\n                             -> Option<MovePathIndex>\n     {\n         // If returns None, then there is no move path corresponding\n         // to a direct owner of `lvalue` (which means there is nothing\n         // that borrowck tracks for its analysis).\n \n-        match move_data.rev_lookup.find(lvalue) {\n+        match self.move_data.rev_lookup.find(lvalue) {\n             LookupResult::Parent(_) => None,\n             LookupResult::Exact(mpi) => Some(mpi),\n         }\n@@ -733,6 +819,11 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum NoMovePathFound {\n+    ReachedStatic,\n+}\n+\n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n     fn each_borrow_involving_path<F>(&mut self,\n                                      _context: Context,\n@@ -846,12 +937,19 @@ mod prefixes {\n \n     #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n     pub(super) enum PrefixSet {\n+        /// Doesn't stop until it returns the base case (a Local or\n+        /// Static prefix).\n         All,\n+        /// Stops at any dereference.\n         Shallow,\n+        /// Stops at the deref of a shared reference.\n         Supporting,\n     }\n \n     impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+        /// Returns an iterator over the prefixes of `lvalue`\n+        /// (inclusive) from longest to smallest, potentially\n+        /// terminating the iteration early based on `kind`.\n         pub(super) fn prefixes<'d>(&self,\n                                    lvalue: &'d Lvalue<'gcx>,\n                                    kind: PrefixSet)\n@@ -1080,49 +1178,52 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     // End-user visible description of `lvalue`\n     fn describe_lvalue(&self, lvalue: &Lvalue) -> String {\n         let mut buf = String::new();\n-        self.append_lvalue_to_string(lvalue, &mut buf);\n+        self.append_lvalue_to_string(lvalue, &mut buf, None);\n         buf\n     }\n \n     // Appends end-user visible description of `lvalue` to `buf`.\n-    fn append_lvalue_to_string(&self, lvalue: &Lvalue, buf: &mut String) {\n+    fn append_lvalue_to_string(&self, lvalue: &Lvalue, buf: &mut String, autoderef: Option<bool>) {\n         match *lvalue {\n             Lvalue::Local(local) => {\n-                let local = &self.mir.local_decls[local];\n-                match local.name {\n-                    Some(name) => buf.push_str(&format!(\"{}\", name)),\n-                    None => buf.push_str(\"_\"),\n-                }\n+                self.append_local_to_string(local, buf, \"_\");\n             }\n             Lvalue::Static(ref static_) => {\n                 buf.push_str(&format!(\"{}\", &self.tcx.item_name(static_.def_id)));\n             }\n             Lvalue::Projection(ref proj) => {\n+                let mut autoderef = autoderef.unwrap_or(false);\n                 let (prefix, suffix, index_operand) = match proj.elem {\n-                    ProjectionElem::Deref =>\n-                        (\"(*\", format!(\")\"), None),\n+                    ProjectionElem::Deref => {\n+                        if autoderef {\n+                            (\"\", format!(\"\"), None)\n+                        } else {\n+                            (\"(*\", format!(\")\"), None)\n+                        }\n+                    },\n                     ProjectionElem::Downcast(..) =>\n                         (\"\",   format!(\"\"), None), // (dont emit downcast info)\n-                    ProjectionElem::Field(field, _ty) =>\n-                        (\"\",   format!(\".{}\", field.index()), None), // FIXME: report name of field\n-                    ProjectionElem::Index(index) =>\n-                        (\"\",   format!(\"\"), Some(index)),\n-                    ProjectionElem::ConstantIndex { offset, min_length, from_end: true } =>\n-                        (\"\",   format!(\"[{} of {}]\", offset, min_length), None),\n-                    ProjectionElem::ConstantIndex { offset, min_length, from_end: false } =>\n-                        (\"\",   format!(\"[-{} of {}]\", offset, min_length), None),\n-                    ProjectionElem::Subslice { from, to: 0 } =>\n-                        (\"\",   format!(\"[{}:]\", from), None),\n-                    ProjectionElem::Subslice { from: 0, to } =>\n-                        (\"\",   format!(\"[:-{}]\", to), None),\n-                    ProjectionElem::Subslice { from, to } =>\n-                        (\"\",   format!(\"[{}:-{}]\", from, to), None),\n+                    ProjectionElem::Field(field, _ty) => {\n+                        autoderef = true;\n+                        (\"\", format!(\".{}\", self.describe_field(&proj.base, field.index())), None)\n+                    },\n+                    ProjectionElem::Index(index) => {\n+                        autoderef = true;\n+                        (\"\",   format!(\"\"), Some(index))\n+                    },\n+                    ProjectionElem::ConstantIndex { .. } | ProjectionElem::Subslice { .. } => {\n+                        autoderef = true;\n+                        // Since it isn't possible to borrow an element on a particular index and\n+                        // then use another while the borrow is held, don't output indices details\n+                        // to avoid confusing the end-user\n+                        (\"\",   format!(\"[..]\"), None)\n+                    },\n                 };\n                 buf.push_str(prefix);\n-                self.append_lvalue_to_string(&proj.base, buf);\n+                self.append_lvalue_to_string(&proj.base, buf, Some(autoderef));\n                 if let Some(index) = index_operand {\n                     buf.push_str(\"[\");\n-                    self.append_lvalue_to_string(&Lvalue::Local(index), buf);\n+                    self.append_local_to_string(index, buf, \"..\");\n                     buf.push_str(\"]\");\n                 } else {\n                     buf.push_str(&suffix);\n@@ -1131,6 +1232,77 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n         }\n     }\n \n+    // Appends end-user visible description of the `local` lvalue to `buf`. If `local` doesn't have\n+    // a name, then `none_string` is appended instead\n+    fn append_local_to_string(&self, local_index: Local, buf: &mut String, none_string: &str) {\n+        let local = &self.mir.local_decls[local_index];\n+        match local.name {\n+            Some(name) => buf.push_str(&format!(\"{}\", name)),\n+            None => buf.push_str(none_string)\n+        }\n+    }\n+\n+    // End-user visible description of the `field_index`nth field of `base`\n+    fn describe_field(&self, base: &Lvalue, field_index: usize) -> String {\n+        match *base {\n+            Lvalue::Local(local) => {\n+                let local = &self.mir.local_decls[local];\n+                self.describe_field_from_ty(&local.ty, field_index)\n+            },\n+            Lvalue::Static(ref static_) => {\n+                self.describe_field_from_ty(&static_.ty, field_index)\n+            },\n+            Lvalue::Projection(ref proj) => {\n+                match proj.elem {\n+                    ProjectionElem::Deref =>\n+                        self.describe_field(&proj.base, field_index),\n+                    ProjectionElem::Downcast(def, variant_index) =>\n+                        format!(\"{}\", def.variants[variant_index].fields[field_index].name),\n+                    ProjectionElem::Field(_, field_type) =>\n+                        self.describe_field_from_ty(&field_type, field_index),\n+                    ProjectionElem::Index(..)\n+                    | ProjectionElem::ConstantIndex { .. }\n+                    | ProjectionElem::Subslice { .. } =>\n+                        format!(\"{}\", self.describe_field(&proj.base, field_index)),\n+                }\n+            }\n+        }\n+    }\n+\n+    // End-user visible description of the `field_index`nth field of `ty`\n+    fn describe_field_from_ty(&self, ty: &ty::Ty, field_index: usize) -> String {\n+        if ty.is_box() {\n+            // If the type is a box, the field is described from the boxed type\n+            self.describe_field_from_ty(&ty.boxed_ty(), field_index)\n+        }\n+        else {\n+            match ty.sty {\n+                ty::TyAdt(def, _) => {\n+                    if def.is_enum() {\n+                        format!(\"{}\", field_index)\n+                    }\n+                    else {\n+                        format!(\"{}\", def.struct_variant().fields[field_index].name)\n+                    }\n+                },\n+                ty::TyTuple(_, _) => {\n+                    format!(\"{}\", field_index)\n+                },\n+                ty::TyRef(_, tnm) | ty::TyRawPtr(tnm) => {\n+                    self.describe_field_from_ty(&tnm.ty, field_index)\n+                },\n+                ty::TyArray(ty, _) | ty::TySlice(ty) => {\n+                    self.describe_field_from_ty(&ty, field_index)\n+                }\n+                _ => {\n+                    // Might need a revision when the fields in trait RFC is implemented\n+                    // (https://github.com/rust-lang/rfcs/pull/1546)\n+                    bug!(\"End-user description not implemented for field access on `{:?}`\", ty.sty);\n+                }\n+            }\n+        }\n+    }\n+\n     // Retrieve span of given borrow from the current MIR representation\n     fn retrieve_borrow_span(&self, borrow: &BorrowData) -> Span {\n         self.mir.source_info(borrow.location).span\n@@ -1266,6 +1438,35 @@ impl<'b, 'tcx: 'b> InProgress<'b, 'tcx> {\n     }\n }\n \n+impl<'b, 'tcx> FlowInProgress<MaybeUninitializedLvals<'b, 'tcx>> {\n+    fn has_any_child_of(&self, mpi: MovePathIndex) -> Option<MovePathIndex> {\n+        let move_data = self.base_results.operator().move_data();\n+\n+        let mut todo = vec![mpi];\n+        let mut push_siblings = false; // don't look at siblings of original `mpi`.\n+        while let Some(mpi) = todo.pop() {\n+            if self.curr_state.contains(&mpi) {\n+                return Some(mpi);\n+            }\n+            let move_path = &move_data.move_paths[mpi];\n+            if let Some(child) = move_path.first_child {\n+                todo.push(child);\n+            }\n+            if push_siblings {\n+                if let Some(sibling) = move_path.next_sibling {\n+                    todo.push(sibling);\n+                }\n+            } else {\n+                // after we've processed the original `mpi`, we should\n+                // always traverse the siblings of any of its\n+                // children.\n+                push_siblings = true;\n+            }\n+        }\n+        return None;\n+    }\n+}\n+\n impl<BD> FlowInProgress<BD> where BD: BitDenotation {\n     fn each_state_bit<F>(&self, f: F) where F: FnMut(BD::Idx) {\n         self.curr_state.each_bit(self.base_results.operator().bits_per_block(), f)"}, {"sha": "56c926eaa615343ee7737abda5f9ac668871c62f", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -21,7 +21,7 @@ use rustc::mir::*;\n use rustc::hir;\n use hair::*;\n use syntax::ast::{Name, NodeId};\n-use syntax_pos::Span;\n+use syntax_pos::{DUMMY_SP, Span};\n \n // helper functions, broken out by category:\n mod simplify;\n@@ -398,10 +398,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             candidates.iter().take_while(|c| c.match_pairs.is_empty()).count();\n         debug!(\"match_candidates: {:?} candidates fully matched\", fully_matched);\n         let mut unmatched_candidates = candidates.split_off(fully_matched);\n-        for candidate in candidates {\n+        for (index, candidate) in candidates.into_iter().enumerate() {\n             // If so, apply any bindings, test the guard (if any), and\n             // branch to the arm.\n-            if let Some(b) = self.bind_and_guard_matched_candidate(block, arm_blocks, candidate) {\n+            let is_last = index == fully_matched - 1;\n+            if let Some(b) = self.bind_and_guard_matched_candidate(block, arm_blocks,\n+                                                                   candidate, is_last) {\n                 block = b;\n             } else {\n                 // if None is returned, then any remaining candidates\n@@ -664,7 +666,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn bind_and_guard_matched_candidate<'pat>(&mut self,\n                                               mut block: BasicBlock,\n                                               arm_blocks: &mut ArmBlocks,\n-                                              candidate: Candidate<'pat, 'tcx>)\n+                                              candidate: Candidate<'pat, 'tcx>,\n+                                              is_last_arm: bool)\n                                               -> Option<BasicBlock> {\n         debug!(\"bind_and_guard_matched_candidate(block={:?}, candidate={:?})\",\n                block, candidate);\n@@ -685,10 +688,26 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             self.cfg.terminate(block, source_info,\n                                TerminatorKind::if_(self.hir.tcx(), cond, arm_block, otherwise));\n             Some(otherwise)\n+        } else if !is_last_arm {\n+            // Add always true guard in case of more than one arm\n+            // it creates false edges and allow MIR borrowck detects errors\n+            // FIXME(#45184) -- permit \"false edges\"\n+            let source_info = self.source_info(candidate.span);\n+            let true_expr = Expr {\n+                temp_lifetime: None,\n+                ty: self.hir.tcx().types.bool,\n+                span: DUMMY_SP,\n+                kind: ExprKind::Literal{literal: self.hir.true_literal()},\n+            };\n+            let cond = unpack!(block = self.as_local_operand(block, true_expr));\n+            let otherwise = self.cfg.start_new_block();\n+            self.cfg.terminate(block, source_info,\n+                               TerminatorKind::if_(self.hir.tcx(), cond, arm_block, otherwise));\n+            Some(otherwise)\n         } else {\n             let source_info = self.source_info(candidate.span);\n             self.cfg.terminate(block, source_info,\n-                               TerminatorKind::Goto { target: arm_block });\n+                               TerminatorKind::Goto { target: arm_block  });\n             None\n         }\n     }"}, {"sha": "b8bb2a404620e1a95d982c73b9ad0bbcc6bc1afe", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -149,7 +149,7 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n             mem::transmute::<Mir, Mir<'tcx>>(mir)\n         };\n \n-        mir_util::dump_mir(tcx, None, \"mir_map\", &0, src, &mir);\n+        mir_util::dump_mir(tcx, None, \"mir_map\", &0, src, &mir, |_, _| Ok(()) );\n \n         mir\n     })\n@@ -227,7 +227,7 @@ fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 mem::transmute::<Mir, Mir<'tcx>>(mir)\n             };\n \n-            mir_util::dump_mir(tcx, None, \"mir_map\", &0, src, &mir);\n+            mir_util::dump_mir(tcx, None, \"mir_map\", &0, src, &mir, |_, _| Ok(()) );\n \n             mir\n         })"}, {"sha": "98c5345c69d35fbc25c6d8d6260bd693e5d422eb", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 461, "deletions": 0, "changes": 461, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -229,6 +229,57 @@ fn main() {\n See also https://doc.rust-lang.org/book/first-edition/unsafe.html\n \"##,\n \n+E0373: r##\"\n+This error occurs when an attempt is made to use data captured by a closure,\n+when that data may no longer exist. It's most commonly seen when attempting to\n+return a closure:\n+\n+```compile_fail,E0373\n+fn foo() -> Box<Fn(u32) -> u32> {\n+    let x = 0u32;\n+    Box::new(|y| x + y)\n+}\n+```\n+\n+Notice that `x` is stack-allocated by `foo()`. By default, Rust captures\n+closed-over data by reference. This means that once `foo()` returns, `x` no\n+longer exists. An attempt to access `x` within the closure would thus be\n+unsafe.\n+\n+Another situation where this might be encountered is when spawning threads:\n+\n+```compile_fail,E0373\n+fn foo() {\n+    let x = 0u32;\n+    let y = 1u32;\n+\n+    let thr = std::thread::spawn(|| {\n+        x + y\n+    });\n+}\n+```\n+\n+Since our new thread runs in parallel, the stack frame containing `x` and `y`\n+may well have disappeared by the time we try to use them. Even if we call\n+`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\n+stack frame won't disappear), we will not succeed: the compiler cannot prove\n+that this behaviour is safe, and so won't let us do it.\n+\n+The solution to this problem is usually to switch to using a `move` closure.\n+This approach moves (or copies, where possible) data into the closure, rather\n+than taking references to it. For example:\n+\n+```\n+fn foo() -> Box<Fn(u32) -> u32> {\n+    let x = 0u32;\n+    Box::new(move |y| x + y)\n+}\n+```\n+\n+Now that the closure has its own copy of the data, there's no need to worry\n+about safety.\n+\"##,\n+\n E0381: r##\"\n It is not allowed to use or capture an uninitialized variable. For example:\n \n@@ -250,6 +301,104 @@ fn main() {\n ```\n \"##,\n \n+E0382: r##\"\n+This error occurs when an attempt is made to use a variable after its contents\n+have been moved elsewhere. For example:\n+\n+```compile_fail,E0382\n+struct MyStruct { s: u32 }\n+\n+fn main() {\n+    let mut x = MyStruct{ s: 5u32 };\n+    let y = x;\n+    x.s = 6;\n+    println!(\"{}\", x.s);\n+}\n+```\n+\n+Since `MyStruct` is a type that is not marked `Copy`, the data gets moved out\n+of `x` when we set `y`. This is fundamental to Rust's ownership system: outside\n+of workarounds like `Rc`, a value cannot be owned by more than one variable.\n+\n+If we own the type, the easiest way to address this problem is to implement\n+`Copy` and `Clone` on it, as shown below. This allows `y` to copy the\n+information in `x`, while leaving the original version owned by `x`. Subsequent\n+changes to `x` will not be reflected when accessing `y`.\n+\n+```\n+#[derive(Copy, Clone)]\n+struct MyStruct { s: u32 }\n+\n+fn main() {\n+    let mut x = MyStruct{ s: 5u32 };\n+    let y = x;\n+    x.s = 6;\n+    println!(\"{}\", x.s);\n+}\n+```\n+\n+Alternatively, if we don't control the struct's definition, or mutable shared\n+ownership is truly required, we can use `Rc` and `RefCell`:\n+\n+```\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+struct MyStruct { s: u32 }\n+\n+fn main() {\n+    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n+    let y = x.clone();\n+    x.borrow_mut().s = 6;\n+    println!(\"{}\", x.borrow().s);\n+}\n+```\n+\n+With this approach, x and y share ownership of the data via the `Rc` (reference\n+count type). `RefCell` essentially performs runtime borrow checking: ensuring\n+that at most one writer or multiple readers can access the data at any one time.\n+\n+If you wish to learn more about ownership in Rust, start with the chapter in the\n+Book:\n+\n+https://doc.rust-lang.org/book/first-edition/ownership.html\n+\"##,\n+\n+E0383: r##\"\n+This error occurs when an attempt is made to partially reinitialize a\n+structure that is currently uninitialized.\n+\n+For example, this can happen when a drop has taken place:\n+\n+```compile_fail,E0383\n+struct Foo {\n+    a: u32,\n+}\n+impl Drop for Foo {\n+    fn drop(&mut self) { /* ... */ }\n+}\n+\n+let mut x = Foo { a: 1 };\n+drop(x); // `x` is now uninitialized\n+x.a = 2; // error, partial reinitialization of uninitialized structure `t`\n+```\n+\n+This error can be fixed by fully reinitializing the structure in question:\n+\n+```\n+struct Foo {\n+    a: u32,\n+}\n+impl Drop for Foo {\n+    fn drop(&mut self) { /* ... */ }\n+}\n+\n+let mut x = Foo { a: 1 };\n+drop(x);\n+x = Foo { a: 2 };\n+```\n+\"##,\n+\n E0384: r##\"\n This error occurs when an attempt is made to reassign an immutable variable.\n For example:\n@@ -272,6 +421,161 @@ fn main() {\n ```\n \"##,\n \n+/*E0386: r##\"\n+This error occurs when an attempt is made to mutate the target of a mutable\n+reference stored inside an immutable container.\n+\n+For example, this can happen when storing a `&mut` inside an immutable `Box`:\n+\n+```compile_fail,E0386\n+let mut x: i64 = 1;\n+let y: Box<_> = Box::new(&mut x);\n+**y = 2; // error, cannot assign to data in an immutable container\n+```\n+\n+This error can be fixed by making the container mutable:\n+\n+```\n+let mut x: i64 = 1;\n+let mut y: Box<_> = Box::new(&mut x);\n+**y = 2;\n+```\n+\n+It can also be fixed by using a type with interior mutability, such as `Cell`\n+or `RefCell`:\n+\n+```\n+use std::cell::Cell;\n+\n+let x: i64 = 1;\n+let y: Box<Cell<_>> = Box::new(Cell::new(x));\n+y.set(2);\n+```\n+\"##,*/\n+\n+E0387: r##\"\n+This error occurs when an attempt is made to mutate or mutably reference data\n+that a closure has captured immutably. Examples of this error are shown below:\n+\n+```compile_fail,E0387\n+// Accepts a function or a closure that captures its environment immutably.\n+// Closures passed to foo will not be able to mutate their closed-over state.\n+fn foo<F: Fn()>(f: F) { }\n+\n+// Attempts to mutate closed-over data. Error message reads:\n+// `cannot assign to data in a captured outer variable...`\n+fn mutable() {\n+    let mut x = 0u32;\n+    foo(|| x = 2);\n+}\n+\n+// Attempts to take a mutable reference to closed-over data.  Error message\n+// reads: `cannot borrow data mutably in a captured outer variable...`\n+fn mut_addr() {\n+    let mut x = 0u32;\n+    foo(|| { let y = &mut x; });\n+}\n+```\n+\n+The problem here is that foo is defined as accepting a parameter of type `Fn`.\n+Closures passed into foo will thus be inferred to be of type `Fn`, meaning that\n+they capture their context immutably.\n+\n+If the definition of `foo` is under your control, the simplest solution is to\n+capture the data mutably. This can be done by defining `foo` to take FnMut\n+rather than Fn:\n+\n+```\n+fn foo<F: FnMut()>(f: F) { }\n+```\n+\n+Alternatively, we can consider using the `Cell` and `RefCell` types to achieve\n+interior mutability through a shared reference. Our example's `mutable`\n+function could be redefined as below:\n+\n+```\n+use std::cell::Cell;\n+\n+fn foo<F: Fn()>(f: F) { }\n+\n+fn mutable() {\n+    let x = Cell::new(0u32);\n+    foo(|| x.set(2));\n+}\n+```\n+\n+You can read more about cell types in the API documentation:\n+\n+https://doc.rust-lang.org/std/cell/\n+\"##,\n+\n+E0388: r##\"\n+E0388 was removed and is no longer issued.\n+\"##,\n+\n+E0389: r##\"\n+An attempt was made to mutate data using a non-mutable reference. This\n+commonly occurs when attempting to assign to a non-mutable reference of a\n+mutable reference (`&(&mut T)`).\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0389\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let mut fancy = FancyNum{ num: 5 };\n+    let fancy_ref = &(&mut fancy);\n+    fancy_ref.num = 6; // error: cannot assign to data in a `&` reference\n+    println!(\"{}\", fancy_ref.num);\n+}\n+```\n+\n+Here, `&mut fancy` is mutable, but `&(&mut fancy)` is not. Creating an\n+immutable reference to a value borrows it immutably. There can be multiple\n+references of type `&(&mut T)` that point to the same value, so they must be\n+immutable to prevent multiple mutable references to the same value.\n+\n+To fix this, either remove the outer reference:\n+\n+```\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let mut fancy = FancyNum{ num: 5 };\n+\n+    let fancy_ref = &mut fancy;\n+    // `fancy_ref` is now &mut FancyNum, rather than &(&mut FancyNum)\n+\n+    fancy_ref.num = 6; // No error!\n+\n+    println!(\"{}\", fancy_ref.num);\n+}\n+```\n+\n+Or make the outer reference mutable:\n+\n+```\n+struct FancyNum {\n+    num: u8\n+}\n+\n+fn main() {\n+    let mut fancy = FancyNum{ num: 5 };\n+\n+    let fancy_ref = &mut (&mut fancy);\n+    // `fancy_ref` is now &mut(&mut FancyNum), rather than &(&mut FancyNum)\n+\n+    fancy_ref.num = 6; // No error!\n+\n+    println!(\"{}\", fancy_ref.num);\n+}\n+```\n+\"##,\n \n E0394: r##\"\n A static was referred to by value by another static.\n@@ -1265,12 +1569,169 @@ fn main() {\n ```\n \"##,\n \n+E0595: r##\"\n+Closures cannot mutate immutable captured variables.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0595\n+let x = 3; // error: closure cannot assign to immutable local variable `x`\n+let mut c = || { x += 1 };\n+```\n+\n+Make the variable binding mutable:\n+\n+```\n+let mut x = 3; // ok!\n+let mut c = || { x += 1 };\n+```\n+\"##,\n+\n+E0596: r##\"\n+This error occurs because you tried to mutably borrow a non-mutable variable.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0596\n+let x = 1;\n+let y = &mut x; // error: cannot borrow mutably\n+```\n+\n+In here, `x` isn't mutable, so when we try to mutably borrow it in `y`, it\n+fails. To fix this error, you need to make `x` mutable:\n+\n+```\n+let mut x = 1;\n+let y = &mut x; // ok!\n+```\n+\"##,\n+\n+E0597: r##\"\n+This error occurs because a borrow was made inside a variable which has a\n+greater lifetime than the borrowed one.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0597\n+struct Foo<'a> {\n+    x: Option<&'a u32>,\n+}\n+\n+let mut x = Foo { x: None };\n+let y = 0;\n+x.x = Some(&y); // error: `y` does not live long enough\n+```\n+\n+In here, `x` is created before `y` and therefore has a greater lifetime. Always\n+keep in mind that values in a scope are dropped in the opposite order they are\n+created. So to fix the previous example, just make the `y` lifetime greater than\n+the `x`'s one:\n+\n+```\n+struct Foo<'a> {\n+    x: Option<&'a u32>,\n+}\n+\n+let y = 0;\n+let mut x = Foo { x: None };\n+x.x = Some(&y);\n+```\n+\"##,\n+\n+E0626: r##\"\n+This error occurs because a borrow in a generator persists across a\n+yield point.\n+\n+```compile_fail,E0626\n+# #![feature(generators, generator_trait)]\n+# use std::ops::Generator;\n+let mut b = || {\n+    let a = &String::new(); // <-- This borrow...\n+    yield (); // ...is still in scope here, when the yield occurs.\n+    println!(\"{}\", a);\n+};\n+b.resume();\n+```\n+\n+At present, it is not permitted to have a yield that occurs while a\n+borrow is still in scope. To resolve this error, the borrow must\n+either be \"contained\" to a smaller scope that does not overlap the\n+yield or else eliminated in another way. So, for example, we might\n+resolve the previous example by removing the borrow and just storing\n+the integer by value:\n+\n+```\n+# #![feature(generators, generator_trait)]\n+# use std::ops::Generator;\n+let mut b = || {\n+    let a = 3;\n+    yield ();\n+    println!(\"{}\", a);\n+};\n+b.resume();\n+```\n+\n+This is a very simple case, of course. In more complex cases, we may\n+wish to have more than one reference to the value that was borrowed --\n+in those cases, something like the `Rc` or `Arc` types may be useful.\n+\n+This error also frequently arises with iteration:\n+\n+```compile_fail,E0626\n+# #![feature(generators, generator_trait)]\n+# use std::ops::Generator;\n+let mut b = || {\n+  let v = vec![1,2,3];\n+  for &x in &v { // <-- borrow of `v` is still in scope...\n+    yield x; // ...when this yield occurs.\n+  }\n+};\n+b.resume();\n+```\n+\n+Such cases can sometimes be resolved by iterating \"by value\" (or using\n+`into_iter()`) to avoid borrowing:\n+\n+```\n+# #![feature(generators, generator_trait)]\n+# use std::ops::Generator;\n+let mut b = || {\n+  let v = vec![1,2,3];\n+  for x in v { // <-- Take ownership of the values instead!\n+    yield x; // <-- Now yield is OK.\n+  }\n+};\n+b.resume();\n+```\n+\n+If taking ownership is not an option, using indices can work too:\n+\n+```\n+# #![feature(generators, generator_trait)]\n+# use std::ops::Generator;\n+let mut b = || {\n+  let v = vec![1,2,3];\n+  let len = v.len(); // (*)\n+  for i in 0..len {\n+    let x = v[i]; // (*)\n+    yield x; // <-- Now yield is OK.\n+  }\n+};\n+b.resume();\n+\n+// (*) -- Unfortunately, these temporaries are currently required.\n+// See <https://github.com/rust-lang/rust/issues/43122>.\n+```\n+\"##,\n+\n }\n \n register_diagnostics! {\n+//    E0385, // {} in an aliasable location\n     E0493, // destructors cannot be evaluated at compile-time\n     E0524, // two closures require unique access to `..` at the same time\n     E0526, // shuffle indices are not constant\n     E0594, // cannot assign to {}\n+    E0598, // lifetime of {} is too short to guarantee its contents can be...\n     E0625, // thread-local statics cannot be accessed at compile-time\n }"}, {"sha": "cea66837d9aaf9fe857ec0995935cede05b4bdd5", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -65,7 +65,18 @@ impl PassHook for DumpMir {\n                                pass_name,\n                                &Disambiguator { is_after },\n                                source,\n-                               mir);\n+                               mir,\n+                               |_, _| Ok(()) );\n+            for (index, promoted_mir) in mir.promoted.iter_enumerated() {\n+                let promoted_source = MirSource::Promoted(source.item_id(), index);\n+                mir_util::dump_mir(tcx,\n+                                   Some((suite, pass_num)),\n+                                   pass_name,\n+                                   &Disambiguator { is_after },\n+                                   promoted_source,\n+                                   promoted_mir,\n+                                   |_, _| Ok(()) );\n+            }\n         }\n     }\n }"}, {"sha": "7d0814b67fba5b1e216d236b62a75466c0e792af", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -587,7 +587,7 @@ fn create_generator_drop_shim<'a, 'tcx>(\n     // unrelated code from the resume part of the function\n     simplify::remove_dead_blocks(&mut mir);\n \n-    dump_mir(tcx, None, \"generator_drop\", &0, source, &mut mir);\n+    dump_mir(tcx, None, \"generator_drop\", &0, source, &mut mir, |_, _| Ok(()) );\n \n     mir\n }\n@@ -673,7 +673,7 @@ fn create_generator_resume_function<'a, 'tcx>(\n     // unrelated code from the drop part of the function\n     simplify::remove_dead_blocks(mir);\n \n-    dump_mir(tcx, None, \"generator_resume\", &0, source, mir);\n+    dump_mir(tcx, None, \"generator_resume\", &0, source, mir, |_, _| Ok(()) );\n }\n \n fn source_info<'a, 'tcx>(mir: &Mir<'tcx>) -> SourceInfo {\n@@ -816,14 +816,14 @@ impl MirPass for StateTransform {\n         // This is expanded to a drop ladder in `elaborate_generator_drops`.\n         let drop_clean = insert_clean_drop(mir);\n \n-        dump_mir(tcx, None, \"generator_pre-elab\", &0, source, mir);\n+        dump_mir(tcx, None, \"generator_pre-elab\", &0, source, mir, |_, _| Ok(()) );\n \n         // Expand `drop(generator_struct)` to a drop ladder which destroys upvars.\n         // If any upvars are moved out of, drop elaboration will handle upvar destruction.\n         // However we need to also elaborate the code generated by `insert_clean_drop`.\n         elaborate_generator_drops(tcx, def_id, mir);\n \n-        dump_mir(tcx, None, \"generator_post-transform\", &0, source, mir);\n+        dump_mir(tcx, None, \"generator_post-transform\", &0, source, mir, |_, _| Ok(()) );\n \n         // Create a copy of our MIR and use it to create the drop shim for the generator\n         let drop_shim = create_generator_drop_shim(tcx,"}, {"sha": "e6e00f295ca11958646338efd680a45d83f29806", "filename": "src/librustc_mir/transform/nll/infer.rs", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_mir%2Ftransform%2Fnll%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_mir%2Ftransform%2Fnll%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Finfer.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -0,0 +1,222 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::{Region, RegionIndex};\n+use std::mem;\n+use rustc::infer::InferCtxt;\n+use rustc::mir::{Location, Mir};\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::fx::FxHashSet;\n+\n+pub struct InferenceContext {\n+    definitions: IndexVec<RegionIndex, VarDefinition>,\n+    constraints: IndexVec<ConstraintIndex, Constraint>,\n+    errors: IndexVec<InferenceErrorIndex, InferenceError>,\n+}\n+\n+pub struct InferenceError {\n+    pub constraint_point: Location,\n+    pub name: (), // FIXME(nashenas88) RegionName\n+}\n+\n+newtype_index!(InferenceErrorIndex);\n+\n+struct VarDefinition {\n+    name: (), // FIXME(nashenas88) RegionName\n+    value: Region,\n+    capped: bool,\n+}\n+\n+impl VarDefinition {\n+    pub fn new(value: Region) -> Self {\n+        Self {\n+            name: (),\n+            value,\n+            capped: false,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct Constraint {\n+    sub: RegionIndex,\n+    sup: RegionIndex,\n+    point: Location,\n+}\n+\n+newtype_index!(ConstraintIndex);\n+\n+impl InferenceContext {\n+    pub fn new(values: IndexVec<RegionIndex, Region>) -> Self {\n+        Self {\n+            definitions: values.into_iter().map(VarDefinition::new).collect(),\n+            constraints: IndexVec::new(),\n+            errors: IndexVec::new(),\n+        }\n+    }\n+\n+    #[allow(dead_code)]\n+    pub fn cap_var(&mut self, v: RegionIndex) {\n+        self.definitions[v].capped = true;\n+    }\n+\n+    #[allow(dead_code)]\n+    pub fn add_live_point(&mut self, v: RegionIndex, point: Location) {\n+        debug!(\"add_live_point({:?}, {:?})\", v, point);\n+        let definition = &mut self.definitions[v];\n+        if definition.value.add_point(point) {\n+            if definition.capped {\n+                self.errors.push(InferenceError {\n+                    constraint_point: point,\n+                    name: definition.name,\n+                });\n+            }\n+        }\n+    }\n+\n+    #[allow(dead_code)]\n+    pub fn add_outlives(&mut self, sup: RegionIndex, sub: RegionIndex, point: Location) {\n+        debug!(\"add_outlives({:?}: {:?} @ {:?}\", sup, sub, point);\n+        self.constraints.push(Constraint { sup, sub, point });\n+    }\n+\n+    #[allow(dead_code)]\n+    pub fn region(&self, v: RegionIndex) -> &Region {\n+        &self.definitions[v].value\n+    }\n+\n+    pub fn solve<'a, 'gcx, 'tcx>(\n+        &mut self,\n+        infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+        mir: &'a Mir<'tcx>,\n+    ) -> IndexVec<InferenceErrorIndex, InferenceError>\n+    where\n+        'gcx: 'tcx + 'a,\n+        'tcx: 'a,\n+    {\n+        let mut changed = true;\n+        let mut dfs = Dfs::new(infcx, mir);\n+        while changed {\n+            changed = false;\n+            for constraint in &self.constraints {\n+                let sub = &self.definitions[constraint.sub].value.clone();\n+                let sup_def = &mut self.definitions[constraint.sup];\n+                debug!(\"constraint: {:?}\", constraint);\n+                debug!(\"    sub (before): {:?}\", sub);\n+                debug!(\"    sup (before): {:?}\", sup_def.value);\n+\n+                if dfs.copy(sub, &mut sup_def.value, constraint.point) {\n+                    changed = true;\n+                    if sup_def.capped {\n+                        // This is kind of a hack, but when we add a\n+                        // constraint, the \"point\" is always the point\n+                        // AFTER the action that induced the\n+                        // constraint. So report the error on the\n+                        // action BEFORE that.\n+                        assert!(constraint.point.statement_index > 0);\n+                        let p = Location {\n+                            block: constraint.point.block,\n+                            statement_index: constraint.point.statement_index - 1,\n+                        };\n+\n+                        self.errors.push(InferenceError {\n+                            constraint_point: p,\n+                            name: sup_def.name,\n+                        });\n+                    }\n+                }\n+\n+                debug!(\"    sup (after) : {:?}\", sup_def.value);\n+                debug!(\"    changed     : {:?}\", changed);\n+            }\n+            debug!(\"\\n\");\n+        }\n+\n+        mem::replace(&mut self.errors, IndexVec::new())\n+    }\n+}\n+\n+struct Dfs<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> {\n+    #[allow(dead_code)]\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n+}\n+\n+impl<'a, 'gcx: 'tcx, 'tcx: 'a> Dfs<'a, 'gcx, 'tcx> {\n+    fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n+        Self { infcx, mir }\n+    }\n+\n+    fn copy(\n+        &mut self,\n+        from_region: &Region,\n+        to_region: &mut Region,\n+        start_point: Location,\n+    ) -> bool {\n+        let mut changed = false;\n+\n+        let mut stack = vec![];\n+        let mut visited = FxHashSet();\n+\n+        stack.push(start_point);\n+        while let Some(p) = stack.pop() {\n+            debug!(\"        dfs: p={:?}\", p);\n+\n+            if !from_region.may_contain(p) {\n+                debug!(\"            not in from-region\");\n+                continue;\n+            }\n+\n+            if !visited.insert(p) {\n+                debug!(\"            already visited\");\n+                continue;\n+            }\n+\n+            changed |= to_region.add_point(p);\n+\n+            let block_data = &self.mir[p.block];\n+            let successor_points = if p.statement_index < block_data.statements.len() {\n+                vec![Location {\n+                    statement_index: p.statement_index + 1,\n+                    ..p\n+                }]\n+            } else {\n+                block_data.terminator()\n+                    .successors()\n+                    .iter()\n+                    .map(|&basic_block| Location {\n+                        statement_index: 0,\n+                        block: basic_block,\n+                    })\n+                    .collect::<Vec<_>>()\n+            };\n+\n+            if successor_points.is_empty() {\n+                // FIXME handle free regions\n+                // If we reach the END point in the graph, then copy\n+                // over any skolemized end points in the `from_region`\n+                // and make sure they are included in the `to_region`.\n+                // for region_decl in self.infcx.tcx.tables.borrow().free_region_map() {\n+                //     // FIXME(nashenas88) figure out skolemized_end points\n+                //     let block = self.env.graph.skolemized_end(region_decl.name);\n+                //     let skolemized_end_point = Location {\n+                //         block,\n+                //         statement_index: 0,\n+                //     };\n+                //     changed |= to_region.add_point(skolemized_end_point);\n+                // }\n+            } else {\n+                stack.extend(successor_points);\n+            }\n+        }\n+\n+        changed\n+    }\n+}"}, {"sha": "805e9c976e4f0ed6774b1ebfb1e14620b7977bab", "filename": "src/librustc_mir/transform/nll/mod.rs", "status": "modified", "additions": 45, "deletions": 11, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -8,42 +8,50 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use self::infer::InferenceContext;\n use rustc::ty::TypeFoldable;\n use rustc::ty::subst::{Kind, Substs};\n use rustc::ty::{Ty, TyCtxt, ClosureSubsts, RegionVid, RegionKind};\n use rustc::mir::{Mir, Location, Rvalue, BasicBlock, Statement, StatementKind};\n use rustc::mir::visit::{MutVisitor, Lookup};\n use rustc::mir::transform::{MirPass, MirSource};\n-use rustc::infer::{self, InferCtxt};\n+use rustc::infer::{self as rustc_infer, InferCtxt};\n use rustc::util::nodemap::FxHashSet;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use syntax_pos::DUMMY_SP;\n use std::collections::HashMap;\n+use std::fmt;\n+\n+use util as mir_util;\n+use self::mir_util::PassWhere;\n+\n+mod infer;\n \n #[allow(dead_code)]\n struct NLLVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     lookup_map: HashMap<RegionVid, Lookup>,\n     regions: IndexVec<RegionIndex, Region>,\n-    infcx: InferCtxt<'a, 'gcx, 'tcx>,\n+    #[allow(dead_code)]\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n-    pub fn new(infcx: InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n         NLLVisitor {\n             infcx,\n             lookup_map: HashMap::new(),\n             regions: IndexVec::new(),\n         }\n     }\n \n-    pub fn into_results(self) -> HashMap<RegionVid, Lookup> {\n-        self.lookup_map\n+    pub fn into_results(self) -> (HashMap<RegionVid, Lookup>, IndexVec<RegionIndex, Region>) {\n+        (self.lookup_map, self.regions)\n     }\n \n     fn renumber_regions<T>(&mut self, value: &T) -> T where T: TypeFoldable<'tcx> {\n         self.infcx.tcx.fold_regions(value, &mut false, |_region, _depth| {\n             self.regions.push(Region::default());\n-            self.infcx.next_region_var(infer::MiscVariable(DUMMY_SP))\n+            self.infcx.next_region_var(rustc_infer::MiscVariable(DUMMY_SP))\n         })\n     }\n \n@@ -134,7 +142,7 @@ pub struct NLL;\n impl MirPass for NLL {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          _: MirSource,\n+                          source: MirSource,\n                           mir: &mut Mir<'tcx>) {\n         if !tcx.sess.opts.debugging_opts.nll {\n             return;\n@@ -143,16 +151,42 @@ impl MirPass for NLL {\n         tcx.infer_ctxt().enter(|infcx| {\n             // Clone mir so we can mutate it without disturbing the rest of the compiler\n             let mut renumbered_mir = mir.clone();\n-            let mut visitor = NLLVisitor::new(infcx);\n+            let mut visitor = NLLVisitor::new(&infcx);\n             visitor.visit_mir(&mut renumbered_mir);\n-            let _results = visitor.into_results();\n+            mir_util::dump_mir(tcx, None, \"nll\", &0, source, mir, |pass_where, out| {\n+                if let PassWhere::BeforeCFG = pass_where {\n+                    for (index, value) in visitor.regions.iter_enumerated() {\n+                        writeln!(out, \"// R{:03}: {:?}\", index.0, value)?;\n+                    }\n+                }\n+                Ok(())\n+            });\n+            let (_lookup_map, regions) = visitor.into_results();\n+            let mut inference_context = InferenceContext::new(regions);\n+            inference_context.solve(&infcx, &renumbered_mir);\n         })\n     }\n }\n \n-#[derive(Clone, Debug, Default, PartialEq, Eq)]\n-struct Region {\n+#[derive(Clone, Default, PartialEq, Eq)]\n+pub struct Region {\n     points: FxHashSet<Location>,\n }\n \n+impl fmt::Debug for Region {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        write!(formatter, \"{:?}\", self.points)\n+    }\n+}\n+\n+impl Region {\n+    pub fn add_point(&mut self, point: Location) -> bool {\n+        self.points.insert(point)\n+    }\n+\n+    pub fn may_contain(&self, point: Location) -> bool {\n+        self.points.contains(&point)\n+    }\n+}\n+\n newtype_index!(RegionIndex);"}, {"sha": "216f6e4457096d28d6c51590c46840d579a57f36", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -294,6 +294,139 @@ pub trait BorrowckErrors {\n         err.span_label(move_from_span, \"cannot move out of here\");\n         err\n     }\n+\n+    fn cannot_act_on_moved_value(&self,\n+                                 use_span: Span,\n+                                 verb: &str,\n+                                 optional_adverb_for_moved: &str,\n+                                 moved_path: &str,\n+                                 o: Origin)\n+                                 -> DiagnosticBuilder\n+    {\n+        let err = struct_span_err!(self, use_span, E0382,\n+                                   \"{} of {}moved value: `{}`{OGN}\",\n+                                   verb, optional_adverb_for_moved, moved_path, OGN=o);\n+        err\n+    }\n+\n+    fn cannot_partially_reinit_an_uninit_struct(&self,\n+                                                span: Span,\n+                                                uninit_path: &str,\n+                                                o: Origin)\n+                                                -> DiagnosticBuilder\n+    {\n+        let err = struct_span_err!(self,\n+                                   span,\n+                                   E0383,\n+                                   \"partial reinitialization of uninitialized structure `{}`{OGN}\",\n+                                   uninit_path, OGN=o);\n+        err\n+    }\n+\n+    fn closure_cannot_assign_to_borrowed(&self,\n+                                         span: Span,\n+                                         descr: &str,\n+                                         o: Origin)\n+                                         -> DiagnosticBuilder\n+    {\n+        let err = struct_span_err!(self, span, E0595, \"closure cannot assign to {}{OGN}\",\n+                                   descr, OGN=o);\n+        err\n+    }\n+\n+    fn cannot_borrow_path_as_mutable(&self,\n+                                     span: Span,\n+                                     path: &str,\n+                                     o: Origin)\n+                                     -> DiagnosticBuilder\n+    {\n+        let err = struct_span_err!(self, span, E0596, \"cannot borrow {} as mutable{OGN}\",\n+                                   path, OGN=o);\n+        err\n+    }\n+\n+    fn cannot_borrow_across_generator_yield(&self,\n+                                            span: Span,\n+                                            yield_span: Span,\n+                                            o: Origin)\n+                                            -> DiagnosticBuilder\n+    {\n+        let mut err = struct_span_err!(self,\n+                                       span,\n+                                       E0626,\n+                                       \"borrow may still be in use when generator yields{OGN}\",\n+                                       OGN=o);\n+        err.span_label(yield_span, \"possible yield occurs here\");\n+        err\n+    }\n+\n+    fn path_does_not_live_long_enough(&self,\n+                                      span: Span,\n+                                      path: &str,\n+                                      o: Origin)\n+                                      -> DiagnosticBuilder\n+    {\n+        let err = struct_span_err!(self, span, E0597, \"{} does not live long enough{OGN}\",\n+                                   path, OGN=o);\n+        err\n+    }\n+\n+    fn lifetime_too_short_for_reborrow(&self,\n+                                       span: Span,\n+                                       path: &str,\n+                                       o: Origin)\n+                                       -> DiagnosticBuilder\n+    {\n+        let err = struct_span_err!(self, span, E0598,\n+                                   \"lifetime of {} is too short to guarantee \\\n+                                    its contents can be safely reborrowed{OGN}\",\n+                                   path, OGN=o);\n+        err\n+    }\n+\n+    fn cannot_act_on_capture_in_sharable_fn(&self,\n+                                            span: Span,\n+                                            bad_thing: &str,\n+                                            help: (Span, &str),\n+                                            o: Origin)\n+                                            -> DiagnosticBuilder\n+    {\n+        let (help_span, help_msg) = help;\n+        let mut err = struct_span_err!(self, span, E0387,\n+                                       \"{} in a captured outer variable in an `Fn` closure{OGN}\",\n+                                       bad_thing, OGN=o);\n+        err.span_help(help_span, help_msg);\n+        err\n+    }\n+\n+    fn cannot_assign_into_immutable_reference(&self,\n+                                              span: Span,\n+                                              bad_thing: &str,\n+                                              o: Origin)\n+                                              -> DiagnosticBuilder\n+    {\n+        let mut err = struct_span_err!(self, span, E0389, \"{} in a `&` reference{OGN}\",\n+                                       bad_thing, OGN=o);\n+        err.span_label(span, \"assignment into an immutable reference\");\n+        err\n+    }\n+\n+    fn cannot_capture_in_long_lived_closure(&self,\n+                                            closure_span: Span,\n+                                            borrowed_path: &str,\n+                                            capture_span: Span,\n+                                            o: Origin)\n+                                            -> DiagnosticBuilder\n+    {\n+        let mut err = struct_span_err!(self, closure_span, E0373,\n+                                       \"closure may outlive the current function, \\\n+                                        but it borrows {}, \\\n+                                        which is owned by the current function{OGN}\",\n+                                       borrowed_path, OGN=o);\n+        err.span_label(capture_span, format!(\"{} is borrowed here\", borrowed_path))\n+            .span_label(closure_span, format!(\"may outlive borrowed value {}\", borrowed_path));\n+        err\n+    }\n }\n \n impl<'b, 'tcx, 'gcx> BorrowckErrors for TyCtxt<'b, 'tcx, 'gcx> {"}, {"sha": "1424c063d73854c43b35102e81af7d14db80d478", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -232,7 +232,7 @@ pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             writeln!(w, \"{} {{{}}}\", prefix, live.join(\", \"))\n         };\n         print(w, \"   \", &result.ins)?;\n-        write_basic_block(tcx, block, mir, w)?;\n+        write_basic_block(tcx, block, mir, &mut |_, _| Ok(()), w)?;\n         print(w, \"   \", &result.outs)?;\n         if block.index() + 1 != mir.basic_blocks().len() {\n             writeln!(w, \"\")?;"}, {"sha": "13c14f8920f4ec600fd2a4e4c6768ba5c36438fa", "filename": "src/librustc_mir/util/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -17,6 +17,6 @@ mod graphviz;\n mod pretty;\n pub mod liveness;\n \n-pub use self::pretty::{dump_enabled, dump_mir, write_mir_pretty};\n+pub use self::pretty::{dump_enabled, dump_mir, write_mir_pretty, PassWhere};\n pub use self::graphviz::{write_mir_graphviz};\n pub use self::graphviz::write_node_label as write_graphviz_node_label;"}, {"sha": "8a9047fb4911c66a598dbec20daa0ffd3727f417", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 65, "deletions": 33, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -25,6 +25,22 @@ const INDENT: &'static str = \"    \";\n /// Alignment for lining up comments following MIR statements\n const ALIGN: usize = 40;\n \n+/// An indication of where we are in the control flow graph. Used for printing\n+/// extra information in `dump_mir`\n+pub enum PassWhere {\n+    /// We have not started dumping the control flow graph, but we are about to.\n+    BeforeCFG,\n+\n+    /// We just finished dumping the control flow graph. This is right before EOF\n+    AfterCFG,\n+\n+    /// We are about to start dumping the given basic block.\n+    BeforeBlock(BasicBlock),\n+\n+    /// We are just about to dumpt the given statement or terminator.\n+    InCFG(Location),\n+}\n+\n /// If the session is properly configured, dumps a human-readable\n /// representation of the mir into:\n ///\n@@ -39,12 +55,16 @@ const ALIGN: usize = 40;\n /// - `substring1&substring2,...` -- `&`-separated list of substrings\n ///   that can appear in the pass-name or the `item_path_str` for the given\n ///   node-id. If any one of the substrings match, the data is dumped out.\n-pub fn dump_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          pass_num: Option<(MirSuite, MirPassIndex)>,\n-                          pass_name: &str,\n-                          disambiguator: &Display,\n-                          source: MirSource,\n-                          mir: &Mir<'tcx>) {\n+pub fn dump_mir<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             pass_num: Option<(MirSuite, MirPassIndex)>,\n+                             pass_name: &str,\n+                             disambiguator: &Display,\n+                             source: MirSource,\n+                             mir: &Mir<'tcx>,\n+                             extra_data: F)\n+where\n+    F: FnMut(PassWhere, &mut Write) -> io::Result<()>\n+{\n     if !dump_enabled(tcx, pass_name, source) {\n         return;\n     }\n@@ -53,12 +73,7 @@ pub fn dump_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         tcx.item_path_str(tcx.hir.local_def_id(source.item_id()))\n     });\n     dump_matched_mir_node(tcx, pass_num, pass_name, &node_path,\n-                          disambiguator, source, mir);\n-    for (index, promoted_mir) in mir.promoted.iter_enumerated() {\n-        let promoted_source = MirSource::Promoted(source.item_id(), index);\n-        dump_matched_mir_node(tcx, pass_num, pass_name, &node_path, disambiguator,\n-                              promoted_source, promoted_mir);\n-    }\n+                          disambiguator, source, mir, extra_data);\n }\n \n pub fn dump_enabled<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -85,13 +100,17 @@ pub fn dump_enabled<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n // `item_path_str()` would otherwise trigger `type_of`, and this can\n // run while we are already attempting to evaluate `type_of`.\n \n-fn dump_matched_mir_node<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   pass_num: Option<(MirSuite, MirPassIndex)>,\n-                                   pass_name: &str,\n-                                   node_path: &str,\n-                                   disambiguator: &Display,\n-                                   source: MirSource,\n-                                   mir: &Mir<'tcx>) {\n+fn dump_matched_mir_node<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                      pass_num: Option<(MirSuite, MirPassIndex)>,\n+                                      pass_name: &str,\n+                                      node_path: &str,\n+                                      disambiguator: &Display,\n+                                      source: MirSource,\n+                                      mir: &Mir<'tcx>,\n+                                      mut extra_data: F)\n+where\n+    F: FnMut(PassWhere, &mut Write) -> io::Result<()>\n+{\n     let promotion_id = match source {\n         MirSource::Promoted(_, id) => format!(\"-{:?}\", id),\n         MirSource::GeneratorDrop(_) => format!(\"-drop\"),\n@@ -125,7 +144,9 @@ fn dump_matched_mir_node<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             writeln!(file, \"// generator_layout = {:?}\", layout)?;\n         }\n         writeln!(file, \"\")?;\n-        write_mir_fn(tcx, source, mir, &mut file)?;\n+        extra_data(PassWhere::BeforeCFG, &mut file)?;\n+        write_mir_fn(tcx, source, mir, &mut extra_data, &mut file)?;\n+        extra_data(PassWhere::AfterCFG, &mut file)?;\n         Ok(())\n     });\n }\n@@ -152,24 +173,29 @@ pub fn write_mir_pretty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         let id = tcx.hir.as_local_node_id(def_id).unwrap();\n         let src = MirSource::from_node(tcx, id);\n-        write_mir_fn(tcx, src, mir, w)?;\n+        write_mir_fn(tcx, src, mir, &mut |_, _| Ok(()), w)?;\n \n         for (i, mir) in mir.promoted.iter_enumerated() {\n             writeln!(w, \"\")?;\n-            write_mir_fn(tcx, MirSource::Promoted(id, i), mir, w)?;\n+            write_mir_fn(tcx, MirSource::Promoted(id, i), mir, &mut |_, _| Ok(()), w)?;\n         }\n     }\n     Ok(())\n }\n \n-pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              src: MirSource,\n-                              mir: &Mir<'tcx>,\n-                              w: &mut Write)\n-                              -> io::Result<()> {\n+pub fn write_mir_fn<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 src: MirSource,\n+                                 mir: &Mir<'tcx>,\n+                                 extra_data: &mut F,\n+                                 w: &mut Write)\n+                                 -> io::Result<()>\n+where\n+    F: FnMut(PassWhere, &mut Write) -> io::Result<()>\n+{\n     write_mir_intro(tcx, src, mir, w)?;\n     for block in mir.basic_blocks().indices() {\n-        write_basic_block(tcx, block, mir, w)?;\n+        extra_data(PassWhere::BeforeBlock(block), w)?;\n+        write_basic_block(tcx, block, mir, extra_data, w)?;\n         if block.index() + 1 != mir.basic_blocks().len() {\n             writeln!(w, \"\")?;\n         }\n@@ -180,11 +206,15 @@ pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n /// Write out a human-readable textual representation for the given basic block.\n-pub fn write_basic_block(tcx: TyCtxt,\n-                     block: BasicBlock,\n-                     mir: &Mir,\n-                     w: &mut Write)\n-                     -> io::Result<()> {\n+pub fn write_basic_block<F>(tcx: TyCtxt,\n+                            block: BasicBlock,\n+                            mir: &Mir,\n+                            extra_data: &mut F,\n+                            w: &mut Write)\n+                            -> io::Result<()>\n+where\n+    F: FnMut(PassWhere, &mut Write) -> io::Result<()>\n+{\n     let data = &mir[block];\n \n     // Basic block label at the top.\n@@ -195,6 +225,7 @@ pub fn write_basic_block(tcx: TyCtxt,\n     // List of statements in the middle.\n     let mut current_location = Location { block: block, statement_index: 0 };\n     for statement in &data.statements {\n+        extra_data(PassWhere::InCFG(current_location), w)?;\n         let indented_mir = format!(\"{0}{0}{1:?};\", INDENT, statement);\n         writeln!(w, \"{0:1$} // {2}\",\n                  indented_mir,\n@@ -205,6 +236,7 @@ pub fn write_basic_block(tcx: TyCtxt,\n     }\n \n     // Terminator at the bottom.\n+    extra_data(PassWhere::InCFG(current_location), w)?;\n     let indented_terminator = format!(\"{0}{0}{1:?};\", INDENT, data.terminator().kind);\n     writeln!(w, \"{0:1$} // {2}\",\n              indented_terminator,"}, {"sha": "14e33378969aaa8cd25d1f091917fe7e1740acb2", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -152,7 +152,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     err.emit();\n                 });\n             }\n-            TyKind::TraitObject(ref bounds) => {\n+            TyKind::TraitObject(ref bounds, ..) => {\n                 let mut any_lifetime_bounds = false;\n                 for bound in bounds {\n                     if let RegionTyParamBound(ref lifetime) = *bound {"}, {"sha": "564626ac39885328089f8be721805ed6e8045981", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -43,7 +43,7 @@ parameter if so.\n \"##,\n \n E0154: r##\"\n-## Note: this error code is no longer emitted by the compiler.\n+#### Note: this error code is no longer emitted by the compiler.\n \n Imports (`use` statements) are not allowed after non-item statements, such as\n variable declarations and expression statements.\n@@ -79,7 +79,7 @@ https://doc.rust-lang.org/reference.html#statements\n \"##,\n \n E0251: r##\"\n-## Note: this error code is no longer emitted by the compiler.\n+#### Note: this error code is no longer emitted by the compiler.\n \n Two items of the same name cannot be imported without rebinding one of the\n items under a new local name.\n@@ -268,7 +268,7 @@ fn main() {\n \"##,\n \n E0256: r##\"\n-## Note: this error code is no longer emitted by the compiler.\n+#### Note: this error code is no longer emitted by the compiler.\n \n You can't import a type or module when the name of the item being imported is\n the same as another type or submodule defined in the module."}, {"sha": "4aab43cbec701cfd0a87bcfb33e3d275172ea4c5", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -137,7 +137,7 @@ enum ResolutionError<'a> {\n     /// error E0416: identifier is bound more than once in the same pattern\n     IdentifierBoundMoreThanOnceInSamePattern(&'a str),\n     /// error E0426: use of undeclared label\n-    UndeclaredLabel(&'a str),\n+    UndeclaredLabel(&'a str, Option<Name>),\n     /// error E0429: `self` imports are only allowed within a { } list\n     SelfImportsOnlyAllowedWithin,\n     /// error E0430: `self` import can only appear once in the list\n@@ -263,13 +263,17 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n             err.span_label(span, \"used in a pattern more than once\");\n             err\n         }\n-        ResolutionError::UndeclaredLabel(name) => {\n+        ResolutionError::UndeclaredLabel(name, lev_candidate) => {\n             let mut err = struct_span_err!(resolver.session,\n                                            span,\n                                            E0426,\n                                            \"use of undeclared label `{}`\",\n                                            name);\n-            err.span_label(span, format!(\"undeclared label `{}`\", name));\n+            if let Some(lev_candidate) = lev_candidate {\n+                err.span_label(span, format!(\"did you mean `{}`?\", lev_candidate));\n+            } else {\n+                err.span_label(span, format!(\"undeclared label `{}`\", name));\n+            }\n             err\n         }\n         ResolutionError::SelfImportsOnlyAllowedWithin => {\n@@ -1790,9 +1794,13 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    /// Searches the current set of local scopes for labels.\n+    /// Searches the current set of local scopes for labels. Returns the first non-None label that\n+    /// is returned by the given predicate function\n+    ///\n     /// Stops after meeting a closure.\n-    fn search_label(&self, mut ident: Ident) -> Option<Def> {\n+    fn search_label<P, R>(&self, mut ident: Ident, pred: P) -> Option<R>\n+        where P: Fn(&Rib, Ident) -> Option<R>\n+    {\n         for rib in self.label_ribs.iter().rev() {\n             match rib.kind {\n                 NormalRibKind => {}\n@@ -1808,9 +1816,9 @@ impl<'a> Resolver<'a> {\n                     return None;\n                 }\n             }\n-            let result = rib.bindings.get(&ident).cloned();\n-            if result.is_some() {\n-                return result;\n+            let r = pred(rib, ident);\n+            if r.is_some() {\n+                return r;\n             }\n         }\n         None\n@@ -3202,12 +3210,20 @@ impl<'a> Resolver<'a> {\n             }\n \n             ExprKind::Break(Some(label), _) | ExprKind::Continue(Some(label)) => {\n-                match self.search_label(label.node) {\n+                match self.search_label(label.node, |rib, id| rib.bindings.get(&id).cloned()) {\n                     None => {\n+                        // Search again for close matches...\n+                        // Picks the first label that is \"close enough\", which is not necessarily\n+                        // the closest match\n+                        let close_match = self.search_label(label.node, |rib, ident| {\n+                            let names = rib.bindings.iter().map(|(id, _)| &id.name);\n+                            find_best_match_for_name(names, &*ident.name.as_str(), None)\n+                        });\n                         self.record_def(expr.id, err_path_resolution());\n                         resolve_error(self,\n                                       label.span,\n-                                      ResolutionError::UndeclaredLabel(&label.node.name.as_str()));\n+                                      ResolutionError::UndeclaredLabel(&label.node.name.as_str(),\n+                                                                       close_match));\n                     }\n                     Some(def @ Def::Label(_)) => {\n                         // Since this def is a label, it is never read."}, {"sha": "47e5ad6c0108834a427f7d8e6331c4cd73229c2f", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -288,7 +288,7 @@ impl Sig for ast::Ty {\n                     })\n                 }\n             }\n-            ast::TyKind::TraitObject(ref bounds) => {\n+            ast::TyKind::TraitObject(ref bounds, ..) => {\n                 // FIXME recurse into bounds\n                 let nested = pprust::bounds_to_string(bounds);\n                 Ok(text_sig(nested))"}, {"sha": "5b7879ea58ee7e88de2b444d2f112c8c34811f27", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -32,4 +32,4 @@ syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n \n [target.\"cfg(windows)\".dependencies]\n-cc = \"1.0\"\n+cc = \"1.0.1\""}, {"sha": "775cf3ac4c934b087b1786886170adc3530e7dd8", "filename": "src/librustc_trans/back/archive.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -31,8 +31,7 @@ pub struct ArchiveConfig<'a> {\n     pub lib_search_paths: Vec<PathBuf>,\n }\n \n-/// Helper for adding many files to an archive with a single invocation of\n-/// `ar`.\n+/// Helper for adding many files to an archive.\n #[must_use = \"must call build() to finish building the archive\"]\n pub struct ArchiveBuilder<'a> {\n     config: ArchiveConfig<'a>,\n@@ -201,8 +200,8 @@ impl<'a> ArchiveBuilder<'a> {\n         });\n     }\n \n-    /// Indicate that the next call to `build` should updates all symbols in\n-    /// the archive (run 'ar s' over it).\n+    /// Indicate that the next call to `build` should update all symbols in\n+    /// the archive (equivalent to running 'ar s' over it).\n     pub fn update_symbols(&mut self) {\n         self.should_update_symbols = true;\n     }"}, {"sha": "570a6bbac1e4e4dd233aec67bbd55464dd484a8b", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -467,7 +467,7 @@ fn link_rlib<'a>(sess: &'a Session,\n                 // of when we do and don't keep .#module-name#.bc files around.\n                 let user_wants_numbered_bitcode =\n                         sess.opts.output_types.contains_key(&OutputType::Bitcode) &&\n-                        sess.opts.codegen_units > 1;\n+                        sess.codegen_units() > 1;\n                 if !sess.opts.cg.save_temps && !user_wants_numbered_bitcode {\n                     remove(sess, &bc_filename);\n                 }"}, {"sha": "01d3d656dfe19677600d6e9fd2f419de4af0934e", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -130,6 +130,7 @@ pub fn run(cgcx: &CodegenContext,\n         .filter_map(symbol_filter)\n         .collect::<Vec<CString>>();\n     timeline.record(\"whitelist\");\n+    info!(\"{} symbols to preserve in this crate\", symbol_white_list.len());\n \n     // If we're performing LTO for the entire crate graph, then for each of our\n     // upstream dependencies, find the corresponding rlib and load the bitcode\n@@ -437,7 +438,24 @@ fn run_pass_manager(cgcx: &CodegenContext,\n         assert!(!pass.is_null());\n         llvm::LLVMRustAddPass(pm, pass);\n \n-        with_llvm_pmb(llmod, config, &mut |b| {\n+        // When optimizing for LTO we don't actually pass in `-O0`, but we force\n+        // it to always happen at least with `-O1`.\n+        //\n+        // With ThinLTO we mess around a lot with symbol visibility in a way\n+        // that will actually cause linking failures if we optimize at O0 which\n+        // notable is lacking in dead code elimination. To ensure we at least\n+        // get some optimizations and correctly link we forcibly switch to `-O1`\n+        // to get dead code elimination.\n+        //\n+        // Note that in general this shouldn't matter too much as you typically\n+        // only turn on ThinLTO when you're compiling with optimizations\n+        // otherwise.\n+        let opt_level = config.opt_level.unwrap_or(llvm::CodeGenOptLevel::None);\n+        let opt_level = match opt_level {\n+            llvm::CodeGenOptLevel::None => llvm::CodeGenOptLevel::Less,\n+            level => level,\n+        };\n+        with_llvm_pmb(llmod, config, opt_level, &mut |b| {\n             if thin {\n                 if !llvm::LLVMRustPassManagerBuilderPopulateThinLTOPassManager(b, pm) {\n                     panic!(\"this version of LLVM does not support ThinLTO\");"}, {"sha": "66a27f1c4a9b1d91e6365d02baf98d2a57d65295", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 38, "deletions": 16, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -98,8 +98,10 @@\n //! DefPaths which are much more robust in the face of changes to the code base.\n \n use monomorphize::Instance;\n+use trans_item::{TransItemExt, InstantiationMode};\n \n use rustc::middle::weak_lang_items;\n+use rustc::middle::trans::TransItem;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -150,7 +152,10 @@ pub fn provide(providers: &mut Providers) {\n fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n                              // the DefId of the item this name is for\n-                             def_id: Option<DefId>,\n+                             def_id: DefId,\n+\n+                             // instance this name will be for\n+                             instance: Instance<'tcx>,\n \n                              // type of the item, without any generic\n                              // parameters substituted; this is\n@@ -160,7 +165,7 @@ fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n                              // values for generic type parameters,\n                              // if any.\n-                             substs: Option<&'tcx Substs<'tcx>>)\n+                             substs: &'tcx Substs<'tcx>)\n                              -> u64 {\n     debug!(\"get_symbol_hash(def_id={:?}, parameters={:?})\", def_id, substs);\n \n@@ -170,7 +175,7 @@ fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // the main symbol name is not necessarily unique; hash in the\n         // compiler's internal def-path, guaranteeing each symbol has a\n         // truly unique path\n-        hasher.hash(def_id.map(|def_id| tcx.def_path_hash(def_id)));\n+        hasher.hash(tcx.def_path_hash(def_id));\n \n         // Include the main item-type. Note that, in this case, the\n         // assertions about `needs_subst` may not hold, but this item-type\n@@ -186,19 +191,36 @@ fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         // also include any type parameters (for generic items)\n-        if let Some(substs) = substs {\n-            assert!(!substs.has_erasable_regions());\n-            assert!(!substs.needs_subst());\n-            substs.visit_with(&mut hasher);\n-\n-            // If this is an instance of a generic function, we also hash in\n-            // the ID of the instantiating crate. This avoids symbol conflicts\n-            // in case the same instances is emitted in two crates of the same\n-            // project.\n-            if substs.types().next().is_some() {\n-                hasher.hash(tcx.crate_name.as_str());\n-                hasher.hash(tcx.sess.local_crate_disambiguator().as_str());\n+        assert!(!substs.has_erasable_regions());\n+        assert!(!substs.needs_subst());\n+        substs.visit_with(&mut hasher);\n+\n+        let mut avoid_cross_crate_conflicts = false;\n+\n+        // If this is an instance of a generic function, we also hash in\n+        // the ID of the instantiating crate. This avoids symbol conflicts\n+        // in case the same instances is emitted in two crates of the same\n+        // project.\n+        if substs.types().next().is_some() {\n+            avoid_cross_crate_conflicts = true;\n+        }\n+\n+        // If we're dealing with an instance of a function that's inlined from\n+        // another crate but we're marking it as globally shared to our\n+        // compliation (aka we're not making an internal copy in each of our\n+        // codegen units) then this symbol may become an exported (but hidden\n+        // visibility) symbol. This means that multiple crates may do the same\n+        // and we want to be sure to avoid any symbol conflicts here.\n+        match TransItem::Fn(instance).instantiation_mode(tcx) {\n+            InstantiationMode::GloballyShared { may_conflict: true } => {\n+                avoid_cross_crate_conflicts = true;\n             }\n+            _ => {}\n+        }\n+\n+        if avoid_cross_crate_conflicts {\n+            hasher.hash(tcx.crate_name.as_str());\n+            hasher.hash(tcx.sess.local_crate_disambiguator().as_str());\n         }\n     });\n \n@@ -309,7 +331,7 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n     // and should not matter anyhow.\n     let instance_ty = tcx.erase_regions(&instance_ty);\n \n-    let hash = get_symbol_hash(tcx, Some(def_id), instance_ty, Some(substs));\n+    let hash = get_symbol_hash(tcx, def_id, instance, instance_ty, substs);\n \n     SymbolPathBuffer::from_interned(tcx.def_symbol_name(def_id)).finish(hash)\n }"}, {"sha": "f7e0ad029afafd8a87717553e4340db00c35c38a", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -217,7 +217,7 @@ pub struct ModuleConfig {\n     passes: Vec<String>,\n     /// Some(level) to optimize at a certain level, or None to run\n     /// absolutely no optimizations (used for the metadata module).\n-    opt_level: Option<llvm::CodeGenOptLevel>,\n+    pub opt_level: Option<llvm::CodeGenOptLevel>,\n \n     /// Some(level) to optimize binary size, or None to not affect program size.\n     opt_size: Option<llvm::CodeGenOptSize>,\n@@ -507,7 +507,8 @@ unsafe fn optimize(cgcx: &CodegenContext,\n         if !config.no_prepopulate_passes {\n             llvm::LLVMRustAddAnalysisPasses(tm, fpm, llmod);\n             llvm::LLVMRustAddAnalysisPasses(tm, mpm, llmod);\n-            with_llvm_pmb(llmod, &config, &mut |b| {\n+            let opt_level = config.opt_level.unwrap_or(llvm::CodeGenOptLevel::None);\n+            with_llvm_pmb(llmod, &config, opt_level, &mut |b| {\n                 llvm::LLVMPassManagerBuilderPopulateFunctionPassManager(b, fpm);\n                 llvm::LLVMPassManagerBuilderPopulateModulePassManager(b, mpm);\n             })\n@@ -1037,10 +1038,10 @@ fn produce_final_output_artifacts(sess: &Session,\n         let needs_crate_object = crate_output.outputs.contains_key(&OutputType::Exe);\n \n         let keep_numbered_bitcode = needs_crate_bitcode ||\n-                (user_wants_bitcode && sess.opts.codegen_units > 1);\n+                (user_wants_bitcode && sess.codegen_units() > 1);\n \n         let keep_numbered_objects = needs_crate_object ||\n-                (user_wants_objects && sess.opts.codegen_units > 1);\n+                (user_wants_objects && sess.codegen_units() > 1);\n \n         for module in compiled_modules.modules.iter() {\n             let module_name = Some(&module.name[..]);\n@@ -1079,13 +1080,9 @@ fn produce_final_output_artifacts(sess: &Session,\n }\n \n pub fn dump_incremental_data(trans: &CrateTranslation) {\n-    let mut reuse = 0;\n-    for mtrans in trans.modules.iter() {\n-        if mtrans.pre_existing {\n-            reuse += 1;\n-        }\n-    }\n-    eprintln!(\"incremental: re-using {} out of {} modules\", reuse, trans.modules.len());\n+    println!(\"[incremental] Re-using {} out of {} modules\",\n+              trans.modules.iter().filter(|m| m.pre_existing).count(),\n+              trans.modules.len());\n }\n \n enum WorkItem {\n@@ -1247,7 +1244,7 @@ fn start_executing_work(tcx: TyCtxt,\n                         modules_config: Arc<ModuleConfig>,\n                         metadata_config: Arc<ModuleConfig>,\n                         allocator_config: Arc<ModuleConfig>)\n-                        -> thread::JoinHandle<CompiledModules> {\n+                        -> thread::JoinHandle<Result<CompiledModules, ()>> {\n     let coordinator_send = tcx.tx_to_llvm_workers.clone();\n     let mut exported_symbols = FxHashMap();\n     exported_symbols.insert(LOCAL_CRATE, tcx.exported_symbols(LOCAL_CRATE));\n@@ -1695,7 +1692,7 @@ fn start_executing_work(tcx: TyCtxt,\n                 Message::Done { result: Err(()), worker_id: _ } => {\n                     shared_emitter.fatal(\"aborting due to worker thread failure\");\n                     // Exit the coordinator thread\n-                    panic!(\"aborting due to worker thread failure\")\n+                    return Err(())\n                 }\n                 Message::TranslateItem => {\n                     bug!(\"the coordinator should not receive translation requests\")\n@@ -1721,11 +1718,11 @@ fn start_executing_work(tcx: TyCtxt,\n         let compiled_metadata_module = compiled_metadata_module\n             .expect(\"Metadata module not compiled?\");\n \n-        CompiledModules {\n+        Ok(CompiledModules {\n             modules: compiled_modules,\n             metadata_module: compiled_metadata_module,\n             allocator_module: compiled_allocator_module,\n-        }\n+        })\n     });\n \n     // A heuristic that determines if we have enough LLVM WorkItems in the\n@@ -1846,16 +1843,17 @@ pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n \n pub unsafe fn with_llvm_pmb(llmod: ModuleRef,\n                             config: &ModuleConfig,\n+                            opt_level: llvm::CodeGenOptLevel,\n                             f: &mut FnMut(llvm::PassManagerBuilderRef)) {\n     // Create the PassManagerBuilder for LLVM. We configure it with\n     // reasonable defaults and prepare it to actually populate the pass\n     // manager.\n     let builder = llvm::LLVMPassManagerBuilderCreate();\n-    let opt_level = config.opt_level.unwrap_or(llvm::CodeGenOptLevel::None);\n     let opt_size = config.opt_size.unwrap_or(llvm::CodeGenOptSizeNone);\n     let inline_threshold = config.inline_threshold;\n \n-    llvm::LLVMRustConfigurePassManagerBuilder(builder, opt_level,\n+    llvm::LLVMRustConfigurePassManagerBuilder(builder,\n+                                              opt_level,\n                                               config.merge_functions,\n                                               config.vectorize_slp,\n                                               config.vectorize_loop);\n@@ -2018,15 +2016,19 @@ pub struct OngoingCrateTranslation {\n     coordinator_send: Sender<Box<Any + Send>>,\n     trans_worker_receive: Receiver<Message>,\n     shared_emitter_main: SharedEmitterMain,\n-    future: thread::JoinHandle<CompiledModules>,\n+    future: thread::JoinHandle<Result<CompiledModules, ()>>,\n     output_filenames: Arc<OutputFilenames>,\n }\n \n impl OngoingCrateTranslation {\n     pub fn join(self, sess: &Session, dep_graph: &DepGraph) -> CrateTranslation {\n         self.shared_emitter_main.check(sess, true);\n         let compiled_modules = match self.future.join() {\n-            Ok(compiled_modules) => compiled_modules,\n+            Ok(Ok(compiled_modules)) => compiled_modules,\n+            Ok(Err(())) => {\n+                sess.abort_if_errors();\n+                panic!(\"expected abort due to worker thread errors\")\n+            },\n             Err(_) => {\n                 sess.fatal(\"Error during translation/LLVM phase.\");\n             }\n@@ -2048,7 +2050,7 @@ impl OngoingCrateTranslation {\n \n         // FIXME: time_llvm_passes support - does this use a global context or\n         // something?\n-        if sess.opts.codegen_units == 1 && sess.time_llvm_passes() {\n+        if sess.codegen_units() == 1 && sess.time_llvm_passes() {\n             unsafe { llvm::LLVMRustPrintPassTimings(); }\n         }\n "}, {"sha": "6b53b5b6411d004e0da8beb893877e07d765bd09", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -1218,7 +1218,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(\n     let strategy = if tcx.sess.opts.debugging_opts.incremental.is_some() {\n         PartitioningStrategy::PerModule\n     } else {\n-        PartitioningStrategy::FixedUnitCount(tcx.sess.opts.codegen_units)\n+        PartitioningStrategy::FixedUnitCount(tcx.sess.codegen_units())\n     };\n \n     let codegen_units = time(time_passes, \"codegen unit partitioning\", || {"}, {"sha": "b515c9420bf36d18812dad1c4208b88bad65ecbb", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -24,6 +24,7 @@ use rustc::hir::def_id::DefId;\n use rustc::ty::{self, TypeFoldable};\n use rustc::traits;\n use rustc::ty::subst::Substs;\n+use rustc_back::PanicStrategy;\n use type_of;\n \n /// Translates a reference to a fn/method item, monomorphizing and\n@@ -105,8 +106,10 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // *in Rust code* may unwind. Foreign items like `extern \"C\" {\n         // fn foo(); }` are assumed not to unwind **unless** they have\n         // a `#[unwind]` attribute.\n-        if !tcx.is_foreign_item(instance_def_id) {\n-            attributes::unwind(llfn, true);\n+        if tcx.sess.panic_strategy() == PanicStrategy::Unwind {\n+            if !tcx.is_foreign_item(instance_def_id) {\n+                attributes::unwind(llfn, true);\n+            }\n         }\n \n         // Apply an appropriate linkage/visibility value to our item that we"}, {"sha": "33a2e96ee6621bb4282ad980d1ab8349c1ba15df", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -401,9 +401,9 @@ fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn record_accesses<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        caller: TransItem<'tcx>,\n-                                        callees: &[TransItem<'tcx>],\n-                                        inlining_map: &mut InliningMap<'tcx>) {\n+                             caller: TransItem<'tcx>,\n+                             callees: &[TransItem<'tcx>],\n+                             inlining_map: &mut InliningMap<'tcx>) {\n     let is_inlining_candidate = |trans_item: &TransItem<'tcx>| {\n         trans_item.instantiation_mode(tcx) == InstantiationMode::LocalCopy\n     };\n@@ -849,8 +849,8 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             assert!(!poly_trait_ref.has_escaping_regions());\n \n             // Walk all methods of the trait, including those of its supertraits\n-            let methods = traits::get_vtable_methods(tcx, poly_trait_ref);\n-            let methods = methods.filter_map(|method| method)\n+            let methods = tcx.vtable_methods(poly_trait_ref);\n+            let methods = methods.iter().cloned().filter_map(|method| method)\n                 .map(|(def_id, substs)| ty::Instance::resolve(\n                         tcx,\n                         ty::ParamEnv::empty(traits::Reveal::All),"}, {"sha": "f894bdf16e4de28c4c3233f622444aafda2882d2", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -24,6 +24,7 @@ use llvm::{self, ValueRef};\n use llvm::AttributePlace::Function;\n use rustc::ty::Ty;\n use rustc::session::config::Sanitizer;\n+use rustc_back::PanicStrategy;\n use abi::{Abi, FnType};\n use attributes;\n use context::CrateContext;\n@@ -98,6 +99,10 @@ fn declare_raw_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty:\n         _ => {},\n     }\n \n+    if ccx.tcx().sess.panic_strategy() != PanicStrategy::Unwind {\n+        attributes::unwind(llfn, false);\n+    }\n+\n     llfn\n }\n "}, {"sha": "3253a0339a850ec209451c5ae0e2f4d9cdbd6356", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use llvm::ValueRef;\n-use rustc::traits;\n use callee;\n use common::*;\n use builder::Builder;\n@@ -87,7 +86,8 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     if let Some(trait_ref) = trait_ref {\n         let trait_ref = trait_ref.with_self_ty(tcx, ty);\n-        let methods = traits::get_vtable_methods(tcx, trait_ref).map(|opt_mth| {\n+        let methods = tcx.vtable_methods(trait_ref);\n+        let methods = methods.iter().cloned().map(|opt_mth| {\n             opt_mth.map_or(nullptr, |(def_id, substs)| {\n                 callee::resolve_and_get_fn(ccx, def_id, substs)\n             })"}, {"sha": "471be439a8f3bb41df43d7d241ffb0bf2a13c5a2", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -15,8 +15,6 @@ use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n \n-use syntax::codemap::DUMMY_SP;\n-\n pub use rustc::ty::Instance;\n \n fn fn_once_adapter_instance<'a, 'tcx>(\n@@ -110,13 +108,14 @@ pub fn custom_coerce_unsize_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            source_ty: Ty<'tcx>,\n                                            target_ty: Ty<'tcx>)\n                                            -> CustomCoerceUnsized {\n+    let def_id = tcx.lang_items().coerce_unsized_trait().unwrap();\n+\n     let trait_ref = ty::Binder(ty::TraitRef {\n-        def_id: tcx.lang_items().coerce_unsized_trait().unwrap(),\n+        def_id: def_id,\n         substs: tcx.mk_substs_trait(source_ty, &[target_ty])\n     });\n \n-    match tcx.trans_fulfill_obligation(\n-        DUMMY_SP, ty::ParamEnv::empty(traits::Reveal::All), trait_ref) {\n+    match tcx.trans_fulfill_obligation( (ty::ParamEnv::empty(traits::Reveal::All), trait_ref)) {\n         traits::VtableImpl(traits::VtableImplData { impl_def_id, .. }) => {\n             tcx.coerce_unsized_info(impl_def_id).custom_kind.unwrap()\n         }"}, {"sha": "386806e4c9c9f27e96ccb2bb51fb8af31c3272fa", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 76, "deletions": 60, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -163,10 +163,27 @@ pub trait CodegenUnitExt<'tcx> {\n         fn item_sort_key<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    item: TransItem<'tcx>) -> ItemSortKey {\n             ItemSortKey(match item {\n-                TransItem::Fn(instance) => {\n-                    tcx.hir.as_local_node_id(instance.def_id())\n+                TransItem::Fn(ref instance) => {\n+                    match instance.def {\n+                        // We only want to take NodeIds of user-defined\n+                        // instances into account. The others don't matter for\n+                        // the codegen tests and can even make item order\n+                        // unstable.\n+                        InstanceDef::Item(def_id) => {\n+                            tcx.hir.as_local_node_id(def_id)\n+                        }\n+                        InstanceDef::Intrinsic(..) |\n+                        InstanceDef::FnPtrShim(..) |\n+                        InstanceDef::Virtual(..) |\n+                        InstanceDef::ClosureOnceShim { .. } |\n+                        InstanceDef::DropGlue(..) |\n+                        InstanceDef::CloneShim(..) => {\n+                            None\n+                        }\n+                    }\n                 }\n-                TransItem::Static(node_id) | TransItem::GlobalAsm(node_id) => {\n+                TransItem::Static(node_id) |\n+                TransItem::GlobalAsm(node_id) => {\n                     Some(node_id)\n                 }\n             }, item.symbol_name(tcx))\n@@ -279,75 +296,74 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut internalization_candidates = FxHashSet();\n \n     for trans_item in trans_items {\n-        let is_root = trans_item.instantiation_mode(tcx) == InstantiationMode::GloballyShared;\n+        match trans_item.instantiation_mode(tcx) {\n+            InstantiationMode::GloballyShared { .. } => {}\n+            InstantiationMode::LocalCopy => continue,\n+        }\n \n-        if is_root {\n-            let characteristic_def_id = characteristic_def_id_of_trans_item(tcx, trans_item);\n-            let is_volatile = is_incremental_build &&\n-                              trans_item.is_generic_fn();\n+        let characteristic_def_id = characteristic_def_id_of_trans_item(tcx, trans_item);\n+        let is_volatile = is_incremental_build &&\n+                          trans_item.is_generic_fn();\n \n-            let codegen_unit_name = match characteristic_def_id {\n-                Some(def_id) => compute_codegen_unit_name(tcx, def_id, is_volatile),\n-                None => Symbol::intern(FALLBACK_CODEGEN_UNIT).as_str(),\n-            };\n+        let codegen_unit_name = match characteristic_def_id {\n+            Some(def_id) => compute_codegen_unit_name(tcx, def_id, is_volatile),\n+            None => Symbol::intern(FALLBACK_CODEGEN_UNIT).as_str(),\n+        };\n \n-            let make_codegen_unit = || {\n-                CodegenUnit::new(codegen_unit_name.clone())\n-            };\n+        let make_codegen_unit = || {\n+            CodegenUnit::new(codegen_unit_name.clone())\n+        };\n \n-            let codegen_unit = codegen_units.entry(codegen_unit_name.clone())\n-                                                .or_insert_with(make_codegen_unit);\n-\n-            let (linkage, visibility) = match trans_item.explicit_linkage(tcx) {\n-                Some(explicit_linkage) => (explicit_linkage, Visibility::Default),\n-                None => {\n-                    match trans_item {\n-                        TransItem::Fn(ref instance) => {\n-                            let visibility = match instance.def {\n-                                InstanceDef::Item(def_id) => {\n-                                    if def_id.is_local() {\n-                                        if tcx.is_exported_symbol(def_id) {\n-                                            Visibility::Default\n-                                        } else {\n-                                            internalization_candidates.insert(trans_item);\n-                                            Visibility::Hidden\n-                                        }\n+        let codegen_unit = codegen_units.entry(codegen_unit_name.clone())\n+                                            .or_insert_with(make_codegen_unit);\n+\n+        let (linkage, visibility) = match trans_item.explicit_linkage(tcx) {\n+            Some(explicit_linkage) => (explicit_linkage, Visibility::Default),\n+            None => {\n+                match trans_item {\n+                    TransItem::Fn(ref instance) => {\n+                        let visibility = match instance.def {\n+                            InstanceDef::Item(def_id) => {\n+                                if def_id.is_local() {\n+                                    if tcx.is_exported_symbol(def_id) {\n+                                        Visibility::Default\n                                     } else {\n-                                        internalization_candidates.insert(trans_item);\n                                         Visibility::Hidden\n                                     }\n+                                } else {\n+                                    Visibility::Hidden\n                                 }\n-                                InstanceDef::FnPtrShim(..) |\n-                                InstanceDef::Virtual(..) |\n-                                InstanceDef::Intrinsic(..) |\n-                                InstanceDef::ClosureOnceShim { .. } |\n-                                InstanceDef::DropGlue(..) |\n-                                InstanceDef::CloneShim(..) => {\n-                                    bug!(\"partitioning: Encountered unexpected\n-                                          root translation item: {:?}\",\n-                                          trans_item)\n-                                }\n-                            };\n-                            (Linkage::External, visibility)\n-                        }\n-                        TransItem::Static(node_id) |\n-                        TransItem::GlobalAsm(node_id) => {\n-                            let def_id = tcx.hir.local_def_id(node_id);\n-                            let visibility = if tcx.is_exported_symbol(def_id) {\n-                                Visibility::Default\n-                            } else {\n-                                internalization_candidates.insert(trans_item);\n+                            }\n+                            InstanceDef::FnPtrShim(..) |\n+                            InstanceDef::Virtual(..) |\n+                            InstanceDef::Intrinsic(..) |\n+                            InstanceDef::ClosureOnceShim { .. } |\n+                            InstanceDef::DropGlue(..) |\n+                            InstanceDef::CloneShim(..) => {\n                                 Visibility::Hidden\n-                            };\n-                            (Linkage::External, visibility)\n-                        }\n+                            }\n+                        };\n+                        (Linkage::External, visibility)\n+                    }\n+                    TransItem::Static(node_id) |\n+                    TransItem::GlobalAsm(node_id) => {\n+                        let def_id = tcx.hir.local_def_id(node_id);\n+                        let visibility = if tcx.is_exported_symbol(def_id) {\n+                            Visibility::Default\n+                        } else {\n+                            Visibility::Hidden\n+                        };\n+                        (Linkage::External, visibility)\n                     }\n                 }\n-            };\n-\n-            codegen_unit.items_mut().insert(trans_item, (linkage, visibility));\n-            roots.insert(trans_item);\n+            }\n+        };\n+        if visibility == Visibility::Hidden {\n+            internalization_candidates.insert(trans_item);\n         }\n+\n+        codegen_unit.items_mut().insert(trans_item, (linkage, visibility));\n+        roots.insert(trans_item);\n     }\n \n     // always ensure we have at least one CGU; otherwise, if we have a"}, {"sha": "060f02ee23e0a83d3a9afe89c93eed138c992101", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 52, "deletions": 9, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -26,11 +26,12 @@ use monomorphize::Instance;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::middle::trans::{Linkage, Visibility};\n+use rustc::session::config::OptLevel;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::subst::{Subst, Substs};\n use syntax::ast;\n-use syntax::attr;\n+use syntax::attr::{self, InlineAttr};\n use syntax_pos::Span;\n use syntax_pos::symbol::Symbol;\n use type_of;\n@@ -44,7 +45,20 @@ pub use rustc::middle::trans::TransItem;\n pub enum InstantiationMode {\n     /// There will be exactly one instance of the given TransItem. It will have\n     /// external linkage so that it can be linked to from other codegen units.\n-    GloballyShared,\n+    GloballyShared {\n+        /// In some compilation scenarios we may decide to take functions that\n+        /// are typically `LocalCopy` and instead move them to `GloballyShared`\n+        /// to avoid translating them a bunch of times. In this situation,\n+        /// however, our local copy may conflict with other crates also\n+        /// inlining the same function.\n+        ///\n+        /// This flag indicates that this situation is occuring, and informs\n+        /// symbol name calculation that some extra mangling is needed to\n+        /// avoid conflicts. Note that this may eventually go away entirely if\n+        /// ThinLTO enables us to *always* have a globally shared instance of a\n+        /// function within one crate's compilation.\n+        may_conflict: bool,\n+    },\n \n     /// Each codegen unit containing a reference to the given TransItem will\n     /// have its own private copy of the function (with internal linkage).\n@@ -154,18 +168,47 @@ pub trait TransItemExt<'a, 'tcx>: fmt::Debug {\n     fn instantiation_mode(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                           -> InstantiationMode {\n+        let inline_in_all_cgus =\n+            tcx.sess.opts.debugging_opts.inline_in_all_cgus.unwrap_or_else(|| {\n+                tcx.sess.opts.optimize != OptLevel::No\n+            });\n+\n         match *self.as_trans_item() {\n             TransItem::Fn(ref instance) => {\n-                if self.explicit_linkage(tcx).is_none() &&\n-                    common::requests_inline(tcx, instance)\n+                // If this function isn't inlined or otherwise has explicit\n+                // linkage, then we'll be creating a globally shared version.\n+                if self.explicit_linkage(tcx).is_some() ||\n+                    !common::requests_inline(tcx, instance)\n                 {\n-                    InstantiationMode::LocalCopy\n-                } else {\n-                    InstantiationMode::GloballyShared\n+                    return InstantiationMode::GloballyShared  { may_conflict: false }\n+                }\n+\n+                // At this point we don't have explicit linkage and we're an\n+                // inlined function. If we're inlining into all CGUs then we'll\n+                // be creating a local copy per CGU\n+                if inline_in_all_cgus {\n+                    return InstantiationMode::LocalCopy\n+                }\n+\n+                // Finally, if this is `#[inline(always)]` we're sure to respect\n+                // that with an inline copy per CGU, but otherwise we'll be\n+                // creating one copy of this `#[inline]` function which may\n+                // conflict with upstream crates as it could be an exported\n+                // symbol.\n+                let attrs = instance.def.attrs(tcx);\n+                match attr::find_inline_attr(Some(tcx.sess.diagnostic()), &attrs) {\n+                    InlineAttr::Always => InstantiationMode::LocalCopy,\n+                    _ => {\n+                        InstantiationMode::GloballyShared  { may_conflict: true }\n+                    }\n                 }\n             }\n-            TransItem::Static(..) => InstantiationMode::GloballyShared,\n-            TransItem::GlobalAsm(..) => InstantiationMode::GloballyShared,\n+            TransItem::Static(..) => {\n+                InstantiationMode::GloballyShared { may_conflict: false }\n+            }\n+            TransItem::GlobalAsm(..) => {\n+                InstantiationMode::GloballyShared { may_conflict: false }\n+            }\n         }\n     }\n "}, {"sha": "7c9497badfbea9925b6f3f450457e8d8bcbada11", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -18,6 +18,7 @@ use hir;\n use hir::def::Def;\n use hir::def_id::DefId;\n use middle::resolve_lifetime as rl;\n+use namespace::Namespace;\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n@@ -827,8 +828,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let trait_did = bound.0.def_id;\n         let (assoc_ident, def_scope) = tcx.adjust(assoc_name, trait_did, ref_id);\n-        let item = tcx.associated_items(trait_did).find(|i| i.name.to_ident() == assoc_ident)\n-                                                  .expect(\"missing associated type\");\n+        let item = tcx.associated_items(trait_did).find(|i| {\n+            Namespace::from(i.kind) == Namespace::Type &&\n+            i.name.to_ident() == assoc_ident\n+        })\n+        .expect(\"missing associated type\");\n \n         let ty = self.projected_ty_from_poly_trait_ref(span, item.def_id, bound);\n         let ty = self.normalize_ty(span, ty);\n@@ -1464,7 +1468,7 @@ impl<'tcx> ExplicitSelf<'tcx> {\n     /// declaration like `self: SomeType` into either `self`,\n     /// `&self`, `&mut self`, or `Box<self>`. We do this here\n     /// by some simple pattern matching. A more precise check\n-    /// is done later in `check_method_self_type()`.\n+    /// is done later in `check_method_receiver()`.\n     ///\n     /// Examples:\n     ///\n@@ -1475,7 +1479,7 @@ impl<'tcx> ExplicitSelf<'tcx> {\n     ///     fn method2(self: &T); // ExplicitSelf::ByValue\n     ///     fn method3(self: Box<&T>); // ExplicitSelf::ByBox\n     ///\n-    ///     // Invalid cases will be caught later by `check_method_self_type`:\n+    ///     // Invalid cases will be caught later by `check_method_receiver`:\n     ///     fn method_err1(self: &mut T); // ExplicitSelf::ByReference\n     /// }\n     /// ```"}, {"sha": "91ce4511a31cb3fe386a403ac4096db1ac56f9b5", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -271,6 +271,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                             fn_sig.output(),\n                                             fn_sig.inputs());\n         self.check_argument_types(call_expr.span,\n+                                  call_expr.span,\n                                   fn_sig.inputs(),\n                                   &expected_arg_tys[..],\n                                   arg_exprs,\n@@ -298,6 +299,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                                fn_sig.inputs());\n \n         self.check_argument_types(call_expr.span,\n+                                  call_expr.span,\n                                   fn_sig.inputs(),\n                                   &expected_arg_tys,\n                                   arg_exprs,\n@@ -315,6 +317,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                method_callee: MethodCallee<'tcx>)\n                                -> Ty<'tcx> {\n         let output_type = self.check_method_argument_types(call_expr.span,\n+                                                           call_expr.span,\n                                                            Ok(method_callee),\n                                                            arg_exprs,\n                                                            TupleArgumentsFlag::TupleArguments,"}, {"sha": "d4eda13c6cd402c8655bd58ac34875e713247d37", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -13,6 +13,7 @@\n use check::FnCtxt;\n use hir::def::Def;\n use hir::def_id::DefId;\n+use namespace::Namespace;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, Ty, ToPredicate, ToPolyTraitRef, TraitRef, TypeFoldable};\n@@ -275,7 +276,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Trait must have a method named `m_name` and it should not have\n         // type parameters or early-bound regions.\n         let tcx = self.tcx;\n-        let method_item = self.associated_item(trait_def_id, m_name).unwrap();\n+        let method_item = self.associated_item(trait_def_id, m_name, Namespace::Value).unwrap();\n         let def_id = method_item.def_id;\n         let generics = tcx.generics_of(def_id);\n         assert_eq!(generics.types.len(), 0);\n@@ -371,10 +372,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     /// Find item with name `item_name` defined in impl/trait `def_id`\n     /// and return it, or `None`, if no such item was defined there.\n-    pub fn associated_item(&self, def_id: DefId, item_name: ast::Name)\n+    pub fn associated_item(&self, def_id: DefId, item_name: ast::Name, ns: Namespace)\n                            -> Option<ty::AssociatedItem> {\n         self.tcx.associated_items(def_id)\n-                .find(|item| self.tcx.hygienic_eq(item_name, item.name, def_id))\n-\n+                .find(|item| Namespace::from(item.kind) == ns &&\n+                             self.tcx.hygienic_eq(item_name, item.name, def_id))\n     }\n }"}, {"sha": "78941cb3a56868b2b1f96caabde6b6deac49ae12", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -16,6 +16,7 @@ use super::suggest;\n use check::FnCtxt;\n use hir::def_id::DefId;\n use hir::def::Def;\n+use namespace::Namespace;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::traits::{self, ObligationCause};\n use rustc::ty::{self, Ty, ToPolyTraitRef, ToPredicate, TraitRef, TypeFoldable};\n@@ -1317,11 +1318,14 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 self.tcx.associated_items(def_id)\n                     .filter(|x| {\n                         let dist = lev_distance(&*name.as_str(), &x.name.as_str());\n-                        dist > 0 && dist <= max_dist\n+                        Namespace::from(x.kind) == Namespace::Value && dist > 0\n+                        && dist <= max_dist\n                     })\n                     .collect()\n             } else {\n-                self.fcx.associated_item(def_id, name).map_or(Vec::new(), |x| vec![x])\n+                self.fcx\n+                    .associated_item(def_id, name, Namespace::Value)\n+                    .map_or(Vec::new(), |x| vec![x])\n             }\n         } else {\n             self.tcx.associated_items(def_id).collect()"}, {"sha": "23148406a111ecb62d6a3e953e71489a68d6c7e1", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -17,6 +17,7 @@ use rustc::ty::{self, Ty, TyCtxt, ToPolyTraitRef, ToPredicate, TypeFoldable};\n use hir::def::Def;\n use hir::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::lang_items::FnOnceTraitLangItem;\n+use namespace::Namespace;\n use rustc::traits::{Obligation, SelectionContext};\n use util::nodemap::FxHashSet;\n \n@@ -92,12 +93,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     CandidateSource::ImplSource(impl_did) => {\n                         // Provide the best span we can. Use the item, if local to crate, else\n                         // the impl, if local to crate (item may be defaulted), else nothing.\n-                        let item = self.associated_item(impl_did, item_name)\n+                        let item = self.associated_item(impl_did, item_name, Namespace::Value)\n                             .or_else(|| {\n                                 self.associated_item(\n                                     self.tcx.impl_trait_ref(impl_did).unwrap().def_id,\n-\n-                                    item_name\n+                                    item_name,\n+                                    Namespace::Value,\n                                 )\n                             }).unwrap();\n                         let note_span = self.tcx.hir.span_if_local(item.def_id).or_else(|| {\n@@ -127,7 +128,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                     }\n                     CandidateSource::TraitSource(trait_did) => {\n-                        let item = self.associated_item(trait_did, item_name).unwrap();\n+                        let item = self\n+                            .associated_item(trait_did, item_name, Namespace::Value)\n+                            .unwrap();\n                         let item_span = self.tcx.def_span(item.def_id);\n                         span_note!(err,\n                                    item_span,\n@@ -402,7 +405,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // implementing a trait would be legal but is rejected\n                 // here).\n                 (type_is_local || info.def_id.is_local())\n-                    && self.associated_item(info.def_id, item_name).is_some()\n+                    && self.associated_item(info.def_id, item_name, Namespace::Value).is_some()\n             })\n             .collect::<Vec<_>>();\n "}, {"sha": "0ebccbc835fc1bd6972af5143eec67d84d6ccfd5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 30, "deletions": 13, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -88,6 +88,7 @@ use astconv::AstConv;\n use hir::def::{Def, CtorKind};\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_back::slice::ref_slice;\n+use namespace::Namespace;\n use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin};\n use rustc::infer::type_variable::{TypeVariableOrigin};\n use rustc::middle::region;\n@@ -728,7 +729,7 @@ fn typeck_item_bodies<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum\n     debug_assert!(crate_num == LOCAL_CRATE);\n     Ok(tcx.sess.track_errors(|| {\n         for body_owner_def_id in tcx.body_owners() {\n-            tcx.typeck_tables_of(body_owner_def_id);\n+            ty::maps::queries::typeck_tables_of::ensure(tcx, body_owner_def_id);\n         }\n     })?)\n }\n@@ -1293,7 +1294,13 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     for impl_item in impl_items() {\n         let ty_impl_item = tcx.associated_item(tcx.hir.local_def_id(impl_item.id));\n         let ty_trait_item = tcx.associated_items(impl_trait_ref.def_id)\n-            .find(|ac| tcx.hygienic_eq(ty_impl_item.name, ac.name, impl_trait_ref.def_id));\n+            .find(|ac| Namespace::from(&impl_item.node) == Namespace::from(ac.kind) &&\n+                         tcx.hygienic_eq(ty_impl_item.name, ac.name, impl_trait_ref.def_id))\n+            .or_else(|| {\n+                // Not compatible, but needed for the error message\n+                tcx.associated_items(impl_trait_ref.def_id)\n+                   .find(|ac| tcx.hygienic_eq(ty_impl_item.name, ac.name, impl_trait_ref.def_id))\n+            });\n \n         // Check that impl definition matches trait definition\n         if let Some(ty_trait_item) = ty_trait_item {\n@@ -2352,6 +2359,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn check_method_argument_types(&self,\n                                    sp: Span,\n+                                   expr_sp: Span,\n                                    method: Result<MethodCallee<'tcx>, ()>,\n                                    args_no_rcvr: &'gcx [hir::Expr],\n                                    tuple_arguments: TupleArgumentsFlag,\n@@ -2371,7 +2379,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 TupleArguments => vec![self.tcx.intern_tup(&err_inputs[..], false)],\n             };\n \n-            self.check_argument_types(sp, &err_inputs[..], &[], args_no_rcvr,\n+            self.check_argument_types(sp, expr_sp, &err_inputs[..], &[], args_no_rcvr,\n                                       false, tuple_arguments, None);\n             return self.tcx.types.err;\n         }\n@@ -2384,7 +2392,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             method.sig.output(),\n             &method.sig.inputs()[1..]\n         );\n-        self.check_argument_types(sp, &method.sig.inputs()[1..], &expected_arg_tys[..],\n+        self.check_argument_types(sp, expr_sp, &method.sig.inputs()[1..], &expected_arg_tys[..],\n                                   args_no_rcvr, method.sig.variadic, tuple_arguments,\n                                   self.tcx.hir.span_if_local(method.def_id));\n         method.sig.output()\n@@ -2394,6 +2402,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// method calls and overloaded operators.\n     fn check_argument_types(&self,\n                             sp: Span,\n+                            expr_sp: Span,\n                             fn_inputs: &[Ty<'tcx>],\n                             expected_arg_tys: &[Ty<'tcx>],\n                             args: &'gcx [hir::Expr],\n@@ -2434,9 +2443,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             sp\n         };\n \n-        fn parameter_count_error<'tcx>(sess: &Session, sp: Span, expected_count: usize,\n-                                       arg_count: usize, error_code: &str, variadic: bool,\n-                                       def_span: Option<Span>, sugg_unit: bool) {\n+        fn parameter_count_error<'tcx>(sess: &Session,\n+                                       sp: Span,\n+                                       expr_sp: Span,\n+                                       expected_count: usize,\n+                                       arg_count: usize,\n+                                       error_code: &str,\n+                                       variadic: bool,\n+                                       def_span: Option<Span>,\n+                                       sugg_unit: bool) {\n             let mut err = sess.struct_span_err_with_code(sp,\n                 &format!(\"this function takes {}{} parameter{} but {} parameter{} supplied\",\n                     if variadic {\"at least \"} else {\"\"},\n@@ -2450,12 +2465,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 err.span_label(def_s, \"defined here\");\n             }\n             if sugg_unit {\n-                let sugg_span = sp.end_point();\n+                let sugg_span = expr_sp.end_point();\n                 // remove closing `)` from the span\n                 let sugg_span = sugg_span.with_hi(sugg_span.lo());\n                 err.span_suggestion(\n                     sugg_span,\n-                    \"expected the unit value `()`. You can create one with a pair of parenthesis\",\n+                    \"expected the unit value `()`; create it with empty parentheses\",\n                     String::from(\"()\"));\n             } else {\n                 err.span_label(sp, format!(\"expected {}{} parameter{}\",\n@@ -2470,7 +2485,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let tuple_type = self.structurally_resolved_type(sp, fn_inputs[0]);\n             match tuple_type.sty {\n                 ty::TyTuple(arg_types, _) if arg_types.len() != args.len() => {\n-                    parameter_count_error(tcx.sess, sp_args, arg_types.len(), args.len(),\n+                    parameter_count_error(tcx.sess, sp_args, expr_sp, arg_types.len(), args.len(),\n                                           \"E0057\", false, def_span, false);\n                     expected_arg_tys = &[];\n                     self.err_args(args.len())\n@@ -2499,7 +2514,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             if supplied_arg_count >= expected_arg_count {\n                 fn_inputs.to_vec()\n             } else {\n-                parameter_count_error(tcx.sess, sp_args, expected_arg_count,\n+                parameter_count_error(tcx.sess, sp_args, expr_sp, expected_arg_count,\n                                       supplied_arg_count, \"E0060\", true, def_span, false);\n                 expected_arg_tys = &[];\n                 self.err_args(supplied_arg_count)\n@@ -2513,7 +2528,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             } else {\n                 false\n             };\n-            parameter_count_error(tcx.sess, sp_args, expected_arg_count,\n+            parameter_count_error(tcx.sess, sp_args, expr_sp, expected_arg_count,\n                                   supplied_arg_count, \"E0061\", false, def_span, sugg_unit);\n             expected_arg_tys = &[];\n             self.err_args(supplied_arg_count)\n@@ -2866,7 +2881,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         // Call the generic checker.\n-        self.check_method_argument_types(span, method,\n+        self.check_method_argument_types(span,\n+                                         expr.span,\n+                                         method,\n                                          &args[1..],\n                                          DontTupleArguments,\n                                          expected)"}, {"sha": "1355f711a4b14f5da51448743877b224d5c743e5", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -8,11 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use namespace::Namespace;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::traits;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::TyCtxt;\n \n pub fn crate_inherent_impls_overlap_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                     crate_num: CrateNum) {\n@@ -28,19 +29,10 @@ struct InherentOverlapChecker<'a, 'tcx: 'a> {\n impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n     fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId,\n                                        overlap: traits::OverlapResult) {\n-        #[derive(Copy, Clone, PartialEq)]\n-        enum Namespace {\n-            Type,\n-            Value,\n-        }\n \n         let name_and_namespace = |def_id| {\n             let item = self.tcx.associated_item(def_id);\n-            (item.name, match item.kind {\n-                ty::AssociatedKind::Type => Namespace::Type,\n-                ty::AssociatedKind::Const |\n-                ty::AssociatedKind::Method => Namespace::Value,\n-            })\n+            (item.name, Namespace::from(item.kind))\n         };\n \n         let impl_items1 = self.tcx.associated_item_def_ids(impl1);"}, {"sha": "1c047ef98d831f643a1a5ee50899a8674c937c7d", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -123,6 +123,7 @@ mod constrained_type_params;\n mod impl_wf_check;\n mod coherence;\n mod variance;\n+mod namespace;\n \n pub struct TypeAndSubsts<'tcx> {\n     substs: &'tcx Substs<'tcx>,"}, {"sha": "6f0e46b3afee11ba60c5445fd7e19726f6939d6d", "filename": "src/librustc_typeck/namespace.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_typeck%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustc_typeck%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fnamespace.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir;\n+use rustc::ty;\n+\n+// Whether an item exists in the type or value namespace.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum Namespace {\n+    Type,\n+    Value,\n+}\n+\n+impl From<ty::AssociatedKind> for Namespace {\n+    fn from(a_kind: ty::AssociatedKind) -> Self {\n+        match a_kind {\n+            ty::AssociatedKind::Type => Namespace::Type,\n+            ty::AssociatedKind::Const |\n+            ty::AssociatedKind::Method => Namespace::Value,\n+        }\n+    }\n+}\n+\n+impl<'a> From <&'a hir::ImplItemKind> for Namespace {\n+    fn from(impl_kind: &'a hir::ImplItemKind) -> Self {\n+        match *impl_kind {\n+            hir::ImplItemKind::Type(..) => Namespace::Type,\n+            hir::ImplItemKind::Const(..) |\n+            hir::ImplItemKind::Method(..) => Namespace::Value,\n+        }\n+    }\n+}"}, {"sha": "e168222058f9a32b290d1424ede8c3cb376051a3", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -18,4 +18,4 @@ html-diff = \"0.0.4\"\n \n [build-dependencies]\n build_helper = { path = \"../build_helper\" }\n-cc = \"1.0\"\n+cc = \"1.0.1\""}, {"sha": "e217978648efa21bc836f6aeeb8f9c905d67a62d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -112,6 +112,7 @@ impl<T: Clean<U>, U> Clean<Vec<U>> for P<[T]> {\n #[derive(Clone, Debug)]\n pub struct Crate {\n     pub name: String,\n+    pub version: Option<String>,\n     pub src: PathBuf,\n     pub module: Option<Item>,\n     pub externs: Vec<(CrateNum, ExternalCrate)>,\n@@ -183,6 +184,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n \n         Crate {\n             name,\n+            version: None,\n             src,\n             module: Some(module),\n             externs,\n@@ -1681,6 +1683,21 @@ impl Type {\n             _ => false\n         }\n     }\n+\n+    pub fn generics(&self) -> Option<&[Type]> {\n+        match *self {\n+            ResolvedPath { ref path, .. } => {\n+                path.segments.last().and_then(|seg| {\n+                    if let PathParameters::AngleBracketed { ref types, .. } = seg.params {\n+                        Some(&**types)\n+                    } else {\n+                        None\n+                    }\n+                })\n+            }\n+            _ => None,\n+        }\n+    }\n }\n \n impl GetDefId for Type {"}, {"sha": "2f7bd5e39a14927aad28c8988b82ae497e66680f", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -10,7 +10,6 @@\n \n use std::fs::File;\n use std::io::prelude::*;\n-use std::io;\n use std::path::Path;\n use std::str;\n use html::markdown::{Markdown, RenderType};\n@@ -70,17 +69,13 @@ pub fn load_string<P: AsRef<Path>>(file_path: P) -> Result<String, LoadStringErr\n     let result = File::open(file_path)\n                       .and_then(|mut f| f.read_to_end(&mut contents));\n     if let Err(e) = result {\n-        let _ = writeln!(&mut io::stderr(),\n-                         \"error reading `{}`: {}\",\n-                         file_path.display(), e);\n+        eprintln!(\"error reading `{}`: {}\", file_path.display(), e);\n         return Err(LoadStringError::ReadFail);\n     }\n     match str::from_utf8(&contents) {\n         Ok(s) => Ok(s.to_string()),\n         Err(_) => {\n-            let _ = writeln!(&mut io::stderr(),\n-                             \"error reading `{}`: not UTF-8\",\n-                             file_path.display());\n+            eprintln!(\"error reading `{}`: not UTF-8\", file_path.display());\n             Err(LoadStringError::BadUtf8)\n         }\n     }"}, {"sha": "873d978b9cb84b960cb58f47b099e32aafa884c8", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -97,9 +97,9 @@ r##\"<!DOCTYPE html>\n                     <dd>Show this help dialog</dd>\n                     <dt>S</dt>\n                     <dd>Focus the search field</dd>\n-                    <dt>&larrb;</dt>\n+                    <dt>\u2191</dt>\n                     <dd>Move up in search results</dd>\n-                    <dt>&rarrb;</dt>\n+                    <dt>\u2193</dt>\n                     <dd>Move down in search results</dd>\n                     <dt>&#9166;</dt>\n                     <dd>Go to active search result</dd>"}, {"sha": "3c789cb3a15939d3c50afa7d35356b8418e6c31f", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 55, "deletions": 13, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -125,6 +125,21 @@ pub struct SharedContext {\n     /// Warnings for the user if rendering would differ using different markdown\n     /// parsers.\n     pub markdown_warnings: RefCell<Vec<(Span, String, Vec<html_diff::Difference>)>>,\n+    /// The directories that have already been created in this doc run. Used to reduce the number\n+    /// of spurious `create_dir_all` calls.\n+    pub created_dirs: RefCell<FxHashSet<PathBuf>>,\n+}\n+\n+impl SharedContext {\n+    fn ensure_dir(&self, dst: &Path) -> io::Result<()> {\n+        let mut dirs = self.created_dirs.borrow_mut();\n+        if !dirs.contains(dst) {\n+            fs::create_dir_all(dst)?;\n+            dirs.insert(dst.to_path_buf());\n+        }\n+\n+        Ok(())\n+    }\n }\n \n /// Indicates where an external crate can be found.\n@@ -256,6 +271,9 @@ pub struct Cache {\n     // the access levels from crateanalysis.\n     pub access_levels: Arc<AccessLevels<DefId>>,\n \n+    /// The version of the crate being documented, if given fron the `--crate-version` flag.\n+    pub crate_version: Option<String>,\n+\n     // Private fields only used when initially crawling a crate to build a cache\n \n     stack: Vec<String>,\n@@ -460,6 +478,7 @@ pub fn run(mut krate: clean::Crate,\n         },\n         css_file_extension: css_file_extension.clone(),\n         markdown_warnings: RefCell::new(vec![]),\n+        created_dirs: RefCell::new(FxHashSet()),\n     };\n \n     // If user passed in `--playground-url` arg, we fill in crate name here\n@@ -534,6 +553,7 @@ pub fn run(mut krate: clean::Crate,\n         primitive_locations: FxHashMap(),\n         stripped_mod: false,\n         access_levels: krate.access_levels.clone(),\n+        crate_version: krate.version.take(),\n         orphan_impl_items: Vec::new(),\n         traits: mem::replace(&mut krate.external_traits, FxHashMap()),\n         deref_trait_did,\n@@ -790,7 +810,6 @@ fn write_shared(cx: &Context,\n     // Write out the shared files. Note that these are shared among all rustdoc\n     // docs placed in the output directory, so this needs to be a synchronized\n     // operation with respect to all other rustdocs running around.\n-    try_err!(fs::create_dir_all(&cx.dst), &cx.dst);\n     let _lock = flock::Lock::panicking_new(&cx.dst.join(\".lock\"), true, true, true);\n \n     // Add all the static files. These may already exist, but we just\n@@ -1306,7 +1325,8 @@ impl DocFolder for Cache {\n                 // Figure out the id of this impl. This may map to a\n                 // primitive rather than always to a struct/enum.\n                 // Note: matching twice to restrict the lifetime of the `i` borrow.\n-                let did = if let clean::Item { inner: clean::ImplItem(ref i), .. } = item {\n+                let mut dids = vec![];\n+                if let clean::Item { inner: clean::ImplItem(ref i), .. } = item {\n                     let masked_trait = i.trait_.def_id().map_or(false,\n                         |d| self.masked_crates.contains(&d.krate));\n                     if !masked_trait {\n@@ -1315,23 +1335,33 @@ impl DocFolder for Cache {\n                             clean::BorrowedRef {\n                                 type_: box clean::ResolvedPath { did, .. }, ..\n                             } => {\n-                                Some(did)\n+                                dids.push(did);\n                             }\n                             ref t => {\n-                                t.primitive_type().and_then(|t| {\n+                                let did = t.primitive_type().and_then(|t| {\n                                     self.primitive_locations.get(&t).cloned()\n-                                })\n+                                });\n+\n+                                if let Some(did) = did {\n+                                    dids.push(did);\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    if let Some(generics) = i.trait_.as_ref().and_then(|t| t.generics()) {\n+                        for bound in generics {\n+                            if let Some(did) = bound.def_id() {\n+                                dids.push(did);\n                             }\n                         }\n-                    } else {\n-                        None\n                     }\n                 } else {\n                     unreachable!()\n                 };\n-                if let Some(did) = did {\n+                for did in dids {\n                     self.impls.entry(did).or_insert(vec![]).push(Impl {\n-                        impl_item: item,\n+                        impl_item: item.clone(),\n                     });\n                 }\n                 None\n@@ -1503,8 +1533,8 @@ impl Context {\n                 this.render_item(&mut buf, &item, false).unwrap();\n                 // buf will be empty if the module is stripped and there is no redirect for it\n                 if !buf.is_empty() {\n+                    try_err!(this.shared.ensure_dir(&this.dst), &this.dst);\n                     let joint_dst = this.dst.join(\"index.html\");\n-                    try_err!(fs::create_dir_all(&this.dst), &this.dst);\n                     let mut dst = try_err!(File::create(&joint_dst), &joint_dst);\n                     try_err!(dst.write_all(&buf), &joint_dst);\n                 }\n@@ -1538,18 +1568,19 @@ impl Context {\n                 let name = item.name.as_ref().unwrap();\n                 let item_type = item.type_();\n                 let file_name = &item_path(item_type, name);\n+                try_err!(self.shared.ensure_dir(&self.dst), &self.dst);\n                 let joint_dst = self.dst.join(file_name);\n-                try_err!(fs::create_dir_all(&self.dst), &self.dst);\n                 let mut dst = try_err!(File::create(&joint_dst), &joint_dst);\n                 try_err!(dst.write_all(&buf), &joint_dst);\n \n                 // Redirect from a sane URL using the namespace to Rustdoc's\n                 // URL for the page.\n                 let redir_name = format!(\"{}.{}.html\", name, item_type.name_space());\n                 let redir_dst = self.dst.join(redir_name);\n-                if let Ok(mut redirect_out) = OpenOptions::new().create_new(true)\n+                if let Ok(redirect_out) = OpenOptions::new().create_new(true)\n                                                                 .write(true)\n                                                                 .open(&redir_dst) {\n+                    let mut redirect_out = BufWriter::new(redirect_out);\n                     try_err!(layout::redirect(&mut redirect_out, file_name), &redir_dst);\n                 }\n \n@@ -1559,7 +1590,8 @@ impl Context {\n                 if item_type == ItemType::Macro {\n                     let redir_name = format!(\"{}.{}!.html\", item_type, name);\n                     let redir_dst = self.dst.join(redir_name);\n-                    let mut redirect_out = try_err!(File::create(&redir_dst), &redir_dst);\n+                    let redirect_out = try_err!(File::create(&redir_dst), &redir_dst);\n+                    let mut redirect_out = BufWriter::new(redirect_out);\n                     try_err!(layout::redirect(&mut redirect_out, file_name), &redir_dst);\n                 }\n             }\n@@ -3422,6 +3454,16 @@ impl<'a> fmt::Display for Sidebar<'a> {\n             write!(fmt, \"{}\", it.name.as_ref().unwrap())?;\n             write!(fmt, \"</p>\")?;\n \n+            if it.is_crate() {\n+                if let Some(ref version) = cache().crate_version {\n+                    write!(fmt,\n+                           \"<div class='block version'>\\\n+                            <p>Version {}</p>\\\n+                            </div>\",\n+                           version)?;\n+                }\n+            }\n+\n             match it.inner {\n                 clean::StructItem(ref s) => sidebar_struct(fmt, it, s)?,\n                 clean::TraitItem(ref t) => sidebar_trait(fmt, it, t)?,"}, {"sha": "bccad6c89dc4fa3ada9f74606f030c7376897f29", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 145, "deletions": 22, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -342,6 +342,17 @@\n                 }\n             }\n \n+            function findArg(obj, val) {\n+                if (obj && obj.type && obj.type.inputs.length > 0) {\n+                    for (var i = 0; i < obj.type.inputs.length; i++) {\n+                        if (obj.type.inputs[i].name === val) {\n+                            return true;\n+                        }\n+                    }\n+                }\n+                return false;\n+            }\n+\n             function typePassesFilter(filter, type) {\n                 // No filter\n                 if (filter < 0) return true;\n@@ -376,18 +387,28 @@\n                         if (typePassesFilter(typeFilter, searchIndex[i].ty)) {\n                             results.push({id: i, index: -1});\n                         }\n+                    } else if (findArg(searchIndex[i], val.toLowerCase()) ||\n+                               (searchIndex[i].type &&\n+                                searchIndex[i].type.output &&\n+                                searchIndex[i].type.output.name === val.toLowerCase())) {\n+                        if (typePassesFilter(typeFilter, searchIndex[i].ty)) {\n+                            results.push({id: i, index: -1, dontValidate: true});\n+                        }\n                     }\n                     if (results.length === max) {\n                         break;\n                     }\n                 }\n+                query.inputs = [val];\n+                query.output = val;\n+                query.search = val;\n             // searching by type\n             } else if (val.search(\"->\") > -1) {\n                 var trimmer = function (s) { return s.trim(); };\n                 var parts = val.split(\"->\").map(trimmer);\n                 var input = parts[0];\n                 // sort inputs so that order does not matter\n-                var inputs = input.split(\",\").map(trimmer).sort().toString();\n+                var inputs = input.split(\",\").map(trimmer).sort();\n                 var output = parts[1];\n \n                 for (var i = 0; i < nSearchWords; ++i) {\n@@ -403,12 +424,30 @@\n \n                     // allow searching for void (no output) functions as well\n                     var typeOutput = type.output ? type.output.name : \"\";\n-                    if ((inputs === \"*\" || inputs === typeInputs.toString()) &&\n-                        (output === \"*\" || output == typeOutput)) {\n-                        results.push({id: i, index: -1, dontValidate: true});\n+                    if (output === \"*\" || output == typeOutput) {\n+                        if (input === \"*\") {\n+                            results.push({id: i, index: -1, dontValidate: true});\n+                        } else {\n+                            var allFound = true;\n+                            for (var it = 0; allFound === true && it < inputs.length; it++) {\n+                                var found = false;\n+                                for (var y = 0; found === false && y < typeInputs.length; y++) {\n+                                    found = typeInputs[y] === inputs[it];\n+                                }\n+                                allFound = found;\n+                            }\n+                            if (allFound === true) {\n+                                results.push({id: i, index: -1, dontValidate: true});\n+                            }\n+                        }\n                     }\n                 }\n+                query.inputs = inputs;\n+                query.output = output;\n             } else {\n+                query.inputs = [val];\n+                query.output = val;\n+                query.search = val;\n                 // gather matching search results up to a certain maximum\n                 val = val.replace(/\\_/g, \"\");\n                 for (var i = 0; i < split.length; ++i) {\n@@ -437,6 +476,15 @@\n                                     lev: lev_distance,\n                                 });\n                             }\n+                        } else if (findArg(searchIndex[j], val)) {\n+                            if (typePassesFilter(typeFilter, searchIndex[j].ty)) {\n+                                results.push({\n+                                    id: j,\n+                                    index: 0,\n+                                    // we want lev results to go lower than others\n+                                    lev: lev_distance,\n+                                });\n+                            }\n                         }\n                         if (results.length === max) {\n                             break;\n@@ -576,8 +624,7 @@\n                     (parent !== undefined &&\n                         parent.name.toLowerCase().indexOf(keys[i]) > -1) ||\n                     // lastly check to see if the name was a levenshtein match\n-                    levenshtein(name.toLowerCase(), keys[i]) <=\n-                        MAX_LEV_DISTANCE)) {\n+                    levenshtein(name.toLowerCase(), keys[i]) <= MAX_LEV_DISTANCE)) {\n                     return false;\n                 }\n             }\n@@ -692,18 +739,18 @@\n             return h1.innerHTML;\n         }\n \n-        function showResults(results) {\n-            var output, shown, query = getQuery();\n-\n-            currentResults = query.id;\n-            output = '<h1>Results for ' + escape(query.query) +\n-                (query.type ? ' (type: ' + escape(query.type) + ')' : '') + '</h1>';\n-            output += '<table class=\"search-results\">';\n+        function addTab(array, query, display) {\n+            var extraStyle = '';\n+            if (display === false) {\n+                extraStyle = ' style=\"display: none;\"';\n+            }\n \n-            if (results.length > 0) {\n-                shown = [];\n+            var output = '';\n+            if (array.length > 0) {\n+                output = `<table class=\"search-results\"${extraStyle}>`;\n+                var shown = [];\n \n-                results.forEach(function(item) {\n+                array.forEach(function(item) {\n                     var name, type, href, displayPath;\n \n                     if (shown.indexOf(item) !== -1) {\n@@ -752,13 +799,32 @@\n                               '<span class=\"desc\">' + escape(item.desc) +\n                               '&nbsp;</span></a></td></tr>';\n                 });\n+                output += '</table>';\n             } else {\n-                output += 'No results :( <a href=\"https://duckduckgo.com/?q=' +\n+                output = `<div class=\"search-failed\"${extraStyle}>No results :(<br/>` +\n+                    'Try on <a href=\"https://duckduckgo.com/?q=' +\n                     encodeURIComponent('rust ' + query.query) +\n-                    '\">Try on DuckDuckGo?</a>';\n+                    '\">DuckDuckGo</a>?</div>';\n             }\n+            return output;\n+        }\n+\n+        function showResults(results) {\n+            var output, query = getQuery();\n+\n+            currentResults = query.id;\n+            output = '<h1>Results for ' + escape(query.query) +\n+                (query.type ? ' (type: ' + escape(query.type) + ')' : '') + '</h1>' +\n+                '<div id=\"titles\">' +\n+                '<div class=\"selected\">Types/modules</div>' +\n+                '<div>As parameters</div>' +\n+                '<div>As return value</div></div><div id=\"results\">';\n+\n+            output += addTab(results['others'], query);\n+            output += addTab(results['in_args'], query, false);\n+            output += addTab(results['returned'], query, false);\n+            output += '</div>';\n \n-            output += \"</p>\";\n             addClass(document.getElementById('main'), 'hidden');\n             var search = document.getElementById('search');\n             removeClass(search, 'hidden');\n@@ -773,13 +839,17 @@\n                 e.style.width = width + 'px';\n             });\n             initSearchNav();\n+            var elems = document.getElementById('titles').childNodes;\n+            elems[0].onclick = function() { printTab(0); };\n+            elems[1].onclick = function() { printTab(1); };\n+            elems[2].onclick = function() { printTab(2); };\n         }\n \n         function search(e) {\n             var query,\n                 filterdata = [],\n                 obj, i, len,\n-                results = [],\n+                results = {\"in_args\": [], \"returned\": [], \"others\": []},\n                 maxResults = 200,\n                 resultIndex;\n             var params = getQueryStringParams();\n@@ -810,11 +880,43 @@\n             len = resultIndex.length;\n             for (i = 0; i < len; ++i) {\n                 if (resultIndex[i].id > -1) {\n+                    var added = false;\n                     obj = searchIndex[resultIndex[i].id];\n                     filterdata.push([obj.name, obj.ty, obj.path, obj.desc]);\n-                    results.push(obj);\n+                    if (obj.type) {\n+                        if (results['returned'].length < maxResults &&\n+                            obj.type.output &&\n+                            obj.type.output.name.toLowerCase() === query.output) {\n+                            results['returned'].push(obj);\n+                            added = true;\n+                        }\n+                        if (results['in_args'].length < maxResults && obj.type.inputs.length > 0) {\n+                            var all_founds = true;\n+                            for (var it = 0;\n+                                 all_founds === true && it < query.inputs.length;\n+                                 it++) {\n+                                var found = false;\n+                                for (var y = 0;\n+                                     found === false && y < obj.type.inputs.length;\n+                                     y++) {\n+                                    found = query.inputs[it] === obj.type.inputs[y].name;\n+                                }\n+                                all_founds = found;\n+                            }\n+                            if (all_founds === true) {\n+                                results['in_args'].push(obj);\n+                                added = true;\n+                            }\n+                        }\n+                    }\n+                    if (results['others'].length < maxResults &&\n+                        ((query.search && obj.name.indexOf(query.search)) || added === false)) {\n+                        results['others'].push(obj);\n+                    }\n                 }\n-                if (results.length >= maxResults) {\n+                if (results['others'].length >= maxResults &&\n+                    results['in_args'].length >= maxResults &&\n+                    results['returned'].length >= maxResults) {\n                     break;\n                 }\n             }\n@@ -1290,6 +1392,27 @@\n         return wrapper;\n     }\n \n+    // In the search display, allows to switch between tabs.\n+    function printTab(nb) {\n+        var nb_copy = nb;\n+        onEach(document.getElementById('titles').childNodes, function(elem) {\n+            if (nb_copy === 0) {\n+                addClass(elem, 'selected');\n+            } else {\n+                removeClass(elem, 'selected');\n+            }\n+            nb_copy -= 1;\n+        });\n+        onEach(document.getElementById('results').childNodes, function(elem) {\n+            if (nb === 0) {\n+                elem.style.display = '';\n+            } else {\n+                elem.style.display = 'none';\n+            }\n+            nb -= 1;\n+        });\n+    }\n+\n     onEach(document.getElementById('main').getElementsByTagName('pre'), function(e) {\n         onEach(e.getElementsByClassName('attributes'), function(i_e) {\n             i_e.parentNode.insertBefore(createToggleWrapper(), i_e);"}, {"sha": "a132223a051017a90956060d345a6487da152ae7", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 47, "deletions": 6, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -203,6 +203,15 @@ nav.sub {\n \tword-wrap: break-word;\n }\n \n+.sidebar .version {\n+\tfont-size: 15px;\n+\ttext-align: center;\n+\tborder-bottom: #DDDDDD 1px solid;\n+\toverflow-wrap: break-word;\n+\tword-wrap: break-word; /* deprecated */\n+\tword-break: break-word; /* Chrome, non-standard */\n+}\n+\n .location:empty {\n \tborder: none;\n }\n@@ -385,7 +394,7 @@ h4 > code, h3 > code, .invisible > code {\n \tpadding: 0;\n }\n \n-.content .item-list li { margin-bottom: 3px; }\n+.content .item-list li { margin-bottom: 1em; }\n \n .content .multi-column {\n \t-moz-column-count: 5;\n@@ -764,17 +773,19 @@ span.since {\n \t}\n \n \t.sidebar {\n-\t\theight: 40px;\n+\t\theight: 45px;\n \t\tmin-height: 40px;\n-\t\twidth: 100%;\n-\t\tmargin: 0px;\n-\t\tpadding: 0px;\n+\t\twidth: calc(100% + 30px);\n+\t\tmargin: 0;\n+\t\tmargin-left: -15px;\n+\t\tpadding: 0 15px;\n \t\tposition: static;\n \t}\n \n \t.sidebar .location {\n \t\tfloat: right;\n \t\tmargin: 0px;\n+\t\tmargin-top: 2px;\n \t\tpadding: 3px 10px 1px 10px;\n \t\tmin-height: 39px;\n \t\tbackground: inherit;\n@@ -789,7 +800,7 @@ span.since {\n \t.sidebar img {\n \t\twidth: 35px;\n \t\tmargin-top: 5px;\n-\t\tmargin-bottom: 0px;\n+\t\tmargin-bottom: 5px;\n \t\tfloat: left;\n \t}\n \n@@ -820,6 +831,10 @@ span.since {\n \t.toggle-wrapper {\n \t\theight: 1.5em;\n \t}\n+\n+\t#search {\n+\t\tmargin-left: 0;\n+\t}\n }\n \n @media print {\n@@ -873,3 +888,29 @@ span.since {\n pre.rust {\n \tposition: relative;\n }\n+\n+.search-failed {\n+\ttext-align: center;\n+\tmargin-top: 20px;\n+}\n+\n+#titles {\n+\theight: 35px;\n+}\n+\n+#titles > div {\n+\tfloat: left;\n+\twidth: 33.3%;\n+\ttext-align: center;\n+\tborder-bottom: 1px solid #ccc;\n+\tfont-size: 18px;\n+\tcursor: pointer;\n+}\n+\n+#titles > div.selected {\n+\tborder-bottom: 3px solid #0078ee;\n+}\n+\n+#titles > div:hover {\n+\tborder-bottom: 3px solid #0089ff;\n+}"}, {"sha": "4a4ca15170a4655d08acc4c7f205219a522fe3aa", "filename": "src/librustdoc/html/static/styles/main.css", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -235,3 +235,7 @@ pre.ignore:hover, .information:hover + pre.ignore {\n .information > .ignore:hover {\n \tcolor: rgba(255,142,0,1);\n }\n+\n+.search-failed > a {\n+\tcolor: #0089ff;\n+}"}, {"sha": "890e1169c05918e1ea8a9024fe11acd39602cebe", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -243,6 +243,12 @@ pub fn opts() -> Vec<RustcOptGroup> {\n         unstable(\"display-warnings\", |o| {\n             o.optflag(\"\", \"display-warnings\", \"to print code warnings when testing doc\")\n         }),\n+        unstable(\"crate-version\", |o| {\n+            o.optopt(\"\", \"crate-version\", \"crate version to print into documentation\", \"VERSION\")\n+        }),\n+        unstable(\"linker\", |o| {\n+            o.optopt(\"\", \"linker\", \"linker used for building executable test code\", \"PATH\")\n+        }),\n     ]\n }\n \n@@ -354,15 +360,16 @@ pub fn main_args(args: &[String]) -> isize {\n     let playground_url = matches.opt_str(\"playground-url\");\n     let maybe_sysroot = matches.opt_str(\"sysroot\").map(PathBuf::from);\n     let display_warnings = matches.opt_present(\"display-warnings\");\n+    let linker = matches.opt_str(\"linker\");\n \n     match (should_test, markdown_input) {\n         (true, true) => {\n             return markdown::test(input, cfgs, libs, externs, test_args, maybe_sysroot, render_type,\n-                                  display_warnings)\n+                                  display_warnings, linker)\n         }\n         (true, false) => {\n             return test::run(input, cfgs, libs, externs, test_args, crate_name, maybe_sysroot,\n-                             render_type, display_warnings)\n+                             render_type, display_warnings, linker)\n         }\n         (false, true) => return markdown::render(input,\n                                                  output.unwrap_or(PathBuf::from(\"doc\")),\n@@ -460,6 +467,7 @@ where R: 'static + Send, F: 'static + Send + FnOnce(Output) -> R {\n     let triple = matches.opt_str(\"target\");\n     let maybe_sysroot = matches.opt_str(\"sysroot\").map(PathBuf::from);\n     let crate_name = matches.opt_str(\"crate-name\");\n+    let crate_version = matches.opt_str(\"crate-version\");\n     let plugin_path = matches.opt_str(\"plugin-path\");\n \n     let cr = PathBuf::from(cratefile);\n@@ -484,6 +492,8 @@ where R: 'static + Send, F: 'static + Send + FnOnce(Output) -> R {\n             krate.name = name\n         }\n \n+        krate.version = crate_version;\n+\n         // Process all of the crate attributes, extracting plugin metadata along\n         // with the passes which we are supposed to run.\n         for attr in krate.module.as_ref().unwrap().attrs.lists(\"doc\") {"}, {"sha": "fe6bd985bb6181fc5c65f8eaf22a2746d7458fbe", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -11,7 +11,6 @@\n use std::default::Default;\n use std::fs::File;\n use std::io::prelude::*;\n-use std::io;\n use std::path::{PathBuf, Path};\n \n use getopts;\n@@ -75,20 +74,15 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n \n     let mut out = match File::create(&output) {\n         Err(e) => {\n-            let _ = writeln!(&mut io::stderr(),\n-                             \"rustdoc: {}: {}\",\n-                             output.display(), e);\n+            eprintln!(\"rustdoc: {}: {}\", output.display(), e);\n             return 4;\n         }\n         Ok(f) => f\n     };\n \n     let (metadata, text) = extract_leading_metadata(&input_str);\n     if metadata.is_empty() {\n-        let _ = writeln!(\n-            &mut io::stderr(),\n-            \"rustdoc: invalid markdown file: no initial lines starting with `# ` or `%`\"\n-        );\n+        eprintln!(\"rustdoc: invalid markdown file: no initial lines starting with `# ` or `%`\");\n         return 5;\n     }\n     let title = metadata[0];\n@@ -138,9 +132,7 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n \n     match err {\n         Err(e) => {\n-            let _ = writeln!(&mut io::stderr(),\n-                             \"rustdoc: cannot write to `{}`: {}\",\n-                             output.display(), e);\n+            eprintln!(\"rustdoc: cannot write to `{}`: {}\", output.display(), e);\n             6\n         }\n         Ok(_) => 0\n@@ -150,7 +142,7 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n /// Run any tests/code examples in the markdown file `input`.\n pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n             mut test_args: Vec<String>, maybe_sysroot: Option<PathBuf>,\n-            render_type: RenderType, display_warnings: bool) -> isize {\n+            render_type: RenderType, display_warnings: bool, linker: Option<String>) -> isize {\n     let input_str = match load_string(input) {\n         Ok(s) => s,\n         Err(LoadStringError::ReadFail) => return 1,\n@@ -162,7 +154,7 @@ pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n     let mut collector = Collector::new(input.to_string(), cfgs, libs, externs,\n                                        true, opts, maybe_sysroot, None,\n                                        Some(input.to_owned()),\n-                                       render_type);\n+                                       render_type, linker);\n     if render_type == RenderType::Pulldown {\n         old_find_testable_code(&input_str, &mut collector, DUMMY_SP);\n         find_testable_code(&input_str, &mut collector, DUMMY_SP);"}, {"sha": "8b2c8d2da395a1f87074507b17e8cb2118d04e49", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 64, "deletions": 37, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -61,7 +61,8 @@ pub fn run(input: &str,\n            crate_name: Option<String>,\n            maybe_sysroot: Option<PathBuf>,\n            render_type: RenderType,\n-           display_warnings: bool)\n+           display_warnings: bool,\n+           linker: Option<String>)\n            -> isize {\n     let input_path = PathBuf::from(input);\n     let input = config::Input::File(input_path.clone());\n@@ -121,7 +122,8 @@ pub fn run(input: &str,\n                                        maybe_sysroot,\n                                        Some(codemap),\n                                        None,\n-                                       render_type);\n+                                       render_type,\n+                                       linker);\n \n     {\n         let map = hir::map::map_crate(&sess, &*cstore, &mut hir_forest, &defs);\n@@ -180,7 +182,8 @@ fn run_test(test: &str, cratename: &str, filename: &str, cfgs: Vec<String>, libs\n             externs: Externs,\n             should_panic: bool, no_run: bool, as_test_harness: bool,\n             compile_fail: bool, mut error_codes: Vec<String>, opts: &TestOptions,\n-            maybe_sysroot: Option<PathBuf>) {\n+            maybe_sysroot: Option<PathBuf>,\n+            linker: Option<String>) {\n     // the test harness wants its own `main` & top level functions, so\n     // never wrap the test in `fn main() { ... }`\n     let test = make_test(test, Some(cratename), as_test_harness, opts);\n@@ -201,6 +204,7 @@ fn run_test(test: &str, cratename: &str, filename: &str, cfgs: Vec<String>, libs\n         externs,\n         cg: config::CodegenOptions {\n             prefer_dynamic: true,\n+            linker,\n             .. config::basic_codegen_options()\n         },\n         test: as_test_harness,\n@@ -407,13 +411,33 @@ pub struct Collector {\n     pub tests: Vec<testing::TestDescAndFn>,\n     // to be removed when hoedown will be definitely gone\n     pub old_tests: HashMap<String, Vec<String>>,\n+\n+    // The name of the test displayed to the user, separated by `::`.\n+    //\n+    // In tests from Rust source, this is the path to the item\n+    // e.g. `[\"std\", \"vec\", \"Vec\", \"push\"]`.\n+    //\n+    // In tests from a markdown file, this is the titles of all headers (h1~h6)\n+    // of the sections that contain the code block, e.g. if the markdown file is\n+    // written as:\n+    //\n+    // ``````markdown\n+    // # Title\n+    //\n+    // ## Subtitle\n+    //\n+    // ```rust\n+    // assert!(true);\n+    // ```\n+    // ``````\n+    //\n+    // the `names` vector of that test will be `[\"Title\", \"Subtitle\"]`.\n     names: Vec<String>,\n+\n     cfgs: Vec<String>,\n     libs: SearchPaths,\n     externs: Externs,\n-    cnt: usize,\n     use_headers: bool,\n-    current_header: Option<String>,\n     cratename: String,\n     opts: TestOptions,\n     maybe_sysroot: Option<PathBuf>,\n@@ -422,56 +446,40 @@ pub struct Collector {\n     filename: Option<String>,\n     // to be removed when hoedown will be removed as well\n     pub render_type: RenderType,\n+    linker: Option<String>,\n }\n \n impl Collector {\n     pub fn new(cratename: String, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n                use_headers: bool, opts: TestOptions, maybe_sysroot: Option<PathBuf>,\n                codemap: Option<Rc<CodeMap>>, filename: Option<String>,\n-               render_type: RenderType) -> Collector {\n+               render_type: RenderType, linker: Option<String>) -> Collector {\n         Collector {\n             tests: Vec::new(),\n             old_tests: HashMap::new(),\n             names: Vec::new(),\n             cfgs,\n             libs,\n             externs,\n-            cnt: 0,\n             use_headers,\n-            current_header: None,\n             cratename,\n             opts,\n             maybe_sysroot,\n             position: DUMMY_SP,\n             codemap,\n             filename,\n             render_type,\n+            linker,\n         }\n     }\n \n     fn generate_name(&self, line: usize, filename: &str) -> String {\n-        if self.use_headers {\n-            if let Some(ref header) = self.current_header {\n-                format!(\"{} - {} (line {})\", filename, header, line)\n-            } else {\n-                format!(\"{} - (line {})\", filename, line)\n-            }\n-        } else {\n-            format!(\"{} - {} (line {})\", filename, self.names.join(\"::\"), line)\n-        }\n+        format!(\"{} - {} (line {})\", filename, self.names.join(\"::\"), line)\n     }\n \n     // to be removed once hoedown is gone\n     fn generate_name_beginning(&self, filename: &str) -> String {\n-        if self.use_headers {\n-            if let Some(ref header) = self.current_header {\n-                format!(\"{} - {} (line\", filename, header)\n-            } else {\n-                format!(\"{} - (line\", filename)\n-            }\n-        } else {\n-            format!(\"{} - {} (line\", filename, self.names.join(\"::\"))\n-        }\n+        format!(\"{} - {} (line\", filename, self.names.join(\"::\"))\n     }\n \n     pub fn add_old_test(&mut self, test: String, filename: String) {\n@@ -495,11 +503,10 @@ impl Collector {\n                 found = entry.remove_item(&test).is_some();\n             }\n             if !found {\n-                let _ = writeln!(&mut io::stderr(),\n-                                 \"WARNING: {} Code block is not currently run as a test, but will \\\n-                                  in future versions of rustdoc. Please ensure this code block is \\\n-                                  a runnable test, or use the `ignore` directive.\",\n-                                 name);\n+                eprintln!(\"WARNING: {} Code block is not currently run as a test, but will \\\n+                           in future versions of rustdoc. Please ensure this code block is \\\n+                           a runnable test, or use the `ignore` directive.\",\n+                          name);\n                 return\n             }\n         }\n@@ -509,6 +516,7 @@ impl Collector {\n         let cratename = self.cratename.to_string();\n         let opts = self.opts.clone();\n         let maybe_sysroot = self.maybe_sysroot.clone();\n+        let linker = self.linker.clone();\n         debug!(\"Creating test {}: {}\", name, test);\n         self.tests.push(testing::TestDescAndFn {\n             desc: testing::TestDesc {\n@@ -537,7 +545,8 @@ impl Collector {\n                                  compile_fail,\n                                  error_codes,\n                                  &opts,\n-                                 maybe_sysroot)\n+                                 maybe_sysroot,\n+                                 linker)\n                     })\n                 } {\n                     Ok(()) => (),\n@@ -580,7 +589,7 @@ impl Collector {\n     }\n \n     pub fn register_header(&mut self, name: &str, level: u32) {\n-        if self.use_headers && level == 1 {\n+        if self.use_headers {\n             // we use these headings as test names, so it's good if\n             // they're valid identifiers.\n             let name = name.chars().enumerate().map(|(i, c)| {\n@@ -592,9 +601,28 @@ impl Collector {\n                     }\n                 }).collect::<String>();\n \n-            // new header => reset count.\n-            self.cnt = 0;\n-            self.current_header = Some(name);\n+            // Here we try to efficiently assemble the header titles into the\n+            // test name in the form of `h1::h2::h3::h4::h5::h6`.\n+            //\n+            // Suppose originally `self.names` contains `[h1, h2, h3]`...\n+            let level = level as usize;\n+            if level <= self.names.len() {\n+                // ... Consider `level == 2`. All headers in the lower levels\n+                // are irrelevant in this new level. So we should reset\n+                // `self.names` to contain headers until <h2>, and replace that\n+                // slot with the new name: `[h1, name]`.\n+                self.names.truncate(level);\n+                self.names[level - 1] = name;\n+            } else {\n+                // ... On the other hand, consider `level == 5`. This means we\n+                // need to extend `self.names` to contain five headers. We fill\n+                // in the missing level (<h4>) with `_`. Thus `self.names` will\n+                // become `[h1, h2, h3, \"_\", name]`.\n+                if level - 1 > self.names.len() {\n+                    self.names.resize(level - 1, \"_\".to_owned());\n+                }\n+                self.names.push(name);\n+            }\n         }\n     }\n }\n@@ -625,7 +653,6 @@ impl<'a, 'hir> HirCollector<'a, 'hir> {\n         attrs.collapse_doc_comments();\n         attrs.unindent_doc_comments();\n         if let Some(doc) = attrs.doc_value() {\n-            self.collector.cnt = 0;\n             if self.collector.render_type == RenderType::Pulldown {\n                 markdown::old_find_testable_code(doc, self.collector,\n                                                  attrs.span.unwrap_or(DUMMY_SP));"}, {"sha": "866c0038a7fd9b5b501456c3987d2a216cfc5748", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -36,7 +36,6 @@ rustc_tsan = { path = \"../librustc_tsan\" }\n \n [build-dependencies]\n build_helper = { path = \"../build_helper\" }\n-cc = \"1.0\"\n \n [features]\n backtrace = []"}, {"sha": "0e6214ea04fc0a20a939fae3b739f44b2b6913a4", "filename": "src/libstd/build.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -11,7 +11,6 @@\n #![deny(warnings)]\n \n extern crate build_helper;\n-extern crate cc;\n \n use std::env;\n use std::process::Command;\n@@ -77,12 +76,6 @@ fn main() {\n fn build_libbacktrace(host: &str, target: &str) -> Result<(), ()> {\n     let native = native_lib_boilerplate(\"libbacktrace\", \"libbacktrace\", \"backtrace\", \".libs\")?;\n \n-    let compiler = cc::Build::new().get_compiler();\n-    // only msvc returns None for ar so unwrap is okay\n-    let ar = build_helper::cc2ar(compiler.path(), target).unwrap();\n-    let mut cflags = compiler.args().iter().map(|s| s.to_str().unwrap())\n-                             .collect::<Vec<_>>().join(\" \");\n-    cflags.push_str(\" -fvisibility=hidden\");\n     run(Command::new(\"sh\")\n                 .current_dir(&native.out_dir)\n                 .arg(native.src_dir.join(\"configure\").to_str().unwrap()\n@@ -94,10 +87,7 @@ fn build_libbacktrace(host: &str, target: &str) -> Result<(), ()> {\n                 .arg(\"--disable-host-shared\")\n                 .arg(format!(\"--host={}\", build_helper::gnu_target(target)))\n                 .arg(format!(\"--build={}\", build_helper::gnu_target(host)))\n-                .env(\"CC\", compiler.path())\n-                .env(\"AR\", &ar)\n-                .env(\"RANLIB\", format!(\"{} s\", ar.display()))\n-                .env(\"CFLAGS\", cflags),\n+                .env(\"CFLAGS\", env::var(\"CFLAGS\").unwrap_or_default() + \" -fvisibility=hidden\"),\n         BuildExpectation::None);\n \n     run(Command::new(build_helper::make(host))"}, {"sha": "7e623a0af17c3c1bab2db1c7948cb2b5f3974aad", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -717,26 +717,25 @@ fn calculate_offsets(hashes_size: usize,\n     (pairs_offset, end_of_pairs, oflo)\n }\n \n-// Returns a tuple of (minimum required malloc alignment, hash_offset,\n+// Returns a tuple of (minimum required malloc alignment,\n // array_size), from the start of a mallocated array.\n fn calculate_allocation(hash_size: usize,\n                         hash_align: usize,\n                         pairs_size: usize,\n                         pairs_align: usize)\n-                        -> (usize, usize, usize, bool) {\n-    let hash_offset = 0;\n+                        -> (usize, usize, bool) {\n     let (_, end_of_pairs, oflo) = calculate_offsets(hash_size, pairs_size, pairs_align);\n \n     let align = cmp::max(hash_align, pairs_align);\n \n-    (align, hash_offset, end_of_pairs, oflo)\n+    (align, end_of_pairs, oflo)\n }\n \n #[test]\n fn test_offset_calculation() {\n-    assert_eq!(calculate_allocation(128, 8, 16, 8), (8, 0, 144, false));\n-    assert_eq!(calculate_allocation(3, 1, 2, 1), (1, 0, 5, false));\n-    assert_eq!(calculate_allocation(6, 2, 12, 4), (4, 0, 20, false));\n+    assert_eq!(calculate_allocation(128, 8, 16, 8), (8, 144, false));\n+    assert_eq!(calculate_allocation(3, 1, 2, 1), (1, 5, false));\n+    assert_eq!(calculate_allocation(6, 2, 12, 4), (4, 20, false));\n     assert_eq!(calculate_offsets(128, 15, 4), (128, 143, false));\n     assert_eq!(calculate_offsets(3, 2, 4), (4, 6, false));\n     assert_eq!(calculate_offsets(6, 12, 4), (8, 20, false));\n@@ -768,10 +767,10 @@ impl<K, V> RawTable<K, V> {\n         // This is great in theory, but in practice getting the alignment\n         // right is a little subtle. Therefore, calculating offsets has been\n         // factored out into a different function.\n-        let (alignment, hash_offset, size, oflo) = calculate_allocation(hashes_size,\n-                                                                        align_of::<HashUint>(),\n-                                                                        pairs_size,\n-                                                                        align_of::<(K, V)>());\n+        let (alignment, size, oflo) = calculate_allocation(hashes_size,\n+                                                           align_of::<HashUint>(),\n+                                                           pairs_size,\n+                                                           align_of::<(K, V)>());\n         assert!(!oflo, \"capacity overflow\");\n \n         // One check for overflow that covers calculation and rounding of size.\n@@ -784,7 +783,7 @@ impl<K, V> RawTable<K, V> {\n         let buffer = Heap.alloc(Layout::from_size_align(size, alignment).unwrap())\n             .unwrap_or_else(|e| Heap.oom(e));\n \n-        let hashes = buffer.offset(hash_offset as isize) as *mut HashUint;\n+        let hashes = buffer as *mut HashUint;\n \n         RawTable {\n             capacity_mask: capacity.wrapping_sub(1),\n@@ -1157,6 +1156,7 @@ impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n             }\n \n             new_ht.size = self.size();\n+            new_ht.set_tag(self.tag());\n \n             new_ht\n         }\n@@ -1183,10 +1183,10 @@ unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for RawTable<K, V> {\n \n         let hashes_size = self.capacity() * size_of::<HashUint>();\n         let pairs_size = self.capacity() * size_of::<(K, V)>();\n-        let (align, _, size, oflo) = calculate_allocation(hashes_size,\n-                                                          align_of::<HashUint>(),\n-                                                          pairs_size,\n-                                                          align_of::<(K, V)>());\n+        let (align, size, oflo) = calculate_allocation(hashes_size,\n+                                                       align_of::<HashUint>(),\n+                                                       pairs_size,\n+                                                       align_of::<(K, V)>());\n \n         debug_assert!(!oflo, \"should be impossible\");\n "}, {"sha": "b54603919427c33bb812fa4f56e55061cf05a001", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 186, "deletions": 65, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -23,19 +23,69 @@ use ptr;\n use slice;\n use str::{self, Utf8Error};\n \n-/// A type representing an owned C-compatible string.\n+/// A type representing an owned, C-compatible, nul-terminated string with no nul bytes in the\n+/// middle.\n ///\n-/// This type serves the primary purpose of being able to safely generate a\n+/// This type serves the purpose of being able to safely generate a\n /// C-compatible string from a Rust byte slice or vector. An instance of this\n /// type is a static guarantee that the underlying bytes contain no interior 0\n-/// bytes and the final byte is 0.\n+/// bytes (\"nul characters\") and that the final byte is 0 (\"nul terminator\").\n ///\n-/// A `CString` is created from either a byte slice or a byte vector. A [`u8`]\n-/// slice can be obtained with the `as_bytes` method. Slices produced from a\n-/// `CString` do *not* contain the trailing nul terminator unless otherwise\n-/// specified.\n+/// `CString` is to [`CStr`] as [`String`] is to [`&str`]: the former\n+/// in each pair are owned strings; the latter are borrowed\n+/// references.\n ///\n+/// # Creating a `CString`\n+///\n+/// A `CString` is created from either a byte slice or a byte vector,\n+/// or anything that implements [`Into`]`<`[`Vec`]`<`[`u8`]`>>` (for\n+/// example, you can build a `CString` straight out of a [`String`] or\n+/// a [`&str`], since both implement that trait).\n+///\n+/// The [`new`] method will actually check that the provided `&[u8]`\n+/// does not have 0 bytes in the middle, and return an error if it\n+/// finds one.\n+///\n+/// # Extracting a raw pointer to the whole C string\n+///\n+/// `CString` implements a [`as_ptr`] method through the [`Deref`]\n+/// trait. This method will give you a `*const c_char` which you can\n+/// feed directly to extern functions that expect a nul-terminated\n+/// string, like C's `strdup()`.\n+///\n+/// # Extracting a slice of the whole C string\n+///\n+/// Alternatively, you can obtain a `&[`[`u8`]`]` slice from a\n+/// `CString` with the [`as_bytes`] method. Slices produced in this\n+/// way do *not* contain the trailing nul terminator. This is useful\n+/// when you will be calling an extern function that takes a `*const\n+/// u8` argument which is not necessarily nul-terminated, plus another\n+/// argument with the length of the string \u2014 like C's `strndup()`.\n+/// You can of course get the slice's length with its\n+/// [`len`][slice.len] method.\n+///\n+/// If you need a `&[`[`u8`]`]` slice *with* the nul terminator, you\n+/// can use [`as_bytes_with_nul`] instead.\n+///\n+/// Once you have the kind of slice you need (with or without a nul\n+/// terminator), you can call the slice's own\n+/// [`as_ptr`][slice.as_ptr] method to get a raw pointer to pass to\n+/// extern functions. See the documentation for that function for a\n+/// discussion on ensuring the lifetime of the raw pointer.\n+///\n+/// [`Into`]: ../convert/trait.Into.html\n+/// [`Vec`]: ../vec/struct.Vec.html\n+/// [`String`]: ../string/struct.String.html\n+/// [`&str`]: ../primitive.str.html\n /// [`u8`]: ../primitive.u8.html\n+/// [`new`]: #method.new\n+/// [`as_bytes`]: #method.as_bytes\n+/// [`as_bytes_with_nul`]: #method.as_bytes_with_nul\n+/// [`as_ptr`]: #method.as_ptr\n+/// [slice.as_ptr]: ../primitive.slice.html#method.as_ptr\n+/// [slice.len]: ../primitive.slice.html#method.len\n+/// [`Deref`]: ../ops/trait.Deref.html\n+/// [`CStr`]: struct.CStr.html\n ///\n /// # Examples\n ///\n@@ -48,6 +98,8 @@ use str::{self, Utf8Error};\n ///     fn my_printer(s: *const c_char);\n /// }\n ///\n+/// // We are certain that our string doesn't have 0 bytes in the middle,\n+/// // so we can .unwrap()\n /// let c_to_print = CString::new(\"Hello, world!\").unwrap();\n /// unsafe {\n ///     my_printer(c_to_print.as_ptr());\n@@ -58,7 +110,7 @@ use str::{self, Utf8Error};\n /// # Safety\n ///\n /// `CString` is intended for working with traditional C-style strings\n-/// (a sequence of non-null bytes terminated by a single null byte); the\n+/// (a sequence of non-nul bytes terminated by a single nul byte); the\n /// primary use case for these kinds of strings is interoperating with C-like\n /// code. Often you will need to transfer ownership to/from that external\n /// code. It is strongly recommended that you thoroughly read through the\n@@ -77,17 +129,21 @@ pub struct CString {\n \n /// Representation of a borrowed C string.\n ///\n-/// This dynamically sized type is only safely constructed via a borrowed\n-/// version of an instance of `CString`. This type can be constructed from a raw\n-/// C string as well and represents a C string borrowed from another location.\n+/// This type represents a borrowed reference to a nul-terminated\n+/// array of bytes. It can be constructed safely from a `&[`[`u8`]`]`\n+/// slice, or unsafely from a raw `*const c_char`. It can then be\n+/// converted to a Rust [`&str`] by performing UTF-8 validation, or\n+/// into an owned [`CString`].\n+///\n+/// `CStr` is to [`CString`] as [`&str`] is to [`String`]: the former\n+/// in each pair are borrowed references; the latter are owned\n+/// strings.\n ///\n /// Note that this structure is **not** `repr(C)` and is not recommended to be\n-/// placed in the signatures of FFI functions. Instead safe wrappers of FFI\n+/// placed in the signatures of FFI functions. Instead, safe wrappers of FFI\n /// functions may leverage the unsafe [`from_ptr`] constructor to provide a safe\n /// interface to other consumers.\n ///\n-/// [`from_ptr`]: #method.from_ptr\n-///\n /// # Examples\n ///\n /// Inspecting a foreign C string:\n@@ -100,7 +156,7 @@ pub struct CString {\n ///\n /// unsafe {\n ///     let slice = CStr::from_ptr(my_string());\n-///     println!(\"string length: {}\", slice.to_bytes().len());\n+///     println!(\"string buffer size without nul terminator: {}\", slice.to_bytes().len());\n /// }\n /// ```\n ///\n@@ -122,8 +178,6 @@ pub struct CString {\n ///\n /// Converting a foreign C string into a Rust [`String`]:\n ///\n-/// [`String`]: ../string/struct.String.html\n-///\n /// ```no_run\n /// use std::ffi::CStr;\n /// use std::os::raw::c_char;\n@@ -138,6 +192,12 @@ pub struct CString {\n ///\n /// println!(\"string: {}\", my_string_safe());\n /// ```\n+///\n+/// [`u8`]: ../primitive.u8.html\n+/// [`&str`]: ../primitive.str.html\n+/// [`String`]: ../string/struct.String.html\n+/// [`CString`]: struct.CString.html\n+/// [`from_ptr`]: #method.from_ptr\n #[derive(Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct CStr {\n@@ -148,9 +208,15 @@ pub struct CStr {\n     inner: [c_char]\n }\n \n-/// An error returned from [`CString::new`] to indicate that a nul byte was found\n-/// in the vector provided.\n+/// An error indicating that an interior nul byte was found.\n+///\n+/// While Rust strings may contain nul bytes in the middle, C strings\n+/// can't, as that byte would effectively truncate the string.\n ///\n+/// This error is created by the [`new`][`CString::new`] method on\n+/// [`CString`]. See its documentation for more.\n+///\n+/// [`CString`]: struct.CString.html\n /// [`CString::new`]: struct.CString.html#method.new\n ///\n /// # Examples\n@@ -164,9 +230,16 @@ pub struct CStr {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct NulError(usize, Vec<u8>);\n \n-/// An error returned from [`CStr::from_bytes_with_nul`] to indicate that a nul\n-/// byte was found too early in the slice provided or one wasn't found at all.\n+/// An error indicating that a nul byte was not in the expected position.\n+///\n+/// The slice used to create a [`CStr`] must have one and only one nul\n+/// byte at the end of the slice.\n ///\n+/// This error is created by the\n+/// [`from_bytes_with_nul`][`CStr::from_bytes_with_nul`] method on\n+/// [`CStr`]. See its documentation for more.\n+///\n+/// [`CStr`]: struct.CStr.html\n /// [`CStr::from_bytes_with_nul`]: struct.CStr.html#method.from_bytes_with_nul\n ///\n /// # Examples\n@@ -201,9 +274,18 @@ impl FromBytesWithNulError {\n     }\n }\n \n-/// An error returned from [`CString::into_string`] to indicate that a UTF-8 error\n-/// was encountered during the conversion.\n+/// An error indicating invalid UTF-8 when converting a [`CString`] into a [`String`].\n+///\n+/// `CString` is just a wrapper over a buffer of bytes with a nul\n+/// terminator; [`into_string`][`CString::into_string`] performs UTF-8\n+/// validation on those bytes and may return this error.\n+///\n+/// This `struct` is created by the\n+/// [`into_string`][`CString::into_string`] method on [`CString`]. See\n+/// its documentation for more.\n ///\n+/// [`String`]: ../string/struct.String.html\n+/// [`CString`]: struct.CString.html\n /// [`CString::into_string`]: struct.CString.html#method.into_string\n #[derive(Clone, PartialEq, Eq, Debug)]\n #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n@@ -215,8 +297,11 @@ pub struct IntoStringError {\n impl CString {\n     /// Creates a new C-compatible string from a container of bytes.\n     ///\n-    /// This method will consume the provided data and use the underlying bytes\n-    /// to construct a new string, ensuring that there is a trailing 0 byte.\n+    /// This function will consume the provided data and use the\n+    /// underlying bytes to construct a new string, ensuring that\n+    /// there is a trailing 0 byte. This trailing 0 byte will be\n+    /// appended by this function; the provided data should *not*\n+    /// contain any 0 bytes in it.\n     ///\n     /// # Examples\n     ///\n@@ -234,9 +319,11 @@ impl CString {\n     ///\n     /// # Errors\n     ///\n-    /// This function will return an error if the bytes yielded contain an\n-    /// internal 0 byte. The error returned will contain the bytes as well as\n+    /// This function will return an error if the supplied bytes contain an\n+    /// internal 0 byte. The [`NulError`] returned will contain the bytes as well as\n     /// the position of the nul byte.\n+    ///\n+    /// [`NulError`]: struct.NulError.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new<T: Into<Vec<u8>>>(t: T) -> Result<CString, NulError> {\n         Self::_new(t.into())\n@@ -249,8 +336,8 @@ impl CString {\n         }\n     }\n \n-    /// Creates a C-compatible string from a byte vector without checking for\n-    /// interior 0 bytes.\n+    /// Creates a C-compatible string by consuming a byte vector,\n+    /// without checking for interior 0 bytes.\n     ///\n     /// This method is equivalent to [`new`] except that no runtime assertion\n     /// is made that `v` contains no 0 bytes, and it requires an actual\n@@ -275,7 +362,7 @@ impl CString {\n         CString { inner: v.into_boxed_slice() }\n     }\n \n-    /// Retakes ownership of a `CString` that was transferred to C.\n+    /// Retakes ownership of a `CString` that was transferred to C via [`into_raw`].\n     ///\n     /// Additionally, the length of the string will be recalculated from the pointer.\n     ///\n@@ -286,7 +373,14 @@ impl CString {\n     /// ownership of a string that was allocated by foreign code) is likely to lead\n     /// to undefined behavior or allocator corruption.\n     ///\n+    /// > **Note:** If you need to borrow a string that was allocated by\n+    /// > foreign code, use [`CStr`]. If you need to take ownership of\n+    /// > a string that was allocated by foreign code, you will need to\n+    /// > make your own provisions for freeing it appropriately, likely\n+    /// > with the foreign code's API to do that.\n+    ///\n     /// [`into_raw`]: #method.into_raw\n+    /// [`CStr`]: struct.CStr.html\n     ///\n     /// # Examples\n     ///\n@@ -315,11 +409,11 @@ impl CString {\n         CString { inner: Box::from_raw(slice as *mut [c_char] as *mut [u8]) }\n     }\n \n-    /// Transfers ownership of the string to a C caller.\n+    /// Consumes the `CString` and transfers ownership of the string to a C caller.\n     ///\n-    /// The pointer must be returned to Rust and reconstituted using\n+    /// The pointer which this function returns must be returned to Rust and reconstituted using\n     /// [`from_raw`] to be properly deallocated. Specifically, one\n-    /// should *not* use the standard C `free` function to deallocate\n+    /// should *not* use the standard C `free()` function to deallocate\n     /// this string.\n     ///\n     /// Failure to call [`from_raw`] will lead to a memory leak.\n@@ -351,11 +445,27 @@ impl CString {\n         Box::into_raw(self.into_inner()) as *mut c_char\n     }\n \n-    /// Converts the `CString` into a [`String`] if it contains valid Unicode data.\n+    /// Converts the `CString` into a [`String`] if it contains valid UTF-8 data.\n     ///\n     /// On failure, ownership of the original `CString` is returned.\n     ///\n     /// [`String`]: ../string/struct.String.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ffi::CString;\n+    ///\n+    /// let valid_utf8 = vec![b'f', b'o', b'o'];\n+    /// let cstring = CString::new(valid_utf8).unwrap();\n+    /// assert_eq!(cstring.into_string().unwrap(), \"foo\");\n+    ///\n+    /// let invalid_utf8 = vec![b'f', 0xff, b'o', b'o'];\n+    /// let cstring = CString::new(invalid_utf8).unwrap();\n+    /// let err = cstring.into_string().err().unwrap();\n+    /// assert_eq!(err.utf8_error().valid_up_to(), 1);\n+    /// ```\n+\n     #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n     pub fn into_string(self) -> Result<String, IntoStringError> {\n         String::from_utf8(self.into_bytes())\n@@ -365,10 +475,11 @@ impl CString {\n             })\n     }\n \n-    /// Returns the underlying byte buffer.\n+    /// Consumes the `CString` and returns the underlying byte buffer.\n     ///\n-    /// The returned buffer does **not** contain the trailing nul separator and\n-    /// it is guaranteed to not have any interior nul bytes.\n+    /// The returned buffer does **not** contain the trailing nul\n+    /// terminator, and it is guaranteed to not have any interior nul\n+    /// bytes.\n     ///\n     /// # Examples\n     ///\n@@ -388,7 +499,7 @@ impl CString {\n     }\n \n     /// Equivalent to the [`into_bytes`] function except that the returned vector\n-    /// includes the trailing nul byte.\n+    /// includes the trailing nul terminator.\n     ///\n     /// [`into_bytes`]: #method.into_bytes\n     ///\n@@ -408,8 +519,12 @@ impl CString {\n \n     /// Returns the contents of this `CString` as a slice of bytes.\n     ///\n-    /// The returned slice does **not** contain the trailing nul separator and\n-    /// it is guaranteed to not have any interior nul bytes.\n+    /// The returned slice does **not** contain the trailing nul\n+    /// terminator, and it is guaranteed to not have any interior nul\n+    /// bytes. If you need the nul terminator, use\n+    /// [`as_bytes_with_nul`] instead.\n+    ///\n+    /// [`as_bytes_with_nul`]: #method.as_bytes_with_nul\n     ///\n     /// # Examples\n     ///\n@@ -427,7 +542,7 @@ impl CString {\n     }\n \n     /// Equivalent to the [`as_bytes`] function except that the returned slice\n-    /// includes the trailing nul byte.\n+    /// includes the trailing nul terminator.\n     ///\n     /// [`as_bytes`]: #method.as_bytes\n     ///\n@@ -598,8 +713,8 @@ impl Default for Box<CStr> {\n }\n \n impl NulError {\n-    /// Returns the position of the nul byte in the slice that was provided to\n-    /// [`CString::new`].\n+    /// Returns the position of the nul byte in the slice that caused\n+    /// [`CString::new`] to fail.\n     ///\n     /// [`CString::new`]: struct.CString.html#method.new\n     ///\n@@ -711,9 +826,9 @@ impl fmt::Display for IntoStringError {\n }\n \n impl CStr {\n-    /// Casts a raw C string to a safe C string wrapper.\n+    /// Wraps a raw C string with a safe C string wrapper.\n     ///\n-    /// This function will cast the provided `ptr` to the `CStr` wrapper which\n+    /// This function will wrap the provided `ptr` with a `CStr` wrapper, which\n     /// allows inspection and interoperation of non-owned C strings. This method\n     /// is unsafe for a number of reasons:\n     ///\n@@ -753,9 +868,9 @@ impl CStr {\n \n     /// Creates a C string wrapper from a byte slice.\n     ///\n-    /// This function will cast the provided `bytes` to a `CStr` wrapper after\n-    /// ensuring that it is null terminated and does not contain any interior\n-    /// nul bytes.\n+    /// This function will cast the provided `bytes` to a `CStr`\n+    /// wrapper after ensuring that the byte slice is nul-terminated\n+    /// and does not contain any interior nul bytes.\n     ///\n     /// # Examples\n     ///\n@@ -766,7 +881,7 @@ impl CStr {\n     /// assert!(cstr.is_ok());\n     /// ```\n     ///\n-    /// Creating a `CStr` without a trailing nul byte is an error:\n+    /// Creating a `CStr` without a trailing nul terminator is an error:\n     ///\n     /// ```\n     /// use std::ffi::CStr;\n@@ -800,7 +915,7 @@ impl CStr {\n     /// Unsafely creates a C string wrapper from a byte slice.\n     ///\n     /// This function will cast the provided `bytes` to a `CStr` wrapper without\n-    /// performing any sanity checks. The provided slice must be null terminated\n+    /// performing any sanity checks. The provided slice **must** be nul-terminated\n     /// and not contain any interior nul bytes.\n     ///\n     /// # Examples\n@@ -822,7 +937,7 @@ impl CStr {\n \n     /// Returns the inner pointer to this C string.\n     ///\n-    /// The returned pointer will be valid for as long as `self` is and points\n+    /// The returned pointer will be valid for as long as `self` is, and points\n     /// to a contiguous region of memory terminated with a 0 byte to represent\n     /// the end of the string.\n     ///\n@@ -843,9 +958,9 @@ impl CStr {\n     /// ```\n     ///\n     /// This happens because the pointer returned by `as_ptr` does not carry any\n-    /// lifetime information and the string is deallocated immediately after\n+    /// lifetime information and the [`CString`] is deallocated immediately after\n     /// the `CString::new(\"Hello\").unwrap().as_ptr()` expression is evaluated.\n-    /// To fix the problem, bind the string to a local variable:\n+    /// To fix the problem, bind the `CString` to a local variable:\n     ///\n     /// ```no_run\n     /// use std::ffi::{CString};\n@@ -857,6 +972,11 @@ impl CStr {\n     ///     *ptr;\n     /// }\n     /// ```\n+    ///\n+    /// This way, the lifetime of the `CString` in `hello` encompasses\n+    /// the lifetime of `ptr` and the `unsafe` block.\n+    ///\n+    /// [`CString`]: struct.CString.html\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_ptr(&self) -> *const c_char {\n@@ -865,11 +985,7 @@ impl CStr {\n \n     /// Converts this C string to a byte slice.\n     ///\n-    /// This function will calculate the length of this string (which normally\n-    /// requires a linear amount of work to be done) and then return the\n-    /// resulting slice of `u8` elements.\n-    ///\n-    /// The returned slice will **not** contain the trailing nul that this C\n+    /// The returned slice will **not** contain the trailing nul terminator that this C\n     /// string has.\n     ///\n     /// > **Note**: This method is currently implemented as a 0-cost cast, but\n@@ -894,7 +1010,7 @@ impl CStr {\n     /// Converts this C string to a byte slice containing the trailing 0 byte.\n     ///\n     /// This function is the equivalent of [`to_bytes`] except that it will retain\n-    /// the trailing nul instead of chopping it off.\n+    /// the trailing nul terminator instead of chopping it off.\n     ///\n     /// > **Note**: This method is currently implemented as a 0-cost cast, but\n     /// > it is planned to alter its definition in the future to perform the\n@@ -918,8 +1034,9 @@ impl CStr {\n \n     /// Yields a [`&str`] slice if the `CStr` contains valid UTF-8.\n     ///\n-    /// This function will calculate the length of this string and check for\n-    /// UTF-8 validity, and then return the [`&str`] if it's valid.\n+    /// If the contents of the `CStr` are valid UTF-8 data, this\n+    /// function will return the corresponding [`&str`] slice. Otherwise,\n+    /// it will return an error with details of where UTF-8 validation failed.\n     ///\n     /// > **Note**: This method is currently implemented to check for validity\n     /// > after a 0-cost cast, but it is planned to alter its definition in the\n@@ -947,18 +1064,22 @@ impl CStr {\n \n     /// Converts a `CStr` into a [`Cow`]`<`[`str`]`>`.\n     ///\n-    /// This function will calculate the length of this string (which normally\n-    /// requires a linear amount of work to be done) and then return the\n-    /// resulting slice as a [`Cow`]`<`[`str`]`>`, replacing any invalid UTF-8 sequences\n-    /// with `U+FFFD REPLACEMENT CHARACTER`.\n+    /// If the contents of the `CStr` are valid UTF-8 data, this\n+    /// function will return a [`Cow`]`::`[`Borrowed`]`(`[`&str`]`)`\n+    /// with the the corresponding [`&str`] slice. Otherwise, it will\n+    /// replace any invalid UTF-8 sequences with `U+FFFD REPLACEMENT\n+    /// CHARACTER` and return a [`Cow`]`::`[`Owned`]`(`[`String`]`)`\n+    /// with the result.\n     ///\n     /// > **Note**: This method is currently implemented to check for validity\n     /// > after a 0-cost cast, but it is planned to alter its definition in the\n     /// > future to perform the length calculation in addition to the UTF-8\n     /// > check whenever this method is called.\n     ///\n     /// [`Cow`]: ../borrow/enum.Cow.html\n+    /// [`Borrowed`]: ../borrow/enum.Cow.html#variant.Borrowed\n     /// [`str`]: ../primitive.str.html\n+    /// [`String`]: ../string/struct.String.html\n     ///\n     /// # Examples\n     ///"}, {"sha": "a75596351e4cf3ec073fa809c29847b2e179969e", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -9,6 +9,157 @@\n // except according to those terms.\n \n //! Utilities related to FFI bindings.\n+//!\n+//! This module provides utilities to handle data across non-Rust\n+//! interfaces, like other programming languages and the underlying\n+//! operating system. It is mainly of use for FFI (Foreign Function\n+//! Interface) bindings and code that needs to exchange C-like strings\n+//! with other languages.\n+//!\n+//! # Overview\n+//!\n+//! Rust represents owned strings with the [`String`] type, and\n+//! borrowed slices of strings with the [`str`] primitive. Both are\n+//! always in UTF-8 encoding, and may contain nul bytes in the middle,\n+//! i.e. if you look at the bytes that make up the string, there may\n+//! be a `\\0` among them. Both `String` and `str` store their length\n+//! explicitly; there are no nul terminators at the end of strings\n+//! like in C.\n+//!\n+//! C strings are different from Rust strings:\n+//!\n+//! * **Encodings** - Rust strings are UTF-8, but C strings may use\n+//! other encodings. If you are using a string from C, you should\n+//! check its encoding explicitly, rather than just assuming that it\n+//! is UTF-8 like you can do in Rust.\n+//!\n+//! * **Character size** - C strings may use `char` or `wchar_t`-sized\n+//! characters; please **note** that C's `char` is different from Rust's.\n+//! The C standard leaves the actual sizes of those types open to\n+//! interpretation, but defines different APIs for strings made up of\n+//! each character type. Rust strings are always UTF-8, so different\n+//! Unicode characters will be encoded in a variable number of bytes\n+//! each. The Rust type [`char`] represents a '[Unicode scalar\n+//! value]', which is similar to, but not the same as, a '[Unicode\n+//! code point]'.\n+//!\n+//! * **Nul terminators and implicit string lengths** - Often, C\n+//! strings are nul-terminated, i.e. they have a `\\0` character at the\n+//! end. The length of a string buffer is not stored, but has to be\n+//! calculated; to compute the length of a string, C code must\n+//! manually call a function like `strlen()` for `char`-based strings,\n+//! or `wcslen()` for `wchar_t`-based ones. Those functions return\n+//! the number of characters in the string excluding the nul\n+//! terminator, so the buffer length is really `len+1` characters.\n+//! Rust strings don't have a nul terminator; their length is always\n+//! stored and does not need to be calculated. While in Rust\n+//! accessing a string's length is a O(1) operation (becasue the\n+//! length is stored); in C it is an O(length) operation because the\n+//! length needs to be computed by scanning the string for the nul\n+//! terminator.\n+//!\n+//! * **Internal nul characters** - When C strings have a nul\n+//! terminator character, this usually means that they cannot have nul\n+//! characters in the middle \u2014 a nul character would essentially\n+//! truncate the string. Rust strings *can* have nul characters in\n+//! the middle, because nul does not have to mark the end of the\n+//! string in Rust.\n+//!\n+//! # Representations of non-Rust strings\n+//!\n+//! [`CString`] and [`CStr`] are useful when you need to transfer\n+//! UTF-8 strings to and from languages with a C ABI, like Python.\n+//!\n+//! * **From Rust to C:** [`CString`] represents an owned, C-friendly\n+//! string: it is nul-terminated, and has no internal nul characters.\n+//! Rust code can create a `CString` out of a normal string (provided\n+//! that the string doesn't have nul characters in the middle), and\n+//! then use a variety of methods to obtain a raw `*mut u8` that can\n+//! then be passed as an argument to functions which use the C\n+//! conventions for strings.\n+//!\n+//! * **From C to Rust:** [`CStr`] represents a borrowed C string; it\n+//! is what you would use to wrap a raw `*const u8` that you got from\n+//! a C function. A `CStr` is guaranteed to be a nul-terminated array\n+//! of bytes. Once you have a `CStr`, you can convert it to a Rust\n+//! `&str` if it's valid UTF-8, or lossily convert it by adding\n+//! replacement characters.\n+//!\n+//! [`OsString`] and [`OsStr`] are useful when you need to transfer\n+//! strings to and from the operating system itself, or when capturing\n+//! the output of external commands. Conversions between `OsString`,\n+//! `OsStr` and Rust strings work similarly to those for [`CString`]\n+//! and [`CStr`].\n+//!\n+//! * [`OsString`] represents an owned string in whatever\n+//! representation the operating system prefers. In the Rust standard\n+//! library, various APIs that transfer strings to/from the operating\n+//! system use `OsString` instead of plain strings. For example,\n+//! [`env::var_os()`] is used to query environment variables; it\n+//! returns an `Option<OsString>`. If the environment variable exists\n+//! you will get a `Some(os_string)`, which you can *then* try to\n+//! convert to a Rust string. This yields a [`Result<>`], so that\n+//! your code can detect errors in case the environment variable did\n+//! not in fact contain valid Unicode data.\n+//!\n+//! * [`OsStr`] represents a borrowed reference to a string in a\n+//! format that can be passed to the operating system. It can be\n+//! converted into an UTF-8 Rust string slice in a similar way to\n+//! `OsString`.\n+//!\n+//! # Conversions\n+//!\n+//! ## On Unix\n+//!\n+//! On Unix, [`OsStr`] implements the\n+//! `std::os::unix:ffi::`[`OsStrExt`][unix.OsStrExt] trait, which\n+//! augments it with two methods, [`from_bytes`] and [`as_bytes`].\n+//! These do inexpensive conversions from and to UTF-8 byte slices.\n+//!\n+//! Additionally, on Unix [`OsString`] implements the\n+//! `std::os::unix:ffi::`[`OsStringExt`][unix.OsStringExt] trait,\n+//! which provides [`from_vec`] and [`into_vec`] methods that consume\n+//! their arguments, and take or produce vectors of [`u8`].\n+//!\n+//! ## On Windows\n+//!\n+//! On Windows, [`OsStr`] implements the\n+//! `std::os::windows::ffi::`[`OsStrExt`][windows.OsStrExt] trait,\n+//! which provides an [`encode_wide`] method. This provides an\n+//! iterator that can be [`collect`]ed into a vector of [`u16`].\n+//!\n+//! Additionally, on Windows [`OsString`] implements the\n+//! `std::os::windows:ffi::`[`OsStringExt`][windows.OsStringExt]\n+//! trait, which provides a [`from_wide`] method. The result of this\n+//! method is an `OsString` which can be round-tripped to a Windows\n+//! string losslessly.\n+//!\n+//! [`String`]: ../string/struct.String.html\n+//! [`str`]: ../primitive.str.html\n+//! [`char`]: ../primitive.char.html\n+//! [`u8`]: ../primitive.u8.html\n+//! [`u16`]: ../primitive.u16.html\n+//! [Unicode scalar value]: http://www.unicode.org/glossary/#unicode_scalar_value\n+//! [Unicode code point]: http://www.unicode.org/glossary/#code_point\n+//! [`CString`]: struct.CString.html\n+//! [`CStr`]: struct.CStr.html\n+//! [`OsString`]: struct.OsString.html\n+//! [`OsStr`]: struct.OsStr.html\n+//! [`env::set_var()`]: ../env/fn.set_var.html\n+//! [`env::var_os()`]: ../env/fn.var_os.html\n+//! [`Result<>`]: ../result/enum.Result.html\n+//! [unix.OsStringExt]: ../os/unix/ffi/trait.OsStringExt.html\n+//! [`from_vec`]: ../os/unix/ffi/trait.OsStringExt.html#tymethod.from_vec\n+//! [`into_vec`]: ../os/unix/ffi/trait.OsStringExt.html#tymethod.into_vec\n+//! [unix.OsStrExt]: ../os/unix/ffi/trait.OsStrExt.html\n+//! [`from_bytes`]: ../os/unix/ffi/trait.OsStrExt.html#tymethod.from_bytes\n+//! [`as_bytes`]: ../os/unix/ffi/trait.OsStrExt.html#tymethod.as_bytes\n+//! [`OsStrExt`]: ../os/unix/ffi/trait.OsStrExt.html\n+//! [windows.OsStrExt]: ../os/windows/ffi/trait.OsStrExt.html\n+//! [`encode_wide`]: ../os/windows/ffi/trait.OsStrExt.html#tymethod.encode_wide\n+//! [`collect`]: ../iter/trait.Iterator.html#method.collect\n+//! [windows.OsStringExt]: ../os/windows/ffi/trait.OsStringExt.html\n+//! [`from_wide`]: ../os/windows/ffi/trait.OsStringExt.html#tymethod.from_wide\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "a97075ff8d8cd7f966dbd9298202e8f79a8a7661", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 49, "deletions": 2, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -32,18 +32,65 @@ use sys_common::{AsInner, IntoInner, FromInner};\n ///\n /// `OsString` and [`OsStr`] bridge this gap by simultaneously representing Rust\n /// and platform-native string values, and in particular allowing a Rust string\n-/// to be converted into an \"OS\" string with no cost.\n+/// to be converted into an \"OS\" string with no cost if possible.\n+///\n+/// `OsString` is to [`OsStr`] as [`String`] is to [`&str`]: the former\n+/// in each pair are owned strings; the latter are borrowed\n+/// references.\n+///\n+/// # Creating an `OsString`\n+///\n+/// **From a Rust string**: `OsString` implements\n+/// [`From`]`<`[`String`]`>`, so you can use `my_string.`[`from`] to\n+/// create an `OsString` from a normal Rust string.\n+///\n+/// **From slices:** Just like you can start with an empty Rust\n+/// [`String`] and then [`push_str`][String.push_str] `&str`\n+/// sub-string slices into it, you can create an empty `OsString` with\n+/// the [`new`] method and then push string slices into it with the\n+/// [`push`] method.\n+///\n+/// # Extracting a borrowed reference to the whole OS string\n+///\n+/// You can use the [`as_os_str`] method to get an `&`[`OsStr`] from\n+/// an `OsString`; this is effectively a borrowed reference to the\n+/// whole string.\n+///\n+/// # Conversions\n+///\n+/// See the [module's toplevel documentation about conversions][conversions] for a discussion on\n+/// the traits which `OsString` implements for conversions from/to native representations.\n ///\n /// [`OsStr`]: struct.OsStr.html\n+/// [`From`]: ../convert/trait.From.html\n+/// [`from`]: ../convert/trait.From.html#tymethod.from\n+/// [`String`]: ../string/struct.String.html\n+/// [`&str`]: ../primitive.str.html\n+/// [`u8`]: ../primitive.u8.html\n+/// [`u16`]: ../primitive.u16.html\n+/// [String.push_str]: ../string/struct.String.html#method.push_str\n+/// [`new`]: #method.new\n+/// [`push`]: #method.push\n+/// [`as_os_str`]: #method.as_os_str\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OsString {\n     inner: Buf\n }\n \n-/// Slices into OS strings (see [`OsString`]).\n+/// Borrowed reference to an OS string (see [`OsString`]).\n+///\n+/// This type represents a borrowed reference to a string in the operating system's preferred\n+/// representation.\n+///\n+/// `OsStr` is to [`OsString`] as [`String`] is to [`&str`]: the former in each pair are borrowed\n+/// references; the latter are owned strings.\n+///\n+/// See the [module's toplevel documentation about conversions][conversions] for a discussion on\n+/// the traits which `OsStr` implements for conversions from/to native representations.\n ///\n /// [`OsString`]: struct.OsString.html\n+/// [conversions]: index.html#conversions\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OsStr {\n     inner: Slice"}, {"sha": "83cc9ce582e34b15d3377518b153d6ae343f904d", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -244,6 +244,7 @@\n #![feature(allow_internal_unstable)]\n #![feature(align_offset)]\n #![feature(asm)]\n+#![feature(attr_literals)]\n #![feature(box_syntax)]\n #![feature(cfg_target_has_atomic)]\n #![feature(cfg_target_thread_local)]\n@@ -290,6 +291,7 @@\n #![feature(prelude_import)]\n #![feature(rand)]\n #![feature(raw)]\n+#![feature(repr_align)]\n #![feature(repr_simd)]\n #![feature(rustc_attrs)]\n #![cfg_attr(not(stage0), feature(rustc_const_unstable))]"}, {"sha": "4656cc5a7a78137aec9eb51c5c5eeab96083b4d2", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -1579,6 +1579,21 @@ mod tests {\n                 \"bad error: {} {:?}\", e, e.kind());\n     }\n \n+    #[test]\n+    fn connect_timeout_unbound() {\n+        // bind and drop a socket to track down a \"probably unassigned\" port\n+        let socket = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n+        let addr = socket.local_addr().unwrap();\n+        drop(socket);\n+\n+        let timeout = Duration::from_secs(1);\n+        let e = TcpStream::connect_timeout(&addr, timeout).unwrap_err();\n+        assert!(e.kind() == io::ErrorKind::ConnectionRefused ||\n+                e.kind() == io::ErrorKind::TimedOut ||\n+                e.kind() == io::ErrorKind::Other,\n+                \"bad error: {} {:?}\", e, e.kind());\n+    }\n+\n     #[test]\n     fn connect_timeout_valid() {\n         let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();"}, {"sha": "f448cffd3725c30ae6709205aa1f87976cbf710a", "filename": "src/libstd/process.rs", "status": "modified", "additions": 118, "deletions": 4, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -702,6 +702,15 @@ impl AsInnerMut<imp::Command> for Command {\n }\n \n /// The output of a finished process.\n+///\n+/// This is returned in a Result by either the [`output`] method of a\n+/// [`Command`], or the [`wait_with_output`] method of a [`Child`]\n+/// process.\n+///\n+/// [`Command`]: struct.Command.html\n+/// [`Child`]: struct.Child.html\n+/// [`output`]: struct.Command.html#method.output\n+/// [`wait_with_output`]: struct.Child.html#method.wait_with_output\n #[derive(PartialEq, Eq, Clone)]\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct Output {\n@@ -742,21 +751,128 @@ impl fmt::Debug for Output {\n     }\n }\n \n-/// Describes what to do with a standard I/O stream for a child process.\n+/// Describes what to do with a standard I/O stream for a child process when\n+/// passed to the [`stdin`], [`stdout`], and [`stderr`] methods of [`Command`].\n+///\n+/// [`stdin`]: struct.Command.html#method.stdin\n+/// [`stdout`]: struct.Command.html#method.stdout\n+/// [`stderr`]: struct.Command.html#method.stderr\n+/// [`Command`]: struct.Command.html\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct Stdio(imp::Stdio);\n \n impl Stdio {\n     /// A new pipe should be arranged to connect the parent and child processes.\n+    ///\n+    /// # Examples\n+    ///\n+    /// With stdout:\n+    ///\n+    /// ```no_run\n+    /// use std::process::{Command, Stdio};\n+    ///\n+    /// let output = Command::new(\"echo\")\n+    ///     .arg(\"Hello, world!\")\n+    ///     .stdout(Stdio::piped())\n+    ///     .output()\n+    ///     .expect(\"Failed to execute command\");\n+    ///\n+    /// assert_eq!(String::from_utf8_lossy(&output.stdout), \"Hello, world!\\n\");\n+    /// // Nothing echoed to console\n+    /// ```\n+    ///\n+    /// With stdin:\n+    ///\n+    /// ```no_run\n+    /// use std::io::Write;\n+    /// use std::process::{Command, Stdio};\n+    ///\n+    /// let mut child = Command::new(\"rev\")\n+    ///     .stdin(Stdio::piped())\n+    ///     .stdout(Stdio::piped())\n+    ///     .spawn()\n+    ///     .expect(\"Failed to spawn child process\");\n+    ///\n+    /// {\n+    ///     let mut stdin = child.stdin.as_mut().expect(\"Failed to open stdin\");\n+    ///     stdin.write_all(\"Hello, world!\".as_bytes()).expect(\"Failed to write to stdin\");\n+    /// }\n+    ///\n+    /// let output = child.wait_with_output().expect(\"Failed to read stdout\");\n+    /// assert_eq!(String::from_utf8_lossy(&output.stdout), \"!dlrow ,olleH\\n\");\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn piped() -> Stdio { Stdio(imp::Stdio::MakePipe) }\n \n     /// The child inherits from the corresponding parent descriptor.\n+    ///\n+    /// # Examples\n+    ///\n+    /// With stdout:\n+    ///\n+    /// ```no_run\n+    /// use std::process::{Command, Stdio};\n+    ///\n+    /// let output = Command::new(\"echo\")\n+    ///     .arg(\"Hello, world!\")\n+    ///     .stdout(Stdio::inherit())\n+    ///     .output()\n+    ///     .expect(\"Failed to execute command\");\n+    ///\n+    /// assert_eq!(String::from_utf8_lossy(&output.stdout), \"\");\n+    /// // \"Hello, world!\" echoed to console\n+    /// ```\n+    ///\n+    /// With stdin:\n+    ///\n+    /// ```no_run\n+    /// use std::process::{Command, Stdio};\n+    ///\n+    /// let output = Command::new(\"rev\")\n+    ///     .stdin(Stdio::inherit())\n+    ///     .stdout(Stdio::piped())\n+    ///     .output()\n+    ///     .expect(\"Failed to execute command\");\n+    ///\n+    /// println!(\"You piped in the reverse of: {}\", String::from_utf8_lossy(&output.stdout));\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn inherit() -> Stdio { Stdio(imp::Stdio::Inherit) }\n \n     /// This stream will be ignored. This is the equivalent of attaching the\n     /// stream to `/dev/null`\n+    ///\n+    /// # Examples\n+    ///\n+    /// With stdout:\n+    ///\n+    /// ```no_run\n+    /// use std::process::{Command, Stdio};\n+    ///\n+    /// let output = Command::new(\"echo\")\n+    ///     .arg(\"Hello, world!\")\n+    ///     .stdout(Stdio::null())\n+    ///     .output()\n+    ///     .expect(\"Failed to execute command\");\n+    ///\n+    /// assert_eq!(String::from_utf8_lossy(&output.stdout), \"\");\n+    /// // Nothing echoed to console\n+    /// ```\n+    ///\n+    /// With stdin:\n+    ///\n+    /// ```no_run\n+    /// use std::process::{Command, Stdio};\n+    ///\n+    /// let output = Command::new(\"rev\")\n+    ///     .stdin(Stdio::null())\n+    ///     .stdout(Stdio::piped())\n+    ///     .output()\n+    ///     .expect(\"Failed to execute command\");\n+    ///\n+    /// assert_eq!(String::from_utf8_lossy(&output.stdout), \"\");\n+    /// // Ignores any piped-in input\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn null() -> Stdio { Stdio(imp::Stdio::Null) }\n }\n@@ -1083,8 +1199,6 @@ impl Child {\n /// function and compute the exit code from its return value:\n ///\n /// ```\n-/// use std::io::{self, Write};\n-///\n /// fn run_app() -> Result<(), ()> {\n ///     // Application logic here\n ///     Ok(())\n@@ -1094,7 +1208,7 @@ impl Child {\n ///     ::std::process::exit(match run_app() {\n ///        Ok(_) => 0,\n ///        Err(err) => {\n-///            writeln!(io::stderr(), \"error: {:?}\", err).unwrap();\n+///            eprintln!(\"error: {:?}\", err);\n ///            1\n ///        }\n ///     });"}, {"sha": "5af01262573f3b93133abadf5c5293f2d4ffa198", "filename": "src/libstd/sync/mpsc/cache_aligned.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fsync%2Fmpsc%2Fcache_aligned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fsync%2Fmpsc%2Fcache_aligned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fcache_aligned.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ops::{Deref, DerefMut};\n+\n+#[derive(Copy, Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[repr(align(64))]\n+pub(super) struct Aligner;\n+\n+#[derive(Copy, Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub(super) struct CacheAligned<T>(pub T, pub Aligner);\n+\n+impl<T> Deref for CacheAligned<T> {\n+     type Target = T;\n+     fn deref(&self) -> &Self::Target {\n+         &self.0\n+     }\n+}\n+\n+impl<T> DerefMut for CacheAligned<T> {\n+     fn deref_mut(&mut self) -> &mut Self::Target {\n+         &mut self.0\n+     }\n+}\n+\n+impl<T> CacheAligned<T> {\n+    pub(super) fn new(t: T) -> Self {\n+        CacheAligned(t, Aligner)\n+    }\n+}"}, {"sha": "45a26e594b0654740d8426d89f20a3364498b59c", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -297,6 +297,8 @@ mod sync;\n mod mpsc_queue;\n mod spsc_queue;\n \n+mod cache_aligned;\n+\n /// The receiving half of Rust's [`channel`][] (or [`sync_channel`]) type.\n /// This half can only be owned by one thread.\n ///\n@@ -919,7 +921,7 @@ impl<T> Drop for Sender<T> {\n #[stable(feature = \"mpsc_debug\", since = \"1.8.0\")]\n impl<T> fmt::Debug for Sender<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Sender {{ .. }}\")\n+        f.debug_struct(\"Sender\").finish()\n     }\n }\n \n@@ -1049,7 +1051,7 @@ impl<T> Drop for SyncSender<T> {\n #[stable(feature = \"mpsc_debug\", since = \"1.8.0\")]\n impl<T> fmt::Debug for SyncSender<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"SyncSender {{ .. }}\")\n+        f.debug_struct(\"SyncSender\").finish()\n     }\n }\n \n@@ -1551,7 +1553,7 @@ impl<T> Drop for Receiver<T> {\n #[stable(feature = \"mpsc_debug\", since = \"1.8.0\")]\n impl<T> fmt::Debug for Receiver<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Receiver {{ .. }}\")\n+        f.debug_struct(\"Receiver\").finish()\n     }\n }\n \n@@ -3009,22 +3011,4 @@ mod sync_tests {\n             repro()\n         }\n     }\n-\n-    #[test]\n-    fn fmt_debug_sender() {\n-        let (tx, _) = channel::<i32>();\n-        assert_eq!(format!(\"{:?}\", tx), \"Sender { .. }\");\n-    }\n-\n-    #[test]\n-    fn fmt_debug_recv() {\n-        let (_, rx) = channel::<i32>();\n-        assert_eq!(format!(\"{:?}\", rx), \"Receiver { .. }\");\n-    }\n-\n-    #[test]\n-    fn fmt_debug_sync_sender() {\n-        let (tx, _) = sync_channel::<i32>(1);\n-        assert_eq!(format!(\"{:?}\", tx), \"SyncSender { .. }\");\n-    }\n }"}, {"sha": "a9f3cea243f366c61e0abf759c474c95a00581ae", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -354,13 +354,13 @@ impl Iterator for Packets {\n \n impl fmt::Debug for Select {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Select {{ .. }}\")\n+        f.debug_struct(\"Select\").finish()\n     }\n }\n \n impl<'rx, T:Send+'rx> fmt::Debug for Handle<'rx, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Handle {{ .. }}\")\n+        f.debug_struct(\"Handle\").finish()\n     }\n }\n \n@@ -774,18 +774,4 @@ mod tests {\n             }\n         }\n     }\n-\n-    #[test]\n-    fn fmt_debug_select() {\n-        let sel = Select::new();\n-        assert_eq!(format!(\"{:?}\", sel), \"Select { .. }\");\n-    }\n-\n-    #[test]\n-    fn fmt_debug_handle() {\n-        let (_, rx) = channel::<i32>();\n-        let sel = Select::new();\n-        let handle = sel.handle(&rx);\n-        assert_eq!(format!(\"{:?}\", handle), \"Handle { .. }\");\n-    }\n }"}, {"sha": "cc4be92276a3b2c3ac4943c00904f77164222d2c", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 90, "deletions": 63, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -22,51 +22,71 @@ use core::cell::UnsafeCell;\n \n use sync::atomic::{AtomicPtr, AtomicUsize, Ordering};\n \n+use super::cache_aligned::CacheAligned;\n+\n // Node within the linked list queue of messages to send\n struct Node<T> {\n     // FIXME: this could be an uninitialized T if we're careful enough, and\n     //      that would reduce memory usage (and be a bit faster).\n     //      is it worth it?\n     value: Option<T>,           // nullable for re-use of nodes\n+    cached: bool,               // This node goes into the node cache\n     next: AtomicPtr<Node<T>>,   // next node in the queue\n }\n \n /// The single-producer single-consumer queue. This structure is not cloneable,\n /// but it can be safely shared in an Arc if it is guaranteed that there\n /// is only one popper and one pusher touching the queue at any one point in\n /// time.\n-pub struct Queue<T> {\n+pub struct Queue<T, ProducerAddition=(), ConsumerAddition=()> {\n     // consumer fields\n+    consumer: CacheAligned<Consumer<T, ConsumerAddition>>,\n+\n+    // producer fields\n+    producer: CacheAligned<Producer<T, ProducerAddition>>,\n+}\n+\n+struct Consumer<T, Addition> {\n     tail: UnsafeCell<*mut Node<T>>, // where to pop from\n     tail_prev: AtomicPtr<Node<T>>, // where to pop from\n+    cache_bound: usize, // maximum cache size\n+    cached_nodes: AtomicUsize, // number of nodes marked as cachable\n+    addition: Addition,\n+}\n \n-    // producer fields\n+struct Producer<T, Addition> {\n     head: UnsafeCell<*mut Node<T>>,      // where to push to\n     first: UnsafeCell<*mut Node<T>>,     // where to get new nodes from\n     tail_copy: UnsafeCell<*mut Node<T>>, // between first/tail\n-\n-    // Cache maintenance fields. Additions and subtractions are stored\n-    // separately in order to allow them to use nonatomic addition/subtraction.\n-    cache_bound: usize,\n-    cache_additions: AtomicUsize,\n-    cache_subtractions: AtomicUsize,\n+    addition: Addition,\n }\n \n-unsafe impl<T: Send> Send for Queue<T> { }\n+unsafe impl<T: Send, P: Send + Sync, C: Send + Sync> Send for Queue<T, P, C> { }\n \n-unsafe impl<T: Send> Sync for Queue<T> { }\n+unsafe impl<T: Send, P: Send + Sync, C: Send + Sync> Sync for Queue<T, P, C> { }\n \n impl<T> Node<T> {\n     fn new() -> *mut Node<T> {\n         Box::into_raw(box Node {\n             value: None,\n+            cached: false,\n             next: AtomicPtr::new(ptr::null_mut::<Node<T>>()),\n         })\n     }\n }\n \n-impl<T> Queue<T> {\n-    /// Creates a new queue.\n+impl<T, ProducerAddition, ConsumerAddition> Queue<T, ProducerAddition, ConsumerAddition> {\n+\n+    /// Creates a new queue. With given additional elements in the producer and\n+    /// consumer portions of the queue.\n+    ///\n+    /// Due to the performance implications of cache-contention,\n+    /// we wish to keep fields used mainly by the producer on a separate cache\n+    /// line than those used by the consumer.\n+    /// Since cache lines are usually 64 bytes, it is unreasonably expensive to\n+    /// allocate one for small fields, so we allow users to insert additional\n+    /// fields into the cache lines already allocated by this for the producer\n+    /// and consumer.\n     ///\n     /// This is unsafe as the type system doesn't enforce a single\n     /// consumer-producer relationship. It also allows the consumer to `pop`\n@@ -83,19 +103,28 @@ impl<T> Queue<T> {\n     ///               cache (if desired). If the value is 0, then the cache has\n     ///               no bound. Otherwise, the cache will never grow larger than\n     ///               `bound` (although the queue itself could be much larger.\n-    pub unsafe fn new(bound: usize) -> Queue<T> {\n+    pub unsafe fn with_additions(\n+        bound: usize,\n+        producer_addition: ProducerAddition,\n+        consumer_addition: ConsumerAddition,\n+    ) -> Self {\n         let n1 = Node::new();\n         let n2 = Node::new();\n         (*n1).next.store(n2, Ordering::Relaxed);\n         Queue {\n-            tail: UnsafeCell::new(n2),\n-            tail_prev: AtomicPtr::new(n1),\n-            head: UnsafeCell::new(n2),\n-            first: UnsafeCell::new(n1),\n-            tail_copy: UnsafeCell::new(n1),\n-            cache_bound: bound,\n-            cache_additions: AtomicUsize::new(0),\n-            cache_subtractions: AtomicUsize::new(0),\n+            consumer: CacheAligned::new(Consumer {\n+                tail: UnsafeCell::new(n2),\n+                tail_prev: AtomicPtr::new(n1),\n+                cache_bound: bound,\n+                cached_nodes: AtomicUsize::new(0),\n+                addition: consumer_addition\n+            }),\n+            producer: CacheAligned::new(Producer {\n+                head: UnsafeCell::new(n2),\n+                first: UnsafeCell::new(n1),\n+                tail_copy: UnsafeCell::new(n1),\n+                addition: producer_addition\n+            }),\n         }\n     }\n \n@@ -109,35 +138,25 @@ impl<T> Queue<T> {\n             assert!((*n).value.is_none());\n             (*n).value = Some(t);\n             (*n).next.store(ptr::null_mut(), Ordering::Relaxed);\n-            (**self.head.get()).next.store(n, Ordering::Release);\n-            *self.head.get() = n;\n+            (**self.producer.head.get()).next.store(n, Ordering::Release);\n+            *(&self.producer.head).get() = n;\n         }\n     }\n \n     unsafe fn alloc(&self) -> *mut Node<T> {\n         // First try to see if we can consume the 'first' node for our uses.\n-        // We try to avoid as many atomic instructions as possible here, so\n-        // the addition to cache_subtractions is not atomic (plus we're the\n-        // only one subtracting from the cache).\n-        if *self.first.get() != *self.tail_copy.get() {\n-            if self.cache_bound > 0 {\n-                let b = self.cache_subtractions.load(Ordering::Relaxed);\n-                self.cache_subtractions.store(b + 1, Ordering::Relaxed);\n-            }\n-            let ret = *self.first.get();\n-            *self.first.get() = (*ret).next.load(Ordering::Relaxed);\n+        if *self.producer.first.get() != *self.producer.tail_copy.get() {\n+            let ret = *self.producer.first.get();\n+            *self.producer.0.first.get() = (*ret).next.load(Ordering::Relaxed);\n             return ret;\n         }\n         // If the above fails, then update our copy of the tail and try\n         // again.\n-        *self.tail_copy.get() = self.tail_prev.load(Ordering::Acquire);\n-        if *self.first.get() != *self.tail_copy.get() {\n-            if self.cache_bound > 0 {\n-                let b = self.cache_subtractions.load(Ordering::Relaxed);\n-                self.cache_subtractions.store(b + 1, Ordering::Relaxed);\n-            }\n-            let ret = *self.first.get();\n-            *self.first.get() = (*ret).next.load(Ordering::Relaxed);\n+        *self.producer.0.tail_copy.get() =\n+            self.consumer.tail_prev.load(Ordering::Acquire);\n+        if *self.producer.first.get() != *self.producer.tail_copy.get() {\n+            let ret = *self.producer.first.get();\n+            *self.producer.0.first.get() = (*ret).next.load(Ordering::Relaxed);\n             return ret;\n         }\n         // If all of that fails, then we have to allocate a new node\n@@ -153,27 +172,27 @@ impl<T> Queue<T> {\n             // sentinel from where we should start popping from. Hence, look at\n             // tail's next field and see if we can use it. If we do a pop, then\n             // the current tail node is a candidate for going into the cache.\n-            let tail = *self.tail.get();\n+            let tail = *self.consumer.tail.get();\n             let next = (*tail).next.load(Ordering::Acquire);\n             if next.is_null() { return None }\n             assert!((*next).value.is_some());\n             let ret = (*next).value.take();\n \n-            *self.tail.get() = next;\n-            if self.cache_bound == 0 {\n-                self.tail_prev.store(tail, Ordering::Release);\n+            *self.consumer.0.tail.get() = next;\n+            if self.consumer.cache_bound == 0 {\n+                self.consumer.tail_prev.store(tail, Ordering::Release);\n             } else {\n-                // FIXME: this is dubious with overflow.\n-                let additions = self.cache_additions.load(Ordering::Relaxed);\n-                let subtractions = self.cache_subtractions.load(Ordering::Relaxed);\n-                let size = additions - subtractions;\n-\n-                if size < self.cache_bound {\n-                    self.tail_prev.store(tail, Ordering::Release);\n-                    self.cache_additions.store(additions + 1, Ordering::Relaxed);\n+                let cached_nodes = self.consumer.cached_nodes.load(Ordering::Relaxed);\n+                if cached_nodes < self.consumer.cache_bound && !(*tail).cached {\n+                    self.consumer.cached_nodes.store(cached_nodes, Ordering::Relaxed);\n+                    (*tail).cached = true;\n+                }\n+\n+                if (*tail).cached {\n+                    self.consumer.tail_prev.store(tail, Ordering::Release);\n                 } else {\n-                    (*self.tail_prev.load(Ordering::Relaxed))\n-                          .next.store(next, Ordering::Relaxed);\n+                    (*self.consumer.tail_prev.load(Ordering::Relaxed))\n+                        .next.store(next, Ordering::Relaxed);\n                     // We have successfully erased all references to 'tail', so\n                     // now we can safely drop it.\n                     let _: Box<Node<T>> = Box::from_raw(tail);\n@@ -194,17 +213,25 @@ impl<T> Queue<T> {\n         // This is essentially the same as above with all the popping bits\n         // stripped out.\n         unsafe {\n-            let tail = *self.tail.get();\n+            let tail = *self.consumer.tail.get();\n             let next = (*tail).next.load(Ordering::Acquire);\n             if next.is_null() { None } else { (*next).value.as_mut() }\n         }\n     }\n+\n+    pub fn producer_addition(&self) -> &ProducerAddition {\n+        &self.producer.addition\n+    }\n+\n+    pub fn consumer_addition(&self) -> &ConsumerAddition {\n+        &self.consumer.addition\n+    }\n }\n \n-impl<T> Drop for Queue<T> {\n+impl<T, ProducerAddition, ConsumerAddition> Drop for Queue<T, ProducerAddition, ConsumerAddition> {\n     fn drop(&mut self) {\n         unsafe {\n-            let mut cur = *self.first.get();\n+            let mut cur = *self.producer.first.get();\n             while !cur.is_null() {\n                 let next = (*cur).next.load(Ordering::Relaxed);\n                 let _n: Box<Node<T>> = Box::from_raw(cur);\n@@ -224,7 +251,7 @@ mod tests {\n     #[test]\n     fn smoke() {\n         unsafe {\n-            let queue = Queue::new(0);\n+            let queue = Queue::with_additions(0, (), ());\n             queue.push(1);\n             queue.push(2);\n             assert_eq!(queue.pop(), Some(1));\n@@ -241,7 +268,7 @@ mod tests {\n     #[test]\n     fn peek() {\n         unsafe {\n-            let queue = Queue::new(0);\n+            let queue = Queue::with_additions(0, (), ());\n             queue.push(vec![1]);\n \n             // Ensure the borrowchecker works\n@@ -264,7 +291,7 @@ mod tests {\n     #[test]\n     fn drop_full() {\n         unsafe {\n-            let q: Queue<Box<_>> = Queue::new(0);\n+            let q: Queue<Box<_>> = Queue::with_additions(0, (), ());\n             q.push(box 1);\n             q.push(box 2);\n         }\n@@ -273,7 +300,7 @@ mod tests {\n     #[test]\n     fn smoke_bound() {\n         unsafe {\n-            let q = Queue::new(0);\n+            let q = Queue::with_additions(0, (), ());\n             q.push(1);\n             q.push(2);\n             assert_eq!(q.pop(), Some(1));\n@@ -295,7 +322,7 @@ mod tests {\n         }\n \n         unsafe fn stress_bound(bound: usize) {\n-            let q = Arc::new(Queue::new(bound));\n+            let q = Arc::new(Queue::with_additions(bound, (), ()));\n \n             let (tx, rx) = channel();\n             let q2 = q.clone();"}, {"sha": "d1515eba68c3eea8ffbf88af03db9661614134e5", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 61, "deletions": 44, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -41,15 +41,22 @@ const MAX_STEALS: isize = 5;\n const MAX_STEALS: isize = 1 << 20;\n \n pub struct Packet<T> {\n-    queue: spsc::Queue<Message<T>>, // internal queue for all message\n+    // internal queue for all messages\n+    queue: spsc::Queue<Message<T>, ProducerAddition, ConsumerAddition>,\n+}\n \n+struct ProducerAddition {\n     cnt: AtomicIsize, // How many items are on this channel\n-    steals: UnsafeCell<isize>, // How many times has a port received without blocking?\n     to_wake: AtomicUsize, // SignalToken for the blocked thread to wake up\n \n     port_dropped: AtomicBool, // flag if the channel has been destroyed.\n }\n \n+struct ConsumerAddition {\n+    steals: UnsafeCell<isize>,  // How many times has a port received without blocking?\n+}\n+\n+\n pub enum Failure<T> {\n     Empty,\n     Disconnected,\n@@ -78,21 +85,26 @@ enum Message<T> {\n impl<T> Packet<T> {\n     pub fn new() -> Packet<T> {\n         Packet {\n-            queue: unsafe { spsc::Queue::new(128) },\n-\n-            cnt: AtomicIsize::new(0),\n-            steals: UnsafeCell::new(0),\n-            to_wake: AtomicUsize::new(0),\n-\n-            port_dropped: AtomicBool::new(false),\n+            queue: unsafe { spsc::Queue::with_additions(\n+                128,\n+                ProducerAddition {\n+                    cnt: AtomicIsize::new(0),\n+                    to_wake: AtomicUsize::new(0),\n+\n+                    port_dropped: AtomicBool::new(false),\n+                },\n+                ConsumerAddition {\n+                    steals: UnsafeCell::new(0),\n+                }\n+            )},\n         }\n     }\n \n     pub fn send(&self, t: T) -> Result<(), T> {\n         // If the other port has deterministically gone away, then definitely\n         // must return the data back up the stack. Otherwise, the data is\n         // considered as being sent.\n-        if self.port_dropped.load(Ordering::SeqCst) { return Err(t) }\n+        if self.queue.producer_addition().port_dropped.load(Ordering::SeqCst) { return Err(t) }\n \n         match self.do_send(Data(t)) {\n             UpSuccess | UpDisconnected => {},\n@@ -104,14 +116,16 @@ impl<T> Packet<T> {\n     pub fn upgrade(&self, up: Receiver<T>) -> UpgradeResult {\n         // If the port has gone away, then there's no need to proceed any\n         // further.\n-        if self.port_dropped.load(Ordering::SeqCst) { return UpDisconnected }\n+        if self.queue.producer_addition().port_dropped.load(Ordering::SeqCst) {\n+            return UpDisconnected\n+        }\n \n         self.do_send(GoUp(up))\n     }\n \n     fn do_send(&self, t: Message<T>) -> UpgradeResult {\n         self.queue.push(t);\n-        match self.cnt.fetch_add(1, Ordering::SeqCst) {\n+        match self.queue.producer_addition().cnt.fetch_add(1, Ordering::SeqCst) {\n             // As described in the mod's doc comment, -1 == wakeup\n             -1 => UpWoke(self.take_to_wake()),\n             // As as described before, SPSC queues must be >= -2\n@@ -125,7 +139,7 @@ impl<T> Packet<T> {\n             // will never remove this data. We can only have at most one item to\n             // drain (the port drains the rest).\n             DISCONNECTED => {\n-                self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n+                self.queue.producer_addition().cnt.store(DISCONNECTED, Ordering::SeqCst);\n                 let first = self.queue.pop();\n                 let second = self.queue.pop();\n                 assert!(second.is_none());\n@@ -144,8 +158,8 @@ impl<T> Packet<T> {\n \n     // Consumes ownership of the 'to_wake' field.\n     fn take_to_wake(&self) -> SignalToken {\n-        let ptr = self.to_wake.load(Ordering::SeqCst);\n-        self.to_wake.store(0, Ordering::SeqCst);\n+        let ptr = self.queue.producer_addition().to_wake.load(Ordering::SeqCst);\n+        self.queue.producer_addition().to_wake.store(0, Ordering::SeqCst);\n         assert!(ptr != 0);\n         unsafe { SignalToken::cast_from_usize(ptr) }\n     }\n@@ -154,14 +168,16 @@ impl<T> Packet<T> {\n     // back if it shouldn't sleep. Note that this is the location where we take\n     // steals into account.\n     fn decrement(&self, token: SignalToken) -> Result<(), SignalToken> {\n-        assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n+        assert_eq!(self.queue.producer_addition().to_wake.load(Ordering::SeqCst), 0);\n         let ptr = unsafe { token.cast_to_usize() };\n-        self.to_wake.store(ptr, Ordering::SeqCst);\n+        self.queue.producer_addition().to_wake.store(ptr, Ordering::SeqCst);\n \n-        let steals = unsafe { ptr::replace(self.steals.get(), 0) };\n+        let steals = unsafe { ptr::replace(self.queue.consumer_addition().steals.get(), 0) };\n \n-        match self.cnt.fetch_sub(1 + steals, Ordering::SeqCst) {\n-            DISCONNECTED => { self.cnt.store(DISCONNECTED, Ordering::SeqCst); }\n+        match self.queue.producer_addition().cnt.fetch_sub(1 + steals, Ordering::SeqCst) {\n+            DISCONNECTED => {\n+                self.queue.producer_addition().cnt.store(DISCONNECTED, Ordering::SeqCst);\n+            }\n             // If we factor in our steals and notice that the channel has no\n             // data, we successfully sleep\n             n => {\n@@ -170,7 +186,7 @@ impl<T> Packet<T> {\n             }\n         }\n \n-        self.to_wake.store(0, Ordering::SeqCst);\n+        self.queue.producer_addition().to_wake.store(0, Ordering::SeqCst);\n         Err(unsafe { SignalToken::cast_from_usize(ptr) })\n     }\n \n@@ -201,7 +217,7 @@ impl<T> Packet<T> {\n             // \"steal\" factored into the channel count above).\n             data @ Ok(..) |\n             data @ Err(Upgraded(..)) => unsafe {\n-                *self.steals.get() -= 1;\n+                *self.queue.consumer_addition().steals.get() -= 1;\n                 data\n             },\n \n@@ -223,28 +239,29 @@ impl<T> Packet<T> {\n             // down as much as possible (without going negative), and then\n             // adding back in whatever we couldn't factor into steals.\n             Some(data) => unsafe {\n-                if *self.steals.get() > MAX_STEALS {\n-                    match self.cnt.swap(0, Ordering::SeqCst) {\n+                if *self.queue.consumer_addition().steals.get() > MAX_STEALS {\n+                    match self.queue.producer_addition().cnt.swap(0, Ordering::SeqCst) {\n                         DISCONNECTED => {\n-                            self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n+                            self.queue.producer_addition().cnt.store(\n+                                DISCONNECTED, Ordering::SeqCst);\n                         }\n                         n => {\n-                            let m = cmp::min(n, *self.steals.get());\n-                            *self.steals.get() -= m;\n+                            let m = cmp::min(n, *self.queue.consumer_addition().steals.get());\n+                            *self.queue.consumer_addition().steals.get() -= m;\n                             self.bump(n - m);\n                         }\n                     }\n-                    assert!(*self.steals.get() >= 0);\n+                    assert!(*self.queue.consumer_addition().steals.get() >= 0);\n                 }\n-                *self.steals.get() += 1;\n+                *self.queue.consumer_addition().steals.get() += 1;\n                 match data {\n                     Data(t) => Ok(t),\n                     GoUp(up) => Err(Upgraded(up)),\n                 }\n             },\n \n             None => {\n-                match self.cnt.load(Ordering::SeqCst) {\n+                match self.queue.producer_addition().cnt.load(Ordering::SeqCst) {\n                     n if n != DISCONNECTED => Err(Empty),\n \n                     // This is a little bit of a tricky case. We failed to pop\n@@ -273,7 +290,7 @@ impl<T> Packet<T> {\n     pub fn drop_chan(&self) {\n         // Dropping a channel is pretty simple, we just flag it as disconnected\n         // and then wakeup a blocker if there is one.\n-        match self.cnt.swap(DISCONNECTED, Ordering::SeqCst) {\n+        match self.queue.producer_addition().cnt.swap(DISCONNECTED, Ordering::SeqCst) {\n             -1 => { self.take_to_wake().signal(); }\n             DISCONNECTED => {}\n             n => { assert!(n >= 0); }\n@@ -300,7 +317,7 @@ impl<T> Packet<T> {\n         // sends are gated on this flag, so we're immediately guaranteed that\n         // there are a bounded number of active sends that we'll have to deal\n         // with.\n-        self.port_dropped.store(true, Ordering::SeqCst);\n+        self.queue.producer_addition().port_dropped.store(true, Ordering::SeqCst);\n \n         // Now that we're guaranteed to deal with a bounded number of senders,\n         // we need to drain the queue. This draining process happens atomically\n@@ -310,9 +327,9 @@ impl<T> Packet<T> {\n         // continue to fail while active senders send data while we're dropping\n         // data, but eventually we're guaranteed to break out of this loop\n         // (because there is a bounded number of senders).\n-        let mut steals = unsafe { *self.steals.get() };\n+        let mut steals = unsafe { *self.queue.consumer_addition().steals.get() };\n         while {\n-            let cnt = self.cnt.compare_and_swap(\n+            let cnt = self.queue.producer_addition().cnt.compare_and_swap(\n                             steals, DISCONNECTED, Ordering::SeqCst);\n             cnt != DISCONNECTED && cnt != steals\n         } {\n@@ -353,9 +370,9 @@ impl<T> Packet<T> {\n \n     // increment the count on the channel (used for selection)\n     fn bump(&self, amt: isize) -> isize {\n-        match self.cnt.fetch_add(amt, Ordering::SeqCst) {\n+        match self.queue.producer_addition().cnt.fetch_add(amt, Ordering::SeqCst) {\n             DISCONNECTED => {\n-                self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n+                self.queue.producer_addition().cnt.store(DISCONNECTED, Ordering::SeqCst);\n                 DISCONNECTED\n             }\n             n => n\n@@ -404,8 +421,8 @@ impl<T> Packet<T> {\n         // this end. This is fine because we know it's a small bounded windows\n         // of time until the data is actually sent.\n         if was_upgrade {\n-            assert_eq!(unsafe { *self.steals.get() }, 0);\n-            assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n+            assert_eq!(unsafe { *self.queue.consumer_addition().steals.get() }, 0);\n+            assert_eq!(self.queue.producer_addition().to_wake.load(Ordering::SeqCst), 0);\n             return Ok(true)\n         }\n \n@@ -418,7 +435,7 @@ impl<T> Packet<T> {\n         // If we were previously disconnected, then we know for sure that there\n         // is no thread in to_wake, so just keep going\n         let has_data = if prev == DISCONNECTED {\n-            assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n+            assert_eq!(self.queue.producer_addition().to_wake.load(Ordering::SeqCst), 0);\n             true // there is data, that data is that we're disconnected\n         } else {\n             let cur = prev + steals + 1;\n@@ -441,13 +458,13 @@ impl<T> Packet<T> {\n             if prev < 0 {\n                 drop(self.take_to_wake());\n             } else {\n-                while self.to_wake.load(Ordering::SeqCst) != 0 {\n+                while self.queue.producer_addition().to_wake.load(Ordering::SeqCst) != 0 {\n                     thread::yield_now();\n                 }\n             }\n             unsafe {\n-                assert_eq!(*self.steals.get(), 0);\n-                *self.steals.get() = steals;\n+                assert_eq!(*self.queue.consumer_addition().steals.get(), 0);\n+                *self.queue.consumer_addition().steals.get() = steals;\n             }\n \n             // if we were previously positive, then there's surely data to\n@@ -481,7 +498,7 @@ impl<T> Drop for Packet<T> {\n         // disconnection, but also a proper fence before the read of\n         // `to_wake`, so this assert cannot be removed with also removing\n         // the `to_wake` assert.\n-        assert_eq!(self.cnt.load(Ordering::SeqCst), DISCONNECTED);\n-        assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n+        assert_eq!(self.queue.producer_addition().cnt.load(Ordering::SeqCst), DISCONNECTED);\n+        assert_eq!(self.queue.producer_addition().to_wake.load(Ordering::SeqCst), 0);\n     }\n }"}, {"sha": "eb507858b92b23f5bd8dd76f88add49e76a4650d", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -394,11 +394,18 @@ impl<T: ?Sized + Default> Default for Mutex<T> {\n impl<T: ?Sized + fmt::Debug> fmt::Debug for Mutex<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.try_lock() {\n-            Ok(guard) => write!(f, \"Mutex {{ data: {:?} }}\", &*guard),\n+            Ok(guard) => f.debug_struct(\"Mutex\").field(\"data\", &&*guard).finish(),\n             Err(TryLockError::Poisoned(err)) => {\n-                write!(f, \"Mutex {{ data: Poisoned({:?}) }}\", &**err.get_ref())\n+                f.debug_struct(\"Mutex\").field(\"data\", &&**err.get_ref()).finish()\n             },\n-            Err(TryLockError::WouldBlock) => write!(f, \"Mutex {{ <locked> }}\")\n+            Err(TryLockError::WouldBlock) => {\n+                struct LockedPlaceholder;\n+                impl fmt::Debug for LockedPlaceholder {\n+                    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { f.write_str(\"<locked>\") }\n+                }\n+\n+                f.debug_struct(\"Mutex\").field(\"data\", &LockedPlaceholder).finish()\n+            }\n         }\n     }\n }"}, {"sha": "5c49d6b58459ccb76988a2680372ee7ae826602a", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -428,11 +428,18 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for RwLock<T> {\n impl<T: ?Sized + fmt::Debug> fmt::Debug for RwLock<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.try_read() {\n-            Ok(guard) => write!(f, \"RwLock {{ data: {:?} }}\", &*guard),\n+            Ok(guard) => f.debug_struct(\"RwLock\").field(\"data\", &&*guard).finish(),\n             Err(TryLockError::Poisoned(err)) => {\n-                write!(f, \"RwLock {{ data: Poisoned({:?}) }}\", &**err.get_ref())\n+                f.debug_struct(\"RwLock\").field(\"data\", &&**err.get_ref()).finish()\n             },\n-            Err(TryLockError::WouldBlock) => write!(f, \"RwLock {{ <locked> }}\")\n+            Err(TryLockError::WouldBlock) => {\n+                struct LockedPlaceholder;\n+                impl fmt::Debug for LockedPlaceholder {\n+                    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { f.write_str(\"<locked>\") }\n+                }\n+\n+                f.debug_struct(\"RwLock\").field(\"data\", &LockedPlaceholder).finish()\n+            }\n         }\n     }\n }"}, {"sha": "e775f857f2b40a84b8df717f9ed6d30649a02b3c", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -176,11 +176,16 @@ impl Socket {\n                 }\n                 0 => {}\n                 _ => {\n-                    if pollfd.revents & libc::POLLOUT == 0 {\n-                        if let Some(e) = self.take_error()? {\n-                            return Err(e);\n-                        }\n+                    // linux returns POLLOUT|POLLERR|POLLHUP for refused connections (!), so look\n+                    // for POLLHUP rather than read readiness\n+                    if pollfd.revents & libc::POLLHUP != 0 {\n+                        let e = self.take_error()?\n+                            .unwrap_or_else(|| {\n+                                io::Error::new(io::ErrorKind::Other, \"no error set after POLLHUP\")\n+                            });\n+                        return Err(e);\n                     }\n+\n                     return Ok(());\n                 }\n             }"}, {"sha": "d6b8896ac096d2e8caf3594a9b6459dfae69e8cb", "filename": "src/libstd/sys/windows/ext/ffi.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fffi.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -9,6 +9,62 @@\n // except according to those terms.\n \n //! Windows-specific extensions to the primitives in the `std::ffi` module.\n+//!\n+//! # Overview\n+//!\n+//! For historical reasons, the Windows API uses a form of potentially\n+//! ill-formed UTF-16 encoding for strings.  Specifically, the 16-bit\n+//! code units in Windows strings may contain [isolated surrogate code\n+//! points which are not paired together][ill-formed-utf-16].  The\n+//! Unicode standard requires that surrogate code points (those in the\n+//! range U+D800 to U+DFFF) always be *paired*, because in the UTF-16\n+//! encoding a *surrogate code unit pair* is used to encode a single\n+//! character.  For compatibility with code that does not enforce\n+//! these pairings, Windows does not enforce them, either.\n+//!\n+//! While it is not always possible to convert such a string losslessly into\n+//! a valid UTF-16 string (or even UTF-8), it is often desirable to be\n+//! able to round-trip such a string from and to Windows APIs\n+//! losslessly.  For example, some Rust code may be \"bridging\" some\n+//! Windows APIs together, just passing `WCHAR` strings among those\n+//! APIs without ever really looking into the strings.\n+//!\n+//! If Rust code *does* need to look into those strings, it can\n+//! convert them to valid UTF-8, possibly lossily, by substituting\n+//! invalid sequences with U+FFFD REPLACEMENT CHARACTER, as is\n+//! conventionally done in other Rust APIs that deal with string\n+//! encodings.\n+//!\n+//! # `OsStringExt` and `OsStrExt`\n+//!\n+//! [`OsString`] is the Rust wrapper for owned strings in the\n+//! preferred representation of the operating system.  On Windows,\n+//! this struct gets augmented with an implementation of the\n+//! [`OsStringExt`] trait, which has a [`from_wide`] method.  This\n+//! lets you create an [`OsString`] from a `&[u16]` slice; presumably\n+//! you get such a slice out of a `WCHAR` Windows API.\n+//!\n+//! Similarly, [`OsStr`] is the Rust wrapper for borrowed strings from\n+//! preferred representation of the operating system.  On Windows, the\n+//! [`OsStrExt`] trait provides the [`encode_wide`] method, which\n+//! outputs an [`EncodeWide`] iterator.  You can [`collect`] this\n+//! iterator, for example, to obtain a `Vec<u16>`; you can later get a\n+//! pointer to this vector's contents and feed it to Windows APIs.\n+//!\n+//! These traits, along with [`OsString`] and [`OsStr`], work in\n+//! conjunction so that it is possible to **round-trip** strings from\n+//! Windows and back, with no loss of data, even if the strings are\n+//! ill-formed UTF-16.\n+//!\n+//! [ill-formed-utf-16]: https://simonsapin.github.io/wtf-8/#ill-formed-utf-16\n+//! [`OsString`]: ../../../ffi/struct.OsString.html\n+//! [`OsStr`]: ../../../ffi/struct.OsStr.html\n+//! [`OsStringExt`]: trait.OsStringExt.html\n+//! [`OsStrExt`]: trait.OsStrExt.html\n+//! [`EncodeWide`]: struct.EncodeWide.html\n+//! [`from_wide`]: trait.OsStringExt.html#tymethod.from_wide\n+//! [`encode_wide`]: trait.OsStrExt.html#tymethod.encode_wide\n+//! [`collect`]: ../../../iter/trait.Iterator.html#method.collect\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "ce43ec6d9abf585f70b910403824a59555e70762", "filename": "src/libstd/sys_common/remutex.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fsys_common%2Fremutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fsys_common%2Fremutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fremutex.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -116,11 +116,18 @@ impl<T> Drop for ReentrantMutex<T> {\n impl<T: fmt::Debug + 'static> fmt::Debug for ReentrantMutex<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.try_lock() {\n-            Ok(guard) => write!(f, \"ReentrantMutex {{ data: {:?} }}\", &*guard),\n+            Ok(guard) => f.debug_struct(\"ReentrantMutex\").field(\"data\", &*guard).finish(),\n             Err(TryLockError::Poisoned(err)) => {\n-                write!(f, \"ReentrantMutex {{ data: Poisoned({:?}) }}\", &**err.get_ref())\n+                f.debug_struct(\"ReentrantMutex\").field(\"data\", &**err.get_ref()).finish()\n             },\n-            Err(TryLockError::WouldBlock) => write!(f, \"ReentrantMutex {{ <locked> }}\")\n+            Err(TryLockError::WouldBlock) => {\n+                struct LockedPlaceholder;\n+                impl fmt::Debug for LockedPlaceholder {\n+                    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { f.write_str(\"<locked>\") }\n+                }\n+\n+                f.debug_struct(\"ReentrantMutex\").field(\"data\", &LockedPlaceholder).finish()\n+            }\n         }\n     }\n }"}, {"sha": "07bbddc62b9f9f5e07cad2d1e8c158878cfc8a71", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -485,15 +485,17 @@ impl Builder {\n /// let (tx, rx) = channel();\n ///\n /// let sender = thread::spawn(move || {\n-///     let _ = tx.send(\"Hello, thread\".to_owned());\n+///     tx.send(\"Hello, thread\".to_owned())\n+///         .expect(\"Unable to send on channel\");\n /// });\n ///\n /// let receiver = thread::spawn(move || {\n-///     println!(\"{}\", rx.recv().unwrap());\n+///     let value = rx.recv().expect(\"Unable to receive from channel\");\n+///     println!(\"{}\", value);\n /// });\n ///\n-/// let _ = sender.join();\n-/// let _ = receiver.join();\n+/// sender.join().expect(\"The sender thread has panicked\");\n+/// receiver.join().expect(\"The receiver thread has panicked\");\n /// ```\n ///\n /// A thread can also return a value through its [`JoinHandle`], you can use\n@@ -1192,7 +1194,7 @@ impl<T> JoinInner<T> {\n ///     });\n /// });\n ///\n-/// let _ = original_thread.join();\n+/// original_thread.join().expect(\"The thread being joined has panicked\");\n /// println!(\"Original thread is joined.\");\n ///\n /// // We make sure that the new thread has time to run, before the main"}, {"sha": "f445def9e0335182dbed2e0118e0a8f288098706", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -1419,7 +1419,7 @@ pub enum TyKind {\n     Path(Option<QSelf>, Path),\n     /// A trait object type `Bound1 + Bound2 + Bound3`\n     /// where `Bound` is a trait or a lifetime.\n-    TraitObject(TyParamBounds),\n+    TraitObject(TyParamBounds, TraitObjectSyntax),\n     /// An `impl Bound1 + Bound2 + Bound3` type\n     /// where `Bound` is a trait or a lifetime.\n     ImplTrait(TyParamBounds),\n@@ -1438,6 +1438,13 @@ pub enum TyKind {\n     Err,\n }\n \n+/// Syntax used to declare a trait object.\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum TraitObjectSyntax {\n+    Dyn,\n+    None,\n+}\n+\n /// Inline assembly dialect.\n ///\n /// E.g. `\"intel\"` as in `asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")``"}, {"sha": "9060a613bc132d87f03f2300483046420bc62511", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -398,6 +398,9 @@ declare_features! (\n \n     // Default match binding modes (RFC 2005)\n     (active, match_default_bindings, \"1.22.0\", Some(42640)),\n+\n+    // Trait object syntax with `dyn` prefix\n+    (active, dyn_trait, \"1.22.0\", Some(44662)),\n );\n \n declare_features! (\n@@ -1417,6 +1420,10 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 gate_feature_post!(&self, never_type, ty.span,\n                                    \"The `!` type is experimental\");\n             },\n+            ast::TyKind::TraitObject(_, ast::TraitObjectSyntax::Dyn) => {\n+                gate_feature_post!(&self, dyn_trait, ty.span,\n+                                   \"`dyn Trait` syntax is unstable\");\n+            }\n             _ => {}\n         }\n         visit::walk_ty(self, ty)"}, {"sha": "d7d491db71f05bfb449c7d5d21436a2da42de7be", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -400,8 +400,8 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n             TyKind::Typeof(expr) => {\n                 TyKind::Typeof(fld.fold_expr(expr))\n             }\n-            TyKind::TraitObject(bounds) => {\n-                TyKind::TraitObject(bounds.move_map(|b| fld.fold_ty_param_bound(b)))\n+            TyKind::TraitObject(bounds, syntax) => {\n+                TyKind::TraitObject(bounds.move_map(|b| fld.fold_ty_param_bound(b)), syntax)\n             }\n             TyKind::ImplTrait(bounds) => {\n                 TyKind::ImplTrait(bounds.move_map(|b| fld.fold_ty_param_bound(b)))"}, {"sha": "35afe8dd56d9335381734972e7b4da8ae417a2f6", "filename": "src/libsyntax/parse/lexer/unicode_chars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -144,7 +144,7 @@ const UNICODE_ARRAY: &'static [(char, &'static str, char)] = &[\n     ('\u2035', \"Reversed Prime\", '\\''),\n     ('\u055a', \"Armenian Apostrophe\", '\\''),\n     ('\u05f3', \"Hebrew Punctuation Geresh\", '\\''),\n-    ('`', \"Greek Accent\", '\\''),\n+    ('`', \"Grave Accent\", '\\''),\n     ('\u1fef', \"Greek Varia\", '\\''),\n     ('\uff40', \"Fullwidth Grave Accent\", '\\''),\n     ('\u00b4', \"Acute Accent\", '\\''),"}, {"sha": "bd400ef6dd6dab9ecdbb0fd960171bc9c13ec94a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 68, "deletions": 29, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -33,7 +33,7 @@ use ast::{Stmt, StmtKind};\n use ast::{VariantData, StructField};\n use ast::StrStyle;\n use ast::SelfKind;\n-use ast::{TraitItem, TraitRef};\n+use ast::{TraitItem, TraitRef, TraitObjectSyntax};\n use ast::{Ty, TyKind, TypeBinding, TyParam, TyParamBounds};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n@@ -364,6 +364,13 @@ fn is_ident_or_underscore(t: &token::Token) -> bool {\n     t.is_ident() || *t == token::Underscore\n }\n \n+// Returns true if `IDENT t` can start a type - `IDENT::a::b`, `IDENT<u8, u8>`,\n+// `IDENT<<u8 as Trait>::AssocTy>`, `IDENT(u8, u8) -> u8`.\n+fn can_continue_type_after_ident(t: &token::Token) -> bool {\n+    t == &token::ModSep || t == &token::Lt ||\n+    t == &token::BinOp(token::Shl) || t == &token::OpenDelim(token::Paren)\n+}\n+\n /// Information about the path to a module.\n pub struct ModulePath {\n     pub name: String,\n@@ -1428,7 +1435,7 @@ impl<'a> Parser<'a> {\n                     TyKind::Path(None, ref path) if maybe_bounds => {\n                         self.parse_remaining_bounds(Vec::new(), path.clone(), lo, true)?\n                     }\n-                    TyKind::TraitObject(ref bounds)\n+                    TyKind::TraitObject(ref bounds, TraitObjectSyntax::None)\n                             if maybe_bounds && bounds.len() == 1 && !trailing_plus => {\n                         let path = match bounds[0] {\n                             TraitTyParamBound(ref pt, ..) => pt.trait_ref.path.clone(),\n@@ -1472,27 +1479,6 @@ impl<'a> Parser<'a> {\n         } else if self.eat(&token::Underscore) {\n             // A type to be inferred `_`\n             TyKind::Infer\n-        } else if self.eat_lt() {\n-            // Qualified path\n-            let (qself, path) = self.parse_qpath(PathStyle::Type)?;\n-            TyKind::Path(Some(qself), path)\n-        } else if self.token.is_path_start() {\n-            // Simple path\n-            let path = self.parse_path(PathStyle::Type)?;\n-            if self.eat(&token::Not) {\n-                // Macro invocation in type position\n-                let (_, tts) = self.expect_delimited_token_tree()?;\n-                TyKind::Mac(respan(lo.to(self.span), Mac_ { path: path, tts: tts }))\n-            } else {\n-                // Just a type path or bound list (trait object type) starting with a trait.\n-                //   `Type`\n-                //   `Trait1 + Trait2 + 'a`\n-                if allow_plus && self.check(&token::BinOp(token::Plus)) {\n-                    self.parse_remaining_bounds(Vec::new(), path, lo, true)?\n-                } else {\n-                    TyKind::Path(None, path)\n-                }\n-            }\n         } else if self.token_is_bare_fn_keyword() {\n             // Function pointer type\n             self.parse_ty_bare_fn(Vec::new())?\n@@ -1512,10 +1498,37 @@ impl<'a> Parser<'a> {\n         } else if self.eat_keyword(keywords::Impl) {\n             // FIXME: figure out priority of `+` in `impl Trait1 + Trait2` (#34511).\n             TyKind::ImplTrait(self.parse_ty_param_bounds()?)\n+        } else if self.check_keyword(keywords::Dyn) &&\n+                  self.look_ahead(1, |t| t.can_begin_bound() && !can_continue_type_after_ident(t)) {\n+            // FIXME: figure out priority of `+` in `dyn Trait1 + Trait2` (#34511).\n+            self.bump(); // `dyn`\n+            TyKind::TraitObject(self.parse_ty_param_bounds()?, TraitObjectSyntax::Dyn)\n         } else if self.check(&token::Question) ||\n-                  self.check_lifetime() && self.look_ahead(1, |t| t == &token::BinOp(token::Plus)){\n+                  self.check_lifetime() && self.look_ahead(1, |t| t == &token::BinOp(token::Plus)) {\n             // Bound list (trait object type)\n-            TyKind::TraitObject(self.parse_ty_param_bounds_common(allow_plus)?)\n+            TyKind::TraitObject(self.parse_ty_param_bounds_common(allow_plus)?,\n+                                TraitObjectSyntax::None)\n+        } else if self.eat_lt() {\n+            // Qualified path\n+            let (qself, path) = self.parse_qpath(PathStyle::Type)?;\n+            TyKind::Path(Some(qself), path)\n+        } else if self.token.is_path_start() {\n+            // Simple path\n+            let path = self.parse_path(PathStyle::Type)?;\n+            if self.eat(&token::Not) {\n+                // Macro invocation in type position\n+                let (_, tts) = self.expect_delimited_token_tree()?;\n+                TyKind::Mac(respan(lo.to(self.span), Mac_ { path: path, tts: tts }))\n+            } else {\n+                // Just a type path or bound list (trait object type) starting with a trait.\n+                //   `Type`\n+                //   `Trait1 + Trait2 + 'a`\n+                if allow_plus && self.check(&token::BinOp(token::Plus)) {\n+                    self.parse_remaining_bounds(Vec::new(), path, lo, true)?\n+                } else {\n+                    TyKind::Path(None, path)\n+                }\n+            }\n         } else {\n             let msg = format!(\"expected type, found {}\", self.this_token_descr());\n             return Err(self.fatal(&msg));\n@@ -1538,7 +1551,7 @@ impl<'a> Parser<'a> {\n             self.bump(); // `+`\n             bounds.append(&mut self.parse_ty_param_bounds()?);\n         }\n-        Ok(TyKind::TraitObject(bounds))\n+        Ok(TyKind::TraitObject(bounds, TraitObjectSyntax::None))\n     }\n \n     fn maybe_recover_from_bad_type_plus(&mut self, allow_plus: bool, ty: &Ty) -> PResult<'a, ()> {\n@@ -2314,6 +2327,7 @@ impl<'a> Parser<'a> {\n \n         while self.token != token::CloseDelim(token::Brace) {\n             if self.eat(&token::DotDot) {\n+                let exp_span = self.prev_span;\n                 match self.parse_expr() {\n                     Ok(e) => {\n                         base = Some(e);\n@@ -2323,6 +2337,16 @@ impl<'a> Parser<'a> {\n                         self.recover_stmt();\n                     }\n                 }\n+                if self.token == token::Comma {\n+                    let mut err = self.sess.span_diagnostic.mut_span_err(\n+                        exp_span.to(self.prev_span),\n+                        \"cannot use a comma after the base struct\",\n+                    );\n+                    err.span_suggestion_short(self.span, \"remove this comma\", \"\".to_owned());\n+                    err.note(\"the base struct must always be the last field\");\n+                    err.emit();\n+                    self.recover_stmt();\n+                }\n                 break;\n             }\n \n@@ -2890,17 +2914,30 @@ impl<'a> Parser<'a> {\n \n                 match self.parse_path(PathStyle::Expr) {\n                     Ok(path) => {\n+                        let (op_noun, op_verb) = match self.token {\n+                            token::Lt => (\"comparison\", \"comparing\"),\n+                            token::BinOp(token::Shl) => (\"shift\", \"shifting\"),\n+                            _ => {\n+                                // We can end up here even without `<` being the next token, for\n+                                // example because `parse_ty_no_plus` returns `Err` on keywords,\n+                                // but `parse_path` returns `Ok` on them due to error recovery.\n+                                // Return original error and parser state.\n+                                mem::replace(self, parser_snapshot_after_type);\n+                                return Err(type_err);\n+                            }\n+                        };\n+\n                         // Successfully parsed the type path leaving a `<` yet to parse.\n                         type_err.cancel();\n \n                         // Report non-fatal diagnostics, keep `x as usize` as an expression\n                         // in AST and continue parsing.\n                         let msg = format!(\"`<` is interpreted as a start of generic \\\n-                                           arguments for `{}`, not a comparison\", path);\n+                                           arguments for `{}`, not a {}\", path, op_noun);\n                         let mut err = self.sess.span_diagnostic.struct_span_err(self.span, &msg);\n                         err.span_label(self.look_ahead_span(1).to(parser_snapshot_after_type.span),\n                                        \"interpreted as generic arguments\");\n-                        err.span_label(self.span, \"not interpreted as comparison\");\n+                        err.span_label(self.span, format!(\"not interpreted as {}\", op_noun));\n \n                         let expr = mk_expr(self, P(Ty {\n                             span: path.span,\n@@ -2911,7 +2948,7 @@ impl<'a> Parser<'a> {\n                         let expr_str = self.sess.codemap().span_to_snippet(expr.span)\n                                                 .unwrap_or(pprust::expr_to_string(&expr));\n                         err.span_suggestion(expr.span,\n-                                            \"try comparing the casted value\",\n+                                            &format!(\"try {} the casted value\", op_verb),\n                                             format!(\"({})\", expr_str));\n                         err.emit();\n \n@@ -2947,6 +2984,7 @@ impl<'a> Parser<'a> {\n                 {                                  //     Foo<Bar<Baz<Qux, ()>>>\n                     err.help(\n                         \"use `::<...>` instead of `<...>` if you meant to specify type arguments\");\n+                    err.help(\"or use `(...)` if you meant to specify fn arguments\");\n                 }\n                 err.emit();\n             }\n@@ -4231,6 +4269,7 @@ impl<'a> Parser<'a> {\n     fn parse_ty_param_bounds_common(&mut self, allow_plus: bool) -> PResult<'a, TyParamBounds> {\n         let mut bounds = Vec::new();\n         loop {\n+            // This needs to be syncronized with `Token::can_begin_bound`.\n             let is_bound_start = self.check_path() || self.check_lifetime() ||\n                                  self.check(&token::Question) ||\n                                  self.check_keyword(keywords::For) ||"}, {"sha": "20db87cfc82d9849367418a197ed876691136aa0", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -258,6 +258,12 @@ impl Token {\n         }\n     }\n \n+    /// Returns `true` if the token can appear at the start of a generic bound.\n+    pub fn can_begin_bound(&self) -> bool {\n+        self.is_path_start() || self.is_lifetime() || self.is_keyword(keywords::For) ||\n+        self == &Question || self == &OpenDelim(Paren)\n+    }\n+\n     /// Returns `true` if the token is any literal\n     pub fn is_lit(&self) -> bool {\n         match *self {"}, {"sha": "02f871c58c73cfb7065d05f8f34c98d16b656fbf", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -1049,8 +1049,9 @@ impl<'a> State<'a> {\n             ast::TyKind::Path(Some(ref qself), ref path) => {\n                 self.print_qpath(path, qself, false)?\n             }\n-            ast::TyKind::TraitObject(ref bounds) => {\n-                self.print_bounds(\"\", &bounds[..])?;\n+            ast::TyKind::TraitObject(ref bounds, syntax) => {\n+                let prefix = if syntax == ast::TraitObjectSyntax::Dyn { \"dyn \" } else { \"\" };\n+                self.print_bounds(prefix, &bounds[..])?;\n             }\n             ast::TyKind::ImplTrait(ref bounds) => {\n                 self.print_bounds(\"impl \", &bounds[..])?;"}, {"sha": "521c6030eba2cc06d064e78ec08a475631638e69", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -348,7 +348,7 @@ pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n             visitor.visit_ty(ty);\n             visitor.visit_expr(expression)\n         }\n-        TyKind::TraitObject(ref bounds) |\n+        TyKind::TraitObject(ref bounds, ..) |\n         TyKind::ImplTrait(ref bounds) => {\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n         }"}, {"sha": "d30d79ece15c73cf62d566b10cc74dff87d18e11", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -339,8 +339,11 @@ impl serialize::UseSpecializedDecodable for Span {\n }\n \n fn default_span_debug(span: Span, f: &mut fmt::Formatter) -> fmt::Result {\n-    write!(f, \"Span {{ lo: {:?}, hi: {:?}, ctxt: {:?} }}\",\n-           span.lo(), span.hi(), span.ctxt())\n+    f.debug_struct(\"Span\")\n+        .field(\"lo\", &span.lo())\n+        .field(\"hi\", &span.hi())\n+        .field(\"ctxt\", &span.ctxt())\n+        .finish()\n }\n \n impl fmt::Debug for Span {"}, {"sha": "872fc031cfb1a8a0fe980b86a5f6e34857884de9", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -309,10 +309,11 @@ declare_keywords! {\n     (54, Yield,          \"yield\")\n \n     // Weak keywords, have special meaning only in specific contexts.\n-    (55, Default,        \"default\")\n-    (56, StaticLifetime, \"'static\")\n-    (57, Union,          \"union\")\n-    (58, Catch,          \"catch\")\n+    (55, Catch,          \"catch\")\n+    (56, Default,        \"default\")\n+    (57, Dyn,            \"dyn\")\n+    (58, StaticLifetime, \"'static\")\n+    (59, Union,          \"union\")\n }\n \n // If an interner exists in TLS, return it. Otherwise, prepare a fresh one."}, {"sha": "83b72cedfd7800ffc983d2855a85c5d06a545aa7", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -1 +1 @@\n-Subproject commit c7a16bd57c2a9c643a52f0cebecdaf0b6a996da1\n+Subproject commit 83b72cedfd7800ffc983d2855a85c5d06a545aa7"}, {"sha": "608e5f5f36d02eb3b6d5ae7eaa8e8a77077beb7f", "filename": "src/rustc/compiler_builtins_shim/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Frustc%2Fcompiler_builtins_shim%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Frustc%2Fcompiler_builtins_shim%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fcompiler_builtins_shim%2FCargo.toml?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -30,7 +30,7 @@ doctest = false\n core = { path = \"../../libcore\" }\n \n [build-dependencies]\n-cc = \"1.0\"\n+cc = \"1.0.1\"\n \n [features]\n c = []"}, {"sha": "1287b94159a57f23ff80fbe32b395a946f250d9c", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -901,9 +901,7 @@ addPreservedGUID(const ModuleSummaryIndex &Index,\n       }\n     }\n \n-    GlobalValueSummary *GVSummary = Summary.get();\n-    if (isa<FunctionSummary>(GVSummary)) {\n-      FunctionSummary *FS = cast<FunctionSummary>(GVSummary);\n+    if (auto *FS = dyn_cast<FunctionSummary>(Summary.get())) {\n       for (auto &Call: FS->calls()) {\n         if (Call.first.isGUID()) {\n           addPreservedGUID(Index, Preserved, Call.first.getGUID());\n@@ -916,6 +914,10 @@ addPreservedGUID(const ModuleSummaryIndex &Index,\n         addPreservedGUID(Index, Preserved, GUID);\n       }\n     }\n+    if (auto *AS = dyn_cast<AliasSummary>(Summary.get())) {\n+      auto GUID = AS->getAliasee().getOriginalName();\n+      addPreservedGUID(Index, Preserved, GUID);\n+    }\n   }\n }\n \n@@ -963,12 +965,13 @@ LLVMRustCreateThinLTOData(LLVMRustThinLTOModule *modules,\n   // combined index\n   //\n   // This is copied from `lib/LTO/ThinLTOCodeGenerator.cpp`\n-  computeDeadSymbols(Ret->Index, Ret->GUIDPreservedSymbols);\n+  auto DeadSymbols = computeDeadSymbols(Ret->Index, Ret->GUIDPreservedSymbols);\n   ComputeCrossModuleImport(\n     Ret->Index,\n     Ret->ModuleToDefinedGVSummaries,\n     Ret->ImportLists,\n-    Ret->ExportLists\n+    Ret->ExportLists,\n+    &DeadSymbols\n   );\n \n   // Resolve LinkOnce/Weak symbols, this has to be computed early be cause it"}, {"sha": "20ea8d70302205f1084b7745ef24475b86e8c2c4", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -57,7 +57,7 @@ static AtomicOrdering fromRust(LLVMAtomicOrdering Ordering) {\n   llvm_unreachable(\"Invalid LLVMAtomicOrdering value!\");\n }\n \n-static char *LastError;\n+static LLVM_THREAD_LOCAL char *LastError;\n \n extern \"C\" LLVMMemoryBufferRef\n LLVMRustCreateMemoryBufferWithContentsOfFile(const char *Path) {"}, {"sha": "b8033b88fb75eaec0b2d81ea031821bb8baa1dec", "filename": "src/test/codegen-units/item-collection/drop_in_place_intrinsic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fdrop_in_place_intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fdrop_in_place_intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fdrop_in_place_intrinsic.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -10,6 +10,7 @@\n \n // ignore-tidy-linelength\n // compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zinline-in-all-cgus\n \n //~ TRANS_ITEM fn core::ptr[0]::drop_in_place[0]<drop_in_place_intrinsic::StructWithDtor[0]> @@ drop_in_place_intrinsic0[Internal]\n struct StructWithDtor(u32);"}, {"sha": "65936d12e316fde81392057ffbaeb02f1309d9ed", "filename": "src/test/codegen-units/item-collection/generic-drop-glue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-drop-glue.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -10,6 +10,7 @@\n \n // ignore-tidy-linelength\n // compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zinline-in-all-cgus\n \n #![deny(dead_code)]\n "}, {"sha": "e32366d15c33718c82a64b88b9713ab6c131de38", "filename": "src/test/codegen-units/item-collection/instantiation-through-vtable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Finstantiation-through-vtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Finstantiation-through-vtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Finstantiation-through-vtable.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -10,6 +10,7 @@\n \n // ignore-tidy-linelength\n // compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zinline-in-all-cgus\n \n #![deny(dead_code)]\n "}, {"sha": "5765f230e8bd4331336bd9fb7235595dc449a4ed", "filename": "src/test/codegen-units/item-collection/non-generic-drop-glue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-drop-glue.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -10,6 +10,7 @@\n \n // ignore-tidy-linelength\n // compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zinline-in-all-cgus\n \n #![deny(dead_code)]\n "}, {"sha": "be560690e51903563fb616c20cd51430c353c804", "filename": "src/test/codegen-units/item-collection/transitive-drop-glue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftransitive-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftransitive-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftransitive-drop-glue.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -10,6 +10,7 @@\n \n // ignore-tidy-linelength\n // compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zinline-in-all-cgus\n \n #![deny(dead_code)]\n "}, {"sha": "ad1475a73f7cc58aad6987f8625673112f1bba07", "filename": "src/test/codegen-units/item-collection/tuple-drop-glue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftuple-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftuple-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftuple-drop-glue.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -10,6 +10,7 @@\n \n // ignore-tidy-linelength\n // compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zinline-in-all-cgus\n \n #![deny(dead_code)]\n "}, {"sha": "d7e457cde8a9092c15fd3fe97ef32328ac9a09e7", "filename": "src/test/codegen-units/item-collection/unsizing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funsizing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funsizing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funsizing.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -10,6 +10,7 @@\n \n // ignore-tidy-linelength\n // compile-flags:-Zprint-trans-items=eager\n+// compile-flags:-Zinline-in-all-cgus\n \n #![deny(dead_code)]\n #![feature(coerce_unsized)]"}, {"sha": "29528644ed0a055c714fe8ea7082e9dd27c7f46a", "filename": "src/test/codegen-units/partitioning/extern-drop-glue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-drop-glue.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -13,6 +13,7 @@\n // We specify -Z incremental here because we want to test the partitioning for\n // incremental compilation\n // compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp/partitioning-tests/extern-drop-glue\n+// compile-flags:-Zinline-in-all-cgus\n \n #![allow(dead_code)]\n #![crate_type=\"lib\"]"}, {"sha": "4bfd35b59bc120a7c20ad86f8ed4c1195d9f2422", "filename": "src/test/codegen-units/partitioning/inlining-from-extern-crate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Finlining-from-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Finlining-from-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Finlining-from-extern-crate.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -12,6 +12,7 @@\n // We specify -Z incremental here because we want to test the partitioning for\n // incremental compilation\n // compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp/partitioning-tests/inlining-from-extern-crate\n+// compile-flags:-Zinline-in-all-cgus\n \n #![crate_type=\"lib\"]\n "}, {"sha": "65e91343ccfcf2c957678d49949fb4f2be65ec3a", "filename": "src/test/codegen-units/partitioning/local-drop-glue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -12,6 +12,7 @@\n // We specify -Z incremental here because we want to test the partitioning for\n // incremental compilation\n // compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp/partitioning-tests/local-drop-glue\n+// compile-flags:-Zinline-in-all-cgus\n \n #![allow(dead_code)]\n #![crate_type=\"lib\"]"}, {"sha": "84464a627beb10906cd0500f17416439ada47010", "filename": "src/test/codegen-units/partitioning/local-inlining-but-not-all.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining-but-not-all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining-but-not-all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining-but-not-all.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// We specify -Z incremental here because we want to test the partitioning for\n+// incremental compilation\n+// compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp/partitioning-tests/local-inlining-but-not-all\n+// compile-flags:-Zinline-in-all-cgus=no\n+\n+#![allow(dead_code)]\n+#![crate_type=\"lib\"]\n+\n+mod inline {\n+\n+    //~ TRANS_ITEM fn local_inlining_but_not_all::inline[0]::inlined_function[0] @@ local_inlining_but_not_all-inline[External]\n+    #[inline]\n+    pub fn inlined_function()\n+    {\n+\n+    }\n+}\n+\n+mod user1 {\n+    use super::inline;\n+\n+    //~ TRANS_ITEM fn local_inlining_but_not_all::user1[0]::foo[0] @@ local_inlining_but_not_all-user1[Internal]\n+    fn foo() {\n+        inline::inlined_function();\n+    }\n+}\n+\n+mod user2 {\n+    use super::inline;\n+\n+    //~ TRANS_ITEM fn local_inlining_but_not_all::user2[0]::bar[0] @@ local_inlining_but_not_all-user2[Internal]\n+    fn bar() {\n+        inline::inlined_function();\n+    }\n+}\n+\n+mod non_user {\n+\n+    //~ TRANS_ITEM fn local_inlining_but_not_all::non_user[0]::baz[0] @@ local_inlining_but_not_all-non_user[Internal]\n+    fn baz() {\n+\n+    }\n+}"}, {"sha": "f31761912412e270191e1707614cb658c8117a48", "filename": "src/test/codegen-units/partitioning/local-inlining.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -12,6 +12,7 @@\n // We specify -Z incremental here because we want to test the partitioning for\n // incremental compilation\n // compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp/partitioning-tests/local-inlining\n+// compile-flags:-Zinline-in-all-cgus\n \n #![allow(dead_code)]\n #![crate_type=\"lib\"]"}, {"sha": "bda76a8789f0f07790e6b9c20462627a584fb391", "filename": "src/test/codegen-units/partitioning/local-transitive-inlining.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-transitive-inlining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-transitive-inlining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-transitive-inlining.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -12,6 +12,7 @@\n // We specify -Z incremental here because we want to test the partitioning for\n // incremental compilation\n // compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp/partitioning-tests/local-transitive-inlining\n+// compile-flags:-Zinline-in-all-cgus\n \n #![allow(dead_code)]\n #![crate_type=\"lib\"]"}, {"sha": "302f9312b57095ef125cd5f27fd9e7aa9454fe2d", "filename": "src/test/codegen-units/partitioning/vtable-through-const.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fvtable-through-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fvtable-through-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fvtable-through-const.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -13,6 +13,7 @@\n // We specify -Z incremental here because we want to test the partitioning for\n // incremental compilation\n // compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp/partitioning-tests/vtable-through-const\n+// compile-flags:-Zinline-in-all-cgus\n \n // This test case makes sure, that references made through constants are\n // recorded properly in the InliningMap."}, {"sha": "5e40e8ede15571f63a0c1f69cc52782f32c3e211", "filename": "src/test/codegen/auxiliary/nounwind.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen%2Fauxiliary%2Fnounwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen%2Fauxiliary%2Fnounwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fauxiliary%2Fnounwind.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[no_mangle]\n+pub fn bar() {\n+}"}, {"sha": "6a6d6f90b2e69acab3553106cd1959620dcd7118", "filename": "src/test/codegen/float_math.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen%2Ffloat_math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen%2Ffloat_math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffloat_math.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -19,7 +19,7 @@ use std::intrinsics::{fadd_fast, fsub_fast, fmul_fast, fdiv_fast, frem_fast};\n #[no_mangle]\n pub fn add(x: f32, y: f32) -> f32 {\n // CHECK: fadd float\n-// CHECK-NOT fast\n+// CHECK-NOT: fast\n     x + y\n }\n "}, {"sha": "9fea907d3c884e56f1078e4b197b9dc3df38a8c9", "filename": "src/test/codegen/nounwind.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen%2Fnounwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen%2Fnounwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fnounwind.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:nounwind.rs\n+// compile-flags: -C no-prepopulate-passes -C panic=abort -C metadata=a\n+// ignore-windows\n+\n+#![crate_type = \"lib\"]\n+\n+extern crate nounwind;\n+\n+#[no_mangle]\n+pub fn foo() {\n+    nounwind::bar();\n+// CHECK: @foo() unnamed_addr #0\n+// CHECK: @bar() unnamed_addr #0\n+// CHECK: attributes #0 = { {{.*}}nounwind{{.*}} }\n+}\n+"}, {"sha": "15688bdc2a110983b22c141e43c3081971499618", "filename": "src/test/codegen/panic-abort-windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen%2Fpanic-abort-windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcodegen%2Fpanic-abort-windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fpanic-abort-windows.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -28,7 +28,7 @@\n \n #![crate_type = \"lib\"]\n \n-// CHECK: Function Attrs: uwtable\n+// CHECK: Function Attrs: nounwind uwtable\n // CHECK-NEXT: define void @normal_uwtable()\n #[no_mangle]\n pub fn normal_uwtable() {"}, {"sha": "548436c3ed87021eedd2d0b2383ddb45bd158188", "filename": "src/test/compile-fail/borrowck/borrowck-assign-comp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-assign-comp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-assign-comp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-assign-comp.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -22,7 +22,7 @@ fn a() {\n     // immutable.  Otherwise the type of &_q.x (&isize) would be wrong.\n     p.x = 5; //[ast]~ ERROR cannot assign to `p.x`\n              //[mir]~^ ERROR cannot assign to `p.x` because it is borrowed (Ast)\n-             //[mir]~| ERROR cannot assign to `p.0` because it is borrowed (Mir)\n+             //[mir]~| ERROR cannot assign to `p.x` because it is borrowed (Mir)\n     q.x;\n }\n \n@@ -47,7 +47,7 @@ fn d() {\n     let q = &p.y;\n     p.y = 5; //[ast]~ ERROR cannot assign to `p.y`\n              //[mir]~^ ERROR cannot assign to `p.y` because it is borrowed (Ast)\n-             //[mir]~| ERROR cannot assign to `p.1` because it is borrowed (Mir)\n+             //[mir]~| ERROR cannot assign to `p.y` because it is borrowed (Mir)\n     *q;\n }\n "}, {"sha": "0b6b9bf7d484d9fd3faf114c8a499b533d36a3c5", "filename": "src/test/compile-fail/borrowck/borrowck-closures-mut-and-imm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-closures-mut-and-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-closures-mut-and-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-closures-mut-and-imm.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -82,7 +82,7 @@ fn g() {\n     let c1 = || get(&*x.f);\n     *x.f = 5; //[ast]~ ERROR cannot assign to `*x.f`\n               //[mir]~^ ERROR cannot assign to `*x.f` because it is borrowed (Ast)\n-              //[mir]~| ERROR cannot assign to `(*(*x).0)` because it is borrowed (Mir)\n+              //[mir]~| ERROR cannot assign to `(*x.f)` because it is borrowed (Mir)\n }\n \n fn h() {"}, {"sha": "cff913b17beddd49ce8323dd8254628a9031e520", "filename": "src/test/compile-fail/borrowck/borrowck-describe-lvalue.rs", "status": "added", "additions": 330, "deletions": 0, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-describe-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-describe-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-describe-lvalue.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -0,0 +1,330 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n+#![feature(slice_patterns)]\n+#![feature(advanced_slice_patterns)]\n+\n+pub struct Foo {\n+  x: u32\n+}\n+\n+pub struct Bar(u32);\n+\n+pub enum Baz {\n+    X(u32)\n+}\n+\n+union U {\n+    a: u8,\n+    b: u64,\n+}\n+\n+impl Foo {\n+  fn x(&mut self) -> &mut u32 { &mut self.x }\n+}\n+\n+impl Bar {\n+    fn x(&mut self) -> &mut u32 { &mut self.0 }\n+}\n+\n+impl Baz {\n+    fn x(&mut self) -> &mut u32 {\n+        match *self {\n+            Baz::X(ref mut value) => value\n+        }\n+    }\n+}\n+\n+static mut sfoo : Foo = Foo{x: 23 };\n+static mut sbar : Bar = Bar(23);\n+static mut stuple : (i32, i32) = (24, 25);\n+static mut senum : Baz = Baz::X(26);\n+static mut sunion : U = U { a: 0 };\n+\n+fn main() {\n+    // Local and field from struct\n+    {\n+        let mut f = Foo { x: 22 };\n+        let _x = f.x();\n+        f.x; //[ast]~ ERROR cannot use `f.x` because it was mutably borrowed\n+             //[mir]~^ ERROR cannot use `f.x` because it was mutably borrowed (Ast)\n+             //[mir]~| ERROR cannot use `f.x` because it was mutably borrowed (Mir)\n+    }\n+    // Local and field from tuple-struct\n+    {\n+        let mut g = Bar(22);\n+        let _0 = g.x();\n+        g.0; //[ast]~ ERROR cannot use `g.0` because it was mutably borrowed\n+             //[mir]~^ ERROR cannot use `g.0` because it was mutably borrowed (Ast)\n+             //[mir]~| ERROR cannot use `g.0` because it was mutably borrowed (Mir)\n+    }\n+    // Local and field from tuple\n+    {\n+        let mut h = (22, 23);\n+        let _0 = &mut h.0;\n+        h.0; //[ast]~ ERROR cannot use `h.0` because it was mutably borrowed\n+             //[mir]~^ ERROR cannot use `h.0` because it was mutably borrowed (Ast)\n+             //[mir]~| ERROR cannot use `h.0` because it was mutably borrowed (Mir)\n+    }\n+    // Local and field from enum\n+    {\n+        let mut e = Baz::X(2);\n+        let _e0 = e.x();\n+        match e {\n+            Baz::X(value) => value\n+            //[ast]~^ ERROR cannot use `e.0` because it was mutably borrowed\n+            //[mir]~^^ ERROR cannot use `e.0` because it was mutably borrowed (Ast)\n+            //[mir]~| ERROR cannot use `e.0` because it was mutably borrowed (Mir)\n+        };\n+    }\n+    // Local and field from union\n+    unsafe {\n+        let mut u = U { b: 0 };\n+        let _ra = &mut u.a;\n+        u.a; //[ast]~ ERROR cannot use `u.a` because it was mutably borrowed\n+             //[mir]~^ ERROR cannot use `u.a` because it was mutably borrowed (Ast)\n+             //[mir]~| ERROR cannot use `u.a` because it was mutably borrowed (Mir)\n+    }\n+    // Static and field from struct\n+    unsafe {\n+        let _x = sfoo.x();\n+        sfoo.x; //[mir]~ ERROR cannot use `sfoo.x` because it was mutably borrowed (Mir)\n+    }\n+    // Static and field from tuple-struct\n+    unsafe {\n+        let _0 = sbar.x();\n+        sbar.0; //[mir]~ ERROR cannot use `sbar.0` because it was mutably borrowed (Mir)\n+    }\n+    // Static and field from tuple\n+    unsafe {\n+        let _0 = &mut stuple.0;\n+        stuple.0; //[mir]~ ERROR cannot use `stuple.0` because it was mutably borrowed (Mir)\n+    }\n+    // Static and field from enum\n+    unsafe {\n+        let _e0 = senum.x();\n+        match senum {\n+            Baz::X(value) => value\n+            //[mir]~^ ERROR cannot use `senum.0` because it was mutably borrowed (Mir)\n+        };\n+    }\n+    // Static and field from union\n+    unsafe {\n+        let _ra = &mut sunion.a;\n+        sunion.a; //[mir]~ ERROR cannot use `sunion.a` because it was mutably borrowed (Mir)\n+    }\n+    // Deref and field from struct\n+    {\n+        let mut f = Box::new(Foo { x: 22 });\n+        let _x = f.x();\n+        f.x; //[ast]~ ERROR cannot use `f.x` because it was mutably borrowed\n+             //[mir]~^ ERROR cannot use `f.x` because it was mutably borrowed (Ast)\n+             //[mir]~| ERROR cannot use `f.x` because it was mutably borrowed (Mir)\n+    }\n+    // Deref and field from tuple-struct\n+    {\n+        let mut g = Box::new(Bar(22));\n+        let _0 = g.x();\n+        g.0; //[ast]~ ERROR cannot use `g.0` because it was mutably borrowed\n+             //[mir]~^ ERROR cannot use `g.0` because it was mutably borrowed (Ast)\n+             //[mir]~| ERROR cannot use `g.0` because it was mutably borrowed (Mir)\n+    }\n+    // Deref and field from tuple\n+    {\n+        let mut h = Box::new((22, 23));\n+        let _0 = &mut h.0;\n+        h.0; //[ast]~ ERROR cannot use `h.0` because it was mutably borrowed\n+             //[mir]~^ ERROR cannot use `h.0` because it was mutably borrowed (Ast)\n+             //[mir]~| ERROR cannot use `h.0` because it was mutably borrowed (Mir)\n+    }\n+    // Deref and field from enum\n+    {\n+        let mut e = Box::new(Baz::X(3));\n+        let _e0 = e.x();\n+        match *e {\n+            Baz::X(value) => value\n+            //[ast]~^ ERROR cannot use `e.0` because it was mutably borrowed\n+            //[mir]~^^ ERROR cannot use `e.0` because it was mutably borrowed (Ast)\n+            //[mir]~| ERROR cannot use `e.0` because it was mutably borrowed (Mir)\n+        };\n+    }\n+    // Deref and field from union\n+    unsafe {\n+        let mut u = Box::new(U { b: 0 });\n+        let _ra = &mut u.a;\n+        u.a; //[ast]~ ERROR cannot use `u.a` because it was mutably borrowed\n+             //[mir]~^ ERROR cannot use `u.a` because it was mutably borrowed (Ast)\n+             //[mir]~| ERROR cannot use `u.a` because it was mutably borrowed (Mir)\n+    }\n+    // Constant index\n+    {\n+        let mut v = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+        let _v = &mut v;\n+        match v {\n+            &[x, _, .., _, _] => println!(\"{}\", x),\n+                //[ast]~^ ERROR cannot use `v[..]` because it was mutably borrowed\n+                //[mir]~^^ ERROR cannot use `v[..]` because it was mutably borrowed (Ast)\n+                //[mir]~| ERROR cannot use `v[..]` because it was mutably borrowed (Mir)\n+                            _ => panic!(\"other case\"),\n+        }\n+        match v {\n+            &[_, x, .., _, _] => println!(\"{}\", x),\n+                //[ast]~^ ERROR cannot use `v[..]` because it was mutably borrowed\n+                //[mir]~^^ ERROR cannot use `v[..]` because it was mutably borrowed (Ast)\n+                //[mir]~| ERROR cannot use `v[..]` because it was mutably borrowed (Mir)\n+                            _ => panic!(\"other case\"),\n+        }\n+        match v {\n+            &[_, _, .., x, _] => println!(\"{}\", x),\n+                //[ast]~^ ERROR cannot use `v[..]` because it was mutably borrowed\n+                //[mir]~^^ ERROR cannot use `v[..]` because it was mutably borrowed (Ast)\n+                //[mir]~| ERROR cannot use `v[..]` because it was mutably borrowed (Mir)\n+                            _ => panic!(\"other case\"),\n+        }\n+        match v {\n+            &[_, _, .., _, x] => println!(\"{}\", x),\n+                //[ast]~^ ERROR cannot use `v[..]` because it was mutably borrowed\n+                //[mir]~^^ ERROR cannot use `v[..]` because it was mutably borrowed (Ast)\n+                //[mir]~| ERROR cannot use `v[..]` because it was mutably borrowed (Mir)\n+                            _ => panic!(\"other case\"),\n+        }\n+    }\n+    // Subslices\n+    {\n+        let mut v = &[1, 2, 3, 4, 5];\n+        let _v = &mut v;\n+        match v {\n+            &[x..] => println!(\"{:?}\", x),\n+                //[ast]~^ ERROR cannot use `v[..]` because it was mutably borrowed\n+                //[mir]~^^ ERROR cannot use `v[..]` because it was mutably borrowed (Ast)\n+                //[mir]~| ERROR cannot use `v[..]` because it was mutably borrowed (Mir)\n+            _ => panic!(\"other case\"),\n+        }\n+        match v {\n+            &[_, x..] => println!(\"{:?}\", x),\n+                //[ast]~^ ERROR cannot use `v[..]` because it was mutably borrowed\n+                //[mir]~^^ ERROR cannot use `v[..]` because it was mutably borrowed (Ast)\n+                //[mir]~| ERROR cannot use `v[..]` because it was mutably borrowed (Mir)\n+            _ => panic!(\"other case\"),\n+        }\n+        match v {\n+            &[x.., _] => println!(\"{:?}\", x),\n+                //[ast]~^ ERROR cannot use `v[..]` because it was mutably borrowed\n+                //[mir]~^^ ERROR cannot use `v[..]` because it was mutably borrowed (Ast)\n+                //[mir]~| ERROR cannot use `v[..]` because it was mutably borrowed (Mir)\n+            _ => panic!(\"other case\"),\n+        }\n+        match v {\n+            &[_, x.., _] => println!(\"{:?}\", x),\n+                //[ast]~^ ERROR cannot use `v[..]` because it was mutably borrowed\n+                //[mir]~^^ ERROR cannot use `v[..]` because it was mutably borrowed (Ast)\n+                //[mir]~| ERROR cannot use `v[..]` because it was mutably borrowed (Mir)\n+            _ => panic!(\"other case\"),\n+        }\n+    }\n+    // Downcasted field\n+    {\n+        enum E<X> { A(X), B { x: X } }\n+\n+        let mut e = E::A(3);\n+        let _e = &mut e;\n+        match e {\n+            E::A(ref ax) =>\n+                //[ast]~^ ERROR cannot borrow `e.0` as immutable because `e` is also borrowed as mutable\n+                //[mir]~^^ ERROR cannot borrow `e.0` as immutable because `e` is also borrowed as mutable (Ast)\n+                //[mir]~| ERROR cannot borrow `e.0` as immutable because it is also borrowed as mutable (Mir)\n+                //[mir]~| ERROR cannot use `e` because it was mutably borrowed (Mir)\n+                println!(\"e.ax: {:?}\", ax),\n+            E::B { x: ref bx } =>\n+                //[ast]~^ ERROR cannot borrow `e.x` as immutable because `e` is also borrowed as mutable\n+                //[mir]~^^ ERROR cannot borrow `e.x` as immutable because `e` is also borrowed as mutable (Ast)\n+                //[mir]~| ERROR cannot borrow `e.x` as immutable because it is also borrowed as mutable (Mir)\n+                println!(\"e.bx: {:?}\", bx),\n+        }\n+    }\n+    // Field in field\n+    {\n+        struct F { x: u32, y: u32 };\n+        struct S { x: F, y: (u32, u32), };\n+        let mut s = S { x: F { x: 1, y: 2}, y: (999, 998) };\n+        let _s = &mut s;\n+        match s {\n+            S  { y: (ref y0, _), .. } =>\n+                //[ast]~^ ERROR cannot borrow `s.y.0` as immutable because `s` is also borrowed as mutable\n+                //[mir]~^^ ERROR cannot borrow `s.y.0` as immutable because `s` is also borrowed as mutable (Ast)\n+                //[mir]~| ERROR cannot borrow `s.y.0` as immutable because it is also borrowed as mutable (Mir)\n+                println!(\"y0: {:?}\", y0),\n+            _ => panic!(\"other case\"),\n+        }\n+        match s {\n+            S  { x: F { y: ref x0, .. }, .. } =>\n+                //[ast]~^ ERROR cannot borrow `s.x.y` as immutable because `s` is also borrowed as mutable\n+                //[mir]~^^ ERROR cannot borrow `s.x.y` as immutable because `s` is also borrowed as mutable (Ast)\n+                //[mir]~| ERROR cannot borrow `s.x.y` as immutable because it is also borrowed as mutable (Mir)\n+                println!(\"x0: {:?}\", x0),\n+            _ => panic!(\"other case\"),\n+        }\n+    }\n+    // Field of ref\n+    {\n+        struct Block<'a> {\n+            current: &'a u8,\n+            unrelated: &'a u8,\n+        };\n+\n+        fn bump<'a>(mut block: &mut Block<'a>) {\n+            let x = &mut block;\n+            let p: &'a u8 = &*block.current;\n+            //[mir]~^ ERROR cannot borrow `(*block.current)` as immutable because it is also borrowed as mutable (Mir)\n+            // No errors in AST because of issue rust#38899\n+        }\n+    }\n+    // Field of ptr\n+    {\n+        struct Block2 {\n+            current: *const u8,\n+            unrelated: *const u8,\n+        }\n+\n+        unsafe fn bump2(mut block: *mut Block2) {\n+            let x = &mut block;\n+            let p : *const u8 = &*(*block).current;\n+            //[mir]~^ ERROR cannot borrow `(*block.current)` as immutable because it is also borrowed as mutable (Mir)\n+            // No errors in AST because of issue rust#38899\n+        }\n+    }\n+    // Field of index\n+    {\n+        struct F {x: u32, y: u32};\n+        let mut v = &[F{x: 1, y: 2}, F{x: 3, y: 4}];\n+        let _v = &mut v;\n+        v[0].y;\n+        //[ast]~^ ERROR cannot use `v[..].y` because it was mutably borrowed\n+        //[mir]~^^ ERROR cannot use `v[..].y` because it was mutably borrowed (Ast)\n+        //[mir]~| ERROR cannot use `v[..].y` because it was mutably borrowed (Mir)\n+        //[mir]~| ERROR cannot use `(*v)` because it was mutably borrowed (Mir)\n+    }\n+    // Field of constant index\n+    {\n+        struct F {x: u32, y: u32};\n+        let mut v = &[F{x: 1, y: 2}, F{x: 3, y: 4}];\n+        let _v = &mut v;\n+        match v {\n+            &[_, F {x: ref xf, ..}] => println!(\"{}\", xf),\n+            //[mir]~^ ERROR cannot borrow `v[..].x` as immutable because it is also borrowed as mutable (Mir)\n+            // No errors in AST\n+            _ => panic!(\"other case\")\n+        }\n+    }\n+}"}, {"sha": "017318b6b217300f75d66d24e7a42ea6cdc108dc", "filename": "src/test/compile-fail/borrowck/borrowck-init-in-fru.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-init-in-fru.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-init-in-fru.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-init-in-fru.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n #[derive(Clone)]\n struct point {\n     x: isize,\n@@ -16,6 +19,9 @@ struct point {\n \n fn main() {\n     let mut origin: point;\n-    origin = point {x: 10,.. origin}; //~ ERROR use of possibly uninitialized variable: `origin.y`\n+    origin = point {x: 10,.. origin};\n+    //[ast]~^ ERROR use of possibly uninitialized variable: `origin.y` [E0381]\n+    //[mir]~^^ ERROR (Ast) [E0381]\n+    //[mir]~|  ERROR (Mir) [E0381]\n     origin.clone();\n }"}, {"sha": "1d21f40fccaef50b36a99d8b3c1a0eaceee06c52", "filename": "src/test/compile-fail/borrowck/borrowck-match-already-borrowed.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-match-already-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-match-already-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-match-already-borrowed.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n+fn main() {\n+    let mut x = 1;\n+    let _x = &mut x;\n+    let _ = match x {\n+        x => x + 1, //[ast]~ ERROR E0503\n+                    //[mir]~^ ERROR (Mir) [E0503]\n+                    //[mir]~| ERROR (Ast) [E0503]\n+        y => y + 2, //[ast]~ ERROR [E0503]\n+                    //[mir]~^ ERROR (Mir) [E0503]\n+                    //[mir]~| ERROR (Ast) [E0503]\n+    };\n+}"}, {"sha": "957086f6af13f5d394c82369033b53f89f294c3f", "filename": "src/test/compile-fail/borrowck/borrowck-uninit-field-access.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-uninit-field-access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-uninit-field-access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-uninit-field-access.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n+// Check that do not allow access to fields of uninitialized or moved\n+// structs.\n+\n+#[derive(Default)]\n+struct Point {\n+    x: isize,\n+    y: isize,\n+}\n+\n+#[derive(Default)]\n+struct Line {\n+    origin: Point,\n+    middle: Point,\n+    target: Point,\n+}\n+\n+impl Line { fn consume(self) { } }\n+\n+fn main() {\n+    let mut a: Point;\n+    let _ = a.x + 1; //[ast]~ ERROR use of possibly uninitialized variable: `a.x`\n+                     //[mir]~^ ERROR       [E0381]\n+                     //[mir]~| ERROR (Mir) [E0381]\n+\n+    let mut line1 = Line::default();\n+    let _moved = line1.origin;\n+    let _ = line1.origin.x + 1; //[ast]~ ERROR use of collaterally moved value: `line1.origin.x`\n+                                //[mir]~^       [E0382]\n+                                //[mir]~| (Mir) [E0381]\n+\n+    let mut line2 = Line::default();\n+    let _moved = (line2.origin, line2.middle);\n+    line2.consume(); //[ast]~ ERROR use of partially moved value: `line2` [E0382]\n+                     //[mir]~^       [E0382]\n+                     //[mir]~| (Mir) [E0381]\n+}"}, {"sha": "71f8693b2101f5388acf66a6370ab4baf0e17dfe", "filename": "src/test/compile-fail/borrowck/borrowck-uninit-ref-chain.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-uninit-ref-chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-uninit-ref-chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-uninit-ref-chain.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n+struct S<X, Y> {\n+    x: X,\n+    y: Y,\n+}\n+\n+fn main() {\n+    let x: &&Box<i32>;\n+    let _y = &**x; //[ast]~ ERROR use of possibly uninitialized variable: `**x` [E0381]\n+                   //[mir]~^ (Ast) [E0381]\n+                   //[mir]~| (Mir) [E0381]\n+\n+    let x: &&S<i32, i32>;\n+    let _y = &**x; //[ast]~ ERROR use of possibly uninitialized variable: `**x` [E0381]\n+                   //[mir]~^ (Ast) [E0381]\n+                   //[mir]~| (Mir) [E0381]\n+\n+    let x: &&i32;\n+    let _y = &**x; //[ast]~ ERROR use of possibly uninitialized variable: `**x` [E0381]\n+                   //[mir]~^ (Ast) [E0381]\n+                   //[mir]~| (Mir) [E0381]\n+\n+\n+    let mut a: S<i32, i32>;\n+    a.x = 0;\n+    let _b = &a.x; //[ast]~ ERROR use of possibly uninitialized variable: `a.x` [E0381]\n+                   //[mir]~^ ERROR (Ast) [E0381]\n+                   // (deliberately *not* an error under MIR-borrowck)\n+\n+    let mut a: S<&&i32, &&i32>;\n+    a.x = &&0;\n+    let _b = &**a.x; //[ast]~ ERROR use of possibly uninitialized variable: `**a.x` [E0381]\n+                     //[mir]~^ ERROR (Ast) [E0381]\n+                     // (deliberately *not* an error under MIR-borrowck)\n+\n+\n+    let mut a: S<i32, i32>;\n+    a.x = 0;\n+    let _b = &a.y; //[ast]~ ERROR use of possibly uninitialized variable: `a.y` [E0381]\n+                   //[mir]~^ ERROR (Ast) [E0381]\n+                   //[mir]~| ERROR (Mir) [E0381]\n+\n+    let mut a: S<&&i32, &&i32>;\n+    a.x = &&0;\n+    let _b = &**a.y; //[ast]~ ERROR use of possibly uninitialized variable: `**a.y` [E0381]\n+                     //[mir]~^ ERROR (Ast) [E0381]\n+                     //[mir]~| ERROR (Mir) [E0381]\n+}"}, {"sha": "0655d2914eefa9ece4d20997905ed0f69043d6a5", "filename": "src/test/compile-fail/borrowck/borrowck-union-borrow.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -34,13 +34,13 @@ fn main() {\n             let ra = &u.a;\n             let rma = &mut u.a; //[ast]~ ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable\n                                 //[mir]~^ ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable (Ast)\n-                                //[mir]~| ERROR cannot borrow `u.0` as mutable because it is also borrowed as immutable (Mir)\n+                                //[mir]~| ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable (Mir)\n         }\n         {\n             let ra = &u.a;\n             u.a = 1; //[ast]~ ERROR cannot assign to `u.a` because it is borrowed\n                      //[mir]~^ ERROR cannot assign to `u.a` because it is borrowed (Ast)\n-                     //[mir]~| ERROR cannot assign to `u.0` because it is borrowed (Mir)\n+                     //[mir]~| ERROR cannot assign to `u.a` because it is borrowed (Mir)\n         }\n         // Imm borrow, other field\n         {\n@@ -68,25 +68,25 @@ fn main() {\n             let rma = &mut u.a;\n             let ra = &u.a; //[ast]~ ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable\n                          //[mir]~^ ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable (Ast)\n-                         //[mir]~| ERROR cannot borrow `u.0` as immutable because it is also borrowed as mutable (Mir)\n+                         //[mir]~| ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable (Mir)\n         }\n         {\n             let ra = &mut u.a;\n             let a = u.a; //[ast]~ ERROR cannot use `u.a` because it was mutably borrowed\n                          //[mir]~^ ERROR cannot use `u.a` because it was mutably borrowed (Ast)\n-                         //[mir]~| ERROR cannot use `u.0` because it was mutably borrowed (Mir)\n+                         //[mir]~| ERROR cannot use `u.a` because it was mutably borrowed (Mir)\n         }\n         {\n             let rma = &mut u.a;\n             let rma2 = &mut u.a; //[ast]~ ERROR cannot borrow `u.a` as mutable more than once at a time\n                                  //[mir]~^ ERROR cannot borrow `u.a` as mutable more than once at a time (Ast)\n-                                 //[mir]~| ERROR cannot borrow `u.0` as mutable more than once at a time (Mir)\n+                                 //[mir]~| ERROR cannot borrow `u.a` as mutable more than once at a time (Mir)\n         }\n         {\n             let rma = &mut u.a;\n             u.a = 1; //[ast]~ ERROR cannot assign to `u.a` because it is borrowed\n                      //[mir]~^ ERROR cannot assign to `u.a` because it is borrowed (Ast)\n-                     //[mir]~| ERROR cannot assign to `u.0` because it is borrowed (Mir)\n+                     //[mir]~| ERROR cannot assign to `u.a` because it is borrowed (Mir)\n         }\n         // Mut borrow, other field\n         {"}, {"sha": "2b567ebd2dba5582b6de0aa69eb76d30f39be0f2", "filename": "src/test/compile-fail/borrowck/borrowck-use-in-index-lvalue.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-use-in-index-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-use-in-index-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-use-in-index-lvalue.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -8,12 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n fn test() {\n     let w: &mut [isize];\n-    w[5] = 0; //~ ERROR use of possibly uninitialized variable: `*w`\n+    w[5] = 0; //[ast]~ ERROR use of possibly uninitialized variable: `*w` [E0381]\n+              //[mir]~^ ERROR (Ast) [E0381]\n+              //[mir]~| ERROR (Mir) [E0381]\n \n     let mut w: &mut [isize];\n-    w[5] = 0; //~ ERROR use of possibly uninitialized variable: `*w`\n+    w[5] = 0; //[ast]~ ERROR use of possibly uninitialized variable: `*w` [E0381]\n+              //[mir]~^ ERROR (Ast) [E0381]\n+              //[mir]~| ERROR (Mir) [E0381]\n }\n \n fn main() { test(); }"}, {"sha": "a48d09b195a5e89827b5d70352d290b3eaeab5f4", "filename": "src/test/compile-fail/borrowck/borrowck-use-uninitialized-in-cast-trait.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-use-uninitialized-in-cast-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-use-uninitialized-in-cast-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-use-uninitialized-in-cast-trait.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n // Variation on `borrowck-use-uninitialized-in-cast` in which we do a\n // trait cast from an uninitialized source. Issue #20791.\n \n@@ -16,5 +19,7 @@ impl Foo for i32 { }\n \n fn main() {\n     let x: &i32;\n-    let y = x as *const Foo; //~ ERROR use of possibly uninitialized variable: `*x`\n+    let y = x as *const Foo; //[ast]~ ERROR use of possibly uninitialized variable: `*x`\n+                             //[mir]~^ ERROR (Ast) [E0381]\n+                             //[mir]~| ERROR (Mir) [E0381]\n }"}, {"sha": "bdd90a3ce1ec2394dc7cbcdae50949d434b43c19", "filename": "src/test/compile-fail/borrowck/borrowck-use-uninitialized-in-cast.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-use-uninitialized-in-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-use-uninitialized-in-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-use-uninitialized-in-cast.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -8,11 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n // Check that we detect unused values that are cast to other things.\n // The problem was specified to casting to `*`, as creating unsafe\n // pointers was not being fully checked. Issue #20791.\n \n fn main() {\n     let x: &i32;\n-    let y = x as *const i32; //~ ERROR use of possibly uninitialized variable: `*x`\n+    let y = x as *const i32; //[ast]~ ERROR use of possibly uninitialized variable: `*x` [E0381]\n+                             //[mir]~^ ERROR (Ast) [E0381]\n+                             //[mir]~| ERROR (Mir) [E0381]\n }"}, {"sha": "a7cfda504c75382a20ada7c28d518915990066ed", "filename": "src/test/compile-fail/dyn-trait-compatibility.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fdyn-trait-compatibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fdyn-trait-compatibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdyn-trait-compatibility.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+type A0 = dyn;\n+//~^ ERROR cannot find type `dyn` in this scope\n+type A1 = dyn::dyn;\n+//~^ ERROR Use of undeclared type or module `dyn`\n+type A2 = dyn<dyn, dyn>;\n+//~^ ERROR cannot find type `dyn` in this scope\n+//~| ERROR cannot find type `dyn` in this scope\n+//~| ERROR cannot find type `dyn` in this scope\n+type A3 = dyn<<dyn as dyn>::dyn>;\n+//~^ ERROR cannot find type `dyn` in this scope\n+//~| ERROR cannot find type `dyn` in this scope\n+//~| ERROR Use of undeclared type or module `dyn`\n+type A4 = dyn(dyn, dyn) -> dyn;\n+//~^ ERROR cannot find type `dyn` in this scope\n+//~| ERROR cannot find type `dyn` in this scope\n+//~| ERROR cannot find type `dyn` in this scope\n+//~| ERROR cannot find type `dyn` in this scope\n+\n+fn main() {}"}, {"sha": "4b3803d019baa043e0a2038616ac4cffbd95f341", "filename": "src/test/compile-fail/feature-gate-dyn-trait.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Ffeature-gate-dyn-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Ffeature-gate-dyn-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-dyn-trait.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Trait {}\n+type A = Box<dyn Trait>; //~ ERROR `dyn Trait` syntax is unstable\n+\n+fn main() {}"}, {"sha": "cdba559445d195be1a4636a496ed0b57fa8467b0", "filename": "src/test/compile-fail/hygiene/impl_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fimpl_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fimpl_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhygiene%2Fimpl_items.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -19,7 +19,7 @@ mod foo {\n     }\n \n     pub macro m() {\n-        let _: () = S.f(); //~ ERROR type `fn(&foo::S) {foo::S::f}` is private\n+        let _: () = S.f(); //~ ERROR type `for<'r> fn(&'r foo::S) {foo::S::f}` is private\n     }\n }\n "}, {"sha": "2d37fc79250357f9d1b0deab53e123c48103c5c3", "filename": "src/test/compile-fail/index-help.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Findex-help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Findex-help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Findex-help.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let x = vec![1];\n+    x[0i32]; //~ ERROR E0277\n+             //~| NOTE vector indices are of type `usize` or ranges of `usize`\n+}"}, {"sha": "85d91bb2db202dd6dcb1681cb4ed1e1ef8fe4505", "filename": "src/test/compile-fail/issue-12997-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fissue-12997-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fissue-12997-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12997-2.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -15,6 +15,6 @@\n #[bench]\n fn bar(x: isize) { }\n //~^ ERROR mismatched types\n-//~| expected type `fn(&mut __test::test::Bencher)`\n+//~| expected type `for<'r> fn(&'r mut __test::test::Bencher)`\n //~| found type `fn(isize) {bar}`\n //~| expected mutable reference, found isize"}, {"sha": "c0ba38b240202ece9a41e16605b858f6cd9ef7f1", "filename": "src/test/compile-fail/private-inferred-type-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type-3.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -15,7 +15,7 @@\n // error-pattern:type `fn() {<u8 as ext::PrivTrait>::method}` is private\n // error-pattern:type `fn(u8) -> ext::PrivTupleStruct {ext::PrivTupleStruct::{{constructor}}}` is pr\n // error-pattern:type `fn(u8) -> ext::PubTupleStruct {ext::PubTupleStruct::{{constructor}}}` is priv\n-// error-pattern:type `fn(&ext::Pub<u8>) {<ext::Pub<u8>>::priv_method}` is private\n+// error-pattern:type `for<'r> fn(&'r ext::Pub<u8>) {<ext::Pub<u8>>::priv_method}` is private\n \n #![feature(decl_macro)]\n "}, {"sha": "95e3732d6134278e980b0b2f44c45fea2af88e14", "filename": "src/test/compile-fail/private-inferred-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -56,7 +56,7 @@ mod m {\n         PubTupleStruct;\n         //~^ ERROR type `fn(u8) -> m::PubTupleStruct {m::PubTupleStruct::{{constructor}}}` is privat\n         Pub(0u8).priv_method();\n-        //~^ ERROR type `fn(&m::Pub<u8>) {<m::Pub<u8>>::priv_method}` is private\n+        //~^ ERROR type `for<'r> fn(&'r m::Pub<u8>) {<m::Pub<u8>>::priv_method}` is private\n     }\n \n     trait Trait {}"}, {"sha": "6be65a5e35905194fe710c4d12a16d0f238aa32c", "filename": "src/test/compile-fail/regions-fn-subtyping-return-static.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping-return-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping-return-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping-return-static.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -58,8 +58,8 @@ fn supply_G() {\n     want_G(bar);\n     want_G(baz);\n     //~^ ERROR mismatched types\n-    //~| expected type `fn(&'cx S) -> &'static S`\n-    //~| found type `fn(&S) -> &S {baz}`\n+    //~| expected type `for<'cx> fn(&'cx S) -> &'static S`\n+    //~| found type `for<'r> fn(&'r S) -> &'r S {baz}`\n     //~| expected concrete lifetime, found bound lifetime parameter 'cx\n }\n "}, {"sha": "6cd439167314bd9ba4f684f4538b26b1bb8b45b5", "filename": "src/test/compile-fail/trait-bounds-not-on-struct.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-struct.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -8,9 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(dyn_trait)]\n \n struct Foo;\n \n fn foo(_x: Box<Foo + Send>) { } //~ ERROR expected trait, found struct `Foo`\n \n+type A<T> = Box<dyn Vec<T>>; //~ ERROR expected trait, found struct `Vec`\n+\n fn main() { }"}, {"sha": "2a28c895b797e2c1eab38159b0133d45c5cce8b7", "filename": "src/test/debuginfo/pretty-std.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -44,6 +44,10 @@\n // gdb-command: print some_string\n // gdb-check:$8 = Some = {\"IAMA optional string!\"}\n \n+// gdb-command: set print length 5\n+// gdb-command: print some_string\n+// gdb-check:$8 = Some = {\"IAMA \"...}\n+\n \n // === LLDB TESTS ==================================================================================\n "}, {"sha": "0090c2aeef9369f57463a1933f8ea04e71c087e8", "filename": "src/test/incremental/hashes/call_expressions.rs", "status": "modified", "additions": 18, "deletions": 32, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fincremental%2Fhashes%2Fcall_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fincremental%2Fhashes%2Fcall_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fcall_expressions.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -36,10 +36,8 @@ pub fn change_callee_function() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirValidated,MirOptimized,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_callee_function() {\n@@ -55,10 +53,8 @@ pub fn change_argument_function() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirValidated,MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_argument_function() {\n@@ -100,10 +96,8 @@ pub fn change_callee_method() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirValidated,MirOptimized,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_callee_method() {\n@@ -121,10 +115,8 @@ pub fn change_argument_method() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirValidated,MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_argument_method() {\n@@ -142,10 +134,8 @@ pub fn change_ufcs_callee_method() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirValidated,MirOptimized,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_ufcs_callee_method() {\n@@ -163,10 +153,8 @@ pub fn change_argument_method_ufcs() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirValidated,MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn change_argument_method_ufcs() {\n@@ -184,12 +172,12 @@ pub fn change_to_ufcs() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirValidated,MirOptimized,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n+// One might think this would be expanded in the HirBody/Mir, but it actually\n+// results in slightly different Hir/Mir.\n pub fn change_to_ufcs() {\n     let s = Struct;\n     Struct::method1(&s, 'x', true);\n@@ -208,10 +196,8 @@ mod change_ufcs_callee_indirectly {\n     #[cfg(not(cfail1))]\n     use super::Struct2 as Struct;\n \n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirValidated,MirOptimized,TypeckTables\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn change_ufcs_callee_indirectly() {"}, {"sha": "35641e978b7fdf7a76d65cd008f8639d1ec624a1", "filename": "src/test/incremental/hashes/consts.rs", "status": "modified", "additions": 18, "deletions": 27, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fincremental%2Fhashes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fincremental%2Fhashes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fconsts.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -30,8 +30,8 @@\n const CONST_VISIBILITY: u8 = 0;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub const CONST_VISIBILITY: u8 = 0;\n@@ -42,8 +42,8 @@ pub const CONST_VISIBILITY: u8 = 0;\n const CONST_CHANGE_TYPE_1: i32 = 0;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,TypeOfItem\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n const CONST_CHANGE_TYPE_1: u32 = 0;\n@@ -54,8 +54,8 @@ const CONST_CHANGE_TYPE_1: u32 = 0;\n const CONST_CHANGE_TYPE_2: Option<u32> = None;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,TypeOfItem\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n const CONST_CHANGE_TYPE_2: Option<u64> = None;\n@@ -66,11 +66,8 @@ const CONST_CHANGE_TYPE_2: Option<u64> = None;\n const CONST_CHANGE_VALUE_1: i16 = 1;\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n const CONST_CHANGE_VALUE_1: i16 = 2;\n \n@@ -80,10 +77,8 @@ const CONST_CHANGE_VALUE_1: i16 = 2;\n const CONST_CHANGE_VALUE_2: i16 = 1 + 1;\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n const CONST_CHANGE_VALUE_2: i16 = 1 + 2;\n@@ -93,10 +88,8 @@ const CONST_CHANGE_VALUE_2: i16 = 1 + 2;\n const CONST_CHANGE_VALUE_3: i16 = 2 + 3;\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n const CONST_CHANGE_VALUE_3: i16 = 2 * 3;\n@@ -106,10 +99,8 @@ const CONST_CHANGE_VALUE_3: i16 = 2 * 3;\n const CONST_CHANGE_VALUE_4: i16 = 1 + 2 * 3;\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n const CONST_CHANGE_VALUE_4: i16 = 1 + 2 * 4;\n@@ -126,14 +117,14 @@ mod const_change_type_indirectly {\n     #[cfg(not(cfail1))]\n     use super::ReferencedType2 as Type;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,TypeOfItem\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     const CONST_CHANGE_TYPE_INDIRECTLY_1: Type = Type;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,TypeOfItem\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     const CONST_CHANGE_TYPE_INDIRECTLY_2: Option<Type> = None;"}, {"sha": "f826d47c3e53f003f6a41ccfc6258abc8c9b6ef4", "filename": "src/test/incremental/hashes/enum_constructors.rs", "status": "modified", "additions": 50, "deletions": 61, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fincremental%2Fhashes%2Fenum_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fincremental%2Fhashes%2Fenum_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fenum_constructors.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -45,10 +45,8 @@ fn change_field_value_struct_like() -> Enum {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirValidated\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_field_value_struct_like() -> Enum {\n@@ -72,12 +70,12 @@ fn change_field_order_struct_like() -> Enum {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n+// FIXME(michaelwoerister):Interesting. I would have thought that that changes the MIR. And it\n+// would if it were not all constants\n fn change_field_order_struct_like() -> Enum {\n     Enum::Struct {\n         y: 4,\n@@ -113,10 +111,8 @@ fn change_constructor_path_struct_like() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirValidated,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_constructor_path_struct_like() {\n@@ -140,10 +136,8 @@ fn change_constructor_variant_struct_like() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirValidated\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_constructor_variant_struct_like() {\n@@ -162,10 +156,12 @@ mod change_constructor_path_indirectly_struct_like {\n     #[cfg(not(cfail1))]\n     use super::Enum2 as TheEnum;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_clean(\n+        cfg=\"cfail2\",\n+        except=\"FnSignature,Hir,HirBody,MirOptimized,MirValidated,\\\n+                TypeckTables\"\n+    )]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn function() -> TheEnum {\n@@ -186,10 +182,8 @@ mod change_constructor_variant_indirectly_struct_like {\n     #[cfg(not(cfail1))]\n     use super::Enum2::Struct2 as Variant;\n \n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirValidated\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn function() -> Enum2 {\n@@ -209,10 +203,8 @@ fn change_field_value_tuple_like() -> Enum {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirValidated\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_field_value_tuple_like() -> Enum {\n@@ -228,10 +220,11 @@ fn change_constructor_path_tuple_like() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(\n+    cfg=\"cfail2\",\n+    except=\"HirBody,MirOptimized,MirValidated,TypeckTables\"\n+)]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_constructor_path_tuple_like() {\n@@ -247,10 +240,11 @@ fn change_constructor_variant_tuple_like() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(\n+    cfg=\"cfail2\",\n+    except=\"HirBody,MirOptimized,MirValidated,TypeckTables\"\n+)]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_constructor_variant_tuple_like() {\n@@ -265,10 +259,12 @@ mod change_constructor_path_indirectly_tuple_like {\n     #[cfg(not(cfail1))]\n     use super::Enum2 as TheEnum;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_clean(\n+        cfg=\"cfail2\",\n+        except=\"FnSignature,Hir,HirBody,MirOptimized,MirValidated,\\\n+                TypeckTables\"\n+    )]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn function() -> TheEnum {\n@@ -286,10 +282,8 @@ mod change_constructor_variant_indirectly_tuple_like {\n     #[cfg(not(cfail1))]\n     use super::Enum2::Tuple2 as Variant;\n \n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirValidated,TypeckTables\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn function() -> Enum2 {\n@@ -317,11 +311,8 @@ fn change_constructor_path_c_like() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirValidated,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_constructor_path_c_like() {\n     let _ = Clike2::B;\n@@ -336,10 +327,8 @@ fn change_constructor_variant_c_like() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirValidated\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_constructor_variant_c_like() {\n@@ -354,10 +343,12 @@ mod change_constructor_path_indirectly_c_like {\n     #[cfg(not(cfail1))]\n     use super::Clike2 as TheEnum;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_clean(\n+        cfg=\"cfail2\",\n+        except=\"FnSignature,Hir,HirBody,MirOptimized,MirValidated,\\\n+                TypeckTables\"\n+    )]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn function() -> TheEnum {\n@@ -375,10 +366,8 @@ mod change_constructor_variant_indirectly_c_like {\n     #[cfg(not(cfail1))]\n     use super::Clike::B as Variant;\n \n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirValidated\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn function() -> Clike {"}, {"sha": "22393fad3d074d223ec5b1274b4655f8c685f5ba", "filename": "src/test/incremental/hashes/enum_defs.rs", "status": "modified", "additions": 74, "deletions": 88, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -37,8 +37,8 @@\n enum EnumVisibility { A }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub enum EnumVisibility {\n@@ -57,8 +57,8 @@ enum EnumChangeNameCStyleVariant {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,TypeOfItem\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumChangeNameCStyleVariant {\n@@ -79,8 +79,8 @@ enum EnumChangeNameTupleStyleVariant {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,TypeOfItem\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumChangeNameTupleStyleVariant {\n@@ -98,8 +98,8 @@ enum EnumChangeNameStructStyleVariant {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,TypeOfItem\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumChangeNameStructStyleVariant {\n@@ -117,10 +117,8 @@ enum EnumChangeValueCStyleVariant0 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumChangeValueCStyleVariant0 {\n@@ -141,10 +139,8 @@ enum EnumChangeValueCStyleVariant1 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,TypeOfItem\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumChangeValueCStyleVariant1 {\n@@ -161,8 +157,8 @@ enum EnumAddCStyleVariant {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,TypeOfItem\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumAddCStyleVariant {\n@@ -180,8 +176,8 @@ enum EnumRemoveCStyleVariant {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,TypeOfItem\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumRemoveCStyleVariant {\n@@ -197,8 +193,8 @@ enum EnumAddTupleStyleVariant {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,TypeOfItem\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumAddTupleStyleVariant {\n@@ -216,8 +212,8 @@ enum EnumRemoveTupleStyleVariant {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,TypeOfItem\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumRemoveTupleStyleVariant {\n@@ -233,8 +229,8 @@ enum EnumAddStructStyleVariant {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,TypeOfItem\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumAddStructStyleVariant {\n@@ -252,8 +248,8 @@ enum EnumRemoveStructStyleVariant {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,TypeOfItem\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumRemoveStructStyleVariant {\n@@ -269,8 +265,8 @@ enum EnumChangeFieldTypeTupleStyleVariant {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumChangeFieldTypeTupleStyleVariant {\n@@ -290,8 +286,8 @@ enum EnumChangeFieldTypeStructStyleVariant {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumChangeFieldTypeStructStyleVariant {\n@@ -313,8 +309,8 @@ enum EnumChangeFieldNameStructStyleVariant {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,TypeOfItem\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumChangeFieldNameStructStyleVariant {\n@@ -330,8 +326,8 @@ enum EnumChangeOrderTupleStyleVariant {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumChangeOrderTupleStyleVariant {\n@@ -353,8 +349,8 @@ enum EnumChangeFieldOrderStructStyleVariant {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,TypeOfItem\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumChangeFieldOrderStructStyleVariant {\n@@ -370,8 +366,8 @@ enum EnumAddFieldTupleStyleVariant {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,TypeOfItem\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumAddFieldTupleStyleVariant {\n@@ -387,8 +383,8 @@ enum EnumAddFieldStructStyleVariant {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,TypeOfItem\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumAddFieldStructStyleVariant {\n@@ -405,8 +401,8 @@ enum EnumAddMustUse {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n #[must_use]\n@@ -425,8 +421,8 @@ enum EnumAddReprC {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,TypeOfItem\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n #[repr(C)]\n@@ -444,11 +440,10 @@ enum EnumChangeNameOfTypeParameter<S> {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n-#[repr(C)]\n enum EnumChangeNameOfTypeParameter<T> {\n     Variant1(T),\n }\n@@ -463,11 +458,10 @@ enum EnumAddTypeParameter<S> {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n-#[repr(C)]\n enum EnumAddTypeParameter<S, T> {\n     Variant1(S),\n     Variant2(T),\n@@ -482,11 +476,10 @@ enum EnumChangeNameOfLifetimeParameter<'a> {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(cfg=\"cfail2\", except=\"PredicatesOfItem\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n-#[repr(C)]\n enum EnumChangeNameOfLifetimeParameter<'b> {\n     Variant1(&'b u32),\n }\n@@ -501,11 +494,10 @@ enum EnumAddLifetimeParameter<'a> {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(cfg=\"cfail2\", except=\"PredicatesOfItem\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n-#[repr(C)]\n enum EnumAddLifetimeParameter<'a, 'b> {\n     Variant1(&'a u32),\n     Variant2(&'b u32),\n@@ -521,11 +513,10 @@ enum EnumAddLifetimeParameterBound<'a, 'b> {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(cfg=\"cfail2\", except=\"GenericsOfItem,TypeOfItem\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n-#[repr(C)]\n enum EnumAddLifetimeParameterBound<'a, 'b: 'a> {\n     Variant1(&'a u32),\n     Variant2(&'b u32),\n@@ -539,11 +530,10 @@ enum EnumAddLifetimeBoundToParameter<'a, T> {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(cfg=\"cfail2\", except=\"TypeOfItem\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n-#[repr(C)]\n enum EnumAddLifetimeBoundToParameter<'a, T: 'a> {\n     Variant1(T),\n     Variant2(&'a u32),\n@@ -558,11 +548,10 @@ enum EnumAddTraitBound<S> {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n-#[repr(C)]\n enum EnumAddTraitBound<T: Sync> {\n     Variant1(T),\n }\n@@ -577,11 +566,10 @@ enum EnumAddLifetimeParameterBoundWhere<'a, 'b> {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(cfg=\"cfail2\", except=\"GenericsOfItem,TypeOfItem\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n-#[repr(C)]\n enum EnumAddLifetimeParameterBoundWhere<'a, 'b> where 'b: 'a {\n     Variant1(&'a u32),\n     Variant2(&'b u32),\n@@ -597,11 +585,10 @@ enum EnumAddLifetimeBoundToParameterWhere<'a, T> {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(cfg=\"cfail2\", except=\"TypeOfItem\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n-#[repr(C)]\n enum EnumAddLifetimeBoundToParameterWhere<'a, T> where T: 'a {\n     Variant1(T),\n     Variant2(&'a u32),\n@@ -616,11 +603,10 @@ enum EnumAddTraitBoundWhere<S> {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n-#[repr(C)]\n enum EnumAddTraitBoundWhere<T> where T: Sync {\n     Variant1(T),\n }\n@@ -635,8 +621,8 @@ enum EnumSwapUsageTypeParameters<A, B> {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumSwapUsageTypeParameters<A, B> {\n@@ -666,8 +652,8 @@ enum EnumSwapUsageLifetimeParameters<'a, 'b> {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumSwapUsageLifetimeParameters<'a, 'b> {\n@@ -701,8 +687,8 @@ mod change_field_type_indirectly_tuple_style {\n     #[cfg(not(cfail1))]\n     use super::ReferencedType2 as FieldType;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     enum TupleStyle {\n@@ -725,8 +711,8 @@ mod change_field_type_indirectly_struct_style {\n     #[cfg(not(cfail1))]\n     use super::ReferencedType2 as FieldType;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     enum StructStyle {\n@@ -754,8 +740,8 @@ mod change_trait_bound_indirectly {\n     #[cfg(not(cfail1))]\n     use super::ReferencedTrait2 as Trait;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,PredicatesOfItem\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     enum Enum<T: Trait> {\n@@ -772,8 +758,8 @@ mod change_trait_bound_indirectly_where {\n     #[cfg(not(cfail1))]\n     use super::ReferencedTrait2 as Trait;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,PredicatesOfItem\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     enum Enum<T> where T: Trait {"}, {"sha": "ec5e088088c9b7b7b23aed7a6a26fa362ce931da", "filename": "src/test/incremental/hashes/extern_mods.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fincremental%2Fhashes%2Fextern_mods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fincremental%2Fhashes%2Fextern_mods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fextern_mods.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -34,8 +34,8 @@ extern {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n extern {\n@@ -51,8 +51,8 @@ extern {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n extern {\n@@ -70,8 +70,8 @@ extern {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n extern {\n@@ -89,8 +89,8 @@ extern {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n extern {\n@@ -108,8 +108,8 @@ extern {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n extern {\n@@ -127,8 +127,8 @@ extern {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n extern {\n@@ -146,8 +146,8 @@ extern {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n extern {\n@@ -165,8 +165,8 @@ extern \"C\" {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n extern \"rust-call\" {\n@@ -184,8 +184,8 @@ extern {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n extern {\n@@ -203,8 +203,8 @@ extern {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n extern {\n@@ -222,8 +222,8 @@ extern {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n #[link_args = \"-foo -bar -baz\"]\n@@ -241,8 +241,8 @@ extern {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n #[link(name = \"bar\")]\n@@ -260,8 +260,8 @@ mod indirectly_change_parameter_type {\n     #[cfg(not(cfail1))]\n     use super::c_i64 as c_int;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_dirty(cfg=\"cfail2\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     extern {\n@@ -280,8 +280,8 @@ mod indirectly_change_return_type {\n     #[cfg(not(cfail1))]\n     use super::c_i64 as c_int;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_dirty(cfg=\"cfail2\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     extern {"}, {"sha": "5067b571ee68b320706553569466ebce866fad67", "filename": "src/test/incremental/hashes/inherent_impls.rs", "status": "modified", "additions": 122, "deletions": 108, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -34,12 +34,12 @@ impl Foo {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,AssociatedItemDefIds\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn method_name2() { }\n }\n@@ -53,15 +53,13 @@ impl Foo {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirValidated,TypeckTables\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn method_body() {\n@@ -80,15 +78,13 @@ impl Foo {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirValidated,TypeckTables\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     #[inline]\n@@ -105,13 +101,13 @@ impl Foo {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"AssociatedItems,Hir,HirBody\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn method_privacy() { }\n@@ -124,13 +120,13 @@ impl Foo {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_dirty(cfg=\"cfail2\", except=\"TypeOfItem,PredicatesOfItem\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn method_selfness(&self) { }\n@@ -143,13 +139,16 @@ impl Foo {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(\n+        cfg=\"cfail2\",\n+        except=\"Hir,HirBody,FnSignature,TypeckTables,MirOptimized,MirValidated\"\n+    )]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn method_selfmutness(&mut self) { }\n@@ -164,18 +163,18 @@ impl Foo {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,AssociatedItemDefIds\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn add_method_to_impl1(&self) { }\n \n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn add_method_to_impl2(&self) { }\n }\n@@ -189,13 +188,16 @@ impl Foo {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(\n+        cfg=\"cfail2\",\n+        except=\"Hir,HirBody,FnSignature,TypeckTables,MirOptimized,MirValidated\"\n+    )]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn add_method_parameter(&self, _: i32) { }\n@@ -210,15 +212,13 @@ impl Foo {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirValidated\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn change_method_parameter_name(&self, b: i64) { }\n@@ -233,13 +233,15 @@ impl Foo {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(\n+        cfg=\"cfail2\",\n+        except=\"Hir,HirBody,FnSignature,MirOptimized,MirValidated,TypeckTables\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn change_method_return_type(&self) -> u8 { 0 }\n@@ -254,13 +256,13 @@ impl Foo {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     #[inline]\n@@ -276,15 +278,13 @@ impl Foo {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirValidated\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn change_method_parameter_order(&self, b: i64, a: i64) { }\n@@ -299,13 +299,16 @@ impl Foo {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(\n+        cfg=\"cfail2\",\n+        except=\"Hir,HirBody,FnSignature,TypeckTables,MirOptimized,MirValidated\"\n+    )]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub unsafe fn make_method_unsafe(&self) { }\n@@ -320,13 +323,13 @@ impl Foo {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,FnSignature,TypeckTables\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub extern fn make_method_extern(&self) { }\n@@ -341,13 +344,13 @@ impl Foo {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,FnSignature,TypeckTables\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub extern \"system\" fn change_method_calling_convention(&self) { }\n@@ -362,13 +365,15 @@ impl Foo {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    // FIXME(michaelwoerister): This is curious but an unused lifetime parameter doesn't seem to\n+    // show up in any of the derived data structures.\n+    #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn add_lifetime_parameter_to_method<'a>(&self) { }\n@@ -383,13 +388,16 @@ impl Foo {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(\n+        cfg=\"cfail2\",\n+        except=\"Hir,HirBody,GenericsOfItem,PredicatesOfItem,TypeOfItem\",\n+    )]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn add_type_parameter_to_method<T>(&self) { }\n@@ -404,13 +412,16 @@ impl Foo {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(\n+        cfg=\"cfail2\",\n+        except=\"Hir,HirBody,GenericsOfItem,PredicatesOfItem,TypeOfItem,TypeckTables\"\n+    )]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn add_lifetime_bound_to_lifetime_param_of_method<'a, 'b: 'a>(&self) { }\n@@ -425,13 +436,13 @@ impl Foo {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,GenericsOfItem,PredicatesOfItem,TypeOfItem\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn add_lifetime_bound_to_type_param_of_method<'a, T: 'a>(&self) { }\n@@ -446,13 +457,13 @@ impl Foo {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,PredicatesOfItem\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn add_trait_bound_to_type_param_of_method<T: Clone>(&self) { }\n@@ -467,13 +478,13 @@ impl Foo {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     #[no_mangle]\n@@ -491,13 +502,16 @@ impl Bar<u32> {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,GenericsOfItem\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl<T> Bar<T> {\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(\n+        cfg=\"cfail2\",\n+        except=\"GenericsOfItem,FnSignature,TypeckTables,TypeOfItem,MirOptimized,MirValidated\"\n+    )]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn add_type_parameter_to_impl(&self) { }\n@@ -512,13 +526,13 @@ impl Bar<u32> {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Bar<u64> {\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"FnSignature,MirOptimized,MirValidated,TypeckTables\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn change_impl_self_type(&self) { }\n@@ -533,13 +547,13 @@ impl<T> Bar<T> {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl<T: 'static> Bar<T> {\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn add_lifetime_bound_to_impl_parameter(&self) { }\n@@ -554,13 +568,13 @@ impl<T> Bar<T> {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl<T: Clone> Bar<T> {\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn add_trait_bound_to_impl_parameter(&self) { }"}, {"sha": "d46fbd367607c72e535f3225e1bda6f7014c12eb", "filename": "src/test/incremental/hashes/let_expressions.rs", "status": "modified", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -38,6 +38,20 @@ pub fn change_name() {\n #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"MirValidated\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"MirValidated\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"MirOptimized\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"MirOptimized\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"TypeckTables\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"TypeOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"TypeOfItem\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"GenericsOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"GenericsOfItem\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"FnSignature\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"FnSignature\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"PredicatesOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"PredicatesOfItem\", cfg=\"cfail3\")]\n pub fn change_name() {\n     let _y = 2u64;\n }\n@@ -57,6 +71,20 @@ pub fn add_type() {\n #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[rustc_clean(label=\"MirValidated\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"MirValidated\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"MirOptimized\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"MirOptimized\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"TypeckTables\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"TypeckTables\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"TypeOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"TypeOfItem\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"GenericsOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"GenericsOfItem\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"FnSignature\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"FnSignature\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"PredicatesOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"PredicatesOfItem\", cfg=\"cfail3\")]\n pub fn add_type() {\n     let _x: u32 = 2u32;\n }\n@@ -76,6 +104,20 @@ pub fn change_type() {\n #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"MirValidated\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"MirValidated\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"MirOptimized\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"MirOptimized\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"TypeckTables\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"TypeckTables\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"TypeOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"TypeOfItem\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"GenericsOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"GenericsOfItem\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"FnSignature\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"FnSignature\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"PredicatesOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"PredicatesOfItem\", cfg=\"cfail3\")]\n pub fn change_type() {\n     let _x: u8 = 2;\n }\n@@ -95,6 +137,20 @@ pub fn change_mutability_of_reference_type() {\n #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"MirValidated\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"MirValidated\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"MirOptimized\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"MirOptimized\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"TypeckTables\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"TypeckTables\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"TypeOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"TypeOfItem\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"GenericsOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"GenericsOfItem\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"FnSignature\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"FnSignature\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"PredicatesOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"PredicatesOfItem\", cfg=\"cfail3\")]\n pub fn change_mutability_of_reference_type() {\n     let _x: &mut u64;\n }\n@@ -114,6 +170,20 @@ pub fn change_mutability_of_slot() {\n #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"MirValidated\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"MirValidated\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"MirOptimized\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"MirOptimized\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"TypeckTables\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"TypeckTables\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"TypeOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"TypeOfItem\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"GenericsOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"GenericsOfItem\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"FnSignature\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"FnSignature\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"PredicatesOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"PredicatesOfItem\", cfg=\"cfail3\")]\n pub fn change_mutability_of_slot() {\n     let _x: u64 = 0;\n }\n@@ -133,6 +203,20 @@ pub fn change_simple_binding_to_pattern() {\n #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"MirValidated\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"MirValidated\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"MirOptimized\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"MirOptimized\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"TypeckTables\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"TypeckTables\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"TypeOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"TypeOfItem\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"GenericsOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"GenericsOfItem\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"FnSignature\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"FnSignature\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"PredicatesOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"PredicatesOfItem\", cfg=\"cfail3\")]\n pub fn change_simple_binding_to_pattern() {\n     let (_a, _b) = (0u8, 'x');\n }\n@@ -152,6 +236,20 @@ pub fn change_name_in_pattern() {\n #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"MirValidated\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"MirValidated\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"MirOptimized\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"MirOptimized\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"TypeckTables\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"TypeOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"TypeOfItem\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"GenericsOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"GenericsOfItem\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"FnSignature\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"FnSignature\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"PredicatesOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"PredicatesOfItem\", cfg=\"cfail3\")]\n pub fn change_name_in_pattern() {\n     let (_a, _c) = (1u8, 'y');\n }\n@@ -171,6 +269,20 @@ pub fn add_ref_in_pattern() {\n #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"MirValidated\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"MirValidated\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"MirOptimized\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"MirOptimized\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"TypeckTables\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"TypeckTables\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"TypeOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"TypeOfItem\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"GenericsOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"GenericsOfItem\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"FnSignature\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"FnSignature\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"PredicatesOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"PredicatesOfItem\", cfg=\"cfail3\")]\n pub fn add_ref_in_pattern() {\n     let (ref _a, _b) = (1u8, 'y');\n }\n@@ -190,6 +302,12 @@ pub fn add_amp_in_pattern() {\n #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"MirValidated\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"MirValidated\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"MirOptimized\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"MirOptimized\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"TypeckTables\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"TypeckTables\", cfg=\"cfail3\")]\n pub fn add_amp_in_pattern() {\n     let (&_a, _b) = (&1u8, 'y');\n }\n@@ -209,6 +327,20 @@ pub fn change_mutability_of_binding_in_pattern() {\n #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"MirValidated\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"MirValidated\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"MirOptimized\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"MirOptimized\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"TypeckTables\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"TypeckTables\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"TypeOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"TypeOfItem\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"GenericsOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"GenericsOfItem\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"FnSignature\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"FnSignature\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"PredicatesOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"PredicatesOfItem\", cfg=\"cfail3\")]\n pub fn change_mutability_of_binding_in_pattern() {\n     let (mut _a, _b) = (99u8, 'q');\n }\n@@ -228,6 +360,20 @@ pub fn add_initializer() {\n #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"MirValidated\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"MirValidated\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"MirOptimized\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"MirOptimized\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"TypeckTables\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"TypeckTables\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"TypeOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"TypeOfItem\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"GenericsOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"GenericsOfItem\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"FnSignature\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"FnSignature\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"PredicatesOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"PredicatesOfItem\", cfg=\"cfail3\")]\n pub fn add_initializer() {\n     let _x: i16 = 3i16;\n }\n@@ -247,6 +393,20 @@ pub fn change_initializer() {\n #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"MirValidated\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"MirValidated\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"MirOptimized\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"MirOptimized\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"TypeckTables\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"TypeOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"TypeOfItem\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"GenericsOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"GenericsOfItem\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"FnSignature\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"FnSignature\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"PredicatesOfItem\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"PredicatesOfItem\", cfg=\"cfail3\")]\n pub fn change_initializer() {\n     let _x = 5u16;\n }"}, {"sha": "4ff80ead89d4569b475e32c6b6782078dea20d79", "filename": "src/test/incremental/hashes/statics.rs", "status": "modified", "additions": 26, "deletions": 34, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fincremental%2Fhashes%2Fstatics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fincremental%2Fhashes%2Fstatics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fstatics.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -32,8 +32,8 @@\n static STATIC_VISIBILITY: u8 = 0;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub static STATIC_VISIBILITY: u8 = 0;\n@@ -44,8 +44,8 @@ pub static STATIC_VISIBILITY: u8 = 0;\n static STATIC_MUTABILITY: u8 = 0;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n static mut STATIC_MUTABILITY: u8 = 0;\n@@ -56,8 +56,8 @@ static mut STATIC_MUTABILITY: u8 = 0;\n static STATIC_LINKAGE: u8 = 0;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n #[linkage=\"weak_odr\"]\n@@ -69,8 +69,8 @@ static STATIC_LINKAGE: u8 = 0;\n static STATIC_NO_MANGLE: u8 = 0;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n #[no_mangle]\n@@ -82,8 +82,8 @@ static STATIC_NO_MANGLE: u8 = 0;\n static STATIC_THREAD_LOCAL: u8 = 0;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n #[thread_local]\n@@ -95,8 +95,8 @@ static STATIC_THREAD_LOCAL: u8 = 0;\n static STATIC_CHANGE_TYPE_1: i16 = 0;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,TypeOfItem\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n static STATIC_CHANGE_TYPE_1: u64 = 0;\n@@ -107,8 +107,8 @@ static STATIC_CHANGE_TYPE_1: u64 = 0;\n static STATIC_CHANGE_TYPE_2: Option<i8> = None;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,TypeOfItem\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n static STATIC_CHANGE_TYPE_2: Option<u16> = None;\n@@ -119,10 +119,8 @@ static STATIC_CHANGE_TYPE_2: Option<u16> = None;\n static STATIC_CHANGE_VALUE_1: i16 = 1;\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n static STATIC_CHANGE_VALUE_1: i16 = 2;\n@@ -133,10 +131,8 @@ static STATIC_CHANGE_VALUE_1: i16 = 2;\n static STATIC_CHANGE_VALUE_2: i16 = 1 + 1;\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n static STATIC_CHANGE_VALUE_2: i16 = 1 + 2;\n@@ -146,10 +142,8 @@ static STATIC_CHANGE_VALUE_2: i16 = 1 + 2;\n static STATIC_CHANGE_VALUE_3: i16 = 2 + 3;\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n static STATIC_CHANGE_VALUE_3: i16 = 2 * 3;\n@@ -159,10 +153,8 @@ static STATIC_CHANGE_VALUE_3: i16 = 2 * 3;\n static STATIC_CHANGE_VALUE_4: i16 = 1 + 2 * 3;\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n static STATIC_CHANGE_VALUE_4: i16 = 1 + 2 * 4;\n@@ -179,14 +171,14 @@ mod static_change_type_indirectly {\n     #[cfg(not(cfail1))]\n     use super::ReferencedType2 as Type;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,TypeOfItem\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     static STATIC_CHANGE_TYPE_INDIRECTLY_1: Type = Type;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,TypeOfItem\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     static STATIC_CHANGE_TYPE_INDIRECTLY_2: Option<Type> = None;"}, {"sha": "231e29b79c41dc0c8d1f3668ff0e0d5864c990b6", "filename": "src/test/incremental/hashes/struct_constructors.rs", "status": "modified", "additions": 24, "deletions": 36, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -42,10 +42,8 @@ fn change_field_value_regular_struct() -> RegularStruct {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirValidated\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_field_value_regular_struct() -> RegularStruct {\n@@ -69,10 +67,8 @@ fn change_field_order_regular_struct() -> RegularStruct {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_field_order_regular_struct() -> RegularStruct {\n@@ -101,10 +97,8 @@ fn add_field_regular_struct() -> RegularStruct {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirValidated,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn add_field_regular_struct() -> RegularStruct {\n@@ -140,10 +134,8 @@ fn change_field_label_regular_struct() -> RegularStruct {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirValidated,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_field_label_regular_struct() -> RegularStruct {\n@@ -179,10 +171,8 @@ fn change_constructor_path_regular_struct() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirValidated,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_constructor_path_regular_struct() {\n@@ -202,10 +192,11 @@ mod change_constructor_path_indirectly_regular_struct {\n     #[cfg(not(cfail1))]\n     use super::RegularStruct2 as Struct;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_clean(\n+        cfg=\"cfail2\",\n+        except=\"FnSignature,Hir,HirBody,MirOptimized,MirValidated,TypeckTables\"\n+    )]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn function() -> Struct {\n@@ -228,10 +219,8 @@ fn change_field_value_tuple_struct() -> TupleStruct {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirValidated\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_field_value_tuple_struct() -> TupleStruct {\n@@ -249,10 +238,8 @@ fn change_constructor_path_tuple_struct() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirValidated,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_constructor_path_tuple_struct() {\n@@ -268,10 +255,11 @@ mod change_constructor_path_indirectly_tuple_struct {\n     #[cfg(not(cfail1))]\n     use super::TupleStruct2 as Struct;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+    #[rustc_clean(\n+        cfg=\"cfail2\",\n+        except=\"FnSignature,Hir,HirBody,MirOptimized,MirValidated,TypeckTables\"\n+    )]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn function() -> Struct {"}, {"sha": "b0a93eea523cfcf363b394e99203cc0f02da4139", "filename": "src/test/incremental/hashes/type_defs.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fincremental%2Fhashes%2Ftype_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fincremental%2Fhashes%2Ftype_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ftype_defs.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -35,8 +35,8 @@\n type ChangePrimitiveType = i32;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n type ChangePrimitiveType = i64;\n \n@@ -47,8 +47,8 @@ type ChangePrimitiveType = i64;\n type ChangeMutability = &'static i32;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n type ChangeMutability = &'static mut i32;\n \n@@ -59,8 +59,8 @@ type ChangeMutability = &'static mut i32;\n type ChangeLifetime<'a> = (&'static i32, &'a i32);\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n type ChangeLifetime<'a> = (&'a i32, &'a i32);\n \n@@ -74,8 +74,8 @@ struct Struct2;\n type ChangeTypeStruct = Struct1;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n type ChangeTypeStruct = Struct2;\n \n@@ -86,8 +86,8 @@ type ChangeTypeStruct = Struct2;\n type ChangeTypeTuple = (u32, u64);\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n type ChangeTypeTuple = (u32, i64);\n \n@@ -107,8 +107,8 @@ enum Enum2 {\n type ChangeTypeEnum = Enum1;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n type ChangeTypeEnum = Enum2;\n \n@@ -119,8 +119,8 @@ type ChangeTypeEnum = Enum2;\n type AddTupleField = (i32, i64);\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n type AddTupleField = (i32, i64, i16);\n \n@@ -131,8 +131,8 @@ type AddTupleField = (i32, i64, i16);\n type ChangeNestedTupleField = (i32, (i64, i16));\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n type ChangeNestedTupleField = (i32, (i64, i8));\n \n@@ -143,8 +143,8 @@ type ChangeNestedTupleField = (i32, (i64, i8));\n type AddTypeParam<T1> = (T1, T1);\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n type AddTypeParam<T1, T2> = (T1, T2);\n \n@@ -155,8 +155,8 @@ type AddTypeParam<T1, T2> = (T1, T2);\n type AddTypeParamBound<T1> = (T1, u32);\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n type AddTypeParamBound<T1: Clone> = (T1, u32);\n \n@@ -167,8 +167,8 @@ type AddTypeParamBound<T1: Clone> = (T1, u32);\n type AddTypeParamBoundWhereClause<T1> where T1: Clone = (T1, u32);\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n type AddTypeParamBoundWhereClause<T1> where T1: Clone+Copy = (T1, u32);\n \n@@ -179,8 +179,8 @@ type AddTypeParamBoundWhereClause<T1> where T1: Clone+Copy = (T1, u32);\n type AddLifetimeParam<'a> = (&'a u32, &'a u32);\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n type AddLifetimeParam<'a, 'b> = (&'a u32, &'b u32);\n \n@@ -191,8 +191,8 @@ type AddLifetimeParam<'a, 'b> = (&'a u32, &'b u32);\n type AddLifetimeParamBound<'a, 'b> = (&'a u32, &'b u32);\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n type AddLifetimeParamBound<'a, 'b: 'a> = (&'a u32, &'b u32);\n \n@@ -205,8 +205,8 @@ where 'b: 'a\n     = (&'a u32, &'b u32, &'c u32);\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+#[rustc_clean(cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n type AddLifetimeParamBoundWhereClause<'a, 'b, 'c>\n where 'b: 'a,\n@@ -225,8 +225,8 @@ mod change_trait_bound_indirectly {\n     #[cfg(not(cfail1))]\n     use super::ReferencedTrait2 as Trait;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     type ChangeTraitBoundIndirectly<T: Trait> = (T, u32);\n@@ -241,8 +241,8 @@ mod change_trait_bound_indirectly_in_where_clause {\n     #[cfg(not(cfail1))]\n     use super::ReferencedTrait2 as Trait;\n \n-    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     type ChangeTraitBoundIndirectly<T> where T : Trait = (T, u32);"}, {"sha": "914632e96ba316569dbb52f5e733b03bbdd4bbfe", "filename": "src/test/incremental/macro_export.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fincremental%2Fmacro_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fincremental%2Fmacro_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fmacro_export.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -8,10 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Zincremental=tmp/cfail-tests/incr_comp_with_macro_export\n+// revisions: cfail1 cfail2 cfail3\n // must-compile-successfully\n \n-\n // This test case makes sure that we can compile with incremental compilation\n // enabled when there are macros exported from this crate. (See #37756)\n ", "previous_filename": "src/test/compile-fail/incr_comp_with_macro_export.rs"}, {"sha": "b00b35aa29ff45191cc696c3970ee381559ed464", "filename": "src/test/mir-opt/README.md", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2FREADME.md?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -7,13 +7,13 @@ The test format is:\n // END RUST SOURCE\n // START $file_name_of_some_mir_dump_0\n //  $expected_line_0\n-// ...\n+// (lines or elision)\n // $expected_line_N\n // END $file_name_of_some_mir_dump_0\n-// ...\n+// (lines or elision)\n // START $file_name_of_some_mir_dump_N\n //  $expected_line_0\n-// ...\n+// (lines or elision)\n // $expected_line_N\n // END $file_name_of_some_mir_dump_N\n ```\n@@ -22,10 +22,15 @@ All the test information is in comments so the test is runnable.\n \n For each $file_name, compiletest expects [$expected_line_0, ...,\n $expected_line_N] to appear in the dumped MIR in order.  Currently it allows\n-other non-matched lines before, after and in-between. Note that this includes\n-lines that end basic blocks or begin new ones; it is good practice\n-in your tests to include the terminator for each of your basic blocks as an\n-internal sanity check guarding against a test like:\n+other non-matched lines before and after, but not between $expected_lines,\n+should you want to skip lines, you must include an elision comment, of the form\n+(as a regex) `//\\s*...\\s*`. The lines will be skipped lazily, that is, if there\n+are two identical lines in the output that match the line after the elision\n+comment, the first one wil be matched.\n+\n+Examples:\n+\n+The following blocks will not match the one after it.\n \n ```\n bb0: {\n@@ -35,8 +40,6 @@ bb0: {\n }\n ```\n \n-that will inadvertantly pattern-matching against:\n-\n ```\n bb0: {\n     StorageLive(_1);\n@@ -49,6 +52,18 @@ bb1: {\n }\n ```\n \n+But this will match the one above,\n+\n+```\n+bb0: {\n+    StorageLive(_1);\n+    _1 = const true;\n+    ...\n+    StorageDead(_1);\n+    ...\n+}\n+```\n+\n Lines match ignoring whitespace, and the prefix \"//\" is removed.\n \n It also currently strips trailing comments -- partly because the full file path"}, {"sha": "5c3b418e950016db67d98ebaac93be5b82db5b92", "filename": "src/test/mir-opt/box_expr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fbox_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fbox_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbox_expr.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -30,7 +30,10 @@ impl Drop for S {\n // END RUST SOURCE\n // START rustc.node4.ElaborateDrops.before.mir\n //     let mut _0: ();\n-//     let _1: std::boxed::Box<S>;\n+//     scope 1 {\n+//         let _1: std::boxed::Box<S>;\n+//     }\n+//     ...\n //     let mut _2: std::boxed::Box<S>;\n //     let mut _3: ();\n //     let mut _4: std::boxed::Box<S>;"}, {"sha": "0b0d2f45f1c553259ec64a17a2a2d6588e894dc2", "filename": "src/test/mir-opt/copy_propagation.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fcopy_propagation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fcopy_propagation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fcopy_propagation.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -18,17 +18,23 @@ fn main() { }\n // END RUST SOURCE\n // START rustc.node4.CopyPropagation.before.mir\n //  bb0: {\n+//      ...\n //      _2 = _1;\n+//      ...\n //      _4 = _2;\n //      _3 = _4;\n+//      ...\n //      _5 = _3;\n //      _0 = _5;\n+//      ...\n //      return;\n //  }\n // END rustc.node4.CopyPropagation.before.mir\n // START rustc.node4.CopyPropagation.after.mir\n //  bb0: {\n+//      ...\n //      _0 = _1;\n+//      ...\n //      return;\n //  }\n // END rustc.node4.CopyPropagation.after.mir"}, {"sha": "ce2b13ecda7b77d634d98de46be63c894d8c4988", "filename": "src/test/mir-opt/deaggregator_test.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fdeaggregator_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fdeaggregator_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdeaggregator_test.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -23,19 +23,25 @@ fn main() {}\n // END RUST SOURCE\n // START rustc.node13.Deaggregator.before.mir\n // bb0: {\n+//     ...\n //     _2 = _1;\n+//     ...\n //     _3 = _2;\n //     _0 = Baz { x: _3, y: const 0f32, z: const false };\n+//     ...\n //     return;\n // }\n // END rustc.node13.Deaggregator.before.mir\n // START rustc.node13.Deaggregator.after.mir\n // bb0: {\n+//     ...\n //     _2 = _1;\n+//     ...\n //     _3 = _2;\n //     (_0.0: usize) = _3;\n //     (_0.1: f32) = const 0f32;\n //     (_0.2: bool) = const false;\n+//     ...\n //     return;\n // }\n // END rustc.node13.Deaggregator.after.mir"}, {"sha": "d77dcb627817fb75431f0d4500e5d79f2e42051b", "filename": "src/test/mir-opt/deaggregator_test_enum.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -28,18 +28,26 @@ fn main() {\n // END RUST SOURCE\n // START rustc.node10.Deaggregator.before.mir\n // bb0: {\n+//     StorageLive(_2);\n //     _2 = _1;\n+//     StorageLive(_3);\n //     _3 = _2;\n //     _0 = Baz::Foo { x: _3 };\n+//     StorageDead(_3);\n+//     StorageDead(_2);\n //     return;\n // }\n // END rustc.node10.Deaggregator.before.mir\n // START rustc.node10.Deaggregator.after.mir\n // bb0: {\n+//     StorageLive(_2);\n //     _2 = _1;\n+//     StorageLive(_3);\n //     _3 = _2;\n //     ((_0 as Foo).0: usize) = _3;\n //     discriminant(_0) = 1;\n+//     StorageDead(_3);\n+//     StorageDead(_2);\n //     return;\n // }\n // END rustc.node10.Deaggregator.after.mir"}, {"sha": "e65830bddc4d3040dc09b382752896a67d7b2e53", "filename": "src/test/mir-opt/deaggregator_test_enum_2.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum_2.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -28,29 +28,35 @@ fn main() {}\n // END RUST SOURCE\n // START rustc.node12.Deaggregator.before.mir\n //  bb1: {\n+//      StorageLive(_6);\n //      _6 = _4;\n //      _0 = Foo::A(_6,);\n+//      StorageDead(_6);\n //      goto -> bb3;\n //  }\n-//\n //  bb2: {\n+//      StorageLive(_7);\n //      _7 = _4;\n //      _0 = Foo::B(_7,);\n+//      StorageDead(_7);\n //      goto -> bb3;\n //  }\n // END rustc.node12.Deaggregator.before.mir\n // START rustc.node12.Deaggregator.after.mir\n //  bb1: {\n+//      StorageLive(_6);\n //      _6 = _4;\n //      ((_0 as A).0: i32) = _6;\n //      discriminant(_0) = 0;\n+//      StorageDead(_6);\n //      goto -> bb3;\n //  }\n-//\n //  bb2: {\n+//      StorageLive(_7);\n //      _7 = _4;\n //      ((_0 as B).0: i32) = _7;\n //      discriminant(_0) = 1;\n+//      StorageDead(_7);\n //      goto -> bb3;\n //  }\n // END rustc.node12.Deaggregator.after.mir"}, {"sha": "ed68d3bf5f750daf3ef35ec046a4865eb9d22ccf", "filename": "src/test/mir-opt/deaggregator_test_multiple.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_multiple.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -24,25 +24,35 @@ fn main() { }\n // END RUST SOURCE\n // START rustc.node10.Deaggregator.before.mir\n // bb0: {\n+//     ...\n //     _2 = _1;\n+//     ...\n //     _4 = _2;\n //     _3 = Foo::A(_4,);\n+//     ...\n //     _6 = _2;\n //     _5 = Foo::A(_6,);\n+//     ...\n //     _0 = [_3, _5];\n+//     ...\n //     return;\n // }\n // END rustc.node10.Deaggregator.before.mir\n // START rustc.node10.Deaggregator.after.mir\n // bb0: {\n+//     ...\n //     _2 = _1;\n+//     ...\n //     _4 = _2;\n //     ((_3 as A).0: i32) = _4;\n //     discriminant(_3) = 0;\n+//     ...\n //     _6 = _2;\n //     ((_5 as A).0: i32) = _6;\n //     discriminant(_5) = 0;\n+//     ...\n //     _0 = [_3, _5];\n+//     ...\n //     return;\n // }\n // END rustc.node10.Deaggregator.after.mir"}, {"sha": "a0edcc82fe18ac888bb25df4c1e4c68f4709020a", "filename": "src/test/mir-opt/end_region_1.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fend_region_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fend_region_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_1.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -21,9 +21,11 @@ fn main() {\n // END RUST SOURCE\n // START rustc.node4.SimplifyCfg-qualify-consts.after.mir\n //     let mut _0: ();\n+//     ...\n //     let _1: i32;\n+//     ...\n //     let _2: &'10_1rs i32;\n-//\n+//     ...\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = const 3i32;"}, {"sha": "69042fecc7d721597d78c947832c9c680a97183e", "filename": "src/test/mir-opt/end_region_2.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fend_region_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fend_region_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_2.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -26,11 +26,16 @@ fn main() {\n // END RUST SOURCE\n // START rustc.node4.SimplifyCfg-qualify-consts.after.mir\n //     let mut _0: ();\n+//     ...\n //     let _2: bool;\n+//     ...\n //     let _3: &'23_1rs bool;\n+//     ...\n //     let _7: &'23_3rs bool;\n+//     ...\n //     let mut _4: ();\n //     let mut _5: bool;\n+//     ...\n //     bb0: {\n //         goto -> bb1;\n //     }\n@@ -52,6 +57,7 @@ fn main() {\n //         return;\n //     }\n //     bb3: {\n+//         _4 = ();\n //         StorageDead(_5);\n //         StorageLive(_7);\n //         _7 = &'23_3rs _2;"}, {"sha": "da423163e842da82ab482b93c734b4d32b295730", "filename": "src/test/mir-opt/end_region_3.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fend_region_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fend_region_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_3.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -27,13 +27,17 @@ fn main() {\n // END RUST SOURCE\n // START rustc.node4.SimplifyCfg-qualify-consts.after.mir\n //     let mut _0: ();\n+//     ...\n //     let mut _1: bool;\n+//     ...\n //     let _3: &'26_1rs bool;\n+//     ...\n //     let _7: &'26_3rs bool;\n+//     ...\n //     let mut _2: ();\n //     let mut _4: ();\n //     let mut _5: bool;\n-//\n+//     let mut _6: !;\n //     bb0: {\n //         StorageLive(_1);\n //         goto -> bb1;"}, {"sha": "2087485b913d4c272ac8843994be5fa4db5d6e4f", "filename": "src/test/mir-opt/end_region_4.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fend_region_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fend_region_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_4.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -31,10 +31,15 @@ fn foo(i: i32) {\n // END RUST SOURCE\n // START rustc.node4.SimplifyCfg-qualify-consts.after.mir\n //     let mut _0: ();\n+//     ...\n //     let _1: D;\n+//     ...\n //     let _2: i32;\n+//     ...\n //     let _3: &'26_2rs i32;\n+//     ...\n //     let _6: &'26_4rs i32;\n+//     ...\n //     let mut _4: ();\n //     let mut _5: i32;\n //     bb0: {"}, {"sha": "4663b71bd7cb0166720c737fdd94f6bfe5c9e704", "filename": "src/test/mir-opt/end_region_5.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fend_region_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fend_region_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_5.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -28,8 +28,11 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // END RUST SOURCE\n // START rustc.node4.SimplifyCfg-qualify-consts.after.mir\n // fn main() -> () {\n+//     ...\n //     let mut _0: ();\n+//     ...\n //     let _1: D;\n+//     ...\n //     let mut _2: ();\n //     let mut _3: [closure@NodeId(18) d:&'14s D];\n //     let mut _4: &'14s D;"}, {"sha": "7d2868ee4ba57f0813854fb5566fe488d2b094a5", "filename": "src/test/mir-opt/end_region_6.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fend_region_6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fend_region_6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_6.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -29,7 +29,9 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // START rustc.node4.SimplifyCfg-qualify-consts.after.mir\n // fn main() -> () {\n //     let mut _0: ();\n+//     ...\n //     let _1: D;\n+//     ...\n //     let mut _2: ();\n //     let mut _3: [closure@NodeId(22) d:&'19s D];\n //     let mut _4: &'19s D;\n@@ -65,9 +67,10 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // START rustc.node22.SimplifyCfg-qualify-consts.after.mir\n // fn main::{{closure}}(_1: [closure@NodeId(22) d:&'19s D]) -> i32 {\n //     let mut _0: i32;\n+//     ...\n //     let _2: &'15_0rs D;\n+//     ...\n //     let mut _3: i32;\n-//\n //     bb0: {\n //         StorageLive(_2);\n //         _2 = &'15_0rs (*(_1.0: &'19s D));"}, {"sha": "0156c1be7edf95b3f282ec83789494ac26d3304f", "filename": "src/test/mir-opt/end_region_7.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fend_region_7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fend_region_7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_7.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -29,11 +29,12 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // START rustc.node4.SimplifyCfg-qualify-consts.after.mir\n // fn main() -> () {\n //     let mut _0: ();\n+//     ...\n //     let _1: D;\n+//     ...\n //     let mut _2: ();\n //     let mut _3: [closure@NodeId(22) d:D];\n //     let mut _4: D;\n-//\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = D::{{constructor}}(const 0i32,);\n@@ -74,9 +75,10 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // START rustc.node22.SimplifyCfg-qualify-consts.after.mir\n // fn main::{{closure}}(_1: [closure@NodeId(22) d:D]) -> i32 {\n //     let mut _0: i32;\n+//     ...\n //     let _2: &'15_0rs D;\n+//     ...\n //     let mut _3: i32;\n-//\n //     bb0: {\n //         StorageLive(_2);\n //         _2 = &'15_0rs (_1.0: D);"}, {"sha": "6e8cf4204ee9becdc2a5b75033f2c3c019168e4d", "filename": "src/test/mir-opt/end_region_8.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_8.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -30,8 +30,11 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // START rustc.node4.SimplifyCfg-qualify-consts.after.mir\n // fn main() -> () {\n //    let mut _0: ();\n+//    ...\n //    let _1: D;\n+//    ...\n //    let _2: &'21_1rs D;\n+//    ...\n //    let mut _3: ();\n //    let mut _4: [closure@NodeId(22) r:&'21_1rs D];\n //    let mut _5: &'21_1rs D;"}, {"sha": "fd23d81345229644dda85be4bbcd9207e4d7a7ad", "filename": "src/test/mir-opt/end_region_9.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fend_region_9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fend_region_9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_9.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -40,15 +40,18 @@ fn main() {\n // START rustc.node4.SimplifyCfg-qualify-consts.after.mir\n // fn main() -> () {\n //     let mut _0: ();\n+//     ...\n //     let mut _1: bool;\n+//     ...\n //     let _2: i32;\n+//     ...\n //     let mut _4: &'33_0rs i32;\n+//     ...\n //     let mut _3: ();\n //     let mut _5: !;\n //     let mut _6: ();\n //     let mut _7: bool;\n //     let mut _8: !;\n-//\n //     bb0: {\n //        StorageLive(_1);\n //        _1 = const false;\n@@ -63,7 +66,6 @@ fn main() {\n //        _7 = _1;\n //        switchInt(_7) -> [0u8: bb3, otherwise: bb2];\n //    }\n-//\n //    bb2: {\n //        _0 = ();\n //        StorageDead(_7);\n@@ -73,7 +75,6 @@ fn main() {\n //        StorageDead(_1);\n //        return;\n //    }\n-//\n //    bb3: {\n //        _4 = &'33_0rs _2;\n //        _6 = ();"}, {"sha": "f70f651927544488aca0069eb13b8340768fb757", "filename": "src/test/mir-opt/end_region_cyclic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fend_region_cyclic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fend_region_cyclic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_cyclic.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -45,6 +45,7 @@ fn query() -> bool { true }\n //     scope 1 {\n //         let _2: S<'35_0rs>;\n //     }\n+//     ...\n //     let mut _1: ();\n //     let mut _3: std::cell::Cell<std::option::Option<&'35_0rs S<'35_0rs>>>;\n //     let mut _4: std::option::Option<&'35_0rs S<'35_0rs>>;"}, {"sha": "384201b7c128d449a48fa527e6aebe446ee1a681", "filename": "src/test/mir-opt/issue-41110.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fissue-41110.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fissue-41110.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-41110.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -35,22 +35,26 @@ impl S {\n // END RUST SOURCE\n // START rustc.node4.ElaborateDrops.after.mir\n //    let mut _0: ();\n-//    let _1: ();\n+//    scope 1 {\n+//        let _1: ();\n+//    }\n+//    ...\n //    let mut _2: S;\n //    let mut _3: S;\n //    let mut _4: S;\n //    let mut _5: bool;\n-//\n //    bb0: {\n // END rustc.node4.ElaborateDrops.after.mir\n // START rustc.node13.ElaborateDrops.after.mir\n //    let mut _0: ();\n+//    ...\n //    let _1: S;\n+//    ...\n //    let mut _2: S;\n+//    ...\n //    let mut _3: ();\n //    let mut _4: S;\n //    let mut _5: S;\n //    let mut _6: bool;\n-//\n //    bb0: {\n // END rustc.node13.ElaborateDrops.after.mir"}, {"sha": "370ab599eca708790b0b802fe2a82783eea72ba1", "filename": "src/test/mir-opt/storage_live_dead_in_statics.rs", "status": "modified", "additions": 150, "deletions": 50, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fstorage_live_dead_in_statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fstorage_live_dead_in_statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fstorage_live_dead_in_statics.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -45,56 +45,156 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.node4.mir_map.0.mir\n+//    let mut _0: &'static Foo;\n+//    let mut _1: &'static Foo;\n+//    let mut _2: Foo;\n+//    let mut _3: &'static [(u32, u32)];\n+//    let mut _4: &'static [(u32, u32); 42];\n+//    let mut _5: &'static [(u32, u32); 42];\n+//    let mut _6: [(u32, u32); 42];\n+//    let mut _7: (u32, u32);\n+//    let mut _8: (u32, u32);\n+//    let mut _9: (u32, u32);\n+//    let mut _10: (u32, u32);\n+//    let mut _11: (u32, u32);\n+//    let mut _12: (u32, u32);\n+//    let mut _13: (u32, u32);\n+//    let mut _14: (u32, u32);\n+//    let mut _15: (u32, u32);\n+//    let mut _16: (u32, u32);\n+//    let mut _17: (u32, u32);\n+//    let mut _18: (u32, u32);\n+//    let mut _19: (u32, u32);\n+//    let mut _20: (u32, u32);\n+//    let mut _21: (u32, u32);\n+//    let mut _22: (u32, u32);\n+//    let mut _23: (u32, u32);\n+//    let mut _24: (u32, u32);\n+//    let mut _25: (u32, u32);\n+//    let mut _26: (u32, u32);\n+//    let mut _27: (u32, u32);\n+//    let mut _28: (u32, u32);\n+//    let mut _29: (u32, u32);\n+//    let mut _30: (u32, u32);\n+//    let mut _31: (u32, u32);\n+//    let mut _32: (u32, u32);\n+//    let mut _33: (u32, u32);\n+//    let mut _34: (u32, u32);\n+//    let mut _35: (u32, u32);\n+//    let mut _36: (u32, u32);\n+//    let mut _37: (u32, u32);\n+//    let mut _38: (u32, u32);\n+//    let mut _39: (u32, u32);\n+//    let mut _40: (u32, u32);\n+//    let mut _41: (u32, u32);\n+//    let mut _42: (u32, u32);\n+//    let mut _43: (u32, u32);\n+//    let mut _44: (u32, u32);\n+//    let mut _45: (u32, u32);\n+//    let mut _46: (u32, u32);\n+//    let mut _47: (u32, u32);\n+//    let mut _48: (u32, u32);\n //    bb0: {\n-//        _7 = (const 0u32, const 1u32);   // scope 0 at src/test/mir-opt/basic_assignment.rs:29:9: 29:15\n-//        _8 = (const 0u32, const 2u32);   // scope 0 at src/test/mir-opt/basic_assignment.rs:29:17: 29:23\n-//        _9 = (const 0u32, const 3u32);   // scope 0 at src/test/mir-opt/basic_assignment.rs:29:25: 29:31\n-//        _10 = (const 0u32, const 1u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:30:9: 30:15\n-//        _11 = (const 0u32, const 2u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:30:17: 30:23\n-//        _12 = (const 0u32, const 3u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:30:25: 30:31\n-//        _13 = (const 0u32, const 1u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:31:9: 31:15\n-//        _14 = (const 0u32, const 2u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:31:17: 31:23\n-//        _15 = (const 0u32, const 3u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:31:25: 31:31\n-//        _16 = (const 0u32, const 1u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:32:9: 32:15\n-//        _17 = (const 0u32, const 2u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:32:17: 32:23\n-//        _18 = (const 0u32, const 3u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:32:25: 32:31\n-//        _19 = (const 0u32, const 1u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:33:9: 33:15\n-//        _20 = (const 0u32, const 2u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:33:17: 33:23\n-//        _21 = (const 0u32, const 3u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:33:25: 33:31\n-//        _22 = (const 0u32, const 1u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:34:9: 34:15\n-//        _23 = (const 0u32, const 2u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:34:17: 34:23\n-//        _24 = (const 0u32, const 3u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:34:25: 34:31\n-//        _25 = (const 0u32, const 1u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:35:9: 35:15\n-//        _26 = (const 0u32, const 2u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:35:17: 35:23\n-//        _27 = (const 0u32, const 3u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:35:25: 35:31\n-//        _28 = (const 0u32, const 1u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:36:9: 36:15\n-//        _29 = (const 0u32, const 2u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:36:17: 36:23\n-//        _30 = (const 0u32, const 3u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:36:25: 36:31\n-//        _31 = (const 0u32, const 1u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:37:9: 37:15\n-//        _32 = (const 0u32, const 2u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:37:17: 37:23\n-//        _33 = (const 0u32, const 3u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:37:25: 37:31\n-//        _34 = (const 0u32, const 1u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:38:9: 38:15\n-//        _35 = (const 0u32, const 2u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:38:17: 38:23\n-//        _36 = (const 0u32, const 3u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:38:25: 38:31\n-//        _37 = (const 0u32, const 1u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:39:9: 39:15\n-//        _38 = (const 0u32, const 2u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:39:17: 39:23\n-//        _39 = (const 0u32, const 3u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:39:25: 39:31\n-//        _40 = (const 0u32, const 1u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:40:9: 40:15\n-//        _41 = (const 0u32, const 2u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:40:17: 40:23\n-//        _42 = (const 0u32, const 3u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:40:25: 40:31\n-//        _43 = (const 0u32, const 1u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:41:9: 41:15\n-//        _44 = (const 0u32, const 2u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:41:17: 41:23\n-//        _45 = (const 0u32, const 3u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:41:25: 41:31\n-//        _46 = (const 0u32, const 1u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:42:9: 42:15\n-//        _47 = (const 0u32, const 2u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:42:17: 42:23\n-//        _48 = (const 0u32, const 3u32);  // scope 0 at src/test/mir-opt/basic_assignment.rs:42:25: 42:31\n-//        _6 = [_7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48]; // scope 0 at src/test/mir-opt/basic_assignment.rs:28:12: 43:6\n-//        _5 = &_6;                        // scope 0 at src/test/mir-opt/basic_assignment.rs:28:11: 43:6\n-//        _4 = &(*_5);                     // scope 0 at src/test/mir-opt/basic_assignment.rs:28:11: 43:6\n-//        _3 = _4 as &'static [(u32, u32)] (Unsize); // scope 0 at src/test/mir-opt/basic_assignment.rs:28:11: 43:6\n-//        _2 = Foo { tup: const \"hi\", data: _3 }; // scope 0 at src/test/mir-opt/basic_assignment.rs:26:29: 44:2\n-//        _1 = &_2;                        // scope 0 at src/test/mir-opt/basic_assignment.rs:26:28: 44:2\n-//        _0 = &(*_1);                     // scope 0 at src/test/mir-opt/basic_assignment.rs:26:28: 44:2\n-//        return;                          // scope 0 at src/test/mir-opt/basic_assignment.rs:26:1: 44:3\n+//        StorageLive(_1);\n+//        StorageLive(_2);\n+//        StorageLive(_3);\n+//        StorageLive(_4);\n+//        StorageLive(_5);\n+//        StorageLive(_6);\n+//        StorageLive(_7);\n+//        _7 = (const 0u32, const 1u32);\n+//        StorageLive(_8);\n+//        _8 = (const 0u32, const 2u32);\n+//        StorageLive(_9);\n+//        _9 = (const 0u32, const 3u32);\n+//        StorageLive(_10);\n+//        _10 = (const 0u32, const 1u32);\n+//        StorageLive(_11);\n+//        _11 = (const 0u32, const 2u32);\n+//        StorageLive(_12);\n+//        _12 = (const 0u32, const 3u32);\n+//        StorageLive(_13);\n+//        _13 = (const 0u32, const 1u32);\n+//        StorageLive(_14);\n+//        _14 = (const 0u32, const 2u32);\n+//        StorageLive(_15);\n+//        _15 = (const 0u32, const 3u32);\n+//        StorageLive(_16);\n+//        _16 = (const 0u32, const 1u32);\n+//        StorageLive(_17);\n+//        _17 = (const 0u32, const 2u32);\n+//        StorageLive(_18);\n+//        _18 = (const 0u32, const 3u32);\n+//        StorageLive(_19);\n+//        _19 = (const 0u32, const 1u32);\n+//        StorageLive(_20);\n+//        _20 = (const 0u32, const 2u32);\n+//        StorageLive(_21);\n+//        _21 = (const 0u32, const 3u32);\n+//        StorageLive(_22);\n+//        _22 = (const 0u32, const 1u32);\n+//        StorageLive(_23);\n+//        _23 = (const 0u32, const 2u32);\n+//        StorageLive(_24);\n+//        _24 = (const 0u32, const 3u32);\n+//        StorageLive(_25);\n+//        _25 = (const 0u32, const 1u32);\n+//        StorageLive(_26);\n+//        _26 = (const 0u32, const 2u32);\n+//        StorageLive(_27);\n+//        _27 = (const 0u32, const 3u32);\n+//        StorageLive(_28);\n+//        _28 = (const 0u32, const 1u32);\n+//        StorageLive(_29);\n+//        _29 = (const 0u32, const 2u32);\n+//        StorageLive(_30);\n+//        _30 = (const 0u32, const 3u32);\n+//        StorageLive(_31);\n+//        _31 = (const 0u32, const 1u32);\n+//        StorageLive(_32);\n+//        _32 = (const 0u32, const 2u32);\n+//        StorageLive(_33);\n+//        _33 = (const 0u32, const 3u32);\n+//        StorageLive(_34);\n+//        _34 = (const 0u32, const 1u32);\n+//        StorageLive(_35);\n+//        _35 = (const 0u32, const 2u32);\n+//        StorageLive(_36);\n+//        _36 = (const 0u32, const 3u32);\n+//        StorageLive(_37);\n+//        _37 = (const 0u32, const 1u32);\n+//        StorageLive(_38);\n+//        _38 = (const 0u32, const 2u32);\n+//        StorageLive(_39);\n+//        _39 = (const 0u32, const 3u32);\n+//        StorageLive(_40);\n+//        _40 = (const 0u32, const 1u32);\n+//        StorageLive(_41);\n+//        _41 = (const 0u32, const 2u32);\n+//        StorageLive(_42);\n+//        _42 = (const 0u32, const 3u32);\n+//        StorageLive(_43);\n+//        _43 = (const 0u32, const 1u32);\n+//        StorageLive(_44);\n+//        _44 = (const 0u32, const 2u32);\n+//        StorageLive(_45);\n+//        _45 = (const 0u32, const 3u32);\n+//        StorageLive(_46);\n+//        _46 = (const 0u32, const 1u32);\n+//        StorageLive(_47);\n+//        _47 = (const 0u32, const 2u32);\n+//        StorageLive(_48);\n+//        _48 = (const 0u32, const 3u32);\n+//        _6 = [_7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48];\n+//        _5 = &_6;\n+//        _4 = &(*_5);\n+//        _3 = _4 as &'static [(u32, u32)] (Unsize);\n+//        _2 = Foo { tup: const \"hi\", data: _3 };\n+//        _1 = &_2;\n+//        _0 = &(*_1);\n+//        StorageDead(_1);\n+//        StorageDead(_5);\n+//        return;\n //    }\n+//}\n // END rustc.node4.mir_map.0.mir"}, {"sha": "7dbcf82af349382222e7d533e64888c012760e06", "filename": "src/test/mir-opt/storage_ranges.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -38,5 +38,6 @@ fn main() {\n //         _0 = ();\n //         StorageDead(_6);\n //         StorageDead(_1);\n+//         return;\n //      }\n // END rustc.node4.TypeckMir.before.mir"}, {"sha": "5a31be8bd502f788025d784e690d9d0fce9b6485", "filename": "src/test/mir-opt/validate_1.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -31,12 +31,15 @@ fn main() {\n // START rustc.node12.EraseRegions.after.mir\n //     bb0: {\n //         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(0:5) => validate_1[8cd8]::{{impl}}[0]::foo[0] }, BrAnon(0)) Test, _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(0:5) => validate_1[8cd8]::{{impl}}[0]::foo[0] }, BrAnon(1)) mut i32]);\n+//         ...\n //         return;\n //     }\n // END rustc.node12.EraseRegions.after.mir\n // START rustc.node23.EraseRegions.after.mir\n // fn main() -> () {\n+//     ...\n //     bb0: {\n+//         ...\n //         Validate(Suspend(ReScope(Node(ItemLocalId(10)))), [_1: i32]);\n //         _6 = &ReErased mut _1;\n //         Validate(Acquire, [(*_6): i32/ReScope(Node(ItemLocalId(10)))]);\n@@ -50,14 +53,16 @@ fn main() {\n //     bb1: {\n //         Validate(Acquire, [_2: ()]);\n //         EndRegion(ReScope(Node(ItemLocalId(10))));\n+//         ...\n //         return;\n //     }\n // }\n // END rustc.node23.EraseRegions.after.mir\n // START rustc.node50.EraseRegions.after.mir\n // fn main::{{closure}}(_1: &ReErased [closure@NodeId(50)], _2: &ReErased mut i32) -> i32 {\n+//     ...\n //     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:11) => validate_1[8cd8]::main[0]::{{closure}}[0] }, \"BrEnv\") [closure@NodeId(50)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:11) => validate_1[8cd8]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:11) => validate_1[8cd8]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(50)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:11) => validate_1[8cd8]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n //         StorageLive(_3);\n //         _3 = _2;\n //         StorageLive(_4);"}, {"sha": "aacf5a5ed0f5afd0ee71579e2d47332f523d211e", "filename": "src/test/mir-opt/validate_2.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fvalidate_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fvalidate_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_2.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -18,10 +18,18 @@ fn main() {\n // END RUST SOURCE\n // START rustc.node4.EraseRegions.after.mir\n // fn main() -> () {\n+//     ...\n //     bb1: {\n+//         Validate(Acquire, [_2: std::boxed::Box<[i32; 3]>]);\n //         Validate(Release, [_2: std::boxed::Box<[i32; 3]>]);\n //         _1 = _2 as std::boxed::Box<[i32]> (Unsize);\n //         Validate(Acquire, [_1: std::boxed::Box<[i32]>]);\n+//         StorageDead(_2);\n+//         StorageDead(_3);\n+//         _0 = ();\n+//         Validate(Release, [_1: std::boxed::Box<[i32]>]);\n+//         drop(_1) -> bb2;\n //     }\n+//     ...\n // }\n // END rustc.node4.EraseRegions.after.mir"}, {"sha": "d7d3e023c9ed6a51496c62d9d395d5e2cfc3ef29", "filename": "src/test/mir-opt/validate_3.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -30,8 +30,17 @@ fn main() {\n // END RUST SOURCE\n // START rustc.node16.EraseRegions.after.mir\n // fn main() -> () {\n+//     ...\n //     let mut _5: &ReErased i32;\n //     bb0: {\n+//         StorageLive(_1);\n+//         _1 = Test { x: const 0i32 };\n+//         StorageLive(_2);\n+//         Validate(Suspend(ReScope(Remainder(BlockRemainder { block: ItemLocalId(19), first_statement_index: 3 }))), [_1: Test]);\n+//         _2 = &ReErased _1;\n+//         Validate(Acquire, [(*_2): Test/ReScope(Remainder(BlockRemainder { block: ItemLocalId(19), first_statement_index: 3 })) (imm)]);\n+//         StorageLive(_4);\n+//         StorageLive(_5);\n //         Validate(Suspend(ReScope(Node(ItemLocalId(17)))), [((*_2).0: i32): i32/ReScope(Remainder(BlockRemainder { block: ItemLocalId(19), first_statement_index: 3 })) (imm)]);\n //         _5 = &ReErased ((*_2).0: i32);\n //         Validate(Acquire, [(*_5): i32/ReScope(Node(ItemLocalId(17))) (imm)]);\n@@ -42,8 +51,14 @@ fn main() {\n //         _3 = const foo(_4) -> bb1;\n //     }\n //     bb1: {\n+//         Validate(Acquire, [_3: ()]);\n //         EndRegion(ReScope(Node(ItemLocalId(17))));\n+//         StorageDead(_4);\n+//         StorageDead(_5);\n+//         _0 = ();\n //         EndRegion(ReScope(Remainder(BlockRemainder { block: ItemLocalId(19), first_statement_index: 3 })));\n+//         StorageDead(_2);\n+//         StorageDead(_1);\n //         return;\n //     }\n // }"}, {"sha": "bcb21c60b269470b4e1707abbe8af3b666a60b63", "filename": "src/test/mir-opt/validate_4.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -38,18 +38,21 @@ fn main() {\n // END RUST SOURCE\n // START rustc.node4.EraseRegions.after.mir\n // fn write_42(_1: *mut i32) -> bool {\n+//     ...\n //     bb0: {\n //         Validate(Acquire, [_1: *mut i32]);\n //         Validate(Release, [_1: *mut i32]);\n+//         ...\n //         return;\n //     }\n // }\n // END rustc.node4.EraseRegions.after.mir\n // START rustc.node22.EraseRegions.after.mir\n // fn write_42::{{closure}}(_1: &ReErased [closure@NodeId(22)], _2: *mut i32) -> () {\n+//     ...\n //     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_4[8cd8]::write_42[0]::{{closure}}[0] }, \"BrEnv\") [closure@NodeId(22)], _2: *mut i32]);\n-//         Validate(Release, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_4[8cd8]::write_42[0]::{{closure}}[0] }, \"BrEnv\") [closure@NodeId(22)], _2: *mut i32]);\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_4[8cd8]::write_42[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(22)], _2: *mut i32]);\n+//         Validate(Release, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_4[8cd8]::write_42[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(22)], _2: *mut i32]);\n //         StorageLive(_3);\n //         _3 = _2;\n //         (*_3) = const 23i32;\n@@ -60,24 +63,30 @@ fn main() {\n // END rustc.node22.EraseRegions.after.mir\n // START rustc.node31.EraseRegions.after.mir\n // fn test(_1: &ReErased mut i32) -> () {\n+//     ...\n //     bb0: {\n //         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(0:4) => validate_4[8cd8]::test[0] }, BrAnon(0)) mut i32]);\n //         Validate(Release, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(0:4) => validate_4[8cd8]::test[0] }, BrAnon(0)) mut i32]);\n+//         ...\n //         _3 = const write_42(_4) -> bb1;\n //     }\n //     bb1: {\n //         Validate(Acquire, [_3: bool]);\n //         Validate(Release, [_3: bool]);\n+//         ...\n //     }\n // }\n // END rustc.node31.EraseRegions.after.mir\n // START rustc.node60.EraseRegions.after.mir\n // fn main::{{closure}}(_1: &ReErased [closure@NodeId(60)], _2: &ReErased mut i32) -> bool {\n+//     ...\n //     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[8cd8]::main[0]::{{closure}}[0] }, \"BrEnv\") [closure@NodeId(60)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[8cd8]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n-//         Validate(Release, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[8cd8]::main[0]::{{closure}}[0] }, \"BrEnv\") [closure@NodeId(60)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[8cd8]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[8cd8]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(60)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[8cd8]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n+//         Validate(Release, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[8cd8]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(60)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[8cd8]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n //         StorageLive(_3);\n+//         ...\n //         _0 = const write_42(_4) -> bb1;\n //     }\n+//     ...\n // }\n // END rustc.node60.EraseRegions.after.mir"}, {"sha": "44280539c41b0cc9c2d21d8ed34de1b583c72943", "filename": "src/test/mir-opt/validate_5.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -35,17 +35,21 @@ fn main() {\n // END RUST SOURCE\n // START rustc.node17.EraseRegions.after.mir\n // fn test(_1: &ReErased mut i32) -> () {\n+//     ...\n //     bb0: {\n //         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(0:4) => validate_5[8cd8]::test[0] }, BrAnon(0)) mut i32]);\n+//         ...\n //         Validate(Release, [_3: bool, _4: *mut i32]);\n //         _3 = const write_42(_4) -> bb1;\n //     }\n+//     ...\n // }\n // END rustc.node17.EraseRegions.after.mir\n // START rustc.node46.EraseRegions.after.mir\n // fn main::{{closure}}(_1: &ReErased [closure@NodeId(46)], _2: &ReErased mut i32) -> bool {\n+//     ...\n //     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_5[8cd8]::main[0]::{{closure}}[0] }, \"BrEnv\") [closure@NodeId(46)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_5[8cd8]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_5[8cd8]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(46)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_5[8cd8]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n //         StorageLive(_3);\n //         _3 = _2;\n //         StorageLive(_4);\n@@ -59,5 +63,6 @@ fn main() {\n //         Validate(Release, [_0: bool, _4: *mut i32]);\n //         _0 = const write_42(_4) -> bb1;\n //     }\n+//     ...\n // }\n // END rustc.node46.EraseRegions.after.mir"}, {"sha": "1ee6996ce9c848f07f94aea5205a79bb0af1203b", "filename": "src/test/parse-fail/require-parens-for-chained-comparison.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fparse-fail%2Frequire-parens-for-chained-comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fparse-fail%2Frequire-parens-for-chained-comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Frequire-parens-for-chained-comparison.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -21,5 +21,6 @@ fn main() {\n \n     f<X>();\n     //~^ ERROR: chained comparison operators require parentheses\n-    //~^^ HELP: use `::<...>` instead of `<...>`\n+    //~| HELP: use `::<...>` instead of `<...>`\n+    //~| HELP: or use `(...)`\n }"}, {"sha": "3e8c140eb197d154c9f7af6f02ef97d908e7d7fa", "filename": "src/test/parse-fail/trait-object-bad-parens.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fparse-fail%2Ftrait-object-bad-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fparse-fail%2Ftrait-object-bad-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-object-bad-parens.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -17,4 +17,6 @@ fn main() {\n     //~^ ERROR expected a path on the left-hand side of `+`, not `( Copy + Copy)`\n     let _: Box<(Copy +) + Copy>;\n     //~^ ERROR expected a path on the left-hand side of `+`, not `( Copy)`\n+    let _: Box<(dyn Copy) + Copy>;\n+    //~^ ERROR expected a path on the left-hand side of `+`, not `(dyn  Copy)`\n }"}, {"sha": "02b8425d88beedb2486b8fdfb7345d2689568742", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -40,31 +40,31 @@\n \n \n                   ((::fmt::format as\n-                       fn(std::fmt::Arguments<'_>) -> std::string::String {std::fmt::format})(((<::std::fmt::Arguments>::new_v1\n-                                                                                                   as\n-                                                                                                   fn(&[&str], &[std::fmt::ArgumentV1<'_>]) -> std::fmt::Arguments<'_> {std::fmt::Arguments<'_>::new_v1})((&([(\"test\"\n-                                                                                                                                                                                                                  as\n-                                                                                                                                                                                                                  &'static str)]\n-                                                                                                                                                                                                                as\n-                                                                                                                                                                                                                [&str; 1])\n-                                                                                                                                                                                                              as\n-                                                                                                                                                                                                              &[&str; 1]),\n-                                                                                                                                                                                                          (&(match (()\n-                                                                                                                                                                                                                       as\n-                                                                                                                                                                                                                       ())\n-                                                                                                                                                                                                                 {\n-                                                                                                                                                                                                                 ()\n-                                                                                                                                                                                                                 =>\n-                                                                                                                                                                                                                 ([]\n-                                                                                                                                                                                                                     as\n-                                                                                                                                                                                                                     [std::fmt::ArgumentV1<'_>; 0]),\n-                                                                                                                                                                                                             }\n-                                                                                                                                                                                                                as\n-                                                                                                                                                                                                                [std::fmt::ArgumentV1<'_>; 0])\n-                                                                                                                                                                                                              as\n-                                                                                                                                                                                                              &[std::fmt::ArgumentV1<'_>; 0]))\n-                                                                                                  as\n-                                                                                                  std::fmt::Arguments<'_>))\n+                       for<'r> fn(std::fmt::Arguments<'r>) -> std::string::String {std::fmt::format})(((<::std::fmt::Arguments>::new_v1\n+                                                                                                           as\n+                                                                                                           fn(&[&str], &[std::fmt::ArgumentV1<'_>]) -> std::fmt::Arguments<'_> {std::fmt::Arguments<'_>::new_v1})((&([(\"test\"\n+                                                                                                                                                                                                                          as\n+                                                                                                                                                                                                                          &'static str)]\n+                                                                                                                                                                                                                        as\n+                                                                                                                                                                                                                        [&str; 1])\n+                                                                                                                                                                                                                      as\n+                                                                                                                                                                                                                      &[&str; 1]),\n+                                                                                                                                                                                                                  (&(match (()\n+                                                                                                                                                                                                                               as\n+                                                                                                                                                                                                                               ())\n+                                                                                                                                                                                                                         {\n+                                                                                                                                                                                                                         ()\n+                                                                                                                                                                                                                         =>\n+                                                                                                                                                                                                                         ([]\n+                                                                                                                                                                                                                             as\n+                                                                                                                                                                                                                             [std::fmt::ArgumentV1<'_>; 0]),\n+                                                                                                                                                                                                                     }\n+                                                                                                                                                                                                                        as\n+                                                                                                                                                                                                                        [std::fmt::ArgumentV1<'_>; 0])\n+                                                                                                                                                                                                                      as\n+                                                                                                                                                                                                                      &[std::fmt::ArgumentV1<'_>; 0]))\n+                                                                                                          as\n+                                                                                                          std::fmt::Arguments<'_>))\n                       as std::string::String);\n               } as ())\n pub type Foo = [i32; (3 as usize)];"}, {"sha": "51191dd7087e483e3f9ae7eabdfe067bbfc83a72", "filename": "src/test/run-fail/mir_drop_panics.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-fail%2Fmir_drop_panics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-fail%2Fmir_drop_panics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_drop_panics.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -10,15 +10,14 @@\n \n // error-pattern:panic 1\n // error-pattern:drop 2\n-use std::io::{self, Write};\n \n struct Droppable(u32);\n impl Drop for Droppable {\n     fn drop(&mut self) {\n         if self.0 == 1 {\n             panic!(\"panic 1\");\n         } else {\n-            write!(io::stderr(), \"drop {}\", self.0);\n+            eprint!(\"drop {}\", self.0);\n         }\n     }\n }"}, {"sha": "69f934272b75cd72a8ffe701ddbdc324ae6b7a98", "filename": "src/test/run-fail/mir_dynamic_drops_1.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-fail%2Fmir_dynamic_drops_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-fail%2Fmir_dynamic_drops_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_dynamic_drops_1.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -9,18 +9,17 @@\n // except according to those terms.\n // error-pattern:drop 1\n // error-pattern:drop 2\n-use std::io::{self, Write};\n \n \n /// Structure which will not allow to be dropped twice.\n struct Droppable<'a>(&'a mut bool, u32);\n impl<'a> Drop for Droppable<'a> {\n     fn drop(&mut self) {\n         if *self.0 {\n-            writeln!(io::stderr(), \"{} dropped twice\", self.1);\n+            eprintln!(\"{} dropped twice\", self.1);\n             ::std::process::exit(1);\n         }\n-        writeln!(io::stderr(), \"drop {}\", self.1);\n+        eprintln!(\"drop {}\", self.1);\n         *self.0 = true;\n     }\n }"}, {"sha": "d2fe50401ab8de4a6da8dc44169f13dac44fe103", "filename": "src/test/run-fail/mir_dynamic_drops_2.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-fail%2Fmir_dynamic_drops_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-fail%2Fmir_dynamic_drops_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_dynamic_drops_2.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -9,18 +9,17 @@\n // except according to those terms.\n \n // error-pattern:drop 1\n-use std::io::{self, Write};\n \n \n /// Structure which will not allow to be dropped twice.\n struct Droppable<'a>(&'a mut bool, u32);\n impl<'a> Drop for Droppable<'a> {\n     fn drop(&mut self) {\n         if *self.0 {\n-            writeln!(io::stderr(), \"{} dropped twice\", self.1);\n+            eprintln!(\"{} dropped twice\", self.1);\n             ::std::process::exit(1);\n         }\n-        writeln!(io::stderr(), \"drop {}\", self.1);\n+        eprintln!(\"drop {}\", self.1);\n         *self.0 = true;\n     }\n }"}, {"sha": "ecc35ee9b2409545c814ab498e730ab9b03556be", "filename": "src/test/run-fail/mir_dynamic_drops_3.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-fail%2Fmir_dynamic_drops_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-fail%2Fmir_dynamic_drops_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_dynamic_drops_3.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -12,18 +12,17 @@\n // error-pattern:drop 3\n // error-pattern:drop 2\n // error-pattern:drop 1\n-use std::io::{self, Write};\n \n \n /// Structure which will not allow to be dropped twice.\n struct Droppable<'a>(&'a mut bool, u32);\n impl<'a> Drop for Droppable<'a> {\n     fn drop(&mut self) {\n         if *self.0 {\n-            writeln!(io::stderr(), \"{} dropped twice\", self.1);\n+            eprintln!(\"{} dropped twice\", self.1);\n             ::std::process::exit(1);\n         }\n-        writeln!(io::stderr(), \"drop {}\", self.1);\n+        eprintln!(\"drop {}\", self.1);\n         *self.0 = true;\n     }\n }"}, {"sha": "9c851eb7346bb295bedfc10fc41fb88980d52cfd", "filename": "src/test/run-fail/mir_trans_calls_converging_drops.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-fail%2Fmir_trans_calls_converging_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-fail%2Fmir_trans_calls_converging_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_trans_calls_converging_drops.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -12,17 +12,15 @@\n // error-pattern:0 dropped\n // error-pattern:exit\n \n-use std::io::{self, Write};\n-\n struct Droppable(u8);\n impl Drop for Droppable {\n     fn drop(&mut self) {\n-        write!(io::stderr(), \"{} dropped\\n\", self.0);\n+        eprintln!(\"{} dropped\", self.0);\n     }\n }\n \n fn converging_fn() {\n-    write!(io::stderr(), \"converging_fn called\\n\");\n+    eprintln!(\"converging_fn called\");\n }\n \n fn mir(d: Droppable) {"}, {"sha": "6f10521155648a8e83fe5f34caa721d34e9191ed", "filename": "src/test/run-fail/mir_trans_calls_converging_drops_2.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-fail%2Fmir_trans_calls_converging_drops_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-fail%2Fmir_trans_calls_converging_drops_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_trans_calls_converging_drops_2.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -12,18 +12,16 @@\n // error-pattern:dropped\n // error-pattern:exit\n \n-use std::io::{self, Write};\n-\n struct Droppable;\n impl Drop for Droppable {\n     fn drop(&mut self) {\n-        write!(io::stderr(), \"dropped\\n\");\n+        eprintln!(\"dropped\");\n     }\n }\n \n // return value of this function is copied into the return slot\n fn complex() -> u64 {\n-    write!(io::stderr(), \"complex called\\n\");\n+    eprintln!(\"complex called\");\n     42\n }\n "}, {"sha": "f8fbe8f79cc622bd8068a4c00d2e056354019898", "filename": "src/test/run-fail/mir_trans_calls_diverging_drops.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-fail%2Fmir_trans_calls_diverging_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-fail%2Fmir_trans_calls_diverging_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_trans_calls_diverging_drops.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -11,12 +11,10 @@\n // error-pattern:diverging_fn called\n // error-pattern:0 dropped\n \n-use std::io::{self, Write};\n-\n struct Droppable(u8);\n impl Drop for Droppable {\n     fn drop(&mut self) {\n-        write!(io::stderr(), \"{} dropped\", self.0);\n+        eprintln!(\"{} dropped\", self.0);\n     }\n }\n "}, {"sha": "68f1c4ed0bceddc17d52ac9b413d64c95fb1bc96", "filename": "src/test/run-fail/panic-set-handler.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-fail%2Fpanic-set-handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-fail%2Fpanic-set-handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-set-handler.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -13,11 +13,10 @@\n #![feature(panic_handler)]\n \n use std::panic;\n-use std::io::{self, Write};\n \n fn main() {\n     panic::set_hook(Box::new(|i| {\n-        write!(io::stderr(), \"greetings from the panic handler\");\n+        eprint!(\"greetings from the panic handler\");\n     }));\n     panic!(\"foobar\");\n }"}, {"sha": "072139a8c9b802c8fe653c82ef1a0f06cade2537", "filename": "src/test/run-fail/panic-set-unset-handler.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-fail%2Fpanic-set-unset-handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-fail%2Fpanic-set-unset-handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-set-unset-handler.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -13,11 +13,10 @@\n #![feature(panic_handler)]\n \n use std::panic;\n-use std::io::{self, Write};\n \n fn main() {\n     panic::set_hook(Box::new(|i| {\n-        write!(io::stderr(), \"greetings from the panic handler\");\n+        eprint!(\"greetings from the panic handler\");\n     }));\n     panic::take_hook();\n     panic!(\"foobar\");"}, {"sha": "93711c41d79f82cc8a906f761a74b76828a18adf", "filename": "src/test/run-make/archive-duplicate-names/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2FMakefile?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -5,7 +5,7 @@ all:\n \tmkdir $(TMPDIR)/b\n \t$(call COMPILE_OBJ,$(TMPDIR)/a/foo.o,foo.c)\n \t$(call COMPILE_OBJ,$(TMPDIR)/b/foo.o,bar.c)\n-\tar crus $(TMPDIR)/libfoo.a $(TMPDIR)/a/foo.o $(TMPDIR)/b/foo.o\n+\t$(AR) crus $(TMPDIR)/libfoo.a $(TMPDIR)/a/foo.o $(TMPDIR)/b/foo.o\n \t$(RUSTC) foo.rs\n \t$(RUSTC) bar.rs\n \t$(call RUN,bar)"}, {"sha": "06d1bb6698ece6ba07aa4379cd2ad0ce9f22238c", "filename": "src/test/run-make/compiler-rt-works-on-mingw/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Fcompiler-rt-works-on-mingw%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Fcompiler-rt-works-on-mingw%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcompiler-rt-works-on-mingw%2FMakefile?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -3,8 +3,8 @@\n ifneq (,$(findstring MINGW,$(UNAME)))\n ifndef IS_MSVC\n all:\n-\tg++ foo.cpp -c -o $(TMPDIR)/foo.o\n-\tar crus $(TMPDIR)/libfoo.a $(TMPDIR)/foo.o\n+\t$(CXX) foo.cpp -c -o $(TMPDIR)/foo.o\n+\t$(AR) crus $(TMPDIR)/libfoo.a $(TMPDIR)/foo.o\n \t$(RUSTC) foo.rs -lfoo -lstdc++\n \t$(call RUN,foo)\n else"}, {"sha": "edf88a6327cd2e128779935a33a2420d8d113cb9", "filename": "src/test/run-make/inline-always-many-cgu/Makefile", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Finline-always-many-cgu%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Finline-always-many-cgu%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Finline-always-many-cgu%2FMakefile?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -0,0 +1,8 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) foo.rs --emit llvm-ir -C codegen-units=2\n+\tif grep -w call $(TMPDIR)/*.ll; then \\\n+\t\techo \"found call instruction when one wasn't expected\"; \\\n+\t\texit 1; \\\n+\tfi"}, {"sha": "539dcdfa9b30b7bfff5f4e7a372b465df0e4f876", "filename": "src/test/run-make/inline-always-many-cgu/foo.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Finline-always-many-cgu%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Finline-always-many-cgu%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Finline-always-many-cgu%2Ffoo.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+\n+pub mod a {\n+    #[inline(always)]\n+    pub fn foo() {\n+    }\n+\n+    pub fn bar() {\n+    }\n+}\n+\n+#[no_mangle]\n+pub fn bar() {\n+    a::foo();\n+}"}, {"sha": "5c9cc9935099f55efecea3971289169f27b926c0", "filename": "src/test/run-make/invalid-library/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Finvalid-library%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Finvalid-library%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Finvalid-library%2FMakefile?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -2,5 +2,5 @@\n \n all:\n \ttouch $(TMPDIR)/rust.metadata.bin\n-\tar crus $(TMPDIR)/libfoo-ffffffff-1.0.rlib $(TMPDIR)/rust.metadata.bin\n+\t$(AR) crus $(TMPDIR)/libfoo-ffffffff-1.0.rlib $(TMPDIR)/rust.metadata.bin\n \t$(RUSTC) foo.rs 2>&1 | grep \"can't find crate for\""}, {"sha": "4db027aaeef7150632f058e02da47e7a29f6dc87", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -18,7 +18,6 @@ extern crate rustc_errors;\n extern crate rustc_trans;\n extern crate syntax;\n \n-use rustc::dep_graph::DepGraph;\n use rustc::session::{build_session, Session};\n use rustc::session::config::{basic_options, build_configuration, Input,\n                              OutputType, OutputTypes};\n@@ -56,6 +55,9 @@ fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>) {\n     let mut opts = basic_options();\n     opts.output_types = OutputTypes::new(&[(OutputType::Exe, None)]);\n     opts.maybe_sysroot = Some(sysroot);\n+    if let Ok(linker) = std::env::var(\"RUSTC_LINKER\") {\n+        opts.cg.linker = Some(linker);\n+    }\n \n     let descriptions = Registry::new(&rustc::DIAGNOSTICS);\n     let cstore = Rc::new(CStore::new(Box::new(rustc_trans::LlvmMetadataLoader)));\n@@ -67,8 +69,7 @@ fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>) {\n \n fn compile(code: String, output: PathBuf, sysroot: PathBuf) {\n     let (sess, cstore) = basic_sess(sysroot);\n-    let cfg = build_configuration(&sess, HashSet::new());\n     let control = CompileController::basic();\n     let input = Input::Str { name: anon_src(), input: code };\n-    compile_input(&sess, &cstore, &input, &None, &Some(output), None, &control);\n+    let _ = compile_input(&sess, &cstore, &input, &None, &Some(output), None, &control);\n }"}, {"sha": "cb4f14627334876917a6702826dea3271fe1ce70", "filename": "src/test/run-make/issue-22131/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Fissue-22131%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Fissue-22131%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-22131%2FMakefile?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -2,6 +2,6 @@\n \n all: foo.rs\n \t$(RUSTC) --cfg 'feature=\"bar\"' --crate-type lib foo.rs\n-\t$(HOST_RPATH_ENV) '$(RUSTDOC)' --test --cfg 'feature=\"bar\"' \\\n+\t$(RUSTDOC) --test --cfg 'feature=\"bar\"' \\\n \t\t-L $(TMPDIR) foo.rs |\\\n \t\tgrep -q 'foo.rs - foo (line 11) ... ok'"}, {"sha": "8ce1c699526cd1b9e4c49aa2627bf5650e95b63f", "filename": "src/test/run-make/rustdoc-output-path/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Frustdoc-output-path%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Frustdoc-output-path%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-output-path%2FMakefile?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -1,4 +1,4 @@\n -include ../tools.mk\n \n all:\n-\t$(HOST_RPATH_ENV) '$(RUSTDOC)' -o \"$(TMPDIR)/foo/bar/doc\" foo.rs\n+\t$(RUSTDOC) -o \"$(TMPDIR)/foo/bar/doc\" foo.rs"}, {"sha": "ccd4e1b0e715a9f72cbabc15bedcf8aea1159fb5", "filename": "src/test/run-make/sepcomp-cci-copies/Makefile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Fsepcomp-cci-copies%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Fsepcomp-cci-copies%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsepcomp-cci-copies%2FMakefile?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -5,5 +5,6 @@\n \n all:\n \t$(RUSTC) cci_lib.rs\n-\t$(RUSTC) foo.rs --emit=llvm-ir -C codegen-units=3\n+\t$(RUSTC) foo.rs --emit=llvm-ir -C codegen-units=3 \\\n+\t\t-Z inline-in-all-cgus\n \t[ \"$$(cat \"$(TMPDIR)\"/foo.*.ll | grep -c define\\ .*cci_fn)\" -eq \"2\" ]"}, {"sha": "1d20d940000f4d4e4f17f18257bff61dd4a040d8", "filename": "src/test/run-make/sepcomp-inlining/Makefile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Fsepcomp-inlining%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Fsepcomp-inlining%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsepcomp-inlining%2FMakefile?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -7,7 +7,8 @@\n # in only one compilation unit.\n \n all:\n-\t$(RUSTC) foo.rs --emit=llvm-ir -C codegen-units=3\n+\t$(RUSTC) foo.rs --emit=llvm-ir -C codegen-units=3 \\\n+\t\t-Z inline-in-all-cgus\n \t[ \"$$(cat \"$(TMPDIR)\"/foo.*.ll | grep -c define\\ i32\\ .*inlined)\" -eq \"0\" ]\n \t[ \"$$(cat \"$(TMPDIR)\"/foo.*.ll | grep -c define\\ internal\\ i32\\ .*inlined)\" -eq \"2\" ]\n \t[ \"$$(cat \"$(TMPDIR)\"/foo.*.ll | grep -c define\\ hidden\\ i32\\ .*normal)\" -eq \"1\" ]"}, {"sha": "92a278825c242941a41b2af7eaf1e620d22c7ce3", "filename": "src/test/run-make/staticlib-blank-lib/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Fstaticlib-blank-lib%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Fstaticlib-blank-lib%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fstaticlib-blank-lib%2FMakefile?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -1,6 +1,6 @@\n -include ../tools.mk\n \n all:\n-\tar crus $(TMPDIR)/libfoo.a foo.rs\n-\tar d $(TMPDIR)/libfoo.a foo.rs\n+\t$(AR) crus $(TMPDIR)/libfoo.a foo.rs\n+\t$(AR) d $(TMPDIR)/libfoo.a foo.rs\n \t$(RUSTC) foo.rs"}, {"sha": "5ea96daa3ef85c90cc5dfce536f1e9f444cbf166", "filename": "src/test/run-make/target-specs/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Ftarget-specs%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Ftarget-specs%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftarget-specs%2FMakefile?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -5,5 +5,5 @@ all:\n \t$(RUSTC) foo.rs --target=my-invalid-platform.json 2>&1 | grep -q \"Error loading target specification\"\n \t$(RUSTC) foo.rs --target=my-incomplete-platform.json 2>&1 | grep 'Field llvm-target'\n \tRUST_TARGET_PATH=. $(RUSTC) foo.rs --target=my-awesome-platform --crate-type=lib --emit=asm\n-\tRUST_TARGET_PATH=. $(RUSTC) foo.rs --target=x86_64-unknown-linux-gnu --crate-type=lib --emit=asm\n+\tRUST_TARGET_PATH=. $(RUSTC) foo.rs --target=my-x86_64-unknown-linux-gnu-platform --crate-type=lib --emit=asm\n \t$(RUSTC) -Z unstable-options --target=my-awesome-platform.json --print target-spec-json > $(TMPDIR)/test-platform.json && $(RUSTC) -Z unstable-options --target=$(TMPDIR)/test-platform.json --print target-spec-json | diff -q $(TMPDIR)/test-platform.json -"}, {"sha": "3ae01d72fcc18c4e0f617ef535ec99b81b4f38f8", "filename": "src/test/run-make/target-specs/my-x86_64-unknown-linux-gnu-platform.json", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Ftarget-specs%2Fmy-x86_64-unknown-linux-gnu-platform.json", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Ftarget-specs%2Fmy-x86_64-unknown-linux-gnu-platform.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftarget-specs%2Fmy-x86_64-unknown-linux-gnu-platform.json?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -1,6 +1,6 @@\n {\n     \"pre-link-args\": [\"-m64\"],\n-    \"data-layout\": \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\",\n+    \"data-layout\": \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\",\n     \"linker-flavor\": \"gcc\",\n     \"llvm-target\": \"x86_64-unknown-linux-gnu\",\n     \"target-endian\": \"little\",", "previous_filename": "src/test/run-make/target-specs/x86_64-unknown-linux-gnu.json"}, {"sha": "c5d5626bf7269f41f03ab4836edbab937da21e4b", "filename": "src/test/run-make/tools.mk", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-make%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftools.mk?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -7,7 +7,13 @@ TARGET_RPATH_ENV = \\\n \n RUSTC_ORIGINAL := $(RUSTC)\n BARE_RUSTC := $(HOST_RPATH_ENV) '$(RUSTC)'\n+BARE_RUSTDOC := $(HOST_RPATH_ENV) '$(RUSTDOC)'\n RUSTC := $(BARE_RUSTC) --out-dir $(TMPDIR) -L $(TMPDIR) $(RUSTFLAGS)\n+RUSTDOC := $(BARE_RUSTDOC)\n+ifdef RUSTC_LINKER\n+RUSTC := $(RUSTC) -Clinker=$(RUSTC_LINKER)\n+RUSTDOC := $(RUSTDOC) --linker $(RUSTC_LINKER) -Z unstable-options\n+endif\n #CC := $(CC) -L $(TMPDIR)\n HTMLDOCCK := $(PYTHON) $(S)/src/etc/htmldocck.py\n \n@@ -102,13 +108,13 @@ REMOVE_DYLIBS     = rm $(TMPDIR)/$(call DYLIB_GLOB,$(1))\n REMOVE_RLIBS      = rm $(TMPDIR)/$(call RLIB_GLOB,$(1))\n \n %.a: %.o\n-\tar crus $@ $<\n+\t$(AR) crus $@ $<\n ifdef IS_MSVC\n %.lib: lib%.o\n \t$(MSVC_LIB) -out:`cygpath -w $@` $<\n else\n %.lib: lib%.o\n-\tar crus $@ $<\n+\t$(AR) crus $@ $<\n endif\n %.dylib: %.o\n \t$(CC) -dynamiclib -Wl,-dylib -o $@ $<"}, {"sha": "f9233026a1e6e2628a841faf01aec2f14c5607ce", "filename": "src/test/run-pass/backtrace-debuginfo.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -19,8 +19,6 @@\n // ignore-pretty issue #37195\n // ignore-emscripten spawning processes is not supported\n \n-use std::io;\n-use std::io::prelude::*;\n use std::env;\n \n #[path = \"backtrace-debuginfo-aux.rs\"] mod aux;\n@@ -163,7 +161,7 @@ fn main() {\n     let args: Vec<String> = env::args().collect();\n     if args.len() >= 2 {\n         let case = args[1].parse().unwrap();\n-        writeln!(&mut io::stderr(), \"test case {}\", case).unwrap();\n+        eprintln!(\"test case {}\", case);\n         outer(case, pos!());\n         println!(\"done.\");\n     } else {"}, {"sha": "91930852a57f64c9f489002c47159346ceb7b975", "filename": "src/test/run-pass/dyn-trait.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fdyn-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fdyn-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdyn-trait.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(dyn_trait)]\n+\n+use std::fmt::Display;\n+\n+static BYTE: u8 = 33;\n+\n+fn main() {\n+    let x: &(dyn 'static + Display) = &BYTE;\n+    let y: Box<dyn Display + 'static> = Box::new(BYTE);\n+    let xstr = format!(\"{}\", x);\n+    let ystr = format!(\"{}\", y);\n+    assert_eq!(xstr, \"33\");\n+    assert_eq!(ystr, \"33\");\n+}"}, {"sha": "88358eff08d05c773f63f24e35865cd716adef6f", "filename": "src/test/run-pass/issue-35600.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fissue-35600.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fissue-35600.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-35600.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {\n+    type bar;\n+    fn bar();\n+}\n+\n+impl Foo for () {\n+    type bar = ();\n+    fn bar() {}\n+}\n+\n+fn main() {\n+    let x: <() as Foo>::bar = ();\n+    <()>::bar();\n+}"}, {"sha": "27b0aeaac5599a36017d021b3f201bdfe58db1ff", "filename": "src/test/run-pass/issue-44247.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fissue-44247.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fissue-44247.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-44247.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait T {\n+    type X;\n+    const X: Self::X;\n+}\n+fn foo<X: T>() {\n+    let _: X::X = X::X;\n+}\n+\n+trait S {\n+    const X: Self::X;\n+    type X;\n+}\n+fn bar<X: S>() {\n+    let _: X::X = X::X;\n+}\n+\n+fn main() {}"}, {"sha": "bcbd3fd3786ab4555da1b24961e880db5728d7b6", "filename": "src/test/run-pass/smallest-hello-world.rs", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/49a73d0901a60b1b77452b92372fd8629f636c2a/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a73d0901a60b1b77452b92372fd8629f636c2a/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs?ref=49a73d0901a60b1b77452b92372fd8629f636c2a", "patch": "@@ -1,41 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Smallest \"hello world\" with a libc runtime\n-\n-// ignore-windows\n-// ignore-android\n-\n-#![feature(intrinsics, lang_items, start, no_core, alloc_system)]\n-#![feature(global_allocator, allocator_api)]\n-#![no_std]\n-\n-extern crate alloc_system;\n-\n-use alloc_system::System;\n-\n-#[global_allocator]\n-static A: System = System;\n-\n-extern {\n-    fn puts(s: *const u8);\n-}\n-\n-#[no_mangle]\n-#[lang = \"eh_personality\"] pub extern fn rust_eh_personality() {}\n-#[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n-\n-#[start]\n-fn main(_: isize, _: *const *const u8) -> isize {\n-    unsafe {\n-        puts(\"Hello!\\0\".as_ptr() as *const u8);\n-    }\n-    return 0\n-}"}, {"sha": "6b999f3835835af47943f4f065fafc89bca17aed", "filename": "src/test/run-pass/specialization/defaultimpl/allowed-cross-crate.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fallowed-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fallowed-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fallowed-cross-crate.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "previous_filename": "src/test/run-pass/specialization/defaultimpl/specialization-allowed-cross-crate.rs"}, {"sha": "b99ba3d0f1c931987f4e5ec228c085eea8481568", "filename": "src/test/run-pass/specialization/defaultimpl/assoc-fns.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fassoc-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fassoc-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fassoc-fns.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "previous_filename": "src/test/run-pass/specialization/defaultimpl/specialization-assoc-fns.rs"}, {"sha": "71dd7c99009ea5a0920c0e35bf943e69c4316b55", "filename": "src/test/run-pass/specialization/defaultimpl/auxiliary/cross_crate.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fauxiliary%2Fcross_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fauxiliary%2Fcross_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fauxiliary%2Fcross_crate.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "previous_filename": "src/test/run-pass/specialization/defaultimpl/auxiliary/specialization_cross_crate.rs"}, {"sha": "9d0ea64fed428d6cefe7beb02a8ddd0ee5f1ad4d", "filename": "src/test/run-pass/specialization/defaultimpl/auxiliary/cross_crate_defaults.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fauxiliary%2Fcross_crate_defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fauxiliary%2Fcross_crate_defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fauxiliary%2Fcross_crate_defaults.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "previous_filename": "src/test/run-pass/specialization/defaultimpl/auxiliary/specialization_cross_crate_defaults.rs"}, {"sha": "7daecc842f3f9fd8a2140a3785db00b2f34cbffc", "filename": "src/test/run-pass/specialization/defaultimpl/basics-unsafe.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fbasics-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fbasics-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fbasics-unsafe.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "previous_filename": "src/test/run-pass/specialization/defaultimpl/specialization-basics-unsafe.rs"}, {"sha": "594f1e4fcdfc26b834c9bea5f57cd3482653b6d0", "filename": "src/test/run-pass/specialization/defaultimpl/basics.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fbasics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fbasics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fbasics.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "previous_filename": "src/test/run-pass/specialization/defaultimpl/specialization-basics.rs"}, {"sha": "19e1af15bdd5627ce8bd0f7dc7f5e26e716d21f8", "filename": "src/test/run-pass/specialization/defaultimpl/cross-crate-defaults.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fcross-crate-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fcross-crate-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fcross-crate-defaults.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// aux-build:specialization_cross_crate_defaults.rs\n+// aux-build:cross_crate_defaults.rs\n \n #![feature(specialization)]\n \n-extern crate specialization_cross_crate_defaults;\n+extern crate cross_crate_defaults;\n \n-use specialization_cross_crate_defaults::*;\n+use cross_crate_defaults::*;\n \n struct LocalDefault;\n struct LocalOverride;", "previous_filename": "src/test/run-pass/specialization/defaultimpl/specialization-cross-crate-defaults.rs"}, {"sha": "67cc694ae12c7087121c76cacbf2a749273923a5", "filename": "src/test/run-pass/specialization/defaultimpl/cross-crate-no-gate.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fcross-crate-no-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fcross-crate-no-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fcross-crate-no-gate.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -10,11 +10,11 @@\n \n // Test that specialization works even if only the upstream crate enables it\n \n-// aux-build:specialization_cross_crate.rs\n+// aux-build:cross_crate.rs\n \n-extern crate specialization_cross_crate;\n+extern crate cross_crate;\n \n-use specialization_cross_crate::*;\n+use cross_crate::*;\n \n fn  main() {\n     assert!(0u8.foo() == \"generic Clone\");", "previous_filename": "src/test/run-pass/specialization/defaultimpl/specialization-cross-crate-no-gate.rs"}, {"sha": "f1ad105db8f7c2bcd49476daca8e1ac14dedfbf0", "filename": "src/test/run-pass/specialization/defaultimpl/cross-crate.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fcross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fcross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fcross-crate.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// aux-build:specialization_cross_crate.rs\n+// aux-build:cross_crate.rs\n \n #![feature(specialization)]\n \n-extern crate specialization_cross_crate;\n+extern crate cross_crate;\n \n-use specialization_cross_crate::*;\n+use cross_crate::*;\n \n struct NotClone;\n ", "previous_filename": "src/test/run-pass/specialization/defaultimpl/specialization-cross-crate.rs"}, {"sha": "4ac9afc1c897fa27e4fcfe357475985563a4f588", "filename": "src/test/run-pass/specialization/defaultimpl/default-methods.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fdefault-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fdefault-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fdefault-methods.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "previous_filename": "src/test/run-pass/specialization/defaultimpl/specialization-default-methods.rs"}, {"sha": "f77b88e2f850ae622b604f8840e15e4ff0619896", "filename": "src/test/run-pass/specialization/defaultimpl/out-of-order.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fout-of-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fout-of-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Fout-of-order.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "previous_filename": "src/test/run-pass/specialization/defaultimpl/specialization-out-of-order.rs"}, {"sha": "500cded38c1adfc154a6dae17960e514c2d2d06c", "filename": "src/test/run-pass/specialization/defaultimpl/overlap-projection.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Foverlap-projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8497884c2863a10b6d67855bd90d40783ce2da/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Foverlap-projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fdefaultimpl%2Foverlap-projection.rs?ref=bd8497884c2863a10b6d67855bd90d40783ce2da", "previous_filename": "src/test/run-pass/specialization/defaultimpl/specialization-overlap-projection.rs"}]}