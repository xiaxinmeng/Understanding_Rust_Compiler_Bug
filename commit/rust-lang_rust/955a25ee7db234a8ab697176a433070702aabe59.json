{"sha": "955a25ee7db234a8ab697176a433070702aabe59", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1NWEyNWVlN2RiMjM0YThhYjY5NzE3NmE0MzMwNzA3MDJhYWJlNTk=", "commit": {"author": {"name": "JarredAllen", "email": "jarredallen73@gmail.com", "date": "2020-05-20T16:23:00Z"}, "committer": {"name": "JarredAllen", "email": "jarredallen73@gmail.com", "date": "2020-05-31T18:55:45Z"}, "message": "Added negative test cases and ran cargo dev fmt", "tree": {"sha": "2180b6ae29426fd82193f6038ee7f4c497e1c1eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2180b6ae29426fd82193f6038ee7f4c497e1c1eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/955a25ee7db234a8ab697176a433070702aabe59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/955a25ee7db234a8ab697176a433070702aabe59", "html_url": "https://github.com/rust-lang/rust/commit/955a25ee7db234a8ab697176a433070702aabe59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/955a25ee7db234a8ab697176a433070702aabe59/comments", "author": {"login": "JarredAllen", "id": 19656507, "node_id": "MDQ6VXNlcjE5NjU2NTA3", "avatar_url": "https://avatars.githubusercontent.com/u/19656507?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JarredAllen", "html_url": "https://github.com/JarredAllen", "followers_url": "https://api.github.com/users/JarredAllen/followers", "following_url": "https://api.github.com/users/JarredAllen/following{/other_user}", "gists_url": "https://api.github.com/users/JarredAllen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JarredAllen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JarredAllen/subscriptions", "organizations_url": "https://api.github.com/users/JarredAllen/orgs", "repos_url": "https://api.github.com/users/JarredAllen/repos", "events_url": "https://api.github.com/users/JarredAllen/events{/privacy}", "received_events_url": "https://api.github.com/users/JarredAllen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JarredAllen", "id": 19656507, "node_id": "MDQ6VXNlcjE5NjU2NTA3", "avatar_url": "https://avatars.githubusercontent.com/u/19656507?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JarredAllen", "html_url": "https://github.com/JarredAllen", "followers_url": "https://api.github.com/users/JarredAllen/followers", "following_url": "https://api.github.com/users/JarredAllen/following{/other_user}", "gists_url": "https://api.github.com/users/JarredAllen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JarredAllen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JarredAllen/subscriptions", "organizations_url": "https://api.github.com/users/JarredAllen/orgs", "repos_url": "https://api.github.com/users/JarredAllen/repos", "events_url": "https://api.github.com/users/JarredAllen/events{/privacy}", "received_events_url": "https://api.github.com/users/JarredAllen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "943cb94dce8fca6f3a3f7f011a2a2f9f0a665b97", "url": "https://api.github.com/repos/rust-lang/rust/commits/943cb94dce8fca6f3a3f7f011a2a2f9f0a665b97", "html_url": "https://github.com/rust-lang/rust/commit/943cb94dce8fca6f3a3f7f011a2a2f9f0a665b97"}], "stats": {"total": 145, "additions": 100, "deletions": 45}, "files": [{"sha": "ea850955db1210b0ccd22cc459f4c9e40e432206", "filename": "clippy_lints/src/sort_by_key_reverse.rs", "status": "modified", "additions": 83, "deletions": 42, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/955a25ee7db234a8ab697176a433070702aabe59/clippy_lints%2Fsrc%2Fsort_by_key_reverse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955a25ee7db234a8ab697176a433070702aabe59/clippy_lints%2Fsrc%2Fsort_by_key_reverse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsort_by_key_reverse.rs?ref=955a25ee7db234a8ab697176a433070702aabe59", "patch": "@@ -3,7 +3,7 @@ use crate::utils::paths;\n use crate::utils::sugg::Sugg;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::*;\n+use rustc_hir::{Expr, ExprKind, Mutability, Param, Pat, PatKind, Path, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::Ident;\n@@ -43,64 +43,105 @@ struct LintTrigger {\n \n /// Detect if the two expressions are mirrored (identical, except one\n /// contains a and the other replaces it with b)\n-fn mirrored_exprs(cx: &LateContext<'_, '_>, a_expr: &Expr<'_>, a_ident: &Ident, b_expr: &Expr<'_>, b_ident: &Ident) -> bool {\n+fn mirrored_exprs(\n+    cx: &LateContext<'_, '_>,\n+    a_expr: &Expr<'_>,\n+    a_ident: &Ident,\n+    b_expr: &Expr<'_>,\n+    b_ident: &Ident,\n+) -> bool {\n     match (&a_expr.kind, &b_expr.kind) {\n         // Two boxes with mirrored contents\n-        (ExprKind::Box(left_expr), ExprKind::Box(right_expr)) => mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident),\n+        (ExprKind::Box(left_expr), ExprKind::Box(right_expr)) => {\n+            mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident)\n+        },\n         // Two arrays with mirrored contents\n-        (ExprKind::Array(left_exprs), ExprKind::Array(right_exprs))\n-            => left_exprs.iter().zip(right_exprs.iter()).all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident)),\n+        (ExprKind::Array(left_exprs), ExprKind::Array(right_exprs)) => left_exprs\n+            .iter()\n+            .zip(right_exprs.iter())\n+            .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident)),\n         // The two exprs are function calls.\n         // Check to see that the function itself and its arguments are mirrored\n-        (ExprKind::Call(left_expr, left_args), ExprKind::Call(right_expr, right_args))\n-            => {\n-                // println!(\"{:?}\\n{:?}\\n\", left_expr, left_args);\n-                // println!(\"{:?}\\n{:?}\\n\", right_expr, right_args);\n-                mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident)\n-                && left_args.iter().zip(right_args.iter()).all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n-            },\n+        (ExprKind::Call(left_expr, left_args), ExprKind::Call(right_expr, right_args)) => {\n+            mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident)\n+                && left_args\n+                    .iter()\n+                    .zip(right_args.iter())\n+                    .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n+        },\n         // The two exprs are method calls.\n         // Check to see that the function is the same and the arguments are mirrored\n         // This is enough because the receiver of the method is listed in the arguments\n-        (ExprKind::MethodCall(left_segment, _, left_args), ExprKind::MethodCall(right_segment, _, right_args))\n-            => left_segment.ident == right_segment.ident\n-                && left_args.iter().zip(right_args.iter()).all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident)),\n+        (ExprKind::MethodCall(left_segment, _, left_args), ExprKind::MethodCall(right_segment, _, right_args)) => {\n+            left_segment.ident == right_segment.ident\n+                && left_args\n+                    .iter()\n+                    .zip(right_args.iter())\n+                    .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n+        },\n         // Two tuples with mirrored contents\n-        (ExprKind::Tup(left_exprs), ExprKind::Tup(right_exprs))\n-            => left_exprs.iter().zip(right_exprs.iter()).all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident)),\n+        (ExprKind::Tup(left_exprs), ExprKind::Tup(right_exprs)) => left_exprs\n+            .iter()\n+            .zip(right_exprs.iter())\n+            .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident)),\n         // Two binary ops, which are the same operation and which have mirrored arguments\n-        (ExprKind::Binary(left_op, left_left, left_right), ExprKind::Binary(right_op, right_left, right_right))\n-            => left_op.node == right_op.node\n+        (ExprKind::Binary(left_op, left_left, left_right), ExprKind::Binary(right_op, right_left, right_right)) => {\n+            left_op.node == right_op.node\n                 && mirrored_exprs(cx, left_left, a_ident, right_left, b_ident)\n-                && mirrored_exprs(cx, left_right, a_ident, right_right, b_ident),\n+                && mirrored_exprs(cx, left_right, a_ident, right_right, b_ident)\n+        },\n         // Two unary ops, which are the same operation and which have the same argument\n-        (ExprKind::Unary(left_op, left_expr), ExprKind::Unary(right_op, right_expr))\n-            => left_op == right_op && mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident),\n+        (ExprKind::Unary(left_op, left_expr), ExprKind::Unary(right_op, right_expr)) => {\n+            left_op == right_op && mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident)\n+        },\n         // The two exprs are literals of some kind\n         (ExprKind::Lit(left_lit), ExprKind::Lit(right_lit)) => left_lit.node == right_lit.node,\n-        (ExprKind::Cast(left_expr, left_ty), ExprKind::Cast(right_expr, right_ty))\n-            => mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident),\n-        (ExprKind::DropTemps(left), ExprKind::DropTemps(right)) => mirrored_exprs(cx, left, a_ident, right, b_ident),\n-        (ExprKind::Field(left_expr, left_ident), ExprKind::Field(right_expr, right_ident))\n-            => left_ident.name == right_ident.name && mirrored_exprs(cx, left_expr, a_ident, right_expr, right_ident),\n+        (ExprKind::Cast(left, _), ExprKind::Cast(right, _)) => mirrored_exprs(cx, left, a_ident, right, b_ident),\n+        (ExprKind::DropTemps(left_block), ExprKind::DropTemps(right_block)) => {\n+            mirrored_exprs(cx, left_block, a_ident, right_block, b_ident)\n+        },\n+        (ExprKind::Field(left_expr, left_ident), ExprKind::Field(right_expr, right_ident)) => {\n+            left_ident.name == right_ident.name && mirrored_exprs(cx, left_expr, a_ident, right_expr, right_ident)\n+        },\n         // Two paths: either one is a and the other is b, or they're identical to each other\n-        (ExprKind::Path(QPath::Resolved(_, Path { segments: left_segments, .. })),\n-         ExprKind::Path(QPath::Resolved(_, Path { segments: right_segments, .. })))\n-            => (left_segments.iter().zip(right_segments.iter()).all(|(left, right)| left.ident == right.ident)\n-                 && left_segments.iter().all(|seg| &seg.ident != a_ident && &seg.ident != b_ident))\n-                || (left_segments.len() == 1 && &left_segments[0].ident == a_ident && right_segments.len() == 1 && &right_segments[0].ident == b_ident),\n+        (\n+            ExprKind::Path(QPath::Resolved(\n+                _,\n+                Path {\n+                    segments: left_segments,\n+                    ..\n+                },\n+            )),\n+            ExprKind::Path(QPath::Resolved(\n+                _,\n+                Path {\n+                    segments: right_segments,\n+                    ..\n+                },\n+            )),\n+        ) => {\n+            (left_segments\n+                .iter()\n+                .zip(right_segments.iter())\n+                .all(|(left, right)| left.ident == right.ident)\n+                && left_segments\n+                    .iter()\n+                    .all(|seg| &seg.ident != a_ident && &seg.ident != b_ident))\n+                || (left_segments.len() == 1\n+                    && &left_segments[0].ident == a_ident\n+                    && right_segments.len() == 1\n+                    && &right_segments[0].ident == b_ident)\n+        },\n         // Matching expressions, but one or both is borrowed\n-        (ExprKind::AddrOf(left_kind, Mutability::Not, left_expr), ExprKind::AddrOf(right_kind, Mutability::Not, right_expr))\n-            => left_kind == right_kind && mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident),\n-        (_, ExprKind::AddrOf(_, Mutability::Not, right_expr))\n-            => mirrored_exprs(cx, a_expr, a_ident, right_expr, b_ident),\n-        (ExprKind::AddrOf(_, Mutability::Not, left_expr), _)\n-            => mirrored_exprs(cx, left_expr, a_ident, b_expr, b_ident),\n+        (\n+            ExprKind::AddrOf(left_kind, Mutability::Not, left_expr),\n+            ExprKind::AddrOf(right_kind, Mutability::Not, right_expr),\n+        ) => left_kind == right_kind && mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident),\n+        (_, ExprKind::AddrOf(_, Mutability::Not, right_expr)) => {\n+            mirrored_exprs(cx, a_expr, a_ident, right_expr, b_ident)\n+        },\n+        (ExprKind::AddrOf(_, Mutability::Not, left_expr), _) => mirrored_exprs(cx, left_expr, a_ident, b_expr, b_ident),\n         _ => false,\n-        // (left, right) => {\n-            // println!(\"{:?}\\n{:?}\", left, right);\n-            // false\n-        // },\n     }\n }\n "}, {"sha": "722675a6b71a82a0de314134974d594eca4df892", "filename": "tests/ui/sort_by_key_reverse.fixed", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/955a25ee7db234a8ab697176a433070702aabe59/tests%2Fui%2Fsort_by_key_reverse.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/955a25ee7db234a8ab697176a433070702aabe59/tests%2Fui%2Fsort_by_key_reverse.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsort_by_key_reverse.fixed?ref=955a25ee7db234a8ab697176a433070702aabe59", "patch": "@@ -12,4 +12,11 @@ fn main() {\n     vec.sort_by_key(|&b| Reverse(b));\n     vec.sort_by_key(|&b| Reverse((b + 5).abs()));\n     vec.sort_by_key(|&b| Reverse(id(-b)));\n+    // Negative examples (shouldn't be changed)\n+    let c = &7;\n+    vec.sort_by(|a, b| (b - a).cmp(&(a - b)));\n+    vec.sort_by(|_, b| b.cmp(&5));\n+    vec.sort_by(|_, b| b.cmp(c));\n+    vec.sort_by(|a, _| a.cmp(c));\n+    vec.sort_by(|a, b| a.cmp(b));\n }"}, {"sha": "601621ffa9f86f053f30608730f951b646472684", "filename": "tests/ui/sort_by_key_reverse.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/955a25ee7db234a8ab697176a433070702aabe59/tests%2Fui%2Fsort_by_key_reverse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955a25ee7db234a8ab697176a433070702aabe59/tests%2Fui%2Fsort_by_key_reverse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsort_by_key_reverse.rs?ref=955a25ee7db234a8ab697176a433070702aabe59", "patch": "@@ -10,6 +10,13 @@ fn id(x: isize) -> isize {\n fn main() {\n     let mut vec: Vec<isize> = vec![3, 6, 1, 2, 5];\n     vec.sort_by(|a, b| b.cmp(a));\n-    vec.sort_by(|a, b| (b + 5).abs().cmp(&(a+5).abs()));\n+    vec.sort_by(|a, b| (b + 5).abs().cmp(&(a + 5).abs()));\n     vec.sort_by(|a, b| id(-b).cmp(&id(-a)));\n+    // Negative examples (shouldn't be changed)\n+    let c = &7;\n+    vec.sort_by(|a, b| (b - a).cmp(&(a - b)));\n+    vec.sort_by(|_, b| b.cmp(&5));\n+    vec.sort_by(|_, b| b.cmp(c));\n+    vec.sort_by(|a, _| a.cmp(c));\n+    vec.sort_by(|a, b| a.cmp(b));\n }"}, {"sha": "b757c8a6176d117994a9ee4726dc80e5ba704e92", "filename": "tests/ui/sort_by_key_reverse.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/955a25ee7db234a8ab697176a433070702aabe59/tests%2Fui%2Fsort_by_key_reverse.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/955a25ee7db234a8ab697176a433070702aabe59/tests%2Fui%2Fsort_by_key_reverse.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsort_by_key_reverse.stderr?ref=955a25ee7db234a8ab697176a433070702aabe59", "patch": "@@ -9,8 +9,8 @@ LL |     vec.sort_by(|a, b| b.cmp(a));\n error: use Vec::sort_by_key here instead\n   --> $DIR/sort_by_key_reverse.rs:13:5\n    |\n-LL |     vec.sort_by(|a, b| (b + 5).abs().cmp(&(a+5).abs()));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|&b| Reverse((b + 5).abs()))`\n+LL |     vec.sort_by(|a, b| (b + 5).abs().cmp(&(a + 5).abs()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|&b| Reverse((b + 5).abs()))`\n \n error: use Vec::sort_by_key here instead\n   --> $DIR/sort_by_key_reverse.rs:14:5"}]}