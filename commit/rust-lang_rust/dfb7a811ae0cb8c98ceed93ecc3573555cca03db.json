{"sha": "dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmYjdhODExYWUwY2I4Yzk4Y2VlZDkzZWNjMzU3MzU1NWNjYTAzZGI=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2014-11-07T19:35:18Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2014-11-16T15:40:25Z"}, "message": "fallout from deprecating find_copy and get_copy", "tree": {"sha": "08c6e3fe2ad4bfcfcb4c9454185e90d65f9703c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08c6e3fe2ad4bfcfcb4c9454185e90d65f9703c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "comment_count": 13, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "html_url": "https://github.com/rust-lang/rust/commit/dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64efd2650c22ab508caf191b6f9055463a7a74c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/64efd2650c22ab508caf191b6f9055463a7a74c4", "html_url": "https://github.com/rust-lang/rust/commit/64efd2650c22ab508caf191b6f9055463a7a74c4"}], "stats": {"total": 186, "additions": 92, "deletions": 94}, "files": [{"sha": "c2bb702d5c0ac94c151e2dce411867637886cf7e", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -391,7 +391,7 @@ struct ImproperCTypesVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     fn check_def(&mut self, sp: Span, ty_id: ast::NodeId, path_id: ast::NodeId) {\n-        match self.cx.tcx.def_map.borrow().get_copy(&path_id) {\n+        match self.cx.tcx.def_map.borrow()[path_id].clone() {\n             def::DefPrimTy(ast::TyInt(ast::TyI)) => {\n                 self.cx.span_lint(IMPROPER_CTYPES, sp,\n                                   \"found rust type `int` in foreign module, while \\\n@@ -866,7 +866,7 @@ fn method_context(cx: &Context, m: &ast::Method) -> MethodContext {\n         node: m.id\n     };\n \n-    match cx.tcx.impl_or_trait_items.borrow().find_copy(&did) {\n+    match cx.tcx.impl_or_trait_items.borrow().get(&did).cloned() {\n         None => cx.sess().span_bug(m.span, \"missing method descriptor?!\"),\n         Some(md) => {\n             match md {"}, {"sha": "322191701e29012dda6374964a43f04e4c9648a4", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -1863,7 +1863,7 @@ impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'b, 'c, 'tcx> {\n         match item.node {\n             ItemImpl(_, Some(ref trait_ref), _, _) => {\n                 let def_map = &self.ecx.tcx.def_map;\n-                let trait_def = def_map.borrow().get_copy(&trait_ref.ref_id);\n+                let trait_def = def_map.borrow()[trait_ref.ref_id].clone();\n                 let def_id = trait_def.def_id();\n \n                 // Load eagerly if this is an implementation of the Drop trait"}, {"sha": "364cc298e8cbd9c0522b12a2273dd45b2070d3bc", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -440,7 +440,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n                                          pos: pos,\n                                          len: len };\n \n-        match st.tcx.rcache.borrow().find_copy(&key) {\n+        match st.tcx.rcache.borrow().get(&key).cloned() {\n           Some(tt) => return tt,\n           None => {}\n         }"}, {"sha": "e20a7901e656a763692911ec632971d7433089b8", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -1200,8 +1200,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                                 var_id: var_id,\n                                 closure_expr_id: id\n                             };\n-                            let upvar_borrow = tcx.upvar_borrow_map.borrow()\n-                                                  .get_copy(&upvar_id);\n+                            let upvar_borrow = tcx.upvar_borrow_map.borrow()[upvar_id].clone();\n                             var_id.encode(rbml_w);\n                             upvar_borrow.encode(rbml_w);\n                         })"}, {"sha": "b38246647d6d55a9d1a556c6c372d01453c04e89", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -295,7 +295,7 @@ impl MoveData {\n \n     fn existing_move_path(&self, lp: &Rc<LoanPath>)\n                           -> Option<MovePathIndex> {\n-        self.path_map.borrow().find_copy(lp)\n+        self.path_map.borrow().get(lp).cloned()\n     }\n \n     fn existing_base_paths(&self, lp: &Rc<LoanPath>)\n@@ -312,7 +312,7 @@ impl MoveData {\n          * paths of `lp` to `result`, but does not add new move paths\n          */\n \n-        match self.path_map.borrow().find_copy(lp) {\n+        match self.path_map.borrow().get(lp).cloned() {\n             Some(index) => {\n                 self.each_base_path(index, |p| {\n                     result.push(p);"}, {"sha": "74a438190fa867d528d9e4a5e0918990bd80869b", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -360,7 +360,7 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n     fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n         match pat.node {\n             PatIdent(..) | PatEnum(..) => {\n-                let def = self.tcx.def_map.borrow().find_copy(&pat.id);\n+                let def = self.tcx.def_map.borrow().get(&pat.id).cloned();\n                 match def {\n                     Some(DefConst(did)) => match lookup_const_by_id(self.tcx, did) {\n                         Some(const_expr) => {\n@@ -753,7 +753,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             Some(Vec::from_elem(arity, DUMMY_WILD_PAT)),\n \n         &PatIdent(_, _, _) => {\n-            let opt_def = cx.tcx.def_map.borrow().find_copy(&pat_id);\n+            let opt_def = cx.tcx.def_map.borrow().get(&pat_id).cloned();\n             match opt_def {\n                 Some(DefConst(..)) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n@@ -768,7 +768,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         }\n \n         &PatEnum(_, ref args) => {\n-            let def = cx.tcx.def_map.borrow().get_copy(&pat_id);\n+            let def = cx.tcx.def_map.borrow()[pat_id].clone();\n             match def {\n                 DefConst(..) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n@@ -786,7 +786,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n \n         &PatStruct(_, ref pattern_fields, _) => {\n             // Is this a struct or an enum variant?\n-            let def = cx.tcx.def_map.borrow().get_copy(&pat_id);\n+            let def = cx.tcx.def_map.borrow()[pat_id].clone();\n             let class_id = match def {\n                 DefConst(..) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\"}, {"sha": "1a3267492d2a99340256601a3510b65e876a4fc5", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -85,7 +85,7 @@ pub fn join_all<It: Iterator<constness>>(mut cs: It) -> constness {\n }\n \n fn lookup_const<'a>(tcx: &'a ty::ctxt, e: &Expr) -> Option<&'a Expr> {\n-    let opt_def = tcx.def_map.borrow().find_copy(&e.id);\n+    let opt_def = tcx.def_map.borrow().get(&e.id).cloned();\n     match opt_def {\n         Some(def::DefConst(def_id)) => {\n             lookup_const_by_id(tcx, def_id)\n@@ -321,7 +321,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<Pat> {\n             PatTup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr)).collect()),\n \n         ExprCall(ref callee, ref args) => {\n-            let def = tcx.def_map.borrow().get_copy(&callee.id);\n+            let def = tcx.def_map.borrow()[callee.id].clone();\n             match tcx.def_map.borrow_mut().entry(expr.id) {\n               Vacant(entry) => { entry.set(def); }\n               _ => {}\n@@ -353,7 +353,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<Pat> {\n         }\n \n         ExprPath(ref path) => {\n-            let opt_def = tcx.def_map.borrow().find_copy(&expr.id);\n+            let opt_def = tcx.def_map.borrow().get(&expr.id).cloned();\n             match opt_def {\n                 Some(def::DefStruct(..)) =>\n                     PatStruct(path.clone(), vec![], false),"}, {"sha": "16e8adb8adf89b59ec09aabfad948c06d92e344c", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -850,7 +850,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n \n                 // Each match binding is effectively an assignment to the\n                 // binding being produced.\n-                let def = def_map.borrow().get_copy(&pat.id);\n+                let def = def_map.borrow()[pat.id].clone();\n                 match mc.cat_def(pat.id, pat.span, pat_ty, def) {\n                     Ok(binding_cmt) => {\n                         delegate.mutate(pat.id, pat.span, binding_cmt, Init);\n@@ -957,8 +957,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n             // inferred by regionbk\n             let upvar_id = ty::UpvarId { var_id: id_var,\n                                          closure_expr_id: closure_expr.id };\n-            let upvar_borrow = self.tcx().upvar_borrow_map.borrow()\n-                                   .get_copy(&upvar_id);\n+            let upvar_borrow = self.tcx().upvar_borrow_map.borrow()[upvar_id].clone();\n \n             self.delegate.borrow(closure_expr.id,\n                                  closure_expr.span,"}, {"sha": "d1f78cf0417018e6be6d6d6d54283e3fad3dc694", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -449,7 +449,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       ExprPath(_) => {\n-        let def = ir.tcx.def_map.borrow().get_copy(&expr.id);\n+        let def = ir.tcx.def_map.borrow()[expr.id].clone();\n         debug!(\"expr {}: path that leads to {}\", expr.id, def);\n         match def {\n             DefLocal(..) => ir.add_live_node_for_node(expr.id, ExprNode(expr.span)),\n@@ -1316,7 +1316,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn access_path(&mut self, expr: &Expr, succ: LiveNode, acc: uint)\n                    -> LiveNode {\n-        match self.ir.tcx.def_map.borrow().get_copy(&expr.id) {\n+        match self.ir.tcx.def_map.borrow()[expr.id].clone() {\n           DefLocal(nid) => {\n             let ln = self.live_node(expr.id, expr.span);\n             if acc != 0u {\n@@ -1582,7 +1582,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn check_lvalue(&mut self, expr: &Expr) {\n         match expr.node {\n           ExprPath(_) => {\n-            match self.ir.tcx.def_map.borrow().get_copy(&expr.id) {\n+            match self.ir.tcx.def_map.borrow()[expr.id].clone() {\n               DefLocal(nid) => {\n                 // Assignment to an immutable variable or argument: only legal\n                 // if there is no later assignment. If this local is actually"}, {"sha": "e9884d0376de1f4404a1a3f7fa791029da9a1673", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -245,7 +245,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             ast::ItemImpl(_, _, ref ty, ref impl_items) => {\n                 let public_ty = match ty.node {\n                     ast::TyPath(_, _, id) => {\n-                        match self.tcx.def_map.borrow().get_copy(&id) {\n+                        match self.tcx.def_map.borrow()[id].clone() {\n                             def::DefPrimTy(..) => true,\n                             def => {\n                                 let did = def.def_id();\n@@ -313,7 +313,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             ast::ItemTy(ref ty, _) if public_first => {\n                 match ty.node {\n                     ast::TyPath(_, _, id) => {\n-                        match self.tcx.def_map.borrow().get_copy(&id) {\n+                        match self.tcx.def_map.borrow()[id].clone() {\n                             def::DefPrimTy(..) | def::DefTyParam(..) => {},\n                             def => {\n                                 let did = def.def_id();\n@@ -620,7 +620,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                             ast::TyPath(_, _, id) => id,\n                             _ => return Some((err_span, err_msg, None)),\n                         };\n-                        let def = self.tcx.def_map.borrow().get_copy(&id);\n+                        let def = self.tcx.def_map.borrow()[id].clone();\n                         let did = def.def_id();\n                         assert!(is_local(did));\n                         match self.tcx.map.get(did.node) {\n@@ -706,7 +706,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     // Checks that a path is in scope.\n     fn check_path(&mut self, span: Span, path_id: ast::NodeId, path: &ast::Path) {\n         debug!(\"privacy - path {}\", self.nodestr(path_id));\n-        let orig_def = self.tcx.def_map.borrow().get_copy(&path_id);\n+        let orig_def = self.tcx.def_map.borrow()[path_id].clone();\n         let ck = |tyname: &str| {\n             let ck_public = |def: ast::DefId| {\n                 let name = token::get_ident(path.segments\n@@ -789,7 +789,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         // def map is not. Therefore the names we work out below will not always\n         // be accurate and we can get slightly wonky error messages (but type\n         // checking is always correct).\n-        match self.tcx.def_map.borrow().get_copy(&path_id) {\n+        match self.tcx.def_map.borrow()[path_id].clone() {\n             def::DefStaticMethod(..) => ck(\"static method\"),\n             def::DefFn(..) => ck(\"function\"),\n             def::DefStatic(..) => ck(\"static\"),\n@@ -873,7 +873,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n-                        match self.tcx.def_map.borrow().get_copy(&expr.id) {\n+                        match self.tcx.def_map.borrow()[expr.id].clone() {\n                             def::DefVariant(_, variant_id, _) => {\n                                 for field in fields.iter() {\n                                     self.check_field(expr.span, variant_id,\n@@ -1254,7 +1254,7 @@ struct CheckTypeForPrivatenessVisitor<'a, 'b: 'a, 'tcx: 'b> {\n \n impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn path_is_private_type(&self, path_id: ast::NodeId) -> bool {\n-        let did = match self.tcx.def_map.borrow().find_copy(&path_id) {\n+        let did = match self.tcx.def_map.borrow().get(&path_id).cloned() {\n             // `int` etc. (None doesn't seem to occur.)\n             None | Some(def::DefPrimTy(..)) => return false,\n             Some(def) => def.def_id()"}, {"sha": "e4a6b14767f1a1391475f4cb45314346984a9788", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -1097,7 +1097,7 @@ impl<'a> Resolver<'a> {\n                                                                    sp);\n \n         // Add or reuse the child.\n-        let child = module_.children.borrow().find_copy(&name);\n+        let child = module_.children.borrow().get(&name).cloned();\n         match child {\n             None => {\n                 let child = Rc::new(NameBindings::new());\n@@ -1381,7 +1381,7 @@ impl<'a> Resolver<'a> {\n                         let mod_name = path.segments.last().unwrap().identifier.name;\n \n                         let parent_opt = parent.module().children.borrow()\n-                                               .find_copy(&mod_name);\n+                                               .get(&mod_name).cloned();\n                         let new_parent = match parent_opt {\n                             // It already exists\n                             Some(ref child) if child.get_module_if_available()\n@@ -2676,7 +2676,7 @@ impl<'a> Resolver<'a> {\n             BoundResult(..) => {}\n             _ => {\n                 match containing_module.external_module_children.borrow_mut()\n-                                       .find_copy(&source) {\n+                                       .get(&source).cloned() {\n                     None => {} // Continue.\n                     Some(module) => {\n                         debug!(\"(resolving single import) found external \\\n@@ -3191,7 +3191,7 @@ impl<'a> Resolver<'a> {\n         fn search_parent_externals(needle: Name, module: &Rc<Module>)\n                                 -> Option<Rc<Module>> {\n             module.external_module_children.borrow()\n-                                            .find_copy(&needle)\n+                                            .get(&needle).cloned()\n                                             .map(|_| module.clone())\n                                             .or_else(|| {\n                 match module.parent_link.clone() {\n@@ -3478,7 +3478,7 @@ impl<'a> Resolver<'a> {\n \n         // Search for external modules.\n         if namespace == TypeNS {\n-            match module_.external_module_children.borrow().find_copy(&name) {\n+            match module_.external_module_children.borrow().get(&name).cloned() {\n                 None => {}\n                 Some(module) => {\n                     let name_bindings =\n@@ -3763,7 +3763,7 @@ impl<'a> Resolver<'a> {\n \n         // Finally, search through external children.\n         if namespace == TypeNS {\n-            match module_.external_module_children.borrow().find_copy(&name) {\n+            match module_.external_module_children.borrow().get(&name).cloned() {\n                 None => {}\n                 Some(module) => {\n                     let name_bindings =\n@@ -4043,7 +4043,7 @@ impl<'a> Resolver<'a> {\n                             // item, it's ok\n                             match def {\n                                 DefTyParam(_, did, _) if {\n-                                    self.def_map.borrow().find_copy(&did.node)\n+                                    self.def_map.borrow().get(&did.node).cloned()\n                                         == Some(DefTyParamBinder(item_id))\n                                 } => {} // ok\n                                 DefSelfTy(did) if did == item_id => {} // ok\n@@ -4096,7 +4096,7 @@ impl<'a> Resolver<'a> {\n                             // item, it's ok\n                             match def {\n                                 DefTyParam(_, did, _) if {\n-                                    self.def_map.borrow().find_copy(&did.node)\n+                                    self.def_map.borrow().get(&did.node).cloned()\n                                         == Some(DefTyParamBinder(item_id))\n                                 } => {} // ok\n                                 DefSelfTy(did) if did == item_id => {} // ok\n@@ -4148,7 +4148,7 @@ impl<'a> Resolver<'a> {\n         // FIXME #4950: Try caching?\n \n         for (i, rib) in ribs.iter().enumerate().rev() {\n-            match rib.bindings.find_copy(&name) {\n+            match rib.bindings.get(&name).cloned() {\n                 Some(def_like) => {\n                     return self.upvarify(ribs[i + 1..], def_like, span);\n                 }\n@@ -5440,7 +5440,7 @@ impl<'a> Resolver<'a> {\n         // Finally, search through external children.\n         if namespace == TypeNS {\n             match containing_module.external_module_children.borrow()\n-                                   .find_copy(&name) {\n+                                   .get(&name).cloned() {\n                 None => {}\n                 Some(module) => {\n                     match module.def_id.get() {"}, {"sha": "49bbfd0be479a2422ec334123d3b5290b4d6e17e", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -139,7 +139,7 @@ pub fn lookup(tcx: &ty::ctxt, id: DefId) -> Option<Stability> {\n             lookup(tcx, trait_method_id)\n         }\n         _ if is_local(id) => {\n-            tcx.stability.borrow().local.find_copy(&id.node)\n+            tcx.stability.borrow().local.get(&id.node).cloned()\n         }\n         _ => {\n             let stab = csearch::get_stability(&tcx.sess.cstore, id);"}, {"sha": "46a72ae8dc0a152301b0c341c21097275d68ac5a", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -568,7 +568,7 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             ast::PatLit(ref l) => ConstantValue(ConstantExpr(&**l)),\n             ast::PatIdent(..) | ast::PatEnum(..) | ast::PatStruct(..) => {\n                 // This is either an enum variant or a variable binding.\n-                let opt_def = tcx.def_map.borrow().find_copy(&cur.id);\n+                let opt_def = tcx.def_map.borrow().get(&cur.id).cloned();\n                 match opt_def {\n                     Some(def::DefVariant(enum_id, var_id, _)) => {\n                         let variant = ty::enum_variant_with_id(tcx, enum_id, var_id);\n@@ -1642,7 +1642,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         ast::PatEnum(_, ref sub_pats) => {\n-            let opt_def = bcx.tcx().def_map.borrow().find_copy(&pat.id);\n+            let opt_def = bcx.tcx().def_map.borrow().get(&pat.id).cloned();\n             match opt_def {\n                 Some(def::DefVariant(enum_id, var_id, _)) => {\n                     let repr = adt::represent_node(bcx, pat.id);"}, {"sha": "d79d703336fe0f56a3be45254b5bdae9f83bd79e", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -2274,7 +2274,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                                          static\");\n               }\n \n-              let v = ccx.static_values().borrow().get_copy(&item.id);\n+              let v = ccx.static_values().borrow()[item.id].clone();\n               unsafe {\n                   if !(llvm::LLVMConstIntGetZExtValue(v) != 0) {\n                       ccx.sess().span_fatal(expr.span, \"static assertion failed\");\n@@ -2666,7 +2666,7 @@ fn contains_null(s: &str) -> bool {\n pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n     debug!(\"get_item_val(id=`{}`)\", id);\n \n-    match ccx.item_vals().borrow().find_copy(&id) {\n+    match ccx.item_vals().borrow().get(&id).cloned() {\n         Some(v) => return v,\n         None => {}\n     }"}, {"sha": "dbc4c58020f62889ed02628d760ad34dd6945bd0", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -526,12 +526,12 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n     }\n \n     fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow {\n-        self.tcx().upvar_borrow_map.borrow().get_copy(&upvar_id)\n+        self.tcx().upvar_borrow_map.borrow()[upvar_id].clone()\n     }\n \n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n                     -> ast::CaptureClause {\n-        self.tcx().capture_modes.borrow().get_copy(&closure_expr_id)\n+        self.tcx().capture_modes.borrow()[closure_expr_id].clone()\n     }\n }\n "}, {"sha": "6c8ae8b45ffeeebed41371018044c46163e562c9", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -185,15 +185,15 @@ pub fn get_const_val(cx: &CrateContext,\n         }\n     }\n \n-    cx.const_values().borrow().get_copy(&def_id.node)\n+    cx.const_values().borrow()[def_id.node].clone()\n }\n \n pub fn const_expr(cx: &CrateContext, e: &ast::Expr) -> (ValueRef, ty::t) {\n     let llconst = const_expr_unadjusted(cx, e);\n     let mut llconst = llconst;\n     let ety = ty::expr_ty(cx.tcx(), e);\n     let mut ety_adjusted = ty::expr_ty_adjusted(cx.tcx(), e);\n-    let opt_adj = cx.tcx().adjustments.borrow().find_copy(&e.id);\n+    let opt_adj = cx.tcx().adjustments.borrow().get(&e.id).cloned();\n     match opt_adj {\n         None => { }\n         Some(adj) => {\n@@ -552,7 +552,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                       _ => break,\n                   }\n               }\n-              let opt_def = cx.tcx().def_map.borrow().find_copy(&cur.id);\n+              let opt_def = cx.tcx().def_map.borrow().get(&cur.id).cloned();\n               match opt_def {\n                   Some(def::DefStatic(def_id, _)) => {\n                       let ty = ty::expr_ty(cx.tcx(), e);\n@@ -627,7 +627,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n             // Assert that there are no type parameters in this path.\n             assert!(pth.segments.iter().all(|seg| !seg.parameters.has_types()));\n \n-            let opt_def = cx.tcx().def_map.borrow().find_copy(&e.id);\n+            let opt_def = cx.tcx().def_map.borrow().get(&e.id).cloned();\n             match opt_def {\n                 Some(def::DefFn(def_id, _)) => {\n                     if !ast_util::is_local(def_id) {\n@@ -661,7 +661,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n             }\n           }\n           ast::ExprCall(ref callee, ref args) => {\n-              let opt_def = cx.tcx().def_map.borrow().find_copy(&callee.id);\n+              let opt_def = cx.tcx().def_map.borrow().get(&callee.id).cloned();\n               match opt_def {\n                   Some(def::DefStruct(_)) => {\n                       let ety = ty::expr_ty(cx.tcx(), e);\n@@ -703,7 +703,7 @@ pub fn trans_static(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) {\n         let g = base::get_item_val(ccx, id);\n         // At this point, get_item_val has already translated the\n         // constant's initializer to determine its LLVM type.\n-        let v = ccx.static_values().borrow().get_copy(&id);\n+        let v = ccx.static_values().borrow()[id].clone();\n         // boolean SSA values are i1, but they have to be stored in i8 slots,\n         // otherwise some LLVM optimization passes don't work as expected\n         let v = if llvm::LLVMTypeOf(v) == Type::i1(ccx).to_ref() {"}, {"sha": "aa3d9ae83fa7de44f9bfd3dfa2df13438895b7b1", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -519,7 +519,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n \n     pub fn get_intrinsic(&self, key: & &'static str) -> ValueRef {\n-        match self.intrinsics().borrow().find_copy(key) {\n+        match self.intrinsics().borrow().get(key).cloned() {\n             Some(v) => return v,\n             _ => {}\n         }"}, {"sha": "ebf05f51e73cbfc3d935de25e82d26d22cff3a4e", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -301,11 +301,11 @@ impl TypeMap {\n     }\n \n     fn find_metadata_for_type(&self, type_: ty::t) -> Option<DIType> {\n-        self.type_to_metadata.find_copy(&type_)\n+        self.type_to_metadata.get(&type_).cloned()\n     }\n \n     fn find_metadata_for_unique_id(&self, unique_type_id: UniqueTypeId) -> Option<DIType> {\n-        self.unique_id_to_metadata.find_copy(&unique_type_id)\n+        self.unique_id_to_metadata.get(&unique_type_id).cloned()\n     }\n \n     // Get the string representation of a UniqueTypeId. This method will fail if\n@@ -341,7 +341,7 @@ impl TypeMap {\n         // unique vec box (~[]) -> {HEAP_VEC_BOX<:pointee-uid:>}\n         // gc box               -> {GC_BOX<:pointee-uid:>}\n \n-        match self.type_to_unique_id.find_copy(&type_) {\n+        match self.type_to_unique_id.get(&type_).cloned() {\n             Some(unique_type_id) => return unique_type_id,\n             None => { /* generate one */}\n         };\n@@ -497,7 +497,7 @@ impl TypeMap {\n             // First, find out the 'real' def_id of the type. Items inlined from\n             // other crates have to be mapped back to their source.\n             let source_def_id = if def_id.krate == ast::LOCAL_CRATE {\n-                match cx.external_srcs().borrow().find_copy(&def_id.node) {\n+                match cx.external_srcs().borrow().get(&def_id.node).cloned() {\n                     Some(source_def_id) => {\n                         // The given def_id identifies the inlined copy of a\n                         // type definition, let's take the source of the copy.\n@@ -851,7 +851,7 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n     pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, path1| {\n         let var_ident = path1.node;\n \n-        let datum = match bcx.fcx.lllocals.borrow().find_copy(&node_id) {\n+        let datum = match bcx.fcx.lllocals.borrow().get(&node_id).cloned() {\n             Some(datum) => datum,\n             None => {\n                 bcx.sess().span_bug(span,\n@@ -1014,7 +1014,7 @@ pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n     let scope_metadata = bcx.fcx.debug_context.get_ref(cx, arg.pat.span).fn_metadata;\n \n     pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, path1| {\n-        let llarg = match bcx.fcx.lllocals.borrow().find_copy(&node_id) {\n+        let llarg = match bcx.fcx.lllocals.borrow().get(&node_id).cloned() {\n             Some(v) => v,\n             None => {\n                 bcx.sess().span_bug(span,\n@@ -1706,7 +1706,7 @@ fn scope_metadata(fcx: &FunctionContext,\n     let scope_map = &fcx.debug_context\n                         .get_ref(fcx.ccx, error_reporting_span)\n                         .scope_map;\n-    match scope_map.borrow().find_copy(&node_id) {\n+    match scope_map.borrow().get(&node_id).cloned() {\n         Some(scope_metadata) => scope_metadata,\n         None => {\n             let node = fcx.ccx.tcx().map.get(node_id);\n@@ -2415,7 +2415,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n         // this cache.\n         let cached_discriminant_type_metadata = debug_context(cx).created_enum_disr_types\n                                                                  .borrow()\n-                                                                 .find_copy(&enum_def_id);\n+                                                                 .get(&enum_def_id).cloned();\n         match cached_discriminant_type_metadata {\n             Some(discriminant_type_metadata) => discriminant_type_metadata,\n             None => {\n@@ -3982,7 +3982,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n             current_key.push(name);\n \n             let existing_node = debug_context(cx).namespace_map.borrow()\n-                                                 .find_copy(&current_key);\n+                                                 .get(&current_key).cloned();\n             let current_node = match existing_node {\n                 Some(existing_node) => existing_node,\n                 None => {"}, {"sha": "ea590a669d0f98bb82e56d6c281233713a3aedba", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -184,7 +184,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let mut bcx = bcx;\n     let mut datum = datum;\n-    let adjustment = match bcx.tcx().adjustments.borrow().find_copy(&expr.id) {\n+    let adjustment = match bcx.tcx().adjustments.borrow().get(&expr.id).cloned() {\n         None => {\n             return DatumBlock::new(bcx, datum);\n         }\n@@ -1293,7 +1293,7 @@ pub fn with_field_tys<R>(tcx: &ty::ctxt,\n                         ty.repr(tcx)).as_slice());\n                 }\n                 Some(node_id) => {\n-                    let def = tcx.def_map.borrow().get_copy(&node_id);\n+                    let def = tcx.def_map.borrow()[node_id].clone();\n                     match def {\n                         def::DefVariant(enum_id, variant_id, _) => {\n                             let variant_info = ty::enum_variant_with_id("}, {"sha": "553e0b22d5c704bed8011c8667015d19d2de76b6", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -301,7 +301,7 @@ pub fn trans_static_method_callee(bcx: Block,\n \n fn method_with_name(ccx: &CrateContext, impl_id: ast::DefId, name: ast::Name)\n                     -> ast::DefId {\n-    match ccx.impl_method_cache().borrow().find_copy(&(impl_id, name)) {\n+    match ccx.impl_method_cache().borrow().get(&(impl_id, name)).cloned() {\n         Some(m) => return m,\n         None => {}\n     }"}, {"sha": "092fe2d1fa91e60b16a7015df653cd87069ee037", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -175,7 +175,7 @@ pub fn type_of_fn_from_ty(cx: &CrateContext, fty: ty::t) -> Type {\n //     recursive types. For example, enum types rely on this behavior.\n \n pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n-    match cx.llsizingtypes().borrow().find_copy(&t) {\n+    match cx.llsizingtypes().borrow().get(&t).cloned() {\n         Some(t) => return t,\n         None => ()\n     }"}, {"sha": "8ec5e381b92c5b050109f0104ee93d7cf27f7596", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -3194,7 +3194,7 @@ pub fn node_id_to_trait_ref(cx: &ctxt, id: ast::NodeId) -> Rc<ty::TraitRef> {\n }\n \n pub fn try_node_id_to_type(cx: &ctxt, id: ast::NodeId) -> Option<t> {\n-    cx.node_types.borrow().find_copy(&id)\n+    cx.node_types.borrow().get(&id).cloned()\n }\n \n pub fn node_id_to_type(cx: &ctxt, id: ast::NodeId) -> t {\n@@ -4055,7 +4055,7 @@ fn lookup_locally_or_in_crate_store<V:Clone>(\n      * the crate loading code (and cache the result for the future).\n      */\n \n-    match map.find_copy(&def_id) {\n+    match map.get(&def_id).cloned() {\n         Some(v) => { return v; }\n         None => { }\n     }\n@@ -4077,7 +4077,7 @@ pub fn trait_item(cx: &ctxt, trait_did: ast::DefId, idx: uint)\n pub fn trait_items(cx: &ctxt, trait_did: ast::DefId)\n                    -> Rc<Vec<ImplOrTraitItem>> {\n     let mut trait_items = cx.trait_items_cache.borrow_mut();\n-    match trait_items.find_copy(&trait_did) {\n+    match trait_items.get(&trait_did).cloned() {\n         Some(trait_items) => trait_items,\n         None => {\n             let def_ids = ty::trait_item_def_ids(cx, trait_did);\n@@ -4627,7 +4627,7 @@ pub fn unboxed_closure_upvars(tcx: &ctxt, closure_id: ast::DefId, substs: &Subst\n     // This may change if abstract return types of some sort are\n     // implemented.\n     assert!(closure_id.krate == ast::LOCAL_CRATE);\n-    let capture_mode = tcx.capture_modes.borrow().get_copy(&closure_id.node);\n+    let capture_mode = tcx.capture_modes.borrow()[closure_id.node].clone();\n     match tcx.freevars.borrow().get(&closure_id.node) {\n         None => vec![],\n         Some(ref freevars) => {\n@@ -4636,10 +4636,10 @@ pub fn unboxed_closure_upvars(tcx: &ctxt, closure_id: ast::DefId, substs: &Subst\n                 let freevar_ty = node_id_to_type(tcx, freevar_def_id.node);\n                 let mut freevar_ty = freevar_ty.subst(tcx, substs);\n                 if capture_mode == ast::CaptureByRef {\n-                    let borrow = tcx.upvar_borrow_map.borrow().get_copy(&ty::UpvarId {\n+                    let borrow = tcx.upvar_borrow_map.borrow()[ty::UpvarId {\n                         var_id: freevar_def_id.node,\n                         closure_expr_id: closure_id.node\n-                    });\n+                    }].clone();\n                     freevar_ty = mk_rptr(tcx, borrow.region, ty::mt {\n                         ty: freevar_ty,\n                         mutbl: borrow.kind.to_mutbl_lossy()\n@@ -4738,7 +4738,7 @@ pub fn normalize_ty(cx: &ctxt, t: t) -> t {\n         fn tcx(&self) -> &ctxt<'tcx> { let TypeNormalizer(c) = *self; c }\n \n         fn fold_ty(&mut self, t: ty::t) -> ty::t {\n-            match self.tcx().normalized_cache.borrow().find_copy(&t) {\n+            match self.tcx().normalized_cache.borrow().get(&t).cloned() {\n                 None => {}\n                 Some(u) => return u\n             }\n@@ -4902,7 +4902,7 @@ pub fn required_region_bounds(tcx: &ctxt,\n \n pub fn get_tydesc_ty(tcx: &ctxt) -> Result<t, String> {\n     tcx.lang_items.require(TyDescStructLangItem).map(|tydesc_lang_item| {\n-        tcx.intrinsic_defs.borrow().find_copy(&tydesc_lang_item)\n+        tcx.intrinsic_defs.borrow().get(&tydesc_lang_item).cloned()\n             .expect(\"Failed to resolve TyDesc\")\n     })\n }\n@@ -5053,7 +5053,7 @@ pub fn impl_of_method(tcx: &ctxt, def_id: ast::DefId)\n             ImplContainer(def_id) => Some(def_id),\n         };\n     }\n-    match tcx.impl_or_trait_items.borrow().find_copy(&def_id) {\n+    match tcx.impl_or_trait_items.borrow().get(&def_id).cloned() {\n         Some(trait_item) => {\n             match trait_item.container() {\n                 TraitContainer(_) => None,\n@@ -5071,7 +5071,7 @@ pub fn trait_of_item(tcx: &ctxt, def_id: ast::DefId) -> Option<ast::DefId> {\n     if def_id.krate != LOCAL_CRATE {\n         return csearch::get_trait_of_item(&tcx.sess.cstore, def_id, tcx);\n     }\n-    match tcx.impl_or_trait_items.borrow().find_copy(&def_id) {\n+    match tcx.impl_or_trait_items.borrow().get(&def_id).cloned() {\n         Some(impl_or_trait_item) => {\n             match impl_or_trait_item.container() {\n                 TraitContainer(def_id) => Some(def_id),\n@@ -5461,12 +5461,12 @@ impl<'tcx> mc::Typer<'tcx> for ty::ctxt<'tcx> {\n     }\n \n     fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow {\n-        self.upvar_borrow_map.borrow().get_copy(&upvar_id)\n+        self.upvar_borrow_map.borrow()[upvar_id].clone()\n     }\n \n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n                     -> ast::CaptureClause {\n-        self.capture_modes.borrow().get_copy(&closure_expr_id)\n+        self.capture_modes.borrow()[closure_expr_id].clone()\n     }\n \n     fn unboxed_closures<'a>(&'a self)"}, {"sha": "90c3d8c4f3f1d6c1a5e681f856eb2d77a230ccfe", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -71,7 +71,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n             demand::eqtype(fcx, pat.span, expected, lhs_ty);\n         }\n         ast::PatEnum(..) | ast::PatIdent(..) if pat_is_const(&tcx.def_map, pat) => {\n-            let const_did = tcx.def_map.borrow().get_copy(&pat.id).def_id();\n+            let const_did = tcx.def_map.borrow()[pat.id].clone().def_id();\n             let const_pty = ty::lookup_item_type(tcx, const_did);\n             fcx.write_ty(pat.id, const_pty.ty);\n             demand::suptype(fcx, pat.span, expected, const_pty.ty);\n@@ -296,7 +296,7 @@ pub fn check_pat_struct(pcx: &pat_ctxt, pat: &ast::Pat,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    let def = tcx.def_map.borrow().get_copy(&pat.id);\n+    let def = tcx.def_map.borrow()[pat.id].clone();\n     let def_type = ty::lookup_item_type(tcx, def.def_id());\n     let (enum_def_id, variant_def_id) = match ty::get(def_type.ty).sty {\n         ty::ty_struct(struct_def_id, _) =>\n@@ -341,7 +341,7 @@ pub fn check_pat_enum(pcx: &pat_ctxt, pat: &ast::Pat,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    let def = tcx.def_map.borrow().get_copy(&pat.id);\n+    let def = tcx.def_map.borrow()[pat.id].clone();\n     let enum_def = def.variant_def_ids()\n         .map_or_else(|| def.def_id(), |(enum_def, _)| enum_def);\n \n@@ -449,7 +449,7 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n             }\n             Vacant(vacant) => {\n                 vacant.set(span);\n-                field_type_map.find_copy(&field.ident.name)\n+                field_type_map.get(&field.ident.name).cloned()\n                     .unwrap_or_else(|| {\n                         span_err!(tcx.sess, span, E0026,\n                             \"struct `{}` does not have a field named `{}`\","}, {"sha": "0cf5069218ede4c12f5bac928f77092b6746b811", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -309,7 +309,7 @@ impl<'a, 'tcx> mem_categorization::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n         self.tcx().temporary_scope(rvalue_id)\n     }\n     fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow {\n-        self.inh.upvar_borrow_map.borrow().get_copy(&upvar_id)\n+        self.inh.upvar_borrow_map.borrow()[upvar_id].clone()\n     }\n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n                     -> ast::CaptureClause {\n@@ -450,7 +450,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n         debug!(\"Local variable {} is assigned type {}\",\n                self.fcx.pat_to_string(&*local.pat),\n                self.fcx.infcx().ty_to_string(\n-                   self.fcx.inh.locals.borrow().get_copy(&local.id)));\n+                   self.fcx.inh.locals.borrow()[local.id].clone()));\n         visit::walk_local(self, local);\n     }\n \n@@ -467,7 +467,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n                     debug!(\"Pattern binding {} is assigned to {} with type {}\",\n                            token::get_ident(path1.node),\n                            self.fcx.infcx().ty_to_string(\n-                               self.fcx.inh.locals.borrow().get_copy(&p.id)),\n+                               self.fcx.inh.locals.borrow()[p.id].clone()),\n                            var_ty.repr(self.fcx.tcx()));\n                 }\n             _ => {}"}, {"sha": "c63e8944dbdcac2906af9c88d8be786d6fdbc294", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -479,12 +479,12 @@ impl<'fcx, 'tcx> mc::Typer<'tcx> for Rcx<'fcx, 'tcx> {\n     }\n \n     fn upvar_borrow(&self, id: ty::UpvarId) -> ty::UpvarBorrow {\n-        self.fcx.inh.upvar_borrow_map.borrow().get_copy(&id)\n+        self.fcx.inh.upvar_borrow_map.borrow()[id].clone()\n     }\n \n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n                     -> ast::CaptureClause {\n-        self.tcx().capture_modes.borrow().get_copy(&closure_expr_id)\n+        self.tcx().capture_modes.borrow()[closure_expr_id].clone()\n     }\n \n     fn unboxed_closures<'a>(&'a self)\n@@ -871,7 +871,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n             });\n         }\n         ty::ty_unboxed_closure(_, region, _) => {\n-            if tcx.capture_modes.borrow().get_copy(&expr.id) == ast::CaptureByRef {\n+            if tcx.capture_modes.borrow()[expr.id].clone() == ast::CaptureByRef {\n                 ty::with_freevars(tcx, expr.id, |freevars| {\n                     if !freevars.is_empty() {\n                         // Variables being referenced must be constrained and registered\n@@ -896,7 +896,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n             })\n         }\n         ty::ty_unboxed_closure(..) => {\n-            if tcx.capture_modes.borrow().get_copy(&expr.id) == ast::CaptureByRef {\n+            if tcx.capture_modes.borrow()[expr.id].clone() == ast::CaptureByRef {\n                 ty::with_freevars(tcx, expr.id, |freevars| {\n                     propagate_upupvar_borrow_kind(rcx, expr, freevars);\n                 });\n@@ -1847,7 +1847,7 @@ fn link_upvar_borrow_kind_for_nested_closures(rcx: &mut Rcx,\n            inner_upvar_id, outer_upvar_id);\n \n     let mut upvar_borrow_map = rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n-    let inner_borrow = upvar_borrow_map.get_copy(&inner_upvar_id);\n+    let inner_borrow = upvar_borrow_map[inner_upvar_id].clone();\n     match upvar_borrow_map.get_mut(&outer_upvar_id) {\n         Some(outer_borrow) => {\n             adjust_upvar_borrow_kind(rcx, outer_upvar_id, outer_borrow, inner_borrow.kind);"}, {"sha": "9e4728195b6d576320cdc397774b824235f3b3ed", "filename": "src/librustc/middle/typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -317,7 +317,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n     fn get_self_type_for_implementation(&self, impl_did: DefId)\n                                         -> Polytype {\n-        self.crate_context.tcx.tcache.borrow().get_copy(&impl_did)\n+        self.crate_context.tcx.tcache.borrow()[impl_did].clone()\n     }\n \n     // Converts an implementation in the AST to a vector of items.\n@@ -428,7 +428,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         };\n \n         let impl_items = tcx.impl_items.borrow();\n-        let trait_impls = match tcx.trait_impls.borrow().find_copy(&drop_trait) {\n+        let trait_impls = match tcx.trait_impls.borrow().get(&drop_trait).cloned() {\n             None => return, // No types with (new-style) dtors present.\n             Some(found_impls) => found_impls\n         };"}, {"sha": "d57343e004bab8896daf4606f2518cf6f5ceb75e", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -1520,7 +1520,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     ConstrainVarSubReg(_, region) => {\n                         state.result.push(RegionAndOrigin {\n                             region: region,\n-                            origin: this.constraints.borrow().get_copy(&edge.data)\n+                            origin: this.constraints.borrow()[edge.data].clone()\n                         });\n                     }\n                 }"}, {"sha": "779cd425d2a6ee70c70acf47fec846bd6590be43", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -37,7 +37,6 @@ use super::table::{\n };\n \n // FIXME(conventions): update capacity management to match other collections (no auto-shrink)\n-// FIXME(conventions): axe find_copy/get_copy in favour of Option.cloned (also implement that)\n \n const INITIAL_LOG2_CAP: uint = 5;\n pub const INITIAL_CAPACITY: uint = 1 << INITIAL_LOG2_CAP; // 2^5\n@@ -1826,6 +1825,7 @@ mod test_map {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn test_find_copy() {\n         let mut m = HashMap::new();\n         assert!(m.get(&1i).is_none());"}, {"sha": "3cb861aac20c13c6ef5318bbb1e918f77ed6a944", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfb7a811ae0cb8c98ceed93ecc3573555cca03db/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "patch": "@@ -94,7 +94,7 @@ fn lookup_cur_matched_by_matched(r: &TtReader, start: Rc<NamedMatch>) -> Rc<Name\n }\n \n fn lookup_cur_matched(r: &TtReader, name: Ident) -> Option<Rc<NamedMatch>> {\n-    let matched_opt = r.interpolations.find_copy(&name);\n+    let matched_opt = r.interpolations.get(&name).cloned();\n     matched_opt.map(|s| lookup_cur_matched_by_matched(r, s))\n }\n "}]}