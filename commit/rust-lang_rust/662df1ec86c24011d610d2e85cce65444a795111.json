{"sha": "662df1ec86c24011d610d2e85cce65444a795111", "node_id": "C_kwDOAAsO6NoAKDY2MmRmMWVjODZjMjQwMTFkNjEwZDJlODVjY2U2NTQ0NGE3OTUxMTE", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-11-12T06:32:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-12T06:32:52Z"}, "message": "Rollup merge of #104206 - compiler-errors:ocx-more-2, r=lcnr\n\nRemove `save_and_restore_in_snapshot_flag`, use `ObligationCtxt` more\n\nr? ```@lcnr```", "tree": {"sha": "a641c0e9275c391a3adbae8dc6635f624ee4f485", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a641c0e9275c391a3adbae8dc6635f624ee4f485"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/662df1ec86c24011d610d2e85cce65444a795111", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjbz4UCRBK7hj4Ov3rIwAAa8YIAGoKDfBkKnysZOfpocpD2/LP\nMICh1oAca7g80YFpsYSQL7l9jWthNwcvQgoMCkSpn7iuANxThUc0NVLIiODykD6s\nNHUi4hKtQriF6AzWTKy1cHMAUaFzvOdntw/qSeqjJQDt12Re0Tl/n++2iLT0PMuV\n4ASYRkHCRprqt5M/0Du2jE4ZtUtZuYb4MQBM7PgDfgdm/LmRvXeborL6rEWQ69hW\n40ZTrgdUqcBQiNijMHcDWL1IWdZHij9V5Ywm9GzSKPTZAi7JAe/2lZMTFgnIBfI4\n9xZvnDmXF7wNenHV7zwLr7uDK0r97l2zSpXbcd8rW0fVSEXHg6mBe/2WDzzUCU4=\n=oJeP\n-----END PGP SIGNATURE-----\n", "payload": "tree a641c0e9275c391a3adbae8dc6635f624ee4f485\nparent fcbe99009308014378a53fbfa695354c65e46529\nparent 63217e08cc041d0c4ce6df4e981899bfbc557de5\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1668234772 +0530\ncommitter GitHub <noreply@github.com> 1668234772 +0530\n\nRollup merge of #104206 - compiler-errors:ocx-more-2, r=lcnr\n\nRemove `save_and_restore_in_snapshot_flag`, use `ObligationCtxt` more\n\nr? ```@lcnr```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/662df1ec86c24011d610d2e85cce65444a795111", "html_url": "https://github.com/rust-lang/rust/commit/662df1ec86c24011d610d2e85cce65444a795111", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/662df1ec86c24011d610d2e85cce65444a795111/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcbe99009308014378a53fbfa695354c65e46529", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcbe99009308014378a53fbfa695354c65e46529", "html_url": "https://github.com/rust-lang/rust/commit/fcbe99009308014378a53fbfa695354c65e46529"}, {"sha": "63217e08cc041d0c4ce6df4e981899bfbc557de5", "url": "https://api.github.com/repos/rust-lang/rust/commits/63217e08cc041d0c4ce6df4e981899bfbc557de5", "html_url": "https://github.com/rust-lang/rust/commit/63217e08cc041d0c4ce6df4e981899bfbc557de5"}], "stats": {"total": 316, "additions": 128, "deletions": 188}, "files": [{"sha": "c6bd771fad2568e4b8578316c80013836f845e38", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 7, "deletions": 26, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/662df1ec86c24011d610d2e85cce65444a795111/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662df1ec86c24011d610d2e85cce65444a795111/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=662df1ec86c24011d610d2e85cce65444a795111", "patch": "@@ -18,6 +18,7 @@ use rustc_infer::infer::canonical::{Canonical, OriginalQueryValues, QueryRespons\n use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n use rustc_infer::infer::{InferOk, InferResult};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n+use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{\n@@ -32,9 +33,7 @@ use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n-use rustc_trait_selection::traits::{\n-    self, ObligationCause, ObligationCauseCode, TraitEngine, TraitEngineExt,\n-};\n+use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, ObligationCtxt};\n \n use std::collections::hash_map::Entry;\n use std::slice;\n@@ -766,34 +765,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let expect_args = self\n             .fudge_inference_if_ok(|| {\n+                let ocx = ObligationCtxt::new_in_snapshot(self);\n+\n                 // Attempt to apply a subtyping relationship between the formal\n                 // return type (likely containing type variables if the function\n                 // is polymorphic) and the expected return type.\n                 // No argument expectations are produced if unification fails.\n                 let origin = self.misc(call_span);\n-                let ures = self.at(&origin, self.param_env).sup(ret_ty, formal_ret);\n-\n-                // FIXME(#27336) can't use ? here, Try::from_error doesn't default\n-                // to identity so the resulting type is not constrained.\n-                match ures {\n-                    Ok(ok) => {\n-                        // Process any obligations locally as much as\n-                        // we can.  We don't care if some things turn\n-                        // out unconstrained or ambiguous, as we're\n-                        // just trying to get hints here.\n-                        let errors = self.save_and_restore_in_snapshot_flag(|_| {\n-                            let mut fulfill = <dyn TraitEngine<'_>>::new(self.tcx);\n-                            for obligation in ok.obligations {\n-                                fulfill.register_predicate_obligation(self, obligation);\n-                            }\n-                            fulfill.select_where_possible(self)\n-                        });\n-\n-                        if !errors.is_empty() {\n-                            return Err(());\n-                        }\n-                    }\n-                    Err(_) => return Err(()),\n+                ocx.sup(&origin, self.param_env, ret_ty, formal_ret)?;\n+                if !ocx.select_where_possible().is_empty() {\n+                    return Err(TypeError::Mismatch);\n                 }\n \n                 // Record all the argument types, with the substitutions"}, {"sha": "fd3b3e4d59fa699d7570a708814025e0519e7e3e", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/662df1ec86c24011d610d2e85cce65444a795111/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662df1ec86c24011d610d2e85cce65444a795111/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=662df1ec86c24011d610d2e85cce65444a795111", "patch": "@@ -778,32 +778,6 @@ impl<'tcx> InferCtxt<'tcx> {\n         }\n     }\n \n-    /// Clear the \"currently in a snapshot\" flag, invoke the closure,\n-    /// then restore the flag to its original value. This flag is a\n-    /// debugging measure designed to detect cases where we start a\n-    /// snapshot, create type variables, and register obligations\n-    /// which may involve those type variables in the fulfillment cx,\n-    /// potentially leaving \"dangling type variables\" behind.\n-    /// In such cases, an assertion will fail when attempting to\n-    /// register obligations, within a snapshot. Very useful, much\n-    /// better than grovelling through megabytes of `RUSTC_LOG` output.\n-    ///\n-    /// HOWEVER, in some cases the flag is unhelpful. In particular, we\n-    /// sometimes create a \"mini-fulfilment-cx\" in which we enroll\n-    /// obligations. As long as this fulfillment cx is fully drained\n-    /// before we return, this is not a problem, as there won't be any\n-    /// escaping obligations in the main cx. In those cases, you can\n-    /// use this function.\n-    pub fn save_and_restore_in_snapshot_flag<F, R>(&self, func: F) -> R\n-    where\n-        F: FnOnce(&Self) -> R,\n-    {\n-        let flag = self.in_snapshot.replace(false);\n-        let result = func(self);\n-        self.in_snapshot.set(flag);\n-        result\n-    }\n-\n     fn start_snapshot(&self) -> CombinedSnapshot<'tcx> {\n         debug!(\"start_snapshot()\");\n "}, {"sha": "231a18f86eae72eaea55261dc2344e087e7d12ba", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/662df1ec86c24011d610d2e85cce65444a795111/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662df1ec86c24011d610d2e85cce65444a795111/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=662df1ec86c24011d610d2e85cce65444a795111", "patch": "@@ -10,10 +10,12 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/specialization.html\n \n pub mod specialization_graph;\n+use rustc_infer::traits::{TraitEngine, TraitEngineExt as _};\n use specialization_graph::GraphExt;\n \n use crate::errors::NegativePositiveConflict;\n use crate::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n+use crate::traits::engine::TraitEngineExt as _;\n use crate::traits::select::IntercrateAmbiguityCause;\n use crate::traits::{self, coherence, FutureCompatOverlapErrorKind, ObligationCause};\n use rustc_data_structures::fx::FxIndexSet;\n@@ -200,36 +202,32 @@ fn fulfill_implication<'tcx>(\n         return Err(());\n     };\n \n+    // Needs to be `in_snapshot` because this function is used to rebase\n+    // substitutions, which may happen inside of a select within a probe.\n+    let mut engine = <dyn TraitEngine<'tcx>>::new_in_snapshot(infcx.tcx);\n     // attempt to prove all of the predicates for impl2 given those for impl1\n     // (which are packed up in penv)\n+    engine.register_predicate_obligations(infcx, obligations.chain(more_obligations));\n \n-    infcx.save_and_restore_in_snapshot_flag(|infcx| {\n-        let errors = traits::fully_solve_obligations(&infcx, obligations.chain(more_obligations));\n-        match &errors[..] {\n-            [] => {\n-                debug!(\n-                    \"fulfill_implication: an impl for {:?} specializes {:?}\",\n-                    source_trait, target_trait\n-                );\n+    let errors = engine.select_all_or_error(infcx);\n+    if !errors.is_empty() {\n+        // no dice!\n+        debug!(\n+            \"fulfill_implication: for impls on {:?} and {:?}, \\\n+                 could not fulfill: {:?} given {:?}\",\n+            source_trait,\n+            target_trait,\n+            errors,\n+            param_env.caller_bounds()\n+        );\n+        return Err(());\n+    }\n \n-                // Now resolve the *substitution* we built for the target earlier, replacing\n-                // the inference variables inside with whatever we got from fulfillment.\n-                Ok(infcx.resolve_vars_if_possible(target_substs))\n-            }\n-            errors => {\n-                // no dice!\n-                debug!(\n-                    \"fulfill_implication: for impls on {:?} and {:?}, \\\n-                     could not fulfill: {:?} given {:?}\",\n-                    source_trait,\n-                    target_trait,\n-                    errors,\n-                    param_env.caller_bounds()\n-                );\n-                Err(())\n-            }\n-        }\n-    })\n+    debug!(\"fulfill_implication: an impl for {:?} specializes {:?}\", source_trait, target_trait);\n+\n+    // Now resolve the *substitution* we built for the target earlier, replacing\n+    // the inference variables inside with whatever we got from fulfillment.\n+    Ok(infcx.resolve_vars_if_possible(target_substs))\n }\n \n // Query provider for `specialization_graph_of`."}, {"sha": "7b4ad9fea137a7bd30bf835c5a86f528b058f764", "filename": "compiler/rustc_traits/src/dropck_outlives.rs", "status": "modified", "additions": 97, "deletions": 110, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/662df1ec86c24011d610d2e85cce65444a795111/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662df1ec86c24011d610d2e85cce65444a795111/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs?ref=662df1ec86c24011d610d2e85cce65444a795111", "patch": "@@ -2,20 +2,18 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::traits::TraitEngineExt as _;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::InternalSubsts;\n use rustc_middle::ty::{self, EarlyBinder, ParamEnvAnd, Ty, TyCtxt};\n use rustc_span::source_map::{Span, DUMMY_SP};\n+use rustc_trait_selection::infer::InferCtxtBuilderExt;\n use rustc_trait_selection::traits::query::dropck_outlives::trivial_dropck_outlives;\n use rustc_trait_selection::traits::query::dropck_outlives::{\n     DropckConstraint, DropckOutlivesResult,\n };\n use rustc_trait_selection::traits::query::normalize::AtExt;\n use rustc_trait_selection::traits::query::{CanonicalTyGoal, NoSolution};\n-use rustc_trait_selection::traits::{\n-    Normalized, ObligationCause, TraitEngine, TraitEngineExt as _,\n-};\n+use rustc_trait_selection::traits::{Normalized, ObligationCause};\n \n pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers { dropck_outlives, adt_dtorck_constraint, ..*p };\n@@ -27,120 +25,109 @@ fn dropck_outlives<'tcx>(\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, DropckOutlivesResult<'tcx>>>, NoSolution> {\n     debug!(\"dropck_outlives(goal={:#?})\", canonical_goal);\n \n-    let (ref infcx, goal, canonical_inference_vars) =\n-        tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n-    let tcx = infcx.tcx;\n-    let ParamEnvAnd { param_env, value: for_ty } = goal;\n-\n-    let mut result = DropckOutlivesResult { kinds: vec![], overflows: vec![] };\n-\n-    // A stack of types left to process. Each round, we pop\n-    // something from the stack and invoke\n-    // `dtorck_constraint_for_ty`. This may produce new types that\n-    // have to be pushed on the stack. This continues until we have explored\n-    // all the reachable types from the type `for_ty`.\n-    //\n-    // Example: Imagine that we have the following code:\n-    //\n-    // ```rust\n-    // struct A {\n-    //     value: B,\n-    //     children: Vec<A>,\n-    // }\n-    //\n-    // struct B {\n-    //     value: u32\n-    // }\n-    //\n-    // fn f() {\n-    //   let a: A = ...;\n-    //   ..\n-    // } // here, `a` is dropped\n-    // ```\n-    //\n-    // at the point where `a` is dropped, we need to figure out\n-    // which types inside of `a` contain region data that may be\n-    // accessed by any destructors in `a`. We begin by pushing `A`\n-    // onto the stack, as that is the type of `a`. We will then\n-    // invoke `dtorck_constraint_for_ty` which will expand `A`\n-    // into the types of its fields `(B, Vec<A>)`. These will get\n-    // pushed onto the stack. Eventually, expanding `Vec<A>` will\n-    // lead to us trying to push `A` a second time -- to prevent\n-    // infinite recursion, we notice that `A` was already pushed\n-    // once and stop.\n-    let mut ty_stack = vec![(for_ty, 0)];\n-\n-    // Set used to detect infinite recursion.\n-    let mut ty_set = FxHashSet::default();\n-\n-    let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-\n-    let cause = ObligationCause::dummy();\n-    let mut constraints = DropckConstraint::empty();\n-    while let Some((ty, depth)) = ty_stack.pop() {\n-        debug!(\n-            \"{} kinds, {} overflows, {} ty_stack\",\n-            result.kinds.len(),\n-            result.overflows.len(),\n-            ty_stack.len()\n-        );\n-        dtorck_constraint_for_ty(tcx, DUMMY_SP, for_ty, depth, ty, &mut constraints)?;\n-\n-        // \"outlives\" represent types/regions that may be touched\n-        // by a destructor.\n-        result.kinds.append(&mut constraints.outlives);\n-        result.overflows.append(&mut constraints.overflows);\n-\n-        // If we have even one overflow, we should stop trying to evaluate further --\n-        // chances are, the subsequent overflows for this evaluation won't provide useful\n-        // information and will just decrease the speed at which we can emit these errors\n-        // (since we'll be printing for just that much longer for the often enormous types\n-        // that result here).\n-        if !result.overflows.is_empty() {\n-            break;\n-        }\n+    tcx.infer_ctxt().enter_canonical_trait_query(&canonical_goal, |ocx, goal| {\n+        let tcx = ocx.infcx.tcx;\n+        let ParamEnvAnd { param_env, value: for_ty } = goal;\n+\n+        let mut result = DropckOutlivesResult { kinds: vec![], overflows: vec![] };\n+\n+        // A stack of types left to process. Each round, we pop\n+        // something from the stack and invoke\n+        // `dtorck_constraint_for_ty`. This may produce new types that\n+        // have to be pushed on the stack. This continues until we have explored\n+        // all the reachable types from the type `for_ty`.\n+        //\n+        // Example: Imagine that we have the following code:\n+        //\n+        // ```rust\n+        // struct A {\n+        //     value: B,\n+        //     children: Vec<A>,\n+        // }\n+        //\n+        // struct B {\n+        //     value: u32\n+        // }\n+        //\n+        // fn f() {\n+        //   let a: A = ...;\n+        //   ..\n+        // } // here, `a` is dropped\n+        // ```\n+        //\n+        // at the point where `a` is dropped, we need to figure out\n+        // which types inside of `a` contain region data that may be\n+        // accessed by any destructors in `a`. We begin by pushing `A`\n+        // onto the stack, as that is the type of `a`. We will then\n+        // invoke `dtorck_constraint_for_ty` which will expand `A`\n+        // into the types of its fields `(B, Vec<A>)`. These will get\n+        // pushed onto the stack. Eventually, expanding `Vec<A>` will\n+        // lead to us trying to push `A` a second time -- to prevent\n+        // infinite recursion, we notice that `A` was already pushed\n+        // once and stop.\n+        let mut ty_stack = vec![(for_ty, 0)];\n+\n+        // Set used to detect infinite recursion.\n+        let mut ty_set = FxHashSet::default();\n+\n+        let cause = ObligationCause::dummy();\n+        let mut constraints = DropckConstraint::empty();\n+        while let Some((ty, depth)) = ty_stack.pop() {\n+            debug!(\n+                \"{} kinds, {} overflows, {} ty_stack\",\n+                result.kinds.len(),\n+                result.overflows.len(),\n+                ty_stack.len()\n+            );\n+            dtorck_constraint_for_ty(tcx, DUMMY_SP, for_ty, depth, ty, &mut constraints)?;\n+\n+            // \"outlives\" represent types/regions that may be touched\n+            // by a destructor.\n+            result.kinds.append(&mut constraints.outlives);\n+            result.overflows.append(&mut constraints.overflows);\n+\n+            // If we have even one overflow, we should stop trying to evaluate further --\n+            // chances are, the subsequent overflows for this evaluation won't provide useful\n+            // information and will just decrease the speed at which we can emit these errors\n+            // (since we'll be printing for just that much longer for the often enormous types\n+            // that result here).\n+            if !result.overflows.is_empty() {\n+                break;\n+            }\n \n-        // dtorck types are \"types that will get dropped but which\n-        // do not themselves define a destructor\", more or less. We have\n-        // to push them onto the stack to be expanded.\n-        for ty in constraints.dtorck_types.drain(..) {\n-            match infcx.at(&cause, param_env).normalize(ty) {\n-                Ok(Normalized { value: ty, obligations }) => {\n-                    fulfill_cx.register_predicate_obligations(infcx, obligations);\n-\n-                    debug!(\"dropck_outlives: ty from dtorck_types = {:?}\", ty);\n-\n-                    match ty.kind() {\n-                        // All parameters live for the duration of the\n-                        // function.\n-                        ty::Param(..) => {}\n-\n-                        // A projection that we couldn't resolve - it\n-                        // might have a destructor.\n-                        ty::Projection(..) | ty::Opaque(..) => {\n-                            result.kinds.push(ty.into());\n-                        }\n+            // dtorck types are \"types that will get dropped but which\n+            // do not themselves define a destructor\", more or less. We have\n+            // to push them onto the stack to be expanded.\n+            for ty in constraints.dtorck_types.drain(..) {\n+                let Normalized { value: ty, obligations } =\n+                    ocx.infcx.at(&cause, param_env).normalize(ty)?;\n+                ocx.register_obligations(obligations);\n+\n+                debug!(\"dropck_outlives: ty from dtorck_types = {:?}\", ty);\n+\n+                match ty.kind() {\n+                    // All parameters live for the duration of the\n+                    // function.\n+                    ty::Param(..) => {}\n+\n+                    // A projection that we couldn't resolve - it\n+                    // might have a destructor.\n+                    ty::Projection(..) | ty::Opaque(..) => {\n+                        result.kinds.push(ty.into());\n+                    }\n \n-                        _ => {\n-                            if ty_set.insert(ty) {\n-                                ty_stack.push((ty, depth + 1));\n-                            }\n+                    _ => {\n+                        if ty_set.insert(ty) {\n+                            ty_stack.push((ty, depth + 1));\n                         }\n                     }\n                 }\n-\n-                // We don't actually expect to fail to normalize.\n-                // That implies a WF error somewhere else.\n-                Err(NoSolution) => {\n-                    return Err(NoSolution);\n-                }\n             }\n         }\n-    }\n-\n-    debug!(\"dropck_outlives: result = {:#?}\", result);\n \n-    infcx.make_canonicalized_query_response(canonical_inference_vars, result, &mut *fulfill_cx)\n+        debug!(\"dropck_outlives: result = {:#?}\", result);\n+        Ok(result)\n+    })\n }\n \n /// Returns a set of constraints that needs to be satisfied in"}]}