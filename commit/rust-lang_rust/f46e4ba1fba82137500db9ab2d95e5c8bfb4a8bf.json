{"sha": "f46e4ba1fba82137500db9ab2d95e5c8bfb4a8bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0NmU0YmExZmJhODIxMzc1MDBkYjlhYjJkOTVlNWM4YmZiNGE4YmY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-08T00:31:39Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-08T00:31:39Z"}, "message": "tutorial: Expand the section on vectors", "tree": {"sha": "411fb15cc37648b1914f4819995a923395597a38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/411fb15cc37648b1914f4819995a923395597a38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f46e4ba1fba82137500db9ab2d95e5c8bfb4a8bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f46e4ba1fba82137500db9ab2d95e5c8bfb4a8bf", "html_url": "https://github.com/rust-lang/rust/commit/f46e4ba1fba82137500db9ab2d95e5c8bfb4a8bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f46e4ba1fba82137500db9ab2d95e5c8bfb4a8bf/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fa64eeb20fad30ec327c0cd3931079e30696228", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fa64eeb20fad30ec327c0cd3931079e30696228", "html_url": "https://github.com/rust-lang/rust/commit/6fa64eeb20fad30ec327c0cd3931079e30696228"}], "stats": {"total": 120, "additions": 81, "deletions": 39}, "files": [{"sha": "b8eb9fdc6e8785fa2d9883f55bfc3af5ef6f7245", "filename": "doc/tutorial.md", "status": "modified", "additions": 81, "deletions": 39, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/f46e4ba1fba82137500db9ab2d95e5c8bfb4a8bf/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/f46e4ba1fba82137500db9ab2d95e5c8bfb4a8bf/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=f46e4ba1fba82137500db9ab2d95e5c8bfb4a8bf", "patch": "@@ -1368,72 +1368,114 @@ fn increase_contents(pt: @mut int) {\n \n # Vectors\n \n-Rust vectors are always heap-allocated and unique. A value of type\n-`~[T]` is represented by a pointer to a section of heap memory\n-containing any number of values of type `T`.\n+Vectors represent a section of memory that contains some number\n+of values. Like other types in Rust, vectors can be stored on\n+the stack, the local heap, or the exchange heap.\n \n-> ***Note:*** This uniqueness is turning out to be quite awkward in\n-> practice, and might change in the future.\n+~~~\n+enum crayon {\n+    almond, antique_brass, apricot,\n+    aquamarine, asparagus, atomic_tangerine,\n+    banana_mania, beaver, bittersweet\n+}\n+\n+// A stack vector of crayons\n+let stack_crayons: &[crayon] = &[almond, antique_brass, apricot];\n+// A local heap (shared) vector of crayons\n+let local_crayons: @[crayon] = @[aquamarine, asparagus, atomic_tangerine];\n+// An exchange heap (unique) vector of crayons\n+let exchange_crayons: ~[crayon] = ~[banana_mania, beaver, bittersweet];\n+~~~\n+\n+> ***Note:*** Until recently Rust only had unique vectors, using the\n+> unadorned `[]` syntax for literals. This syntax is still supported\n+> but is deprecated. In the future it will probably represent some\n+> \"reasonable default\" vector type.\n+>\n+> Unique vectors are the currently-recomended vector type for general\n+> use as they are the most tested and well-supported by existing\n+> libraries. There will be a gradual shift toward using more\n+> stack and local vectors in the coming releases.\n \n-Vector literals are enclosed in square brackets. Dereferencing is done\n-with square brackets (zero-based):\n+Vector literals are enclosed in square brackets and dereferencing is\n+also done with square brackets (zero-based):\n \n ~~~~\n-let myvec = ~[true, false, true, false];\n-if myvec[1] { io::println(\"boom\"); }\n+# enum crayon { almond, antique_brass, apricot,\n+#               aquamarine, asparagus, atomic_tangerine,\n+#               banana_mania, beaver, bittersweet };\n+# fn draw_crying_puppy(c: crayon) { }\n+\n+let crayons = ~[banana_mania, beaver, bittersweet];\n+if crayons[0] == bittersweet { draw_crying_puppy(crayons[0]); }\n ~~~~\n \n By default, vectors are immutable\u2014you can not replace their elements.\n The type written as `~[mut T]` is a vector with mutable\n elements. Mutable vector literals are written `~[mut]` (empty) or `~[mut\n 1, 2, 3]` (with elements).\n \n+~~~~\n+# enum crayon { almond, antique_brass, apricot,\n+#               aquamarine, asparagus, atomic_tangerine,\n+#               banana_mania, beaver, bittersweet };\n+\n+let crayons = ~[mut banana_mania, beaver, bittersweet];\n+crayons[0] = atomic_tangerine;\n+~~~~\n+\n The `+` operator means concatenation when applied to vector types.\n-Growing a vector in Rust is not as inefficient as it looks :\n \n ~~~~\n-let mut myvec = ~[], i = 0;\n-while i < 100 {\n-    myvec += ~[i];\n-    i += 1;\n-}\n+# enum crayon { almond, antique_brass, apricot,\n+#               aquamarine, asparagus, atomic_tangerine,\n+#               banana_mania, beaver, bittersweet };\n+\n+let my_crayons = ~[almond, antique_brass, apricot];\n+let your_crayons = ~[banana_mania, beaver, bittersweet];\n+\n+let our_crayons = my_crayons + your_crayons;\n ~~~~\n \n-Because a vector is unique, replacing it with a longer one (which is\n-what `+= ~[i]` does) is indistinguishable from appending to it\n-in-place. Vector representations are optimized to grow\n-logarithmically, so the above code generates about the same amount of\n-copying and reallocation as `push` implementations in most other\n-languages.\n+The `+=` operator also works as expected, provided the assignee\n+lives in a mutable slot.\n+\n+~~~~\n+# enum crayon { almond, antique_brass, apricot,\n+#               aquamarine, asparagus, atomic_tangerine,\n+#               banana_mania, beaver, bittersweet };\n \n-> ***Note:*** Actually, currently, growing a vector is *exactly* as\n-> inefficient as it looks, since vector `+` has been moved to the\n-> libraries and Rust's operator overloading support is insufficient to\n-> allow this optimization. Try using `vec::push`.\n+let mut my_crayons = ~[almond, antique_brass, apricot];\n+let your_crayons = ~[banana_mania, beaver, bittersweet];\n+\n+my_crayons += your_crayons;\n+~~~~\n \n ## Strings\n \n-The `str` type in Rust is represented exactly the same way as a vector\n-of bytes (`~[u8]`), except that it is guaranteed to have a trailing\n-null byte (for interoperability with C APIs).\n+The `str` type in Rust is represented exactly the same way as a unique\n+vector of immutable bytes (`~[u8]`). This sequence of bytes is\n+interpreted as an UTF-8 encoded sequence of characters. This has the\n+advantage that UTF-8 encoded I/O (which should really be the default\n+for modern systems) is very fast, and that strings have, for most\n+intents and purposes, a nicely compact representation. It has the\n+disadvantage that you only get constant-time access by byte, not by\n+character.\n \n-This sequence of bytes is interpreted as an UTF-8 encoded sequence of\n-characters. This has the advantage that UTF-8 encoded I/O (which\n-should really be the default for modern systems) is very fast, and\n-that strings have, for most intents and purposes, a nicely compact\n-representation. It has the disadvantage that you only get\n-constant-time access by byte, not by character.\n+~~~~\n+let huh = \"what?\";\n+let que: u8 = huh[4]; // indexing a string returns a `u8`\n+assert que == '?' as u8;\n+~~~~\n \n A lot of algorithms don't need constant-time indexed access (they\n iterate over all characters, which `str::chars` helps with), and\n for those that do, many don't need actual characters, and can operate\n on bytes. For algorithms that do really need to index by character,\n-there's the option to convert your string to a character vector (using\n-`str::chars`).\n+there are core library functions available.\n \n-Like vectors, strings are always unique. You can wrap them in a shared\n-box to share them. Unlike vectors, there is no mutable variant of\n-strings. They are always immutable.\n+> ***Note:*** like vectors, strings will soon be allocatable in\n+> the local heap and on the stack, in addition to the exchange heap.\n \n # Closures\n "}]}