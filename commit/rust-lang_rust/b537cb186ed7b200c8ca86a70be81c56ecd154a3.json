{"sha": "b537cb186ed7b200c8ca86a70be81c56ecd154a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1MzdjYjE4NmVkN2IyMDBjOGNhODZhNzBiZTgxYzU2ZWNkMTU0YTM=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-29T15:17:45Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-29T15:26:37Z"}, "message": "Use more strictly typed syntax nodes for analysis in extract_function assist", "tree": {"sha": "2f16f3b7af01c21503fbd65106502f93a86f79ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f16f3b7af01c21503fbd65106502f93a86f79ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b537cb186ed7b200c8ca86a70be81c56ecd154a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b537cb186ed7b200c8ca86a70be81c56ecd154a3", "html_url": "https://github.com/rust-lang/rust/commit/b537cb186ed7b200c8ca86a70be81c56ecd154a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b537cb186ed7b200c8ca86a70be81c56ecd154a3/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b461c50d7a05c76c996d75e858cfe3c8a7390b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b461c50d7a05c76c996d75e858cfe3c8a7390b7", "html_url": "https://github.com/rust-lang/rust/commit/2b461c50d7a05c76c996d75e858cfe3c8a7390b7"}], "stats": {"total": 287, "additions": 199, "deletions": 88}, "files": [{"sha": "169961eabf9ce03e31ac0b885099b27a9d266aba", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b537cb186ed7b200c8ca86a70be81c56ecd154a3/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b537cb186ed7b200c8ca86a70be81c56ecd154a3/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b537cb186ed7b200c8ca86a70be81c56ecd154a3", "patch": "@@ -600,6 +600,7 @@ dependencies = [\n  \"expect-test\",\n  \"hir\",\n  \"ide_db\",\n+ \"indexmap\",\n  \"itertools\",\n  \"profile\",\n  \"rustc-hash\","}, {"sha": "c34798d0ea6c3677122c4a50827cfa5d58f48bd6", "filename": "crates/ide_assists/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b537cb186ed7b200c8ca86a70be81c56ecd154a3/crates%2Fide_assists%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b537cb186ed7b200c8ca86a70be81c56ecd154a3/crates%2Fide_assists%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2FCargo.toml?ref=b537cb186ed7b200c8ca86a70be81c56ecd154a3", "patch": "@@ -13,6 +13,7 @@ cov-mark = \"2.0.0-pre.1\"\n rustc-hash = \"1.1.0\"\n itertools = \"0.10.0\"\n either = \"1.6.1\"\n+indexmap = \"1.6.2\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n syntax = { path = \"../syntax\", version = \"0.0.0\" }"}, {"sha": "350e204a1640401671d05b9876cf898559d40dd7", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 122, "deletions": 88, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/b537cb186ed7b200c8ca86a70be81c56ecd154a3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b537cb186ed7b200c8ca86a70be81c56ecd154a3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=b537cb186ed7b200c8ca86a70be81c56ecd154a3", "patch": "@@ -1,13 +1,14 @@\n-use std::iter;\n+use std::{hash::BuildHasherDefault, iter};\n \n use ast::make;\n use either::Either;\n-use hir::{HirDisplay, Local};\n+use hir::{HirDisplay, Local, Semantics};\n use ide_db::{\n     defs::{Definition, NameRefClass},\n     search::{FileReference, ReferenceAccess, SearchScope},\n+    RootDatabase,\n };\n-use itertools::Itertools;\n+use rustc_hash::FxHasher;\n use stdx::format_to;\n use syntax::{\n     ast::{\n@@ -25,6 +26,8 @@ use crate::{\n     AssistId,\n };\n \n+type FxIndexSet<T> = indexmap::IndexSet<T, BuildHasherDefault<FxHasher>>;\n+\n // Assist: extract_function\n //\n // Extracts selected statements into new function.\n@@ -51,7 +54,8 @@ use crate::{\n // }\n // ```\n pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    if ctx.frange.range.is_empty() {\n+    let range = ctx.frange.range;\n+    if range.is_empty() {\n         return None;\n     }\n \n@@ -65,11 +69,9 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         syntax::NodeOrToken::Node(n) => n,\n         syntax::NodeOrToken::Token(t) => t.parent()?,\n     };\n+    let body = extraction_target(&node, range)?;\n \n-    let body = extraction_target(&node, ctx.frange.range)?;\n-\n-    let vars_used_in_body = vars_used_in_body(ctx, &body);\n-    let self_param = self_param_from_usages(ctx, &body, &vars_used_in_body);\n+    let (locals_used, has_await, self_param) = analyze_body(&ctx.sema, &body);\n \n     let anchor = if self_param.is_some() { Anchor::Method } else { Anchor::Freestanding };\n     let insert_after = scope_for_fn_insertion(&body, anchor)?;\n@@ -95,7 +97,7 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         \"Extract into function\",\n         target_range,\n         move |builder| {\n-            let params = extracted_function_params(ctx, &body, &vars_used_in_body);\n+            let params = extracted_function_params(ctx, &body, locals_used.iter().copied());\n \n             let fun = Function {\n                 name: \"fun_name\".to_string(),\n@@ -109,15 +111,10 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n \n             let new_indent = IndentLevel::from_node(&insert_after);\n             let old_indent = fun.body.indent_level();\n-            let body_contains_await = body_contains_await(&fun.body);\n \n-            builder.replace(\n-                target_range,\n-                format_replacement(ctx, &fun, old_indent, body_contains_await),\n-            );\n+            builder.replace(target_range, format_replacement(ctx, &fun, old_indent, has_await));\n \n-            let fn_def =\n-                format_function(ctx, module, &fun, old_indent, new_indent, body_contains_await);\n+            let fn_def = format_function(ctx, module, &fun, old_indent, new_indent, has_await);\n             let insert_offset = insert_after.text_range().end();\n             match ctx.config.snippet_cap {\n                 Some(cap) => builder.insert_snippet(cap, insert_offset, fn_def),\n@@ -500,15 +497,59 @@ impl FunctionBody {\n         }\n     }\n \n-    fn descendants(&self) -> impl Iterator<Item = SyntaxNode> + '_ {\n+    fn walk_expr(&self, cb: &mut dyn FnMut(ast::Expr)) {\n+        match self {\n+            FunctionBody::Expr(expr) => expr.walk(cb),\n+            FunctionBody::Span { parent, text_range } => {\n+                parent\n+                    .statements()\n+                    .filter(|stmt| text_range.contains_range(stmt.syntax().text_range()))\n+                    .filter_map(|stmt| match stmt {\n+                        ast::Stmt::ExprStmt(expr_stmt) => expr_stmt.expr(),\n+                        ast::Stmt::Item(_) => None,\n+                        ast::Stmt::LetStmt(stmt) => stmt.initializer(),\n+                    })\n+                    .for_each(|expr| expr.walk(cb));\n+                if let Some(expr) = parent\n+                    .tail_expr()\n+                    .filter(|it| text_range.contains_range(it.syntax().text_range()))\n+                {\n+                    expr.walk(cb);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn walk_pat(&self, cb: &mut dyn FnMut(ast::Pat)) {\n         match self {\n-            FunctionBody::Expr(expr) => Either::Right(expr.syntax().descendants()),\n-            FunctionBody::Span { parent, text_range } => Either::Left(\n+            FunctionBody::Expr(expr) => expr.walk_patterns(cb),\n+            FunctionBody::Span { parent, text_range } => {\n                 parent\n-                    .syntax()\n-                    .descendants()\n-                    .filter(move |it| text_range.contains_range(it.text_range())),\n-            ),\n+                    .statements()\n+                    .filter(|stmt| text_range.contains_range(stmt.syntax().text_range()))\n+                    .for_each(|stmt| match stmt {\n+                        ast::Stmt::ExprStmt(expr_stmt) => {\n+                            if let Some(expr) = expr_stmt.expr() {\n+                                expr.walk_patterns(cb)\n+                            }\n+                        }\n+                        ast::Stmt::Item(_) => (),\n+                        ast::Stmt::LetStmt(stmt) => {\n+                            if let Some(pat) = stmt.pat() {\n+                                pat.walk(cb);\n+                            }\n+                            if let Some(expr) = stmt.initializer() {\n+                                expr.walk_patterns(cb);\n+                            }\n+                        }\n+                    });\n+                if let Some(expr) = parent\n+                    .tail_expr()\n+                    .filter(|it| text_range.contains_range(it.syntax().text_range()))\n+                {\n+                    expr.walk_patterns(cb);\n+                }\n+            }\n         }\n     }\n \n@@ -622,58 +663,48 @@ fn extraction_target(node: &SyntaxNode, selection_range: TextRange) -> Option<Fu\n     node.ancestors().find_map(ast::Expr::cast).and_then(FunctionBody::from_expr)\n }\n \n-/// list local variables that are referenced in `body`\n-fn vars_used_in_body(ctx: &AssistContext, body: &FunctionBody) -> Vec<Local> {\n+/// Analyzes a function body, returning the used local variables that are referenced in it as well as\n+/// whether it contains an await expression.\n+fn analyze_body(\n+    sema: &Semantics<RootDatabase>,\n+    body: &FunctionBody,\n+) -> (FxIndexSet<Local>, bool, Option<(Local, ast::SelfParam)>) {\n     // FIXME: currently usages inside macros are not found\n-    body.descendants()\n-        .filter_map(ast::NameRef::cast)\n-        .filter_map(|name_ref| NameRefClass::classify(&ctx.sema, &name_ref))\n-        .map(|name_kind| match name_kind {\n-            NameRefClass::Definition(def) => def,\n-            NameRefClass::FieldShorthand { local_ref, field_ref: _ } => {\n-                Definition::Local(local_ref)\n+    let mut has_await = false;\n+    let mut self_param = None;\n+    let mut res = FxIndexSet::default();\n+    body.walk_expr(&mut |expr| {\n+        has_await |= matches!(expr, ast::Expr::AwaitExpr(_));\n+        let name_ref = match expr {\n+            ast::Expr::PathExpr(path_expr) => {\n+                path_expr.path().and_then(|it| it.as_single_name_ref())\n             }\n-        })\n-        .filter_map(|definition| match definition {\n-            Definition::Local(local) => Some(local),\n-            _ => None,\n-        })\n-        .unique()\n-        .collect()\n-}\n-\n-fn body_contains_await(body: &FunctionBody) -> bool {\n-    body.descendants().any(|d| matches!(d.kind(), SyntaxKind::AWAIT_EXPR))\n-}\n-\n-/// find `self` param, that was not defined inside `body`\n-///\n-/// It should skip `self` params from impls inside `body`\n-fn self_param_from_usages(\n-    ctx: &AssistContext,\n-    body: &FunctionBody,\n-    vars_used_in_body: &[Local],\n-) -> Option<(Local, ast::SelfParam)> {\n-    let mut iter = vars_used_in_body\n-        .iter()\n-        .filter(|var| var.is_self(ctx.db()))\n-        .map(|var| (var, var.source(ctx.db())))\n-        .filter(|(_, src)| is_defined_before(ctx, body, src))\n-        .filter_map(|(&node, src)| match src.value {\n-            Either::Right(it) => Some((node, it)),\n-            Either::Left(_) => {\n-                stdx::never!(false, \"Local::is_self returned true, but source is IdentPat\");\n-                None\n+            _ => return,\n+        };\n+        if let Some(name_ref) = name_ref {\n+            if let Some(\n+                NameRefClass::Definition(Definition::Local(local_ref))\n+                | NameRefClass::FieldShorthand { local_ref, field_ref: _ },\n+            ) = NameRefClass::classify(sema, &name_ref)\n+            {\n+                res.insert(local_ref);\n+                if local_ref.is_self(sema.db) {\n+                    match local_ref.source(sema.db).value {\n+                        Either::Right(it) => {\n+                            stdx::always!(\n+                                self_param.replace((local_ref, it)).is_none(),\n+                                \"body references two different self params\"\n+                            );\n+                        }\n+                        Either::Left(_) => {\n+                            stdx::never!(\"Local::is_self returned true, but source is IdentPat\");\n+                        }\n+                    }\n+                }\n             }\n-        });\n-\n-    let self_param = iter.next();\n-    stdx::always!(\n-        iter.next().is_none(),\n-        \"body references two different self params, both defined outside\"\n-    );\n-\n-    self_param\n+        }\n+    });\n+    (res, has_await, self_param)\n }\n \n /// find variables that should be extracted as params\n@@ -682,16 +713,15 @@ fn self_param_from_usages(\n fn extracted_function_params(\n     ctx: &AssistContext,\n     body: &FunctionBody,\n-    vars_used_in_body: &[Local],\n+    locals: impl Iterator<Item = Local>,\n ) -> Vec<Param> {\n-    vars_used_in_body\n-        .iter()\n-        .filter(|var| !var.is_self(ctx.db()))\n-        .map(|node| (node, node.source(ctx.db())))\n-        .filter(|(_, src)| is_defined_before(ctx, body, src))\n-        .filter_map(|(&node, src)| {\n+    locals\n+        .filter(|local| !local.is_self(ctx.db()))\n+        .map(|local| (local, local.source(ctx.db())))\n+        .filter(|(_, src)| is_defined_outside_of_body(ctx, body, src))\n+        .filter_map(|(local, src)| {\n             if src.value.is_left() {\n-                Some(node)\n+                Some(local)\n             } else {\n                 stdx::never!(false, \"Local::is_self returned false, but source is SelfParam\");\n                 None\n@@ -838,14 +868,18 @@ fn path_element_of_reference(\n }\n \n /// list local variables defined inside `body`\n-fn vars_defined_in_body(body: &FunctionBody, ctx: &AssistContext) -> Vec<Local> {\n+fn locals_defined_in_body(body: &FunctionBody, ctx: &AssistContext) -> FxIndexSet<Local> {\n     // FIXME: this doesn't work well with macros\n     //        see https://github.com/rust-analyzer/rust-analyzer/pull/7535#discussion_r570048550\n-    body.descendants()\n-        .filter_map(ast::IdentPat::cast)\n-        .filter_map(|let_stmt| ctx.sema.to_def(&let_stmt))\n-        .unique()\n-        .collect()\n+    let mut res = FxIndexSet::default();\n+    body.walk_pat(&mut |pat| {\n+        if let ast::Pat::IdentPat(pat) = pat {\n+            if let Some(local) = ctx.sema.to_def(&pat) {\n+                res.insert(local);\n+            }\n+        }\n+    });\n+    res\n }\n \n /// list local variables defined inside `body` that should be returned from extracted function\n@@ -854,15 +888,15 @@ fn vars_defined_in_body_and_outlive(\n     body: &FunctionBody,\n     parent: &SyntaxNode,\n ) -> Vec<OutlivedLocal> {\n-    let vars_defined_in_body = vars_defined_in_body(body, ctx);\n+    let vars_defined_in_body = locals_defined_in_body(body, ctx);\n     vars_defined_in_body\n         .into_iter()\n         .filter_map(|var| var_outlives_body(ctx, body, var, parent))\n         .collect()\n }\n \n /// checks if the relevant local was defined before(outside of) body\n-fn is_defined_before(\n+fn is_defined_outside_of_body(\n     ctx: &AssistContext,\n     body: &FunctionBody,\n     src: &hir::InFile<Either<ast::IdentPat, ast::SelfParam>>,"}, {"sha": "e9465536c8d35cd8ab27899721db8c0d814c9b00", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b537cb186ed7b200c8ca86a70be81c56ecd154a3/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b537cb186ed7b200c8ca86a70be81c56ecd154a3/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=b537cb186ed7b200c8ca86a70be81c56ecd154a3", "patch": "@@ -103,6 +103,81 @@ impl ast::Expr {\n             }\n         }\n     }\n+\n+    /// Preorder walk all the expression's child patterns.\n+    pub fn walk_patterns(&self, cb: &mut dyn FnMut(ast::Pat)) {\n+        let mut preorder = self.syntax().preorder();\n+        while let Some(event) = preorder.next() {\n+            let node = match event {\n+                WalkEvent::Enter(node) => node,\n+                WalkEvent::Leave(_) => continue,\n+            };\n+            match ast::Stmt::cast(node.clone()) {\n+                Some(ast::Stmt::LetStmt(l)) => {\n+                    if let Some(pat) = l.pat() {\n+                        pat.walk(cb);\n+                    }\n+                    if let Some(expr) = l.initializer() {\n+                        expr.walk_patterns(cb);\n+                    }\n+                    preorder.skip_subtree();\n+                }\n+                // Don't skip subtree since we want to process the expression child next\n+                Some(ast::Stmt::ExprStmt(_)) => (),\n+                // skip inner items which might have their own patterns\n+                Some(ast::Stmt::Item(_)) => preorder.skip_subtree(),\n+                None => {\n+                    // skip const args, those are a different context\n+                    if ast::GenericArg::can_cast(node.kind()) {\n+                        preorder.skip_subtree();\n+                    } else if let Some(expr) = ast::Expr::cast(node.clone()) {\n+                        let is_different_context = match &expr {\n+                            ast::Expr::EffectExpr(effect) => {\n+                                matches!(\n+                                    effect.effect(),\n+                                    ast::Effect::Async(_)\n+                                        | ast::Effect::Try(_)\n+                                        | ast::Effect::Const(_)\n+                                )\n+                            }\n+                            ast::Expr::ClosureExpr(_) => true,\n+                            _ => false,\n+                        };\n+                        if is_different_context {\n+                            preorder.skip_subtree();\n+                        }\n+                    } else if let Some(pat) = ast::Pat::cast(node) {\n+                        preorder.skip_subtree();\n+                        pat.walk(cb);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl ast::Pat {\n+    /// Preorder walk all the pattern's sub patterns.\n+    pub fn walk(&self, cb: &mut dyn FnMut(ast::Pat)) {\n+        let mut preorder = self.syntax().preorder();\n+        while let Some(event) = preorder.next() {\n+            let node = match event {\n+                WalkEvent::Enter(node) => node,\n+                WalkEvent::Leave(_) => continue,\n+            };\n+            match ast::Pat::cast(node.clone()) {\n+                Some(ast::Pat::ConstBlockPat(_)) => preorder.skip_subtree(),\n+                Some(pat) => {\n+                    cb(pat);\n+                }\n+                // skip const args\n+                None if ast::GenericArg::can_cast(node.kind()) => {\n+                    preorder.skip_subtree();\n+                }\n+                None => (),\n+            }\n+        }\n+    }\n }\n \n #[derive(Debug, PartialEq, Eq, Clone)]"}]}