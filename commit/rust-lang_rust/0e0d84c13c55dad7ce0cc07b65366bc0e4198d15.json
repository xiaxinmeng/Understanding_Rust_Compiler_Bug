{"sha": "0e0d84c13c55dad7ce0cc07b65366bc0e4198d15", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlMGQ4NGMxM2M1NWRhZDdjZTBjYzA3YjY1MzY2YmMwZTQxOThkMTU=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-01T20:25:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-01T20:25:15Z"}, "message": "Rollup merge of #70535 - jonas-schievink:graph-refactor, r=nikomatsakis\n\nTrack the finalizing node in the specialization graph\n\nFixes https://github.com/rust-lang/rust/issues/70419\nFixes https://github.com/rust-lang/rust/issues/70442\n\nr? @eddyb", "tree": {"sha": "22e03bf8572a2f1c6963c46e8ad87897dfe918e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22e03bf8572a2f1c6963c46e8ad87897dfe918e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e0d84c13c55dad7ce0cc07b65366bc0e4198d15", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJehPirCRBK7hj4Ov3rIwAAdHIIAFmqJqe4xot3rzMHOhBlz6VS\n/BsL9jliVo47LQB01SgXnz5Kod2tWuNhbOOjw20gmsOzdIvblqqfvTaY5nffk1qp\nJUiha20h772W4r8ZxI61oqPcUiCJ/f21saXeG/N2e91b/7glGSQjl24QGxIbvX8a\nOLVUvEGNRfe4jsRSDvx1oEwNEyfgro+kT2xCg+kwuI7mBUAKbr+lnp/7CElrPXNq\n+7DnVJOcq8I+VDlxtRSWQ191WNwOH9cYNJrbMaTsHvgZ2tgJt1h1Fi9kQf63VTao\nAL8gabBJnU5musWYoiZj9tPMryUDvErDLT/Qmya/MMpmfQzTyz5d/tQys8HObN8=\n=vFIF\n-----END PGP SIGNATURE-----\n", "payload": "tree 22e03bf8572a2f1c6963c46e8ad87897dfe918e5\nparent 235938d1acdd93d6641a741c81f64e415b786751\nparent fd8f8189d3323737a06285c9a4b926fefc9411fa\nauthor Dylan DPC <dylan.dpc@gmail.com> 1585772715 +0200\ncommitter GitHub <noreply@github.com> 1585772715 +0200\n\nRollup merge of #70535 - jonas-schievink:graph-refactor, r=nikomatsakis\n\nTrack the finalizing node in the specialization graph\n\nFixes https://github.com/rust-lang/rust/issues/70419\nFixes https://github.com/rust-lang/rust/issues/70442\n\nr? @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e0d84c13c55dad7ce0cc07b65366bc0e4198d15", "html_url": "https://github.com/rust-lang/rust/commit/0e0d84c13c55dad7ce0cc07b65366bc0e4198d15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e0d84c13c55dad7ce0cc07b65366bc0e4198d15/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "235938d1acdd93d6641a741c81f64e415b786751", "url": "https://api.github.com/repos/rust-lang/rust/commits/235938d1acdd93d6641a741c81f64e415b786751", "html_url": "https://github.com/rust-lang/rust/commit/235938d1acdd93d6641a741c81f64e415b786751"}, {"sha": "fd8f8189d3323737a06285c9a4b926fefc9411fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd8f8189d3323737a06285c9a4b926fefc9411fa", "html_url": "https://github.com/rust-lang/rust/commit/fd8f8189d3323737a06285c9a4b926fefc9411fa"}], "stats": {"total": 270, "additions": 149, "deletions": 121}, "files": [{"sha": "a2793f98050048ceeed91f55138599f5ebe0982e", "filename": "src/librustc_middle/traits/specialization_graph.rs", "status": "modified", "additions": 59, "deletions": 11, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0e0d84c13c55dad7ce0cc07b65366bc0e4198d15/src%2Flibrustc_middle%2Ftraits%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e0d84c13c55dad7ce0cc07b65366bc0e4198d15/src%2Flibrustc_middle%2Ftraits%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fspecialization_graph.rs?ref=0e0d84c13c55dad7ce0cc07b65366bc0e4198d15", "patch": "@@ -154,14 +154,44 @@ impl Iterator for Ancestors<'_> {\n     }\n }\n \n-pub struct NodeItem<T> {\n-    pub node: Node,\n-    pub item: T,\n+/// Information about the most specialized definition of an associated item.\n+pub struct LeafDef {\n+    /// The associated item described by this `LeafDef`.\n+    pub item: ty::AssocItem,\n+\n+    /// The node in the specialization graph containing the definition of `item`.\n+    pub defining_node: Node,\n+\n+    /// The \"top-most\" (ie. least specialized) specialization graph node that finalized the\n+    /// definition of `item`.\n+    ///\n+    /// Example:\n+    ///\n+    /// ```\n+    /// trait Tr {\n+    ///     fn assoc(&self);\n+    /// }\n+    ///\n+    /// impl<T> Tr for T {\n+    ///     default fn assoc(&self) {}\n+    /// }\n+    ///\n+    /// impl Tr for u8 {}\n+    /// ```\n+    ///\n+    /// If we start the leaf definition search at `impl Tr for u8`, that impl will be the\n+    /// `finalizing_node`, while `defining_node` will be the generic impl.\n+    ///\n+    /// If the leaf definition search is started at the generic impl, `finalizing_node` will be\n+    /// `None`, since the most specialized impl we found still allows overriding the method\n+    /// (doesn't finalize it).\n+    pub finalizing_node: Option<Node>,\n }\n \n-impl<T> NodeItem<T> {\n-    pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> NodeItem<U> {\n-        NodeItem { node: self.node, item: f(self.item) }\n+impl LeafDef {\n+    /// Returns whether this definition is known to not be further specializable.\n+    pub fn is_final(&self) -> bool {\n+        self.finalizing_node.is_some()\n     }\n }\n \n@@ -173,18 +203,36 @@ impl<'tcx> Ancestors<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         trait_item_name: Ident,\n         trait_item_kind: ty::AssocKind,\n-    ) -> Option<NodeItem<ty::AssocItem>> {\n+    ) -> Option<LeafDef> {\n         let trait_def_id = self.trait_def_id;\n+        let mut finalizing_node = None;\n+\n         self.find_map(|node| {\n-            node.item(tcx, trait_item_name, trait_item_kind, trait_def_id)\n-                .map(|item| NodeItem { node, item })\n+            if let Some(item) = node.item(tcx, trait_item_name, trait_item_kind, trait_def_id) {\n+                if finalizing_node.is_none() {\n+                    let is_specializable = item.defaultness.is_default()\n+                        || tcx.impl_defaultness(node.def_id()).is_default();\n+\n+                    if !is_specializable {\n+                        finalizing_node = Some(node);\n+                    }\n+                }\n+\n+                Some(LeafDef { item, defining_node: node, finalizing_node })\n+            } else {\n+                // Item not mentioned. This \"finalizes\" any defaulted item provided by an ancestor.\n+                finalizing_node = Some(node);\n+                None\n+            }\n         })\n     }\n }\n \n /// Walk up the specialization ancestors of a given impl, starting with that\n-/// impl itself. Returns `None` if an error was reported while building the\n-/// specialization graph.\n+/// impl itself.\n+///\n+/// Returns `Err` if an error was reported while building the specialization\n+/// graph.\n pub fn ancestors(\n     tcx: TyCtxt<'tcx>,\n     trait_def_id: DefId,"}, {"sha": "5f98850633075f5540ef1526b95983032c927aa5", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e0d84c13c55dad7ce0cc07b65366bc0e4198d15/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e0d84c13c55dad7ce0cc07b65366bc0e4198d15/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=0e0d84c13c55dad7ce0cc07b65366bc0e4198d15", "patch": "@@ -54,7 +54,6 @@ pub use self::project::{\n };\n pub use self::select::{EvaluationCache, SelectionCache, SelectionContext};\n pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError};\n-pub use self::specialize::find_associated_item;\n pub use self::specialize::specialization_graph::FutureCompatOverlapError;\n pub use self::specialize::specialization_graph::FutureCompatOverlapErrorKind;\n pub use self::specialize::{specialization_graph, translate_substs, OverlapError};\n@@ -64,8 +63,7 @@ pub use self::structural_match::NonStructuralMatchTy;\n pub use self::util::{elaborate_predicates, elaborate_trait_ref, elaborate_trait_refs};\n pub use self::util::{expand_trait_aliases, TraitAliasExpander};\n pub use self::util::{\n-    get_vtable_index_of_object_method, impl_is_default, impl_item_is_final,\n-    predicate_for_trait_def, upcast_choices,\n+    get_vtable_index_of_object_method, impl_item_is_final, predicate_for_trait_def, upcast_choices,\n };\n pub use self::util::{\n     supertrait_def_ids, supertraits, transitive_bounds, SupertraitDefIds, Supertraits,"}, {"sha": "aae0d46756331310c063f589ac859f2de4bd37de", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 11, "deletions": 37, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0e0d84c13c55dad7ce0cc07b65366bc0e4198d15/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e0d84c13c55dad7ce0cc07b65366bc0e4198d15/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=0e0d84c13c55dad7ce0cc07b65366bc0e4198d15", "patch": "@@ -1015,49 +1015,21 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                     assoc_ty_def(selcx, impl_data.impl_def_id, obligation.predicate.item_def_id)\n                         .map_err(|ErrorReported| ())?;\n \n-                let is_default = if node_item.node.is_from_trait() {\n-                    // If true, the impl inherited a `type Foo = Bar`\n-                    // given in the trait, which is implicitly default.\n-                    // Otherwise, the impl did not specify `type` and\n-                    // neither did the trait:\n-                    //\n-                    // ```rust\n-                    // trait Foo { type T; }\n-                    // impl Foo for Bar { }\n-                    // ```\n-                    //\n-                    // This is an error, but it will be\n-                    // reported in `check_impl_items_against_trait`.\n-                    // We accept it here but will flag it as\n-                    // an error when we confirm the candidate\n-                    // (which will ultimately lead to `normalize_to_error`\n-                    // being invoked).\n-                    false\n+                if node_item.is_final() {\n+                    // Non-specializable items are always projectable.\n+                    true\n                 } else {\n-                    // If we're looking at a trait *impl*, the item is\n-                    // specializable if the impl or the item are marked\n-                    // `default`.\n-                    node_item.item.defaultness.is_default()\n-                        || super::util::impl_is_default(selcx.tcx(), node_item.node.def_id())\n-                };\n-\n-                match is_default {\n-                    // Non-specializable items are always projectable\n-                    false => true,\n-\n                     // Only reveal a specializable default if we're past type-checking\n                     // and the obligation is monomorphic, otherwise passes such as\n                     // transmute checking and polymorphic MIR optimizations could\n                     // get a result which isn't correct for all monomorphizations.\n-                    true if obligation.param_env.reveal == Reveal::All => {\n+                    if obligation.param_env.reveal == Reveal::All {\n                         // NOTE(eddyb) inference variables can resolve to parameters, so\n                         // assume `poly_trait_ref` isn't monomorphic, if it contains any.\n                         let poly_trait_ref =\n                             selcx.infcx().resolve_vars_if_possible(&poly_trait_ref);\n                         !poly_trait_ref.needs_infer() && !poly_trait_ref.needs_subst()\n-                    }\n-\n-                    true => {\n+                    } else {\n                         debug!(\n                             \"assemble_candidates_from_impls: not eligible due to default: \\\n                              assoc_ty={} predicate={}\",\n@@ -1422,7 +1394,8 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n         return Progress { ty: tcx.types.err, obligations: nested };\n     }\n     let substs = obligation.predicate.substs.rebase_onto(tcx, trait_def_id, substs);\n-    let substs = translate_substs(selcx.infcx(), param_env, impl_def_id, substs, assoc_ty.node);\n+    let substs =\n+        translate_substs(selcx.infcx(), param_env, impl_def_id, substs, assoc_ty.defining_node);\n     let ty = if let ty::AssocKind::OpaqueTy = assoc_ty.item.kind {\n         let item_substs = InternalSubsts::identity_for_item(tcx, assoc_ty.item.def_id);\n         tcx.mk_opaque(assoc_ty.item.def_id, item_substs)\n@@ -1447,7 +1420,7 @@ fn assoc_ty_def(\n     selcx: &SelectionContext<'_, '_>,\n     impl_def_id: DefId,\n     assoc_ty_def_id: DefId,\n-) -> Result<specialization_graph::NodeItem<ty::AssocItem>, ErrorReported> {\n+) -> Result<specialization_graph::LeafDef, ErrorReported> {\n     let tcx = selcx.tcx();\n     let assoc_ty_name = tcx.associated_item(assoc_ty_def_id).ident;\n     let trait_def_id = tcx.impl_trait_ref(impl_def_id).unwrap().def_id;\n@@ -1464,9 +1437,10 @@ fn assoc_ty_def(\n         if matches!(item.kind, ty::AssocKind::Type | ty::AssocKind::OpaqueTy)\n             && tcx.hygienic_eq(item.ident, assoc_ty_name, trait_def_id)\n         {\n-            return Ok(specialization_graph::NodeItem {\n-                node: specialization_graph::Node::Impl(impl_def_id),\n+            return Ok(specialization_graph::LeafDef {\n                 item: *item,\n+                defining_node: impl_node,\n+                finalizing_node: if item.defaultness.is_default() { None } else { Some(impl_node) },\n             });\n         }\n     }"}, {"sha": "fabd8c89b72af7e075e8476bf747495f9a6d26d9", "filename": "src/librustc_trait_selection/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 43, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0e0d84c13c55dad7ce0cc07b65366bc0e4198d15/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e0d84c13c55dad7ce0cc07b65366bc0e4198d15/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs?ref=0e0d84c13c55dad7ce0cc07b65366bc0e4198d15", "patch": "@@ -20,7 +20,7 @@ use rustc_errors::struct_span_err;\n use rustc_hir::def_id::DefId;\n use rustc_middle::lint::LintDiagnosticBuilder;\n use rustc_middle::ty::subst::{InternalSubsts, Subst, SubstsRef};\n-use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::lint::builtin::COHERENCE_LEAK_CHECK;\n use rustc_session::lint::builtin::ORDER_DEPENDENT_TRAIT_OBJECTS;\n use rustc_span::DUMMY_SP;\n@@ -112,48 +112,6 @@ pub fn translate_substs<'a, 'tcx>(\n     source_substs.rebase_onto(infcx.tcx, source_impl, target_substs)\n }\n \n-/// Given a selected impl described by `impl_data`, returns the\n-/// definition and substitutions for the method with the name `name`\n-/// the kind `kind`, and trait method substitutions `substs`, in\n-/// that impl, a less specialized impl, or the trait default,\n-/// whichever applies.\n-pub fn find_associated_item<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    item: &ty::AssocItem,\n-    substs: SubstsRef<'tcx>,\n-    impl_data: &super::VtableImplData<'tcx, ()>,\n-) -> (DefId, SubstsRef<'tcx>) {\n-    debug!(\"find_associated_item({:?}, {:?}, {:?}, {:?})\", param_env, item, substs, impl_data);\n-    assert!(!substs.needs_infer());\n-\n-    let trait_def_id = tcx.trait_id_of_impl(impl_data.impl_def_id).unwrap();\n-    let trait_def = tcx.trait_def(trait_def_id);\n-\n-    if let Ok(ancestors) = trait_def.ancestors(tcx, impl_data.impl_def_id) {\n-        match ancestors.leaf_def(tcx, item.ident, item.kind) {\n-            Some(node_item) => {\n-                let substs = tcx.infer_ctxt().enter(|infcx| {\n-                    let param_env = param_env.with_reveal_all();\n-                    let substs = substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n-                    let substs = translate_substs(\n-                        &infcx,\n-                        param_env,\n-                        impl_data.impl_def_id,\n-                        substs,\n-                        node_item.node,\n-                    );\n-                    infcx.tcx.erase_regions(&substs)\n-                });\n-                (node_item.item.def_id, substs)\n-            }\n-            None => bug!(\"{:?} not found in {:?}\", item, impl_data.impl_def_id),\n-        }\n-    } else {\n-        (item.def_id, substs)\n-    }\n-}\n-\n /// Is `impl1` a specialization of `impl2`?\n ///\n /// Specialization is determined by the sets of types to which the impls apply;"}, {"sha": "6348673dab8b542a28450966d6da22f68f31a957", "filename": "src/librustc_trait_selection/traits/util.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0e0d84c13c55dad7ce0cc07b65366bc0e4198d15/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e0d84c13c55dad7ce0cc07b65366bc0e4198d15/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs?ref=0e0d84c13c55dad7ce0cc07b65366bc0e4198d15", "patch": "@@ -4,7 +4,6 @@ use smallvec::smallvec;\n use smallvec::SmallVec;\n \n use rustc_data_structures::fx::FxHashSet;\n-use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::outlives::Component;\n use rustc_middle::ty::subst::{GenericArg, Subst, SubstsRef};\n@@ -651,22 +650,8 @@ pub fn generator_trait_ref_and_outputs(\n     ty::Binder::bind((trait_ref, sig.skip_binder().yield_ty, sig.skip_binder().return_ty))\n }\n \n-pub fn impl_is_default(tcx: TyCtxt<'_>, node_item_def_id: DefId) -> bool {\n-    match tcx.hir().as_local_hir_id(node_item_def_id) {\n-        Some(hir_id) => {\n-            let item = tcx.hir().expect_item(hir_id);\n-            if let hir::ItemKind::Impl { defaultness, .. } = item.kind {\n-                defaultness.is_default()\n-            } else {\n-                false\n-            }\n-        }\n-        None => tcx.impl_defaultness(node_item_def_id).is_default(),\n-    }\n-}\n-\n pub fn impl_item_is_final(tcx: TyCtxt<'_>, assoc_item: &ty::AssocItem) -> bool {\n-    assoc_item.defaultness.is_final() && !impl_is_default(tcx, assoc_item.container.id())\n+    assoc_item.defaultness.is_final() && tcx.impl_defaultness(assoc_item.container.id()).is_final()\n }\n \n pub enum TupleArgumentsFlag {"}, {"sha": "47c4b1c41cdbdbc4fae61918836d4b530f611068", "filename": "src/librustc_ty/instance.rs", "status": "modified", "additions": 39, "deletions": 8, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0e0d84c13c55dad7ce0cc07b65366bc0e4198d15/src%2Flibrustc_ty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e0d84c13c55dad7ce0cc07b65366bc0e4198d15/src%2Flibrustc_ty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Finstance.rs?ref=0e0d84c13c55dad7ce0cc07b65366bc0e4198d15", "patch": "@@ -1,9 +1,11 @@\n use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Instance, TyCtxt, TypeFoldable};\n use rustc_span::sym;\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n+use traits::{translate_substs, Reveal};\n \n use log::debug;\n \n@@ -82,21 +84,50 @@ fn resolve_associated_item<'tcx>(\n     // the actual function:\n     match vtbl {\n         traits::VtableImpl(impl_data) => {\n-            let (def_id, substs) =\n-                traits::find_associated_item(tcx, param_env, trait_item, rcvr_substs, &impl_data);\n-\n-            let resolved_item = tcx.associated_item(def_id);\n+            debug!(\n+                \"resolving VtableImpl: {:?}, {:?}, {:?}, {:?}\",\n+                param_env, trait_item, rcvr_substs, impl_data\n+            );\n+            assert!(!rcvr_substs.needs_infer());\n+            assert!(!trait_ref.needs_infer());\n+\n+            let trait_def_id = tcx.trait_id_of_impl(impl_data.impl_def_id).unwrap();\n+            let trait_def = tcx.trait_def(trait_def_id);\n+            let leaf_def = trait_def\n+                .ancestors(tcx, impl_data.impl_def_id)\n+                .ok()?\n+                .leaf_def(tcx, trait_item.ident, trait_item.kind)\n+                .unwrap_or_else(|| {\n+                    bug!(\"{:?} not found in {:?}\", trait_item, impl_data.impl_def_id);\n+                });\n+            let def_id = leaf_def.item.def_id;\n+\n+            let substs = tcx.infer_ctxt().enter(|infcx| {\n+                let param_env = param_env.with_reveal_all();\n+                let substs = rcvr_substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n+                let substs = translate_substs(\n+                    &infcx,\n+                    param_env,\n+                    impl_data.impl_def_id,\n+                    substs,\n+                    leaf_def.defining_node,\n+                );\n+                infcx.tcx.erase_regions(&substs)\n+            });\n \n             // Since this is a trait item, we need to see if the item is either a trait default item\n             // or a specialization because we can't resolve those unless we can `Reveal::All`.\n             // NOTE: This should be kept in sync with the similar code in\n             // `rustc_middle::traits::project::assemble_candidates_from_impls()`.\n-            let eligible = if !resolved_item.defaultness.is_default() {\n+            let eligible = if leaf_def.is_final() {\n+                // Non-specializable items are always projectable.\n                 true\n-            } else if param_env.reveal == traits::Reveal::All {\n-                !trait_ref.needs_subst()\n             } else {\n-                false\n+                // Only reveal a specializable default if we're past type-checking\n+                // and the obligation is monomorphic, otherwise passes such as\n+                // transmute checking and polymorphic MIR optimizations could\n+                // get a result which isn't correct for all monomorphizations.\n+                if param_env.reveal == Reveal::All { !trait_ref.needs_subst() } else { false }\n             };\n \n             if !eligible {"}, {"sha": "aefe61f60b87a4e59b2d2effa8a9d33b1cc751d6", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0e0d84c13c55dad7ce0cc07b65366bc0e4198d15/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e0d84c13c55dad7ce0cc07b65366bc0e4198d15/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=0e0d84c13c55dad7ce0cc07b65366bc0e4198d15", "patch": "@@ -165,6 +165,16 @@ fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n     )\n }\n \n+fn impl_defaultness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::Defaultness {\n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let item = tcx.hir().expect_item(hir_id);\n+    if let hir::ItemKind::Impl { defaultness, .. } = item.kind {\n+        defaultness\n+    } else {\n+        bug!(\"`impl_defaultness` called on {:?}\", item);\n+    }\n+}\n+\n /// Calculates the `Sized` constraint.\n ///\n /// In fact, there are only a few options for the types in the constraint:\n@@ -371,6 +381,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         crate_hash,\n         instance_def_size_estimate,\n         issue33140_self_ty,\n+        impl_defaultness,\n         ..*providers\n     };\n }"}, {"sha": "3823efe9d927e9667fd9ede644a9cbb876d36815", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e0d84c13c55dad7ce0cc07b65366bc0e4198d15/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e0d84c13c55dad7ce0cc07b65366bc0e4198d15/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0e0d84c13c55dad7ce0cc07b65366bc0e4198d15", "patch": "@@ -1942,7 +1942,7 @@ fn check_specialization_validity<'tcx>(\n             // grandparent. In that case, if parent is a `default impl`, inherited items use the\n             // \"defaultness\" from the grandparent, else they are final.\n             None => {\n-                if traits::impl_is_default(tcx, parent_impl.def_id()) {\n+                if tcx.impl_defaultness(parent_impl.def_id()).is_default() {\n                     None\n                 } else {\n                     Some(Err(parent_impl.def_id()))\n@@ -2114,10 +2114,10 @@ fn check_impl_items_against_trait<'tcx>(\n         for trait_item in tcx.associated_items(impl_trait_ref.def_id).in_definition_order() {\n             let is_implemented = ancestors\n                 .leaf_def(tcx, trait_item.ident, trait_item.kind)\n-                .map(|node_item| !node_item.node.is_from_trait())\n+                .map(|node_item| !node_item.defining_node.is_from_trait())\n                 .unwrap_or(false);\n \n-            if !is_implemented && !traits::impl_is_default(tcx, impl_id) {\n+            if !is_implemented && tcx.impl_defaultness(impl_id).is_final() {\n                 if !trait_item.defaultness.has_value() {\n                     missing_items.push(*trait_item);\n                 }"}, {"sha": "4371dd2e16747784fc67047d13384ac5a8cccbe0", "filename": "src/test/ui/specialization/issue-70442.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0e0d84c13c55dad7ce0cc07b65366bc0e4198d15/src%2Ftest%2Fui%2Fspecialization%2Fissue-70442.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e0d84c13c55dad7ce0cc07b65366bc0e4198d15/src%2Ftest%2Fui%2Fspecialization%2Fissue-70442.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fissue-70442.rs?ref=0e0d84c13c55dad7ce0cc07b65366bc0e4198d15", "patch": "@@ -0,0 +1,23 @@\n+#![feature(specialization)]\n+\n+// check-pass\n+\n+trait Trait {\n+    type Assoc;\n+}\n+\n+impl<T> Trait for T {\n+    default type Assoc = bool;\n+}\n+\n+// This impl inherits the `Assoc` definition from above and \"locks it in\", or finalizes it, making\n+// child impls unable to further specialize it. However, since the specialization graph didn't\n+// correctly track this, we would refuse to project `Assoc` from this impl, even though that should\n+// happen for items that are final.\n+impl Trait for () {}\n+\n+fn foo<X: Trait<Assoc=bool>>() {}\n+\n+fn main() {\n+    foo::<()>();  // `<() as Trait>::Assoc` is normalized to `bool` correctly\n+}"}]}