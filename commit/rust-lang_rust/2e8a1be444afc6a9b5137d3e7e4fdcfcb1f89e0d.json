{"sha": "2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlOGExYmU0NDRhZmM2YTliNTEzN2QzZTdlNGZkY2ZjYjFmODllMGQ=", "commit": {"author": {"name": "robojumper", "email": "robojumper@gmail.com", "date": "2020-07-05T20:10:59Z"}, "committer": {"name": "robojumper", "email": "robojumper@gmail.com", "date": "2020-07-06T16:25:20Z"}, "message": "new lint: match_like_matches_macro", "tree": {"sha": "9d9a666d2ad727ea925b463103f4a1272948177d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d9a666d2ad727ea925b463103f4a1272948177d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d", "html_url": "https://github.com/rust-lang/rust/commit/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/comments", "author": {"login": "robojumper", "id": 14299449, "node_id": "MDQ6VXNlcjE0Mjk5NDQ5", "avatar_url": "https://avatars.githubusercontent.com/u/14299449?v=4", "gravatar_id": "", "url": "https://api.github.com/users/robojumper", "html_url": "https://github.com/robojumper", "followers_url": "https://api.github.com/users/robojumper/followers", "following_url": "https://api.github.com/users/robojumper/following{/other_user}", "gists_url": "https://api.github.com/users/robojumper/gists{/gist_id}", "starred_url": "https://api.github.com/users/robojumper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/robojumper/subscriptions", "organizations_url": "https://api.github.com/users/robojumper/orgs", "repos_url": "https://api.github.com/users/robojumper/repos", "events_url": "https://api.github.com/users/robojumper/events{/privacy}", "received_events_url": "https://api.github.com/users/robojumper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "robojumper", "id": 14299449, "node_id": "MDQ6VXNlcjE0Mjk5NDQ5", "avatar_url": "https://avatars.githubusercontent.com/u/14299449?v=4", "gravatar_id": "", "url": "https://api.github.com/users/robojumper", "html_url": "https://github.com/robojumper", "followers_url": "https://api.github.com/users/robojumper/followers", "following_url": "https://api.github.com/users/robojumper/following{/other_user}", "gists_url": "https://api.github.com/users/robojumper/gists{/gist_id}", "starred_url": "https://api.github.com/users/robojumper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/robojumper/subscriptions", "organizations_url": "https://api.github.com/users/robojumper/orgs", "repos_url": "https://api.github.com/users/robojumper/repos", "events_url": "https://api.github.com/users/robojumper/events{/privacy}", "received_events_url": "https://api.github.com/users/robojumper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "html_url": "https://github.com/rust-lang/rust/commit/ac856922f80e9ef8cd95c3004699e4bc8fa0c978"}], "stats": {"total": 891, "additions": 563, "deletions": 328}, "files": [{"sha": "6261ca4879a53587684eccb240271934e460f77f", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d", "patch": "@@ -1513,6 +1513,7 @@ Released 2018-09-13\n [`map_unwrap_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_unwrap_or\n [`match_as_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_as_ref\n [`match_bool`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_bool\n+[`match_like_matches_macro`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_like_matches_macro\n [`match_on_vec_items`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_on_vec_items\n [`match_overlapping_arm`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_overlapping_arm\n [`match_ref_pats`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_ref_pats"}, {"sha": "34aa2981535dcdfb65286f51f0ea0b78e52ad883", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 380, "deletions": 15, "changes": 395, "blob_url": "https://github.com/rust-lang/rust/blob/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d", "patch": "@@ -13,14 +13,14 @@ use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::def::CtorKind;\n use rustc_hir::{\n-    Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, Local, MatchSource, Mutability, Node, Pat, PatKind,\n-    QPath, RangeEnd,\n+    Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, Guard, Local, MatchSource, Mutability, Node, Pat,\n+    PatKind, QPath, RangeEnd,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::source_map::Span;\n+use rustc_span::source_map::{Span, Spanned};\n use std::cmp::Ordering;\n use std::collections::Bound;\n \n@@ -409,6 +409,67 @@ declare_clippy_lint! {\n     \"a match on a struct that binds all fields but still uses the wildcard pattern\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Lint for redundant pattern matching over `Result` or\n+    /// `Option`\n+    ///\n+    /// **Why is this bad?** It's more concise and clear to just use the proper\n+    /// utility function\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// if let Ok(_) = Ok::<i32, i32>(42) {}\n+    /// if let Err(_) = Err::<i32, i32>(42) {}\n+    /// if let None = None::<()> {}\n+    /// if let Some(_) = Some(42) {}\n+    /// match Ok::<i32, i32>(42) {\n+    ///     Ok(_) => true,\n+    ///     Err(_) => false,\n+    /// };\n+    /// ```\n+    ///\n+    /// The more idiomatic use would be:\n+    ///\n+    /// ```rust\n+    /// if Ok::<i32, i32>(42).is_ok() {}\n+    /// if Err::<i32, i32>(42).is_err() {}\n+    /// if None::<()>.is_none() {}\n+    /// if Some(42).is_some() {}\n+    /// Ok::<i32, i32>(42).is_ok();\n+    /// ```\n+    pub REDUNDANT_PATTERN_MATCHING,\n+    style,\n+    \"use the proper utility function avoiding an `if let`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `match` expressions producing a `bool` that could be written using `matches!`\n+    ///\n+    /// **Why is this bad?** Readability and needless complexity.\n+    ///\n+    /// **Known problems:** This can turn an intentionally exhaustive match into a non-exhaustive one.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = Some(5);\n+    ///\n+    /// // Bad\n+    /// let a = match x {\n+    ///     Some(0) => true,\n+    ///     _ => false,\n+    /// };\n+    ///\n+    /// // Good\n+    /// let a = matches!(x, Some(5));\n+    /// ```\n+    pub MATCH_LIKE_MATCHES_MACRO,\n+    style,\n+    \"a match that could be written with the matches! macro\"\n+}\n+\n #[derive(Default)]\n pub struct Matches {\n     infallible_destructuring_match_linted: bool,\n@@ -427,14 +488,21 @@ impl_lint_pass!(Matches => [\n     WILDCARD_IN_OR_PATTERNS,\n     MATCH_SINGLE_BINDING,\n     INFALLIBLE_DESTRUCTURING_MATCH,\n-    REST_PAT_IN_FULLY_BOUND_STRUCTS\n+    REST_PAT_IN_FULLY_BOUND_STRUCTS,\n+    REDUNDANT_PATTERN_MATCHING,\n+    MATCH_LIKE_MATCHES_MACRO\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Matches {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n+\n+        if !redundant_pattern_match::check(cx, expr) {\n+            check_match_like_matches(cx, expr);\n+        }\n+\n         if let ExprKind::Match(ref ex, ref arms, MatchSource::Normal) = expr.kind {\n             check_single_match(cx, ex, arms, expr);\n             check_match_bool(cx, ex, arms, expr);\n@@ -802,13 +870,8 @@ fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n                     // Some simple checks for exhaustive patterns.\n                     // There is a room for improvements to detect more cases,\n                     // but it can be more expensive to do so.\n-                    let is_pattern_exhaustive = |pat: &&Pat<'_>| {\n-                        if let PatKind::Wild | PatKind::Binding(.., None) = pat.kind {\n-                            true\n-                        } else {\n-                            false\n-                        }\n-                    };\n+                    let is_pattern_exhaustive =\n+                        |pat: &&Pat<'_>| matches!(pat.kind, PatKind::Wild | PatKind::Binding(.., None));\n                     if patterns.iter().all(is_pattern_exhaustive) {\n                         missing_variants.retain(|e| e.ctor_def_id != Some(p.res.def_id()));\n                     }\n@@ -989,6 +1052,78 @@ fn check_wild_in_or_pats(cx: &LateContext<'_>, arms: &[Arm<'_>]) {\n     }\n }\n \n+/// Lint a `match` or `if let .. { .. } else { .. }` expr that could be replaced by `matches!`\n+fn check_match_like_matches<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+    if let ExprKind::Match(ex, arms, ref match_source) = &expr.kind {\n+        match match_source {\n+            MatchSource::Normal => find_matches_sugg(cx, ex, arms, expr, false),\n+            MatchSource::IfLetDesugar { .. } => find_matches_sugg(cx, ex, arms, expr, true),\n+            _ => return,\n+        }\n+    }\n+}\n+\n+/// Lint a `match` or desugared `if let` for replacement by `matches!`\n+fn find_matches_sugg(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>, desugared: bool) {\n+    if_chain! {\n+        if arms.len() == 2;\n+        if cx.tables().expr_ty(expr).is_bool();\n+        if let Some(first) = find_bool_lit(&arms[0].body.kind, desugared);\n+        if let Some(second) = find_bool_lit(&arms[1].body.kind, desugared);\n+        if first != second;\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+\n+            let pat_and_guard = if let Some(Guard::If(g)) = arms[0].guard {\n+                format!(\"{} if {}\", snippet_with_applicability(cx, arms[0].pat.span, \"..\", &mut applicability), snippet_with_applicability(cx, g.span, \"..\", &mut applicability))\n+            } else {\n+                format!(\"{}\", snippet_with_applicability(cx, arms[0].pat.span, \"..\", &mut applicability))\n+            };\n+            span_lint_and_sugg(\n+                cx,\n+                MATCH_LIKE_MATCHES_MACRO,\n+                expr.span,\n+                &format!(\"{} expression looks like `matches!` macro\", if desugared { \"if let .. else\" } else { \"match\" }),\n+                \"try this\",\n+                format!(\n+                    \"{}matches!({}, {})\",\n+                    if first { \"\" } else { \"!\" },\n+                    snippet_with_applicability(cx, ex.span, \"..\", &mut applicability),\n+                    pat_and_guard,\n+                ),\n+                applicability,\n+            )\n+        }\n+    }\n+}\n+\n+/// Extract a `bool` or `{ bool }`\n+fn find_bool_lit(ex: &ExprKind<'_>, desugared: bool) -> Option<bool> {\n+    match ex {\n+        ExprKind::Lit(Spanned {\n+            node: LitKind::Bool(b), ..\n+        }) => Some(*b),\n+        ExprKind::Block(\n+            rustc_hir::Block {\n+                stmts: &[],\n+                expr: Some(exp),\n+                ..\n+            },\n+            _,\n+        ) if desugared => {\n+            if let ExprKind::Lit(Spanned {\n+                node: LitKind::Bool(b), ..\n+            }) = exp.kind\n+            {\n+                Some(b)\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    }\n+}\n+\n fn check_match_single_binding<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     if in_macro(expr.span) || arms.len() != 1 || is_refutable(cx, arms[0].pat) {\n         return;\n@@ -1179,10 +1314,7 @@ fn is_unit_expr(expr: &Expr<'_>) -> bool {\n \n // Checks if arm has the form `None => None`\n fn is_none_arm(arm: &Arm<'_>) -> bool {\n-    match arm.pat.kind {\n-        PatKind::Path(ref path) if match_qpath(path, &paths::OPTION_NONE) => true,\n-        _ => false,\n-    }\n+    matches!(arm.pat.kind, PatKind::Path(ref path) if match_qpath(path, &paths::OPTION_NONE))\n }\n \n // Checks if arm has the form `Some(ref v) => Some(v)` (checks for `ref` and `ref mut`)\n@@ -1293,6 +1425,239 @@ where\n     None\n }\n \n+mod redundant_pattern_match {\n+    use super::REDUNDANT_PATTERN_MATCHING;\n+    use crate::utils::{in_constant, match_qpath, match_trait_method, paths, snippet, span_lint_and_then};\n+    use if_chain::if_chain;\n+    use rustc_ast::ast::LitKind;\n+    use rustc_errors::Applicability;\n+    use rustc_hir::{Arm, Expr, ExprKind, HirId, MatchSource, PatKind, QPath};\n+    use rustc_lint::LateContext;\n+    use rustc_middle::ty;\n+    use rustc_mir::const_eval::is_const_fn;\n+    use rustc_span::source_map::Symbol;\n+\n+    pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+        if let ExprKind::Match(op, arms, ref match_source) = &expr.kind {\n+            match match_source {\n+                MatchSource::Normal => find_sugg_for_match(cx, expr, op, arms),\n+                MatchSource::IfLetDesugar { .. } => find_sugg_for_if_let(cx, expr, op, arms, \"if\"),\n+                MatchSource::WhileLetDesugar => find_sugg_for_if_let(cx, expr, op, arms, \"while\"),\n+                _ => false,\n+            }\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn find_sugg_for_if_let<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        expr: &'tcx Expr<'_>,\n+        op: &Expr<'_>,\n+        arms: &[Arm<'_>],\n+        keyword: &'static str,\n+    ) -> bool {\n+        fn find_suggestion(cx: &LateContext<'_>, hir_id: HirId, path: &QPath<'_>) -> Option<&'static str> {\n+            if match_qpath(path, &paths::RESULT_OK) && can_suggest(cx, hir_id, sym!(result_type), \"is_ok\") {\n+                return Some(\"is_ok()\");\n+            }\n+            if match_qpath(path, &paths::RESULT_ERR) && can_suggest(cx, hir_id, sym!(result_type), \"is_err\") {\n+                return Some(\"is_err()\");\n+            }\n+            if match_qpath(path, &paths::OPTION_SOME) && can_suggest(cx, hir_id, sym!(option_type), \"is_some\") {\n+                return Some(\"is_some()\");\n+            }\n+            if match_qpath(path, &paths::OPTION_NONE) && can_suggest(cx, hir_id, sym!(option_type), \"is_none\") {\n+                return Some(\"is_none()\");\n+            }\n+            None\n+        }\n+\n+        let hir_id = expr.hir_id;\n+        let good_method = match arms[0].pat.kind {\n+            PatKind::TupleStruct(ref path, ref patterns, _) if patterns.len() == 1 => {\n+                if let PatKind::Wild = patterns[0].kind {\n+                    find_suggestion(cx, hir_id, path)\n+                } else {\n+                    None\n+                }\n+            },\n+            PatKind::Path(ref path) => find_suggestion(cx, hir_id, path),\n+            _ => None,\n+        };\n+        let good_method = match good_method {\n+            Some(method) => method,\n+            None => return false,\n+        };\n+\n+        // check that `while_let_on_iterator` lint does not trigger\n+        if_chain! {\n+            if keyword == \"while\";\n+            if let ExprKind::MethodCall(method_path, _, _, _) = op.kind;\n+            if method_path.ident.name == sym!(next);\n+            if match_trait_method(cx, op, &paths::ITERATOR);\n+            then {\n+                return false;\n+            }\n+        }\n+\n+        span_lint_and_then(\n+            cx,\n+            REDUNDANT_PATTERN_MATCHING,\n+            arms[0].pat.span,\n+            &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n+            |diag| {\n+                // while let ... = ... { ... }\n+                // ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+                let expr_span = expr.span;\n+\n+                // while let ... = ... { ... }\n+                //                 ^^^\n+                let op_span = op.span.source_callsite();\n+\n+                // while let ... = ... { ... }\n+                // ^^^^^^^^^^^^^^^^^^^\n+                let span = expr_span.until(op_span.shrink_to_hi());\n+                diag.span_suggestion(\n+                    span,\n+                    \"try this\",\n+                    format!(\"{} {}.{}\", keyword, snippet(cx, op_span, \"_\"), good_method),\n+                    Applicability::MachineApplicable, // snippet\n+                );\n+            },\n+        );\n+        true\n+    }\n+\n+    fn find_sugg_for_match<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        expr: &'tcx Expr<'_>,\n+        op: &Expr<'_>,\n+        arms: &[Arm<'_>],\n+    ) -> bool {\n+        if arms.len() == 2 {\n+            let node_pair = (&arms[0].pat.kind, &arms[1].pat.kind);\n+\n+            let hir_id = expr.hir_id;\n+            let found_good_method = match node_pair {\n+                (\n+                    PatKind::TupleStruct(ref path_left, ref patterns_left, _),\n+                    PatKind::TupleStruct(ref path_right, ref patterns_right, _),\n+                ) if patterns_left.len() == 1 && patterns_right.len() == 1 => {\n+                    if let (PatKind::Wild, PatKind::Wild) = (&patterns_left[0].kind, &patterns_right[0].kind) {\n+                        find_good_method_for_match(\n+                            arms,\n+                            path_left,\n+                            path_right,\n+                            &paths::RESULT_OK,\n+                            &paths::RESULT_ERR,\n+                            \"is_ok()\",\n+                            \"is_err()\",\n+                            || can_suggest(cx, hir_id, sym!(result_type), \"is_ok\"),\n+                            || can_suggest(cx, hir_id, sym!(result_type), \"is_err\"),\n+                        )\n+                    } else {\n+                        None\n+                    }\n+                },\n+                (PatKind::TupleStruct(ref path_left, ref patterns, _), PatKind::Path(ref path_right))\n+                | (PatKind::Path(ref path_left), PatKind::TupleStruct(ref path_right, ref patterns, _))\n+                    if patterns.len() == 1 =>\n+                {\n+                    if let PatKind::Wild = patterns[0].kind {\n+                        find_good_method_for_match(\n+                            arms,\n+                            path_left,\n+                            path_right,\n+                            &paths::OPTION_SOME,\n+                            &paths::OPTION_NONE,\n+                            \"is_some()\",\n+                            \"is_none()\",\n+                            || can_suggest(cx, hir_id, sym!(option_type), \"is_some\"),\n+                            || can_suggest(cx, hir_id, sym!(option_type), \"is_none\"),\n+                        )\n+                    } else {\n+                        None\n+                    }\n+                },\n+                _ => None,\n+            };\n+\n+            if let Some(good_method) = found_good_method {\n+                span_lint_and_then(\n+                    cx,\n+                    REDUNDANT_PATTERN_MATCHING,\n+                    expr.span,\n+                    &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n+                    |diag| {\n+                        let span = expr.span.to(op.span);\n+                        diag.span_suggestion(\n+                            span,\n+                            \"try this\",\n+                            format!(\"{}.{}\", snippet(cx, op.span, \"_\"), good_method),\n+                            Applicability::MaybeIncorrect, // snippet\n+                        );\n+                    },\n+                );\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+\n+    #[allow(clippy::too_many_arguments)]\n+    fn find_good_method_for_match<'a>(\n+        arms: &[Arm<'_>],\n+        path_left: &QPath<'_>,\n+        path_right: &QPath<'_>,\n+        expected_left: &[&str],\n+        expected_right: &[&str],\n+        should_be_left: &'a str,\n+        should_be_right: &'a str,\n+        can_suggest_left: impl Fn() -> bool,\n+        can_suggest_right: impl Fn() -> bool,\n+    ) -> Option<&'a str> {\n+        let body_node_pair = if match_qpath(path_left, expected_left) && match_qpath(path_right, expected_right) {\n+            (&(*arms[0].body).kind, &(*arms[1].body).kind)\n+        } else if match_qpath(path_right, expected_left) && match_qpath(path_left, expected_right) {\n+            (&(*arms[1].body).kind, &(*arms[0].body).kind)\n+        } else {\n+            return None;\n+        };\n+\n+        match body_node_pair {\n+            (ExprKind::Lit(ref lit_left), ExprKind::Lit(ref lit_right)) => match (&lit_left.node, &lit_right.node) {\n+                (LitKind::Bool(true), LitKind::Bool(false)) if can_suggest_left() => Some(should_be_left),\n+                (LitKind::Bool(false), LitKind::Bool(true)) if can_suggest_right() => Some(should_be_right),\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    fn can_suggest(cx: &LateContext<'_>, hir_id: HirId, diag_item: Symbol, name: &str) -> bool {\n+        if !in_constant(cx, hir_id) {\n+            return true;\n+        }\n+\n+        // Avoid suggesting calls to non-`const fn`s in const contexts, see #5697.\n+        cx.tcx\n+            .get_diagnostic_item(diag_item)\n+            .and_then(|def_id| {\n+                cx.tcx.inherent_impls(def_id).iter().find_map(|imp| {\n+                    cx.tcx\n+                        .associated_items(*imp)\n+                        .in_definition_order()\n+                        .find_map(|item| match item.kind {\n+                            ty::AssocKind::Fn if item.ident.name.as_str() == name => Some(item.def_id),\n+                            _ => None,\n+                        })\n+                })\n+            })\n+            .map_or(false, |def_id| is_const_fn(cx.tcx, def_id))\n+    }\n+}\n+\n #[test]\n fn test_overlapping() {\n     use rustc_span::source_map::DUMMY_SP;"}, {"sha": "d8d16efb978a53727fe61bdd746c11d2c5a10708", "filename": "clippy_lints/src/redundant_pattern_matching.rs", "status": "removed", "additions": 0, "deletions": 260, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac856922f80e9ef8cd95c3004699e4bc8fa0c978/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs?ref=ac856922f80e9ef8cd95c3004699e4bc8fa0c978", "patch": "@@ -1,260 +0,0 @@\n-use crate::utils::{in_constant, match_qpath, match_trait_method, paths, snippet, span_lint_and_then};\n-use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n-use rustc_errors::Applicability;\n-use rustc_hir::{Arm, Expr, ExprKind, HirId, MatchSource, PatKind, QPath};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n-use rustc_mir::const_eval::is_const_fn;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Symbol;\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Lint for redundant pattern matching over `Result` or\n-    /// `Option`\n-    ///\n-    /// **Why is this bad?** It's more concise and clear to just use the proper\n-    /// utility function\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    ///\n-    /// ```rust\n-    /// if let Ok(_) = Ok::<i32, i32>(42) {}\n-    /// if let Err(_) = Err::<i32, i32>(42) {}\n-    /// if let None = None::<()> {}\n-    /// if let Some(_) = Some(42) {}\n-    /// match Ok::<i32, i32>(42) {\n-    ///     Ok(_) => true,\n-    ///     Err(_) => false,\n-    /// };\n-    /// ```\n-    ///\n-    /// The more idiomatic use would be:\n-    ///\n-    /// ```rust\n-    /// if Ok::<i32, i32>(42).is_ok() {}\n-    /// if Err::<i32, i32>(42).is_err() {}\n-    /// if None::<()>.is_none() {}\n-    /// if Some(42).is_some() {}\n-    /// Ok::<i32, i32>(42).is_ok();\n-    /// ```\n-    pub REDUNDANT_PATTERN_MATCHING,\n-    style,\n-    \"use the proper utility function avoiding an `if let`\"\n-}\n-\n-declare_lint_pass!(RedundantPatternMatching => [REDUNDANT_PATTERN_MATCHING]);\n-\n-impl<'tcx> LateLintPass<'tcx> for RedundantPatternMatching {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Match(op, arms, ref match_source) = &expr.kind {\n-            match match_source {\n-                MatchSource::Normal => find_sugg_for_match(cx, expr, op, arms),\n-                MatchSource::IfLetDesugar { .. } => find_sugg_for_if_let(cx, expr, op, arms, \"if\"),\n-                MatchSource::WhileLetDesugar => find_sugg_for_if_let(cx, expr, op, arms, \"while\"),\n-                _ => return,\n-            }\n-        }\n-    }\n-}\n-\n-fn find_sugg_for_if_let<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    expr: &'tcx Expr<'_>,\n-    op: &Expr<'_>,\n-    arms: &[Arm<'_>],\n-    keyword: &'static str,\n-) {\n-    fn find_suggestion(cx: &LateContext<'_>, hir_id: HirId, path: &QPath<'_>) -> Option<&'static str> {\n-        if match_qpath(path, &paths::RESULT_OK) && can_suggest(cx, hir_id, sym!(result_type), \"is_ok\") {\n-            return Some(\"is_ok()\");\n-        }\n-        if match_qpath(path, &paths::RESULT_ERR) && can_suggest(cx, hir_id, sym!(result_type), \"is_err\") {\n-            return Some(\"is_err()\");\n-        }\n-        if match_qpath(path, &paths::OPTION_SOME) && can_suggest(cx, hir_id, sym!(option_type), \"is_some\") {\n-            return Some(\"is_some()\");\n-        }\n-        if match_qpath(path, &paths::OPTION_NONE) && can_suggest(cx, hir_id, sym!(option_type), \"is_none\") {\n-            return Some(\"is_none()\");\n-        }\n-        None\n-    }\n-\n-    let hir_id = expr.hir_id;\n-    let good_method = match arms[0].pat.kind {\n-        PatKind::TupleStruct(ref path, ref patterns, _) if patterns.len() == 1 => {\n-            if let PatKind::Wild = patterns[0].kind {\n-                find_suggestion(cx, hir_id, path)\n-            } else {\n-                None\n-            }\n-        },\n-        PatKind::Path(ref path) => find_suggestion(cx, hir_id, path),\n-        _ => None,\n-    };\n-    let good_method = match good_method {\n-        Some(method) => method,\n-        None => return,\n-    };\n-\n-    // check that `while_let_on_iterator` lint does not trigger\n-    if_chain! {\n-        if keyword == \"while\";\n-        if let ExprKind::MethodCall(method_path, _, _, _) = op.kind;\n-        if method_path.ident.name == sym!(next);\n-        if match_trait_method(cx, op, &paths::ITERATOR);\n-        then {\n-            return;\n-        }\n-    }\n-\n-    span_lint_and_then(\n-        cx,\n-        REDUNDANT_PATTERN_MATCHING,\n-        arms[0].pat.span,\n-        &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n-        |diag| {\n-            // while let ... = ... { ... }\n-            // ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-            let expr_span = expr.span;\n-\n-            // while let ... = ... { ... }\n-            //                 ^^^\n-            let op_span = op.span.source_callsite();\n-\n-            // while let ... = ... { ... }\n-            // ^^^^^^^^^^^^^^^^^^^\n-            let span = expr_span.until(op_span.shrink_to_hi());\n-            diag.span_suggestion(\n-                span,\n-                \"try this\",\n-                format!(\"{} {}.{}\", keyword, snippet(cx, op_span, \"_\"), good_method),\n-                Applicability::MachineApplicable, // snippet\n-            );\n-        },\n-    );\n-}\n-\n-fn find_sugg_for_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op: &Expr<'_>, arms: &[Arm<'_>]) {\n-    if arms.len() == 2 {\n-        let node_pair = (&arms[0].pat.kind, &arms[1].pat.kind);\n-\n-        let hir_id = expr.hir_id;\n-        let found_good_method = match node_pair {\n-            (\n-                PatKind::TupleStruct(ref path_left, ref patterns_left, _),\n-                PatKind::TupleStruct(ref path_right, ref patterns_right, _),\n-            ) if patterns_left.len() == 1 && patterns_right.len() == 1 => {\n-                if let (PatKind::Wild, PatKind::Wild) = (&patterns_left[0].kind, &patterns_right[0].kind) {\n-                    find_good_method_for_match(\n-                        arms,\n-                        path_left,\n-                        path_right,\n-                        &paths::RESULT_OK,\n-                        &paths::RESULT_ERR,\n-                        \"is_ok()\",\n-                        \"is_err()\",\n-                        || can_suggest(cx, hir_id, sym!(result_type), \"is_ok\"),\n-                        || can_suggest(cx, hir_id, sym!(result_type), \"is_err\"),\n-                    )\n-                } else {\n-                    None\n-                }\n-            },\n-            (PatKind::TupleStruct(ref path_left, ref patterns, _), PatKind::Path(ref path_right))\n-            | (PatKind::Path(ref path_left), PatKind::TupleStruct(ref path_right, ref patterns, _))\n-                if patterns.len() == 1 =>\n-            {\n-                if let PatKind::Wild = patterns[0].kind {\n-                    find_good_method_for_match(\n-                        arms,\n-                        path_left,\n-                        path_right,\n-                        &paths::OPTION_SOME,\n-                        &paths::OPTION_NONE,\n-                        \"is_some()\",\n-                        \"is_none()\",\n-                        || can_suggest(cx, hir_id, sym!(option_type), \"is_some\"),\n-                        || can_suggest(cx, hir_id, sym!(option_type), \"is_none\"),\n-                    )\n-                } else {\n-                    None\n-                }\n-            },\n-            _ => None,\n-        };\n-\n-        if let Some(good_method) = found_good_method {\n-            span_lint_and_then(\n-                cx,\n-                REDUNDANT_PATTERN_MATCHING,\n-                expr.span,\n-                &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n-                |diag| {\n-                    let span = expr.span.to(op.span);\n-                    diag.span_suggestion(\n-                        span,\n-                        \"try this\",\n-                        format!(\"{}.{}\", snippet(cx, op.span, \"_\"), good_method),\n-                        Applicability::MaybeIncorrect, // snippet\n-                    );\n-                },\n-            );\n-        }\n-    }\n-}\n-\n-#[allow(clippy::too_many_arguments)]\n-fn find_good_method_for_match<'a>(\n-    arms: &[Arm<'_>],\n-    path_left: &QPath<'_>,\n-    path_right: &QPath<'_>,\n-    expected_left: &[&str],\n-    expected_right: &[&str],\n-    should_be_left: &'a str,\n-    should_be_right: &'a str,\n-    can_suggest_left: impl Fn() -> bool,\n-    can_suggest_right: impl Fn() -> bool,\n-) -> Option<&'a str> {\n-    let body_node_pair = if match_qpath(path_left, expected_left) && match_qpath(path_right, expected_right) {\n-        (&(*arms[0].body).kind, &(*arms[1].body).kind)\n-    } else if match_qpath(path_right, expected_left) && match_qpath(path_left, expected_right) {\n-        (&(*arms[1].body).kind, &(*arms[0].body).kind)\n-    } else {\n-        return None;\n-    };\n-\n-    match body_node_pair {\n-        (ExprKind::Lit(ref lit_left), ExprKind::Lit(ref lit_right)) => match (&lit_left.node, &lit_right.node) {\n-            (LitKind::Bool(true), LitKind::Bool(false)) if can_suggest_left() => Some(should_be_left),\n-            (LitKind::Bool(false), LitKind::Bool(true)) if can_suggest_right() => Some(should_be_right),\n-            _ => None,\n-        },\n-        _ => None,\n-    }\n-}\n-\n-fn can_suggest(cx: &LateContext<'_>, hir_id: HirId, diag_item: Symbol, name: &str) -> bool {\n-    if !in_constant(cx, hir_id) {\n-        return true;\n-    }\n-\n-    // Avoid suggesting calls to non-`const fn`s in const contexts, see #5697.\n-    cx.tcx\n-        .get_diagnostic_item(diag_item)\n-        .and_then(|def_id| {\n-            cx.tcx.inherent_impls(def_id).iter().find_map(|imp| {\n-                cx.tcx\n-                    .associated_items(*imp)\n-                    .in_definition_order()\n-                    .find_map(|item| match item.kind {\n-                        ty::AssocKind::Fn if item.ident.name.as_str() == name => Some(item.def_id),\n-                        _ => None,\n-                    })\n-            })\n-        })\n-        .map_or(false, |def_id| is_const_fn(cx.tcx, def_id))\n-}"}, {"sha": "888b475548461b17cb447927f716349506ebf665", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d", "patch": "@@ -1179,6 +1179,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"matches\",\n     },\n+    Lint {\n+        name: \"match_like_matches_macro\",\n+        group: \"style\",\n+        desc: \"a match that could be written with the matches! macro\",\n+        deprecation: None,\n+        module: \"matches\",\n+    },\n     Lint {\n         name: \"match_on_vec_items\",\n         group: \"pedantic\",\n@@ -1856,7 +1863,7 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         group: \"style\",\n         desc: \"use the proper utility function avoiding an `if let`\",\n         deprecation: None,\n-        module: \"redundant_pattern_matching\",\n+        module: \"matches\",\n     },\n     Lint {\n         name: \"redundant_pub_crate\","}, {"sha": "88d3b0e74900152d33938bf332da60dd9035f31c", "filename": "tests/ui/find_map.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Ffind_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Ffind_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffind_map.rs?ref=2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d", "patch": "@@ -19,6 +19,7 @@ fn main() {\n \n     let _: Option<i32> = a.iter().find(|s| s.parse::<i32>().is_ok()).map(|s| s.parse().unwrap());\n \n+    #[allow(clippy::match_like_matches_macro)]\n     let _: Option<Flavor> = desserts_of_the_week\n         .iter()\n         .find(|dessert| match *dessert {"}, {"sha": "f279850fef8af91a0c520197efb7571f4e22b5e6", "filename": "tests/ui/find_map.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Ffind_map.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Ffind_map.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffind_map.stderr?ref=2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d", "patch": "@@ -8,7 +8,7 @@ LL |     let _: Option<i32> = a.iter().find(|s| s.parse::<i32>().is_ok()).map(|s\n    = help: this is more succinctly expressed by calling `.find_map(..)` instead\n \n error: called `find(p).map(q)` on an `Iterator`\n-  --> $DIR/find_map.rs:22:29\n+  --> $DIR/find_map.rs:23:29\n    |\n LL |       let _: Option<Flavor> = desserts_of_the_week\n    |  _____________________________^"}, {"sha": "2d1ac8836d63f52d78cb35e76bd6b53d9f300b27", "filename": "tests/ui/match_expr_like_matches_macro.fixed", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Fmatch_expr_like_matches_macro.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Fmatch_expr_like_matches_macro.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_expr_like_matches_macro.fixed?ref=2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d", "patch": "@@ -0,0 +1,32 @@\n+// run-rustfix\n+\n+#![warn(clippy::match_like_matches_macro)]\n+\n+fn main() {\n+    let x = Some(5);\n+\n+    // Lint\n+    let _y = matches!(x, Some(0));\n+\n+    // Turn into is_none\n+    let _z = x.is_none();\n+\n+    // Lint\n+    let _z = !matches!(x, Some(r) if r == 0);\n+\n+    // Lint\n+    let _zz = matches!(x, Some(5));\n+\n+    // No lint\n+    let _a = match x {\n+        Some(_) => false,\n+        None => false,\n+    };\n+\n+    // No lint\n+    let _a = match x {\n+        Some(0) => false,\n+        Some(_) => true,\n+        None => false,\n+    };\n+}"}, {"sha": "376abf9244eafd7d64f920ffc15f914a600f5175", "filename": "tests/ui/match_expr_like_matches_macro.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Fmatch_expr_like_matches_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Fmatch_expr_like_matches_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_expr_like_matches_macro.rs?ref=2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d", "patch": "@@ -0,0 +1,41 @@\n+// run-rustfix\n+\n+#![warn(clippy::match_like_matches_macro)]\n+\n+fn main() {\n+    let x = Some(5);\n+\n+    // Lint\n+    let _y = match x {\n+        Some(0) => true,\n+        _ => false,\n+    };\n+\n+    // Turn into is_none\n+    let _z = match x {\n+        Some(_) => false,\n+        None => true,\n+    };\n+\n+    // Lint\n+    let _z = match x {\n+        Some(r) if r == 0 => false,\n+        _ => true,\n+    };\n+\n+    // Lint\n+    let _zz = if let Some(5) = x { true } else { false };\n+\n+    // No lint\n+    let _a = match x {\n+        Some(_) => false,\n+        None => false,\n+    };\n+\n+    // No lint\n+    let _a = match x {\n+        Some(0) => false,\n+        Some(_) => true,\n+        None => false,\n+    };\n+}"}, {"sha": "0b32af039a8cc17d9a6e479e67514eb4c091de26", "filename": "tests/ui/match_expr_like_matches_macro.stderr", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Fmatch_expr_like_matches_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Fmatch_expr_like_matches_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_expr_like_matches_macro.stderr?ref=2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d", "patch": "@@ -0,0 +1,42 @@\n+error: match expression looks like `matches!` macro\n+  --> $DIR/match_expr_like_matches_macro.rs:9:14\n+   |\n+LL |       let _y = match x {\n+   |  ______________^\n+LL | |         Some(0) => true,\n+LL | |         _ => false,\n+LL | |     };\n+   | |_____^ help: try this: `matches!(x, Some(0))`\n+   |\n+   = note: `-D clippy::match-like-matches-macro` implied by `-D warnings`\n+\n+error: redundant pattern matching, consider using `is_none()`\n+  --> $DIR/match_expr_like_matches_macro.rs:15:14\n+   |\n+LL |       let _z = match x {\n+   |  ______________^\n+LL | |         Some(_) => false,\n+LL | |         None => true,\n+LL | |     };\n+   | |_____^ help: try this: `x.is_none()`\n+   |\n+   = note: `-D clippy::redundant-pattern-matching` implied by `-D warnings`\n+\n+error: match expression looks like `matches!` macro\n+  --> $DIR/match_expr_like_matches_macro.rs:21:14\n+   |\n+LL |       let _z = match x {\n+   |  ______________^\n+LL | |         Some(r) if r == 0 => false,\n+LL | |         _ => true,\n+LL | |     };\n+   | |_____^ help: try this: `!matches!(x, Some(r) if r == 0)`\n+\n+error: if let .. else expression looks like `matches!` macro\n+  --> $DIR/match_expr_like_matches_macro.rs:27:15\n+   |\n+LL |     let _zz = if let Some(5) = x { true } else { false };\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `matches!(x, Some(5))`\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "0cee0a28fc7cd23b6e6b508e6d99f7881c230ee0", "filename": "tests/ui/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneg_cmp_op_on_partial_ord.rs?ref=2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d", "patch": "@@ -4,7 +4,7 @@\n \n use std::cmp::Ordering;\n \n-#[allow(clippy::unnested_or_patterns)]\n+#[allow(clippy::unnested_or_patterns, clippy::match_like_matches_macro)]\n #[warn(clippy::neg_cmp_op_on_partial_ord)]\n fn main() {\n     let a_value = 1.0;"}, {"sha": "bd13cf1bdfaf60378b72c9a0365aff95347ac262", "filename": "tests/ui/question_mark.fixed", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Fquestion_mark.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Fquestion_mark.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fquestion_mark.fixed?ref=2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d", "patch": "@@ -23,10 +23,7 @@ pub enum SeemsOption<T> {\n \n impl<T> SeemsOption<T> {\n     pub fn is_none(&self) -> bool {\n-        match *self {\n-            SeemsOption::None => true,\n-            SeemsOption::Some(_) => false,\n-        }\n+        matches!(*self, SeemsOption::None)\n     }\n }\n "}, {"sha": "94479e685551ce7d3f0a30f13ed7a817d17f2b64", "filename": "tests/ui/question_mark.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fquestion_mark.rs?ref=2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d", "patch": "@@ -25,10 +25,7 @@ pub enum SeemsOption<T> {\n \n impl<T> SeemsOption<T> {\n     pub fn is_none(&self) -> bool {\n-        match *self {\n-            SeemsOption::None => true,\n-            SeemsOption::Some(_) => false,\n-        }\n+        matches!(*self, SeemsOption::None)\n     }\n }\n "}, {"sha": "be323035d6ccd43ba1047b86cc9eeb76816eb63d", "filename": "tests/ui/question_mark.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Fquestion_mark.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Fquestion_mark.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fquestion_mark.stderr?ref=2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d", "patch": "@@ -9,23 +9,23 @@ LL | |     }\n    = note: `-D clippy::question-mark` implied by `-D warnings`\n \n error: this block may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:50:9\n+  --> $DIR/question_mark.rs:47:9\n    |\n LL | /         if (self.opt).is_none() {\n LL | |             return None;\n LL | |         }\n    | |_________^ help: replace it with: `(self.opt)?;`\n \n error: this block may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:54:9\n+  --> $DIR/question_mark.rs:51:9\n    |\n LL | /         if self.opt.is_none() {\n LL | |             return None\n LL | |         }\n    | |_________^ help: replace it with: `self.opt?;`\n \n error: this block may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:58:17\n+  --> $DIR/question_mark.rs:55:17\n    |\n LL |           let _ = if self.opt.is_none() {\n    |  _________________^\n@@ -36,7 +36,7 @@ LL | |         };\n    | |_________^ help: replace it with: `Some(self.opt?)`\n \n error: this if-let-else may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:64:17\n+  --> $DIR/question_mark.rs:61:17\n    |\n LL |           let _ = if let Some(x) = self.opt {\n    |  _________________^\n@@ -47,31 +47,31 @@ LL | |         };\n    | |_________^ help: replace it with: `self.opt?`\n \n error: this block may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:81:9\n+  --> $DIR/question_mark.rs:78:9\n    |\n LL | /         if self.opt.is_none() {\n LL | |             return None;\n LL | |         }\n    | |_________^ help: replace it with: `self.opt.as_ref()?;`\n \n error: this block may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:89:9\n+  --> $DIR/question_mark.rs:86:9\n    |\n LL | /         if self.opt.is_none() {\n LL | |             return None;\n LL | |         }\n    | |_________^ help: replace it with: `self.opt.as_ref()?;`\n \n error: this block may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:97:9\n+  --> $DIR/question_mark.rs:94:9\n    |\n LL | /         if self.opt.is_none() {\n LL | |             return None;\n LL | |         }\n    | |_________^ help: replace it with: `self.opt.as_ref()?;`\n \n error: this if-let-else may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:104:26\n+  --> $DIR/question_mark.rs:101:26\n    |\n LL |           let v: &Vec<_> = if let Some(ref v) = self.opt {\n    |  __________________________^\n@@ -82,7 +82,7 @@ LL | |         };\n    | |_________^ help: replace it with: `self.opt.as_ref()?`\n \n error: this if-let-else may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:114:17\n+  --> $DIR/question_mark.rs:111:17\n    |\n LL |           let v = if let Some(v) = self.opt {\n    |  _________________^\n@@ -93,7 +93,7 @@ LL | |         };\n    | |_________^ help: replace it with: `self.opt?`\n \n error: this block may be rewritten with the `?` operator\n-  --> $DIR/question_mark.rs:129:5\n+  --> $DIR/question_mark.rs:126:5\n    |\n LL | /     if f().is_none() {\n LL | |         return None;"}, {"sha": "ce8582d2b221cd21c891bfd38af0d20bfd073ec4", "filename": "tests/ui/redundant_pattern_matching.fixed", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Fredundant_pattern_matching.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Fredundant_pattern_matching.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching.fixed?ref=2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d", "patch": "@@ -2,7 +2,13 @@\n \n #![warn(clippy::all)]\n #![warn(clippy::redundant_pattern_matching)]\n-#![allow(clippy::unit_arg, unused_must_use, clippy::needless_bool, deprecated)]\n+#![allow(\n+    clippy::unit_arg,\n+    unused_must_use,\n+    clippy::needless_bool,\n+    clippy::match_like_matches_macro,\n+    deprecated\n+)]\n \n fn main() {\n     if Ok::<i32, i32>(42).is_ok() {}"}, {"sha": "a3a9aa40e3b9c8ec7fd2b7a708c34bf5d93377ab", "filename": "tests/ui/redundant_pattern_matching.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Fredundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Fredundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching.rs?ref=2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d", "patch": "@@ -2,7 +2,13 @@\n \n #![warn(clippy::all)]\n #![warn(clippy::redundant_pattern_matching)]\n-#![allow(clippy::unit_arg, unused_must_use, clippy::needless_bool, deprecated)]\n+#![allow(\n+    clippy::unit_arg,\n+    unused_must_use,\n+    clippy::needless_bool,\n+    clippy::match_like_matches_macro,\n+    deprecated\n+)]\n \n fn main() {\n     if let Ok(_) = Ok::<i32, i32>(42) {}"}, {"sha": "25d1476062e7f599e7fe37dfddab9c1ce80bc1c0", "filename": "tests/ui/redundant_pattern_matching.stderr", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Fredundant_pattern_matching.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Fredundant_pattern_matching.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching.stderr?ref=2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d", "patch": "@@ -1,73 +1,73 @@\n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:8:12\n+  --> $DIR/redundant_pattern_matching.rs:14:12\n    |\n LL |     if let Ok(_) = Ok::<i32, i32>(42) {}\n    |     -------^^^^^--------------------- help: try this: `if Ok::<i32, i32>(42).is_ok()`\n    |\n    = note: `-D clippy::redundant-pattern-matching` implied by `-D warnings`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching.rs:10:12\n+  --> $DIR/redundant_pattern_matching.rs:16:12\n    |\n LL |     if let Err(_) = Err::<i32, i32>(42) {}\n    |     -------^^^^^^---------------------- help: try this: `if Err::<i32, i32>(42).is_err()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching.rs:12:12\n+  --> $DIR/redundant_pattern_matching.rs:18:12\n    |\n LL |     if let None = None::<()> {}\n    |     -------^^^^------------- help: try this: `if None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:14:12\n+  --> $DIR/redundant_pattern_matching.rs:20:12\n    |\n LL |     if let Some(_) = Some(42) {}\n    |     -------^^^^^^^----------- help: try this: `if Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:16:12\n+  --> $DIR/redundant_pattern_matching.rs:22:12\n    |\n LL |     if let Some(_) = Some(42) {\n    |     -------^^^^^^^----------- help: try this: `if Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:22:15\n+  --> $DIR/redundant_pattern_matching.rs:28:15\n    |\n LL |     while let Some(_) = Some(42) {}\n    |     ----------^^^^^^^----------- help: try this: `while Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching.rs:24:15\n+  --> $DIR/redundant_pattern_matching.rs:30:15\n    |\n LL |     while let None = Some(42) {}\n    |     ----------^^^^----------- help: try this: `while Some(42).is_none()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching.rs:26:15\n+  --> $DIR/redundant_pattern_matching.rs:32:15\n    |\n LL |     while let None = None::<()> {}\n    |     ----------^^^^------------- help: try this: `while None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:28:15\n+  --> $DIR/redundant_pattern_matching.rs:34:15\n    |\n LL |     while let Ok(_) = Ok::<i32, i32>(10) {}\n    |     ----------^^^^^--------------------- help: try this: `while Ok::<i32, i32>(10).is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching.rs:30:15\n+  --> $DIR/redundant_pattern_matching.rs:36:15\n    |\n LL |     while let Err(_) = Ok::<i32, i32>(10) {}\n    |     ----------^^^^^^--------------------- help: try this: `while Ok::<i32, i32>(10).is_err()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:33:15\n+  --> $DIR/redundant_pattern_matching.rs:39:15\n    |\n LL |     while let Some(_) = v.pop() {\n    |     ----------^^^^^^^---------- help: try this: `while v.pop().is_some()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:49:5\n+  --> $DIR/redundant_pattern_matching.rs:55:5\n    |\n LL | /     match Ok::<i32, i32>(42) {\n LL | |         Ok(_) => true,\n@@ -76,7 +76,7 @@ LL | |     };\n    | |_____^ help: try this: `Ok::<i32, i32>(42).is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching.rs:54:5\n+  --> $DIR/redundant_pattern_matching.rs:60:5\n    |\n LL | /     match Ok::<i32, i32>(42) {\n LL | |         Ok(_) => false,\n@@ -85,7 +85,7 @@ LL | |     };\n    | |_____^ help: try this: `Ok::<i32, i32>(42).is_err()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching.rs:59:5\n+  --> $DIR/redundant_pattern_matching.rs:65:5\n    |\n LL | /     match Err::<i32, i32>(42) {\n LL | |         Ok(_) => false,\n@@ -94,7 +94,7 @@ LL | |     };\n    | |_____^ help: try this: `Err::<i32, i32>(42).is_err()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:64:5\n+  --> $DIR/redundant_pattern_matching.rs:70:5\n    |\n LL | /     match Err::<i32, i32>(42) {\n LL | |         Ok(_) => true,\n@@ -103,7 +103,7 @@ LL | |     };\n    | |_____^ help: try this: `Err::<i32, i32>(42).is_ok()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:69:5\n+  --> $DIR/redundant_pattern_matching.rs:75:5\n    |\n LL | /     match Some(42) {\n LL | |         Some(_) => true,\n@@ -112,7 +112,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching.rs:74:5\n+  --> $DIR/redundant_pattern_matching.rs:80:5\n    |\n LL | /     match None::<()> {\n LL | |         Some(_) => false,\n@@ -121,7 +121,7 @@ LL | |     };\n    | |_____^ help: try this: `None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching.rs:79:13\n+  --> $DIR/redundant_pattern_matching.rs:85:13\n    |\n LL |       let _ = match None::<()> {\n    |  _____________^\n@@ -131,61 +131,61 @@ LL | |     };\n    | |_____^ help: try this: `None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:84:20\n+  --> $DIR/redundant_pattern_matching.rs:90:20\n    |\n LL |     let _ = if let Ok(_) = Ok::<usize, ()>(4) { true } else { false };\n    |             -------^^^^^--------------------- help: try this: `if Ok::<usize, ()>(4).is_ok()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:87:20\n+  --> $DIR/redundant_pattern_matching.rs:93:20\n    |\n LL |     let x = if let Some(_) = opt { true } else { false };\n    |             -------^^^^^^^------ help: try this: `if opt.is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:93:20\n+  --> $DIR/redundant_pattern_matching.rs:99:20\n    |\n LL |     let _ = if let Some(_) = gen_opt() {\n    |             -------^^^^^^^------------ help: try this: `if gen_opt().is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching.rs:95:19\n+  --> $DIR/redundant_pattern_matching.rs:101:19\n    |\n LL |     } else if let None = gen_opt() {\n    |            -------^^^^------------ help: try this: `if gen_opt().is_none()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:97:19\n+  --> $DIR/redundant_pattern_matching.rs:103:19\n    |\n LL |     } else if let Ok(_) = gen_res() {\n    |            -------^^^^^------------ help: try this: `if gen_res().is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching.rs:99:19\n+  --> $DIR/redundant_pattern_matching.rs:105:19\n    |\n LL |     } else if let Err(_) = gen_res() {\n    |            -------^^^^^^------------ help: try this: `if gen_res().is_err()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:132:19\n+  --> $DIR/redundant_pattern_matching.rs:138:19\n    |\n LL |         while let Some(_) = r#try!(result_opt()) {}\n    |         ----------^^^^^^^----------------------- help: try this: `while r#try!(result_opt()).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:133:16\n+  --> $DIR/redundant_pattern_matching.rs:139:16\n    |\n LL |         if let Some(_) = r#try!(result_opt()) {}\n    |         -------^^^^^^^----------------------- help: try this: `if r#try!(result_opt()).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:139:12\n+  --> $DIR/redundant_pattern_matching.rs:145:12\n    |\n LL |     if let Some(_) = m!() {}\n    |     -------^^^^^^^------- help: try this: `if m!().is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:140:15\n+  --> $DIR/redundant_pattern_matching.rs:146:15\n    |\n LL |     while let Some(_) = m!() {}\n    |     ----------^^^^^^^------- help: try this: `while m!().is_some()`"}, {"sha": "de3fe00d5fa689b81591706e9acd4693f1073053", "filename": "tests/ui/redundant_pattern_matching_const_result.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Fredundant_pattern_matching_const_result.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Fredundant_pattern_matching_const_result.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_const_result.fixed?ref=2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d", "patch": "@@ -2,7 +2,7 @@\n \n #![feature(const_result)]\n #![warn(clippy::redundant_pattern_matching)]\n-#![allow(unused)]\n+#![allow(clippy::match_like_matches_macro, unused)]\n \n // Test that results are linted with the feature enabled.\n "}, {"sha": "b77969d53d92df3def12d657c545d7c62e5ee39d", "filename": "tests/ui/redundant_pattern_matching_const_result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Fredundant_pattern_matching_const_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d/tests%2Fui%2Fredundant_pattern_matching_const_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_const_result.rs?ref=2e8a1be444afc6a9b5137d3e7e4fdcfcb1f89e0d", "patch": "@@ -2,7 +2,7 @@\n \n #![feature(const_result)]\n #![warn(clippy::redundant_pattern_matching)]\n-#![allow(unused)]\n+#![allow(clippy::match_like_matches_macro, unused)]\n \n // Test that results are linted with the feature enabled.\n "}]}