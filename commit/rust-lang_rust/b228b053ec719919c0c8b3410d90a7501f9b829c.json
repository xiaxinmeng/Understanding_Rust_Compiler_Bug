{"sha": "b228b053ec719919c0c8b3410d90a7501f9b829c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyMjhiMDUzZWM3MTk5MTljMGM4YjM0MTBkOTBhNzUwMWY5YjgyOWM=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-03-09T01:25:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-03-09T01:25:55Z"}, "message": "Rollup merge of #48527 - zackmdavis:and_the_social_construction_of_tuples, r=estebank\n\nin which parentheses are suggested for should-have-been-tuple-patterns\n\n![destructure_suggest_parens](https://user-images.githubusercontent.com/1076988/36638335-48b082d4-19a7-11e8-9726-0d043544df2f.png)\n\nProgrammers used to working in some other languages (such as Python or\nGo) might expect to be able to destructure values with comma-separated\nidentifiers but no parentheses on the left side of an assignment.\n\nPreviously, the first name in such code would get parsed as a\nsingle-indentifier pattern\u2014recognizing, for example, the\n`let a` in `let a, b = (1, 2);`\u2014whereupon we would have a fatal syntax\nerror on seeing an unexpected comma rather than the expected semicolon\n(all the way nearer to the end of `parse_full_stmt`).\n\nInstead, let's look for that comma when parsing the pattern, and if we\nsee it, make-believe that we're parsing the remaining elements in a\ntuple pattern, so that we can suggest wrapping it all in parentheses. We\nneed to do this in a separate wrapper method called on a \"top-level\"\npattern, rather than within\n`parse_pat` itself, because `parse_pat` gets called recursively to parse\nthe sub-patterns within a tuple pattern.\n\n~~We could also do this for `match` arms, `if let`, and `while let`, but\nwe elect not to in this patch, as it seems less likely for users to make\nthe mistake in those contexts.~~\n\nResolves #48492.\n\nr? @petrochenkov", "tree": {"sha": "8ba08ffdb488d2f67ac74241becca9f37c07d8b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ba08ffdb488d2f67ac74241becca9f37c07d8b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b228b053ec719919c0c8b3410d90a7501f9b829c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJaoeKjCRBK7hj4Ov3rIwAAdHIIALK1sO9eSOZ6Q5pACA7XQWe4\npnC8LqPoZ5C6KvUI6gCnm+m2QA7/gUmJI/CLg/pKr8GNgnuI7UhUgcaYGS3AghOY\n+qXbOQgix22h87FJVPSlYTcNKLPZ+1QI6+QxGyEzyFrTJzpFnzV0PzuDR8TNqVjK\n/fViZHRY7DtA07nge9hUck7W4kTmWVA89k8nLgsbfweelvpIl8fZNCkXjlATQddC\npcMl+hLWKa+/Vp3FpEKOh4UJug4/YBk3yZ1yB/UgsIoh1OplKCLFpU7pC94ZuiHZ\nJ7ROBB+R5B404g16bzujt3+TkkeHYQLdP/rk9VPScPIhVfiFZ4LwJDlNg+MCpQo=\n=tl+N\n-----END PGP SIGNATURE-----\n", "payload": "tree 8ba08ffdb488d2f67ac74241becca9f37c07d8b6\nparent 604d4ce7577b07b73d115c94fbd8007c1d9c9335\nparent 1f04597c3ca3af45236ecb496bd30db5c57daae9\nauthor Manish Goregaokar <manishsmail@gmail.com> 1520558755 -0800\ncommitter GitHub <noreply@github.com> 1520558755 -0800\n\nRollup merge of #48527 - zackmdavis:and_the_social_construction_of_tuples, r=estebank\n\nin which parentheses are suggested for should-have-been-tuple-patterns\n\n![destructure_suggest_parens](https://user-images.githubusercontent.com/1076988/36638335-48b082d4-19a7-11e8-9726-0d043544df2f.png)\n\nProgrammers used to working in some other languages (such as Python or\nGo) might expect to be able to destructure values with comma-separated\nidentifiers but no parentheses on the left side of an assignment.\n\nPreviously, the first name in such code would get parsed as a\nsingle-indentifier pattern\u2014recognizing, for example, the\n`let a` in `let a, b = (1, 2);`\u2014whereupon we would have a fatal syntax\nerror on seeing an unexpected comma rather than the expected semicolon\n(all the way nearer to the end of `parse_full_stmt`).\n\nInstead, let's look for that comma when parsing the pattern, and if we\nsee it, make-believe that we're parsing the remaining elements in a\ntuple pattern, so that we can suggest wrapping it all in parentheses. We\nneed to do this in a separate wrapper method called on a \"top-level\"\npattern, rather than within\n`parse_pat` itself, because `parse_pat` gets called recursively to parse\nthe sub-patterns within a tuple pattern.\n\n~~We could also do this for `match` arms, `if let`, and `while let`, but\nwe elect not to in this patch, as it seems less likely for users to make\nthe mistake in those contexts.~~\n\nResolves #48492.\n\nr? @petrochenkov\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b228b053ec719919c0c8b3410d90a7501f9b829c", "html_url": "https://github.com/rust-lang/rust/commit/b228b053ec719919c0c8b3410d90a7501f9b829c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b228b053ec719919c0c8b3410d90a7501f9b829c/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "604d4ce7577b07b73d115c94fbd8007c1d9c9335", "url": "https://api.github.com/repos/rust-lang/rust/commits/604d4ce7577b07b73d115c94fbd8007c1d9c9335", "html_url": "https://github.com/rust-lang/rust/commit/604d4ce7577b07b73d115c94fbd8007c1d9c9335"}, {"sha": "1f04597c3ca3af45236ecb496bd30db5c57daae9", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f04597c3ca3af45236ecb496bd30db5c57daae9", "html_url": "https://github.com/rust-lang/rust/commit/1f04597c3ca3af45236ecb496bd30db5c57daae9"}], "stats": {"total": 179, "additions": 174, "deletions": 5}, "files": [{"sha": "847733e1e37b60ca5116595912d7d492b98189b9", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 39, "deletions": 5, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b228b053ec719919c0c8b3410d90a7501f9b829c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b228b053ec719919c0c8b3410d90a7501f9b829c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b228b053ec719919c0c8b3410d90a7501f9b829c", "patch": "@@ -3318,7 +3318,7 @@ impl<'a> Parser<'a> {\n                           mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n \n-        let pat = self.parse_pat()?;\n+        let pat = self.parse_top_level_pat()?;\n         if !self.eat_keyword(keywords::In) {\n             let in_span = self.prev_span.between(self.span);\n             let mut err = self.sess.span_diagnostic\n@@ -3528,7 +3528,7 @@ impl<'a> Parser<'a> {\n     fn parse_pats(&mut self) -> PResult<'a, Vec<P<Pat>>> {\n         let mut pats = Vec::new();\n         loop {\n-            pats.push(self.parse_pat()?);\n+            pats.push(self.parse_top_level_pat()?);\n \n             if self.token == token::OrOr {\n                 let mut err = self.struct_span_err(self.span,\n@@ -3554,7 +3554,12 @@ impl<'a> Parser<'a> {\n     // Trailing commas are significant because (p) and (p,) are different patterns.\n     fn parse_parenthesized_pat_list(&mut self) -> PResult<'a, (Vec<P<Pat>>, Option<usize>, bool)> {\n         self.expect(&token::OpenDelim(token::Paren))?;\n+        let result = self.parse_pat_list()?;\n+        self.expect(&token::CloseDelim(token::Paren))?;\n+        Ok(result)\n+    }\n \n+    fn parse_pat_list(&mut self) -> PResult<'a, (Vec<P<Pat>>, Option<usize>, bool)> {\n         let mut fields = Vec::new();\n         let mut ddpos = None;\n         let mut trailing_comma = false;\n@@ -3584,8 +3589,6 @@ impl<'a> Parser<'a> {\n             self.span_err(self.prev_span, \"trailing comma is not permitted after `..`\");\n         }\n \n-        self.expect(&token::CloseDelim(token::Paren))?;\n-\n         Ok((fields, ddpos, trailing_comma))\n     }\n \n@@ -3767,6 +3770,37 @@ impl<'a> Parser<'a> {\n         }))\n     }\n \n+    /// A wrapper around `parse_pat` with some special error handling for the\n+    /// \"top-level\" patterns in a match arm, `for` loop, `let`, &c. (in contast\n+    /// to subpatterns within such).\n+    pub fn parse_top_level_pat(&mut self) -> PResult<'a, P<Pat>> {\n+        let pat = self.parse_pat()?;\n+        if self.token == token::Comma {\n+            // An unexpected comma after a top-level pattern is a clue that the\n+            // user (perhaps more accustomed to some other language) forgot the\n+            // parentheses in what should have been a tuple pattern; return a\n+            // suggestion-enhanced error here rather than choking on the comma\n+            // later.\n+            let comma_span = self.span;\n+            self.bump();\n+            if let Err(mut err) = self.parse_pat_list() {\n+                // We didn't expect this to work anyway; we just wanted\n+                // to advance to the end of the comma-sequence so we know\n+                // the span to suggest parenthesizing\n+                err.cancel();\n+            }\n+            let seq_span = pat.span.to(self.prev_span);\n+            let mut err = self.struct_span_err(comma_span,\n+                                               \"unexpected `,` in pattern\");\n+            if let Ok(seq_snippet) = self.sess.codemap().span_to_snippet(seq_span) {\n+                err.span_suggestion(seq_span, \"try adding parentheses\",\n+                                    format!(\"({})\", seq_snippet));\n+            }\n+            return Err(err);\n+        }\n+        Ok(pat)\n+    }\n+\n     /// Parse a pattern.\n     pub fn parse_pat(&mut self) -> PResult<'a, P<Pat>> {\n         maybe_whole!(self, NtPat, |x| x);\n@@ -3969,7 +4003,7 @@ impl<'a> Parser<'a> {\n     /// Parse a local variable declaration\n     fn parse_local(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Local>> {\n         let lo = self.prev_span;\n-        let pat = self.parse_pat()?;\n+        let pat = self.parse_top_level_pat()?;\n \n         let (err, ty) = if self.eat(&token::Colon) {\n             // Save the state of the parser before parsing type normally, in case there is a `:`"}, {"sha": "7bdaaddad843286affad2c31390b0b2b40ed15c8", "filename": "src/test/ui/did_you_mean/issue-48492-tuple-destructure-missing-parens.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/b228b053ec719919c0c8b3410d90a7501f9b829c/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-48492-tuple-destructure-missing-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b228b053ec719919c0c8b3410d90a7501f9b829c/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-48492-tuple-destructure-missing-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-48492-tuple-destructure-missing-parens.rs?ref=b228b053ec719919c0c8b3410d90a7501f9b829c", "patch": "@@ -0,0 +1,97 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused)]\n+\n+#[derive(Copy, Clone)]\n+enum Nucleotide {\n+    Adenine,\n+    Thymine,\n+    Cytosine,\n+    Guanine\n+}\n+\n+#[derive(Clone)]\n+struct Autosome;\n+\n+#[derive(Clone)]\n+enum Allosome {\n+    X(Vec<Nucleotide>),\n+    Y(Vec<Nucleotide>)\n+}\n+\n+impl Allosome {\n+    fn is_x(&self) -> bool {\n+        match *self {\n+            Allosome::X(_) => true,\n+            Allosome::Y(_) => false,\n+        }\n+    }\n+}\n+\n+#[derive(Clone)]\n+struct Genome {\n+    autosomes: [Autosome; 22],\n+    allosomes: (Allosome, Allosome)\n+}\n+\n+fn find_start_codon(strand: &[Nucleotide]) -> Option<usize> {\n+    let mut reading_frame = strand.windows(3);\n+    // (missing parentheses in `while let` tuple pattern)\n+    while let b1, b2, b3 = reading_frame.next().expect(\"there should be a start codon\") {\n+        //~^ ERROR unexpected `,` in pattern\n+        // ...\n+    }\n+    None\n+}\n+\n+fn find_thr(strand: &[Nucleotide]) -> Option<usize> {\n+    let mut reading_frame = strand.windows(3);\n+    let mut i = 0;\n+    // (missing parentheses in `if let` tuple pattern)\n+    if let b1, b2, b3 = reading_frame.next().unwrap() {\n+        //~^ ERROR unexpected `,` in pattern\n+        // ...\n+    }\n+    None\n+}\n+\n+fn is_thr(codon: (Nucleotide, Nucleotide, Nucleotide)) -> bool {\n+    match codon {\n+        // (missing parentheses in match arm tuple pattern)\n+        Nucleotide::Adenine, Nucleotide::Cytosine, _ => true\n+        //~^ ERROR unexpected `,` in pattern\n+        _ => false\n+    }\n+}\n+\n+fn analyze_female_sex_chromosomes(women: &[Genome]) {\n+    // (missing parentheses in `for` tuple pattern)\n+    for x, _barr_body in women.iter().map(|woman| woman.allosomes.clone()) {\n+        //~^ ERROR unexpected `,` in pattern\n+        // ...\n+    }\n+}\n+\n+fn analyze_male_sex_chromosomes(men: &[Genome]) {\n+    // (missing parentheses in pattern with `@` binding)\n+    for x, y @ Allosome::Y(_) in men.iter().map(|man| man.allosomes.clone()) {\n+        //~^ ERROR unexpected `,` in pattern\n+        // ...\n+    }\n+}\n+\n+fn main() {\n+    let genomes = Vec::new();\n+    // (missing parentheses in `let` pattern)\n+    let women, men: (Vec<Genome>, Vec<Genome>) = genomes.iter().cloned()\n+    //~^ ERROR unexpected `,` in pattern\n+        .partition(|g: &Genome| g.allosomes.0.is_x() && g.allosomes.1.is_x());\n+}"}, {"sha": "db3f93af444487acfe38685a9cd310e40baa520b", "filename": "src/test/ui/did_you_mean/issue-48492-tuple-destructure-missing-parens.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b228b053ec719919c0c8b3410d90a7501f9b829c/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-48492-tuple-destructure-missing-parens.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b228b053ec719919c0c8b3410d90a7501f9b829c/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-48492-tuple-destructure-missing-parens.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-48492-tuple-destructure-missing-parens.stderr?ref=b228b053ec719919c0c8b3410d90a7501f9b829c", "patch": "@@ -0,0 +1,38 @@\n+error: unexpected `,` in pattern\n+  --> $DIR/issue-48492-tuple-destructure-missing-parens.rs:48:17\n+   |\n+LL |     while let b1, b2, b3 = reading_frame.next().expect(\"there should be a start codon\") {\n+   |               --^------- help: try adding parentheses: `(b1, b2, b3)`\n+\n+error: unexpected `,` in pattern\n+  --> $DIR/issue-48492-tuple-destructure-missing-parens.rs:59:14\n+   |\n+LL |     if let b1, b2, b3 = reading_frame.next().unwrap() {\n+   |            --^------- help: try adding parentheses: `(b1, b2, b3)`\n+\n+error: unexpected `,` in pattern\n+  --> $DIR/issue-48492-tuple-destructure-missing-parens.rs:69:28\n+   |\n+LL |         Nucleotide::Adenine, Nucleotide::Cytosine, _ => true\n+   |         -------------------^------------------------ help: try adding parentheses: `(Nucleotide::Adenine, Nucleotide::Cytosine, _)`\n+\n+error: unexpected `,` in pattern\n+  --> $DIR/issue-48492-tuple-destructure-missing-parens.rs:77:10\n+   |\n+LL |     for x, _barr_body in women.iter().map(|woman| woman.allosomes.clone()) {\n+   |         -^----------- help: try adding parentheses: `(x, _barr_body)`\n+\n+error: unexpected `,` in pattern\n+  --> $DIR/issue-48492-tuple-destructure-missing-parens.rs:85:10\n+   |\n+LL |     for x, y @ Allosome::Y(_) in men.iter().map(|man| man.allosomes.clone()) {\n+   |         -^------------------- help: try adding parentheses: `(x, y @ Allosome::Y(_))`\n+\n+error: unexpected `,` in pattern\n+  --> $DIR/issue-48492-tuple-destructure-missing-parens.rs:94:14\n+   |\n+LL |     let women, men: (Vec<Genome>, Vec<Genome>) = genomes.iter().cloned()\n+   |         -----^---- help: try adding parentheses: `(women, men)`\n+\n+error: aborting due to 6 previous errors\n+"}]}