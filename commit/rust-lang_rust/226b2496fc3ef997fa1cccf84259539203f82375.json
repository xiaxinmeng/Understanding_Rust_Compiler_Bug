{"sha": "226b2496fc3ef997fa1cccf84259539203f82375", "node_id": "C_kwDOAAsO6NoAKDIyNmIyNDk2ZmMzZWY5OTdmYTFjY2NmODQyNTk1MzkyMDNmODIzNzU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-28T06:46:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-28T06:46:42Z"}, "message": "Auto merge of #107400 - matthiaskrgr:rollup-l6bycds, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #107022 (Implement `SpecOptionPartialEq` for `cmp::Ordering`)\n - #107100 (Use proper `InferCtxt` when probing for associated types in astconv)\n - #107103 (Use new solver in `evaluate_obligation` query (when new solver is enabled))\n - #107190 (Recover from more const arguments that are not wrapped in curly braces)\n - #107306 (Correct suggestions for closure arguments that need a borrow)\n - #107339 (internally change regions to be covariant)\n - #107344 (Minor tweaks in the new solver)\n - #107373 (Don't merge vtables when full debuginfo is enabled.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "2361600500563b0dead6cc46bd77ca20bcd915a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2361600500563b0dead6cc46bd77ca20bcd915a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/226b2496fc3ef997fa1cccf84259539203f82375", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/226b2496fc3ef997fa1cccf84259539203f82375", "html_url": "https://github.com/rust-lang/rust/commit/226b2496fc3ef997fa1cccf84259539203f82375", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/226b2496fc3ef997fa1cccf84259539203f82375/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "252741673b9c2b06267cd3a036d77489e92f963a", "url": "https://api.github.com/repos/rust-lang/rust/commits/252741673b9c2b06267cd3a036d77489e92f963a", "html_url": "https://github.com/rust-lang/rust/commit/252741673b9c2b06267cd3a036d77489e92f963a"}, {"sha": "c89bb159f6d1e9049f9c42a3eb8d0f355524f029", "url": "https://api.github.com/repos/rust-lang/rust/commits/c89bb159f6d1e9049f9c42a3eb8d0f355524f029", "html_url": "https://github.com/rust-lang/rust/commit/c89bb159f6d1e9049f9c42a3eb8d0f355524f029"}], "stats": {"total": 691, "additions": 531, "deletions": 160}, "files": [{"sha": "f73bbf3d22bd789f17306cfefaff39a7b7885cba", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -1499,6 +1499,11 @@ pub fn create_vtable_di_node<'ll, 'tcx>(\n         return;\n     }\n \n+    // When full debuginfo is enabled, we want to try and prevent vtables from being\n+    // merged. Otherwise debuggers will have a hard time mapping from dyn pointer\n+    // to concrete type.\n+    llvm::SetUnnamedAddress(vtable, llvm::UnnamedAddr::No);\n+\n     let vtable_name =\n         compute_debuginfo_vtable_name(cx.tcx, ty, poly_trait_ref, VTableNameKind::GlobalVariable);\n     let vtable_type_di_node = build_vtable_type_di_node(cx, ty, poly_trait_ref);"}, {"sha": "caf26a75d3cc4c18b4bfabcac1af7e84875b0b09", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 61, "deletions": 45, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -27,7 +27,7 @@ use rustc_hir::def::{CtorOf, DefKind, Namespace, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{walk_generics, Visitor as _};\n use rustc_hir::{GenericArg, GenericArgs, OpaqueTyOrigin};\n-use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_middle::middle::stability::AllowUnstable;\n use rustc_middle::ty::subst::{self, GenericArgKind, InternalSubsts, SubstsRef};\n use rustc_middle::ty::GenericParamDefKind;\n@@ -37,7 +37,7 @@ use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, BARE_TRAIT_OBJECT\n use rustc_span::edition::Edition;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{kw, Ident, Symbol};\n-use rustc_span::{sym, Span};\n+use rustc_span::{sym, Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::astconv_object_safety_violations;\n@@ -54,7 +54,7 @@ use std::slice;\n pub struct PathSeg(pub DefId, pub usize);\n \n pub trait AstConv<'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'tcx>;\n+    fn tcx(&self) -> TyCtxt<'tcx>;\n \n     fn item_def_id(&self) -> DefId;\n \n@@ -131,6 +131,8 @@ pub trait AstConv<'tcx> {\n     {\n         self\n     }\n+\n+    fn infcx(&self) -> Option<&InferCtxt<'tcx>>;\n }\n \n #[derive(Debug)]\n@@ -2132,48 +2134,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     )\n                     .emit() // Already reported in an earlier stage.\n                 } else {\n-                    // Find all the `impl`s that `qself_ty` has for any trait that has the\n-                    // associated type, so that we suggest the right one.\n-                    let infcx = tcx.infer_ctxt().build();\n-                    // We create a fresh `ty::ParamEnv` instead of the one for `self.item_def_id()`\n-                    // to avoid a cycle error in `src/test/ui/resolve/issue-102946.rs`.\n-                    let param_env = ty::ParamEnv::empty();\n-                    let traits: Vec<_> = self\n-                        .tcx()\n-                        .all_traits()\n-                        .filter(|trait_def_id| {\n-                            // Consider only traits with the associated type\n-                            tcx.associated_items(*trait_def_id)\n-                                .in_definition_order()\n-                                .any(|i| {\n-                                    i.kind.namespace() == Namespace::TypeNS\n-                                        && i.ident(tcx).normalize_to_macros_2_0() == assoc_ident\n-                                        && matches!(i.kind, ty::AssocKind::Type)\n-                                })\n-                            // Consider only accessible traits\n-                            && tcx.visibility(*trait_def_id)\n-                                .is_accessible_from(self.item_def_id(), tcx)\n-                            && tcx.all_impls(*trait_def_id)\n-                                .any(|impl_def_id| {\n-                                    let trait_ref = tcx.impl_trait_ref(impl_def_id);\n-                                    trait_ref.map_or(false, |trait_ref| {\n-                                        let impl_ = trait_ref.subst(\n-                                            tcx,\n-                                            infcx.fresh_substs_for_item(span, impl_def_id),\n-                                        );\n-                                        infcx\n-                                            .can_eq(\n-                                                param_env,\n-                                                tcx.erase_regions(impl_.self_ty()),\n-                                                tcx.erase_regions(qself_ty),\n-                                            )\n-                                            .is_ok()\n-                                    })\n-                                    && tcx.impl_polarity(impl_def_id) != ty::ImplPolarity::Negative\n-                                })\n-                        })\n-                        .map(|trait_def_id| tcx.def_path_str(trait_def_id))\n-                        .collect();\n+                    let traits: Vec<_> =\n+                        self.probe_traits_that_match_assoc_ty(qself_ty, assoc_ident);\n \n                     // Don't print `TyErr` to the user.\n                     self.report_ambiguous_associated_type(\n@@ -2232,6 +2194,60 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         Ok((ty, DefKind::AssocTy, assoc_ty_did))\n     }\n \n+    fn probe_traits_that_match_assoc_ty(\n+        &self,\n+        qself_ty: Ty<'tcx>,\n+        assoc_ident: Ident,\n+    ) -> Vec<String> {\n+        let tcx = self.tcx();\n+\n+        // In contexts that have no inference context, just make a new one.\n+        // We do need a local variable to store it, though.\n+        let infcx_;\n+        let infcx = if let Some(infcx) = self.infcx() {\n+            infcx\n+        } else {\n+            assert!(!qself_ty.needs_infer());\n+            infcx_ = tcx.infer_ctxt().build();\n+            &infcx_\n+        };\n+\n+        tcx.all_traits()\n+            .filter(|trait_def_id| {\n+                // Consider only traits with the associated type\n+                tcx.associated_items(*trait_def_id)\n+                        .in_definition_order()\n+                        .any(|i| {\n+                            i.kind.namespace() == Namespace::TypeNS\n+                                && i.ident(tcx).normalize_to_macros_2_0() == assoc_ident\n+                                && matches!(i.kind, ty::AssocKind::Type)\n+                        })\n+                    // Consider only accessible traits\n+                    && tcx.visibility(*trait_def_id)\n+                        .is_accessible_from(self.item_def_id(), tcx)\n+                    && tcx.all_impls(*trait_def_id)\n+                        .any(|impl_def_id| {\n+                            let trait_ref = tcx.impl_trait_ref(impl_def_id);\n+                            trait_ref.map_or(false, |trait_ref| {\n+                                let impl_ = trait_ref.subst(\n+                                    tcx,\n+                                    infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id),\n+                                );\n+                                infcx\n+                                    .can_eq(\n+                                        ty::ParamEnv::empty(),\n+                                        tcx.erase_regions(impl_.self_ty()),\n+                                        tcx.erase_regions(qself_ty),\n+                                    )\n+                                    .is_ok()\n+                            })\n+                            && tcx.impl_polarity(impl_def_id) != ty::ImplPolarity::Negative\n+                        })\n+            })\n+            .map(|trait_def_id| tcx.def_path_str(trait_def_id))\n+            .collect()\n+    }\n+\n     fn lookup_assoc_ty(\n         &self,\n         ident: Ident,"}, {"sha": "f5a1e51c07b2f53edecc49e633318789dfeb08fd", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -25,7 +25,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{GenericParamKind, Node};\n-use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::query::Providers;\n@@ -517,6 +517,10 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n     fn record_ty(&self, _hir_id: hir::HirId, _ty: Ty<'tcx>, _span: Span) {\n         // There's no place to record types from signatures?\n     }\n+\n+    fn infcx(&self) -> Option<&InferCtxt<'tcx>> {\n+        None\n+    }\n }\n \n /// Synthesize a new lifetime name that doesn't clash with any of the lifetimes already present."}, {"sha": "165782f209a0ce925418ef909f926d61db62a5b8", "filename": "compiler/rustc_hir_analysis/src/variance/constraints.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fconstraints.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -225,8 +225,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::Ref(region, ty, mutbl) => {\n-                let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(current, region, contra);\n+                self.add_constraints_from_region(current, region, variance);\n                 self.add_constraints_from_mt(current, &ty::TypeAndMut { ty, mutbl }, variance);\n             }\n \n@@ -258,9 +257,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::Dynamic(data, r, _) => {\n-                // The type `Foo<T+'a>` is contravariant w/r/t `'a`:\n-                let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(current, r, contra);\n+                // The type `dyn Trait<T> +'a` is covariant w/r/t `'a`:\n+                self.add_constraints_from_region(current, r, variance);\n \n                 if let Some(poly_trait_ref) = data.principal() {\n                     self.add_constraints_from_invariant_substs("}, {"sha": "4940015ddd571811d90137ce5dd33a69cd6ba08f", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -324,6 +324,10 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         let ty = if !ty.has_escaping_bound_vars() { self.normalize(span, ty) } else { ty };\n         self.write_ty(hir_id, ty)\n     }\n+\n+    fn infcx(&self) -> Option<&infer::InferCtxt<'tcx>> {\n+        Some(&self.infcx)\n+    }\n }\n \n /// Represents a user-provided type in the raw form (never normalized)."}, {"sha": "b92b162a9786a652dd51a0e8085251718e8f5a4f", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -79,7 +79,8 @@ impl<'tcx> TypeRelation<'tcx> for Glb<'_, '_, 'tcx> {\n         debug!(\"{}.regions({:?}, {:?})\", self.tag(), a, b);\n \n         let origin = Subtype(Box::new(self.fields.trace.clone()));\n-        Ok(self.fields.infcx.inner.borrow_mut().unwrap_region_constraints().glb_regions(\n+        // GLB(&'static u8, &'a u8) == &RegionLUB('static, 'a) u8 == &'static u8\n+        Ok(self.fields.infcx.inner.borrow_mut().unwrap_region_constraints().lub_regions(\n             self.tcx(),\n             origin,\n             a,"}, {"sha": "f6e0554fd1f951634bfa9b78a7123b3338b286d9", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -79,7 +79,8 @@ impl<'tcx> TypeRelation<'tcx> for Lub<'_, '_, 'tcx> {\n         debug!(\"{}.regions({:?}, {:?})\", self.tag(), a, b);\n \n         let origin = Subtype(Box::new(self.fields.trace.clone()));\n-        Ok(self.fields.infcx.inner.borrow_mut().unwrap_region_constraints().lub_regions(\n+        // LUB(&'static u8, &'a u8) == &RegionGLB('static, 'a) u8 == &'a u8\n+        Ok(self.fields.infcx.inner.borrow_mut().unwrap_region_constraints().glb_regions(\n             self.tcx(),\n             origin,\n             a,"}, {"sha": "f83219b8ee2a0e0ad1e80f374f6d12dd4574aa5c", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -663,13 +663,13 @@ where\n         debug!(?v_b);\n \n         if self.ambient_covariance() {\n-            // Covariance: a <= b. Hence, `b: a`.\n-            self.push_outlives(v_b, v_a, self.ambient_variance_info);\n+            // Covariant: &'a u8 <: &'b u8. Hence, `'a: 'b`.\n+            self.push_outlives(v_a, v_b, self.ambient_variance_info);\n         }\n \n         if self.ambient_contravariance() {\n-            // Contravariant: b <= a. Hence, `a: b`.\n-            self.push_outlives(v_a, v_b, self.ambient_variance_info);\n+            // Contravariant: &'b u8 <: &'a u8. Hence, `'b: 'a`.\n+            self.push_outlives(v_b, v_a, self.ambient_variance_info);\n         }\n \n         Ok(a)"}, {"sha": "51c34f0d55f6ff715336cc2b45d53c3e2df19a16", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -191,12 +191,13 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n         // from the \"cause\" field, we could perhaps give more tailored\n         // error messages.\n         let origin = SubregionOrigin::Subtype(Box::new(self.fields.trace.clone()));\n+        // Subtype(&'a u8, &'b u8) => Outlives('a: 'b) => SubRegion('b, 'a)\n         self.fields\n             .infcx\n             .inner\n             .borrow_mut()\n             .unwrap_region_constraints()\n-            .make_subregion(origin, a, b);\n+            .make_subregion(origin, b, a);\n \n         Ok(a)\n     }"}, {"sha": "fa87301df7e779f09d0eb8f002164b7fe9e82221", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -443,12 +443,7 @@ pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n             if a_repr == b_repr =>\n         {\n             let region_bound = relation.with_cause(Cause::ExistentialRegionBound, |relation| {\n-                relation.relate_with_variance(\n-                    ty::Contravariant,\n-                    ty::VarianceDiagInfo::default(),\n-                    a_region,\n-                    b_region,\n-                )\n+                relation.relate(a_region, b_region)\n             })?;\n             Ok(tcx.mk_dynamic(relation.relate(a_obj, b_obj)?, region_bound, a_repr))\n         }\n@@ -497,12 +492,7 @@ pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n         }\n \n         (&ty::Ref(a_r, a_ty, a_mutbl), &ty::Ref(b_r, b_ty, b_mutbl)) => {\n-            let r = relation.relate_with_variance(\n-                ty::Contravariant,\n-                ty::VarianceDiagInfo::default(),\n-                a_r,\n-                b_r,\n-            )?;\n+            let r = relation.relate(a_r, b_r)?;\n             let a_mt = ty::TypeAndMut { ty: a_ty, mutbl: a_mutbl };\n             let b_mt = ty::TypeAndMut { ty: b_ty, mutbl: b_mutbl };\n             let mt = relate_type_and_mut(relation, a_mt, b_mt, a)?;"}, {"sha": "f4c08031bcca08c15542d6eb326d56bd07e54749", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -2353,6 +2353,28 @@ impl<'a> Parser<'a> {\n         Err(err)\n     }\n \n+    /// Try to recover from an unbraced const argument whose first token [could begin a type][ty].\n+    ///\n+    /// [ty]: token::Token::can_begin_type\n+    pub(crate) fn recover_unbraced_const_arg_that_can_begin_ty(\n+        &mut self,\n+        mut snapshot: SnapshotParser<'a>,\n+    ) -> Option<P<ast::Expr>> {\n+        match snapshot.parse_expr_res(Restrictions::CONST_EXPR, None) {\n+            // Since we don't know the exact reason why we failed to parse the type or the\n+            // expression, employ a simple heuristic to weed out some pathological cases.\n+            Ok(expr) if let token::Comma | token::Gt = snapshot.token.kind => {\n+                self.restore_snapshot(snapshot);\n+                Some(expr)\n+            }\n+            Ok(_) => None,\n+            Err(err) => {\n+                err.cancel();\n+                None\n+            }\n+        }\n+    }\n+\n     /// Creates a dummy const argument, and reports that the expression must be enclosed in braces\n     pub fn dummy_const_arg_needs_braces(\n         &self,"}, {"sha": "2e706a00cf7f3babcbf027c568599a77d3431597", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -675,22 +675,42 @@ impl<'a> Parser<'a> {\n             GenericArg::Const(self.parse_const_arg()?)\n         } else if self.check_type() {\n             // Parse type argument.\n-            let is_const_fn =\n-                self.look_ahead(1, |t| t.kind == token::OpenDelim(Delimiter::Parenthesis));\n-            let mut snapshot = self.create_snapshot_for_diagnostic();\n+\n+            // Proactively create a parser snapshot enabling us to rewind and try to reparse the\n+            // input as a const expression in case we fail to parse a type. If we successfully\n+            // do so, we will report an error that it needs to be wrapped in braces.\n+            let mut snapshot = None;\n+            if self.may_recover() && self.token.can_begin_expr() {\n+                snapshot = Some(self.create_snapshot_for_diagnostic());\n+            }\n+\n             match self.parse_ty() {\n-                Ok(ty) => GenericArg::Type(ty),\n+                Ok(ty) => {\n+                    // Since the type parser recovers from some malformed slice and array types and\n+                    // successfully returns a type, we need to look for `TyKind::Err`s in the\n+                    // type to determine if error recovery has occurred and if the input is not a\n+                    // syntactically valid type after all.\n+                    if let ast::TyKind::Slice(inner_ty) | ast::TyKind::Array(inner_ty, _) = &ty.kind\n+                        && let ast::TyKind::Err = inner_ty.kind\n+                        && let Some(snapshot) = snapshot\n+                        && let Some(expr) = self.recover_unbraced_const_arg_that_can_begin_ty(snapshot)\n+                    {\n+                        return Ok(Some(self.dummy_const_arg_needs_braces(\n+                            self.struct_span_err(expr.span, \"invalid const generic expression\"),\n+                            expr.span,\n+                        )));\n+                    }\n+\n+                    GenericArg::Type(ty)\n+                }\n                 Err(err) => {\n-                    if is_const_fn {\n-                        match (*snapshot).parse_expr_res(Restrictions::CONST_EXPR, None) {\n-                            Ok(expr) => {\n-                                self.restore_snapshot(snapshot);\n-                                return Ok(Some(self.dummy_const_arg_needs_braces(err, expr.span)));\n-                            }\n-                            Err(err) => {\n-                                err.cancel();\n-                            }\n-                        }\n+                    if let Some(snapshot) = snapshot\n+                        && let Some(expr) = self.recover_unbraced_const_arg_that_can_begin_ty(snapshot)\n+                    {\n+                        return Ok(Some(self.dummy_const_arg_needs_braces(\n+                            err,\n+                            expr.span,\n+                        )));\n                     }\n                     // Try to recover from possible `const` arg without braces.\n                     return self.recover_const_arg(start, err).map(Some);"}, {"sha": "f7cf81da497529af14920277b0bb892aa9323ae6", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -1,6 +1,8 @@\n //! Code shared by trait and projection goals for candidate assembly.\n \n use super::infcx_ext::InferCtxtExt;\n+#[cfg(doc)]\n+use super::trait_goals::structural_traits::*;\n use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n@@ -98,52 +100,75 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy + Eq {\n         assumption: ty::Predicate<'tcx>,\n     ) -> QueryResult<'tcx>;\n \n+    // A type implements an `auto trait` if its components do as well. These components\n+    // are given by built-in rules from [`instantiate_constituent_tys_for_auto_trait`].\n     fn consider_auto_trait_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n \n+    // A trait alias holds if the RHS traits and `where` clauses hold.\n     fn consider_trait_alias_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n \n+    // A type is `Copy` or `Clone` if its components are `Sized`. These components\n+    // are given by built-in rules from [`instantiate_constituent_tys_for_sized_trait`].\n     fn consider_builtin_sized_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n \n+    // A type is `Copy` or `Clone` if its components are `Copy` or `Clone`. These\n+    // components are given by built-in rules from [`instantiate_constituent_tys_for_copy_clone_trait`].\n     fn consider_builtin_copy_clone_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n \n+    // A type is `PointerSized` if we can compute its layout, and that layout\n+    // matches the layout of `usize`.\n     fn consider_builtin_pointer_sized_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n \n+    // A callable type (a closure, fn def, or fn ptr) is known to implement the `Fn<A>`\n+    // family of traits where `A` is given by the signature of the type.\n     fn consider_builtin_fn_trait_candidates(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n         kind: ty::ClosureKind,\n     ) -> QueryResult<'tcx>;\n \n+    // `Tuple` is implemented if the `Self` type is a tuple.\n     fn consider_builtin_tuple_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n \n+    // `Pointee` is always implemented.\n+    //\n+    // See the projection implementation for the `Metadata` types for all of\n+    // the built-in types. For structs, the metadata type is given by the struct\n+    // tail.\n     fn consider_builtin_pointee_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n \n+    // A generator (that comes from an `async` desugaring) is known to implement\n+    // `Future<Output = O>`, where `O` is given by the generator's return type\n+    // that was computed during type-checking.\n     fn consider_builtin_future_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n \n+    // A generator (that doesn't come from an `async` desugaring) is known to\n+    // implement `Generator<R, Yield = Y, Return = O>`, given the resume, yield,\n+    // and return types of the generator computed during type-checking.\n     fn consider_builtin_generator_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,"}, {"sha": "e240dd5a2257a062f2b8e117e104c7a34b952f79", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -335,15 +335,13 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             // That won't actually reflect in the query response, so it seems moot.\n             self.make_canonical_response(Certainty::AMBIGUOUS)\n         } else {\n-            self.infcx.probe(|_| {\n-                let InferOk { value: (), obligations } = self\n-                    .infcx\n-                    .at(&ObligationCause::dummy(), goal.param_env)\n-                    .sub(goal.predicate.a, goal.predicate.b)?;\n-                self.evaluate_all_and_make_canonical_response(\n-                    obligations.into_iter().map(|pred| pred.into()).collect(),\n-                )\n-            })\n+            let InferOk { value: (), obligations } = self\n+                .infcx\n+                .at(&ObligationCause::dummy(), goal.param_env)\n+                .sub(goal.predicate.a, goal.predicate.b)?;\n+            self.evaluate_all_and_make_canonical_response(\n+                obligations.into_iter().map(|pred| pred.into()).collect(),\n+            )\n         }\n     }\n \n@@ -376,22 +374,22 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         &mut self,\n         goal: Goal<'tcx, ty::GenericArg<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        self.infcx.probe(|_| {\n-            match crate::traits::wf::unnormalized_obligations(\n-                self.infcx,\n-                goal.param_env,\n-                goal.predicate,\n-            ) {\n-                Some(obligations) => self.evaluate_all_and_make_canonical_response(\n-                    obligations.into_iter().map(|o| o.into()).collect(),\n-                ),\n-                None => self.make_canonical_response(Certainty::AMBIGUOUS),\n-            }\n-        })\n+        match crate::traits::wf::unnormalized_obligations(\n+            self.infcx,\n+            goal.param_env,\n+            goal.predicate,\n+        ) {\n+            Some(obligations) => self.evaluate_all_and_make_canonical_response(\n+                obligations.into_iter().map(|o| o.into()).collect(),\n+            ),\n+            None => self.make_canonical_response(Certainty::AMBIGUOUS),\n+        }\n     }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n+    // Recursively evaluates a list of goals to completion, returning the certainty\n+    // of all of the goals.\n     fn evaluate_all(\n         &mut self,\n         mut goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,\n@@ -428,6 +426,10 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         })\n     }\n \n+    // Recursively evaluates a list of goals to completion, making a query response.\n+    //\n+    // This is just a convenient way of calling [`EvalCtxt::evaluate_all`],\n+    // then [`EvalCtxt::make_canonical_response`].\n     fn evaluate_all_and_make_canonical_response(\n         &mut self,\n         goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,"}, {"sha": "638efaa2ba5d2f388a4ddd432ccc68bf0f0812ad", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -296,7 +296,9 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n     ) -> QueryResult<'tcx> {\n-        if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred() {\n+        if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred()\n+            && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n+        {\n             ecx.infcx.probe(|_| {\n                 let assumption_projection_pred =\n                     ecx.infcx.instantiate_bound_vars_with_infer(poly_projection_pred);"}, {"sha": "45b6a5f4ec578b3ce19b4c9f60a03c9649fc88b5", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -65,7 +65,9 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n     ) -> QueryResult<'tcx> {\n-        if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred() {\n+        if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred()\n+            && poly_trait_pred.def_id() == goal.predicate.def_id()\n+        {\n             // FIXME: Constness and polarity\n             ecx.infcx.probe(|_| {\n                 let assumption_trait_pred ="}, {"sha": "26c0b3beb37ba91df6fc0bc309f331d161c40061", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -3807,13 +3807,13 @@ fn hint_missing_borrow<'tcx>(\n     err: &mut Diagnostic,\n ) {\n     let found_args = match found.kind() {\n-        ty::FnPtr(f) => f.inputs().skip_binder().iter(),\n+        ty::FnPtr(f) => infcx.replace_bound_vars_with_placeholders(*f).inputs().iter(),\n         kind => {\n             span_bug!(span, \"found was converted to a FnPtr above but is now {:?}\", kind)\n         }\n     };\n     let expected_args = match expected.kind() {\n-        ty::FnPtr(f) => f.inputs().skip_binder().iter(),\n+        ty::FnPtr(f) => infcx.replace_bound_vars_with_placeholders(*f).inputs().iter(),\n         kind => {\n             span_bug!(span, \"expected was converted to a FnPtr above but is now {:?}\", kind)\n         }\n@@ -3824,12 +3824,12 @@ fn hint_missing_borrow<'tcx>(\n \n     let args = fn_decl.inputs.iter().map(|ty| ty);\n \n-    fn get_deref_type_and_refs(mut ty: Ty<'_>) -> (Ty<'_>, usize) {\n-        let mut refs = 0;\n+    fn get_deref_type_and_refs(mut ty: Ty<'_>) -> (Ty<'_>, Vec<hir::Mutability>) {\n+        let mut refs = vec![];\n \n-        while let ty::Ref(_, new_ty, _) = ty.kind() {\n+        while let ty::Ref(_, new_ty, mutbl) = ty.kind() {\n             ty = *new_ty;\n-            refs += 1;\n+            refs.push(*mutbl);\n         }\n \n         (ty, refs)\n@@ -3843,11 +3843,21 @@ fn hint_missing_borrow<'tcx>(\n         let (expected_ty, expected_refs) = get_deref_type_and_refs(*expected_arg);\n \n         if infcx.can_eq(param_env, found_ty, expected_ty).is_ok() {\n-            if found_refs < expected_refs {\n-                to_borrow.push((arg.span.shrink_to_lo(), \"&\".repeat(expected_refs - found_refs)));\n-            } else if found_refs > expected_refs {\n+            // FIXME: This could handle more exotic cases like mutability mismatches too!\n+            if found_refs.len() < expected_refs.len()\n+                && found_refs[..] == expected_refs[expected_refs.len() - found_refs.len()..]\n+            {\n+                to_borrow.push((\n+                    arg.span.shrink_to_lo(),\n+                    expected_refs[..expected_refs.len() - found_refs.len()]\n+                        .iter()\n+                        .map(|mutbl| format!(\"&{}\", mutbl.prefix_str()))\n+                        .collect::<Vec<_>>()\n+                        .join(\"\"),\n+                ));\n+            } else if found_refs.len() > expected_refs.len() {\n                 let mut span = arg.span.shrink_to_lo();\n-                let mut left = found_refs - expected_refs;\n+                let mut left = found_refs.len() - expected_refs.len();\n                 let mut ty = arg;\n                 while let hir::TyKind::Ref(_, mut_ty) = &ty.kind && left > 0 {\n                     span = span.with_hi(mut_ty.ty.span.lo());"}, {"sha": "f183248f2d08b0474e6ef47b7b3ced870c95d53a", "filename": "compiler/rustc_trait_selection/src/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 37, "deletions": 6, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -1,7 +1,9 @@\n use rustc_middle::ty;\n+use rustc_session::config::TraitSolver;\n \n use crate::infer::canonical::OriginalQueryValues;\n use crate::infer::InferCtxt;\n+use crate::solve::{Certainty, Goal, InferCtxtEvalExt, MaybeCause};\n use crate::traits::{EvaluationResult, OverflowError, PredicateObligation, SelectionContext};\n \n pub trait InferCtxtExt<'tcx> {\n@@ -77,12 +79,38 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n             _ => obligation.param_env.without_const(),\n         };\n \n-        let c_pred = self\n-            .canonicalize_query_keep_static(param_env.and(obligation.predicate), &mut _orig_values);\n-        // Run canonical query. If overflow occurs, rerun from scratch but this time\n-        // in standard trait query mode so that overflow is handled appropriately\n-        // within `SelectionContext`.\n-        self.tcx.at(obligation.cause.span()).evaluate_obligation(c_pred)\n+        if self.tcx.sess.opts.unstable_opts.trait_solver != TraitSolver::Next {\n+            let c_pred = self.canonicalize_query_keep_static(\n+                param_env.and(obligation.predicate),\n+                &mut _orig_values,\n+            );\n+            self.tcx.at(obligation.cause.span()).evaluate_obligation(c_pred)\n+        } else {\n+            self.probe(|snapshot| {\n+                if let Ok((_, certainty)) =\n+                    self.evaluate_root_goal(Goal::new(self.tcx, param_env, obligation.predicate))\n+                {\n+                    match certainty {\n+                        Certainty::Yes => {\n+                            if self.opaque_types_added_in_snapshot(snapshot) {\n+                                Ok(EvaluationResult::EvaluatedToOkModuloOpaqueTypes)\n+                            } else if self.region_constraints_added_in_snapshot(snapshot).is_some()\n+                            {\n+                                Ok(EvaluationResult::EvaluatedToOkModuloRegions)\n+                            } else {\n+                                Ok(EvaluationResult::EvaluatedToOk)\n+                            }\n+                        }\n+                        Certainty::Maybe(MaybeCause::Ambiguity) => {\n+                            Ok(EvaluationResult::EvaluatedToAmbig)\n+                        }\n+                        Certainty::Maybe(MaybeCause::Overflow) => Err(OverflowError::Canonical),\n+                    }\n+                } else {\n+                    Ok(EvaluationResult::EvaluatedToErr)\n+                }\n+            })\n+        }\n     }\n \n     // Helper function that canonicalizes and runs the query. If an\n@@ -92,6 +120,9 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n     ) -> EvaluationResult {\n+        // Run canonical query. If overflow occurs, rerun from scratch but this time\n+        // in standard trait query mode so that overflow is handled appropriately\n+        // within `SelectionContext`.\n         match self.evaluate_obligation(obligation) {\n             Ok(result) => result,\n             Err(OverflowError::Canonical) => {"}, {"sha": "c43b728022d2fa60ab35b41f249c33410d3afef0", "filename": "library/core/src/option.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -551,7 +551,7 @@ use crate::marker::Destruct;\n use crate::panicking::{panic, panic_str};\n use crate::pin::Pin;\n use crate::{\n-    convert, hint, mem,\n+    cmp, convert, hint, mem,\n     ops::{self, ControlFlow, Deref, DerefMut},\n };\n \n@@ -2090,6 +2090,12 @@ impl<T: PartialEq> PartialEq for Option<T> {\n     }\n }\n \n+/// This specialization trait is a workaround for LLVM not currently (2023-01)\n+/// being able to optimize this itself, even though Alive confirms that it would\n+/// be legal to do so: <https://github.com/llvm/llvm-project/issues/52622>\n+///\n+/// Once that's fixed, `Option` should go back to deriving `PartialEq`, as\n+/// it used to do before <https://github.com/rust-lang/rust/pull/103556>.\n #[unstable(feature = \"spec_option_partial_eq\", issue = \"none\", reason = \"exposed only for rustc\")]\n #[doc(hidden)]\n pub trait SpecOptionPartialEq: Sized {\n@@ -2146,6 +2152,14 @@ impl<T> SpecOptionPartialEq for crate::ptr::NonNull<T> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl SpecOptionPartialEq for cmp::Ordering {\n+    #[inline]\n+    fn eq(l: &Option<Self>, r: &Option<Self>) -> bool {\n+        l.map_or(2, |x| x as i8) == r.map_or(2, |x| x as i8)\n+    }\n+}\n+\n /////////////////////////////////////////////////////////////////////////////\n // The Option Iterators\n /////////////////////////////////////////////////////////////////////////////"}, {"sha": "d82b737de0b417c5dd6c31288ef0edfc594205b8", "filename": "tests/codegen/debug-vtable.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fcodegen%2Fdebug-vtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fcodegen%2Fdebug-vtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fdebug-vtable.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -9,6 +9,14 @@\n // compile-flags: -Cdebuginfo=2 -Copt-level=0 -Csymbol-mangling-version=v0\n // ignore-tidy-linelength\n \n+// Make sure that vtables don't have the unnamed_addr attribute when debuginfo is enabled.\n+// This helps debuggers more reliably map from dyn pointer to concrete type.\n+// CHECK: @vtable.0 = private constant <{\n+// CHECK: @vtable.1 = private constant <{\n+// CHECK: @vtable.2 = private constant <{\n+// CHECK: @vtable.3 = private constant <{\n+// CHECK: @vtable.4 = private constant <{\n+\n // NONMSVC: ![[USIZE:[0-9]+]] = !DIBasicType(name: \"usize\"\n // MSVC: ![[USIZE:[0-9]+]] = !DIDerivedType(tag: DW_TAG_typedef, name: \"usize\"\n // NONMSVC: ![[PTR:[0-9]+]] = !DIDerivedType(tag: DW_TAG_pointer_type, name: \"*const ()\""}, {"sha": "835decd3e5f5e488f98693f3b8aa3acbffd857d2", "filename": "tests/codegen/option-nonzero-eq.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fcodegen%2Foption-nonzero-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fcodegen%2Foption-nonzero-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Foption-nonzero-eq.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -3,6 +3,7 @@\n #![crate_type = \"lib\"]\n \n extern crate core;\n+use core::cmp::Ordering;\n use core::num::{NonZeroU32, NonZeroI64};\n use core::ptr::NonNull;\n \n@@ -32,3 +33,12 @@ pub fn non_null_eq(l: Option<NonNull<u8>>, r: Option<NonNull<u8>>) -> bool {\n     // CHECK-NEXT: ret i1\n     l == r\n }\n+\n+// CHECK-lABEL: @ordering_eq\n+#[no_mangle]\n+pub fn ordering_eq(l: Option<Ordering>, r: Option<Ordering>) -> bool {\n+    // CHECK: start:\n+    // CHECK-NEXT: icmp eq i8\n+    // CHECK-NEXT: ret i1\n+    l == r\n+}"}, {"sha": "423752ca25eba9320e7589369bb58e224cc887ac", "filename": "tests/ui/const-generics/bad-const-generic-exprs.rs", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fconst-generics%2Fbad-const-generic-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fconst-generics%2Fbad-const-generic-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fbad-const-generic-exprs.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -13,10 +13,34 @@ fn main() {\n     let _: Wow<A.0>;\n     //~^ ERROR expected one of\n     //~| HELP expressions must be enclosed in braces to be used as const generic arguments\n-\n-    // FIXME(compiler-errors): This one is still unsatisfying,\n-    // and probably a case I could see someone typing by accident..\n+    let _: Wow<[]>;\n+    //~^ ERROR expected type\n+    //~| HELP expressions must be enclosed in braces to be used as const generic arguments\n     let _: Wow<[12]>;\n-    //~^ ERROR expected type, found\n-    //~| ERROR type provided when a constant was expected\n+    //~^ ERROR expected type\n+    //~| ERROR invalid const generic expression\n+    //~| HELP expressions must be enclosed in braces to be used as const generic arguments\n+    let _: Wow<[0, 1, 3]>;\n+    //~^ ERROR expected type\n+    //~| HELP expressions must be enclosed in braces to be used as const generic arguments\n+    let _: Wow<[0xff; 8]>;\n+    //~^ ERROR expected type\n+    //~| ERROR invalid const generic expression\n+    //~| HELP expressions must be enclosed in braces to be used as const generic arguments\n+    let _: Wow<[1, 2]>; // Regression test for issue #81698.\n+    //~^ ERROR expected type\n+    //~| HELP expressions must be enclosed in braces to be used as const generic arguments\n+    let _: Wow<&0>;\n+    //~^ ERROR expected type\n+    //~| HELP expressions must be enclosed in braces to be used as const generic arguments\n+    let _: Wow<(\"\", 0)>;\n+    //~^ ERROR expected type\n+    //~| HELP expressions must be enclosed in braces to be used as const generic arguments\n+    let _: Wow<(1 + 2) * 3>;\n+    //~^ ERROR expected type\n+    //~| HELP expressions must be enclosed in braces to be used as const generic arguments\n+    // FIXME(fmease): This one is pretty bad.\n+    let _: Wow<!0>;\n+    //~^ ERROR expected one of\n+    //~| HELP you might have meant to end the type parameters here\n }"}, {"sha": "17a63a96fe4fe5e12a68594e8c3d521b980c80ea", "filename": "tests/ui/const-generics/bad-const-generic-exprs.stderr", "status": "modified", "additions": 103, "deletions": 3, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fconst-generics%2Fbad-const-generic-exprs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fconst-generics%2Fbad-const-generic-exprs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fbad-const-generic-exprs.stderr?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -42,18 +42,118 @@ help: expressions must be enclosed in braces to be used as const generic argumen\n LL |     let _: Wow<{ A.0 }>;\n    |                +     +\n \n+error: expected type, found `]`\n+  --> $DIR/bad-const-generic-exprs.rs:16:17\n+   |\n+LL |     let _: Wow<[]>;\n+   |                 ^ expected type\n+   |\n+help: expressions must be enclosed in braces to be used as const generic arguments\n+   |\n+LL |     let _: Wow<{ [] }>;\n+   |                +    +\n+\n error: expected type, found `12`\n   --> $DIR/bad-const-generic-exprs.rs:19:17\n    |\n LL |     let _: Wow<[12]>;\n    |                 ^^ expected type\n \n-error[E0747]: type provided when a constant was expected\n+error: invalid const generic expression\n   --> $DIR/bad-const-generic-exprs.rs:19:16\n    |\n LL |     let _: Wow<[12]>;\n    |                ^^^^\n+   |\n+help: expressions must be enclosed in braces to be used as const generic arguments\n+   |\n+LL |     let _: Wow<{ [12] }>;\n+   |                +      +\n+\n+error: expected type, found `0`\n+  --> $DIR/bad-const-generic-exprs.rs:23:17\n+   |\n+LL |     let _: Wow<[0, 1, 3]>;\n+   |                 ^ expected type\n+   |\n+help: expressions must be enclosed in braces to be used as const generic arguments\n+   |\n+LL |     let _: Wow<{ [0, 1, 3] }>;\n+   |                +           +\n+\n+error: expected type, found `0xff`\n+  --> $DIR/bad-const-generic-exprs.rs:26:17\n+   |\n+LL |     let _: Wow<[0xff; 8]>;\n+   |                 ^^^^ expected type\n+\n+error: invalid const generic expression\n+  --> $DIR/bad-const-generic-exprs.rs:26:16\n+   |\n+LL |     let _: Wow<[0xff; 8]>;\n+   |                ^^^^^^^^^\n+   |\n+help: expressions must be enclosed in braces to be used as const generic arguments\n+   |\n+LL |     let _: Wow<{ [0xff; 8] }>;\n+   |                +           +\n+\n+error: expected type, found `1`\n+  --> $DIR/bad-const-generic-exprs.rs:30:17\n+   |\n+LL |     let _: Wow<[1, 2]>; // Regression test for issue #81698.\n+   |                 ^ expected type\n+   |\n+help: expressions must be enclosed in braces to be used as const generic arguments\n+   |\n+LL |     let _: Wow<{ [1, 2] }>; // Regression test for issue #81698.\n+   |                +        +\n+\n+error: expected type, found `0`\n+  --> $DIR/bad-const-generic-exprs.rs:33:17\n+   |\n+LL |     let _: Wow<&0>;\n+   |                 ^ expected type\n+   |\n+help: expressions must be enclosed in braces to be used as const generic arguments\n+   |\n+LL |     let _: Wow<{ &0 }>;\n+   |                +    +\n+\n+error: expected type, found `\"\"`\n+  --> $DIR/bad-const-generic-exprs.rs:36:17\n+   |\n+LL |     let _: Wow<(\"\", 0)>;\n+   |                 ^^ expected type\n+   |\n+help: expressions must be enclosed in braces to be used as const generic arguments\n+   |\n+LL |     let _: Wow<{ (\"\", 0) }>;\n+   |                +         +\n+\n+error: expected type, found `1`\n+  --> $DIR/bad-const-generic-exprs.rs:39:17\n+   |\n+LL |     let _: Wow<(1 + 2) * 3>;\n+   |                 ^ expected type\n+   |\n+help: expressions must be enclosed in braces to be used as const generic arguments\n+   |\n+LL |     let _: Wow<{ (1 + 2) * 3 }>;\n+   |                +             +\n+\n+error: expected one of `,` or `>`, found `0`\n+  --> $DIR/bad-const-generic-exprs.rs:43:17\n+   |\n+LL |     let _: Wow<!0>;\n+   |         -       ^ expected one of `,` or `>`\n+   |         |\n+   |         while parsing the type for `_`\n+   |\n+help: you might have meant to end the type parameters here\n+   |\n+LL |     let _: Wow<!>0>;\n+   |                 +\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 15 previous errors\n \n-For more information about this error, try `rustc --explain E0747`."}, {"sha": "74c138af483c17d99379753a95b18b5652fc39dc", "filename": "tests/ui/error-codes/E0208.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Ferror-codes%2FE0208.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Ferror-codes%2FE0208.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0208.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -1,7 +1,7 @@\n #![feature(rustc_attrs)]\n \n #[rustc_variance]\n-struct Foo<'a, T> { //~ ERROR [-, o]\n+struct Foo<'a, T> { //~ ERROR [+, o]\n     t: &'a mut T,\n }\n "}, {"sha": "2c7072a7e76266a74329c7311b4b484759cd0b31", "filename": "tests/ui/error-codes/E0208.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Ferror-codes%2FE0208.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Ferror-codes%2FE0208.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0208.stderr?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -1,4 +1,4 @@\n-error: [-, o]\n+error: [+, o]\n   --> $DIR/E0208.rs:4:1\n    |\n LL | struct Foo<'a, T> {"}, {"sha": "3bf6b7bb9b19e484ea0de703d880777df2316433", "filename": "tests/ui/suggestions/late-bound-in-borrow-closure-sugg.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fsuggestions%2Flate-bound-in-borrow-closure-sugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fsuggestions%2Flate-bound-in-borrow-closure-sugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Flate-bound-in-borrow-closure-sugg.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -0,0 +1,28 @@\n+use std::cell::RefCell;\n+use std::collections::HashMap;\n+use std::rc::Rc;\n+\n+pub struct Trader<'a> {\n+    closure: Box<dyn Fn(&mut Trader) + 'a>,\n+}\n+\n+impl<'a> Trader<'a> {\n+    pub fn new() -> Self {\n+        Trader {\n+            closure: Box::new(|_| {}),\n+        }\n+    }\n+    pub fn set_closure(&mut self, function: impl Fn(&mut Trader) + 'a) {\n+        //foo\n+    }\n+}\n+\n+fn main() {\n+    let closure = |trader : Trader| {\n+        println!(\"Woooosh!\");\n+    };\n+\n+    let mut trader = Trader::new();\n+    trader.set_closure(closure);\n+    //~^ ERROR type mismatch in closure arguments\n+}"}, {"sha": "6820af1fd45c36e03418bf26e18241566b6ff667", "filename": "tests/ui/suggestions/late-bound-in-borrow-closure-sugg.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fsuggestions%2Flate-bound-in-borrow-closure-sugg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fsuggestions%2Flate-bound-in-borrow-closure-sugg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Flate-bound-in-borrow-closure-sugg.stderr?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -0,0 +1,26 @@\n+error[E0631]: type mismatch in closure arguments\n+  --> $DIR/late-bound-in-borrow-closure-sugg.rs:26:24\n+   |\n+LL |     let closure = |trader : Trader| {\n+   |                   ----------------- found signature defined here\n+...\n+LL |     trader.set_closure(closure);\n+   |            ----------- ^^^^^^^ expected due to this\n+   |            |\n+   |            required by a bound introduced by this call\n+   |\n+   = note: expected closure signature `for<'a, 'b> fn(&'a mut Trader<'b>) -> _`\n+              found closure signature `for<'a> fn(Trader<'a>) -> _`\n+note: required by a bound in `Trader::<'a>::set_closure`\n+  --> $DIR/late-bound-in-borrow-closure-sugg.rs:15:50\n+   |\n+LL |     pub fn set_closure(&mut self, function: impl Fn(&mut Trader) + 'a) {\n+   |                                                  ^^^^^^^^^^^^^^^ required by this bound in `Trader::<'a>::set_closure`\n+help: consider borrowing the argument\n+   |\n+LL |     let closure = |trader : &mut Trader| {\n+   |                             ++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0631`."}, {"sha": "135cdf19e3e3e417b81bd27465df5e5b365d252a", "filename": "tests/ui/typeck/issue-107087.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Ftypeck%2Fissue-107087.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Ftypeck%2Fissue-107087.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-107087.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -0,0 +1,18 @@\n+struct A<T>(T);\n+\n+trait Foo {\n+    type B;\n+}\n+\n+impl Foo for A<u32> {\n+    type B = i32;\n+}\n+\n+impl Foo for A<i32> {\n+    type B = i32;\n+}\n+\n+fn main() {\n+    A::B::<>::C\n+    //~^ ERROR ambiguous associated type\n+}"}, {"sha": "70f19320802b91142d13e676f132f3f47ce9a3b8", "filename": "tests/ui/typeck/issue-107087.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Ftypeck%2Fissue-107087.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Ftypeck%2Fissue-107087.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-107087.stderr?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -0,0 +1,9 @@\n+error[E0223]: ambiguous associated type\n+  --> $DIR/issue-107087.rs:16:5\n+   |\n+LL |     A::B::<>::C\n+   |     ^^^^^^^^ help: use the fully-qualified path: `<A<_> as Foo>::B`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0223`."}, {"sha": "ecb0821827dc0df4a3048f794defb55f700b6457", "filename": "tests/ui/variance/variance-associated-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fvariance%2Fvariance-associated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fvariance%2Fvariance-associated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvariance%2Fvariance-associated-types.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -10,7 +10,7 @@ trait Trait<'a> {\n }\n \n #[rustc_variance]\n-struct Foo<'a, T : Trait<'a>> { //~ ERROR [-, +]\n+struct Foo<'a, T : Trait<'a>> { //~ ERROR [+, +]\n     field: (T, &'a ())\n }\n "}, {"sha": "70cb246f6e906da04ac481fdf156a070d1886aa3", "filename": "tests/ui/variance/variance-associated-types.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fvariance%2Fvariance-associated-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fvariance%2Fvariance-associated-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvariance%2Fvariance-associated-types.stderr?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -1,4 +1,4 @@\n-error: [-, +]\n+error: [+, +]\n   --> $DIR/variance-associated-types.rs:13:1\n    |\n LL | struct Foo<'a, T : Trait<'a>> {"}, {"sha": "39ea77a8aa21a1a38c00e6b852149b10abfc25c6", "filename": "tests/ui/variance/variance-regions-direct.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fvariance%2Fvariance-regions-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fvariance%2Fvariance-regions-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvariance%2Fvariance-regions-direct.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -6,7 +6,7 @@\n // Regions that just appear in normal spots are contravariant:\n \n #[rustc_variance]\n-struct Test2<'a, 'b, 'c> { //~ ERROR [-, -, -]\n+struct Test2<'a, 'b, 'c> { //~ ERROR [+, +, +]\n     x: &'a isize,\n     y: &'b [isize],\n     c: &'c str\n@@ -15,7 +15,7 @@ struct Test2<'a, 'b, 'c> { //~ ERROR [-, -, -]\n // Those same annotations in function arguments become covariant:\n \n #[rustc_variance]\n-struct Test3<'a, 'b, 'c> { //~ ERROR [+, +, +]\n+struct Test3<'a, 'b, 'c> { //~ ERROR [-, -, -]\n     x: extern \"Rust\" fn(&'a isize),\n     y: extern \"Rust\" fn(&'b [isize]),\n     c: extern \"Rust\" fn(&'c str),\n@@ -24,15 +24,15 @@ struct Test3<'a, 'b, 'c> { //~ ERROR [+, +, +]\n // Mutability induces invariance:\n \n #[rustc_variance]\n-struct Test4<'a, 'b:'a> { //~ ERROR [-, o]\n+struct Test4<'a, 'b:'a> { //~ ERROR [+, o]\n     x: &'a mut &'b isize,\n }\n \n // Mutability induces invariance, even when in a\n // contravariant context:\n \n #[rustc_variance]\n-struct Test5<'a, 'b:'a> { //~ ERROR [+, o]\n+struct Test5<'a, 'b:'a> { //~ ERROR [-, o]\n     x: extern \"Rust\" fn(&'a mut &'b isize),\n }\n \n@@ -42,7 +42,7 @@ struct Test5<'a, 'b:'a> { //~ ERROR [+, o]\n // argument list occurs in an invariant context.\n \n #[rustc_variance]\n-struct Test6<'a, 'b:'a> { //~ ERROR [-, o]\n+struct Test6<'a, 'b:'a> { //~ ERROR [+, o]\n     x: &'a mut extern \"Rust\" fn(&'b isize),\n }\n \n@@ -56,7 +56,7 @@ struct Test7<'a> { //~ ERROR [*]\n // Try enums too.\n \n #[rustc_variance]\n-enum Test8<'a, 'b, 'c:'b> { //~ ERROR [+, -, o]\n+enum Test8<'a, 'b, 'c:'b> { //~ ERROR [-, +, o]\n     Test8A(extern \"Rust\" fn(&'a isize)),\n     Test8B(&'b [isize]),\n     Test8C(&'b mut &'c str),"}, {"sha": "c55730296f1c515ba98f8505150bdac43741898d", "filename": "tests/ui/variance/variance-regions-direct.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fvariance%2Fvariance-regions-direct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fvariance%2Fvariance-regions-direct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvariance%2Fvariance-regions-direct.stderr?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -1,28 +1,28 @@\n-error: [-, -, -]\n+error: [+, +, +]\n   --> $DIR/variance-regions-direct.rs:9:1\n    |\n LL | struct Test2<'a, 'b, 'c> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: [+, +, +]\n+error: [-, -, -]\n   --> $DIR/variance-regions-direct.rs:18:1\n    |\n LL | struct Test3<'a, 'b, 'c> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: [-, o]\n+error: [+, o]\n   --> $DIR/variance-regions-direct.rs:27:1\n    |\n LL | struct Test4<'a, 'b:'a> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: [+, o]\n+error: [-, o]\n   --> $DIR/variance-regions-direct.rs:35:1\n    |\n LL | struct Test5<'a, 'b:'a> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: [-, o]\n+error: [+, o]\n   --> $DIR/variance-regions-direct.rs:45:1\n    |\n LL | struct Test6<'a, 'b:'a> {\n@@ -34,7 +34,7 @@ error: [*]\n LL | struct Test7<'a> {\n    | ^^^^^^^^^^^^^^^^\n \n-error: [+, -, o]\n+error: [-, +, o]\n   --> $DIR/variance-regions-direct.rs:59:1\n    |\n LL | enum Test8<'a, 'b, 'c:'b> {"}, {"sha": "0d00535fef11be78a41d87ed2be7b6c69d1f450a", "filename": "tests/ui/variance/variance-regions-indirect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fvariance%2Fvariance-regions-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fvariance%2Fvariance-regions-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvariance%2Fvariance-regions-indirect.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -5,14 +5,14 @@\n #![feature(rustc_attrs)]\n \n #[rustc_variance]\n-enum Base<'a, 'b, 'c:'b, 'd> { //~ ERROR [+, -, o, *]\n+enum Base<'a, 'b, 'c:'b, 'd> { //~ ERROR [-, +, o, *]\n     Test8A(extern \"Rust\" fn(&'a isize)),\n     Test8B(&'b [isize]),\n     Test8C(&'b mut &'c str),\n }\n \n #[rustc_variance]\n-struct Derived1<'w, 'x:'y, 'y, 'z> { //~ ERROR [*, o, -, +]\n+struct Derived1<'w, 'x:'y, 'y, 'z> { //~ ERROR [*, o, +, -]\n     f: Base<'z, 'y, 'x, 'w>\n }\n \n@@ -22,12 +22,12 @@ struct Derived2<'a, 'b:'a, 'c> { //~ ERROR [o, o, *]\n }\n \n #[rustc_variance] // Combine + and o to yield o (just pay attention to 'a here)\n-struct Derived3<'a:'b, 'b, 'c> { //~ ERROR [o, -, *]\n+struct Derived3<'a:'b, 'b, 'c> { //~ ERROR [o, +, *]\n     f: Base<'a, 'b, 'a, 'c>\n }\n \n #[rustc_variance] // Combine + and * to yield + (just pay attention to 'a here)\n-struct Derived4<'a, 'b, 'c:'b> { //~ ERROR [+, -, o]\n+struct Derived4<'a, 'b, 'c:'b> { //~ ERROR [-, +, o]\n     f: Base<'a, 'b, 'c, 'a>\n }\n "}, {"sha": "edf2626d5984fffda8ea53dce6a032b03cc5612c", "filename": "tests/ui/variance/variance-regions-indirect.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fvariance%2Fvariance-regions-indirect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fvariance%2Fvariance-regions-indirect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvariance%2Fvariance-regions-indirect.stderr?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -1,10 +1,10 @@\n-error: [+, -, o, *]\n+error: [-, +, o, *]\n   --> $DIR/variance-regions-indirect.rs:8:1\n    |\n LL | enum Base<'a, 'b, 'c:'b, 'd> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: [*, o, -, +]\n+error: [*, o, +, -]\n   --> $DIR/variance-regions-indirect.rs:15:1\n    |\n LL | struct Derived1<'w, 'x:'y, 'y, 'z> {\n@@ -16,13 +16,13 @@ error: [o, o, *]\n LL | struct Derived2<'a, 'b:'a, 'c> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: [o, -, *]\n+error: [o, +, *]\n   --> $DIR/variance-regions-indirect.rs:25:1\n    |\n LL | struct Derived3<'a:'b, 'b, 'c> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: [+, -, o]\n+error: [-, +, o]\n   --> $DIR/variance-regions-indirect.rs:30:1\n    |\n LL | struct Derived4<'a, 'b, 'c:'b> {"}, {"sha": "11303c465200574d018358e4479af4aeccc4aa1e", "filename": "tests/ui/variance/variance-trait-object-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fvariance%2Fvariance-trait-object-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fvariance%2Fvariance-trait-object-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvariance%2Fvariance-trait-object-bound.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -11,7 +11,7 @@ use std::mem;\n trait T { fn foo(&self); }\n \n #[rustc_variance]\n-struct TOption<'a> { //~ ERROR [-]\n+struct TOption<'a> { //~ ERROR [+]\n     v: Option<Box<dyn T + 'a>>,\n }\n "}, {"sha": "bfcc8d4a1d11b058df1fd2bcc666016b332d1e31", "filename": "tests/ui/variance/variance-trait-object-bound.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fvariance%2Fvariance-trait-object-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fvariance%2Fvariance-trait-object-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvariance%2Fvariance-trait-object-bound.stderr?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -1,4 +1,4 @@\n-error: [-]\n+error: [+]\n   --> $DIR/variance-trait-object-bound.rs:14:1\n    |\n LL | struct TOption<'a> {"}, {"sha": "cfc03b754734d156bca8d87e8dcd94cf0b75ff81", "filename": "tests/ui/variance/variance-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fvariance%2Fvariance-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fvariance%2Fvariance-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvariance%2Fvariance-types.rs?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -7,7 +7,7 @@ use std::cell::Cell;\n // not considered bivariant.\n \n #[rustc_variance]\n-struct InvariantMut<'a,A:'a,B:'a> { //~ ERROR [-, o, o]\n+struct InvariantMut<'a,A:'a,B:'a> { //~ ERROR [+, o, o]\n     t: &'a mut (A,B)\n }\n "}, {"sha": "0fda4b8036e721ac941487f3ad2b29a3f5bde26b", "filename": "tests/ui/variance/variance-types.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fvariance%2Fvariance-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/226b2496fc3ef997fa1cccf84259539203f82375/tests%2Fui%2Fvariance%2Fvariance-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvariance%2Fvariance-types.stderr?ref=226b2496fc3ef997fa1cccf84259539203f82375", "patch": "@@ -1,4 +1,4 @@\n-error: [-, o, o]\n+error: [+, o, o]\n   --> $DIR/variance-types.rs:10:1\n    |\n LL | struct InvariantMut<'a,A:'a,B:'a> {"}]}