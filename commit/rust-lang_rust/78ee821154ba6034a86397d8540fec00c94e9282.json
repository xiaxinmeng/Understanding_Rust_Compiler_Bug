{"sha": "78ee821154ba6034a86397d8540fec00c94e9282", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4ZWU4MjExNTRiYTYwMzRhODYzOTdkODU0MGZlYzAwYzk0ZTkyODI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-28T20:34:30Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-30T02:10:11Z"}, "message": "Implement trait inheritance for bounded type parameters", "tree": {"sha": "7e029752af04975fd78b6218c8a0d44010b51a42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e029752af04975fd78b6218c8a0d44010b51a42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78ee821154ba6034a86397d8540fec00c94e9282", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78ee821154ba6034a86397d8540fec00c94e9282", "html_url": "https://github.com/rust-lang/rust/commit/78ee821154ba6034a86397d8540fec00c94e9282", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78ee821154ba6034a86397d8540fec00c94e9282/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "daa89e086156099e3aa95577ec97f761e056e65e", "url": "https://api.github.com/repos/rust-lang/rust/commits/daa89e086156099e3aa95577ec97f761e056e65e", "html_url": "https://github.com/rust-lang/rust/commit/daa89e086156099e3aa95577ec97f761e056e65e"}], "stats": {"total": 1174, "additions": 1001, "deletions": 173}, "files": [{"sha": "5f0f3bc9593d1dd28e2e0af28cd7987f636e8e69", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -1330,16 +1330,12 @@ fn find_vtable(tcx: ty::ctxt, ps: &param_substs,\n     debug!(\"find_vtable_in_fn_ctxt(n_param=%u, n_bound=%u, ps=%?)\",\n            n_param, n_bound, param_substs_to_str(tcx, ps));\n \n-    let mut vtable_off = n_bound, i = 0u;\n     // Vtables are stored in a flat array, finding the right one is\n     // somewhat awkward\n-    for vec::each(*ps.bounds) |bounds| {\n-        if i >= n_param { break; }\n-        for vec::each(**bounds) |bound| {\n-            match *bound { ty::bound_trait(_) => vtable_off += 1u, _ => () }\n-        }\n-        i += 1u;\n-    }\n+    let first_n_bounds = ps.bounds.view(0, n_param);\n+    let vtables_to_skip =\n+        ty::count_traits_and_supertraits(tcx, first_n_bounds);\n+    let vtable_off = vtables_to_skip + n_bound;\n     ps.vtables.get()[vtable_off]\n }\n "}, {"sha": "ba6ec2a44c99e4c7dd9892437dc852479fa6c4dd", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -243,17 +243,7 @@ fn trans_static_method_callee(bcx: block,\n     // one we are interested in.\n     let bound_index = {\n         let trait_polyty = ty::lookup_item_type(bcx.tcx(), trait_id);\n-        let mut index = 0;\n-        for trait_polyty.bounds.each |param_bounds| {\n-            for param_bounds.each |param_bound| {\n-                match *param_bound {\n-                    ty::bound_trait(_) => { index += 1; }\n-                    ty::bound_copy | ty::bound_owned |\n-                    ty::bound_send | ty::bound_const => {}\n-                }\n-            }\n-        }\n-        index\n+        ty::count_traits_and_supertraits(bcx.tcx(), *trait_polyty.bounds)\n     };\n \n     let mname = if method_id.crate == ast::local_crate {"}, {"sha": "d52f507e53e9ec6a213828356bac58bee20637ba", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -204,6 +204,8 @@ export DerivedFieldInfo;\n export AutoAdjustment;\n export AutoRef;\n export AutoRefKind, AutoPtr, AutoBorrowVec, AutoBorrowFn;\n+export iter_bound_traits_and_supertraits;\n+export count_traits_and_supertraits;\n \n // Data types\n \n@@ -4530,6 +4532,64 @@ pure fn determine_inherited_purity(parent_purity: ast::purity,\n     }\n }\n \n+// Iterate over a type parameter's bounded traits and any supertraits\n+// of those traits, ignoring kinds.\n+fn iter_bound_traits_and_supertraits(tcx: ctxt,\n+                                     bounds: param_bounds,\n+                                     f: &fn(t) -> bool) {\n+    for bounds.each |bound| {\n+\n+        let bound_trait_ty = match *bound {\n+            ty::bound_trait(bound_t) => bound_t,\n+\n+            ty::bound_copy | ty::bound_send |\n+            ty::bound_const | ty::bound_owned => {\n+                loop; // skip non-trait bounds\n+            }\n+        };\n+\n+        let mut worklist = ~[];\n+\n+        let init_trait_ty = bound_trait_ty;\n+\n+        worklist.push(init_trait_ty);\n+\n+        let mut i = 0;\n+        while i < worklist.len() {\n+            let init_trait_ty = worklist[i];\n+            i += 1;\n+\n+            let init_trait_id = match ty_to_def_id(init_trait_ty) {\n+                Some(id) => id,\n+                None => tcx.sess.bug(\n+                    ~\"trait type should have def_id\")\n+            };\n+\n+            // Add supertraits to worklist\n+            let supertraits = trait_supertraits(tcx,\n+                                                init_trait_id);\n+            for supertraits.each |supertrait| {\n+                worklist.push(supertrait.tpt.ty);\n+            }\n+\n+            if !f(init_trait_ty) {\n+                return;\n+            }\n+        }\n+    }\n+}\n+\n+fn count_traits_and_supertraits(tcx: ctxt,\n+                                boundses: &[param_bounds]) -> uint {\n+    let mut total = 0;\n+    for boundses.each |bounds| {\n+        for iter_bound_traits_and_supertraits(tcx, *bounds) |_trait_ty| {\n+            total += 1;\n+        }\n+    }\n+    return total;\n+}\n+\n impl mt : cmp::Eq {\n     pure fn eq(&self, other: &mt) -> bool {\n         (*self).ty == (*other).ty && (*self).mutbl == (*other).mutbl"}, {"sha": "b4f5441c981a79509ca9f14fad5914441a1740fb", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 99, "deletions": 36, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -241,7 +241,7 @@ impl LookupContext {\n         loop {\n             match get(self_ty).sty {\n                 ty_param(p) => {\n-                    self.push_inherent_candidates_from_param(p);\n+                    self.push_inherent_candidates_from_param(self_ty, p);\n                 }\n                 ty_trait(did, ref substs, vstore) => {\n                     self.push_inherent_candidates_from_trait(\n@@ -305,16 +305,18 @@ impl LookupContext {\n         }\n     }\n \n-    fn push_inherent_candidates_from_param(&self, param_ty: param_ty) {\n+    fn push_inherent_candidates_from_param(&self, rcvr_ty: ty::t,\n+                                           param_ty: param_ty) {\n         debug!(\"push_inherent_candidates_from_param(param_ty=%?)\",\n                param_ty);\n         let _indenter = indenter();\n \n         let tcx = self.tcx();\n         let mut next_bound_idx = 0; // count only trait bounds\n         let bounds = tcx.ty_param_bounds.get(param_ty.def_id.node);\n+\n         for vec::each(*bounds) |bound| {\n-            let bound_t = match *bound {\n+            let bound_trait_ty = match *bound {\n                 ty::bound_trait(bound_t) => bound_t,\n \n                 ty::bound_copy | ty::bound_send |\n@@ -323,56 +325,64 @@ impl LookupContext {\n                 }\n             };\n \n-            let this_bound_idx = next_bound_idx;\n-            next_bound_idx += 1;\n \n-            let (trait_id, bound_substs) = match ty::get(bound_t).sty {\n-                ty::ty_trait(i, substs, _) => (i, substs),\n+            let bound_substs = match ty::get(bound_trait_ty).sty {\n+                ty::ty_trait(_, substs, _) => substs,\n                 _ => {\n                     self.bug(fmt!(\"add_candidates_from_param: \\\n                                    non-trait bound %s\",\n-                                  self.ty_to_str(bound_t)));\n+                                  self.ty_to_str(bound_trait_ty)));\n                 }\n             };\n \n+\n             // Loop over the trait and all of its supertraits.\n-            let worklist = dvec::DVec();\n-            worklist.push((trait_id, move bound_substs));\n+            let mut worklist = ~[];\n+\n+            let init_trait_ty = bound_trait_ty;\n+            let init_substs = bound_substs;\n+\n+            // Replace any appearance of `self` with the type of the\n+            // generic parameter itself.  Note that this is the only\n+            // case where this replacement is necessary: in all other\n+            // cases, we are either invoking a method directly from an\n+            // impl or class (where the self type is not permitted),\n+            // or from a trait type (in which case methods that refer\n+            // to self are not permitted).\n+            let init_substs = {self_ty: Some(rcvr_ty), ..init_substs};\n+\n+            worklist.push((init_trait_ty, init_substs));\n \n             let mut i = 0;\n             while i < worklist.len() {\n-                let (trait_id, bound_substs) = worklist[i];\n+                let (init_trait_ty, init_substs) = worklist[i];\n                 i += 1;\n \n-                // Replace any appearance of `self` with the type of the\n-                // generic parameter itself.  Note that this is the only\n-                // case where this replacement is necessary: in all other\n-                // cases, we are either invoking a method directly from an\n-                // impl or class (where the self type is not permitted),\n-                // or from a trait type (in which case methods that refer\n-                // to self are not permitted).\n-                let rcvr_ty = ty::mk_param(tcx, param_ty.idx,\n-                                           param_ty.def_id);\n-                let rcvr_substs = {self_ty: Some(rcvr_ty), ..bound_substs};\n+                let init_trait_id = ty::ty_to_def_id(init_trait_ty).get();\n \n                 // Add all the supertraits of this trait to the worklist.\n-                debug!(\"finding supertraits for %d:%d\", trait_id.crate,\n-                       trait_id.node);\n-                let instantiated_trait_refs = ty::trait_supertraits(\n-                    tcx, trait_id);\n-                for instantiated_trait_refs.each |instantiated_trait_ref| {\n-                    debug!(\"adding supertrait\");\n+                let supertraits = ty::trait_supertraits(tcx,\n+                                                        init_trait_id);\n+                for supertraits.each |supertrait| {\n+                    debug!(\"adding supertrait: %?\",\n+                           supertrait.def_id);\n \n                     let new_substs = ty::subst_substs(\n                         tcx,\n-                        &instantiated_trait_ref.tpt.substs,\n-                        &rcvr_substs);\n+                        &supertrait.tpt.substs,\n+                        &init_substs);\n+\n+                    // Again replacing the self type\n+                    let new_substs = {self_ty: Some(rcvr_ty), ..new_substs};\n \n-                    worklist.push(\n-                        (instantiated_trait_ref.def_id, new_substs));\n+                    worklist.push((supertrait.tpt.ty, new_substs));\n                 }\n \n-                let trait_methods = ty::trait_methods(tcx, trait_id);\n+\n+                let this_bound_idx = next_bound_idx;\n+                next_bound_idx += 1;\n+\n+                let trait_methods = ty::trait_methods(tcx, init_trait_id);\n                 let pos = {\n                     // FIXME #3453 can't use trait_methods.position\n                     match vec::position(*trait_methods,\n@@ -381,6 +391,8 @@ impl LookupContext {\n                     {\n                         Some(pos) => pos,\n                         None => {\n+                            debug!(\"trait doesn't contain method: %?\",\n+                                   init_trait_id);\n                             loop; // check next trait or bound\n                         }\n                     }\n@@ -389,18 +401,21 @@ impl LookupContext {\n \n                 let (rcvr_ty, rcvr_substs) =\n                     self.create_rcvr_ty_and_substs_for_method(\n-                        method.self_ty, rcvr_ty, move rcvr_substs);\n+                        method.self_ty, rcvr_ty, move init_substs);\n \n-                self.inherent_candidates.push(Candidate {\n+                let cand = Candidate {\n                     rcvr_ty: rcvr_ty,\n                     rcvr_substs: rcvr_substs,\n                     num_method_tps: method.tps.len(),\n                     self_mode: get_mode_from_self_type(method.self_ty),\n-                    origin: method_param({trait_id:trait_id,\n+                    origin: method_param({trait_id:init_trait_id,\n                                           method_num:pos,\n                                           param_num:param_ty.idx,\n                                           bound_num:this_bound_idx})\n-                });\n+                };\n+\n+                debug!(\"pushing inherent candidate for param: %?\", cand);\n+                self.inherent_candidates.push(cand);\n             }\n         }\n     }\n@@ -775,6 +790,8 @@ impl LookupContext {\n         let relevant_candidates =\n             candidates.filter_to_vec(|c| self.is_relevant(self_ty, &c));\n \n+        let relevant_candidates = self.merge_candidates(relevant_candidates);\n+\n         if relevant_candidates.len() == 0 {\n             return None;\n         }\n@@ -791,6 +808,52 @@ impl LookupContext {\n         Some(self.confirm_candidate(self_ty, &relevant_candidates[0]))\n     }\n \n+    fn merge_candidates(&self, candidates: &[Candidate]) -> ~[Candidate] {\n+        let mut merged = ~[];\n+        let mut i = 0;\n+        while i < candidates.len() {\n+            let candidate_a = candidates[i];\n+\n+            let mut skip = false;\n+\n+            let mut j = i + 1;\n+            while j < candidates.len() {\n+                let candidate_b = candidates[j];\n+                debug!(\"attempting to merge %? and %?\",\n+                       candidate_a, candidate_b);\n+                let candidates_same = match (&candidate_a.origin,\n+                                             &candidate_b.origin) {\n+                    (&method_param(p1), &method_param(p2)) => {\n+                        let same_trait = p1.trait_id == p2.trait_id;\n+                        let same_method = p1.method_num == p2.method_num;\n+                        let same_param = p1.param_num == p2.param_num;\n+                        // The bound number may be different because\n+                        // multiple bounds may lead to the same trait\n+                        // impl\n+                        same_trait && same_method && same_param\n+                    }\n+                    _ => false\n+                };\n+                if candidates_same {\n+                    skip = true;\n+                    break;\n+                }\n+                j += 1;\n+            }\n+\n+            i += 1;\n+\n+            if skip {\n+                // There are more than one of these and we need only one\n+                loop;\n+            } else {\n+                merged.push(candidate_a);\n+            }\n+        }\n+\n+        return merged;\n+    }\n+\n     fn confirm_candidate(&self,\n                          self_ty: ty::t,\n                          candidate: &Candidate)"}, {"sha": "99999ca2ae10df3c3b64eaec6d07f4177d94a7bf", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 85, "deletions": 82, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -67,28 +67,43 @@ fn lookup_vtables(vcx: &VtableContext,\n     let tcx = vcx.tcx();\n     let mut result = ~[], i = 0u;\n     for substs.tps.each |ty| {\n-        for vec::each(*bounds[i]) |bound| {\n-            match *bound {\n-              ty::bound_trait(i_ty) => {\n-                let i_ty = ty::subst(tcx, substs, i_ty);\n-                match lookup_vtable_covariant(vcx, location_info, *ty, i_ty,\n-                                              allow_unsafe, is_early) {\n-                    Some(vtable) => result.push(vtable),\n-                    None => {\n-                        vcx.tcx().sess.span_fatal(\n-                            location_info.span,\n-                            fmt!(\"failed to find an implementation of trait \\\n-                                  %s for %s\",\n-                                 ty_to_str(vcx.tcx(), i_ty),\n-                                 ty_to_str(vcx.tcx(), *ty)));\n-                    }\n+        for ty::iter_bound_traits_and_supertraits(\n+            tcx, bounds[i]) |trait_ty| {\n+\n+            debug!(\"about to subst: %?, %?\",\n+                   ty_to_str(tcx, trait_ty),\n+                   ty::substs_to_str(tcx, substs));\n+\n+            let new_substs = {self_ty: Some(*ty), ..*substs};\n+            let trait_ty = ty::subst(tcx, &new_substs, trait_ty);\n+\n+            debug!(\"after subst: %?\",\n+                   ty_to_str(tcx, trait_ty));\n+\n+            match lookup_vtable(vcx, location_info, *ty, trait_ty,\n+                                allow_unsafe, is_early) {\n+                Some(vtable) => result.push(vtable),\n+                None => {\n+                    vcx.tcx().sess.span_fatal(\n+                        location_info.span,\n+                        fmt!(\"failed to find an implementation of \\\n+                              trait %s for %s\",\n+                             ty_to_str(vcx.tcx(), trait_ty),\n+                             ty_to_str(vcx.tcx(), *ty)));\n                 }\n-              }\n-              _ => ()\n             }\n         }\n         i += 1u;\n     }\n+    debug!(\"lookup_vtables result(\\\n+            location_info=%?,\n+            # bounds=%?, \\\n+            substs=%s, \\\n+            result=%?\",\n+           location_info,\n+           bounds.len(),\n+           ty::substs_to_str(vcx.tcx(), substs),\n+           result);\n     @result\n }\n \n@@ -112,40 +127,23 @@ fn relate_trait_tys(vcx: &VtableContext, location_info: &LocationInfo,\n }\n \n // Look up the vtable to use when treating an item of type `t` as if it has\n-// type `trait_ty`. This does allow subtraits.\n-fn lookup_vtable_covariant(vcx: &VtableContext,\n-                           location_info: &LocationInfo,\n-                           ty: ty::t,\n-                           trait_ty: ty::t,\n-                           allow_unsafe: bool,\n-                           is_early: bool)\n-                        -> Option<vtable_origin> {\n-    debug!(\"lookup_vtable_covariant(ty: %s, trait_ty=%s)\",\n-           vcx.infcx.ty_to_str(ty),\n-           vcx.infcx.ty_to_str(trait_ty));\n-\n-    lookup_vtable_invariant(vcx, location_info, ty, trait_ty,\n-                            allow_unsafe, is_early)\n-}\n-\n-// Look up the vtable to use when treating an item of type `t` as if it has\n-// type `trait_ty`. This does not allow subtraits.\n-fn lookup_vtable_invariant(vcx: &VtableContext,\n-                           location_info: &LocationInfo,\n-                           ty: ty::t,\n-                           trait_ty: ty::t,\n-                           allow_unsafe: bool,\n-                           is_early: bool)\n-                        -> Option<vtable_origin> {\n-    debug!(\"lookup_vtable_invariant(ty=%s, trait_ty=%s)\",\n+// type `trait_ty`\n+fn lookup_vtable(vcx: &VtableContext,\n+                 location_info: &LocationInfo,\n+                 ty: ty::t,\n+                 trait_ty: ty::t,\n+                 allow_unsafe: bool,\n+                 is_early: bool)\n+    -> Option<vtable_origin> {\n+    debug!(\"lookup_vtable(ty=%s, trait_ty=%s)\",\n            vcx.infcx.ty_to_str(ty), vcx.infcx.ty_to_str(trait_ty));\n     let _i = indenter();\n \n     let tcx = vcx.tcx();\n     let (trait_id, trait_substs, trait_vstore) = match ty::get(trait_ty).sty {\n         ty::ty_trait(did, substs, vstore) => (did, substs, vstore),\n         _ => tcx.sess.impossible_case(location_info.span,\n-                                      \"lookup_vtable_invariant: \\\n+                                      \"lookup_vtable: \\\n                                        don't know how to handle a non-trait\")\n     };\n     let ty = match fixup_ty(vcx, location_info, ty, is_early) {\n@@ -163,32 +161,35 @@ fn lookup_vtable_invariant(vcx: &VtableContext,\n     match ty::get(ty).sty {\n         ty::ty_param({idx: n, def_id: did}) => {\n             let mut n_bound = 0;\n-            for vec::each(*tcx.ty_param_bounds.get(did.node)) |bound| {\n-                match *bound {\n-                    ty::bound_send | ty::bound_copy | ty::bound_const |\n-                    ty::bound_owned => {\n-                        /* ignore */\n-                    }\n-                    ty::bound_trait(ity) => {\n-                        match ty::get(ity).sty {\n-                            ty::ty_trait(idid, _, _) => {\n-                                if trait_id == idid {\n-                                    debug!(\"(checking vtable) @0 relating \\\n-                                            ty to trait ty with did %?\",\n-                                           idid);\n-                                    relate_trait_tys(vcx, location_info,\n-                                                     trait_ty, ity);\n-                                    return Some(vtable_param(n, n_bound));\n-                                }\n-                            }\n-                            _ => tcx.sess.impossible_case(\n-                                location_info.span,\n-                                \"lookup_vtable_invariant: in loop, \\\n-                                 don't know how to handle a non-trait ity\")\n+            let bounds = tcx.ty_param_bounds.get(did.node);\n+            for ty::iter_bound_traits_and_supertraits(\n+                tcx, bounds) |ity| {\n+                debug!(\"checking bounds trait %?\",\n+                       vcx.infcx.ty_to_str(ity));\n+\n+                match ty::get(ity).sty {\n+                    ty::ty_trait(idid, _, _) => {\n+                        if trait_id == idid {\n+                            debug!(\"(checking vtable) @0 \\\n+                                    relating ty to trait \\\n+                                    ty with did %?\",\n+                                   idid);\n+                            relate_trait_tys(vcx, location_info,\n+                                             trait_ty, ity);\n+                            let vtable = vtable_param(n, n_bound);\n+                            debug!(\"found param vtable: %?\",\n+                                   vtable);\n+                            return Some(vtable);\n                         }\n-                        n_bound += 1u;\n                     }\n+                    _ => tcx.sess.impossible_case(\n+                        location_info.span,\n+                        \"lookup_vtable: in loop, \\\n+                         don't know how to handle a \\\n+                         non-trait ity\")\n                 }\n+\n+                n_bound += 1;\n             }\n         }\n \n@@ -283,8 +284,6 @@ fn lookup_vtable_invariant(vcx: &VtableContext,\n                             // impl.\n                             let {substs: substs, ty: for_ty} =\n                                 impl_self_ty(vcx, location_info, im.did);\n-                            let im_bs = ty::lookup_item_type(tcx,\n-                                                             im.did).bounds;\n                             match infer::mk_subty(vcx.infcx,\n                                                   false,\n                                                   location_info.span,\n@@ -369,6 +368,8 @@ fn lookup_vtable_invariant(vcx: &VtableContext,\n                             // to. connect_trait_tps requires these\n                             // lists of types to unify pairwise.\n \n+                            let im_bs = ty::lookup_item_type(tcx,\n+                                                             im.did).bounds;\n                             connect_trait_tps(vcx,\n                                               location_info,\n                                               substs_f.tps,\n@@ -493,8 +494,9 @@ fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n           Some(ref substs) => {\n               let def = cx.tcx.def_map.get(ex.id);\n             let did = ast_util::def_id_of_def(def);\n-            debug!(\"early resolve expr: def %?\", def);\n             let item_ty = ty::lookup_item_type(cx.tcx, did);\n+            debug!(\"early resolve expr: def %? %?, %?, %?\", ex.id, did, def,\n+                   fcx.infcx().ty_to_str(item_ty.ty));\n             if has_trait_bounds(*item_ty.bounds) {\n                 for item_ty.bounds.each |bounds| {\n                     debug!(\"early_resolve_expr: looking up vtables for bound \\\n@@ -527,6 +529,7 @@ fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n                   ast::expr_field(_, _, _) => ex.id,\n                   _ => ex.callee_id\n                 };\n+\n                 let substs = fcx.node_ty_substs(callee_id);\n                 let vcx = VtableContext { ccx: fcx.ccx, infcx: fcx.infcx() };\n                 let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),\n@@ -551,12 +554,12 @@ fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n             let ty = fcx.expr_ty(src);\n             let vcx = VtableContext { ccx: fcx.ccx, infcx: fcx.infcx() };\n             let vtable_opt =\n-                lookup_vtable_invariant(&vcx,\n-                                        &location_info_for_expr(ex),\n-                                        ty,\n-                                        target_ty,\n-                                        true,\n-                                        is_early);\n+                lookup_vtable(&vcx,\n+                              &location_info_for_expr(ex),\n+                              ty,\n+                              target_ty,\n+                              true,\n+                              is_early);\n             match vtable_opt {\n                 None => {\n                     // Try the new-style boxed trait; \"@int as @Trait\".\n@@ -577,12 +580,12 @@ fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n                                     let location_info =\n                                         &location_info_for_expr(ex);\n                                     let vtable_opt =\n-                                        lookup_vtable_invariant(&vcx,\n-                                                                location_info,\n-                                                                mt.ty,\n-                                                                target_ty,\n-                                                                true,\n-                                                                is_early);\n+                                        lookup_vtable(&vcx,\n+                                                      location_info,\n+                                                      mt.ty,\n+                                                      target_ty,\n+                                                      true,\n+                                                      is_early);\n                                     match vtable_opt {\n                                         Some(vtable) => {\n                                             // Map this expression to that"}, {"sha": "99f4119b1ccee06e4516d71eac7e3f72c66bdbff", "filename": "src/test/auxiliary/trait_inheritance_auto_xc_2_aux.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_auto_xc_2_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_auto_xc_2_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_auto_xc_2_aux.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,11 @@\n+pub trait Foo { fn f() -> int; }\n+pub trait Bar { fn g() -> int; }\n+pub trait Baz { fn h() -> int; }\n+\n+pub struct A { x: int }\n+\n+impl A : Foo { fn f() -> int { 10 } }\n+impl A : Bar { fn g() -> int { 20 } }\n+impl A : Baz { fn h() -> int { 30 } }\n+\n+"}, {"sha": "8fe7b72f8e7d8e4543e8718684af3210bc6ee0e8", "filename": "src/test/auxiliary/trait_inheritance_auto_xc_aux.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_auto_xc_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_auto_xc_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_auto_xc_aux.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,7 @@\n+trait Foo { fn f() -> int; }\n+trait Bar { fn g() -> int; }\n+trait Baz { fn h() -> int; }\n+\n+trait Quux: Foo, Bar, Baz { }\n+\n+impl<T: Foo Bar Baz> T: Quux { }"}, {"sha": "00029d11bf4cb1b212dfbd46c2bbb33a01993539", "filename": "src/test/auxiliary/trait_inheritance_cross_trait_call_xc_aux.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_cross_trait_call_xc_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_cross_trait_call_xc_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_cross_trait_call_xc_aux.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,12 @@\n+\n+pub trait Foo {\n+    fn f() -> int;\n+}\n+\n+pub struct A {\n+    x: int\n+}\n+\n+impl A : Foo {\n+    fn f() -> int { 10 }\n+}"}, {"sha": "ceeee89de6a565502b9420ef45a34d63599d44e0", "filename": "src/test/auxiliary/trait_inheritance_overloading_xc.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -1,9 +1,31 @@\n-pub trait MyNum : Add<self,self>, Sub<self,self>, Mul<self,self> {\n+use cmp::Eq;\n+\n+pub trait MyNum : Add<self,self>, Sub<self,self>, Mul<self,self>, Eq {\n+}\n+\n+pub struct MyInt {\n+    val: int\n+}\n+\n+pub impl MyInt : Add<MyInt, MyInt> {\n+    pure fn add(other: &MyInt) -> MyInt { mi(self.val + other.val) }\n+}\n+\n+pub impl MyInt : Sub<MyInt, MyInt> {\n+    pure fn sub(&self, other: &MyInt) -> MyInt { mi(self.val - other.val) }\n+}\n+\n+pub impl MyInt : Mul<MyInt, MyInt> {\n+    pure fn mul(&self, other: &MyInt) -> MyInt { mi(self.val * other.val) }\n }\n \n-pub impl int : MyNum {\n-    pure fn add(other: &int) -> int { self + *other }\n-    pure fn sub(&self, other: &int) -> int { *self - *other }\n-    pure fn mul(&self, other: &int) -> int { *self * *other }\n+pub impl MyInt : Eq {\n+    pure fn eq(&self, other: &MyInt) -> bool { self.val == other.val }\n+\n+    pure fn ne(&self, other: &MyInt) -> bool { !self.eq(other) }\n }\n \n+pub impl MyInt : MyNum;\n+\n+pure fn mi(v: int) -> MyInt { MyInt { val: v } }\n+"}, {"sha": "3105f72415af4be734b8839359c147585813d455", "filename": "src/test/compile-fail/trait-inheritance-missing-requirement.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Fcompile-fail%2Ftrait-inheritance-missing-requirement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Fcompile-fail%2Ftrait-inheritance-missing-requirement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-inheritance-missing-requirement.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,23 @@\n+// xfail-test\n+// error-pattern: what\n+\n+trait Foo {\n+    fn f();\n+}\n+\n+trait Bar : Foo {\n+    fn g();\n+}\n+\n+struct A {\n+    x: int\n+}\n+\n+// Can't implement Bar without an impl of Foo\n+impl A : Bar {\n+    fn g() { }\n+}\n+\n+fn main() {\n+}\n+"}, {"sha": "4eac97102506a9a32dd6e531dd3c4b213ef4fc56", "filename": "src/test/run-pass/trait-inheritance-auto-xc-2.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-auto-xc-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-auto-xc-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-auto-xc-2.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,23 @@\n+// xfail-fast\n+// aux-build:trait_inheritance_auto_xc_2_aux.rs\n+\n+extern mod aux(name = \"trait_inheritance_auto_xc_2_aux\");\n+\n+// aux defines impls of Foo, Bar and Baz for A\n+use aux::{Foo, Bar, Baz, A};\n+\n+// We want to extend all Foo, Bar, Bazes to Quuxes\n+pub trait Quux: Foo, Bar, Baz { }\n+impl<T: Foo Bar Baz> T: Quux { }\n+\n+fn f<T: Quux>(a: &T) {\n+    assert a.f() == 10;\n+    assert a.g() == 20;\n+    assert a.h() == 30;\n+}\n+\n+fn main() {\n+    let a = &A { x: 3 };\n+    f(a);\n+}\n+"}, {"sha": "4bc62fab51b5a00e95520b34b6fc14ead7112428", "filename": "src/test/run-pass/trait-inheritance-auto-xc.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-auto-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-auto-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-auto-xc.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,24 @@\n+// xfail-fast\n+// aux-build:trait_inheritance_auto_xc_aux.rs\n+\n+extern mod aux(name = \"trait_inheritance_auto_xc_aux\");\n+\n+use aux::{Foo, Bar, Baz, Quux};\n+\n+struct A { x: int }\n+\n+impl A : Foo { fn f() -> int { 10 } }\n+impl A : Bar { fn g() -> int { 20 } }\n+impl A : Baz { fn h() -> int { 30 } }\n+\n+fn f<T: Quux>(a: &T) {\n+    assert a.f() == 10;\n+    assert a.g() == 20;\n+    assert a.h() == 30;\n+}\n+\n+fn main() {\n+    let a = &A { x: 3 };\n+    f(a);\n+}\n+"}, {"sha": "29de9f111dcbd5874426733d64910f79c8248e33", "filename": "src/test/run-pass/trait-inheritance-auto.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-auto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-auto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-auto.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,27 @@\n+// Testing that this impl turns A into a Quux, because\n+// A is already a Foo Bar Baz\n+impl<T: Foo Bar Baz> T: Quux { }\n+\n+trait Foo { fn f() -> int; }\n+trait Bar { fn g() -> int; }\n+trait Baz { fn h() -> int; }\n+\n+trait Quux: Foo, Bar, Baz { }\n+\n+struct A { x: int }\n+\n+impl A : Foo { fn f() -> int { 10 } }\n+impl A : Bar { fn g() -> int { 20 } }\n+impl A : Baz { fn h() -> int { 30 } }\n+\n+fn f<T: Quux>(a: &T) {\n+    assert a.f() == 10;\n+    assert a.g() == 20;\n+    assert a.h() == 30;\n+}\n+\n+fn main() {\n+    let a = &A { x: 3 };\n+    f(a);\n+}\n+"}, {"sha": "dd3f53cfbdd3573d126db412d1a2d1bfb57b4fd6", "filename": "src/test/run-pass/trait-inheritance-call-bound-inherited.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-call-bound-inherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-call-bound-inherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-call-bound-inherited.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,18 @@\n+trait Foo { fn f() -> int; }\n+trait Bar : Foo { fn g() -> int; }\n+\n+struct A { x: int }\n+\n+impl A : Foo { fn f() -> int { 10 } }\n+impl A : Bar { fn g() -> int { 20 } }\n+\n+// Call a function on Foo, given a T: Bar\n+fn gg<T:Bar>(a: &T) -> int {\n+    a.f()\n+}\n+\n+fn main() {\n+    let a = &A { x: 3 };\n+    assert gg(a) == 10;\n+}\n+"}, {"sha": "222d8e7291d5c39b1fa7653d7b9e118654b47c40", "filename": "src/test/run-pass/trait-inheritance-call-bound-inherited2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-call-bound-inherited2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-call-bound-inherited2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-call-bound-inherited2.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,21 @@\n+trait Foo { fn f() -> int; }\n+trait Bar : Foo { fn g() -> int; }\n+trait Baz : Bar { fn h() -> int; }\n+\n+struct A { x: int }\n+\n+impl A : Foo { fn f() -> int { 10 } }\n+impl A : Bar { fn g() -> int { 20 } }\n+impl A : Baz { fn h() -> int { 30 } }\n+\n+// Call a function on Foo, given a T: Baz,\n+// which is inherited via Bar\n+fn gg<T: Baz>(a: &T) -> int {\n+    a.f()\n+}\n+\n+fn main() {\n+    let a = &A { x: 3 };\n+    assert gg(a) == 10;\n+}\n+"}, {"sha": "6cb0551652061bad4055860d61f9085a0543a38f", "filename": "src/test/run-pass/trait-inheritance-cast-without-call-to-supertrait.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-cast-without-call-to-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-cast-without-call-to-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-cast-without-call-to-supertrait.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,31 @@\n+// Testing that we can cast to a subtrait and call subtrait\n+// methods. Not testing supertrait methods\n+\n+trait Foo {\n+    fn f() -> int;\n+}\n+\n+trait Bar : Foo {\n+    fn g() -> int;\n+}\n+\n+struct A {\n+    x: int\n+}\n+\n+impl A : Foo {\n+    fn f() -> int { 10 }\n+}\n+\n+impl A : Bar {\n+    fn g() -> int { 20 }\n+}\n+\n+fn main() {\n+    let a = &A { x: 3 };\n+    let afoo = a as &Foo;\n+    let abar = a as &Bar;\n+    assert afoo.f() == 10;\n+    assert abar.g() == 20;\n+}\n+"}, {"sha": "1cd23f497339fb3dec0f1177ff0f77702aafb9e3", "filename": "src/test/run-pass/trait-inheritance-cast.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-cast.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,33 @@\n+// xfail-test\n+// Testing that supertrait methods can be called on subtrait object types\n+// It's not clear yet that we want this\n+\n+trait Foo {\n+    fn f() -> int;\n+}\n+\n+trait Bar : Foo {\n+    fn g() -> int;\n+}\n+\n+struct A {\n+    x: int\n+}\n+\n+impl A : Foo {\n+    fn f() -> int { 10 }\n+}\n+\n+impl A : Bar {\n+    fn g() -> int { 20 }\n+}\n+\n+fn main() {\n+    let a = &A { x: 3 };\n+    let afoo = a as &Foo;\n+    let abar = a as &Bar;\n+    assert afoo.f() == 10;\n+    assert abar.g() == 20;\n+    assert abar.f() == 10;\n+}\n+"}, {"sha": "9f588ddb907c7b0d69ae09b58d181fff756f66c4", "filename": "src/test/run-pass/trait-inheritance-cross-trait-call-xc.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-cross-trait-call-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-cross-trait-call-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-cross-trait-call-xc.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,18 @@\n+// xfail-fast\n+// aux-build:trait_inheritance_cross_trait_call_xc_aux.rs\n+\n+extern mod aux(name = \"trait_inheritance_cross_trait_call_xc_aux\");\n+\n+trait Bar : aux::Foo {\n+    fn g() -> int;\n+}\n+\n+impl aux::A : Bar {\n+    fn g() -> int { self.f() }\n+}\n+\n+fn main() {\n+    let a = &aux::A { x: 3 };\n+    assert a.g() == 10;\n+}\n+"}, {"sha": "a96bfb41f4465939ae9155cf65482e68c014f791", "filename": "src/test/run-pass/trait-inheritance-cross-trait-call.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-cross-trait-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-cross-trait-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-cross-trait-call.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,17 @@\n+trait Foo { fn f() -> int; }\n+trait Bar : Foo { fn g() -> int; }\n+\n+struct A { x: int }\n+\n+impl A : Foo { fn f() -> int { 10 } }\n+\n+impl A : Bar {\n+    // Testing that this impl can call the impl of Foo\n+    fn g() -> int { self.f() }\n+}\n+\n+fn main() {\n+    let a = &A { x: 3 };\n+    assert a.g() == 10;\n+}\n+"}, {"sha": "4c18d92a8c0d83375e5a844b1bb5390ae99cd698", "filename": "src/test/run-pass/trait-inheritance-diamond.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-diamond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-diamond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-diamond.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,25 @@\n+// B and C both require A, so D does as well, twice, but that's just fine\n+\n+trait A { fn a(&self) -> int; }\n+trait B: A { fn b(&self) -> int; }\n+trait C: A { fn c(&self) -> int; }\n+trait D: B, C { fn d(&self) -> int; }\n+\n+struct S { bogus: () }\n+\n+impl S: A { fn a(&self) -> int { 10 } }\n+impl S: B { fn b(&self) -> int { 20 } }\n+impl S: C { fn c(&self) -> int { 30 } }\n+impl S: D { fn d(&self) -> int { 40 } }\n+\n+fn f<T: D>(x: &T) {\n+    assert x.a() == 10;\n+    assert x.b() == 20;\n+    assert x.c() == 30;\n+    assert x.d() == 40;\n+}\n+\n+fn main() {\n+    let value = &S { bogus: () };\n+    f(value);\n+}\n\\ No newline at end of file"}, {"sha": "fdc68a31997f9c08a9fd8e38d40a7750bc784a2f", "filename": "src/test/run-pass/trait-inheritance-multiple-inheritors.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-multiple-inheritors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-multiple-inheritors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-multiple-inheritors.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,20 @@\n+trait A { fn a(&self) -> int; }\n+trait B: A { fn b(&self) -> int; }\n+trait C: A { fn c(&self) -> int; }\n+\n+struct S { bogus: () }\n+\n+impl S: A { fn a(&self) -> int { 10 } }\n+impl S: B { fn b(&self) -> int { 20 } }\n+impl S: C { fn c(&self) -> int { 30 } }\n+\n+// Both B and C inherit from A\n+fn f<T: B C>(x: &T) {\n+    assert x.a() == 10;\n+    assert x.b() == 20;\n+    assert x.c() == 30;\n+}\n+\n+fn main() {\n+    f(&S { bogus: () })\n+}\n\\ No newline at end of file"}, {"sha": "0a5330b68f8ba617915fe908c61ccec0e919d693", "filename": "src/test/run-pass/trait-inheritance-multiple-params.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-multiple-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-multiple-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-multiple-params.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,23 @@\n+trait A { fn a(&self) -> int; }\n+trait B: A { fn b(&self) -> int; }\n+trait C: A { fn c(&self) -> int; }\n+\n+struct S { bogus: () }\n+\n+impl S: A { fn a(&self) -> int { 10 } }\n+impl S: B { fn b(&self) -> int { 20 } }\n+impl S: C { fn c(&self) -> int { 30 } }\n+\n+// Multiple type params, multiple levels of inheritance\n+fn f<X: A, Y: B, Z: C>(x: &X, y: &Y, z: &Z) {\n+    assert x.a() == 10;\n+    assert y.a() == 10;\n+    assert y.b() == 20;\n+    assert z.a() == 10;\n+    assert z.c() == 30;\n+}\n+\n+fn main() {\n+    let s = &S { bogus: () };\n+    f(s, s, s);\n+}\n\\ No newline at end of file"}, {"sha": "2266b67c23439ddd48f80a19b8974031b251bee5", "filename": "src/test/run-pass/trait-inheritance-num.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,14 @@\n+use cmp::{Eq, Ord};\n+use num::from_int;\n+\n+extern mod std;\n+use std::cmp::FuzzyEq;\n+\n+pub trait NumExt: Num, Eq, Ord {}\n+\n+pub trait FloatExt: NumExt, FuzzyEq {}\n+\n+fn greater_than_one<T:NumExt>(n: &T) -> bool { *n > from_int(1) }\n+fn greater_than_one_float<T:FloatExt>(n: &T) -> bool { *n > from_int(1) }\n+\n+fn main() {}"}, {"sha": "6c3b22894f56a9adbe58cb27e14aa81092c2e127", "filename": "src/test/run-pass/trait-inheritance-num0.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num0.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,16 @@\n+// Extending Num and using inherited static methods\n+\n+use num::from_int;\n+\n+trait Num {\n+    static fn from_int(i: int) -> self;\n+    fn gt(&self, other: &self) -> bool;\n+}\n+\n+pub trait NumExt: Num { }\n+\n+fn greater_than_one<T:NumExt>(n: &T) -> bool {\n+    n.gt(&from_int(1))\n+}\n+\n+fn main() {}"}, {"sha": "57487f072f38994f5401333acc91f84ebe5c91e1", "filename": "src/test/run-pass/trait-inheritance-num1.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num1.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,12 @@\n+// Using the real Num from core\n+\n+use cmp::Ord;\n+use num::from_int;\n+\n+pub trait NumExt: Num, Ord { }\n+\n+fn greater_than_one<T:NumExt>(n: &T) -> bool {\n+    *n > from_int(1)\n+}\n+\n+fn main() {}"}, {"sha": "5f51f943817d27394906d1f64fd0e004c5b0b82d", "filename": "src/test/run-pass/trait-inheritance-num2.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num2.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,96 @@\n+// A more complex example of numeric extensions\n+\n+use cmp::{Eq, Ord};\n+use num::from_int;\n+\n+extern mod std;\n+use std::cmp::FuzzyEq;\n+\n+pub trait TypeExt {}\n+\n+\n+pub impl u8: TypeExt {}\n+pub impl u16: TypeExt {}\n+pub impl u32: TypeExt {}\n+pub impl u64: TypeExt {}\n+pub impl uint: TypeExt {}\n+\n+pub impl i8: TypeExt {}\n+pub impl i16: TypeExt {}\n+pub impl i32: TypeExt {}\n+pub impl i64: TypeExt {}\n+pub impl int: TypeExt {}\n+\n+pub impl f32: TypeExt {}\n+pub impl f64: TypeExt {}\n+pub impl float: TypeExt {}\n+\n+\n+pub trait NumExt: TypeExt, Eq, Ord, Num {}\n+\n+pub impl u8: NumExt {}\n+pub impl u16: NumExt {}\n+pub impl u32: NumExt {}\n+pub impl u64: NumExt {}\n+pub impl uint: NumExt {}\n+\n+pub impl i8: NumExt {}\n+pub impl i16: NumExt {}\n+pub impl i32: NumExt {}\n+pub impl i64: NumExt {}\n+pub impl int: NumExt {}\n+\n+pub impl f32: NumExt {}\n+pub impl f64: NumExt {}\n+pub impl float: NumExt {}\n+\n+\n+pub trait UnSignedExt: NumExt {}\n+\n+pub impl u8: UnSignedExt {}\n+pub impl u16: UnSignedExt {}\n+pub impl u32: UnSignedExt {}\n+pub impl u64: UnSignedExt {}\n+pub impl uint: UnSignedExt {}\n+\n+\n+pub trait SignedExt: NumExt {}\n+\n+pub impl i8: SignedExt {}\n+pub impl i16: SignedExt {}\n+pub impl i32: SignedExt {}\n+pub impl i64: SignedExt {}\n+pub impl int: SignedExt {}\n+\n+pub impl f32: SignedExt {}\n+pub impl f64: SignedExt {}\n+pub impl float: SignedExt {}\n+\n+\n+pub trait IntegerExt: NumExt {}\n+\n+pub impl u8: IntegerExt {}\n+pub impl u16: IntegerExt {}\n+pub impl u32: IntegerExt {}\n+pub impl u64: IntegerExt {}\n+pub impl uint: IntegerExt {}\n+\n+pub impl i8: IntegerExt {}\n+pub impl i16: IntegerExt {}\n+pub impl i32: IntegerExt {}\n+pub impl i64: IntegerExt {}\n+pub impl int: IntegerExt {}\n+\n+\n+pub trait FloatExt: NumExt , FuzzyEq {}\n+\n+pub impl f32: FloatExt {}\n+pub impl f64: FloatExt {}\n+pub impl float: FloatExt {}\n+\n+\n+fn test_float_ext<T:FloatExt>(n: T) { io::println(fmt!(\"%?\", n < n)) }\n+\n+fn main() {\n+    test_float_ext(1f32);\n+}\n\\ No newline at end of file"}, {"sha": "656e63906621c0ba4a89ee4c6877123e0aa300b4", "filename": "src/test/run-pass/trait-inheritance-num3.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,12 @@\n+use cmp::{Eq, Ord};\n+use num::from_int;\n+\n+pub trait NumExt: Eq, Ord, Num {}\n+\n+pub impl f32: NumExt {}\n+\n+fn num_eq_one<T:NumExt>(n: T) { io::println(fmt!(\"%?\", n == from_int(1))) }\n+\n+fn main() {\n+    num_eq_one(1f32); // you need to actually use the function to trigger the ICE\n+}\n\\ No newline at end of file"}, {"sha": "fa30ceff8ad01ff451908e65751f5db18bdff86e", "filename": "src/test/run-pass/trait-inheritance-num5.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,15 @@\n+use cmp::{Eq, Ord};\n+use num::from_int;\n+\n+pub trait NumExt: Eq, Num {}\n+\n+pub impl f32: NumExt {}\n+pub impl int: NumExt {}\n+\n+fn num_eq_one<T:NumExt>() -> T {\n+    from_int(1)\n+}\n+\n+fn main() {\n+    num_eq_one::<int>(); // you need to actually use the function to trigger the ICE\n+}"}, {"sha": "13867eed52f1c978df50cd59628c6b0276870152", "filename": "src/test/run-pass/trait-inheritance-overloading-simple.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading-simple.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,25 @@\n+use cmp::Eq;\n+\n+trait MyNum : Eq { }\n+\n+struct MyInt { val: int }\n+\n+impl MyInt : Eq {\n+    pure fn eq(&self, other: &MyInt) -> bool { self.val == other.val }\n+    pure fn ne(&self, other: &MyInt) -> bool { !self.eq(other) }\n+}\n+\n+impl MyInt : MyNum;\n+\n+fn f<T:MyNum>(x: T, y: T) -> bool {\n+    return x == y;\n+}\n+\n+pure fn mi(v: int) -> MyInt { MyInt { val: v } }\n+\n+fn main() {\n+    let (x, y, z) = (mi(3), mi(5), mi(3));\n+    assert x != y;\n+    assert x == z;\n+}\n+"}, {"sha": "585ce63b38997bab4b72270b83c8dc90a036bf77", "filename": "src/test/run-pass/trait-inheritance-overloading-xc-exe.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading-xc-exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading-xc-exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading-xc-exe.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -2,18 +2,19 @@\n // aux-build:trait_inheritance_overloading_xc.rs\n \n extern mod trait_inheritance_overloading_xc;\n-use trait_inheritance_overloading_xc::MyNum;\n+use trait_inheritance_overloading_xc::{MyNum, MyInt};\n \n fn f<T:Copy MyNum>(x: T, y: T) -> (T, T, T) {\n     return (x + y, x - y, x * y);\n }\n \n+pure fn mi(v: int) -> MyInt { MyInt { val: v } }\n+\n fn main() {\n-    let (x, y) = (3, 5);\n+    let (x, y) = (mi(3), mi(5));\n     let (a, b, c) = f(x, y);\n-    assert a == 8;\n-    assert b == -2;\n-    assert c == 15;\n+    assert a == mi(8);\n+    assert b == mi(-2);\n+    assert c == mi(15);\n }\n \n-"}, {"sha": "def37d1f9505c018777175fa837364fef1937751", "filename": "src/test/run-pass/trait-inheritance-overloading.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -1,21 +1,39 @@\n-trait MyNum : Add<self,self>, Sub<self,self>, Mul<self,self> {\n+use cmp::Eq;\n+\n+trait MyNum : Add<self,self>, Sub<self,self>, Mul<self,self>, Eq { }\n+\n+struct MyInt { val: int }\n+\n+impl MyInt : Add<MyInt, MyInt> {\n+    pure fn add(other: &MyInt) -> MyInt { mi(self.val + other.val) }\n+}\n+\n+impl MyInt : Sub<MyInt, MyInt> {\n+    pure fn sub(&self, other: &MyInt) -> MyInt { mi(self.val - other.val) }\n }\n \n-impl int : MyNum {\n-    pure fn add(other: &int) -> int { self + *other }\n-    pure fn sub(&self, other: &int) -> int { *self - *other }\n-    pure fn mul(&self, other: &int) -> int { *self * *other }\n+impl MyInt : Mul<MyInt, MyInt> {\n+    pure fn mul(&self, other: &MyInt) -> MyInt { mi(self.val * other.val) }\n }\n \n+impl MyInt : Eq {\n+    pure fn eq(&self, other: &MyInt) -> bool { self.val == other.val }\n+    pure fn ne(&self, other: &MyInt) -> bool { !self.eq(other) }\n+}\n+\n+impl MyInt : MyNum;\n+\n fn f<T:Copy MyNum>(x: T, y: T) -> (T, T, T) {\n     return (x + y, x - y, x * y);\n }\n \n+pure fn mi(v: int) -> MyInt { MyInt { val: v } }\n+\n fn main() {\n-    let (x, y) = (3, 5);\n+    let (x, y) = (mi(3), mi(5));\n     let (a, b, c) = f(x, y);\n-    assert a == 8;\n-    assert b == -2;\n-    assert c == 15;\n+    assert a == mi(8);\n+    assert b == mi(-2);\n+    assert c == mi(15);\n }\n "}, {"sha": "9725b18ca0f199ca0d7d189dbf0a44340deed915", "filename": "src/test/run-pass/trait-inheritance-simple.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-simple.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -1,26 +1,22 @@\n-trait Foo {\n-    fn f();\n-}\n+trait Foo { fn f() -> int; }\n+trait Bar : Foo { fn g() -> int; }\n \n-trait Bar : Foo {\n-    fn g();\n-}\n+struct A { x: int }\n \n-struct A {\n-    x: int\n-}\n+impl A : Foo { fn f() -> int { 10 } }\n+impl A : Bar { fn g() -> int { 20 } }\n \n-impl A : Bar {\n-    fn g() { io::println(\"in g\"); }\n-    fn f() { io::println(\"in f\"); }\n+fn ff<T:Foo>(a: &T) -> int {\n+    a.f()\n }\n \n-fn h<T:Foo>(a: &T) {\n-    a.f();\n+fn gg<T:Bar>(a: &T) -> int {\n+    a.g()\n }\n \n fn main() {\n-    let a = A { x: 3 };\n-    h(&a);\n+    let a = &A { x: 3 };\n+    assert ff(a) == 10;\n+    assert gg(a) == 20;\n }\n "}, {"sha": "a3788d8647b6474abbf826001fd5909dc66ae721", "filename": "src/test/run-pass/trait-inheritance-static.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-static.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,24 @@\n+trait MyNum {\n+    static fn from_int(int) -> self;\n+}\n+\n+pub trait NumExt: MyNum { }\n+\n+struct S { v: int }\n+\n+impl S: MyNum {\n+    static fn from_int(i: int) -> S {\n+        S {\n+            v: i\n+        }\n+    }\n+}\n+\n+impl S: NumExt { }\n+\n+fn greater_than_one<T:NumExt>() -> T { from_int(1) }\n+\n+fn main() {\n+    let v: S = greater_than_one();\n+    assert v.v == 1;\n+}"}, {"sha": "e6f3f1fb99147211a48cfd76f324be4fc20acea4", "filename": "src/test/run-pass/trait-inheritance-static2.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-static2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-static2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-static2.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,28 @@\n+trait MyEq { }\n+\n+trait MyNum {\n+    static fn from_int(int) -> self;\n+}\n+\n+pub trait NumExt: MyEq, MyNum { }\n+\n+struct S { v: int }\n+\n+impl S: MyEq { }\n+\n+impl S: MyNum {\n+    static fn from_int(i: int) -> S {\n+        S {\n+            v: i\n+        }\n+    }\n+}\n+\n+impl S: NumExt { }\n+\n+fn greater_than_one<T:NumExt>() -> T { from_int(1) }\n+\n+fn main() {\n+    let v: S = greater_than_one();\n+    assert v.v == 1;\n+}"}, {"sha": "3fdf96b404ed798396f12d74617fad5d356e0d63", "filename": "src/test/run-pass/trait-inheritance-subst.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-subst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-subst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-subst.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,26 @@\n+pub trait Add<RHS,Result> {\n+    pure fn add(rhs: &RHS) -> Result;\n+}\n+\n+trait MyNum : Add<self,self> { }\n+\n+struct MyInt { val: int }\n+\n+impl MyInt : Add<MyInt, MyInt> {\n+    pure fn add(other: &MyInt) -> MyInt { mi(self.val + other.val) }\n+}\n+\n+impl MyInt : MyNum;\n+\n+fn f<T:MyNum>(x: T, y: T) -> T {\n+    return x.add(&y);\n+}\n+\n+pure fn mi(v: int) -> MyInt { MyInt { val: v } }\n+\n+fn main() {\n+    let (x, y) = (mi(3), mi(5));\n+    let z = f(x, y);\n+    assert z.val == 8\n+}\n+"}, {"sha": "343c567ab97bc4530f9f7e5c96be16c6c89d4227", "filename": "src/test/run-pass/trait-inheritance-subst2.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-subst2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-subst2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-subst2.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,36 @@\n+trait Panda<T> {\n+    fn chomp(bamboo: &T) -> T;\n+}\n+\n+trait Add<RHS,Result>: Panda<RHS> {\n+    fn add(rhs: &RHS) -> Result;\n+}\n+\n+trait MyNum : Add<self,self> { }\n+\n+struct MyInt { val: int }\n+\n+impl MyInt : Panda<MyInt> {\n+    fn chomp(bamboo: &MyInt) -> MyInt {\n+        mi(self.val + bamboo.val)\n+    }\n+}\n+\n+impl MyInt : Add<MyInt, MyInt> {\n+    fn add(other: &MyInt) -> MyInt { self.chomp(other) }\n+}\n+\n+impl MyInt : MyNum;\n+\n+fn f<T:MyNum>(x: T, y: T) -> T {\n+    return x.add(&y).chomp(&y);\n+}\n+\n+fn mi(v: int) -> MyInt { MyInt { val: v } }\n+\n+fn main() {\n+    let (x, y) = (mi(3), mi(5));\n+    let z = f(x, y);\n+    assert z.val == 13;\n+}\n+"}, {"sha": "1fbe35328b60bcc8e140fb4eed3f4480e8dec2ed", "filename": "src/test/run-pass/trait-inheritance-visibility.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-visibility.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,18 @@\n+mod traits {\n+    pub trait Foo { fn f() -> int; }\n+\n+    impl int: Foo { fn f() -> int { 10 } }\n+}\n+\n+trait Quux: traits::Foo { }\n+impl<T: traits::Foo> T: Quux { }\n+\n+// Foo is not in scope but because Quux is we can still access\n+// Foo's methods on a Quux bound typaram\n+fn f<T: Quux>(x: &T) {\n+    assert x.f() == 10;\n+}\n+\n+fn main() {\n+    f(&0)\n+}\n\\ No newline at end of file"}, {"sha": "7d4c2cacfeaad26fc078960ab71adff327b59c06", "filename": "src/test/run-pass/trait-inheritance2.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ee821154ba6034a86397d8540fec00c94e9282/src%2Ftest%2Frun-pass%2Ftrait-inheritance2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance2.rs?ref=78ee821154ba6034a86397d8540fec00c94e9282", "patch": "@@ -0,0 +1,24 @@\n+trait Foo { fn f() -> int; }\n+trait Bar { fn g() -> int; }\n+trait Baz { fn h() -> int; }\n+\n+trait Quux: Foo, Bar, Baz { }\n+\n+struct A { x: int }\n+\n+impl A : Foo { fn f() -> int { 10 } }\n+impl A : Bar { fn g() -> int { 20 } }\n+impl A : Baz { fn h() -> int { 30 } }\n+impl A : Quux;\n+\n+fn f<T: Quux Foo Bar Baz>(a: &T) {\n+    assert a.f() == 10;\n+    assert a.g() == 20;\n+    assert a.h() == 30;\n+}\n+\n+fn main() {\n+    let a = &A { x: 3 };\n+    f(a);\n+}\n+"}]}