{"sha": "1304e4e40fb6fae370b91e24a3b00942fdec06f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzMDRlNGU0MGZiNmZhZTM3MGI5MWUyNGEzYjAwOTQyZmRlYzA2ZjE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-20T17:14:30Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-20T17:14:30Z"}, "message": "update tutorial to avoid block() syntax and to use term stack closure", "tree": {"sha": "fb980cec03edde6d2bc4d541a42c476ea1c56a79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb980cec03edde6d2bc4d541a42c476ea1c56a79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1304e4e40fb6fae370b91e24a3b00942fdec06f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1304e4e40fb6fae370b91e24a3b00942fdec06f1", "html_url": "https://github.com/rust-lang/rust/commit/1304e4e40fb6fae370b91e24a3b00942fdec06f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1304e4e40fb6fae370b91e24a3b00942fdec06f1/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7811e613d035e6bbe8a7f119b9af03e5370fca1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7811e613d035e6bbe8a7f119b9af03e5370fca1", "html_url": "https://github.com/rust-lang/rust/commit/b7811e613d035e6bbe8a7f119b9af03e5370fca1"}], "stats": {"total": 78, "additions": 41, "deletions": 37}, "files": [{"sha": "8bc2ee1ac0c5adf09351b999f230b43bafacb89d", "filename": "doc/tutorial.md", "status": "modified", "additions": 41, "deletions": 37, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/1304e4e40fb6fae370b91e24a3b00942fdec06f1/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/1304e4e40fb6fae370b91e24a3b00942fdec06f1/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=1304e4e40fb6fae370b91e24a3b00942fdec06f1", "patch": "@@ -381,7 +381,7 @@ more detail later on (the `T`s here stand for any other type):\n `{field1: T1, field2: T2}`\n   : Record type.\n \n-`fn(arg1: T1, arg2: T2) -> T3`, `lambda()`, `block()`\n+`fn(arg1: T1, arg2: T2) -> T3`, `fn@()`, `fn~()`, `fn&()`\n   : Function types.\n \n `@T`, `~T`, `*T`\n@@ -824,32 +824,36 @@ functions that can access variables in the scope in which they are\n created.\n \n There are several forms of closures, each with its own role. The most\n-common type is called a 'block', this is a closure which has full\n-access to its environment.\n+common type is called a 'stack closure'; this is a closure which has\n+full access to its environment.\n \n ~~~~\n-fn call_block_with_ten(b: block(int)) { b(10); }\n+fn call_closure_with_ten(b: fn(int)) { b(10); }\n \n let x = 20;    \n-call_block_with_ten({|arg|\n+call_closure_with_ten({|arg|\n     #info(\"x=%d, arg=%d\", x, arg);\n });\n ~~~~\n \n-This defines a function that accepts a block, and then calls it with a\n-simple block that executes a log statement, accessing both its\n-argument and the variable `x` from its environment.\n+This defines a function that accepts a closure, and then calls it with\n+a simple stack closure that executes a log statement, accessing both\n+its argument and the variable `x` from its environment.\n \n-Blocks can only be used in a restricted way, because it is not allowed\n-to survive the scope in which it was created. They are allowed to\n-appear in function argument position and in call position, but nowhere\n-else.\n+Stack closures are called stack closures because they directly access\n+the stack frame in which they are created.  This makes them very\n+lightweight to construct and lets them modify local variables from the\n+enclosing scope, but it also makes it unsafe for the closure to\n+survive the scope in which it was created.  To prevent them from being\n+used after the creating scope has returned, stack closures can only be\n+used in a restricted way: they are allowed to appear in function\n+argument position and in call position, but nowhere else.\n \n ### Boxed closures\n \n-When you need to store a closure in a data structure, a block will not\n-do, since the compiler will refuse to let you store it. For this\n-purpose, Rust provides a type of closure that has an arbitrary\n+When you need to store a closure in a data structure, a stack closure\n+will not do, since the compiler will refuse to let you store it. For\n+this purpose, Rust provides a type of closure that has an arbitrary\n lifetime, written `fn@` (boxed closure, analogous to the `@` pointer\n type described in the next section).\n \n@@ -879,14 +883,14 @@ fn main() {\n \n A nice property of Rust closures is that you can pass any kind of\n closure (as long as the arguments and return types match) to functions\n-that expect a `block`. Thus, when writing a higher-order function that\n+that expect a `fn()`. Thus, when writing a higher-order function that\n wants to do nothing with its function argument beyond calling it, you\n-should almost always specify the type of that argument as `block`, so\n+should almost always specify the type of that argument as `fn()`, so\n that callers have the flexibility to pass whatever they want.\n \n ~~~~\n-fn call_twice(f: block()) { f(); f(); }\n-call_twice({|| \"I am a block\"; });\n+fn call_twice(f: fn()) { f(); f(); }\n+call_twice({|| \"I am a stack closure; });\n call_twice(fn@() { \"I am a boxed closure\"; });\n fn bare_function() { \"I am a plain function\"; }\n call_twice(bare_function);\n@@ -903,9 +907,9 @@ them. Unique closures mostly exist to for spawning new\n \n ### Shorthand syntax\n \n-The compact syntax used for blocks (`{|arg1, arg2| body}`) can also\n-be used to express boxed and unique closures in situations where the\n-closure style can be unambiguously derived from the context. Most\n+The compact syntax used for stack closures (`{|arg1, arg2| body}`) can\n+also be used to express boxed and unique closures in situations where\n+the closure style can be unambiguously derived from the context. Most\n notably, when calling a higher-order function you do not have to use\n the long-hand syntax for the function you're passing, since the\n compiler can look at the argument type to find out what the parameter\n@@ -941,12 +945,12 @@ returning the day of the week that string corresponds to (if any).\n \n ## Iteration\n \n-Functions taking blocks provide a good way to define non-trivial\n+Functions taking closures provide a good way to define non-trivial\n iteration constructs. For example, this one iterates over a vector\n of integers backwards:\n \n ~~~~\n-fn for_rev(v: [int], act: block(int)) {\n+fn for_rev(v: [int], act: fn(int)) {\n     let i = vec::len(v);\n     while (i > 0u) {\n         i -= 1u;\n@@ -958,7 +962,7 @@ fn for_rev(v: [int], act: block(int)) {\n To run such an iteration, you could do this:\n \n ~~~~\n-# fn for_rev(v: [int], act: block(int)) {}\n+# fn for_rev(v: [int], act: fn(int)) {}\n for_rev([1, 2, 3], {|n| log(error, n); });\n ~~~~\n \n@@ -967,7 +971,7 @@ moved outside of the parentheses permits the following, which\n looks quite like a normal loop:\n \n ~~~~\n-# fn for_rev(v: [int], act: block(int)) {}\n+# fn for_rev(v: [int], act: fn(int)) {}\n for_rev([1, 2, 3]) {|n|\n     log(error, n);\n }\n@@ -1387,7 +1391,7 @@ Here we know for sure that no one else has access to the `x` variable\n in `main`, so we're good. But the call could also look like this:\n \n ~~~~\n-# fn myfunc(a: int, b: block()) {}\n+# fn myfunc(a: int, b: fn()) {}\n # fn get_another_record() -> int { 1 }\n # let x = 1;\n myfunc(x, {|| x = get_another_record(); });\n@@ -1408,7 +1412,7 @@ to pessimistically assume a value will get mutated, even though it is\n not sure.\n \n ~~~~\n-fn for_each(v: [mutable @int], iter: block(@int)) {\n+fn for_each(v: [mutable @int], iter: fn(@int)) {\n    for elt in v { iter(elt); }\n }\n ~~~~\n@@ -1431,7 +1435,7 @@ with the `copy` operator:\n \n ~~~~\n type mutrec = {mutable x: int};\n-fn for_each(v: [mutable mutrec], iter: block(mutrec)) {\n+fn for_each(v: [mutable mutrec], iter: fn(mutrec)) {\n    for elt in v { iter(copy elt); }\n }\n ~~~~\n@@ -1509,23 +1513,23 @@ defining such functions again and again for every type they apply to.\n Thus, Rust allows functions and datatypes to have type parameters.\n \n ~~~~\n-fn for_rev<T>(v: [T], act: block(T)) {\n+fn for_rev<T>(v: [T], act: fn(T)) {\n     let i = vec::len(v);\n     while i > 0u {\n         i -= 1u;\n         act(v[i]);\n     }\n }\n \n-fn map<T, U>(v: [T], f: block(T) -> U) -> [U] {\n+fn map<T, U>(v: [T], f: fn(T) -> U) -> [U] {\n     let acc = [];\n     for elt in v { acc += [f(elt)]; }\n     ret acc;\n }\n ~~~~\n \n When defined in this way, these functions can be applied to any type\n-of vector, as long as the type of the block's argument and the type of\n+of vector, as long as the type of the closure's argument and the type of\n the vector's content agree with each other.\n \n Inside a parameterized (generic) function, the names of the type\n@@ -1635,7 +1639,7 @@ by value based on their type. There is one situation in which this is\n difficult. If you try this program:\n \n ~~~~\n-# fn map(f: block(int) -> int, v: [int]) {}\n+# fn map(f: fn(int) -> int, v: [int]) {}\n fn plus1(x: int) -> int { x + 1 }\n map(plus1, [1, 2, 3]);\n ~~~~\n@@ -1650,7 +1654,7 @@ pass to a generic higher-order function as being passed by pointer,\n using the `&&` sigil:\n \n ~~~~\n-# fn map<T, U>(f: block(T) -> U, v: [T]) {}\n+# fn map<T, U>(f: fn(T) -> U, v: [T]) {}\n fn plus1(&&x: int) -> int { x + 1 }\n map(plus1, [1, 2, 3]);\n ~~~~\n@@ -2027,11 +2031,11 @@ generalized sequence types:\n ~~~~\n iface seq<T> {\n     fn len() -> uint;\n-    fn iter(block(T));\n+    fn iter(fn(T));\n }\n impl <T> of seq<T> for [T] {\n     fn len() -> uint { vec::len(self) }\n-    fn iter(b: block(T)) {\n+    fn iter(b: fn(T)) {\n         for elt in self { b(elt); }\n     }\n }\n@@ -2112,7 +2116,7 @@ to leave off the `of` clause.\n # type currency = ();\n # fn mk_currency(x: int, s: str) {}\n impl int_util for int {\n-    fn times(b: block(int)) {\n+    fn times(b: fn(int)) {\n         let i = 0;\n         while i < self { b(i); i += 1; }\n     }"}]}