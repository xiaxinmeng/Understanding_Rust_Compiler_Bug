{"sha": "e96699337b6bec60f60b7c5cbb3f8cdd7647405b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5NjY5OTMzN2I2YmVjNjBmNjBiN2M1Y2JiM2Y4Y2RkNzY0NzQwNWI=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-02-24T16:55:42Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-02-24T20:47:59Z"}, "message": "Rollup merge of #48185 - michaelwoerister:recursive-cache-decoding, r=nikomatsakis\n\nincr.comp.: Don't keep RefCells in on-disk-cache borrowed in order to allow for recursive invocations.\n\nFixes #47972.\n\nr? @nikomatsakis", "tree": {"sha": "317e2c0be96219c9b6bccf1778e818b4296e1cf8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/317e2c0be96219c9b6bccf1778e818b4296e1cf8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e96699337b6bec60f60b7c5cbb3f8cdd7647405b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e96699337b6bec60f60b7c5cbb3f8cdd7647405b", "html_url": "https://github.com/rust-lang/rust/commit/e96699337b6bec60f60b7c5cbb3f8cdd7647405b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e96699337b6bec60f60b7c5cbb3f8cdd7647405b/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b52b33a38626306ec2f622f101e7edc2964abfe4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b52b33a38626306ec2f622f101e7edc2964abfe4", "html_url": "https://github.com/rust-lang/rust/commit/b52b33a38626306ec2f622f101e7edc2964abfe4"}, {"sha": "335e25fd79e57c4cd7453c0af25e5c6bd0406602", "url": "https://api.github.com/repos/rust-lang/rust/commits/335e25fd79e57c4cd7453c0af25e5c6bd0406602", "html_url": "https://github.com/rust-lang/rust/commit/335e25fd79e57c4cd7453c0af25e5c6bd0406602"}], "stats": {"total": 34, "additions": 19, "deletions": 15}, "files": [{"sha": "17b44f6959f2f88f97dcf278ba139fa1d7e8e881", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e96699337b6bec60f60b7c5cbb3f8cdd7647405b/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96699337b6bec60f60b7c5cbb3f8cdd7647405b/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=e96699337b6bec60f60b7c5cbb3f8cdd7647405b", "patch": "@@ -347,22 +347,21 @@ impl<'sess> OnDiskCache<'sess> {\n             return None\n         };\n \n-        let mut cnum_map = self.cnum_map.borrow_mut();\n-        if cnum_map.is_none() {\n+        // Initialize the cnum_map if it is not initialized yet.\n+        if self.cnum_map.borrow().is_none() {\n+            let mut cnum_map = self.cnum_map.borrow_mut();\n             *cnum_map = Some(Self::compute_cnum_map(tcx, &self.prev_cnums[..]));\n         }\n-\n-        let mut synthetic_expansion_infos = self.synthetic_expansion_infos.borrow_mut();\n-        let mut file_index_to_file = self.file_index_to_file.borrow_mut();\n+        let cnum_map = self.cnum_map.borrow();\n \n         let mut decoder = CacheDecoder {\n             tcx,\n             opaque: opaque::Decoder::new(&self.serialized_data[..], pos.to_usize()),\n             codemap: self.codemap,\n             cnum_map: cnum_map.as_ref().unwrap(),\n-            file_index_to_file: &mut file_index_to_file,\n+            file_index_to_file: &self.file_index_to_file,\n             file_index_to_stable_id: &self.file_index_to_stable_id,\n-            synthetic_expansion_infos: &mut synthetic_expansion_infos,\n+            synthetic_expansion_infos: &self.synthetic_expansion_infos,\n         };\n \n         match decode_tagged(&mut decoder, dep_node_index) {\n@@ -421,21 +420,21 @@ struct CacheDecoder<'a, 'tcx: 'a, 'x> {\n     opaque: opaque::Decoder<'x>,\n     codemap: &'x CodeMap,\n     cnum_map: &'x IndexVec<CrateNum, Option<CrateNum>>,\n-    synthetic_expansion_infos: &'x mut FxHashMap<AbsoluteBytePos, SyntaxContext>,\n-    file_index_to_file: &'x mut FxHashMap<FileMapIndex, Rc<FileMap>>,\n+    synthetic_expansion_infos: &'x RefCell<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n+    file_index_to_file: &'x RefCell<FxHashMap<FileMapIndex, Rc<FileMap>>>,\n     file_index_to_stable_id: &'x FxHashMap<FileMapIndex, StableFilemapId>,\n }\n \n impl<'a, 'tcx, 'x> CacheDecoder<'a, 'tcx, 'x> {\n-    fn file_index_to_file(&mut self, index: FileMapIndex) -> Rc<FileMap> {\n+    fn file_index_to_file(&self, index: FileMapIndex) -> Rc<FileMap> {\n         let CacheDecoder {\n-            ref mut file_index_to_file,\n+            ref file_index_to_file,\n             ref file_index_to_stable_id,\n             ref codemap,\n             ..\n         } = *self;\n \n-        file_index_to_file.entry(index).or_insert_with(|| {\n+        file_index_to_file.borrow_mut().entry(index).or_insert_with(|| {\n             let stable_id = file_index_to_stable_id[&index];\n             codemap.filemap_by_stable_id(stable_id)\n                    .expect(\"Failed to lookup FileMap in new context.\")\n@@ -572,19 +571,24 @@ impl<'a, 'tcx, 'x> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx, 'x> {\n                 let pos = AbsoluteBytePos::new(self.opaque.position());\n                 let expn_info: ExpnInfo = Decodable::decode(self)?;\n                 let ctxt = SyntaxContext::allocate_directly(expn_info);\n-                self.synthetic_expansion_infos.insert(pos, ctxt);\n+                self.synthetic_expansion_infos.borrow_mut().insert(pos, ctxt);\n                 ctxt\n             }\n             TAG_EXPANSION_INFO_SHORTHAND => {\n                 let pos = AbsoluteBytePos::decode(self)?;\n-                if let Some(ctxt) = self.synthetic_expansion_infos.get(&pos).cloned() {\n+                let cached_ctxt = self.synthetic_expansion_infos\n+                                      .borrow()\n+                                      .get(&pos)\n+                                      .cloned();\n+\n+                if let Some(ctxt) = cached_ctxt {\n                     ctxt\n                 } else {\n                     let expn_info = self.with_position(pos.to_usize(), |this| {\n                          ExpnInfo::decode(this)\n                     })?;\n                     let ctxt = SyntaxContext::allocate_directly(expn_info);\n-                    self.synthetic_expansion_infos.insert(pos, ctxt);\n+                    self.synthetic_expansion_infos.borrow_mut().insert(pos, ctxt);\n                     ctxt\n                 }\n             }"}]}