{"sha": "f8403aac81d5720bb722a85a9120c14ceb763eb9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4NDAzYWFjODFkNTcyMGJiNzIyYTg1YTkxMjBjMTRjZWI3NjNlYjk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-06T03:06:04Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-17T19:25:11Z"}, "message": "Rewrite method resolution to be cleaner, more correct, and to lay\ngroundwork for better performance.\n\nKey points:\n\n- Separate out determining which method to use from actually selecting\n  a method (this should enable caching, as well as the pcwalton fast-reject strategy).\n- Merge the impl selection back into method resolution and don't rely on\n  trait matching (this should perform better but also is needed to resolve some\n  kind of conflicts, see e.g. `method-two-traits-distinguished-via-where-clause.rs`)\n- Purge a lot of out-of-date junk and coercions from method lookups.", "tree": {"sha": "510db4cf66cb0bd455cbf1775fbe9bf5041512a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/510db4cf66cb0bd455cbf1775fbe9bf5041512a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8403aac81d5720bb722a85a9120c14ceb763eb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8403aac81d5720bb722a85a9120c14ceb763eb9", "html_url": "https://github.com/rust-lang/rust/commit/f8403aac81d5720bb722a85a9120c14ceb763eb9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8403aac81d5720bb722a85a9120c14ceb763eb9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f09279395b6ca40f1398277971586197f949738a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f09279395b6ca40f1398277971586197f949738a", "html_url": "https://github.com/rust-lang/rust/commit/f09279395b6ca40f1398277971586197f949738a"}], "stats": {"total": 4466, "additions": 2396, "deletions": 2070}, "files": [{"sha": "ce736a344d5a67609ab29da7bf8000f7f07ab345", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=f8403aac81d5720bb722a85a9120c14ceb763eb9", "patch": "@@ -29,7 +29,7 @@ This API is completely unstable and subject to change.\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![feature(default_type_params, globs, if_let, import_shadowing, macro_rules, phase, quote)]\n-#![feature(slicing_syntax, struct_variant, unsafe_destructor)]\n+#![feature(slicing_syntax, struct_variant, tuple_indexing, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]\n \n extern crate arena;"}, {"sha": "9e0abb897f709393c302bdd748164e2b6a0b82a4", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=f8403aac81d5720bb722a85a9120c14ceb763eb9", "patch": "@@ -281,6 +281,16 @@ pub fn overlapping_impls(infcx: &InferCtxt,\n     coherence::impl_can_satisfy(infcx, impl2_def_id, impl1_def_id)\n }\n \n+pub fn impl_obligations(tcx: &ty::ctxt,\n+                        cause: ObligationCause,\n+                        impl_def_id: ast::DefId,\n+                        impl_substs: &subst::Substs)\n+                        -> subst::VecPerParamSpace<Obligation>\n+{\n+    let impl_generics = ty::lookup_item_type(tcx, impl_def_id).generics;\n+    obligations_for_generics(tcx, cause, &impl_generics, impl_substs)\n+}\n+\n pub fn obligations_for_generics(tcx: &ty::ctxt,\n                                 cause: ObligationCause,\n                                 generics: &ty::Generics,"}, {"sha": "7ea58be34807bf851564f15d65abaed46ff07e58", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=f8403aac81d5720bb722a85a9120c14ceb763eb9", "patch": "@@ -1714,7 +1714,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 closure_type.sig.binder_id,\n                 &closure_type.sig,\n                 |br| self.infcx.next_region_var(\n-                         infer::LateBoundRegion(obligation.cause.span, br)));\n+                         infer::LateBoundRegion(obligation.cause.span, br,\n+                                                infer::FnCall)));\n \n         let arguments_tuple = new_signature.inputs[0];\n         let trait_ref = Rc::new(ty::TraitRef {"}, {"sha": "52b29ff8b2e0fc13a4bcaa959604ec86b9f71e86", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f8403aac81d5720bb722a85a9120c14ceb763eb9", "patch": "@@ -3491,43 +3491,45 @@ pub fn adjust_ty(cx: &ctxt,\n                         }\n                     }\n \n-                    match adj.autoref {\n-                        None => adjusted_ty,\n-                        Some(ref autoref) => adjust_for_autoref(cx, span, adjusted_ty, autoref)\n-                    }\n+                    adjust_ty_for_autoref(cx, span, adjusted_ty, adj.autoref.as_ref())\n                 }\n             }\n         }\n         None => unadjusted_ty\n     };\n+}\n \n-    fn adjust_for_autoref(cx: &ctxt,\n-                          span: Span,\n-                          ty: ty::t,\n-                          autoref: &AutoRef) -> ty::t{\n-        match *autoref {\n-            AutoPtr(r, m, ref a) => {\n-                let adjusted_ty = match a {\n-                    &Some(box ref a) => adjust_for_autoref(cx, span, ty, a),\n-                    &None => ty\n-                };\n-                mk_rptr(cx, r, mt {\n-                    ty: adjusted_ty,\n-                    mutbl: m\n-                })\n-            }\n+pub fn adjust_ty_for_autoref(cx: &ctxt,\n+                             span: Span,\n+                             ty: ty::t,\n+                             autoref: Option<&AutoRef>)\n+                             -> ty::t\n+{\n+    match autoref {\n+        None => ty,\n \n-            AutoUnsafe(m, ref a) => {\n-                let adjusted_ty = match a {\n-                    &Some(box ref a) => adjust_for_autoref(cx, span, ty, a),\n-                    &None => ty\n-                };\n-                mk_ptr(cx, mt {ty: adjusted_ty, mutbl: m})\n-            }\n+        Some(&AutoPtr(r, m, ref a)) => {\n+            let adjusted_ty = match a {\n+                &Some(box ref a) => adjust_ty_for_autoref(cx, span, ty, Some(a)),\n+                &None => ty\n+            };\n+            mk_rptr(cx, r, mt {\n+                ty: adjusted_ty,\n+                mutbl: m\n+            })\n+        }\n \n-            AutoUnsize(ref k) => unsize_ty(cx, ty, k, span),\n-            AutoUnsizeUniq(ref k) => ty::mk_uniq(cx, unsize_ty(cx, ty, k, span)),\n+        Some(&AutoUnsafe(m, ref a)) => {\n+            let adjusted_ty = match a {\n+                &Some(box ref a) => adjust_ty_for_autoref(cx, span, ty, Some(a)),\n+                &None => ty\n+            };\n+            mk_ptr(cx, mt {ty: adjusted_ty, mutbl: m})\n         }\n+\n+        Some(&AutoUnsize(ref k)) => unsize_ty(cx, ty, k, span),\n+\n+        Some(&AutoUnsizeUniq(ref k)) => ty::mk_uniq(cx, unsize_ty(cx, ty, k, span)),\n     }\n }\n "}, {"sha": "59b8309383ce082267f4dd061650de78fcae6a94", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "removed", "additions": 0, "deletions": 1903, "changes": 1903, "blob_url": "https://github.com/rust-lang/rust/blob/f09279395b6ca40f1398277971586197f949738a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f09279395b6ca40f1398277971586197f949738a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=f09279395b6ca40f1398277971586197f949738a", "patch": "@@ -1,1903 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-# Method lookup\n-\n-Method lookup can be rather complex due to the interaction of a number\n-of factors, such as self types, autoderef, trait lookup, etc.  The\n-algorithm is divided into two parts: candidate collection and\n-candidate selection.\n-\n-## Candidate collection\n-\n-A `Candidate` is a method item that might plausibly be the method\n-being invoked.  Candidates are grouped into two kinds, inherent and\n-extension.  Inherent candidates are those that are derived from the\n-type of the receiver itself.  So, if you have a receiver of some\n-nominal type `Foo` (e.g., a struct), any methods defined within an\n-impl like `impl Foo` are inherent methods.  Nothing needs to be\n-imported to use an inherent method, they are associated with the type\n-itself (note that inherent impls can only be defined in the same\n-module as the type itself).\n-\n-Inherent candidates are not always derived from impls.  If you have a\n-trait instance, such as a value of type `Box<ToString>`, then the trait\n-methods (`to_string()`, in this case) are inherently associated with it.\n-Another case is type parameters, in which case the methods of their\n-bounds are inherent.\n-\n-Extension candidates are derived from imported traits.  If I have the\n-trait `ToString` imported, and I call `to_string()` on a value of type `T`,\n-then we will go off to find out whether there is an impl of `ToString`\n-for `T`.  These kinds of method calls are called \"extension methods\".\n-They can be defined in any module, not only the one that defined `T`.\n-Furthermore, you must import the trait to call such a method.\n-\n-For better or worse, we currently give weight to inherent methods over\n-extension methods during candidate selection (below).\n-\n-## Candidate selection\n-\n-Once we know the set of candidates, we can go off and try to select\n-which one is actually being called.  We do this by taking the type of\n-the receiver, let's call it R, and checking whether it matches against\n-the expected receiver type for each of the collected candidates.  We\n-first check for inherent candidates and see whether we get exactly one\n-match (zero means keep searching, more than one is an error).  If so,\n-we return that as the candidate.  Otherwise we search the extension\n-candidates in the same way.\n-\n-If find no matching candidate at all, we proceed to auto-deref the\n-receiver type and search again.  We keep doing that until we cannot\n-auto-deref any longer.  At each step, we also check for candidates\n-based on \"autoptr\", which if the current type is `T`, checks for `&mut\n-T`, `&const T`, and `&T` receivers.  Finally, at the very end, we will\n-also try autoslice, which converts `~[]` to `&[]` (there is no point\n-at trying autoslice earlier, because no autoderefable type is also\n-sliceable).\n-\n-## Why two phases?\n-\n-You might wonder why we first collect the candidates and then select.\n-Both the inherent candidate collection and the candidate selection\n-proceed by progressively deref'ing the receiver type, after all.  The\n-answer is that two phases are needed to elegantly deal with explicit\n-self.  After all, if there is an impl for the type `Foo`, it can\n-define a method with the type `Box<self>`, which means that it expects a\n-receiver of type `Box<Foo>`.  If we have a receiver of type `Box<Foo>`, but we\n-waited to search for that impl until we have deref'd the `Box` away and\n-obtained the type `Foo`, we would never match this method.\n-\n-*/\n-\n-pub use self::CheckTraitsFlag::*;\n-pub use self::AutoderefReceiverFlag::*;\n-pub use self::MethodError::*;\n-pub use self::CandidateSource::*;\n-\n-use middle::subst;\n-use middle::subst::{Subst, SelfSpace};\n-use middle::traits;\n-use middle::ty::*;\n-use middle::ty;\n-use middle::typeck::astconv::AstConv;\n-use middle::typeck::check::{FnCtxt, NoPreference, PreferMutLvalue};\n-use middle::typeck::check::{impl_self_ty};\n-use middle::typeck::check::vtable::select_new_fcx_obligations;\n-use middle::typeck::check;\n-use middle::typeck::infer;\n-use middle::typeck::{MethodCall, MethodCallee};\n-use middle::typeck::{MethodOrigin, MethodParam, MethodTypeParam};\n-use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure, MethodObject, MethodTraitObject};\n-use middle::typeck::check::regionmanip::replace_late_bound_regions;\n-use middle::typeck::TypeAndSubsts;\n-use middle::typeck::check::vtable;\n-use middle::ty_fold::TypeFoldable;\n-use util::common::indenter;\n-use util::ppaux;\n-use util::ppaux::{Repr, UserString};\n-\n-use std::collections::HashSet;\n-use std::rc::Rc;\n-use syntax::ast::{DefId, MutImmutable, MutMutable};\n-use syntax::ast;\n-use syntax::codemap::Span;\n-\n-#[deriving(PartialEq)]\n-pub enum CheckTraitsFlag {\n-    CheckTraitsOnly,\n-    CheckTraitsAndInherentMethods,\n-}\n-\n-#[deriving(PartialEq)]\n-pub enum AutoderefReceiverFlag {\n-    AutoderefReceiver,\n-    DontAutoderefReceiver,\n-}\n-\n-pub enum MethodError {\n-    // Did not find an applicable method, but we did find various\n-    // static methods that may apply.\n-    NoMatch(Vec<CandidateSource>),\n-\n-    // Multiple methods might apply.\n-    Ambiguity(Vec<CandidateSource>),\n-}\n-\n-pub type MethodResult = Result<MethodCallee, MethodError>;\n-\n-pub fn lookup<'a, 'tcx>(\n-    fcx: &'a FnCtxt<'a, 'tcx>,\n-\n-    // In a call `a.b::<X, Y, ...>(...)`:\n-    expr: &ast::Expr,                   // The expression `a.b(...)`.\n-    self_expr: &'a ast::Expr,           // The expression `a`.\n-    m_name: ast::Name,                  // The name `b`.\n-    self_ty: ty::t,                     // The type of `a`.\n-    supplied_tps: &'a [ty::t],          // The list of types X, Y, ... .\n-    deref_args: check::DerefArgs,       // Whether we autopointer first.\n-    check_traits: CheckTraitsFlag,      // Whether we check traits only.\n-    autoderef_receiver: AutoderefReceiverFlag)\n-    -> MethodResult\n-{\n-    let mut lcx = LookupContext {\n-        fcx: fcx,\n-        span: expr.span,\n-        self_expr: Some(self_expr),\n-        m_name: m_name,\n-        supplied_tps: supplied_tps,\n-        impl_dups: HashSet::new(),\n-        inherent_candidates: Vec::new(),\n-        extension_candidates: Vec::new(),\n-        static_candidates: Vec::new(),\n-        deref_args: deref_args,\n-        check_traits: check_traits,\n-        autoderef_receiver: autoderef_receiver,\n-    };\n-\n-    debug!(\"method lookup(self_ty={}, expr={}, self_expr={})\",\n-           self_ty.repr(fcx.tcx()), expr.repr(fcx.tcx()),\n-           self_expr.repr(fcx.tcx()));\n-\n-    debug!(\"searching inherent candidates\");\n-    lcx.push_inherent_candidates(self_ty);\n-    debug!(\"searching extension candidates\");\n-    lcx.push_bound_candidates(self_ty, None);\n-    lcx.push_extension_candidates(expr.id);\n-    lcx.search(self_ty)\n-}\n-\n-pub fn lookup_in_trait<'a, 'tcx>(\n-    fcx: &'a FnCtxt<'a, 'tcx>,\n-    span: Span,\n-    self_expr: Option<&'a ast::Expr>,\n-    m_name: ast::Name,\n-    trait_def_id: DefId,\n-    self_ty: ty::t,\n-    opt_input_types: Option<Vec<ty::t>>)\n-    -> Option<MethodCallee>\n-{\n-    lookup_in_trait_adjusted(fcx, span, self_expr, m_name, trait_def_id,\n-                             ty::AutoDerefRef { autoderefs: 0, autoref: None },\n-                             self_ty, opt_input_types)\n-}\n-\n-pub fn lookup_in_trait_adjusted<'a, 'tcx>(\n-    fcx: &'a FnCtxt<'a, 'tcx>,\n-    span: Span,\n-    self_expr: Option<&'a ast::Expr>,\n-    m_name: ast::Name,\n-    trait_def_id: DefId,\n-    autoderefref: ty::AutoDerefRef,\n-    self_ty: ty::t,\n-    opt_input_types: Option<Vec<ty::t>>)\n-    -> Option<MethodCallee>\n-{\n-    debug!(\"method lookup_in_trait(self_ty={}, self_expr={}, m_name={}, trait_def_id={})\",\n-           self_ty.repr(fcx.tcx()),\n-           self_expr.repr(fcx.tcx()),\n-           m_name.repr(fcx.tcx()),\n-           trait_def_id.repr(fcx.tcx()));\n-\n-    let trait_def = ty::lookup_trait_def(fcx.tcx(), trait_def_id);\n-\n-    let expected_number_of_input_types = trait_def.generics.types.len(subst::TypeSpace);\n-    let input_types = match opt_input_types {\n-        Some(input_types) => {\n-            assert_eq!(expected_number_of_input_types, input_types.len());\n-            input_types\n-        }\n-\n-        None => {\n-            fcx.inh.infcx.next_ty_vars(expected_number_of_input_types)\n-        }\n-    };\n-\n-    let number_assoc_types = trait_def.generics.types.len(subst::AssocSpace);\n-    let assoc_types = fcx.inh.infcx.next_ty_vars(number_assoc_types);\n-\n-    assert_eq!(trait_def.generics.types.len(subst::FnSpace), 0);\n-    assert!(trait_def.generics.regions.is_empty());\n-\n-    // Construct a trait-reference `self_ty : Trait<input_tys>`\n-    let substs = subst::Substs::new_trait(input_types, Vec::new(), assoc_types, self_ty);\n-    let trait_ref = Rc::new(ty::TraitRef::new(trait_def_id, substs));\n-\n-    // Construct an obligation\n-    let obligation = traits::Obligation::misc(span, trait_ref.clone());\n-\n-    // Now we want to know if this can be matched\n-    let mut selcx = traits::SelectionContext::new(fcx.infcx(),\n-                                                  &fcx.inh.param_env,\n-                                                  fcx);\n-    if !selcx.evaluate_obligation(&obligation) {\n-        debug!(\"--> Cannot match obligation\");\n-        return None; // Cannot be matched, no such method resolution is possible.\n-    }\n-\n-    // Trait must have a method named `m_name` and it should not have\n-    // type parameters or early-bound regions.\n-    let tcx = fcx.tcx();\n-    let (method_num, method_ty) = trait_method(tcx, trait_def_id, m_name).unwrap();\n-    assert_eq!(method_ty.generics.types.len(subst::FnSpace), 0);\n-    assert_eq!(method_ty.generics.regions.len(subst::FnSpace), 0);\n-\n-    // Substitute the trait parameters into the method type and\n-    // instantiate late-bound regions to get the actual method type.\n-    let ref bare_fn_ty = method_ty.fty;\n-    let fn_sig = bare_fn_ty.sig.subst(tcx, &trait_ref.substs);\n-    let fn_sig = replace_late_bound_regions_with_fresh_var(fcx.infcx(), span,\n-                                                           fn_sig.binder_id, &fn_sig);\n-    let transformed_self_ty = fn_sig.inputs[0];\n-    let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n-        sig: fn_sig,\n-        fn_style: bare_fn_ty.fn_style,\n-        abi: bare_fn_ty.abi.clone(),\n-    });\n-\n-    debug!(\"matched method fty={} obligation={}\",\n-           fty.repr(fcx.tcx()),\n-           obligation.repr(fcx.tcx()));\n-\n-    // Register obligations for the parameters.  This will include the\n-    // `Self` parameter, which in turn has a bound of the main trait,\n-    // so this also effectively registers `obligation` as well.  (We\n-    // used to register `obligation` explicitly, but that resulted in\n-    // double error messages being reported.)\n-    fcx.add_obligations_for_parameters(\n-        traits::ObligationCause::misc(span),\n-        &trait_ref.substs,\n-        &method_ty.generics);\n-\n-    // FIXME(#18653) -- Try to resolve obligations, giving us more\n-    // typing information, which can sometimes be needed to avoid\n-    // pathological region inference failures.\n-    vtable::select_new_fcx_obligations(fcx);\n-\n-    // Insert any adjustments needed (always an autoref of some mutability).\n-    match self_expr {\n-        None => { }\n-\n-        Some(self_expr) => {\n-            debug!(\"inserting adjustment if needed (self-id = {}, \\\n-                   base adjustment = {}, explicit self = {})\",\n-                   self_expr.id, autoderefref, method_ty.explicit_self);\n-\n-            match method_ty.explicit_self {\n-                ty::ByValueExplicitSelfCategory => {\n-                    // Trait method is fn(self), no transformation needed.\n-                    if !autoderefref.is_identity() {\n-                        fcx.write_adjustment(\n-                            self_expr.id,\n-                            span,\n-                            ty::AdjustDerefRef(autoderefref));\n-                    }\n-                }\n-\n-                ty::ByReferenceExplicitSelfCategory(..) => {\n-                    // Trait method is fn(&self) or fn(&mut self), need an\n-                    // autoref. Pull the region etc out of the type of first argument.\n-                    match ty::get(transformed_self_ty).sty {\n-                        ty::ty_rptr(region, ty::mt { mutbl, ty: _ }) => {\n-                            let ty::AutoDerefRef { autoderefs, autoref } = autoderefref;\n-                            let autoref = autoref.map(|r| box r);\n-                            fcx.write_adjustment(\n-                                self_expr.id,\n-                                span,\n-                                ty::AdjustDerefRef(ty::AutoDerefRef {\n-                                    autoderefs: autoderefs,\n-                                    autoref: Some(ty::AutoPtr(region, mutbl, autoref))\n-                                }));\n-                        }\n-\n-                        _ => {\n-                            fcx.tcx().sess.span_bug(\n-                                span,\n-                                format!(\n-                                    \"trait method is &self but first arg is: {}\",\n-                                    transformed_self_ty.repr(fcx.tcx())).as_slice());\n-                        }\n-                    }\n-                }\n-\n-                _ => {\n-                    fcx.tcx().sess.span_bug(\n-                        span,\n-                        format!(\n-                            \"unexpected explicit self type in operator method: {}\",\n-                            method_ty.explicit_self).as_slice());\n-                }\n-            }\n-        }\n-    }\n-\n-    let callee = MethodCallee {\n-        origin: MethodTypeParam(MethodParam{trait_ref: trait_ref.clone(),\n-                                            method_num: method_num}),\n-        ty: fty,\n-        substs: trait_ref.substs.clone()\n-    };\n-\n-    debug!(\"callee = {}\", callee.repr(fcx.tcx()));\n-\n-    Some(callee)\n-}\n-\n-pub fn report_error(fcx: &FnCtxt,\n-                    span: Span,\n-                    rcvr_ty: ty::t,\n-                    method_name: ast::Name,\n-                    error: MethodError)\n-{\n-    match error {\n-        NoMatch(static_sources) => {\n-            let cx = fcx.tcx();\n-            let method_ustring = method_name.user_string(cx);\n-\n-            // True if the type is a struct and contains a field with\n-            // the same name as the not-found method\n-            let is_field = match ty::get(rcvr_ty).sty {\n-                ty_struct(did, _) =>\n-                    ty::lookup_struct_fields(cx, did)\n-                        .iter()\n-                        .any(|f| f.name.user_string(cx) == method_ustring),\n-                _ => false\n-            };\n-\n-            fcx.type_error_message(\n-                span,\n-                |actual| {\n-                    format!(\"type `{}` does not implement any \\\n-                             method in scope named `{}`\",\n-                            actual,\n-                            method_ustring)\n-                },\n-                rcvr_ty,\n-                None);\n-\n-            // If the method has the name of a field, give a help note\n-            if is_field {\n-                cx.sess.span_note(span,\n-                    format!(\"use `(s.{0})(...)` if you meant to call the \\\n-                            function stored in the `{0}` field\", method_ustring).as_slice());\n-            }\n-\n-            if static_sources.len() > 0 {\n-                fcx.tcx().sess.fileline_note(\n-                    span,\n-                    \"found defined static methods, maybe a `self` is missing?\");\n-\n-                report_candidates(fcx, span, method_name, static_sources);\n-            }\n-        }\n-\n-        Ambiguity(sources) => {\n-            span_err!(fcx.sess(), span, E0034,\n-                      \"multiple applicable methods in scope\");\n-\n-            report_candidates(fcx, span, method_name, sources);\n-        }\n-    }\n-\n-    fn report_candidates(fcx: &FnCtxt,\n-                         span: Span,\n-                         method_name: ast::Name,\n-                         mut sources: Vec<CandidateSource>) {\n-        sources.sort();\n-        sources.dedup();\n-\n-        for (idx, source) in sources.iter().enumerate() {\n-            match *source {\n-                ImplSource(impl_did) => {\n-                    // Provide the best span we can. Use the method, if local to crate, else\n-                    // the impl, if local to crate (method may be defaulted), else the call site.\n-                    let method = impl_method(fcx.tcx(), impl_did, method_name).unwrap();\n-                    let impl_span = fcx.tcx().map.def_id_span(impl_did, span);\n-                    let method_span = fcx.tcx().map.def_id_span(method.def_id, impl_span);\n-\n-                    let impl_ty = impl_self_ty(fcx, span, impl_did).ty;\n-\n-                    let insertion = match impl_trait_ref(fcx.tcx(), impl_did) {\n-                        None => format!(\"\"),\n-                        Some(trait_ref) => format!(\" of the trait `{}`\",\n-                                                   ty::item_path_str(fcx.tcx(),\n-                                                                     trait_ref.def_id)),\n-                    };\n-\n-                    span_note!(fcx.sess(), method_span,\n-                               \"candidate #{} is defined in an impl{} for the type `{}`\",\n-                               idx + 1u,\n-                               insertion,\n-                               impl_ty.user_string(fcx.tcx()));\n-                }\n-                TraitSource(trait_did) => {\n-                    let (_, method) = trait_method(fcx.tcx(), trait_did, method_name).unwrap();\n-                    let method_span = fcx.tcx().map.def_id_span(method.def_id, span);\n-                    span_note!(fcx.sess(), method_span,\n-                               \"candidate #{} is defined in the trait `{}`\",\n-                               idx + 1u,\n-                               ty::item_path_str(fcx.tcx(), trait_did));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-// Determine the index of a method in the list of all methods belonging\n-// to a trait and its supertraits.\n-fn get_method_index(tcx: &ty::ctxt,\n-                    trait_ref: &TraitRef,\n-                    subtrait: Rc<TraitRef>,\n-                    n_method: uint) -> uint {\n-    // We need to figure the \"real index\" of the method in a\n-    // listing of all the methods of an object. We do this by\n-    // iterating down the supertraits of the object's trait until\n-    // we find the trait the method came from, counting up the\n-    // methods from them.\n-    let mut method_count = 0;\n-    ty::each_bound_trait_and_supertraits(tcx, &[subtrait], |bound_ref| {\n-        if bound_ref.def_id == trait_ref.def_id {\n-            false\n-        } else {\n-            let trait_items = ty::trait_items(tcx, bound_ref.def_id);\n-            for trait_item in trait_items.iter() {\n-                match *trait_item {\n-                    ty::MethodTraitItem(_) => method_count += 1,\n-                    ty::TypeTraitItem(_) => {}\n-                }\n-            }\n-            true\n-        }\n-    });\n-    method_count + n_method\n-}\n-\n-struct LookupContext<'a, 'tcx: 'a> {\n-    fcx: &'a FnCtxt<'a, 'tcx>,\n-    span: Span,\n-\n-    // The receiver to the method call. Only `None` in the case of\n-    // an overloaded autoderef, where the receiver may be an intermediate\n-    // state like \"the expression `x` when it has been autoderef'd\n-    // twice already\".\n-    self_expr: Option<&'a ast::Expr>,\n-\n-    m_name: ast::Name,\n-    supplied_tps: &'a [ty::t],\n-    impl_dups: HashSet<DefId>,\n-    inherent_candidates: Vec<Candidate>,\n-    extension_candidates: Vec<ExtensionCandidate>,\n-    static_candidates: Vec<CandidateSource>,\n-    deref_args: check::DerefArgs,\n-    check_traits: CheckTraitsFlag,\n-    autoderef_receiver: AutoderefReceiverFlag,\n-}\n-\n-// A method that the user may be trying to invoke. Initially, we\n-// construct candidates only for inherent methods; for extension\n-// traits, we use an ExtensionCandidate.\n-#[deriving(Clone)]\n-struct Candidate {\n-    xform_self_ty: ty::t,\n-    rcvr_substs: subst::Substs,\n-    method_ty: Rc<ty::Method>,\n-    origin: MethodOrigin,\n-}\n-\n-// A variation on a candidate that just stores the data needed\n-// extension trait matching.  Once we pick the trait that matches,\n-// we'll construct a normal candidate from that. There is no deep\n-// reason for this, the code just worked out a bit cleaner.\n-struct ExtensionCandidate {\n-    obligation: traits::Obligation,\n-    xform_self_ty: ty::t,\n-    method_ty: Rc<ty::Method>,\n-    method_num: uint,\n-}\n-\n-// A pared down enum describing just the places from which a method\n-// candidate can arise. Used for error reporting only.\n-#[deriving(PartialOrd, Ord, PartialEq, Eq)]\n-pub enum CandidateSource {\n-    ImplSource(ast::DefId),\n-    TraitSource(/* trait id */ ast::DefId),\n-}\n-\n-impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n-    fn search(self, self_ty: ty::t) -> MethodResult {\n-        let span = self.self_expr.map_or(self.span, |e| e.span);\n-        let self_expr_id = self.self_expr.map(|e| e.id);\n-\n-        let (_, _, result) =\n-            check::autoderef(\n-                self.fcx, span, self_ty, self_expr_id, NoPreference,\n-                |self_ty, autoderefs| self.search_step(self_ty, autoderefs));\n-\n-        match result {\n-            Some(Some(Ok(result))) => {\n-                self.fixup_derefs_on_method_receiver_if_necessary(&result);\n-                Ok(result)\n-            }\n-            Some(Some(Err(err))) => {\n-                Err(err)\n-            }\n-            None | Some(None) => {\n-                Err(NoMatch(self.static_candidates))\n-            }\n-        }\n-    }\n-\n-    fn search_step(&self,\n-                   self_ty: ty::t,\n-                   autoderefs: uint)\n-                   -> Option<Option<MethodResult>>\n-    {\n-        // Oh my, what a return type!\n-        //\n-        // Returning:\n-        // - `None` => autoderef more, keep searching\n-        // - `Some(None)` => stop searching, found nothing\n-        // - `Some(Some(_))` => stop searching, found either callee/error\n-        //   - `Some(Some(Ok(_)))` => found a callee\n-        //   - `Some(Some(Err(_)))` => found an error (ambiguity, etc)\n-\n-        debug!(\"search_step: self_ty={} autoderefs={}\",\n-               self.ty_to_string(self_ty), autoderefs);\n-\n-        match self.deref_args {\n-            check::DontDerefArgs => {\n-                match self.search_for_autoderefd_method(self_ty, autoderefs) {\n-                    Some(result) => return Some(Some(result)),\n-                    None => {}\n-                }\n-\n-                match self.search_for_autoptrd_method(self_ty, autoderefs) {\n-                    Some(result) => return Some(Some(result)),\n-                    None => {}\n-                }\n-            }\n-            check::DoDerefArgs => {\n-                match self.search_for_autoptrd_method(self_ty, autoderefs) {\n-                    Some(result) => return Some(Some(result)),\n-                    None => {}\n-                }\n-\n-                match self.search_for_autoderefd_method(self_ty, autoderefs) {\n-                    Some(result) => return Some(Some(result)),\n-                    None => {}\n-                }\n-            }\n-        }\n-\n-        // If we are searching for an overloaded deref, no\n-        // need to try coercing a `~[T]` to an `&[T]` and\n-        // searching for an overloaded deref on *that*.\n-        if !self.is_overloaded_deref() {\n-            match self.search_for_autofatptrd_method(self_ty, autoderefs) {\n-                Some(result) => return Some(Some(result)),\n-                None => {}\n-            }\n-        }\n-\n-        // Don't autoderef if we aren't supposed to.\n-        if self.autoderef_receiver == DontAutoderefReceiver {\n-            Some(None)\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn is_overloaded_deref(&self) -> bool {\n-        self.self_expr.is_none()\n-    }\n-\n-    ///////////////////////////////////////////////////////////////////////////\n-    // Candidate collection (see comment at start of file)\n-\n-    fn push_inherent_candidates(&mut self, self_ty: ty::t) {\n-        /*!\n-         * Collect all inherent candidates into\n-         * `self.inherent_candidates`.  See comment at the start of\n-         * the file.  To find the inherent candidates, we repeatedly\n-         * deref the self-ty to find the \"base-type\".  So, for\n-         * example, if the receiver is Box<Box<C>> where `C` is a struct type,\n-         * we'll want to find the inherent impls for `C`.\n-         */\n-\n-        let span = self.self_expr.map_or(self.span, |e| e.span);\n-        check::autoderef(self.fcx, span, self_ty, None, NoPreference, |self_ty, _| {\n-            match get(self_ty).sty {\n-                ty_trait(box TyTrait { ref principal, bounds, .. }) => {\n-                    self.push_inherent_candidates_from_object(self_ty, &*principal, bounds);\n-                    self.push_inherent_impl_candidates_for_type(principal.def_id);\n-                }\n-                ty_enum(did, _) |\n-                ty_struct(did, _) |\n-                ty_unboxed_closure(did, _, _) => {\n-                    if self.check_traits == CheckTraitsAndInherentMethods {\n-                        self.push_inherent_impl_candidates_for_type(did);\n-                    }\n-                }\n-                _ => { /* No inherent methods in these types */ }\n-            }\n-\n-            // Don't autoderef if we aren't supposed to.\n-            if self.autoderef_receiver == DontAutoderefReceiver {\n-                Some(())\n-            } else {\n-                None\n-            }\n-        });\n-    }\n-\n-    fn push_bound_candidates(&mut self, self_ty: ty::t, restrict_to: Option<DefId>) {\n-        let span = self.self_expr.map_or(self.span, |e| e.span);\n-        check::autoderef(self.fcx, span, self_ty, None, NoPreference, |self_ty, _| {\n-            match get(self_ty).sty {\n-                ty_param(p) => {\n-                    self.push_inherent_candidates_from_param(self_ty, restrict_to, p);\n-                }\n-                _ => { /* No bound methods in these types */ }\n-            }\n-\n-            // Don't autoderef if we aren't supposed to.\n-            if self.autoderef_receiver == DontAutoderefReceiver {\n-                Some(())\n-            } else {\n-                None\n-            }\n-        });\n-    }\n-\n-    fn push_extension_candidates(&mut self, expr_id: ast::NodeId) {\n-        debug!(\"push_extension_candidates(expr_id={})\", expr_id);\n-\n-        let mut duplicates = HashSet::new();\n-        let opt_applicable_traits = self.fcx.ccx.trait_map.get(&expr_id);\n-        for applicable_traits in opt_applicable_traits.into_iter() {\n-            for &trait_did in applicable_traits.iter() {\n-                if duplicates.insert(trait_did) {\n-                    self.push_extension_candidate(trait_did);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn push_extension_candidate(&mut self, trait_def_id: DefId) {\n-        debug!(\"push_extension_candidates: trait_def_id={}\", trait_def_id);\n-\n-        // Check whether `trait_def_id` defines a method with suitable name:\n-        let trait_items =\n-            ty::trait_items(self.tcx(), trait_def_id);\n-        let matching_index =\n-            trait_items.iter()\n-                       .position(|item| item.name() == self.m_name);\n-        let matching_index = match matching_index {\n-            Some(i) => i,\n-            None => { return; }\n-        };\n-        let method = match (&*trait_items)[matching_index].as_opt_method() {\n-            Some(m) => m,\n-            None => { return; }\n-        };\n-\n-        // Check whether `trait_def_id` defines a method with suitable name:\n-        if !self.has_applicable_self(&*method) {\n-            debug!(\"method has inapplicable self\");\n-            return self.record_static_candidate(TraitSource(trait_def_id));\n-        }\n-\n-        // Otherwise, construct the receiver type.\n-        let self_ty =\n-            self.fcx.infcx().next_ty_var();\n-        let trait_def =\n-            ty::lookup_trait_def(self.tcx(), trait_def_id);\n-        let substs =\n-            self.fcx.infcx().fresh_substs_for_trait(self.span,\n-                                                    &trait_def.generics,\n-                                                    self_ty);\n-        let xform_self_ty =\n-            self.xform_self_ty(&method, &substs);\n-\n-        // Construct the obligation which must match.\n-        let trait_ref =\n-            Rc::new(ty::TraitRef::new(trait_def_id, substs));\n-        let obligation =\n-            traits::Obligation::misc(self.span, trait_ref);\n-\n-        debug!(\"extension-candidate(xform_self_ty={} obligation={})\",\n-               self.infcx().ty_to_string(xform_self_ty),\n-               obligation.repr(self.tcx()));\n-\n-        self.extension_candidates.push(ExtensionCandidate {\n-            obligation: obligation,\n-            xform_self_ty: xform_self_ty,\n-            method_ty: method,\n-            method_num: matching_index,\n-        });\n-    }\n-\n-    fn push_inherent_candidates_from_object(&mut self,\n-                                            self_ty: ty::t,\n-                                            principal: &ty::TraitRef,\n-                                            _bounds: ty::ExistentialBounds) {\n-        debug!(\"push_inherent_candidates_from_object(self_ty={})\",\n-               self_ty.repr(self.tcx()));\n-\n-        let tcx = self.tcx();\n-\n-        // It is illegal to invoke a method on a trait instance that\n-        // refers to the `Self` type. An error will be reported by\n-        // `enforce_object_limitations()` if the method refers to the\n-        // `Self` type anywhere other than the receiver. Here, we use\n-        // a substitution that replaces `Self` with the object type\n-        // itself. Hence, a `&self` method will wind up with an\n-        // argument type like `&Trait`.\n-        let rcvr_substs = principal.substs.with_self_ty(self_ty);\n-        let trait_ref = Rc::new(TraitRef { def_id: principal.def_id,\n-                                           substs: rcvr_substs.clone() });\n-\n-        self.push_inherent_candidates_from_bounds_inner(\n-            &[trait_ref.clone()],\n-            |this, new_trait_ref, m, method_num| {\n-                let vtable_index =\n-                    get_method_index(tcx, &*new_trait_ref,\n-                                     trait_ref.clone(), method_num);\n-\n-                // FIXME Hacky. By-value `self` methods in objects ought to be\n-                // just a special case of passing ownership of a DST value\n-                // as a parameter. *But* we currently hack them in and tie them to\n-                // the particulars of the `Box` type. So basically for a `fn foo(self,...)`\n-                // method invoked on an object, we don't want the receiver type to be\n-                // `TheTrait`, but rather `Box<TheTrait>`. Yuck.\n-                let mut m = m;\n-                match m.explicit_self {\n-                    ByValueExplicitSelfCategory => {\n-                        let mut n = (*m).clone();\n-                        let self_ty = n.fty.sig.inputs[0];\n-                        n.fty.sig.inputs[0] = ty::mk_uniq(tcx, self_ty);\n-                        m = Rc::new(n);\n-                    }\n-                    _ => { }\n-                }\n-\n-                let xform_self_ty =\n-                    this.xform_self_ty(&m, &new_trait_ref.substs);\n-\n-                Some(Candidate {\n-                    xform_self_ty: xform_self_ty,\n-                    rcvr_substs: new_trait_ref.substs.clone(),\n-                    method_ty: m,\n-                    origin: MethodTraitObject(MethodObject {\n-                        trait_ref: new_trait_ref,\n-                        object_trait_id: principal.def_id,\n-                        method_num: method_num,\n-                        real_index: vtable_index\n-                    })\n-                })\n-            });\n-    }\n-\n-    fn push_inherent_candidates_from_param(&mut self,\n-                                           rcvr_ty: ty::t,\n-                                           restrict_to: Option<DefId>,\n-                                           param_ty: ParamTy) {\n-        debug!(\"push_inherent_candidates_from_param(param_ty={})\",\n-               param_ty);\n-        self.push_inherent_candidates_from_bounds(\n-            rcvr_ty,\n-            param_ty.space,\n-            param_ty.idx,\n-            restrict_to);\n-    }\n-\n-    fn push_inherent_candidates_from_bounds(&mut self,\n-                                            _self_ty: ty::t,\n-                                            space: subst::ParamSpace,\n-                                            index: uint,\n-                                            restrict_to: Option<DefId>) {\n-        let bounds =\n-            self.fcx.inh.param_env.bounds.get(space, index).trait_bounds\n-            .as_slice();\n-        self.push_inherent_candidates_from_bounds_inner(bounds,\n-            |this, trait_ref, m, method_num| {\n-                match restrict_to {\n-                    Some(trait_did) => {\n-                        if trait_did != trait_ref.def_id {\n-                            return None;\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-\n-                let xform_self_ty =\n-                    this.xform_self_ty(&m, &trait_ref.substs);\n-\n-                debug!(\"found match: trait_ref={} substs={} m={}\",\n-                       trait_ref.repr(this.tcx()),\n-                       trait_ref.substs.repr(this.tcx()),\n-                       m.repr(this.tcx()));\n-                assert_eq!(m.generics.types.get_slice(subst::TypeSpace).len(),\n-                           trait_ref.substs.types.get_slice(subst::TypeSpace).len());\n-                assert_eq!(m.generics.regions.get_slice(subst::TypeSpace).len(),\n-                           trait_ref.substs.regions().get_slice(subst::TypeSpace).len());\n-                assert_eq!(m.generics.types.get_slice(subst::SelfSpace).len(),\n-                           trait_ref.substs.types.get_slice(subst::SelfSpace).len());\n-                assert_eq!(m.generics.regions.get_slice(subst::SelfSpace).len(),\n-                           trait_ref.substs.regions().get_slice(subst::SelfSpace).len());\n-\n-                Some(Candidate {\n-                    xform_self_ty: xform_self_ty,\n-                    rcvr_substs: trait_ref.substs.clone(),\n-                    method_ty: m,\n-                    origin: MethodTypeParam(MethodParam {\n-                        trait_ref: trait_ref,\n-                        method_num: method_num,\n-                    })\n-                })\n-            })\n-    }\n-\n-    // Do a search through a list of bounds, using a callback to actually\n-    // create the candidates.\n-    fn push_inherent_candidates_from_bounds_inner(\n-        &mut self,\n-        bounds: &[Rc<TraitRef>],\n-        mk_cand: |this: &mut LookupContext,\n-                  tr: Rc<TraitRef>,\n-                  m: Rc<ty::Method>,\n-                  method_num: uint|\n-                  -> Option<Candidate>)\n-    {\n-        let tcx = self.tcx();\n-        let mut cache = HashSet::new();\n-        for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n-            // Already visited this trait, skip it.\n-            if !cache.insert(bound_trait_ref.def_id) {\n-                continue;\n-            }\n-\n-            let (pos, method) = match trait_method(tcx, bound_trait_ref.def_id, self.m_name) {\n-                Some(v) => v,\n-                None => { continue; }\n-            };\n-\n-            if !self.has_applicable_self(&*method) {\n-                self.record_static_candidate(TraitSource(bound_trait_ref.def_id));\n-            } else {\n-                match mk_cand(self,\n-                              bound_trait_ref,\n-                              method,\n-                              pos) {\n-                    Some(cand) => {\n-                        debug!(\"pushing inherent candidate for param: {}\",\n-                               cand.repr(self.tcx()));\n-                        self.inherent_candidates.push(cand);\n-                    }\n-                    None => {}\n-                }\n-            }\n-        }\n-    }\n-\n-\n-    fn push_inherent_impl_candidates_for_type(&mut self, did: DefId) {\n-        // Read the inherent implementation candidates for this type from the\n-        // metadata if necessary.\n-        ty::populate_implementations_for_type_if_necessary(self.tcx(), did);\n-\n-        for impl_infos in self.tcx().inherent_impls.borrow().get(&did).iter() {\n-            for impl_did in impl_infos.iter() {\n-                self.push_candidates_from_inherent_impl(*impl_did);\n-            }\n-        }\n-    }\n-\n-    fn push_candidates_from_inherent_impl(&mut self,\n-                                          impl_did: DefId) {\n-        if !self.impl_dups.insert(impl_did) {\n-            return; // already visited\n-        }\n-\n-        let method = match impl_method(self.tcx(), impl_did, self.m_name) {\n-            Some(m) => m,\n-            None => { return; } // No method with correct name on this impl\n-        };\n-\n-        debug!(\"push_candidates_from_inherent_impl: impl_did={} method={}\",\n-               impl_did.repr(self.tcx()),\n-               method.repr(self.tcx()));\n-\n-        if !self.has_applicable_self(&*method) {\n-            // No receiver declared. Not a candidate.\n-            return self.record_static_candidate(ImplSource(impl_did));\n-        }\n-\n-        // Determine the `self` of the impl with fresh\n-        // variables for each parameter.\n-        let span = self.self_expr.map_or(self.span, |e| e.span);\n-        let TypeAndSubsts {\n-            substs: impl_substs,\n-            ty: _impl_ty\n-        } = impl_self_ty(self.fcx, span, impl_did);\n-\n-        // Determine the receiver type that the method itself expects.\n-        let xform_self_ty =\n-            self.xform_self_ty(&method, &impl_substs);\n-\n-        self.inherent_candidates.push(Candidate {\n-            xform_self_ty: xform_self_ty,\n-            rcvr_substs: impl_substs,\n-            origin: MethodStatic(method.def_id),\n-            method_ty: method,\n-        });\n-    }\n-\n-    // ______________________________________________________________________\n-    // Candidate selection (see comment at start of file)\n-\n-    fn search_for_autoderefd_method(&self,\n-                                    self_ty: ty::t,\n-                                    autoderefs: uint)\n-                                    -> Option<MethodResult> {\n-        // Hacky. For overloaded derefs, there may be an adjustment\n-        // added to the expression from the outside context, so we do not store\n-        // an explicit adjustment, but rather we hardwire the single deref\n-        // that occurs in trans and mem_categorization.\n-        if self.self_expr.is_none() {\n-            return None;\n-        }\n-\n-        let (self_ty, auto_deref_ref) = self.consider_reborrow(self_ty, autoderefs);\n-        let adjustment = Some((self.self_expr.unwrap().id, ty::AdjustDerefRef(auto_deref_ref)));\n-\n-        match self.search_for_method(self_ty) {\n-            None => {\n-                None\n-            }\n-            Some(Ok(method)) => {\n-                debug!(\"(searching for autoderef'd method) writing \\\n-                       adjustment {} for {}\", adjustment, self.ty_to_string(self_ty));\n-                match adjustment {\n-                    Some((self_expr_id, adj)) => {\n-                        self.fcx.write_adjustment(self_expr_id, self.span, adj);\n-                    }\n-                    None => {}\n-                }\n-                Some(Ok(method))\n-            }\n-            Some(Err(error)) => {\n-                Some(Err(error))\n-            }\n-        }\n-    }\n-\n-    fn consider_reborrow(&self,\n-                         self_ty: ty::t,\n-                         autoderefs: uint)\n-                         -> (ty::t, ty::AutoDerefRef) {\n-        /*!\n-         * In the event that we are invoking a method with a receiver\n-         * of a borrowed type like `&T`, `&mut T`, or `&mut [T]`,\n-         * we will \"reborrow\" the receiver implicitly.  For example, if\n-         * you have a call `r.inc()` and where `r` has type `&mut T`,\n-         * then we treat that like `(&mut *r).inc()`.  This avoids\n-         * consuming the original pointer.\n-         *\n-         * You might think that this would be a natural byproduct of\n-         * the auto-deref/auto-ref process.  This is true for `Box<T>`\n-         * but not for an `&mut T` receiver.  With `Box<T>`, we would\n-         * begin by testing for methods with a self type `Box<T>`,\n-         * then autoderef to `T`, then autoref to `&mut T`.  But with\n-         * an `&mut T` receiver the process begins with `&mut T`, only\n-         * without any autoadjustments.\n-         */\n-\n-        let tcx = self.tcx();\n-        return match ty::get(self_ty).sty {\n-            ty::ty_rptr(_, self_mt) if default_method_hack(self_mt) => {\n-                (self_ty,\n-                 ty::AutoDerefRef {\n-                     autoderefs: autoderefs,\n-                     autoref: None})\n-            }\n-            ty::ty_rptr(_, self_mt) => {\n-                let region =\n-                    self.infcx().next_region_var(infer::Autoref(self.span));\n-                (ty::mk_rptr(tcx, region, self_mt),\n-                 ty::AutoDerefRef {\n-                     autoderefs: autoderefs + 1,\n-                     autoref: Some(ty::AutoPtr(region, self_mt.mutbl, None))})\n-            }\n-            _ => {\n-                (self_ty,\n-                 ty::AutoDerefRef {\n-                     autoderefs: autoderefs,\n-                     autoref: None})\n-            }\n-        };\n-\n-        fn default_method_hack(self_mt: ty::mt) -> bool {\n-            // FIXME(#6129). Default methods can't deal with autoref.\n-            //\n-            // I am a horrible monster and I pray for death. Currently\n-            // the default method code panics when you try to reborrow\n-            // because it is not handling types correctly. In lieu of\n-            // fixing that, I am introducing this horrible hack. - ndm\n-            self_mt.mutbl == MutImmutable && ty::type_is_self(self_mt.ty)\n-        }\n-    }\n-\n-    // Takes an [T] - an unwrapped DST pointer (either ~ or &)\n-    // [T] to &[T] or &&[T] (note that we started with a &[T] or ~[T] which has\n-    // been implicitly derefed).\n-    fn auto_slice_vec(&self, ty: ty::t, autoderefs: uint)\n-                      -> Option<MethodResult>\n-    {\n-        let tcx = self.tcx();\n-        debug!(\"auto_slice_vec {}\", ppaux::ty_to_string(tcx, ty));\n-\n-        // First try to borrow to a slice\n-        let entry = self.search_for_some_kind_of_autorefd_method(\n-            |r, m| AutoPtr(r, m, None), autoderefs, &[MutImmutable, MutMutable],\n-            |m,r| ty::mk_slice(tcx, r,\n-                               ty::mt {ty:ty, mutbl:m}));\n-\n-        if entry.is_some() {\n-            return entry;\n-        }\n-\n-        // Then try to borrow to a slice *and* borrow a pointer.\n-        self.search_for_some_kind_of_autorefd_method(\n-            |r, m| AutoPtr(r, ast::MutImmutable, Some( box AutoPtr(r, m, None))),\n-            autoderefs, &[MutImmutable, MutMutable],\n-            |m, r| {\n-                let slice_ty = ty::mk_slice(tcx, r,\n-                                            ty::mt {ty:ty, mutbl:m});\n-                // NB: we do not try to autoref to a mutable\n-                // pointer. That would be creating a pointer\n-                // to a temporary pointer (the borrowed\n-                // slice), so any update the callee makes to\n-                // it can't be observed.\n-                ty::mk_rptr(tcx, r, ty::mt {ty:slice_ty, mutbl:MutImmutable})\n-            })\n-    }\n-\n-    // [T, ..len] -> [T] or &[T] or &&[T]\n-    fn auto_unsize_vec(&self, ty: ty::t, autoderefs: uint, len: uint) -> Option<MethodResult> {\n-        let tcx = self.tcx();\n-        debug!(\"auto_unsize_vec {}\", ppaux::ty_to_string(tcx, ty));\n-\n-        // First try to borrow to an unsized vec.\n-        let entry = self.search_for_some_kind_of_autorefd_method(\n-            |_r, _m| AutoUnsize(ty::UnsizeLength(len)),\n-            autoderefs, &[MutImmutable, MutMutable],\n-            |_m, _r| ty::mk_vec(tcx, ty, None));\n-\n-        if entry.is_some() {\n-            return entry;\n-        }\n-\n-        // Then try to borrow to a slice.\n-        let entry = self.search_for_some_kind_of_autorefd_method(\n-            |r, m| AutoPtr(r, m, Some(box AutoUnsize(ty::UnsizeLength(len)))),\n-            autoderefs, &[MutImmutable, MutMutable],\n-            |m, r|  ty::mk_slice(tcx, r, ty::mt {ty:ty, mutbl:m}));\n-\n-        if entry.is_some() {\n-            return entry;\n-        }\n-\n-        // Then try to borrow to a slice *and* borrow a pointer.\n-        self.search_for_some_kind_of_autorefd_method(\n-            |r, m| AutoPtr(r, m,\n-                           Some(box AutoPtr(r, m,\n-                                            Some(box AutoUnsize(ty::UnsizeLength(len)))))),\n-            autoderefs, &[MutImmutable, MutMutable],\n-            |m, r| {\n-                let slice_ty = ty::mk_slice(tcx, r, ty::mt {ty:ty, mutbl:m});\n-                ty::mk_rptr(tcx, r, ty::mt {ty:slice_ty, mutbl:MutImmutable})\n-            })\n-    }\n-\n-    fn auto_slice_str(&self, autoderefs: uint) -> Option<MethodResult> {\n-        let tcx = self.tcx();\n-        debug!(\"auto_slice_str\");\n-\n-        let entry = self.search_for_some_kind_of_autorefd_method(\n-            |r, m| AutoPtr(r, m, None), autoderefs, &[MutImmutable],\n-            |_m, r| ty::mk_str_slice(tcx, r, MutImmutable));\n-\n-        if entry.is_some() {\n-            return entry;\n-        }\n-\n-        self.search_for_some_kind_of_autorefd_method(\n-            |r, m| AutoPtr(r, ast::MutImmutable, Some( box AutoPtr(r, m, None))),\n-            autoderefs, &[MutImmutable],\n-            |m, r| {\n-                let slice_ty = ty::mk_str_slice(tcx, r, m);\n-                ty::mk_rptr(tcx, r, ty::mt {ty:slice_ty, mutbl:m})\n-            })\n-    }\n-\n-    // Coerce Box/&Trait instances to &Trait.\n-    fn auto_slice_trait(&self, ty: ty::t, autoderefs: uint) -> Option<MethodResult> {\n-        debug!(\"auto_slice_trait\");\n-        match ty::get(ty).sty {\n-            ty_trait(box ty::TyTrait { ref principal,\n-                                       bounds: b,\n-                                       .. }) => {\n-                let trt_did = principal.def_id;\n-                let trt_substs = &principal.substs;\n-                let tcx = self.tcx();\n-                self.search_for_some_kind_of_autorefd_method(\n-                    |r, m| AutoPtr(r, m, None),\n-                    autoderefs, &[MutImmutable, MutMutable],\n-                    |m, r| {\n-                        let principal = ty::TraitRef::new(trt_did,\n-                                                          trt_substs.clone());\n-                        let tr = ty::mk_trait(tcx, principal, b);\n-                        ty::mk_rptr(tcx, r, ty::mt{ ty: tr, mutbl: m })\n-                    })\n-            }\n-            _ => panic!(\"Expected ty_trait in auto_slice_trait\")\n-        }\n-    }\n-\n-    fn search_for_autofatptrd_method(&self,\n-                                     self_ty: ty::t,\n-                                     autoderefs: uint)\n-                                     -> Option<MethodResult>\n-    {\n-        /*!\n-         * Searches for a candidate by converting things like\n-         * `~[]` to `&[]`.\n-         */\n-\n-        let tcx = self.tcx();\n-        debug!(\"search_for_autofatptrd_method {}\", ppaux::ty_to_string(tcx, self_ty));\n-\n-        let sty = ty::get(self_ty).sty.clone();\n-        match sty {\n-            ty_vec(ty, Some(len)) => self.auto_unsize_vec(ty, autoderefs, len),\n-            ty_vec(ty, None) => self.auto_slice_vec(ty, autoderefs),\n-            ty_str => self.auto_slice_str(autoderefs),\n-            ty_trait(..) => self.auto_slice_trait(self_ty, autoderefs),\n-\n-            ty_closure(..) => {\n-                // This case should probably be handled similarly to\n-                // Trait instances.\n-                None\n-            }\n-\n-            _ => None\n-        }\n-    }\n-\n-    fn search_for_autoptrd_method(&self, self_ty: ty::t, autoderefs: uint)\n-                                  -> Option<MethodResult>\n-    {\n-        /*!\n-         *\n-         * Converts any type `T` to `&M T` where `M` is an\n-         * appropriate mutability.\n-         */\n-\n-        let tcx = self.tcx();\n-        match ty::get(self_ty).sty {\n-            ty_bare_fn(..) | ty_uniq(..) | ty_rptr(..) |\n-            ty_infer(IntVar(_)) |\n-            ty_infer(FloatVar(_)) |\n-            ty_param(..) | ty_bool |\n-            ty_char | ty_int(..) | ty_uint(..) |\n-            ty_float(..) | ty_enum(..) | ty_ptr(..) | ty_struct(..) |\n-            ty_unboxed_closure(..) | ty_tup(..) | ty_open(..) |\n-            ty_str | ty_vec(..) | ty_trait(..) | ty_closure(..) => {\n-                self.search_for_some_kind_of_autorefd_method(\n-                    |r, m| AutoPtr(r, m, None), autoderefs, &[MutImmutable, MutMutable],\n-                    |m,r| ty::mk_rptr(tcx, r, ty::mt {ty:self_ty, mutbl:m}))\n-            }\n-\n-            ty_err => None,\n-\n-            ty_infer(TyVar(_)) |\n-            ty_infer(SkolemizedTy(_)) |\n-            ty_infer(SkolemizedIntTy(_)) => {\n-                self.bug(format!(\"unexpected type: {}\",\n-                                 self.ty_to_string(self_ty)).as_slice());\n-            }\n-        }\n-    }\n-\n-    fn search_for_some_kind_of_autorefd_method(\n-        &self,\n-        kind: |Region, ast::Mutability| -> ty::AutoRef,\n-        autoderefs: uint,\n-        mutbls: &[ast::Mutability],\n-        mk_autoref_ty: |ast::Mutability, ty::Region| -> ty::t)\n-        -> Option<MethodResult>\n-    {\n-        // Hacky. For overloaded derefs, there may be an adjustment\n-        // added to the expression from the outside context, so we do not store\n-        // an explicit adjustment, but rather we hardwire the single deref\n-        // that occurs in trans and mem_categorization.\n-        let self_expr_id = match self.self_expr {\n-            Some(expr) => Some(expr.id),\n-            None => {\n-                assert_eq!(autoderefs, 0);\n-                assert!(kind(ty::ReEmpty, ast::MutImmutable) ==\n-                        ty::AutoPtr(ty::ReEmpty, ast::MutImmutable, None));\n-                None\n-            }\n-        };\n-\n-        // This is hokey. We should have mutability inference as a\n-        // variable.  But for now, try &, then &mut:\n-        let region =\n-            self.infcx().next_region_var(infer::Autoref(self.span));\n-        for mutbl in mutbls.iter() {\n-            let autoref_ty = mk_autoref_ty(*mutbl, region);\n-            match self.search_for_method(autoref_ty) {\n-                None => {}\n-                Some(method) => {\n-                    match self_expr_id {\n-                        Some(self_expr_id) => {\n-                            self.fcx.write_adjustment(\n-                                self_expr_id,\n-                                self.span,\n-                                ty::AdjustDerefRef(ty::AutoDerefRef {\n-                                    autoderefs: autoderefs,\n-                                    autoref: Some(kind(region, *mutbl))\n-                                }));\n-                        }\n-                        None => {}\n-                    }\n-                    return Some(method);\n-                }\n-            }\n-        }\n-        None\n-    }\n-\n-    fn search_for_method(&self, rcvr_ty: ty::t) -> Option<MethodResult> {\n-        debug!(\"search_for_method(rcvr_ty={})\", self.ty_to_string(rcvr_ty));\n-        let _indenter = indenter();\n-\n-        // I am not sure that inherent methods should have higher\n-        // priority, but it is necessary ATM to handle some of the\n-        // existing code.\n-\n-        debug!(\"searching inherent candidates\");\n-        match self.consider_candidates(rcvr_ty, self.inherent_candidates.as_slice()) {\n-            None => {}\n-            Some(mme) => {\n-                return Some(mme);\n-            }\n-        }\n-\n-        debug!(\"searching extension candidates\");\n-        self.consider_extension_candidates(rcvr_ty)\n-    }\n-\n-    fn consider_candidates(&self, rcvr_ty: ty::t,\n-                           candidates: &[Candidate])\n-                           -> Option<MethodResult> {\n-        let relevant_candidates = self.filter_candidates(rcvr_ty, candidates);\n-\n-        if relevant_candidates.len() == 0 {\n-            return None;\n-        }\n-\n-        if relevant_candidates.len() > 1 {\n-            let sources = relevant_candidates.iter()\n-                                             .map(|candidate| candidate.to_source())\n-                                             .collect();\n-            return Some(Err(Ambiguity(sources)));\n-        }\n-\n-        Some(Ok(self.confirm_candidate(rcvr_ty, &relevant_candidates[0])))\n-    }\n-\n-    fn filter_candidates(&self, rcvr_ty: ty::t, candidates: &[Candidate]) -> Vec<Candidate> {\n-        let mut relevant_candidates: Vec<Candidate> = Vec::new();\n-\n-        for candidate_a in candidates.iter().filter(|&c| self.is_relevant(rcvr_ty, c)) {\n-            // Skip this one if we already have one like it\n-            if !relevant_candidates.iter().any(|candidate_b| {\n-                debug!(\"attempting to merge {} and {}\",\n-                       candidate_a.repr(self.tcx()),\n-                       candidate_b.repr(self.tcx()));\n-                match (&candidate_a.origin, &candidate_b.origin) {\n-                    (&MethodTypeParam(ref p1), &MethodTypeParam(ref p2)) => {\n-                        let same_trait =\n-                            p1.trait_ref.def_id == p2.trait_ref.def_id;\n-                        let same_method =\n-                            p1.method_num == p2.method_num;\n-                        // it's ok to compare self-ty with `==` here because\n-                        // they are always a TyParam\n-                        let same_param =\n-                            p1.trait_ref.self_ty() == p2.trait_ref.self_ty();\n-                        same_trait && same_method && same_param\n-                    }\n-                    _ => false\n-                }\n-            }) {\n-                relevant_candidates.push((*candidate_a).clone());\n-            }\n-        }\n-\n-        relevant_candidates\n-    }\n-\n-    fn consider_extension_candidates(&self, rcvr_ty: ty::t)\n-                                     -> Option<MethodResult>\n-    {\n-        let mut selcx = traits::SelectionContext::new(self.infcx(),\n-                                                      &self.fcx.inh.param_env,\n-                                                      self.fcx);\n-\n-        let extension_evaluations: Vec<_> =\n-            self.extension_candidates.iter()\n-            .map(|ext| self.probe_extension_candidate(&mut selcx, rcvr_ty, ext))\n-            .collect();\n-\n-        // How many traits can apply?\n-        let applicable_evaluations_count =\n-            extension_evaluations.iter()\n-                                 .filter(|eval| eval.may_apply())\n-                                 .count();\n-\n-        // Determine whether there are multiple traits that could apply.\n-        if applicable_evaluations_count > 1 {\n-            let sources =\n-                self.extension_candidates.iter()\n-                    .zip(extension_evaluations.iter())\n-                    .filter(|&(_, eval)| eval.may_apply())\n-                    .map(|(ext, _)| ext.to_source())\n-                    .collect();\n-            return Some(Err(Ambiguity(sources)));\n-        }\n-\n-        // Determine whether there are no traits that could apply.\n-        if applicable_evaluations_count == 0 {\n-            return None;\n-        }\n-\n-        // Exactly one trait applies. It itself could *still* be ambiguous thanks\n-        // to coercions.\n-        let applicable_evaluation = extension_evaluations.iter()\n-                                                         .position(|eval| eval.may_apply())\n-                                                         .unwrap();\n-        let match_data = match extension_evaluations[applicable_evaluation] {\n-            traits::MethodMatched(data) => data,\n-            traits::MethodAmbiguous(ref impl_def_ids) => {\n-                let sources = impl_def_ids.iter().map(|&d| ImplSource(d)).collect();\n-                return Some(Err(Ambiguity(sources)));\n-            }\n-            traits::MethodDidNotMatch => {\n-                self.bug(\"Method did not match and yet may_apply() is true\")\n-            }\n-        };\n-\n-        let extension = &self.extension_candidates[applicable_evaluation];\n-\n-        debug!(\"picked extension={}\", extension.repr(self.tcx()));\n-\n-        // We have to confirm the method match. This will cause the type variables\n-        // in the obligation to be appropriately unified based on the subtyping/coercion\n-        // between `rcvr_ty` and `extension.xform_self_ty`.\n-        selcx.confirm_method_match(rcvr_ty, extension.xform_self_ty,\n-                                   &extension.obligation, match_data);\n-\n-        // Finally, construct the candidate, now that everything is\n-        // known, and confirm *that*. Note that whatever we pick\n-        // (impl, whatever) we can always use the same kind of origin\n-        // (trait-based method dispatch).\n-        let candidate = Candidate {\n-            xform_self_ty: extension.xform_self_ty,\n-            rcvr_substs: extension.obligation.trait_ref.substs.clone(),\n-            method_ty: extension.method_ty.clone(),\n-            origin: MethodTypeParam(MethodParam{trait_ref: extension.obligation.trait_ref.clone(),\n-                                                method_num: extension.method_num})\n-        };\n-\n-        // Confirming the candidate will do the final work of\n-        // instantiating late-bound variables, unifying things, and\n-        // registering trait obligations (including\n-        // `extension.obligation`, which should be a requirement of\n-        // the `Self` trait).\n-        let callee = self.confirm_candidate(rcvr_ty, &candidate);\n-\n-        select_new_fcx_obligations(self.fcx);\n-\n-        Some(Ok(callee))\n-    }\n-\n-    fn probe_extension_candidate(&self,\n-                                 selcx: &mut traits::SelectionContext,\n-                                 rcvr_ty: ty::t,\n-                                 candidate: &ExtensionCandidate)\n-                                 -> traits::MethodMatchResult\n-    {\n-        debug!(\"probe_extension_candidate(rcvr_ty={}, candidate.obligation={})\",\n-               rcvr_ty.repr(self.tcx()),\n-               candidate.obligation.repr(self.tcx()));\n-\n-        selcx.evaluate_method_obligation(rcvr_ty, candidate.xform_self_ty, &candidate.obligation)\n-    }\n-\n-    fn confirm_candidate(&self, rcvr_ty: ty::t, candidate: &Candidate)\n-                         -> MethodCallee\n-    {\n-        // This method performs two sets of substitutions, one after the other:\n-        // 1. Substitute values for any type/lifetime parameters from the impl and\n-        //    method declaration into the method type. This is the function type\n-        //    before it is called; it may still include late bound region variables.\n-        // 2. Instantiate any late bound lifetime parameters in the method itself\n-        //    with fresh region variables.\n-\n-        let tcx = self.tcx();\n-\n-        debug!(\"confirm_candidate(rcvr_ty={}, candidate={})\",\n-               self.ty_to_string(rcvr_ty),\n-               candidate.repr(self.tcx()));\n-\n-        let rcvr_substs = candidate.rcvr_substs.clone();\n-        self.enforce_drop_trait_limitations(candidate);\n-\n-        // Determine the values for the generic parameters of the method.\n-        // If they were not explicitly supplied, just construct fresh\n-        // variables.\n-        let num_supplied_tps = self.supplied_tps.len();\n-        let num_method_tps = candidate.method_ty.generics.types.len(subst::FnSpace);\n-        let m_types = {\n-            if num_supplied_tps == 0u {\n-                self.fcx.infcx().next_ty_vars(num_method_tps)\n-            } else if num_method_tps == 0u {\n-                span_err!(tcx.sess, self.span, E0035,\n-                    \"does not take type parameters\");\n-                self.fcx.infcx().next_ty_vars(num_method_tps)\n-            } else if num_supplied_tps != num_method_tps {\n-                span_err!(tcx.sess, self.span, E0036,\n-                    \"incorrect number of type parameters given for this method\");\n-                self.fcx.infcx().next_ty_vars(num_method_tps)\n-            } else {\n-                self.supplied_tps.to_vec()\n-            }\n-        };\n-\n-        // Create subst for early-bound lifetime parameters, combining\n-        // parameters from the type and those from the method.\n-        //\n-        // FIXME -- permit users to manually specify lifetimes\n-        let m_regions =\n-            self.fcx.infcx().region_vars_for_defs(\n-                self.span,\n-                candidate.method_ty.generics.regions.get_slice(subst::FnSpace));\n-\n-        let all_substs = rcvr_substs.with_method(m_types, m_regions);\n-\n-        let ref bare_fn_ty = candidate.method_ty.fty;\n-\n-        // Compute the method type with type parameters substituted\n-        debug!(\"fty={} all_substs={}\",\n-               bare_fn_ty.repr(tcx),\n-               all_substs.repr(tcx));\n-\n-        let fn_sig = bare_fn_ty.sig.subst(tcx, &all_substs);\n-\n-        debug!(\"after subst, fty={}\", fn_sig.repr(tcx));\n-\n-        // Replace any bound regions that appear in the function\n-        // signature with region variables\n-        let fn_sig =\n-            self.replace_late_bound_regions_with_fresh_var(fn_sig.binder_id, &fn_sig);\n-        let transformed_self_ty = fn_sig.inputs[0];\n-        let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n-            sig: fn_sig,\n-            fn_style: bare_fn_ty.fn_style,\n-            abi: bare_fn_ty.abi.clone(),\n-        });\n-        debug!(\"after replacing bound regions, fty={}\", self.ty_to_string(fty));\n-\n-        // Before, we only checked whether self_ty could be a subtype\n-        // of rcvr_ty; now we actually make it so (this may cause\n-        // variables to unify etc).  Since we checked beforehand, and\n-        // nothing has changed in the meantime, this unification\n-        // should never fail.\n-        let span = self.self_expr.map_or(self.span, |e| e.span);\n-        match self.fcx.mk_subty(false, infer::Misc(span),\n-                                rcvr_ty, transformed_self_ty) {\n-            Ok(_) => {}\n-            Err(_) => {\n-                self.bug(format!(\n-                        \"{} was a subtype of {} but now is not?\",\n-                        self.ty_to_string(rcvr_ty),\n-                        self.ty_to_string(transformed_self_ty)).as_slice());\n-            }\n-        }\n-\n-        // FIXME(DST). Super hack. For a method on a trait object\n-        // `Trait`, the generic signature requires that\n-        // `Self:Trait`. Since, for an object, we bind `Self` to the\n-        // type `Trait`, this leads to an obligation\n-        // `Trait:Trait`. Until such time we DST is fully implemented,\n-        // that obligation is not necessarily satisfied. (In the\n-        // future, it would be.)\n-        //\n-        // To sidestep this, we overwrite the binding for `Self` with\n-        // `err` (just for trait objects) when we generate the\n-        // obligations.  This causes us to generate the obligation\n-        // `err:Trait`, and the error type is considered to implement\n-        // all traits, so we're all good. Hack hack hack.\n-        match candidate.origin {\n-            MethodTraitObject(..) => {\n-                let mut temp_substs = all_substs.clone();\n-                temp_substs.types.get_mut_slice(SelfSpace)[0] = ty::mk_err();\n-                self.fcx.add_obligations_for_parameters(\n-                    traits::ObligationCause::misc(self.span),\n-                    &temp_substs,\n-                    &candidate.method_ty.generics);\n-            }\n-            _ => {\n-                self.fcx.add_obligations_for_parameters(\n-                    traits::ObligationCause::misc(self.span),\n-                    &all_substs,\n-                    &candidate.method_ty.generics);\n-            }\n-        }\n-\n-        MethodCallee {\n-            origin: candidate.origin.clone(),\n-            ty: fty,\n-            substs: all_substs\n-        }\n-    }\n-\n-    fn fixup_derefs_on_method_receiver_if_necessary(&self,\n-                                                    method_callee: &MethodCallee) {\n-        let sig = match ty::get(method_callee.ty).sty {\n-            ty::ty_bare_fn(ref f) => f.sig.clone(),\n-            ty::ty_closure(ref f) => f.sig.clone(),\n-            _ => return,\n-        };\n-\n-        match ty::get(sig.inputs[0]).sty {\n-            ty::ty_rptr(_, ty::mt {\n-                ty: _,\n-                mutbl: ast::MutMutable,\n-            }) => {}\n-            _ => return,\n-        }\n-\n-        // Gather up expressions we want to munge.\n-        let mut exprs = Vec::new();\n-        match self.self_expr {\n-            Some(expr) => exprs.push(expr),\n-            None => {}\n-        }\n-        loop {\n-            if exprs.len() == 0 {\n-                break\n-            }\n-            let last = exprs[exprs.len() - 1];\n-            match last.node {\n-                ast::ExprParen(ref expr) |\n-                ast::ExprField(ref expr, _, _) |\n-                ast::ExprTupField(ref expr, _, _) |\n-                ast::ExprSlice(ref expr, _, _, _) |\n-                ast::ExprIndex(ref expr, _) |\n-                ast::ExprUnary(ast::UnDeref, ref expr) => exprs.push(&**expr),\n-                _ => break,\n-            }\n-        }\n-\n-        debug!(\"fixup_derefs_on_method_receiver_if_necessary: exprs={}\",\n-               exprs.repr(self.tcx()));\n-\n-        // Fix up autoderefs and derefs.\n-        for (i, expr) in exprs.iter().rev().enumerate() {\n-            // Count autoderefs.\n-            let autoderef_count = match self.fcx\n-                                            .inh\n-                                            .adjustments\n-                                            .borrow()\n-                                            .get(&expr.id) {\n-                Some(&ty::AdjustDerefRef(ty::AutoDerefRef {\n-                    autoderefs: autoderef_count,\n-                    autoref: _\n-                })) => autoderef_count,\n-                Some(_) | None => 0,\n-            };\n-\n-            debug!(\"fixup_derefs_on_method_receiver_if_necessary: i={} expr={} autoderef_count={}\",\n-                   i, expr.repr(self.tcx()), autoderef_count);\n-\n-            if autoderef_count > 0 {\n-                check::autoderef(self.fcx,\n-                                 expr.span,\n-                                 self.fcx.expr_ty(*expr),\n-                                 Some(expr.id),\n-                                 PreferMutLvalue,\n-                                 |_, autoderefs| {\n-                                     if autoderefs == autoderef_count + 1 {\n-                                         Some(())\n-                                     } else {\n-                                         None\n-                                     }\n-                                 });\n-            }\n-\n-            // Don't retry the first one or we might infinite loop!\n-            if i != 0 {\n-                match expr.node {\n-                    ast::ExprIndex(ref base_expr, _) => {\n-                        let mut base_adjustment =\n-                            match self.fcx.inh.adjustments.borrow().get(&base_expr.id) {\n-                                Some(&ty::AdjustDerefRef(ref adr)) => (*adr).clone(),\n-                                None => ty::AutoDerefRef { autoderefs: 0, autoref: None },\n-                                Some(_) => {\n-                                    self.tcx().sess.span_bug(\n-                                        base_expr.span,\n-                                        \"unexpected adjustment type\");\n-                                }\n-                            };\n-\n-                        // If this is an overloaded index, the\n-                        // adjustment will include an extra layer of\n-                        // autoref because the method is an &self/&mut\n-                        // self method. We have to peel it off to get\n-                        // the raw adjustment that `try_index_step`\n-                        // expects. This is annoying and horrible. We\n-                        // ought to recode this routine so it doesn't\n-                        // (ab)use the normal type checking paths.\n-                        base_adjustment.autoref = match base_adjustment.autoref {\n-                            None => { None }\n-                            Some(AutoPtr(_, _, None)) => { None }\n-                            Some(AutoPtr(_, _, Some(box r))) => { Some(r) }\n-                            Some(_) => {\n-                                self.tcx().sess.span_bug(\n-                                    base_expr.span,\n-                                    \"unexpected adjustment autoref\");\n-                            }\n-                        };\n-\n-                        let adjusted_base_ty =\n-                            self.fcx.adjust_expr_ty(\n-                                &**base_expr,\n-                                Some(&ty::AdjustDerefRef(base_adjustment.clone())));\n-\n-                        check::try_index_step(\n-                            self.fcx,\n-                            MethodCall::expr(expr.id),\n-                            *expr,\n-                            &**base_expr,\n-                            adjusted_base_ty,\n-                            base_adjustment,\n-                            PreferMutLvalue);\n-                    }\n-                    ast::ExprUnary(ast::UnDeref, ref base_expr) => {\n-                        // if this is an overloaded deref, then re-evaluate with\n-                        // a preference for mut\n-                        let method_call = MethodCall::expr(expr.id);\n-                        if self.fcx.inh.method_map.borrow().contains_key(&method_call) {\n-                            check::try_overloaded_deref(\n-                                self.fcx,\n-                                expr.span,\n-                                Some(method_call),\n-                                Some(&**base_expr),\n-                                self.fcx.expr_ty(&**base_expr),\n-                                PreferMutLvalue);\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-        }\n-    }\n-\n-    fn enforce_drop_trait_limitations(&self, candidate: &Candidate) {\n-        // No code can call the finalize method explicitly.\n-        let bad = match candidate.origin {\n-            MethodStatic(method_id) => {\n-                self.tcx().destructors.borrow().contains(&method_id)\n-            }\n-            MethodStaticUnboxedClosure(_) => {\n-                false\n-            }\n-            MethodTypeParam(MethodParam { ref trait_ref, .. }) |\n-            MethodTraitObject(MethodObject { ref trait_ref, .. }) => {\n-                Some(trait_ref.def_id) == self.tcx().lang_items.drop_trait()\n-            }\n-        };\n-\n-        if bad {\n-            span_err!(self.tcx().sess, self.span, E0040,\n-                \"explicit call to destructor\");\n-        }\n-    }\n-\n-    // `rcvr_ty` is the type of the expression. It may be a subtype of a\n-    // candidate method's `self_ty`.\n-    fn is_relevant(&self, rcvr_ty: ty::t, candidate: &Candidate) -> bool {\n-        debug!(\"is_relevant(rcvr_ty={}, candidate={})\",\n-               self.ty_to_string(rcvr_ty), candidate.repr(self.tcx()));\n-\n-        infer::can_mk_subty(self.infcx(), rcvr_ty, candidate.xform_self_ty).is_ok()\n-    }\n-\n-    fn infcx(&'a self) -> &'a infer::InferCtxt<'a, 'tcx> {\n-        &self.fcx.inh.infcx\n-    }\n-\n-    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n-        self.fcx.tcx()\n-    }\n-\n-    fn ty_to_string(&self, t: ty::t) -> String {\n-        self.fcx.infcx().ty_to_string(t)\n-    }\n-\n-    fn bug(&self, s: &str) -> ! {\n-        self.tcx().sess.span_bug(self.span, s)\n-    }\n-\n-    fn has_applicable_self(&self, method: &ty::Method) -> bool {\n-        // \"fast track\" -- check for usage of sugar\n-        match method.explicit_self {\n-            StaticExplicitSelfCategory => {\n-                // fallthrough\n-            }\n-            ByValueExplicitSelfCategory |\n-            ByReferenceExplicitSelfCategory(..) |\n-            ByBoxExplicitSelfCategory => {\n-                return true;\n-            }\n-        }\n-\n-        // FIXME -- check for types that deref to `Self`,\n-        // like `Rc<Self>` and so on.\n-        //\n-        // Note also that the current code will break if this type\n-        // includes any of the type parameters defined on the method\n-        // -- but this could be overcome.\n-        return false;\n-    }\n-\n-    fn record_static_candidate(&mut self, source: CandidateSource) {\n-        self.static_candidates.push(source);\n-    }\n-\n-    fn xform_self_ty(&self, method: &Rc<ty::Method>, substs: &subst::Substs) -> ty::t {\n-        let xform_self_ty = method.fty.sig.inputs[0].subst(self.tcx(), substs);\n-        self.replace_late_bound_regions_with_fresh_var(method.fty.sig.binder_id, &xform_self_ty)\n-    }\n-\n-    fn replace_late_bound_regions_with_fresh_var<T>(&self, binder_id: ast::NodeId, value: &T) -> T\n-        where T : TypeFoldable + Repr\n-    {\n-        replace_late_bound_regions_with_fresh_var(self.fcx.infcx(), self.span, binder_id, value)\n-    }\n-}\n-\n-fn replace_late_bound_regions_with_fresh_var<T>(infcx: &infer::InferCtxt,\n-                                                span: Span,\n-                                                binder_id: ast::NodeId,\n-                                                value: &T)\n-                                                -> T\n-    where T : TypeFoldable + Repr\n-{\n-    let (_, value) = replace_late_bound_regions(\n-        infcx.tcx,\n-        binder_id,\n-        value,\n-        |br| infcx.next_region_var(infer::LateBoundRegion(span, br)));\n-    value\n-}\n-\n-fn trait_method(tcx: &ty::ctxt,\n-                trait_def_id: ast::DefId,\n-                method_name: ast::Name)\n-                -> Option<(uint, Rc<ty::Method>)>\n-{\n-    /*!\n-     * Find method with name `method_name` defined in `trait_def_id` and return it,\n-     * along with its index (or `None`, if no such method).\n-     */\n-\n-    let trait_items = ty::trait_items(tcx, trait_def_id);\n-    trait_items\n-        .iter()\n-        .enumerate()\n-        .find(|&(_, ref item)| item.name() == method_name)\n-        .and_then(|(idx, item)| item.as_opt_method().map(|m| (idx, m)))\n-}\n-\n-fn impl_method(tcx: &ty::ctxt,\n-               impl_def_id: ast::DefId,\n-               method_name: ast::Name)\n-               -> Option<Rc<ty::Method>>\n-{\n-    let impl_items = tcx.impl_items.borrow();\n-    let impl_items = impl_items.get(&impl_def_id).unwrap();\n-    impl_items\n-        .iter()\n-        .map(|&did| ty::impl_or_trait_item(tcx, did.def_id()))\n-        .find(|m| m.name() == method_name)\n-        .and_then(|item| item.as_opt_method())\n-}\n-\n-impl Repr for Candidate {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n-        format!(\"Candidate(rcvr_ty={}, rcvr_substs={}, method_ty={}, origin={})\",\n-                self.xform_self_ty.repr(tcx),\n-                self.rcvr_substs.repr(tcx),\n-                self.method_ty.repr(tcx),\n-                self.origin)\n-    }\n-}\n-\n-impl Repr for ExtensionCandidate {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n-        format!(\"ExtensionCandidate(obligation={}, xform_self_ty={}, method_ty={}, method_num={})\",\n-                self.obligation.repr(tcx),\n-                self.xform_self_ty.repr(tcx),\n-                self.method_ty.repr(tcx),\n-                self.method_num)\n-    }\n-}\n-\n-impl Candidate {\n-    fn to_source(&self) -> CandidateSource {\n-        match self.origin {\n-            MethodStatic(def_id) => {\n-                ImplSource(def_id)\n-            }\n-            MethodStaticUnboxedClosure(..) => {\n-                panic!(\"MethodStaticUnboxedClosure only used in trans\")\n-            }\n-            MethodTypeParam(ref param) => {\n-                TraitSource(param.trait_ref.def_id)\n-            }\n-            MethodTraitObject(ref obj) => {\n-                TraitSource(obj.trait_ref.def_id)\n-            }\n-        }\n-    }\n-}\n-\n-impl ExtensionCandidate {\n-    fn to_source(&self) -> CandidateSource {\n-        TraitSource(self.obligation.trait_ref.def_id)\n-    }\n-}"}, {"sha": "ba64a1e23a70f4a3fd8b3b0971ec9eb556bb1702", "filename": "src/librustc/middle/typeck/check/method/confirm.rs", "status": "added", "additions": 603, "deletions": 0, "changes": 603, "blob_url": "https://github.com/rust-lang/rust/blob/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=f8403aac81d5720bb722a85a9120c14ceb763eb9", "patch": "@@ -0,0 +1,603 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::probe;\n+\n+use middle::subst;\n+use middle::subst::Subst;\n+use middle::traits;\n+use middle::ty;\n+use middle::typeck::check;\n+use middle::typeck::check::{FnCtxt, NoPreference, PreferMutLvalue};\n+use middle::typeck::{MethodCall, MethodCallee, MethodObject, MethodOrigin,\n+                     MethodParam, MethodStatic, MethodTraitObject, MethodTypeParam};\n+use middle::typeck::infer;\n+use middle::typeck::infer::InferCtxt;\n+use syntax::ast;\n+use syntax::codemap::Span;\n+use std::rc::Rc;\n+use std::mem;\n+use util::ppaux::Repr;\n+\n+struct ConfirmContext<'a, 'tcx:'a> {\n+    fcx: &'a FnCtxt<'a, 'tcx>,\n+    span: Span,\n+    self_expr: &'a ast::Expr,\n+}\n+\n+pub fn confirm(fcx: &FnCtxt,\n+               span: Span,\n+               self_expr: &ast::Expr,\n+               unadjusted_self_ty: ty::t,\n+               pick: probe::Pick,\n+               supplied_method_types: Vec<ty::t>)\n+               -> MethodCallee\n+{\n+    debug!(\"confirm(unadjusted_self_ty={}, pick={}, supplied_method_types={})\",\n+           unadjusted_self_ty.repr(fcx.tcx()),\n+           pick.repr(fcx.tcx()),\n+           supplied_method_types.repr(fcx.tcx()));\n+\n+    let mut confirm_cx = ConfirmContext::new(fcx, span, self_expr);\n+    confirm_cx.confirm(unadjusted_self_ty, pick, supplied_method_types)\n+}\n+\n+impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n+    fn new(fcx: &'a FnCtxt<'a, 'tcx>,\n+           span: Span,\n+           self_expr: &'a ast::Expr)\n+           -> ConfirmContext<'a, 'tcx>\n+    {\n+        ConfirmContext { fcx: fcx, span: span, self_expr: self_expr }\n+    }\n+\n+    fn confirm(&mut self,\n+               unadjusted_self_ty: ty::t,\n+               pick: probe::Pick,\n+               supplied_method_types: Vec<ty::t>)\n+               -> MethodCallee\n+    {\n+        // Adjust the self expression the user provided and obtain the adjusted type.\n+        let self_ty = self.adjust_self_ty(unadjusted_self_ty, &pick.adjustment);\n+\n+        // Make sure nobody calls `drop()` explicitly.\n+        self.enforce_drop_trait_limitations(&pick);\n+\n+        // Create substitutions for the method's type parameters.\n+        let (rcvr_substs, method_origin) =\n+            self.fresh_receiver_substs(self_ty, &pick);\n+        let (method_types, method_regions) =\n+            self.instantiate_method_substs(&pick, supplied_method_types);\n+        let all_substs = rcvr_substs.with_method(method_types, method_regions);\n+        debug!(\"all_substs={}\", all_substs.repr(self.tcx()));\n+\n+        // Create the final signature for the method, replacing late-bound regions.\n+        let method_sig = self.instantiate_method_sig(&pick, &all_substs);\n+        let method_self_ty = method_sig.inputs[0];\n+\n+        // Unify the (adjusted) self type with what the method expects.\n+        self.unify_receivers(self_ty, method_self_ty);\n+\n+        // Add any trait/regions obligations specified on the method's type parameters.\n+        self.add_obligations(&pick, &all_substs);\n+\n+        // Create the final `MethodCallee`.\n+        let fty = ty::mk_bare_fn(self.tcx(), ty::BareFnTy {\n+            sig: method_sig,\n+            fn_style: pick.method_ty.fty.fn_style,\n+            abi: pick.method_ty.fty.abi.clone(),\n+        });\n+        let callee = MethodCallee {\n+            origin: method_origin,\n+            ty: fty,\n+            substs: all_substs\n+        };\n+\n+        // If this is an `&mut self` method, bias the receiver\n+        // expression towards mutability (this will switch\n+        // e.g. `Deref` to `DerefMut` in oveloaded derefs and so on).\n+        self.fixup_derefs_on_method_receiver_if_necessary(&callee);\n+\n+        callee\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // ADJUSTMENTS\n+\n+    fn adjust_self_ty(&mut self,\n+                      unadjusted_self_ty: ty::t,\n+                      adjustment: &probe::PickAdjustment)\n+                      -> ty::t\n+    {\n+        // Construct the actual adjustment and write it into the table\n+        let auto_deref_ref = self.create_ty_adjustment(adjustment);\n+\n+        // Commit the autoderefs by calling `autoderef again, but this\n+        // time writing the results into the various tables.\n+        let (autoderefd_ty, n, result) =\n+            check::autoderef(\n+                self.fcx, self.span, unadjusted_self_ty, Some(self.self_expr.id), NoPreference,\n+                |_, n| if n == auto_deref_ref.autoderefs { Some(()) } else { None });\n+        assert_eq!(n, auto_deref_ref.autoderefs);\n+        assert_eq!(result, Some(()));\n+\n+        let final_ty =\n+            ty::adjust_ty_for_autoref(self.tcx(), self.span, autoderefd_ty,\n+                                      auto_deref_ref.autoref.as_ref());\n+\n+        // Write out the final adjustment.\n+        self.fcx.write_adjustment(self.self_expr.id, self.span, ty::AdjustDerefRef(auto_deref_ref));\n+\n+        final_ty\n+    }\n+\n+    fn create_ty_adjustment(&mut self,\n+                            adjustment: &probe::PickAdjustment)\n+                            -> ty::AutoDerefRef\n+    {\n+        match *adjustment {\n+            probe::AutoDeref(num) => {\n+                ty::AutoDerefRef {\n+                    autoderefs: num,\n+                    autoref: None\n+                }\n+            }\n+            probe::AutoUnsizeLength(autoderefs, len) => {\n+                ty::AutoDerefRef {\n+                    autoderefs: autoderefs,\n+                    autoref: Some(ty::AutoUnsize(ty::UnsizeLength(len)))\n+                }\n+            }\n+            probe::AutoRef(mutability, ref sub_adjustment) => {\n+                let deref = self.create_ty_adjustment(&**sub_adjustment);\n+                let region = self.infcx().next_region_var(infer::Autoref(self.span));\n+                wrap_autoref(deref, |base| ty::AutoPtr(region, mutability, base))\n+            }\n+        }\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    //\n+\n+    fn fresh_receiver_substs(&mut self,\n+                             self_ty: ty::t,\n+                             pick: &probe::Pick)\n+                             -> (subst::Substs, MethodOrigin)\n+    {\n+        /*!\n+         * Returns a set of substitutions for the method *receiver*\n+         * where all type and region parameters are instantiated with\n+         * fresh variables. This substitution does not include any\n+         * parameters declared on the method itself.\n+         */\n+\n+        match pick.kind {\n+            probe::InherentImplPick(impl_def_id) => {\n+                assert!(ty::impl_trait_ref(self.tcx(), impl_def_id).is_none(),\n+                        \"impl {} is not an inherent impl\", impl_def_id);\n+                let impl_polytype = check::impl_self_ty(self.fcx, self.span, impl_def_id);\n+\n+                (impl_polytype.substs, MethodStatic(pick.method_ty.def_id))\n+            }\n+\n+            probe::ObjectPick(trait_def_id, method_num, real_index) => {\n+                self.extract_trait_ref(self_ty, |this, object_ty, data| {\n+                    // The object data has no entry for the Self\n+                    // Type. For the purposes of this method call, we\n+                    // substitute the object type itself. This\n+                    // wouldn't be a sound substitution in all cases,\n+                    // since each instance of the object type is a\n+                    // different existential and hence could match\n+                    // distinct types (e.g., if `Self` appeared as an\n+                    // argument type), but those cases have already\n+                    // been ruled out when we deemed the trait to be\n+                    // \"object safe\".\n+                    let substs = data.principal.substs.clone().with_self_ty(object_ty);\n+                    let original_trait_ref =\n+                        Rc::new(ty::TraitRef::new(data.principal.def_id, substs));\n+                    let upcast_trait_ref = this.upcast(original_trait_ref.clone(), trait_def_id);\n+                    debug!(\"original_trait_ref={} upcast_trait_ref={} target_trait={}\",\n+                           original_trait_ref.repr(this.tcx()),\n+                           upcast_trait_ref.repr(this.tcx()),\n+                           trait_def_id.repr(this.tcx()));\n+                    let substs = upcast_trait_ref.substs.clone();\n+                    let origin = MethodTraitObject(MethodObject {\n+                        trait_ref: upcast_trait_ref,\n+                        object_trait_id: trait_def_id,\n+                        method_num: method_num,\n+                        real_index: real_index,\n+                    });\n+                    (substs, origin)\n+                })\n+            }\n+\n+            probe::ExtensionImplPick(impl_def_id, method_num) => {\n+                // The method being invoked is the method as defined on the trait,\n+                // so return the substitutions from the trait. Consider:\n+                //\n+                //     impl<A,B,C> Trait<A,B> for Foo<C> { ... }\n+                //\n+                // If we instantiate A, B, and C with $A, $B, and $C\n+                // respectively, then we want to return the type\n+                // parameters from the trait ([$A,$B]), not those from\n+                // the impl ([$A,$B,$C]) not the receiver type ([$C]).\n+                let impl_polytype = check::impl_self_ty(self.fcx, self.span, impl_def_id);\n+                let impl_trait_ref = ty::impl_trait_ref(self.tcx(), impl_def_id)\n+                                     .unwrap()\n+                                     .subst(self.tcx(), &impl_polytype.substs);\n+                let origin = MethodTypeParam(MethodParam { trait_ref: impl_trait_ref.clone(),\n+                                                           method_num: method_num });\n+                (impl_trait_ref.substs.clone(), origin)\n+            }\n+\n+            probe::TraitPick(trait_def_id, method_num) => {\n+                let trait_def = ty::lookup_trait_def(self.tcx(), trait_def_id);\n+\n+                // Make a trait reference `$0 : Trait<$1...$n>`\n+                // consisting entirely of type variables. Later on in\n+                // the process we will unify the transformed-self-type\n+                // of the method with the actual type in order to\n+                // unify some of these variables.\n+                let substs = self.infcx().fresh_substs_for_trait(self.span,\n+                                                                 &trait_def.generics,\n+                                                                 self.infcx().next_ty_var());\n+\n+                let trait_ref = Rc::new(ty::TraitRef::new(trait_def_id, substs.clone()));\n+                let origin = MethodTypeParam(MethodParam { trait_ref: trait_ref,\n+                                                           method_num: method_num });\n+                (substs, origin)\n+            }\n+\n+            probe::WhereClausePick(ref trait_ref, method_num) => {\n+                let origin = MethodTypeParam(MethodParam { trait_ref: (*trait_ref).clone(),\n+                                                           method_num: method_num });\n+                (trait_ref.substs.clone(), origin)\n+            }\n+        }\n+    }\n+\n+    fn extract_trait_ref<R>(&mut self,\n+                            self_ty: ty::t,\n+                            closure: |&mut ConfirmContext<'a,'tcx>, ty::t, &ty::TyTrait| -> R)\n+                            -> R\n+    {\n+        // If we specified that this is an object method, then the\n+        // self-type ought to be something that can be dereferenced to\n+        // yield an object-type (e.g., `&Object` or `Box<Object>`\n+        // etc).\n+\n+        let (_, _, result) =\n+            check::autoderef(\n+                self.fcx, self.span, self_ty, None, NoPreference,\n+                |ty, _| {\n+                    match ty::get(ty).sty {\n+                        ty::ty_trait(ref data) => Some(closure(self, ty, &**data)),\n+                        _ => None,\n+                    }\n+                });\n+\n+        match result {\n+            Some(r) => r,\n+            None => {\n+                self.tcx().sess.span_bug(\n+                    self.span,\n+                    format!(\"self-type `{}` for ObjectPick never dereferenced to an object\",\n+                            self_ty.repr(self.tcx()))[])\n+            }\n+        }\n+    }\n+\n+    fn instantiate_method_substs(&mut self,\n+                                 pick: &probe::Pick,\n+                                 supplied_method_types: Vec<ty::t>)\n+                                 -> (Vec<ty::t>, Vec<ty::Region>)\n+    {\n+        // Determine the values for the generic parameters of the method.\n+        // If they were not explicitly supplied, just construct fresh\n+        // variables.\n+        let num_supplied_types = supplied_method_types.len();\n+        let num_method_types = pick.method_ty.generics.types.len(subst::FnSpace);\n+        let method_types = {\n+            if num_supplied_types == 0u {\n+                self.fcx.infcx().next_ty_vars(num_method_types)\n+            } else if num_method_types == 0u {\n+                span_err!(self.tcx().sess, self.span, E0035,\n+                    \"does not take type parameters\");\n+                self.fcx.infcx().next_ty_vars(num_method_types)\n+            } else if num_supplied_types != num_method_types {\n+                span_err!(self.tcx().sess, self.span, E0036,\n+                    \"incorrect number of type parameters given for this method\");\n+                Vec::from_elem(num_method_types, ty::mk_err())\n+            } else {\n+                supplied_method_types\n+            }\n+        };\n+\n+        // Create subst for early-bound lifetime parameters, combining\n+        // parameters from the type and those from the method.\n+        //\n+        // FIXME -- permit users to manually specify lifetimes\n+        let method_regions =\n+            self.fcx.infcx().region_vars_for_defs(\n+                self.span,\n+                pick.method_ty.generics.regions.get_slice(subst::FnSpace));\n+\n+        (method_types, method_regions)\n+    }\n+\n+    fn unify_receivers(&mut self,\n+                       self_ty: ty::t,\n+                       method_self_ty: ty::t)\n+    {\n+        match self.fcx.mk_subty(false, infer::Misc(self.span), self_ty, method_self_ty) {\n+            Ok(_) => {}\n+            Err(_) => {\n+                self.tcx().sess.span_bug(\n+                    self.span,\n+                    format!(\n+                        \"{} was a subtype of {} but now is not?\",\n+                        self_ty.repr(self.tcx()),\n+                        method_self_ty.repr(self.tcx()))[]);\n+            }\n+        }\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    //\n+\n+    fn instantiate_method_sig(&mut self,\n+                              pick: &probe::Pick,\n+                              all_substs: &subst::Substs)\n+                              -> ty::FnSig\n+    {\n+        let ref bare_fn_ty = pick.method_ty.fty;\n+        let fn_sig = bare_fn_ty.sig.subst(self.tcx(), all_substs);\n+        self.infcx().replace_late_bound_regions_with_fresh_var(fn_sig.binder_id,\n+                                                               self.span,\n+                                                               infer::FnCall,\n+                                                               &fn_sig).0\n+    }\n+\n+    fn add_obligations(&mut self,\n+                       pick: &probe::Pick,\n+                       all_substs: &subst::Substs) {\n+        // FIXME(DST). Super hack. For a method on a trait object\n+        // `Trait`, the generic signature requires that\n+        // `Self:Trait`. Since, for an object, we bind `Self` to the\n+        // type `Trait`, this leads to an obligation\n+        // `Trait:Trait`. Until such time we DST is fully implemented,\n+        // that obligation is not necessarily satisfied. (In the\n+        // future, it would be.)\n+        //\n+        // To sidestep this, we overwrite the binding for `Self` with\n+        // `err` (just for trait objects) when we generate the\n+        // obligations.  This causes us to generate the obligation\n+        // `err:Trait`, and the error type is considered to implement\n+        // all traits, so we're all good. Hack hack hack.\n+        match pick.kind {\n+            probe::ObjectPick(..) => {\n+                let mut temp_substs = all_substs.clone();\n+                temp_substs.types.get_mut_slice(subst::SelfSpace)[0] = ty::mk_err();\n+                self.fcx.add_obligations_for_parameters(\n+                    traits::ObligationCause::misc(self.span),\n+                    &temp_substs,\n+                    &pick.method_ty.generics);\n+            }\n+            _ => {\n+                self.fcx.add_obligations_for_parameters(\n+                    traits::ObligationCause::misc(self.span),\n+                    all_substs,\n+                    &pick.method_ty.generics);\n+            }\n+        }\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // RECONCILIATION\n+\n+    fn fixup_derefs_on_method_receiver_if_necessary(&self,\n+                                                    method_callee: &MethodCallee) {\n+        /*!\n+         * When we select a method with an `&mut self` receiver, we have to go\n+         * convert any auto-derefs, indices, etc from `Deref` and `Index` into\n+         * `DerefMut` and `IndexMut` respectively.\n+         */\n+\n+        let sig = match ty::get(method_callee.ty).sty {\n+            ty::ty_bare_fn(ref f) => f.sig.clone(),\n+            ty::ty_closure(ref f) => f.sig.clone(),\n+            _ => return,\n+        };\n+\n+        match ty::get(sig.inputs[0]).sty {\n+            ty::ty_rptr(_, ty::mt {\n+                ty: _,\n+                mutbl: ast::MutMutable,\n+            }) => {}\n+            _ => return,\n+        }\n+\n+        // Gather up expressions we want to munge.\n+        let mut exprs = Vec::new();\n+        exprs.push(self.self_expr);\n+        loop {\n+            let last = exprs[exprs.len() - 1];\n+            match last.node {\n+                ast::ExprParen(ref expr) |\n+                ast::ExprField(ref expr, _, _) |\n+                ast::ExprTupField(ref expr, _, _) |\n+                ast::ExprSlice(ref expr, _, _, _) |\n+                ast::ExprIndex(ref expr, _) |\n+                ast::ExprUnary(ast::UnDeref, ref expr) => exprs.push(&**expr),\n+                _ => break,\n+            }\n+        }\n+\n+        debug!(\"fixup_derefs_on_method_receiver_if_necessary: exprs={}\",\n+               exprs.repr(self.tcx()));\n+\n+        // Fix up autoderefs and derefs.\n+        for (i, expr) in exprs.iter().rev().enumerate() {\n+            // Count autoderefs.\n+            let autoderef_count = match self.fcx\n+                                            .inh\n+                                            .adjustments\n+                                            .borrow()\n+                                            .get(&expr.id) {\n+                Some(&ty::AdjustDerefRef(ty::AutoDerefRef {\n+                    autoderefs: autoderef_count,\n+                    autoref: _\n+                })) => autoderef_count,\n+                Some(_) | None => 0,\n+            };\n+\n+            debug!(\"fixup_derefs_on_method_receiver_if_necessary: i={} expr={} autoderef_count={}\",\n+                   i, expr.repr(self.tcx()), autoderef_count);\n+\n+            if autoderef_count > 0 {\n+                check::autoderef(self.fcx,\n+                                 expr.span,\n+                                 self.fcx.expr_ty(*expr),\n+                                 Some(expr.id),\n+                                 PreferMutLvalue,\n+                                 |_, autoderefs| {\n+                                     if autoderefs == autoderef_count + 1 {\n+                                         Some(())\n+                                     } else {\n+                                         None\n+                                     }\n+                                 });\n+            }\n+\n+            // Don't retry the first one or we might infinite loop!\n+            if i != 0 {\n+                match expr.node {\n+                    ast::ExprIndex(ref base_expr, _) => {\n+                        let mut base_adjustment =\n+                            match self.fcx.inh.adjustments.borrow().get(&base_expr.id) {\n+                                Some(&ty::AdjustDerefRef(ref adr)) => (*adr).clone(),\n+                                None => ty::AutoDerefRef { autoderefs: 0, autoref: None },\n+                                Some(_) => {\n+                                    self.tcx().sess.span_bug(\n+                                        base_expr.span,\n+                                        \"unexpected adjustment type\");\n+                                }\n+                            };\n+\n+                        // If this is an overloaded index, the\n+                        // adjustment will include an extra layer of\n+                        // autoref because the method is an &self/&mut\n+                        // self method. We have to peel it off to get\n+                        // the raw adjustment that `try_index_step`\n+                        // expects. This is annoying and horrible. We\n+                        // ought to recode this routine so it doesn't\n+                        // (ab)use the normal type checking paths.\n+                        base_adjustment.autoref = match base_adjustment.autoref {\n+                            None => { None }\n+                            Some(ty::AutoPtr(_, _, None)) => { None }\n+                            Some(ty::AutoPtr(_, _, Some(box r))) => { Some(r) }\n+                            Some(_) => {\n+                                self.tcx().sess.span_bug(\n+                                    base_expr.span,\n+                                    \"unexpected adjustment autoref\");\n+                            }\n+                        };\n+\n+                        let adjusted_base_ty =\n+                            self.fcx.adjust_expr_ty(\n+                                &**base_expr,\n+                                Some(&ty::AdjustDerefRef(base_adjustment.clone())));\n+\n+                        check::try_index_step(\n+                            self.fcx,\n+                            MethodCall::expr(expr.id),\n+                            *expr,\n+                            &**base_expr,\n+                            adjusted_base_ty,\n+                            base_adjustment,\n+                            PreferMutLvalue);\n+                    }\n+                    ast::ExprUnary(ast::UnDeref, ref base_expr) => {\n+                        // if this is an overloaded deref, then re-evaluate with\n+                        // a preference for mut\n+                        let method_call = MethodCall::expr(expr.id);\n+                        if self.fcx.inh.method_map.borrow().contains_key(&method_call) {\n+                            check::try_overloaded_deref(\n+                                self.fcx,\n+                                expr.span,\n+                                Some(method_call),\n+                                Some(&**base_expr),\n+                                self.fcx.expr_ty(&**base_expr),\n+                                PreferMutLvalue);\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // MISCELLANY\n+\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n+        self.fcx.tcx()\n+    }\n+\n+    fn infcx(&self) -> &'a InferCtxt<'a, 'tcx> {\n+        self.fcx.infcx()\n+    }\n+\n+    fn enforce_drop_trait_limitations(&self, pick: &probe::Pick) {\n+        // Disallow calls to the method `drop` defined in the `Drop` trait.\n+        match pick.method_ty.container {\n+            ty::TraitContainer(trait_def_id) => {\n+                if Some(trait_def_id) == self.tcx().lang_items.drop_trait() {\n+                    span_err!(self.tcx().sess, self.span, E0040,\n+                              \"explicit call to destructor\");\n+                }\n+            }\n+            ty::ImplContainer(..) => {\n+                // Since `drop` is a trait method, we expect that any\n+                // potential calls to it will wind up in the other\n+                // arm. But just to be sure, check that the method id\n+                // does not appear in the list of destructors.\n+                assert!(!self.tcx().destructors.borrow().contains(&pick.method_ty.def_id));\n+            }\n+        }\n+    }\n+\n+    fn upcast(&mut self,\n+              source_trait_ref: Rc<ty::TraitRef>,\n+              target_trait_def_id: ast::DefId)\n+              -> Rc<ty::TraitRef>\n+    {\n+        for super_trait_ref in traits::supertraits(self.tcx(), source_trait_ref.clone()) {\n+            if super_trait_ref.def_id == target_trait_def_id {\n+                return super_trait_ref;\n+            }\n+        }\n+\n+        self.tcx().sess.span_bug(\n+            self.span,\n+            format!(\"cannot upcast `{}` to `{}`\",\n+                    source_trait_ref.repr(self.tcx()),\n+                    target_trait_def_id.repr(self.tcx()))[]);\n+    }\n+}\n+\n+fn wrap_autoref(mut deref: ty::AutoDerefRef,\n+                base_fn: |Option<Box<ty::AutoRef>>| -> ty::AutoRef)\n+                -> ty::AutoDerefRef {\n+    let autoref = mem::replace(&mut deref.autoref, None);\n+    let autoref = autoref.map(|r| box r);\n+    deref.autoref = Some(base_fn(autoref));\n+    deref\n+}"}, {"sha": "8c691e02ca9d053f12bd5c195ea05b931ebf7a5d", "filename": "src/librustc/middle/typeck/check/method/doc.rs", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fdoc.rs?ref=f8403aac81d5720bb722a85a9120c14ceb763eb9", "patch": "@@ -0,0 +1,126 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+# Method lookup\n+\n+Method lookup can be rather complex due to the interaction of a number\n+of factors, such as self types, autoderef, trait lookup, etc. This\n+file provides an overview of the process. More detailed notes are in\n+the code itself, naturally.\n+\n+One way to think of method lookup is that we convert an expression of\n+the form:\n+\n+    receiver.method(...)\n+\n+into a more explicit UFCS form:\n+\n+    Trait::method(ADJ(receiver), ...) // for a trait call\n+    ReceiverType::method(ADJ(receiver), ...) // for an inherent method call\n+\n+Here `ADJ` is some kind of adjustment, which is typically a series of\n+autoderefs and then possibly an autoref (e.g., `&**receiver`). However\n+we sometimes do other adjustments and coercions along the way, in\n+particular unsizing (e.g., converting from `[T, ..n]` to `[T]`).\n+\n+## The Two Phases\n+\n+Method lookup is divided into two major phases: probing (`probe.rs`)\n+and confirmation (`confirm.rs`). The probe phase is when we decide\n+what method to call and how to adjust the receiver. The confirmation\n+phase \"applies\" this selection, updating the side-tables, unifying\n+type variables, and otherwise doing side-effectful things.\n+\n+One reason for this division is to be more amenable to caching.  The\n+probe phase produces a \"pick\" (`probe::Pick`), which is designed to be\n+cacheable across method-call sites. Therefore, it does not include\n+inference variables or other information.\n+\n+## Probe phase\n+\n+The probe phase (`probe.rs`) decides what method is being called and\n+how to adjust the receiver.\n+\n+### Steps\n+\n+The first thing that the probe phase does is to create a series of\n+*steps*. This is done by progressively dereferencing the receiver type\n+until it cannot be deref'd anymore, as well as applying an optional\n+\"unsize\" step. So if the receiver has type `Rc<Box<[T, ..3]>>`, this\n+might yield:\n+\n+    Rc<Box<[T, ..3]>>\n+    Box<[T, ..3]>\n+    [T, ..3]\n+    [T]\n+\n+### Candidate assembly\n+\n+We then search along those steps to create a list of *candidates*. A\n+`Candidate` is a method item that might plausibly be the method being\n+invoked. For each candidate, we'll derive a \"transformed self type\"\n+that takes into account explicit self.\n+\n+Candidates are grouped into two kinds, inherent and extension.\n+\n+**Inherent candidates** are those that are derived from the\n+type of the receiver itself.  So, if you have a receiver of some\n+nominal type `Foo` (e.g., a struct), any methods defined within an\n+impl like `impl Foo` are inherent methods.  Nothing needs to be\n+imported to use an inherent method, they are associated with the type\n+itself (note that inherent impls can only be defined in the same\n+module as the type itself).\n+\n+FIXME: Inherent candidates are not always derived from impls.  If you\n+have a trait object, such as a value of type `Box<ToString>`, then the\n+trait methods (`to_string()`, in this case) are inherently associated\n+with it. Another case is type parameters, in which case the methods of\n+their bounds are inherent. However, this part of the rules is subject\n+to change: when DST's \"impl Trait for Trait\" is complete, trait object\n+dispatch could be subsumed into trait matching, and the type parameter\n+behavior should be reconsidered in light of where clauses.\n+\n+**Extension candidates** are derived from imported traits.  If I have\n+the trait `ToString` imported, and I call `to_string()` on a value of\n+type `T`, then we will go off to find out whether there is an impl of\n+`ToString` for `T`.  These kinds of method calls are called \"extension\n+methods\".  They can be defined in any module, not only the one that\n+defined `T`.  Furthermore, you must import the trait to call such a\n+method.\n+\n+So, let's continue our example. Imagine that we were calling a method\n+`foo` with the receiver `Rc<Box<[T, ..3]>>` and there is a trait `Foo`\n+that defines it with `&self` for the type `Rc<U>` as well as a method\n+on the type `Box` that defines `Foo` but with `&mut self`. Then we\n+might have two candidates:\n+\n+    &Rc<Box<[T, ..3]>> from the impl of `Foo` for `Rc<U>` where `U=Box<T, ..3]>\n+    &mut Box<[T, ..3]>> from the inherent impl on `Box<U>` where `U=[T, ..3]`\n+\n+### Candidate search\n+\n+Finally, to actually pick the method, we will search down the steps,\n+trying to match the receiver type against the candidate types. At\n+each step, we also consider an auto-ref and auto-mut-ref to see whether\n+that makes any of the candidates match. We pick the first step where\n+we find a match.\n+\n+In the case of our example, the first step is `Rc<Box<[T, ..3]>>`,\n+which does not itself match any candidate. But when we autoref it, we\n+get the type `&Rc<Box<[T, ..3]>>` which does match. We would then\n+recursively consider all where-clauses that appear on the impl: if\n+those match (or we cannot rule out that they do), then this is the\n+method we would pick. Otherwise, we would continue down the series of\n+steps.\n+\n+*/\n+"}, {"sha": "2cd981370570dec182d8dcccde2e7e451ad58711", "filename": "src/librustc/middle/typeck/check/method/mod.rs", "status": "added", "additions": 432, "deletions": 0, "changes": 432, "blob_url": "https://github.com/rust-lang/rust/blob/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fmod.rs?ref=f8403aac81d5720bb722a85a9120c14ceb763eb9", "patch": "@@ -0,0 +1,432 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*! Method lookup: the secret sauce of Rust. See `doc.rs`. */\n+\n+use middle::subst;\n+use middle::subst::{Subst};\n+use middle::traits;\n+use middle::ty::*;\n+use middle::ty;\n+use middle::typeck::astconv::AstConv;\n+use middle::typeck::check::{FnCtxt};\n+use middle::typeck::check::{impl_self_ty};\n+use middle::typeck::check::vtable;\n+use middle::typeck::check::vtable::select_new_fcx_obligations;\n+use middle::typeck::infer;\n+use middle::typeck::{MethodCallee};\n+use middle::typeck::{MethodParam, MethodTypeParam};\n+use util::ppaux::{Repr, UserString};\n+\n+use std::rc::Rc;\n+use syntax::ast::{DefId};\n+use syntax::ast;\n+use syntax::codemap::Span;\n+\n+mod confirm;\n+mod doc;\n+mod probe;\n+\n+pub enum MethodError {\n+    // Did not find an applicable method, but we did find various\n+    // static methods that may apply.\n+    NoMatch(Vec<CandidateSource>),\n+\n+    // Multiple methods might apply.\n+    Ambiguity(Vec<CandidateSource>),\n+}\n+\n+// A pared down enum describing just the places from which a method\n+// candidate can arise. Used for error reporting only.\n+#[deriving(PartialOrd, Ord, PartialEq, Eq)]\n+pub enum CandidateSource {\n+    ImplSource(ast::DefId),\n+    TraitSource(/* trait id */ ast::DefId),\n+}\n+\n+type MethodIndex = uint; // just for doc purposes\n+\n+pub fn exists(fcx: &FnCtxt,\n+              span: Span,\n+              method_name: ast::Name,\n+              self_ty: ty::t,\n+              call_expr_id: ast::NodeId)\n+              -> bool\n+{\n+    /*!\n+     * Determines whether the type `self_ty` supports a method name `method_name` or not.\n+     */\n+\n+    match probe::probe(fcx, span, method_name, self_ty, call_expr_id) {\n+        Ok(_) => true,\n+        Err(NoMatch(_)) => false,\n+        Err(Ambiguity(_)) => true,\n+    }\n+}\n+\n+pub fn lookup(fcx: &FnCtxt,\n+              span: Span,\n+              method_name: ast::Name,\n+              self_ty: ty::t,\n+              supplied_method_types: Vec<ty::t>,\n+              call_expr_id: ast::NodeId,\n+              self_expr: &ast::Expr)\n+              -> Result<MethodCallee, MethodError>\n+{\n+    /*!\n+     * Performs method lookup. If lookup is successful, it will return the callee\n+     * and store an appropriate adjustment for the self-expr. In some cases it may\n+     * report an error (e.g., invoking the `drop` method).\n+     *\n+     * # Arguments\n+     *\n+     * Given a method call like `foo.bar::<T1,...Tn>(...)`:\n+     *\n+     * - `fcx`:                   the surrounding `FnCtxt` (!)\n+     * - `span`:                  the span for the method call\n+     * - `method_name`:           the name of the method being called (`bar`)\n+     * - `self_ty`:               the (unadjusted) type of the self expression (`foo`)\n+     * - `supplied_method_types`: the explicit method type parameters, if any (`T1..Tn`)\n+     * - `self_expr`:             the self expression (`foo`)\n+     */\n+\n+    debug!(\"lookup(method_name={}, self_ty={}, call_expr_id={}, self_expr={})\",\n+           method_name.repr(fcx.tcx()),\n+           self_ty.repr(fcx.tcx()),\n+           call_expr_id,\n+           self_expr.repr(fcx.tcx()));\n+\n+    let pick = try!(probe::probe(fcx, span, method_name, self_ty, call_expr_id));\n+    Ok(confirm::confirm(fcx, span, self_expr, self_ty, pick, supplied_method_types))\n+}\n+\n+pub fn lookup_in_trait<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n+                                 span: Span,\n+                                 self_expr: Option<&'a ast::Expr>,\n+                                 m_name: ast::Name,\n+                                 trait_def_id: DefId,\n+                                 self_ty: ty::t,\n+                                 opt_input_types: Option<Vec<ty::t>>)\n+                                 -> Option<MethodCallee>\n+{\n+    lookup_in_trait_adjusted(fcx, span, self_expr, m_name, trait_def_id,\n+                             ty::AutoDerefRef { autoderefs: 0, autoref: None },\n+                             self_ty, opt_input_types)\n+}\n+\n+pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n+                                          span: Span,\n+                                          self_expr: Option<&'a ast::Expr>,\n+                                          m_name: ast::Name,\n+                                          trait_def_id: DefId,\n+                                          autoderefref: ty::AutoDerefRef,\n+                                          self_ty: ty::t,\n+                                          opt_input_types: Option<Vec<ty::t>>)\n+                                          -> Option<MethodCallee>\n+{\n+    /*!\n+     * `lookup_in_trait_adjusted` is used for overloaded operators. It\n+     * does a very narrow slice of what the normal probe/confirm path\n+     * does. In particular, it doesn't really do any probing: it\n+     * simply constructs an obligation for a particular trait with the\n+     * given self-type and checks whether that trait is implemented.\n+     *\n+     * FIXME(#18741) -- It seems likely that we can consolidate some of this\n+     * code with the other method-lookup code. In particular,\n+     * autoderef on index is basically identical to autoderef with\n+     * normal probes, except that the test also looks for built-in\n+     * indexing. Also, the second half of this method is basically\n+     * the same as confirmation.\n+     */\n+\n+    debug!(\"lookup_in_trait_adjusted(self_ty={}, self_expr={}, m_name={}, trait_def_id={})\",\n+           self_ty.repr(fcx.tcx()),\n+           self_expr.repr(fcx.tcx()),\n+           m_name.repr(fcx.tcx()),\n+           trait_def_id.repr(fcx.tcx()));\n+\n+    let trait_def = ty::lookup_trait_def(fcx.tcx(), trait_def_id);\n+\n+    let expected_number_of_input_types = trait_def.generics.types.len(subst::TypeSpace);\n+    let input_types = match opt_input_types {\n+        Some(input_types) => {\n+            assert_eq!(expected_number_of_input_types, input_types.len());\n+            input_types\n+        }\n+\n+        None => {\n+            fcx.inh.infcx.next_ty_vars(expected_number_of_input_types)\n+        }\n+    };\n+\n+    let number_assoc_types = trait_def.generics.types.len(subst::AssocSpace);\n+    let assoc_types = fcx.inh.infcx.next_ty_vars(number_assoc_types);\n+\n+    assert_eq!(trait_def.generics.types.len(subst::FnSpace), 0);\n+    assert!(trait_def.generics.regions.is_empty());\n+\n+    // Construct a trait-reference `self_ty : Trait<input_tys>`\n+    let substs = subst::Substs::new_trait(input_types, Vec::new(), assoc_types, self_ty);\n+    let trait_ref = Rc::new(ty::TraitRef::new(trait_def_id, substs));\n+\n+    // Construct an obligation\n+    let obligation = traits::Obligation::misc(span, trait_ref.clone());\n+\n+    // Now we want to know if this can be matched\n+    let mut selcx = traits::SelectionContext::new(fcx.infcx(),\n+                                                  &fcx.inh.param_env,\n+                                                  fcx);\n+    if !selcx.evaluate_obligation(&obligation) {\n+        debug!(\"--> Cannot match obligation\");\n+        return None; // Cannot be matched, no such method resolution is possible.\n+    }\n+\n+    // Trait must have a method named `m_name` and it should not have\n+    // type parameters or early-bound regions.\n+    let tcx = fcx.tcx();\n+    let (method_num, method_ty) = trait_method(tcx, trait_def_id, m_name).unwrap();\n+    assert_eq!(method_ty.generics.types.len(subst::FnSpace), 0);\n+    assert_eq!(method_ty.generics.regions.len(subst::FnSpace), 0);\n+\n+    // Substitute the trait parameters into the method type and\n+    // instantiate late-bound regions to get the actual method type.\n+    let ref bare_fn_ty = method_ty.fty;\n+    let fn_sig = bare_fn_ty.sig.subst(tcx, &trait_ref.substs);\n+    let fn_sig = fcx.infcx().replace_late_bound_regions_with_fresh_var(fn_sig.binder_id,\n+                                                                       span,\n+                                                                       infer::FnCall,\n+                                                                       &fn_sig).0;\n+    let transformed_self_ty = fn_sig.inputs[0];\n+    let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n+        sig: fn_sig,\n+        fn_style: bare_fn_ty.fn_style,\n+        abi: bare_fn_ty.abi.clone(),\n+    });\n+\n+    debug!(\"matched method fty={} obligation={}\",\n+           fty.repr(fcx.tcx()),\n+           obligation.repr(fcx.tcx()));\n+\n+    // Register obligations for the parameters.  This will include the\n+    // `Self` parameter, which in turn has a bound of the main trait,\n+    // so this also effectively registers `obligation` as well.  (We\n+    // used to register `obligation` explicitly, but that resulted in\n+    // double error messages being reported.)\n+    fcx.add_obligations_for_parameters(\n+        traits::ObligationCause::misc(span),\n+        &trait_ref.substs,\n+        &method_ty.generics);\n+\n+    // FIXME(#18653) -- Try to resolve obligations, giving us more\n+    // typing information, which can sometimes be needed to avoid\n+    // pathological region inference failures.\n+    vtable::select_new_fcx_obligations(fcx);\n+\n+    // Insert any adjustments needed (always an autoref of some mutability).\n+    match self_expr {\n+        None => { }\n+\n+        Some(self_expr) => {\n+            debug!(\"inserting adjustment if needed (self-id = {}, \\\n+                   base adjustment = {}, explicit self = {})\",\n+                   self_expr.id, autoderefref, method_ty.explicit_self);\n+\n+            match method_ty.explicit_self {\n+                ty::ByValueExplicitSelfCategory => {\n+                    // Trait method is fn(self), no transformation needed.\n+                    if !autoderefref.is_identity() {\n+                        fcx.write_adjustment(\n+                            self_expr.id,\n+                            span,\n+                            ty::AdjustDerefRef(autoderefref));\n+                    }\n+                }\n+\n+                ty::ByReferenceExplicitSelfCategory(..) => {\n+                    // Trait method is fn(&self) or fn(&mut self), need an\n+                    // autoref. Pull the region etc out of the type of first argument.\n+                    match ty::get(transformed_self_ty).sty {\n+                        ty::ty_rptr(region, ty::mt { mutbl, ty: _ }) => {\n+                            let ty::AutoDerefRef { autoderefs, autoref } = autoderefref;\n+                            let autoref = autoref.map(|r| box r);\n+                            fcx.write_adjustment(\n+                                self_expr.id,\n+                                span,\n+                                ty::AdjustDerefRef(ty::AutoDerefRef {\n+                                    autoderefs: autoderefs,\n+                                    autoref: Some(ty::AutoPtr(region, mutbl, autoref))\n+                                }));\n+                        }\n+\n+                        _ => {\n+                            fcx.tcx().sess.span_bug(\n+                                span,\n+                                format!(\n+                                    \"trait method is &self but first arg is: {}\",\n+                                    transformed_self_ty.repr(fcx.tcx())).as_slice());\n+                        }\n+                    }\n+                }\n+\n+                _ => {\n+                    fcx.tcx().sess.span_bug(\n+                        span,\n+                        format!(\n+                            \"unexpected explicit self type in operator method: {}\",\n+                            method_ty.explicit_self).as_slice());\n+                }\n+            }\n+        }\n+    }\n+\n+    let callee = MethodCallee {\n+        origin: MethodTypeParam(MethodParam{trait_ref: trait_ref.clone(),\n+                                            method_num: method_num}),\n+        ty: fty,\n+        substs: trait_ref.substs.clone()\n+    };\n+\n+    debug!(\"callee = {}\", callee.repr(fcx.tcx()));\n+\n+    Some(callee)\n+}\n+\n+pub fn report_error(fcx: &FnCtxt,\n+                    span: Span,\n+                    rcvr_ty: ty::t,\n+                    method_name: ast::Name,\n+                    error: MethodError)\n+{\n+    match error {\n+        NoMatch(static_sources) => {\n+            let cx = fcx.tcx();\n+            let method_ustring = method_name.user_string(cx);\n+\n+            // True if the type is a struct and contains a field with\n+            // the same name as the not-found method\n+            let is_field = match ty::get(rcvr_ty).sty {\n+                ty_struct(did, _) =>\n+                    ty::lookup_struct_fields(cx, did)\n+                        .iter()\n+                        .any(|f| f.name.user_string(cx) == method_ustring),\n+                _ => false\n+            };\n+\n+            fcx.type_error_message(\n+                span,\n+                |actual| {\n+                    format!(\"type `{}` does not implement any \\\n+                             method in scope named `{}`\",\n+                            actual,\n+                            method_ustring)\n+                },\n+                rcvr_ty,\n+                None);\n+\n+            // If the method has the name of a field, give a help note\n+            if is_field {\n+                cx.sess.span_note(span,\n+                    format!(\"use `(s.{0})(...)` if you meant to call the \\\n+                            function stored in the `{0}` field\", method_ustring).as_slice());\n+            }\n+\n+            if static_sources.len() > 0 {\n+                fcx.tcx().sess.fileline_note(\n+                    span,\n+                    \"found defined static methods, maybe a `self` is missing?\");\n+\n+                report_candidates(fcx, span, method_name, static_sources);\n+            }\n+        }\n+\n+        Ambiguity(sources) => {\n+            span_err!(fcx.sess(), span, E0034,\n+                      \"multiple applicable methods in scope\");\n+\n+            report_candidates(fcx, span, method_name, sources);\n+        }\n+    }\n+\n+    fn report_candidates(fcx: &FnCtxt,\n+                         span: Span,\n+                         method_name: ast::Name,\n+                         mut sources: Vec<CandidateSource>) {\n+        sources.sort();\n+        sources.dedup();\n+\n+        for (idx, source) in sources.iter().enumerate() {\n+            match *source {\n+                ImplSource(impl_did) => {\n+                    // Provide the best span we can. Use the method, if local to crate, else\n+                    // the impl, if local to crate (method may be defaulted), else the call site.\n+                    let method = impl_method(fcx.tcx(), impl_did, method_name).unwrap();\n+                    let impl_span = fcx.tcx().map.def_id_span(impl_did, span);\n+                    let method_span = fcx.tcx().map.def_id_span(method.def_id, impl_span);\n+\n+                    let impl_ty = impl_self_ty(fcx, span, impl_did).ty;\n+\n+                    let insertion = match impl_trait_ref(fcx.tcx(), impl_did) {\n+                        None => format!(\"\"),\n+                        Some(trait_ref) => format!(\" of the trait `{}`\",\n+                                                   ty::item_path_str(fcx.tcx(),\n+                                                                     trait_ref.def_id)),\n+                    };\n+\n+                    span_note!(fcx.sess(), method_span,\n+                               \"candidate #{} is defined in an impl{} for the type `{}`\",\n+                               idx + 1u,\n+                               insertion,\n+                               impl_ty.user_string(fcx.tcx()));\n+                }\n+                TraitSource(trait_did) => {\n+                    let (_, method) = trait_method(fcx.tcx(), trait_did, method_name).unwrap();\n+                    let method_span = fcx.tcx().map.def_id_span(method.def_id, span);\n+                    span_note!(fcx.sess(), method_span,\n+                               \"candidate #{} is defined in the trait `{}`\",\n+                               idx + 1u,\n+                               ty::item_path_str(fcx.tcx(), trait_did));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn trait_method(tcx: &ty::ctxt,\n+                trait_def_id: ast::DefId,\n+                method_name: ast::Name)\n+                -> Option<(uint, Rc<ty::Method>)>\n+{\n+    /*!\n+     * Find method with name `method_name` defined in `trait_def_id` and return it,\n+     * along with its index (or `None`, if no such method).\n+     */\n+\n+    let trait_items = ty::trait_items(tcx, trait_def_id);\n+    trait_items\n+        .iter()\n+        .enumerate()\n+        .find(|&(_, ref item)| item.name() == method_name)\n+        .and_then(|(idx, item)| item.as_opt_method().map(|m| (idx, m)))\n+}\n+\n+fn impl_method(tcx: &ty::ctxt,\n+               impl_def_id: ast::DefId,\n+               method_name: ast::Name)\n+               -> Option<Rc<ty::Method>>\n+{\n+    let impl_items = tcx.impl_items.borrow();\n+    let impl_items = impl_items.get(&impl_def_id).unwrap();\n+    impl_items\n+        .iter()\n+        .map(|&did| ty::impl_or_trait_item(tcx, did.def_id()))\n+        .find(|m| m.name() == method_name)\n+        .and_then(|item| item.as_opt_method())\n+}\n+"}, {"sha": "63f017e8041b1f8911689dd9f73af54e3218b15d", "filename": "src/librustc/middle/typeck/check/method/probe.rs", "status": "added", "additions": 1011, "deletions": 0, "changes": 1011, "blob_url": "https://github.com/rust-lang/rust/blob/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=f8403aac81d5720bb722a85a9120c14ceb763eb9", "patch": "@@ -0,0 +1,1011 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::Ambiguity;\n+use super::CandidateSource;\n+use super::ImplSource;\n+use super::MethodError;\n+use super::MethodIndex;\n+use super::NoMatch;\n+use super::TraitSource;\n+\n+use middle::subst;\n+use middle::subst::Subst;\n+use middle::traits;\n+use middle::ty;\n+use middle::typeck::check;\n+use middle::typeck::check::{FnCtxt, NoPreference};\n+use middle::typeck::{MethodObject};\n+use middle::typeck::infer;\n+use middle::typeck::infer::InferCtxt;\n+use syntax::ast;\n+use syntax::codemap::{Span, DUMMY_SP};\n+use std::collections::HashSet;\n+use std::rc::Rc;\n+use util::ppaux::Repr;\n+\n+struct ProbeContext<'a, 'tcx:'a> {\n+    fcx: &'a FnCtxt<'a, 'tcx>,\n+    span: Span,\n+    method_name: ast::Name,\n+    steps: Rc<Vec<CandidateStep>>,\n+    inherent_candidates: Vec<Candidate>,\n+    extension_candidates: Vec<Candidate>,\n+    impl_dups: HashSet<ast::DefId>,\n+    static_candidates: Vec<CandidateSource>,\n+}\n+\n+struct CandidateStep {\n+    self_ty: ty::t,\n+    adjustment: PickAdjustment\n+}\n+\n+struct Candidate {\n+    xform_self_ty: ty::t,\n+    method_ty: Rc<ty::Method>,\n+    kind: CandidateKind,\n+}\n+\n+enum CandidateKind {\n+    InherentImplCandidate(/* Impl */ ast::DefId, subst::Substs),\n+    ObjectCandidate(MethodObject),\n+    ExtensionImplCandidate(/* Impl */ ast::DefId, Rc<ty::TraitRef>, subst::Substs, MethodIndex),\n+    UnboxedClosureCandidate(/* Trait */ ast::DefId, MethodIndex),\n+    WhereClauseCandidate(Rc<ty::TraitRef>, MethodIndex),\n+}\n+\n+pub struct Pick {\n+    pub method_ty: Rc<ty::Method>,\n+    pub adjustment: PickAdjustment,\n+    pub kind: PickKind,\n+}\n+\n+#[deriving(Clone,Show)]\n+pub enum PickKind {\n+    InherentImplPick(/* Impl */ ast::DefId),\n+    ObjectPick(/* Trait */ ast::DefId, /* method_num */ uint, /* real_index */ uint),\n+    ExtensionImplPick(/* Impl */ ast::DefId, MethodIndex),\n+    TraitPick(/* Trait */ ast::DefId, MethodIndex),\n+    WhereClausePick(/* Trait */ Rc<ty::TraitRef>, MethodIndex),\n+}\n+\n+pub type PickResult = Result<Pick, MethodError>;\n+\n+// This is a kind of \"abstracted\" version of ty::AutoAdjustment.  The\n+// difference is that it doesn't embed any regions or other\n+// specifics. The \"confirmation\" step recreates those details as\n+// needed.\n+#[deriving(Clone,Show)]\n+pub enum PickAdjustment {\n+    // Indicates that the source expression should be autoderef'd N times\n+    //\n+    // A = expr | *expr | **expr\n+    AutoDeref(uint),\n+\n+    // Indicates that the source expression should be autoderef'd N\n+    // times and then \"unsized\". This should probably eventually go\n+    // away in favor of just coercing method receivers.\n+    //\n+    // A = unsize(expr | *expr | **expr)\n+    AutoUnsizeLength(/* number of autoderefs */ uint, /* length*/ uint),\n+\n+    // Indicates that an autoref is applied after some number of other adjustments\n+    //\n+    // A = &A | &mut A\n+    AutoRef(ast::Mutability, Box<PickAdjustment>),\n+}\n+\n+pub fn probe(fcx: &FnCtxt,\n+             span: Span,\n+             method_name: ast::Name,\n+             self_ty: ty::t,\n+             call_expr_id: ast::NodeId)\n+             -> PickResult\n+{\n+    debug!(\"probe(self_ty={}, method_name={}, call_expr_id={})\",\n+           self_ty.repr(fcx.tcx()),\n+           method_name,\n+           call_expr_id);\n+\n+    // FIXME(#18741) -- right now, creating the steps involves evaluating the\n+    // `*` operator, which registers obligations that then escape into\n+    // the global fulfillment context and thus has global\n+    // side-effects. This is a bit of a pain to refactor. So just let\n+    // it ride, although it's really not great, and in fact could I\n+    // think cause spurious errors. Really though this part should\n+    // take place in the `fcx.infcx().probe` below.\n+    let steps = create_steps(fcx, span, self_ty);\n+\n+    debug!(\"ProbeContext: steps for self_ty={} are {}\",\n+           self_ty.repr(fcx.tcx()),\n+           steps.repr(fcx.tcx()));\n+\n+    // this creates one big transaction so that all type variables etc\n+    // that we create during the probe process are removed later\n+    let mut steps = Some(steps); // FIXME(#18101) need once closures\n+    fcx.infcx().probe(|| {\n+        let steps = steps.take().unwrap();\n+        let mut probe_cx = ProbeContext::new(fcx, span, method_name, steps);\n+        probe_cx.assemble_inherent_candidates();\n+        probe_cx.assemble_extension_candidates_for_traits_in_scope(call_expr_id);\n+        probe_cx.pick()\n+    })\n+}\n+\n+fn create_steps(fcx: &FnCtxt, span: Span, self_ty: ty::t) -> Vec<CandidateStep> {\n+    let mut steps = Vec::new();\n+\n+    let (fully_dereferenced_ty, dereferences, _) =\n+        check::autoderef(\n+            fcx, span, self_ty, None, NoPreference,\n+            |t, d| {\n+                let adjustment = consider_reborrow(t, d);\n+                steps.push(CandidateStep { self_ty: t, adjustment: adjustment });\n+                None::<()> // keep iterating until we can't anymore\n+            });\n+\n+    match ty::get(fully_dereferenced_ty).sty {\n+        ty::ty_vec(elem_ty, Some(len)) => {\n+            steps.push(CandidateStep {\n+                self_ty: ty::mk_vec(fcx.tcx(), elem_ty, None),\n+                adjustment: AutoUnsizeLength(dereferences, len),\n+            });\n+        }\n+        _ => {\n+        }\n+    }\n+\n+    return steps;\n+\n+    fn consider_reborrow(t: ty::t, d: uint) -> PickAdjustment {\n+        // Insert a `&*` or `&mut *` if this is a reference type:\n+        match ty::get(t).sty {\n+            ty::ty_rptr(_, ref mt) => AutoRef(mt.mutbl, box AutoDeref(d+1)),\n+            _ => AutoDeref(d),\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx> ProbeContext<'a,'tcx> {\n+    fn new(fcx: &'a FnCtxt<'a,'tcx>,\n+           span: Span,\n+           method_name: ast::Name,\n+           steps: Vec<CandidateStep>)\n+           -> ProbeContext<'a,'tcx>\n+    {\n+        ProbeContext {\n+            fcx: fcx,\n+            span: span,\n+            method_name: method_name,\n+            inherent_candidates: Vec::new(),\n+            extension_candidates: Vec::new(),\n+            impl_dups: HashSet::new(),\n+            steps: Rc::new(steps),\n+            static_candidates: Vec::new(),\n+        }\n+    }\n+\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n+        self.fcx.tcx()\n+    }\n+\n+    fn infcx(&self) -> &'a InferCtxt<'a, 'tcx> {\n+        self.fcx.infcx()\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // CANDIDATE ASSEMBLY\n+\n+    fn assemble_inherent_candidates(&mut self) {\n+        let steps = self.steps.clone();\n+        for step in steps.iter() {\n+            self.assemble_probe(step.self_ty);\n+        }\n+    }\n+\n+    fn assemble_probe(&mut self, self_ty: ty::t) {\n+        debug!(\"assemble_probe: self_ty={}\",\n+               self_ty.repr(self.tcx()));\n+\n+        match ty::get(self_ty).sty {\n+            ty::ty_trait(box ty::TyTrait { ref principal, bounds, .. }) => {\n+                self.assemble_inherent_candidates_from_object(self_ty, &*principal, bounds);\n+                self.assemble_inherent_impl_candidates_for_type(principal.def_id);\n+            }\n+            ty::ty_enum(did, _) |\n+            ty::ty_struct(did, _) |\n+            ty::ty_unboxed_closure(did, _, _) => {\n+                self.assemble_inherent_impl_candidates_for_type(did);\n+            }\n+            ty::ty_param(p) => {\n+                self.assemble_inherent_candidates_from_param(self_ty, p);\n+            }\n+            _ => {\n+            }\n+        }\n+    }\n+\n+    fn assemble_inherent_impl_candidates_for_type(&mut self, def_id: ast::DefId) {\n+        // Read the inherent implementation candidates for this type from the\n+        // metadata if necessary.\n+        ty::populate_implementations_for_type_if_necessary(self.tcx(), def_id);\n+\n+        for impl_infos in self.tcx().inherent_impls.borrow().get(&def_id).iter() {\n+            for &impl_did in impl_infos.iter() {\n+                self.assemble_inherent_impl_probe(impl_did);\n+            }\n+        }\n+    }\n+\n+    fn assemble_inherent_impl_probe(&mut self, impl_did: ast::DefId) {\n+        if !self.impl_dups.insert(impl_did) {\n+            return; // already visited\n+        }\n+\n+        let method = match impl_method(self.tcx(), impl_did, self.method_name) {\n+            Some(m) => m,\n+            None => { return; } // No method with correct name on this impl\n+        };\n+\n+        if !self.has_applicable_self(&*method) {\n+            // No receiver declared. Not a candidate.\n+            return self.record_static_candidate(ImplSource(impl_did));\n+        }\n+\n+        let impl_pty = check::impl_self_ty(self.fcx, self.span, impl_did);\n+        let impl_substs = impl_pty.substs;\n+\n+        // Determine the receiver type that the method itself expects.\n+        let xform_self_ty =\n+            self.xform_self_ty(&method, &impl_substs);\n+\n+        self.inherent_candidates.push(Candidate {\n+            xform_self_ty: xform_self_ty,\n+            method_ty: method,\n+            kind: InherentImplCandidate(impl_did, impl_substs)\n+        });\n+    }\n+\n+    fn assemble_inherent_candidates_from_object(&mut self,\n+                                                self_ty: ty::t,\n+                                                principal: &ty::TraitRef,\n+                                                _bounds: ty::ExistentialBounds) {\n+        debug!(\"assemble_inherent_candidates_from_object(self_ty={})\",\n+               self_ty.repr(self.tcx()));\n+\n+        let tcx = self.tcx();\n+\n+        // It is illegal to invoke a method on a trait instance that\n+        // refers to the `Self` type. An error will be reported by\n+        // `enforce_object_limitations()` if the method refers to the\n+        // `Self` type anywhere other than the receiver. Here, we use\n+        // a substitution that replaces `Self` with the object type\n+        // itself. Hence, a `&self` method will wind up with an\n+        // argument type like `&Trait`.\n+        let rcvr_substs = principal.substs.clone().with_self_ty(self_ty);\n+        let trait_ref = Rc::new(ty::TraitRef {\n+            def_id: principal.def_id,\n+            substs: rcvr_substs.clone()\n+        });\n+\n+        self.elaborate_bounds(&[trait_ref.clone()], |this, new_trait_ref, m, method_num| {\n+            let vtable_index =\n+                get_method_index(tcx, &*new_trait_ref,\n+                                 trait_ref.clone(), method_num);\n+\n+            // FIXME Hacky. By-value `self` methods in objects ought to be\n+            // just a special case of passing ownership of a DST value\n+            // as a parameter. *But* we currently hack them in and tie them to\n+            // the particulars of the `Box` type. So basically for a `fn foo(self,...)`\n+            // method invoked on an object, we don't want the receiver type to be\n+            // `TheTrait`, but rather `Box<TheTrait>`. Yuck.\n+            let mut m = m;\n+            match m.explicit_self {\n+                ty::ByValueExplicitSelfCategory => {\n+                    let mut n = (*m).clone();\n+                    let self_ty = n.fty.sig.inputs[0];\n+                    n.fty.sig.inputs[0] = ty::mk_uniq(tcx, self_ty);\n+                    m = Rc::new(n);\n+                }\n+                _ => { }\n+            }\n+\n+            let xform_self_ty =\n+                this.xform_self_ty(&m, &new_trait_ref.substs);\n+\n+            this.inherent_candidates.push(Candidate {\n+                xform_self_ty: xform_self_ty,\n+                method_ty: m,\n+                kind: ObjectCandidate(MethodObject {\n+                    trait_ref: new_trait_ref,\n+                    object_trait_id: principal.def_id,\n+                    method_num: method_num,\n+                    real_index: vtable_index\n+                })\n+            });\n+        });\n+    }\n+\n+    fn assemble_inherent_candidates_from_param(&mut self,\n+                                           _rcvr_ty: ty::t,\n+                                           param_ty: ty::ParamTy) {\n+        // FIXME -- Do we want to commit to this behavior for param bounds?\n+\n+        let ty::ParamTy { space, idx: index, .. } = param_ty;\n+        let bounds =\n+            self.fcx.inh.param_env.bounds.get(space, index).trait_bounds\n+            .as_slice();\n+        self.elaborate_bounds(bounds, |this, trait_ref, m, method_num| {\n+            let xform_self_ty =\n+                this.xform_self_ty(&m, &trait_ref.substs);\n+\n+            debug!(\"found match: trait_ref={} substs={} m={}\",\n+                   trait_ref.repr(this.tcx()),\n+                   trait_ref.substs.repr(this.tcx()),\n+                   m.repr(this.tcx()));\n+            assert_eq!(m.generics.types.get_slice(subst::TypeSpace).len(),\n+                       trait_ref.substs.types.get_slice(subst::TypeSpace).len());\n+            assert_eq!(m.generics.regions.get_slice(subst::TypeSpace).len(),\n+                       trait_ref.substs.regions().get_slice(subst::TypeSpace).len());\n+            assert_eq!(m.generics.types.get_slice(subst::SelfSpace).len(),\n+                       trait_ref.substs.types.get_slice(subst::SelfSpace).len());\n+            assert_eq!(m.generics.regions.get_slice(subst::SelfSpace).len(),\n+                       trait_ref.substs.regions().get_slice(subst::SelfSpace).len());\n+\n+            // Because this trait derives from a where-clause, it\n+            // should not contain any inference variables or other\n+            // artifacts. This means it is safe to put into the\n+            // `WhereClauseCandidate` and (eventually) into the\n+            // `WhereClausePick`.\n+            assert!(trait_ref.substs.types.iter().all(|&t| !ty::type_needs_infer(t)));\n+\n+            this.inherent_candidates.push(Candidate {\n+                xform_self_ty: xform_self_ty,\n+                method_ty: m,\n+                kind: WhereClauseCandidate(trait_ref, method_num)\n+            });\n+        });\n+    }\n+\n+    // Do a search through a list of bounds, using a callback to actually\n+    // create the candidates.\n+    fn elaborate_bounds(\n+        &mut self,\n+        bounds: &[Rc<ty::TraitRef>],\n+        mk_cand: |this: &mut ProbeContext,\n+                  tr: Rc<ty::TraitRef>,\n+                  m: Rc<ty::Method>,\n+                  method_num: uint|)\n+    {\n+        let tcx = self.tcx();\n+        let mut cache = HashSet::new();\n+        for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n+            // Already visited this trait, skip it.\n+            if !cache.insert(bound_trait_ref.def_id) {\n+                continue;\n+            }\n+\n+            let (pos, method) = match trait_method(tcx, bound_trait_ref.def_id, self.method_name) {\n+                Some(v) => v,\n+                None => { continue; }\n+            };\n+\n+            if !self.has_applicable_self(&*method) {\n+                self.record_static_candidate(TraitSource(bound_trait_ref.def_id));\n+            } else {\n+                mk_cand(self, bound_trait_ref, method, pos);\n+            }\n+        }\n+    }\n+\n+    fn assemble_extension_candidates_for_traits_in_scope(&mut self,\n+                                                         expr_id: ast::NodeId)\n+    {\n+        let mut duplicates = HashSet::new();\n+        let opt_applicable_traits = self.fcx.ccx.trait_map.get(&expr_id);\n+        for applicable_traits in opt_applicable_traits.into_iter() {\n+            for &trait_did in applicable_traits.iter() {\n+                if duplicates.insert(trait_did) {\n+                    self.assemble_extension_candidates_for_trait(trait_did);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn assemble_extension_candidates_for_trait(&mut self,\n+                                           trait_def_id: ast::DefId) {\n+        debug!(\"assemble_extension_candidates_for_trait: trait_def_id={}\",\n+               trait_def_id.repr(self.tcx()));\n+\n+        // Check whether `trait_def_id` defines a method with suitable name:\n+        let trait_items =\n+            ty::trait_items(self.tcx(), trait_def_id);\n+        let matching_index =\n+            trait_items.iter()\n+                       .position(|item| item.name() == self.method_name);\n+        let matching_index = match matching_index {\n+            Some(i) => i,\n+            None => { return; }\n+        };\n+        let method = match (&*trait_items)[matching_index].as_opt_method() {\n+            Some(m) => m,\n+            None => { return; }\n+        };\n+\n+        // Check whether `trait_def_id` defines a method with suitable name:\n+        if !self.has_applicable_self(&*method) {\n+            debug!(\"method has inapplicable self\");\n+            return self.record_static_candidate(TraitSource(trait_def_id));\n+        }\n+\n+        self.assemble_extension_candidates_for_trait_impls(trait_def_id,\n+                                                       method.clone(),\n+                                                       matching_index);\n+\n+        self.assemble_unboxed_closure_candidates(trait_def_id,\n+                                                 method,\n+                                                 matching_index);\n+    }\n+\n+    fn assemble_extension_candidates_for_trait_impls(&mut self,\n+                                                 trait_def_id: ast::DefId,\n+                                                 method: Rc<ty::Method>,\n+                                                 method_index: uint)\n+    {\n+        ty::populate_implementations_for_trait_if_necessary(self.tcx(),\n+                                                            trait_def_id);\n+\n+        let trait_impls = self.tcx().trait_impls.borrow();\n+        let impl_def_ids = match trait_impls.get(&trait_def_id) {\n+            None => { return; }\n+            Some(impls) => impls,\n+        };\n+\n+        for &impl_def_id in impl_def_ids.borrow().iter() {\n+            debug!(\"assemble_extension_candidates_for_trait_impl: trait_def_id={} impl_def_id={}\",\n+                   trait_def_id.repr(self.tcx()),\n+                   impl_def_id.repr(self.tcx()));\n+\n+            let impl_pty = check::impl_self_ty(self.fcx, self.span, impl_def_id);\n+            let impl_substs = impl_pty.substs;\n+\n+            debug!(\"impl_substs={}\", impl_substs.repr(self.tcx()));\n+\n+            let impl_trait_ref =\n+                ty::impl_trait_ref(self.tcx(), impl_def_id)\n+                .unwrap() // we know this is a trait impl\n+                .subst(self.tcx(), &impl_substs);\n+\n+            debug!(\"impl_trait_ref={}\", impl_trait_ref.repr(self.tcx()));\n+\n+            // Determine the receiver type that the method itself expects.\n+            let xform_self_ty =\n+                self.xform_self_ty(&method, &impl_trait_ref.substs);\n+\n+            debug!(\"xform_self_ty={}\", xform_self_ty.repr(self.tcx()));\n+\n+            self.extension_candidates.push(Candidate {\n+                xform_self_ty: xform_self_ty,\n+                method_ty: method.clone(),\n+                kind: ExtensionImplCandidate(impl_def_id, impl_trait_ref, impl_substs, method_index)\n+            });\n+        }\n+    }\n+\n+    fn assemble_unboxed_closure_candidates(&mut self,\n+                                           trait_def_id: ast::DefId,\n+                                           method_ty: Rc<ty::Method>,\n+                                           method_index: uint)\n+    {\n+        // Check if this is one of the Fn,FnMut,FnOnce traits.\n+        let tcx = self.tcx();\n+        let kind = if Some(trait_def_id) == tcx.lang_items.fn_trait() {\n+            ty::FnUnboxedClosureKind\n+        } else if Some(trait_def_id) == tcx.lang_items.fn_mut_trait() {\n+            ty::FnMutUnboxedClosureKind\n+        } else if Some(trait_def_id) == tcx.lang_items.fn_once_trait() {\n+            ty::FnOnceUnboxedClosureKind\n+        } else {\n+            return;\n+        };\n+\n+        // Check if there is an unboxed-closure self-type in the list of receivers.\n+        // If so, add \"synthetic impls\".\n+        let steps = self.steps.clone();\n+        for step in steps.iter() {\n+            let (closure_def_id, _, _) = match ty::get(step.self_ty).sty {\n+                ty::ty_unboxed_closure(a, b, ref c) => (a, b, c),\n+                _ => continue,\n+            };\n+\n+            let unboxed_closures = self.fcx.inh.unboxed_closures.borrow();\n+            let closure_data = match unboxed_closures.get(&closure_def_id) {\n+                Some(data) => data,\n+                None => {\n+                    self.tcx().sess.span_bug(\n+                        self.span,\n+                        format!(\"No entry for unboxed closure: {}\",\n+                                closure_def_id.repr(self.tcx())).as_slice());\n+                }\n+            };\n+\n+            // this closure doesn't implement the right kind of `Fn` trait\n+            if closure_data.kind != kind {\n+                continue;\n+            }\n+\n+            // create some substitutions for the argument/return type;\n+            // for the purposes of our method lookup, we only take\n+            // receiver type into account, so we can just substitute\n+            // fresh types here to use during substitution and subtyping.\n+            let trait_def = ty::lookup_trait_def(self.tcx(), trait_def_id);\n+            let substs = self.infcx().fresh_substs_for_trait(self.span,\n+                                                             &trait_def.generics,\n+                                                             step.self_ty);\n+\n+            let xform_self_ty = self.xform_self_ty(&method_ty, &substs);\n+            self.inherent_candidates.push(Candidate {\n+                xform_self_ty: xform_self_ty,\n+                method_ty: method_ty.clone(),\n+                kind: UnboxedClosureCandidate(trait_def_id, method_index)\n+            });\n+        }\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // THE ACTUAL SEARCH\n+\n+    fn pick(mut self) -> PickResult {\n+        let steps = self.steps.clone();\n+\n+        for step in steps.iter() {\n+            match self.pick_step(step) {\n+                Some(r) => {\n+                    return r;\n+                }\n+                None => { }\n+            }\n+        }\n+\n+        Err(NoMatch(self.static_candidates))\n+    }\n+\n+    fn pick_step(&mut self, step: &CandidateStep) -> Option<PickResult> {\n+        debug!(\"pick_step: step={}\", step.repr(self.tcx()));\n+\n+        if ty::type_is_error(step.self_ty) {\n+            return None;\n+        }\n+\n+        match self.pick_adjusted_method(step) {\n+            Some(result) => return Some(result),\n+            None => {}\n+        }\n+\n+        match self.pick_autorefd_method(step) {\n+            Some(result) => return Some(result),\n+            None => {}\n+        }\n+\n+        // FIXME -- Super hack. For DST types, we will convert to\n+        // &&[T] or &&str, as part of a kind of legacy lookup scheme.\n+        match ty::get(step.self_ty).sty {\n+            ty::ty_str | ty::ty_vec(_, None) => self.pick_autorefrefd_method(step),\n+            _ => None\n+        }\n+    }\n+\n+    fn pick_adjusted_method(&mut self,\n+                            step: &CandidateStep)\n+                            -> Option<PickResult>\n+    {\n+        self.pick_method(step.self_ty).map(|r| self.adjust(r, step.adjustment.clone()))\n+    }\n+\n+    fn pick_autorefd_method(&mut self,\n+                            step: &CandidateStep)\n+                            -> Option<PickResult>\n+    {\n+        let tcx = self.tcx();\n+        self.search_mutabilities(\n+            |m| AutoRef(m, box step.adjustment.clone()),\n+            |m,r| ty::mk_rptr(tcx, r, ty::mt {ty:step.self_ty, mutbl:m}))\n+    }\n+\n+    fn pick_autorefrefd_method(&mut self,\n+                               step: &CandidateStep)\n+                               -> Option<PickResult>\n+    {\n+        let tcx = self.tcx();\n+        self.search_mutabilities(\n+            |m| AutoRef(m, box AutoRef(m, box step.adjustment.clone())),\n+            |m,r| ty::mk_rptr(tcx, r, ty::mt { ty: ty::mk_rptr(tcx, r, ty::mt { ty:step.self_ty,\n+                                                                                mutbl:m}),\n+                                               mutbl: m }))\n+    }\n+\n+    fn search_mutabilities(&mut self,\n+                           mk_adjustment: |ast::Mutability| -> PickAdjustment,\n+                           mk_autoref_ty: |ast::Mutability, ty::Region| -> ty::t)\n+                           -> Option<PickResult>\n+    {\n+        let region = self.infcx().next_region_var(infer::Autoref(self.span));\n+\n+        // Search through mutabilities in order to find one where pick works:\n+        [ast::MutImmutable, ast::MutMutable]\n+            .iter()\n+            .flat_map(|&m| {\n+                let autoref_ty = mk_autoref_ty(m, region);\n+                self.pick_method(autoref_ty)\n+                    .map(|r| self.adjust(r, mk_adjustment(m)))\n+                    .into_iter()\n+            })\n+            .nth(0)\n+    }\n+\n+    fn adjust(&mut self, result: PickResult, adjustment: PickAdjustment) -> PickResult {\n+        match result {\n+            Err(e) => Err(e),\n+            Ok(mut pick) => {\n+                pick.adjustment = adjustment;\n+                Ok(pick)\n+            }\n+        }\n+    }\n+\n+    fn pick_method(&mut self, self_ty: ty::t) -> Option<PickResult> {\n+        debug!(\"pick_method(self_ty={})\", self.infcx().ty_to_string(self_ty));\n+\n+        debug!(\"searching inherent candidates\");\n+        match self.consider_candidates(self_ty, self.inherent_candidates[]) {\n+            None => {}\n+            Some(pick) => {\n+                return Some(pick);\n+            }\n+        }\n+\n+        debug!(\"searching extension candidates\");\n+        self.consider_candidates(self_ty, self.extension_candidates[])\n+    }\n+\n+    fn consider_candidates(&self, self_ty: ty::t, probes: &[Candidate]) -> Option<PickResult> {\n+        let mut applicable_candidates: Vec<_> =\n+            probes.iter()\n+                  .filter(|&probe| self.consider_probe(self_ty, probe))\n+                  .collect();\n+\n+        debug!(\"applicable_candidates: {}\", applicable_candidates.repr(self.tcx()));\n+\n+        if applicable_candidates.len() > 1 {\n+            match self.collapse_candidates_to_trait_pick(applicable_candidates[]) {\n+                Some(pick) => { return Some(Ok(pick)); }\n+                None => { }\n+            }\n+        }\n+\n+        if applicable_candidates.len() > 1 {\n+            let sources = probes.iter().map(|p| p.to_source()).collect();\n+            return Some(Err(Ambiguity(sources)));\n+        }\n+\n+        applicable_candidates.pop().map(|probe| {\n+            let pick = probe.to_unadjusted_pick();\n+            Ok(pick)\n+        })\n+    }\n+\n+    fn consider_probe(&self, self_ty: ty::t, probe: &Candidate) -> bool {\n+        debug!(\"consider_probe: self_ty={} probe={}\",\n+               self_ty.repr(self.tcx()),\n+               probe.repr(self.tcx()));\n+\n+        self.infcx().probe(|| {\n+            match self.make_sub_ty(self_ty, probe.xform_self_ty) {\n+                Ok(()) => { }\n+                Err(_) => {\n+                    debug!(\"--> cannot relate self-types\");\n+                    return false;\n+                }\n+            }\n+\n+            match probe.kind {\n+                InherentImplCandidate(impl_def_id, ref substs) |\n+                ExtensionImplCandidate(impl_def_id, _, ref substs, _) => {\n+                    // Check whether the impl imposes obligations we have to worry about.\n+                    let obligations =\n+                        traits::impl_obligations(\n+                            self.tcx(),\n+                            traits::ObligationCause::misc(self.span),\n+                            impl_def_id,\n+                            substs);\n+\n+                    debug!(\"impl_obligations={}\", obligations.repr(self.tcx()));\n+\n+                    let mut selcx = traits::SelectionContext::new(self.infcx(),\n+                                                                  &self.fcx.inh.param_env,\n+                                                                  self.fcx);\n+\n+                    obligations.all(|o| selcx.evaluate_obligation(o))\n+                }\n+\n+                ObjectCandidate(..) |\n+                UnboxedClosureCandidate(..) |\n+                WhereClauseCandidate(..) => {\n+                    // These have no additional conditions to check.\n+                    true\n+                }\n+            }\n+        })\n+    }\n+\n+    fn collapse_candidates_to_trait_pick(&self, probes: &[&Candidate]) -> Option<Pick> {\n+        /*!\n+         * Sometimes we get in a situation where we have multiple\n+         * probes that are all impls of the same trait, but we don't\n+         * know which impl to use. In this case, since in all cases\n+         * the external interface of the method can be determined from\n+         * the trait, it's ok not to decide.  We can basically just\n+         * collapse all of the probes for various impls into one\n+         * where-clause probe. This will result in a pending\n+         * obligation so when more type-info is available we can make\n+         * the final decision.\n+         *\n+         * Example (`src/test/run-pass/method-two-trait-defer-resolution-1.rs`):\n+         *\n+         * ```\n+         * trait Foo { ... }\n+         * impl Foo for Vec<int> { ... }\n+         * impl Foo for Vec<uint> { ... }\n+         * ```\n+         *\n+         * Now imagine the receiver is `Vec<_>`. It doesn't really\n+         * matter at this time which impl we use, so it's ok to just\n+         * commit to \"using the method from the trait Foo\".\n+         */\n+\n+        // Do all probes correspond to the same trait?\n+        let trait_data = match probes[0].to_trait_data() {\n+            Some(data) => data,\n+            None => return None,\n+        };\n+        if probes[1..].iter().any(|p| p.to_trait_data() != Some(trait_data)) {\n+            return None;\n+        }\n+\n+        // If so, just use this trait and call it a day.\n+        let (trait_def_id, method_num) = trait_data;\n+        let method_ty = probes[0].method_ty.clone();\n+        Some(Pick {\n+            method_ty: method_ty,\n+            adjustment: AutoDeref(0),\n+            kind: TraitPick(trait_def_id, method_num)\n+        })\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // MISCELLANY\n+\n+    fn make_sub_ty(&self, sub: ty::t, sup: ty::t) -> infer::ures {\n+        self.infcx().sub_types(false, infer::Misc(DUMMY_SP), sub, sup)\n+    }\n+\n+    fn has_applicable_self(&self, method: &ty::Method) -> bool {\n+        // \"fast track\" -- check for usage of sugar\n+        match method.explicit_self {\n+            ty::StaticExplicitSelfCategory => {\n+                // fallthrough\n+            }\n+            ty::ByValueExplicitSelfCategory |\n+            ty::ByReferenceExplicitSelfCategory(..) |\n+            ty::ByBoxExplicitSelfCategory => {\n+                return true;\n+            }\n+        }\n+\n+        // FIXME -- check for types that deref to `Self`,\n+        // like `Rc<Self>` and so on.\n+        //\n+        // Note also that the current code will break if this type\n+        // includes any of the type parameters defined on the method\n+        // -- but this could be overcome.\n+        return false;\n+    }\n+\n+    fn record_static_candidate(&mut self, source: CandidateSource) {\n+        self.static_candidates.push(source);\n+    }\n+\n+    fn xform_self_ty(&self, method: &Rc<ty::Method>, substs: &subst::Substs) -> ty::t {\n+        debug!(\"xform_self_ty(self_ty={}, substs={})\",\n+               method.fty.sig.inputs[0].repr(self.tcx()),\n+               substs.repr(self.tcx()));\n+\n+        let xform_self_ty = method.fty.sig.inputs[0].subst(self.tcx(), substs);\n+        self.infcx().replace_late_bound_regions_with_fresh_var(method.fty.sig.binder_id,\n+                                                               self.span,\n+                                                               infer::FnCall,\n+                                                               &xform_self_ty).0\n+    }\n+}\n+\n+fn impl_method(tcx: &ty::ctxt,\n+               impl_def_id: ast::DefId,\n+               method_name: ast::Name)\n+               -> Option<Rc<ty::Method>>\n+{\n+    let impl_items = tcx.impl_items.borrow();\n+    let impl_items = impl_items.get(&impl_def_id).unwrap();\n+    impl_items\n+        .iter()\n+        .map(|&did| ty::impl_or_trait_item(tcx, did.def_id()))\n+        .find(|m| m.name() == method_name)\n+        .and_then(|item| item.as_opt_method())\n+}\n+\n+fn trait_method(tcx: &ty::ctxt,\n+                trait_def_id: ast::DefId,\n+                method_name: ast::Name)\n+                -> Option<(uint, Rc<ty::Method>)>\n+{\n+    /*!\n+     * Find method with name `method_name` defined in `trait_def_id` and return it,\n+     * along with its index (or `None`, if no such method).\n+     */\n+\n+    let trait_items = ty::trait_items(tcx, trait_def_id);\n+    trait_items\n+        .iter()\n+        .enumerate()\n+        .find(|&(_, ref item)| item.name() == method_name)\n+        .and_then(|(idx, item)| item.as_opt_method().map(|m| (idx, m)))\n+}\n+\n+// Determine the index of a method in the list of all methods belonging\n+// to a trait and its supertraits.\n+fn get_method_index(tcx: &ty::ctxt,\n+                    trait_ref: &ty::TraitRef,\n+                    subtrait: Rc<ty::TraitRef>,\n+                    n_method: uint) -> uint {\n+    // We need to figure the \"real index\" of the method in a\n+    // listing of all the methods of an object. We do this by\n+    // iterating down the supertraits of the object's trait until\n+    // we find the trait the method came from, counting up the\n+    // methods from them.\n+    let mut method_count = 0;\n+    ty::each_bound_trait_and_supertraits(tcx, &[subtrait], |bound_ref| {\n+        if bound_ref.def_id == trait_ref.def_id {\n+            false\n+        } else {\n+            let trait_items = ty::trait_items(tcx, bound_ref.def_id);\n+            for trait_item in trait_items.iter() {\n+                match *trait_item {\n+                    ty::MethodTraitItem(_) => method_count += 1,\n+                    ty::TypeTraitItem(_) => {}\n+                }\n+            }\n+            true\n+        }\n+    });\n+    method_count + n_method\n+}\n+\n+impl Candidate {\n+    fn to_unadjusted_pick(&self) -> Pick {\n+        Pick {\n+            method_ty: self.method_ty.clone(),\n+            adjustment: AutoDeref(0),\n+            kind: match self.kind {\n+                InherentImplCandidate(def_id, _) => {\n+                    InherentImplPick(def_id)\n+                }\n+                ObjectCandidate(ref data) => {\n+                    ObjectPick(data.trait_ref.def_id, data.method_num, data.real_index)\n+                }\n+                ExtensionImplCandidate(def_id, _, _, index) => {\n+                    ExtensionImplPick(def_id, index)\n+                }\n+                UnboxedClosureCandidate(trait_def_id, index) => {\n+                    TraitPick(trait_def_id, index)\n+                }\n+                WhereClauseCandidate(ref trait_ref, index) => {\n+                    // Only trait derived from where-clauses should\n+                    // appear here, so they should not contain any\n+                    // inference variables or other artifacts. This\n+                    // means they are safe to put into the\n+                    // `WhereClausePick`.\n+                    assert!(trait_ref.substs.types.iter().all(|&t| !ty::type_needs_infer(t)));\n+\n+                    WhereClausePick((*trait_ref).clone(), index)\n+                }\n+            }\n+        }\n+    }\n+\n+    fn to_source(&self) -> CandidateSource {\n+        match self.kind {\n+            InherentImplCandidate(def_id, _) => ImplSource(def_id),\n+            ObjectCandidate(ref obj) => TraitSource(obj.trait_ref.def_id),\n+            ExtensionImplCandidate(def_id, _, _, _) => ImplSource(def_id),\n+            UnboxedClosureCandidate(trait_def_id, _) => TraitSource(trait_def_id),\n+            WhereClauseCandidate(ref trait_ref, _) => TraitSource(trait_ref.def_id),\n+        }\n+    }\n+\n+    fn to_trait_data(&self) -> Option<(ast::DefId,MethodIndex)> {\n+        match self.kind {\n+            InherentImplCandidate(..) |\n+            ObjectCandidate(..) => {\n+                None\n+            }\n+            UnboxedClosureCandidate(trait_def_id, method_num) => {\n+                Some((trait_def_id, method_num))\n+            }\n+            ExtensionImplCandidate(_, ref trait_ref, _, method_num) |\n+            WhereClauseCandidate(ref trait_ref, method_num) => {\n+                Some((trait_ref.def_id, method_num))\n+            }\n+        }\n+    }\n+}\n+\n+impl Repr for Candidate {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        format!(\"Candidate(xform_self_ty={}, kind={})\",\n+                self.xform_self_ty.repr(tcx),\n+                self.kind.repr(tcx))\n+    }\n+}\n+\n+impl Repr for CandidateKind {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        match *self {\n+            InherentImplCandidate(ref a, ref b) =>\n+                format!(\"InherentImplCandidate({},{})\", a.repr(tcx), b.repr(tcx)),\n+            ObjectCandidate(ref a) =>\n+                format!(\"ObjectCandidate({})\", a.repr(tcx)),\n+            ExtensionImplCandidate(ref a, ref b, ref c, ref d) =>\n+                format!(\"ExtensionImplCandidate({},{},{},{})\", a.repr(tcx), b.repr(tcx),\n+                        c.repr(tcx), d),\n+            UnboxedClosureCandidate(ref a, ref b) =>\n+                format!(\"UnboxedClosureCandidate({},{})\", a.repr(tcx), b),\n+            WhereClauseCandidate(ref a, ref b) =>\n+                format!(\"WhereClauseCandidate({},{})\", a.repr(tcx), b),\n+        }\n+    }\n+}\n+\n+impl Repr for CandidateStep {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        format!(\"CandidateStep({},{})\",\n+                self.self_ty.repr(tcx),\n+                self.adjustment)\n+    }\n+}\n+\n+impl Repr for PickAdjustment {\n+    fn repr(&self, _tcx: &ty::ctxt) -> String {\n+        format!(\"{}\", self)\n+    }\n+}\n+\n+impl Repr for PickKind {\n+    fn repr(&self, _tcx: &ty::ctxt) -> String {\n+        format!(\"{}\", self)\n+    }\n+}\n+\n+impl Repr for Pick {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        format!(\"Pick(method_ty={}, adjustment={}, kind={})\",\n+                self.method_ty.repr(tcx),\n+                self.adjustment,\n+                self.kind)\n+    }\n+}"}, {"sha": "d58b03224335103b882a677fb8dfbc9f9ea2f30c", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 42, "deletions": 54, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=f8403aac81d5720bb722a85a9120c14ceb763eb9", "patch": "@@ -102,8 +102,6 @@ use middle::typeck::astconv::AstConv;\n use middle::typeck::astconv::{ast_region_to_region, ast_ty_to_ty};\n use middle::typeck::astconv;\n use middle::typeck::check::_match::pat_ctxt;\n-use middle::typeck::check::method::{AutoderefReceiver};\n-use middle::typeck::check::method::{CheckTraitsAndInherentMethods};\n use middle::typeck::check::regionmanip::replace_late_bound_regions;\n use middle::typeck::CrateCtxt;\n use middle::typeck::infer;\n@@ -2271,6 +2269,10 @@ fn autoderef_for_index<T>(fcx: &FnCtxt,\n                           step: |ty::t, ty::AutoDerefRef| -> Option<T>)\n                           -> Option<T>\n {\n+    // FIXME(#18741) -- this is almost but not quite the same as the\n+    // autoderef that normal method probing does. They could likely be\n+    // consolidated.\n+\n     let (ty, autoderefs, final_mt) =\n         autoderef(fcx, base_expr.span, base_ty, Some(base_expr.id), lvalue_pref, |adj_ty, idx| {\n             let autoderefref = ty::AutoDerefRef { autoderefs: idx, autoref: None };\n@@ -3048,9 +3050,12 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n         // Replace any bound regions that appear in the function\n         // signature with region variables\n-        let (_, fn_sig) = replace_late_bound_regions(fcx.tcx(), fn_sig.binder_id, fn_sig, |br| {\n-            fcx.infcx().next_region_var(infer::LateBoundRegion(call_expr.span, br))\n-        });\n+        let fn_sig =\n+            fcx.infcx().replace_late_bound_regions_with_fresh_var(\n+                fn_sig.binder_id,\n+                call_expr.span,\n+                infer::FnCall,\n+                fn_sig).0;\n \n         // Call the generic checker.\n         check_argument_types(fcx,\n@@ -3082,14 +3087,12 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n         let tps = tps.iter().map(|ast_ty| fcx.to_ty(&**ast_ty)).collect::<Vec<_>>();\n         let fn_ty = match method::lookup(fcx,\n-                                         expr,\n-                                         &*rcvr,\n+                                         method_name.span,\n                                          method_name.node.name,\n                                          expr_t,\n-                                         tps.as_slice(),\n-                                         DontDerefArgs,\n-                                         CheckTraitsAndInherentMethods,\n-                                         AutoderefReceiver) {\n+                                         tps,\n+                                         expr.id,\n+                                         rcvr) {\n             Ok(method) => {\n                 let method_ty = method.ty;\n                 let method_call = MethodCall::expr(expr.id);\n@@ -3597,8 +3600,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                    expr: &ast::Expr,\n                    lvalue_pref: LvaluePreference,\n                    base: &ast::Expr,\n-                   field: &ast::SpannedIdent,\n-                   tys: &[P<ast::Ty>]) {\n+                   field: &ast::SpannedIdent) {\n         let tcx = fcx.ccx.tcx;\n         check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n@@ -3625,42 +3627,29 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             None => {}\n         }\n \n-        let tps: Vec<ty::t> = tys.iter().map(|ty| fcx.to_ty(&**ty)).collect();\n-        match method::lookup(fcx,\n-                             expr,\n-                             base,\n-                             field.node.name,\n-                             expr_t,\n-                             tps.as_slice(),\n-                             DontDerefArgs,\n-                             CheckTraitsAndInherentMethods,\n-                             AutoderefReceiver) {\n-            Ok(_) => {\n-                fcx.type_error_message(\n-                    field.span,\n-                    |actual| {\n-                        format!(\"attempted to take value of method `{}` on type \\\n-                                 `{}`\", token::get_ident(field.node), actual)\n-                    },\n-                    expr_t, None);\n-\n-                tcx.sess.span_help(field.span,\n-                    \"maybe a `()` to call it is missing? \\\n-                     If not, try an anonymous function\");\n-            }\n+        if method::exists(fcx, field.span, field.node.name, expr_t, expr.id) {\n+            fcx.type_error_message(\n+                field.span,\n+                |actual| {\n+                    format!(\"attempted to take value of method `{}` on type \\\n+                            `{}`\", token::get_ident(field.node), actual)\n+                },\n+                expr_t, None);\n \n-            Err(_) => {\n-                fcx.type_error_message(\n-                    expr.span,\n-                    |actual| {\n-                        format!(\"attempted access of field `{}` on \\\n-                                        type `{}`, but no field with that \\\n-                                        name was found\",\n-                                       token::get_ident(field.node),\n-                                       actual)\n-                    },\n-                    expr_t, None);\n-            }\n+            tcx.sess.span_help(field.span,\n+                               \"maybe a `()` to call it is missing? \\\n+                               If not, try an anonymous function\");\n+        } else {\n+            fcx.type_error_message(\n+                expr.span,\n+                |actual| {\n+                    format!(\"attempted access of field `{}` on \\\n+                            type `{}`, but no field with that \\\n+                            name was found\",\n+                            token::get_ident(field.node),\n+                            actual)\n+                },\n+                expr_t, None);\n         }\n \n         fcx.write_error(expr.id);\n@@ -3671,8 +3660,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                        expr: &ast::Expr,\n                        lvalue_pref: LvaluePreference,\n                        base: &ast::Expr,\n-                       idx: codemap::Spanned<uint>,\n-                       _tys: &[P<ast::Ty>]) {\n+                       idx: codemap::Spanned<uint>) {\n         let tcx = fcx.ccx.tcx;\n         check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n@@ -4495,11 +4483,11 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n         fcx.require_expr_have_sized_type(expr, traits::StructInitializerSized);\n       }\n-      ast::ExprField(ref base, ref field, ref tys) => {\n-        check_field(fcx, expr, lvalue_pref, &**base, field, tys.as_slice());\n+      ast::ExprField(ref base, ref field, _) => {\n+        check_field(fcx, expr, lvalue_pref, &**base, field);\n       }\n-      ast::ExprTupField(ref base, idx, ref tys) => {\n-        check_tup_field(fcx, expr, lvalue_pref, &**base, idx, tys.as_slice());\n+      ast::ExprTupField(ref base, idx, _) => {\n+        check_tup_field(fcx, expr, lvalue_pref, &**base, idx);\n       }\n       ast::ExprIndex(ref base, ref idx) => {\n           check_expr_with_lvalue_pref(fcx, &**base, lvalue_pref);"}, {"sha": "8c55872d962174ef5b72106ea1f2618a828257a3", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=f8403aac81d5720bb722a85a9120c14ceb763eb9", "patch": "@@ -1456,11 +1456,11 @@ impl<'a, 'tcx> ErrorReportingHelpers for InferCtxt<'a, 'tcx> {\n             infer::AddrOfSlice(_) => \" for slice expression\".to_string(),\n             infer::Autoref(_) => \" for autoref\".to_string(),\n             infer::Coercion(_) => \" for automatic coercion\".to_string(),\n-            infer::LateBoundRegion(_, br) => {\n+            infer::LateBoundRegion(_, br, infer::FnCall) => {\n                 format!(\" for {}in function call\",\n                         bound_region_to_string(self.tcx, \"lifetime parameter \", true, br))\n             }\n-            infer::BoundRegionInFnType(_, br) => {\n+            infer::LateBoundRegion(_, br, infer::FnType) => {\n                 format!(\" for {}in function type\",\n                         bound_region_to_string(self.tcx, \"lifetime parameter \", true, br))\n             }"}, {"sha": "12b81010e982716e2179982734ea62e4d0a42dbe", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=f8403aac81d5720bb722a85a9120c14ceb763eb9", "patch": "@@ -15,12 +15,13 @@ use middle::ty;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::lattice::*;\n use middle::typeck::infer::equate::Equate;\n+use middle::typeck::infer::FnType;\n+use middle::typeck::infer::fold_regions_in_sig;\n use middle::typeck::infer::lub::Lub;\n+use middle::typeck::infer::region_inference::RegionMark;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::{cres, InferCtxt};\n use middle::typeck::infer::{TypeTrace, Subtype};\n-use middle::typeck::infer::fold_regions_in_sig;\n-use middle::typeck::infer::region_inference::RegionMark;\n use syntax::ast::{Many, Once, MutImmutable, MutMutable};\n use syntax::ast::{NormalFn, UnsafeFn, NodeId};\n use syntax::ast::{Onceness, FnStyle};\n@@ -140,12 +141,12 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n \n         // Instantiate each bound region with a fresh region variable.\n         let (a_with_fresh, a_map) =\n-            self.fields.infcx.replace_late_bound_regions_with_fresh_regions(\n-                self.trace(), a);\n+            self.fields.infcx.replace_late_bound_regions_with_fresh_var(\n+                a.binder_id, self.trace().span(), FnType, a);\n         let a_vars = var_ids(self, &a_map);\n         let (b_with_fresh, b_map) =\n-            self.fields.infcx.replace_late_bound_regions_with_fresh_regions(\n-                self.trace(), b);\n+            self.fields.infcx.replace_late_bound_regions_with_fresh_var(\n+                b.binder_id, self.trace().span(), FnType, b);\n         let b_vars = var_ids(self, &b_map);\n \n         // Collect constraints."}, {"sha": "bd0e88b5812e56846a7b7607bd9912703f5ce19e", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=f8403aac81d5720bb722a85a9120c14ceb763eb9", "patch": "@@ -13,6 +13,7 @@ use middle::ty::RegionVid;\n use middle::ty;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::equate::Equate;\n+use middle::typeck::infer::FnType;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lattice::*;\n use middle::typeck::infer::sub::Sub;\n@@ -126,11 +127,11 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n \n         // Instantiate each bound region with a fresh region variable.\n         let (a_with_fresh, a_map) =\n-            self.fields.infcx.replace_late_bound_regions_with_fresh_regions(\n-                self.trace(), a);\n+            self.fields.infcx.replace_late_bound_regions_with_fresh_var(\n+                a.binder_id, self.trace().span(), FnType, a);\n         let (b_with_fresh, _) =\n-            self.fields.infcx.replace_late_bound_regions_with_fresh_regions(\n-                self.trace(), b);\n+            self.fields.infcx.replace_late_bound_regions_with_fresh_var(\n+                b.binder_id, self.trace().span(), FnType, b);\n \n         // Collect constraints.\n         let sig0 = try!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));"}, {"sha": "ab7c8b7640e9ef5cfa53b51aebaaa157f2c04b59", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=f8403aac81d5720bb722a85a9120c14ceb763eb9", "patch": "@@ -41,7 +41,7 @@ use syntax::codemap;\n use syntax::codemap::Span;\n use util::common::indent;\n use util::nodemap::FnvHashMap;\n-use util::ppaux::{bound_region_to_string, ty_to_string};\n+use util::ppaux::{ty_to_string};\n use util::ppaux::{trait_ref_to_string, Repr};\n \n use self::coercion::Coerce;\n@@ -227,6 +227,16 @@ pub enum SubregionOrigin {\n     AutoBorrow(Span),\n }\n \n+/// Times when we replace late-bound regions with variables:\n+#[deriving(Clone, Show)]\n+pub enum LateBoundRegionConversionTime {\n+    /// when a fn is called\n+    FnCall,\n+\n+    /// when two fn types are compared\n+    FnType,\n+}\n+\n /// Reasons to create a region inference variable\n ///\n /// See `error_reporting.rs` for more details\n@@ -256,11 +266,7 @@ pub enum RegionVariableOrigin {\n \n     // Region variables created for bound regions\n     // in a function or method that is called\n-    LateBoundRegion(Span, ty::BoundRegion),\n-\n-    // Region variables created for bound regions\n-    // when doing subtyping/lub/glb computations\n-    BoundRegionInFnType(Span, ty::BoundRegion),\n+    LateBoundRegion(Span, ty::BoundRegion, LateBoundRegionConversionTime),\n \n     UpvarRegion(ty::UpvarId, Span),\n \n@@ -959,22 +965,21 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.report_and_explain_type_error(trace, err);\n     }\n \n-    pub fn replace_late_bound_regions_with_fresh_regions(&self,\n-                                                         trace: TypeTrace,\n-                                                         fsig: &ty::FnSig)\n-                                                    -> (ty::FnSig,\n-                                                        FnvHashMap<ty::BoundRegion,\n-                                                                ty::Region>) {\n-        let (map, fn_sig) =\n-            replace_late_bound_regions(self.tcx, fsig.binder_id, fsig, |br| {\n-                let rvar = self.next_region_var(\n-                    BoundRegionInFnType(trace.origin.span(), br));\n-                debug!(\"Bound region {} maps to {}\",\n-                       bound_region_to_string(self.tcx, \"\", false, br),\n-                       rvar);\n-                rvar\n-            });\n-        (fn_sig, map)\n+    pub fn replace_late_bound_regions_with_fresh_var<T>(&self,\n+                                                        binder_id: ast::NodeId,\n+                                                        span: Span,\n+                                                        lbrct: LateBoundRegionConversionTime,\n+                                                        value: &T)\n+                                                        -> (T, FnvHashMap<ty::BoundRegion,ty::Region>)\n+                                                        where T : TypeFoldable + Repr\n+    {\n+        let (map, value) =\n+            replace_late_bound_regions(\n+                self.tcx,\n+                binder_id,\n+                value,\n+                |br| self.next_region_var(LateBoundRegion(span, br, lbrct)));\n+        (value, map)\n     }\n }\n \n@@ -1156,8 +1161,7 @@ impl RegionVariableOrigin {\n             Autoref(a) => a,\n             Coercion(ref a) => a.span(),\n             EarlyBoundRegion(a, _) => a,\n-            LateBoundRegion(a, _) => a,\n-            BoundRegionInFnType(a, _) => a,\n+            LateBoundRegion(a, _, _) => a,\n             BoundRegionInCoherence(_) => codemap::DUMMY_SP,\n             UpvarRegion(_, a) => a\n         }\n@@ -1182,12 +1186,8 @@ impl Repr for RegionVariableOrigin {\n             EarlyBoundRegion(a, b) => {\n                 format!(\"EarlyBoundRegion({},{})\", a.repr(tcx), b.repr(tcx))\n             }\n-            LateBoundRegion(a, b) => {\n-                format!(\"LateBoundRegion({},{})\", a.repr(tcx), b.repr(tcx))\n-            }\n-            BoundRegionInFnType(a, b) => {\n-                format!(\"bound_regionInFnType({},{})\", a.repr(tcx),\n-                b.repr(tcx))\n+            LateBoundRegion(a, b, c) => {\n+                format!(\"LateBoundRegion({},{},{})\", a.repr(tcx), b.repr(tcx), c)\n             }\n             BoundRegionInCoherence(a) => {\n                 format!(\"bound_regionInCoherence({})\", a.repr(tcx))"}, {"sha": "6f9000f55379cf8328100af02d862627ad5b0245", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=f8403aac81d5720bb722a85a9120c14ceb763eb9", "patch": "@@ -16,6 +16,7 @@ use middle::typeck::check::regionmanip::replace_late_bound_regions;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::{cres, CresCompare};\n use middle::typeck::infer::equate::Equate;\n+use middle::typeck::infer::FnType;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::lub::Lub;\n@@ -175,8 +176,8 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n         // First, we instantiate each bound region in the subtype with a fresh\n         // region variable.\n         let (a_sig, _) =\n-            self.fields.infcx.replace_late_bound_regions_with_fresh_regions(\n-                self.trace(), a);\n+            self.fields.infcx.replace_late_bound_regions_with_fresh_var(\n+                a.binder_id, self.trace().span(), FnType, a);\n \n         // Second, we instantiate each bound region in the supertype with a\n         // fresh concrete region."}, {"sha": "b116c84552e6a4b73346915e7b49637ca030d4cc", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=f8403aac81d5720bb722a85a9120c14ceb763eb9", "patch": "@@ -544,7 +544,7 @@ impl<'ast> Map<'ast> {\n \n     pub fn def_id_span(&self, def_id: DefId, fallback: Span) -> Span {\n         if def_id.krate == LOCAL_CRATE {\n-            self.span(def_id.node)\n+            self.opt_span(def_id.node).unwrap_or(fallback)\n         } else {\n             fallback\n         }"}, {"sha": "fcbf8a3d3519eb8f623282552a32c0fa1ae98360", "filename": "src/test/compile-fail/issue-16683.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Ftest%2Fcompile-fail%2Fissue-16683.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Ftest%2Fcompile-fail%2Fissue-16683.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16683.rs?ref=f8403aac81d5720bb722a85a9120c14ceb763eb9", "patch": "@@ -11,7 +11,7 @@\n trait T<'a> {\n     fn a(&'a self) -> &'a bool;\n     fn b(&self) {\n-        self.a(); //~ ERROR mismatched types: expected `&'a Self`, found `&Self` (lifetime mismatch)\n+        self.a(); //~ ERROR cannot infer\n     }\n }\n "}, {"sha": "a47f5c16a469159b7392adc6e5868c1f820c8d48", "filename": "src/test/compile-fail/issue-17758.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Ftest%2Fcompile-fail%2Fissue-17758.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Ftest%2Fcompile-fail%2Fissue-17758.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17758.rs?ref=f8403aac81d5720bb722a85a9120c14ceb763eb9", "patch": "@@ -15,7 +15,7 @@ trait Foo<'a> {\n     fn foo(&'a self);\n     fn bar(&self) {\n         self.foo();\n-        //~^ ERROR mismatched types: expected `&'a Self`, found `&Self` (lifetime mismatch)\n+        //~^ ERROR cannot infer\n     }\n }\n "}, {"sha": "5e3206ea51696df4a76ecef32f1a46c30997bcd1", "filename": "src/test/compile-fail/method-ambig-one-trait-coerce.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-one-trait-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-one-trait-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-one-trait-coerce.rs?ref=f8403aac81d5720bb722a85a9120c14ceb763eb9", "patch": "@@ -27,8 +27,14 @@ impl foo for Box<Object+Send> {\n }\n \n fn test1(x: Box<Object+Send+Sync>) {\n-    // Ambiguous because we could coerce to either impl:\n-    x.foo(); //~ ERROR E0034\n+    // FIXME(#18737) -- we ought to consider this to be ambiguous,\n+    // since we could coerce to either impl. However, what actually\n+    // happens is that we consider both impls applicable because of\n+    // incorrect subtyping relation. We then decide to call this a\n+    // call to the `foo` trait, leading to the following error\n+    // message.\n+\n+    x.foo(); //~ ERROR `foo` is not implemented\n }\n \n fn test2(x: Box<Object+Send>) {"}, {"sha": "6e4b5e088c9fcc00590440474ac13483ee0cfa80", "filename": "src/test/compile-fail/method-commit-to-trait.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f09279395b6ca40f1398277971586197f949738a/src%2Ftest%2Fcompile-fail%2Fmethod-commit-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f09279395b6ca40f1398277971586197f949738a/src%2Ftest%2Fcompile-fail%2Fmethod-commit-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-commit-to-trait.rs?ref=f09279395b6ca40f1398277971586197f949738a", "patch": "@@ -1,33 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that we pick `Foo`, and also pick the `impl`, even though in\n-// this case the vector type `T` is not copyable. This is because\n-// there is no other reasonable choice. The error you see is thus\n-// about `T` being non-copyable, not about `Foo` being\n-// unimplemented. This is better for user too, since it suggests minimal\n-// diff requird to fix program.\n-\n-trait Object { }\n-\n-trait Foo {\n-    fn foo(self) -> int;\n-}\n-\n-impl<T:Copy> Foo for Vec<T> {\n-    fn foo(self) -> int {1}\n-}\n-\n-fn test1<T>(x: Vec<T>) {\n-    x.foo();\n-    //~^ ERROR `core::kinds::Copy` is not implemented for the type `T`\n-}\n-\n-fn main() { }"}, {"sha": "c60a99ca0dfc0eea187f1c46e08fd971c0750d83", "filename": "src/test/compile-fail/unboxed-closures-type-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Ftest%2Fcompile-fail%2Funboxed-closures-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Ftest%2Fcompile-fail%2Funboxed-closures-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-type-mismatch.rs?ref=f8403aac81d5720bb722a85a9120c14ceb763eb9", "patch": "@@ -14,6 +14,6 @@ use std::ops::FnMut;\n \n pub fn main() {\n     let mut f = |&mut: x: int, y: int| -> int { x + y };\n-    let z = f.call_mut((1u, 2));    //~ ERROR mismatched types\n+    let z = f.call_mut((1u, 2));    //~ ERROR not implemented\n     println!(\"{}\", z);\n }"}, {"sha": "b45faca2de6024d7d0de72bf0658cb126b390eb2", "filename": "src/test/run-pass/method-recursive-blanket-impl.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Ftest%2Frun-pass%2Fmethod-recursive-blanket-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Ftest%2Frun-pass%2Fmethod-recursive-blanket-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-recursive-blanket-impl.rs?ref=f8403aac81d5720bb722a85a9120c14ceb763eb9", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we don't trigger on the blanket impl for all `&'a T` but\n+// rather keep autoderefing and trigger on the underlying impl.  To\n+// know not to stop at the blanket, we have to recursively evaluate\n+// the `T:Foo` bound.\n+\n+use std::kinds::Sized;\n+\n+// Note: this must be generic for the problem to show up\n+trait Foo<A> for Sized? {\n+    fn foo(&self);\n+}\n+\n+impl Foo<u8> for [u8] {\n+    fn foo(&self) {}\n+}\n+\n+impl<'a, A, T> Foo<A> for &'a T where T: Foo<A> {\n+    fn foo(&self) {\n+        Foo::foo(*self)\n+    }\n+}\n+\n+trait Bar {\n+    fn foo(&self);\n+}\n+\n+struct MyType;\n+\n+impl Bar for MyType {\n+    fn foo(&self) {}\n+}\n+\n+fn main() {\n+    let mut m = MyType;\n+    (&mut m).foo()\n+}"}, {"sha": "986236fb6f9fdc201f458462d17fd60c566bdea3", "filename": "src/test/run-pass/method-two-traits-distinguished-via-where-clause.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Ftest%2Frun-pass%2Fmethod-two-traits-distinguished-via-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8403aac81d5720bb722a85a9120c14ceb763eb9/src%2Ftest%2Frun-pass%2Fmethod-two-traits-distinguished-via-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-two-traits-distinguished-via-where-clause.rs?ref=f8403aac81d5720bb722a85a9120c14ceb763eb9", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we select between traits A and B. To do that, we must\n+// consider the `Sized` bound.\n+\n+trait A {\n+    fn foo(self);\n+}\n+\n+trait B {\n+    fn foo(self);\n+}\n+\n+impl<T: Sized> A for *const T {\n+    fn foo(self) {}\n+}\n+\n+impl<T> B for *const [T] {\n+    fn foo(self) {}\n+}\n+\n+fn main() {\n+    let x: [int, ..4] = [1,2,3,4];\n+    let xptr = x.as_slice() as *const _;\n+    xptr.foo();\n+}"}]}