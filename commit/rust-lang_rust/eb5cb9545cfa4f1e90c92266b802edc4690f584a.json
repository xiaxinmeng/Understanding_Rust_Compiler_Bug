{"sha": "eb5cb9545cfa4f1e90c92266b802edc4690f584a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViNWNiOTU0NWNmYTRmMWU5MGM5MjI2NmI4MDJlZGM0NjkwZjU4NGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-04T18:38:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-04T18:38:56Z"}, "message": "Auto merge of #39424 - nikomatsakis:incr-comp-skip-typeck-3, r=mw\n\nrewrite the predecessors code to create a reduced graph\n\nThe old code created a flat listing of \"HIR -> WorkProduct\" edges.\nWhile perfectly general, this could lead to a lot of repetition if the\nsame HIR nodes affect many work-products. This is set to be a problem\nwhen we start to skip typeck, since we will be adding a lot more\n\"work-product\"-like nodes.\n\nThe newer code uses an alternative strategy: it \"reduces\" the graph\ninstead. Basically we walk the dep-graph and convert it to a DAG, where\nwe only keep intermediate nodes if they are used by multiple\nwork-products.\n\nThis DAG does not contain the same set of nodes as the original graph,\nbut it is guaranteed that (a) every output node is included in the graph\nand (b) the set of input nodes that can reach each output node is\nunchanged.\n\n(Input nodes are basically HIR nodes and foreign metadata; output nodes\nare nodes that have assocaited state which we will persist to disk in\nsome way. These are assumed to be disjoint sets.)\n\nr? @michaelwoerister\n\nFixes #39494", "tree": {"sha": "16279a1fb43704ba946dde6ea0ea13d806dbce78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16279a1fb43704ba946dde6ea0ea13d806dbce78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb5cb9545cfa4f1e90c92266b802edc4690f584a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb5cb9545cfa4f1e90c92266b802edc4690f584a", "html_url": "https://github.com/rust-lang/rust/commit/eb5cb9545cfa4f1e90c92266b802edc4690f584a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb5cb9545cfa4f1e90c92266b802edc4690f584a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8967085617f13fd11067e632f4f29e7eb013c1fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/8967085617f13fd11067e632f4f29e7eb013c1fd", "html_url": "https://github.com/rust-lang/rust/commit/8967085617f13fd11067e632f4f29e7eb013c1fd"}, {"sha": "b3096e25c0a574cb20706adabe75667a215a86b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3096e25c0a574cb20706adabe75667a215a86b9", "html_url": "https://github.com/rust-lang/rust/commit/b3096e25c0a574cb20706adabe75667a215a86b9"}], "stats": {"total": 1688, "additions": 1209, "deletions": 479}, "files": [{"sha": "e3c339829f6a4f64cf0de3557601fe0682fd66ed", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=eb5cb9545cfa4f1e90c92266b802edc4690f584a", "patch": "@@ -23,6 +23,9 @@\n #![feature(staged_api)]\n #![feature(rand)]\n #![feature(core_intrinsics)]\n+#![feature(conservative_impl_trait)]\n+#![feature(field_init_shorthand)]\n+#![feature(pub_restricted)]\n \n extern crate graphviz;\n #[macro_use] extern crate rustc;"}, {"sha": "60f24b71de2452eb3660dfcb9f743153837d6e7f", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=eb5cb9545cfa4f1e90c92266b802edc4690f584a", "patch": "@@ -21,7 +21,7 @@ use super::directory::DefPathIndex;\n /// Data for use when recompiling the **current crate**.\n #[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct SerializedDepGraph {\n-    pub edges: Vec<SerializedEdge>,\n+    pub edges: Vec<SerializedEdgeSet>,\n \n     /// These are hashes of two things:\n     /// - the HIR nodes in this crate\n@@ -45,14 +45,13 @@ pub struct SerializedDepGraph {\n     pub hashes: Vec<SerializedHash>,\n }\n \n-/// Represents a \"reduced\" dependency edge. Unlike the full dep-graph,\n-/// the dep-graph we serialize contains only edges `S -> T` where the\n-/// source `S` is something hashable (a HIR node or foreign metadata)\n-/// and the target `T` is something significant, like a work-product.\n-/// Normally, significant nodes are only those that have saved data on\n-/// disk, but in unit-testing the set of significant nodes can be\n-/// increased.\n-pub type SerializedEdge = (DepNode<DefPathIndex>, DepNode<DefPathIndex>);\n+/// Represents a set of \"reduced\" dependency edge. We group the\n+/// outgoing edges from a single source together.\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n+pub struct SerializedEdgeSet {\n+    pub source: DepNode<DefPathIndex>,\n+    pub targets: Vec<DepNode<DefPathIndex>>\n+}\n \n #[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct SerializedHash {"}, {"sha": "798bc6e9f9856652125afc1163d1438e5c54b989", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=eb5cb9545cfa4f1e90c92266b802edc4690f584a", "patch": "@@ -67,9 +67,9 @@ pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let _ignore = tcx.dep_graph.in_ignore();\n     let dirty_inputs: FxHashSet<DepNode<DefId>> =\n-        dirty_inputs.iter()\n-                   .filter_map(|d| retraced.map(d))\n-                   .collect();\n+        dirty_inputs.keys()\n+                    .filter_map(|d| retraced.map(d))\n+                    .collect();\n     let query = tcx.dep_graph.query();\n     debug!(\"query-nodes: {:?}\", query.nodes());\n     let krate = tcx.hir.krate();"}, {"sha": "b371ab6aa31bc1ac05080e4e52f4fb6c0758df1e", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 94, "deletions": 79, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=eb5cb9545cfa4f1e90c92266b802edc4690f584a", "patch": "@@ -10,7 +10,7 @@\n \n //! Code to save/load the dep-graph from files.\n \n-use rustc::dep_graph::DepNode;\n+use rustc::dep_graph::{DepNode, WorkProductId};\n use rustc::hir::def_id::DefId;\n use rustc::hir::svh::Svh;\n use rustc::session::Session;\n@@ -19,6 +19,7 @@ use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use rustc_serialize::Decodable as RustcDecodable;\n use rustc_serialize::opaque::Decoder;\n use std::path::{Path};\n+use std::sync::Arc;\n \n use IncrementalHashesMap;\n use ich::Fingerprint;\n@@ -30,7 +31,9 @@ use super::fs::*;\n use super::file_format;\n use super::work_product;\n \n-pub type DirtyNodes = FxHashSet<DepNode<DefPathIndex>>;\n+// The key is a dirty node. The value is **some** base-input that we\n+// can blame it on.\n+pub type DirtyNodes = FxHashMap<DepNode<DefPathIndex>, DepNode<DefPathIndex>>;\n \n /// If we are in incremental mode, and a previous dep-graph exists,\n /// then load up those nodes/edges that are still valid into the\n@@ -149,86 +152,75 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let directory = DefIdDirectory::decode(&mut dep_graph_decoder)?;\n     let serialized_dep_graph = SerializedDepGraph::decode(&mut dep_graph_decoder)?;\n \n+    let edge_map: FxHashMap<_, _> = serialized_dep_graph.edges\n+                                                        .into_iter()\n+                                                        .map(|s| (s.source, s.targets))\n+                                                        .collect();\n+\n     // Retrace the paths in the directory to find their current location (if any).\n     let retraced = directory.retrace(tcx);\n \n-    // Compute the set of Hir nodes whose data has changed or which\n-    // have been removed.  These are \"raw\" source nodes, which means\n-    // that they still use the original `DefPathIndex` values from the\n-    // encoding, rather than having been retraced to a `DefId`. The\n-    // reason for this is that this way we can include nodes that have\n-    // been removed (which no longer have a `DefId` in the current\n-    // compilation).\n-    let dirty_raw_source_nodes = dirty_nodes(tcx,\n-                                             incremental_hashes_map,\n-                                             &serialized_dep_graph.hashes,\n-                                             &retraced);\n-\n-    // Create a list of (raw-source-node ->\n-    // retracted-target-node) edges. In the process of retracing the\n-    // target nodes, we may discover some of them def-paths no longer exist,\n-    // in which case there is no need to mark the corresopnding nodes as dirty\n-    // (they are just not present). So this list may be smaller than the original.\n-    //\n-    // Note though that in the common case the target nodes are\n-    // `DepNode::WorkProduct` instances, and those don't have a\n-    // def-id, so they will never be considered to not exist. Instead,\n-    // we do a secondary hashing step (later, in trans) when we know\n-    // the set of symbols that go into a work-product: if any symbols\n-    // have been removed (or added) the hash will be different and\n-    // we'll ignore the work-product then.\n-    let retraced_edges: Vec<_> =\n-        serialized_dep_graph.edges.iter()\n-                                  .filter_map(|&(ref raw_source_node, ref raw_target_node)| {\n-                                      retraced.map(raw_target_node)\n-                                              .map(|target_node| (raw_source_node, target_node))\n-                                  })\n-                                  .collect();\n-\n-    // Compute which work-products have an input that has changed or\n-    // been removed. Put the dirty ones into a set.\n-    let mut dirty_target_nodes = FxHashSet();\n-    for &(raw_source_node, ref target_node) in &retraced_edges {\n-        if dirty_raw_source_nodes.contains(raw_source_node) {\n-            if !dirty_target_nodes.contains(target_node) {\n-                dirty_target_nodes.insert(target_node.clone());\n-\n-                if tcx.sess.opts.debugging_opts.incremental_info {\n-                    // It'd be nice to pretty-print these paths better than just\n-                    // using the `Debug` impls, but wev.\n-                    println!(\"incremental: module {:?} is dirty because {:?} \\\n-                              changed or was removed\",\n-                             target_node,\n-                             raw_source_node.map_def(|&index| {\n-                                 Some(directory.def_path_string(tcx, index))\n-                             }).unwrap());\n+    // Compute the set of nodes from the old graph where some input\n+    // has changed or been removed. These are \"raw\" source nodes,\n+    // which means that they still use the original `DefPathIndex`\n+    // values from the encoding, rather than having been retraced to a\n+    // `DefId`. The reason for this is that this way we can include\n+    // nodes that have been removed (which no longer have a `DefId` in\n+    // the current compilation).\n+    let dirty_raw_nodes = initial_dirty_nodes(tcx,\n+                                              incremental_hashes_map,\n+                                              &serialized_dep_graph.hashes,\n+                                              &retraced);\n+    let dirty_raw_nodes = transitive_dirty_nodes(&edge_map, dirty_raw_nodes);\n+\n+    // Recreate the edges in the graph that are still clean.\n+    let mut clean_work_products = FxHashSet();\n+    let mut dirty_work_products = FxHashSet(); // incomplete; just used to suppress debug output\n+    for (source, targets) in &edge_map {\n+        for target in targets {\n+            // If the target is dirty, skip the edge. If this is an edge\n+            // that targets a work-product, we can print the blame\n+            // information now.\n+            if let Some(blame) = dirty_raw_nodes.get(target) {\n+                if let DepNode::WorkProduct(ref wp) = *target {\n+                    if tcx.sess.opts.debugging_opts.incremental_info {\n+                        if dirty_work_products.insert(wp.clone()) {\n+                            // It'd be nice to pretty-print these paths better than just\n+                            // using the `Debug` impls, but wev.\n+                            println!(\"incremental: module {:?} is dirty because {:?} \\\n+                                      changed or was removed\",\n+                                     wp,\n+                                     blame.map_def(|&index| {\n+                                         Some(directory.def_path_string(tcx, index))\n+                                     }).unwrap());\n+                        }\n+                    }\n                 }\n+                continue;\n             }\n-        }\n-    }\n \n-    // For work-products that are still clean, add their deps into the\n-    // graph. This is needed because later we will have to save this\n-    // back out again!\n-    let dep_graph = tcx.dep_graph.clone();\n-    for (raw_source_node, target_node) in retraced_edges {\n-        if dirty_target_nodes.contains(&target_node) {\n-            continue;\n+            // If the source is dirty, the target will be dirty.\n+            assert!(!dirty_raw_nodes.contains_key(source));\n+\n+            // Retrace the source -> target edges to def-ids and then\n+            // create an edge in the graph. Retracing may yield none if\n+            // some of the data happens to have been removed; this ought\n+            // to be impossible unless it is dirty, so we can unwrap.\n+            let source_node = retraced.map(source).unwrap();\n+            let target_node = retraced.map(target).unwrap();\n+            let _task = tcx.dep_graph.in_task(target_node);\n+            tcx.dep_graph.read(source_node);\n+            if let DepNode::WorkProduct(ref wp) = *target {\n+                clean_work_products.insert(wp.clone());\n+            }\n         }\n-\n-        let source_node = retraced.map(raw_source_node).unwrap();\n-\n-        debug!(\"decode_dep_graph: clean edge: {:?} -> {:?}\", source_node, target_node);\n-\n-        let _task = dep_graph.in_task(target_node);\n-        dep_graph.read(source_node);\n     }\n \n     // Add in work-products that are still clean, and delete those that are\n     // dirty.\n-    reconcile_work_products(tcx, work_products, &dirty_target_nodes);\n+    reconcile_work_products(tcx, work_products, &clean_work_products);\n \n-    dirty_clean::check_dirty_clean_annotations(tcx, &dirty_raw_source_nodes, &retraced);\n+    dirty_clean::check_dirty_clean_annotations(tcx, &dirty_raw_nodes, &retraced);\n \n     load_prev_metadata_hashes(tcx,\n                               &retraced,\n@@ -238,13 +230,13 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n /// Computes which of the original set of def-ids are dirty. Stored in\n /// a bit vector where the index is the DefPathIndex.\n-fn dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         incremental_hashes_map: &IncrementalHashesMap,\n-                         serialized_hashes: &[SerializedHash],\n-                         retraced: &RetracedDefIdDirectory)\n-                         -> DirtyNodes {\n+fn initial_dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 incremental_hashes_map: &IncrementalHashesMap,\n+                                 serialized_hashes: &[SerializedHash],\n+                                 retraced: &RetracedDefIdDirectory)\n+                                 -> DirtyNodes {\n     let mut hcx = HashContext::new(tcx, incremental_hashes_map);\n-    let mut dirty_nodes = FxHashSet();\n+    let mut dirty_nodes = FxHashMap();\n \n     for hash in serialized_hashes {\n         if let Some(dep_node) = retraced.map(&hash.dep_node) {\n@@ -277,21 +269,44 @@ fn dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                    hash.dep_node);\n         }\n \n-        dirty_nodes.insert(hash.dep_node.clone());\n+        dirty_nodes.insert(hash.dep_node.clone(), hash.dep_node.clone());\n     }\n \n     dirty_nodes\n }\n \n+fn transitive_dirty_nodes(edge_map: &FxHashMap<DepNode<DefPathIndex>, Vec<DepNode<DefPathIndex>>>,\n+                          mut dirty_nodes: DirtyNodes)\n+                          -> DirtyNodes\n+{\n+    let mut stack: Vec<(DepNode<DefPathIndex>, DepNode<DefPathIndex>)> = vec![];\n+    stack.extend(dirty_nodes.iter().map(|(s, b)| (s.clone(), b.clone())));\n+    while let Some((source, blame)) = stack.pop() {\n+        // we know the source is dirty (because of the node `blame`)...\n+        assert!(dirty_nodes.contains_key(&source));\n+\n+        // ...so we dirty all the targets (with the same blame)\n+        if let Some(targets) = edge_map.get(&source) {\n+            for target in targets {\n+                if !dirty_nodes.contains_key(target) {\n+                    dirty_nodes.insert(target.clone(), blame.clone());\n+                    stack.push((target.clone(), blame.clone()));\n+                }\n+            }\n+        }\n+    }\n+    dirty_nodes\n+}\n+\n /// Go through the list of work-products produced in the previous run.\n /// Delete any whose nodes have been found to be dirty or which are\n /// otherwise no longer applicable.\n fn reconcile_work_products<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      work_products: Vec<SerializedWorkProduct>,\n-                                     dirty_target_nodes: &FxHashSet<DepNode<DefId>>) {\n+                                     clean_work_products: &FxHashSet<Arc<WorkProductId>>) {\n     debug!(\"reconcile_work_products({:?})\", work_products);\n     for swp in work_products {\n-        if dirty_target_nodes.contains(&DepNode::WorkProduct(swp.id.clone())) {\n+        if !clean_work_products.contains(&swp.id) {\n             debug!(\"reconcile_work_products: dep-node for {:?} is dirty\", swp);\n             delete_dirty_work_product(tcx, swp);\n         } else {"}, {"sha": "3daeacfe87d8211ffc709546ee67ad80329e0337", "filename": "src/librustc_incremental/persist/preds.rs", "status": "removed", "additions": 0, "deletions": 366, "changes": 366, "blob_url": "https://github.com/rust-lang/rust/blob/8967085617f13fd11067e632f4f29e7eb013c1fd/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8967085617f13fd11067e632f4f29e7eb013c1fd/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs?ref=8967085617f13fd11067e632f4f29e7eb013c1fd", "patch": "@@ -1,366 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::dep_graph::{DepGraphQuery, DepNode};\n-use rustc::hir::def_id::DefId;\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::bitvec::BitVector;\n-use rustc_data_structures::graph::{NodeIndex, Graph};\n-\n-use super::hash::*;\n-use ich::Fingerprint;\n-\n-/// A data-structure that makes it easy to enumerate the hashable\n-/// predecessors of any given dep-node.\n-pub struct Predecessors<'query> {\n-    // - Keys: dep-nodes that may have work-products, output meta-data\n-    //   nodes.\n-    // - Values: transitive predecessors of the key that are hashable\n-    //   (e.g., HIR nodes, input meta-data nodes)\n-    pub inputs: FxHashMap<&'query DepNode<DefId>, Vec<&'query DepNode<DefId>>>,\n-\n-    // - Keys: some hashable node\n-    // - Values: the hash thereof\n-    pub hashes: FxHashMap<&'query DepNode<DefId>, Fingerprint>,\n-}\n-\n-impl<'q> Predecessors<'q> {\n-    pub fn new(query: &'q DepGraphQuery<DefId>, hcx: &mut HashContext) -> Self {\n-        let tcx = hcx.tcx;\n-\n-        let collect_for_metadata = tcx.sess.opts.debugging_opts.incremental_cc ||\n-                                   tcx.sess.opts.debugging_opts.query_dep_graph;\n-\n-        // Find nodes for which we want to know the full set of preds\n-        let node_count = query.graph.len_nodes();\n-\n-        // Set up some data structures the cache predecessor search needs:\n-        let mut visit_counts: Vec<u32> = Vec::new();\n-        let mut node_cache: Vec<Option<Box<[u32]>>> = Vec::new();\n-        visit_counts.resize(node_count, 0);\n-        node_cache.resize(node_count, None);\n-        let mut dfs_workspace1 = DfsWorkspace::new(node_count);\n-        let mut dfs_workspace2 = DfsWorkspace::new(node_count);\n-\n-        let inputs: FxHashMap<_, _> = query\n-            .graph\n-            .all_nodes()\n-            .iter()\n-            .enumerate()\n-            .filter(|&(_, node)| match node.data {\n-                DepNode::WorkProduct(_) => true,\n-                DepNode::MetaData(ref def_id) => collect_for_metadata && def_id.is_local(),\n-\n-                // if -Z query-dep-graph is passed, save more extended data\n-                // to enable better unit testing\n-                DepNode::TypeckTables(_) |\n-                DepNode::TransCrateItem(_) => tcx.sess.opts.debugging_opts.query_dep_graph,\n-\n-                _ => false,\n-            })\n-            .map(|(node_index, node)| {\n-                find_roots(&query.graph,\n-                           node_index as u32,\n-                           &mut visit_counts,\n-                           &mut node_cache[..],\n-                           HashContext::is_hashable,\n-                           &mut dfs_workspace1,\n-                           Some(&mut dfs_workspace2));\n-\n-                let inputs: Vec<_> = dfs_workspace1.output.nodes.iter().map(|&i| {\n-                    query.graph.node_data(NodeIndex(i as usize))\n-                }).collect();\n-\n-                (&node.data, inputs)\n-            })\n-            .collect();\n-\n-        let mut hashes = FxHashMap();\n-        for input in inputs.values().flat_map(|v| v.iter().cloned()) {\n-            hashes.entry(input)\n-                  .or_insert_with(|| hcx.hash(input).unwrap());\n-        }\n-\n-        Predecessors {\n-            inputs: inputs,\n-            hashes: hashes,\n-        }\n-    }\n-}\n-\n-const CACHING_THRESHOLD: u32 = 60;\n-\n-// Starting at `start_node`, this function finds this node's \"roots\", that is,\n-// anything that is hashable, in the dep-graph. It uses a simple depth-first\n-// search to achieve that. However, since some sub-graphs are traversed over\n-// and over again, the function also some caching built into it: Each time it\n-// visits a node it increases a counter for that node. If a node has been\n-// visited more often than CACHING_THRESHOLD, the function will allocate a\n-// cache entry in the `cache` array. This cache entry contains a flat list of\n-// all roots reachable from the given node. The next time the node is visited,\n-// the search can just add the contents of this array to the output instead of\n-// recursing further.\n-//\n-// The function takes two `DfsWorkspace` arguments. These contains some data\n-// structures that would be expensive to re-allocate all the time, so they are\n-// allocated once up-front. There are two of them because building a cache entry\n-// requires a recursive invocation of this function. Two are enough though,\n-// since function never recurses more than once.\n-fn find_roots<T, F>(graph: &Graph<T, ()>,\n-                    start_node: u32,\n-                    visit_counts: &mut [u32],\n-                    cache: &mut [Option<Box<[u32]>>],\n-                    is_root: F,\n-                    workspace: &mut DfsWorkspace,\n-                    mut sub_workspace: Option<&mut DfsWorkspace>)\n-    where F: Copy + Fn(&T) -> bool,\n-          T: ::std::fmt::Debug,\n-{\n-    workspace.visited.clear();\n-    workspace.output.clear();\n-    workspace.stack.clear();\n-    workspace.stack.push(start_node);\n-\n-    loop {\n-        let node = match workspace.stack.pop() {\n-            Some(node) => node,\n-            None => return,\n-        };\n-\n-        if !workspace.visited.insert(node as usize) {\n-            continue\n-        }\n-\n-        if is_root(graph.node_data(NodeIndex(node as usize))) {\n-            // If this is a root, just add it to the output.\n-            workspace.output.insert(node);\n-        } else {\n-            if let Some(ref cached) = cache[node as usize] {\n-                for &n in &cached[..] {\n-                    workspace.output.insert(n);\n-                }\n-                // No need to recurse further from this node\n-                continue\n-            }\n-\n-            visit_counts[node as usize] += 1;\n-\n-            // If this node has been visited often enough to be cached ...\n-            if visit_counts[node as usize] > CACHING_THRESHOLD {\n-                // ... we are actually allowed to cache something, do so:\n-                if let Some(ref mut sub_workspace) = sub_workspace {\n-                    // Note that the following recursive invocation does never\n-                    // write to the cache (since we pass None as sub_workspace).\n-                    // This is intentional: The graph we are working with\n-                    // contains cycles and this prevent us from simply building\n-                    // our caches recursively on-demand.\n-                    // However, we can just do a regular, non-caching DFS to\n-                    // yield the set of roots and cache that.\n-                    find_roots(graph,\n-                               node,\n-                               visit_counts,\n-                               cache,\n-                               is_root,\n-                               sub_workspace,\n-                               None);\n-\n-                    for &n in &sub_workspace.output.nodes {\n-                        workspace.output.insert(n);\n-                    }\n-\n-                    cache[node as usize] = Some(sub_workspace.output\n-                                                             .nodes\n-                                                             .clone()\n-                                                             .into_boxed_slice());\n-                    // No need to recurse further from this node\n-                    continue\n-                }\n-            }\n-\n-            for pred in graph.predecessor_nodes(NodeIndex(node as usize)) {\n-                workspace.stack.push(pred.node_id() as u32);\n-            }\n-        }\n-    }\n-}\n-\n-struct DfsWorkspace {\n-    stack: Vec<u32>,\n-    visited: BitVector,\n-    output: NodeIndexSet,\n-}\n-\n-impl DfsWorkspace {\n-    fn new(total_node_count: usize) -> DfsWorkspace {\n-        DfsWorkspace {\n-            stack: Vec::new(),\n-            visited: BitVector::new(total_node_count),\n-            output: NodeIndexSet::new(total_node_count),\n-        }\n-    }\n-}\n-\n-struct NodeIndexSet {\n-    bitset: BitVector,\n-    nodes: Vec<u32>,\n-}\n-\n-impl NodeIndexSet {\n-    fn new(total_node_count: usize) -> NodeIndexSet {\n-        NodeIndexSet {\n-            bitset: BitVector::new(total_node_count),\n-            nodes: Vec::new(),\n-        }\n-    }\n-\n-    #[inline]\n-    fn clear(&mut self) {\n-        self.bitset.clear();\n-        self.nodes.clear();\n-    }\n-\n-    #[inline]\n-    fn insert(&mut self, node: u32) {\n-        if self.bitset.insert(node as usize) {\n-            self.nodes.push(node)\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_cached_dfs_acyclic() {\n-\n-    //     0     1   2\n-    //     |      \\ /\n-    //     3---+   |\n-    //     |   |   |\n-    //     |   |   |\n-    //     4   5   6\n-    //      \\ / \\ / \\\n-    //       |   |   |\n-    //       7   8   9\n-\n-    let mut g: Graph<bool, ()> = Graph::new();\n-    g.add_node(false);\n-    g.add_node(false);\n-    g.add_node(false);\n-    g.add_node(false);\n-    g.add_node(false);\n-    g.add_node(false);\n-    g.add_node(false);\n-    g.add_node(true);\n-    g.add_node(true);\n-    g.add_node(true);\n-\n-    g.add_edge(NodeIndex(3), NodeIndex(0), ());\n-    g.add_edge(NodeIndex(4), NodeIndex(3), ());\n-    g.add_edge(NodeIndex(7), NodeIndex(4), ());\n-    g.add_edge(NodeIndex(5), NodeIndex(3), ());\n-    g.add_edge(NodeIndex(7), NodeIndex(5), ());\n-    g.add_edge(NodeIndex(8), NodeIndex(5), ());\n-    g.add_edge(NodeIndex(8), NodeIndex(6), ());\n-    g.add_edge(NodeIndex(9), NodeIndex(6), ());\n-    g.add_edge(NodeIndex(6), NodeIndex(1), ());\n-    g.add_edge(NodeIndex(6), NodeIndex(2), ());\n-\n-    let mut ws1 = DfsWorkspace::new(g.len_nodes());\n-    let mut ws2 = DfsWorkspace::new(g.len_nodes());\n-    let mut visit_counts: Vec<_> = g.all_nodes().iter().map(|_| 0u32).collect();\n-    let mut cache: Vec<Option<Box<[u32]>>> = g.all_nodes().iter().map(|_| None).collect();\n-\n-    fn is_root(x: &bool) -> bool { *x }\n-\n-    for _ in 0 .. CACHING_THRESHOLD + 1 {\n-        find_roots(&g, 5, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n-        ws1.output.nodes.sort();\n-        assert_eq!(ws1.output.nodes, vec![7, 8]);\n-\n-        find_roots(&g, 6, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n-        ws1.output.nodes.sort();\n-        assert_eq!(ws1.output.nodes, vec![8, 9]);\n-\n-        find_roots(&g, 0, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n-        ws1.output.nodes.sort();\n-        assert_eq!(ws1.output.nodes, vec![7, 8]);\n-\n-        find_roots(&g, 1, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n-        ws1.output.nodes.sort();\n-        assert_eq!(ws1.output.nodes, vec![8, 9]);\n-\n-        find_roots(&g, 2, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n-        ws1.output.nodes.sort();\n-        assert_eq!(ws1.output.nodes, vec![8, 9]);\n-\n-        find_roots(&g, 3, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n-        ws1.output.nodes.sort();\n-        assert_eq!(ws1.output.nodes, vec![7, 8]);\n-\n-        find_roots(&g, 4, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n-        ws1.output.nodes.sort();\n-        assert_eq!(ws1.output.nodes, vec![7]);\n-    }\n-}\n-\n-#[test]\n-fn test_cached_dfs_cyclic() {\n-\n-    //    0       1 <---- 2       3\n-    //    ^       |       ^       ^\n-    //    |       v       |       |\n-    //    4 ----> 5 ----> 6 ----> 7\n-    //    ^       ^       ^       ^\n-    //    |       |       |       |\n-    //    8       9      10      11\n-\n-\n-    let mut g: Graph<bool, ()> = Graph::new();\n-    g.add_node(false);\n-    g.add_node(false);\n-    g.add_node(false);\n-    g.add_node(false);\n-    g.add_node(false);\n-    g.add_node(false);\n-    g.add_node(false);\n-    g.add_node(false);\n-    g.add_node(true);\n-    g.add_node(true);\n-    g.add_node(true);\n-    g.add_node(true);\n-\n-    g.add_edge(NodeIndex( 4), NodeIndex(0), ());\n-    g.add_edge(NodeIndex( 8), NodeIndex(4), ());\n-    g.add_edge(NodeIndex( 4), NodeIndex(5), ());\n-    g.add_edge(NodeIndex( 1), NodeIndex(5), ());\n-    g.add_edge(NodeIndex( 9), NodeIndex(5), ());\n-    g.add_edge(NodeIndex( 5), NodeIndex(6), ());\n-    g.add_edge(NodeIndex( 6), NodeIndex(2), ());\n-    g.add_edge(NodeIndex( 2), NodeIndex(1), ());\n-    g.add_edge(NodeIndex(10), NodeIndex(6), ());\n-    g.add_edge(NodeIndex( 6), NodeIndex(7), ());\n-    g.add_edge(NodeIndex(11), NodeIndex(7), ());\n-    g.add_edge(NodeIndex( 7), NodeIndex(3), ());\n-\n-    let mut ws1 = DfsWorkspace::new(g.len_nodes());\n-    let mut ws2 = DfsWorkspace::new(g.len_nodes());\n-    let mut visit_counts: Vec<_> = g.all_nodes().iter().map(|_| 0u32).collect();\n-    let mut cache: Vec<Option<Box<[u32]>>> = g.all_nodes().iter().map(|_| None).collect();\n-\n-    fn is_root(x: &bool) -> bool { *x }\n-\n-    for _ in 0 .. CACHING_THRESHOLD + 1 {\n-        find_roots(&g, 2, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n-        ws1.output.nodes.sort();\n-        assert_eq!(ws1.output.nodes, vec![8, 9, 10]);\n-\n-        find_roots(&g, 3, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n-        ws1.output.nodes.sort();\n-        assert_eq!(ws1.output.nodes, vec![8, 9, 10, 11]);\n-    }\n-}"}, {"sha": "d2aa245c7c9424633718f3eadfe052b8accc5083", "filename": "src/librustc_incremental/persist/preds/compress/README.md", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2FREADME.md?ref=eb5cb9545cfa4f1e90c92266b802edc4690f584a", "patch": "@@ -0,0 +1,48 @@\n+Graph compression\n+\n+The graph compression algorithm is intended to remove and minimize the\n+size of the dependency graph so it can be saved, while preserving\n+everything we care about. In particular, given a set of input/output\n+nodes in the graph (which must be disjoint), we ensure that the set of\n+input nodes that can reach a given output node does not change,\n+although the intermediate nodes may change in various ways. In short,\n+the output nodes are intended to be the ones whose existence we care\n+about when we start up, because they have some associated data that we\n+will try to re-use (and hence if they are dirty, we have to throw that\n+data away). The other intermediate nodes don't really matter so much.\n+\n+### Overview\n+\n+The algorithm works as follows:\n+\n+1. Do a single walk of the graph to construct a DAG\n+    - in this walk, we identify and unify all cycles, electing a representative \"head\" node\n+    - this is done using the union-find implementation\n+    - this code is found in the `classify` module\n+2. The result from this walk is a `Dag`: \n+   - the set of SCCs, represented by the union-find table\n+   - a set of edges in the new DAG, represented by:\n+     - a vector of parent nodes for each child node\n+     - a vector of cross-edges\n+     - once these are canonicalized, some of these edges may turn out to be cyclic edges\n+       (i.e., an edge A -> A where A is the head of some SCC)\n+3. We pass this `Dag` into the construct code, which then creates a\n+   new graph.  This graph has a smaller set of indices which includes\n+   *at least* the inputs/outputs from the original graph, but may have\n+   other nodes as well, if keeping them reduces the overall size of\n+   the graph.\n+   - This code is found in the `construct` module.\n+   \n+### Some notes\n+\n+The input graph is assumed to have *read-by* edges. i.e., `A -> B`\n+means that the task B reads data from A. But the DAG defined by\n+classify is expressed in terms of *reads-from* edges, which are the\n+inverse. So `A -> B` is the same as `B -rf-> A`. *reads-from* edges\n+are more natural since we want to walk from the outputs to the inputs,\n+effectively. When we construct the final graph, we reverse these edges\n+back into the *read-by* edges common elsewhere.\n+\n+   \n+   \n+   "}, {"sha": "559bdbdd1e2e5d11d1a39ccc72c6cec508dfbaea", "filename": "src/librustc_incremental/persist/preds/compress/classify/mod.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Fclassify%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Fclassify%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Fclassify%2Fmod.rs?ref=eb5cb9545cfa4f1e90c92266b802edc4690f584a", "patch": "@@ -0,0 +1,151 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! First phase. Detect cycles and cross-edges.\n+\n+use super::*;\n+\n+#[cfg(test)]\n+mod test;\n+\n+pub struct Classify<'a, 'g: 'a, N: 'g, I: 'a, O: 'a>\n+    where N: Debug + Clone + 'g,\n+          I: Fn(&N) -> bool,\n+          O: Fn(&N) -> bool,\n+{\n+    r: &'a mut GraphReduce<'g, N, I, O>,\n+    stack: Vec<NodeIndex>,\n+    colors: Vec<Color>,\n+    dag: Dag,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+enum Color {\n+    // not yet visited\n+    White,\n+\n+    // visiting; usize is index on stack\n+    Grey(usize),\n+\n+    // finished visiting\n+    Black,\n+}\n+\n+impl<'a, 'g, N, I, O> Classify<'a, 'g, N, I, O>\n+    where N: Debug + Clone + 'g,\n+          I: Fn(&N) -> bool,\n+          O: Fn(&N) -> bool,\n+{\n+    pub(super) fn new(r: &'a mut GraphReduce<'g, N, I, O>) -> Self {\n+        Classify {\n+            r: r,\n+            colors: vec![Color::White; r.in_graph.len_nodes()],\n+            stack: vec![],\n+            dag: Dag {\n+                parents: (0..r.in_graph.len_nodes()).map(|i| NodeIndex(i)).collect(),\n+                cross_edges: vec![],\n+                input_nodes: vec![],\n+                output_nodes: vec![],\n+            },\n+        }\n+    }\n+\n+    pub(super) fn walk(mut self) -> Dag {\n+        for (index, node) in self.r.in_graph.all_nodes().iter().enumerate() {\n+            if (self.r.is_output)(&node.data) {\n+                let index = NodeIndex(index);\n+                self.dag.output_nodes.push(index);\n+                match self.colors[index.0] {\n+                    Color::White => self.open(index),\n+                    Color::Grey(_) => panic!(\"grey node but have not yet started a walk\"),\n+                    Color::Black => (), // already visited, skip\n+                }\n+            }\n+        }\n+\n+        // At this point we've identifed all the cycles, and we've\n+        // constructed a spanning tree over the original graph\n+        // (encoded in `self.parents`) as well as a list of\n+        // cross-edges that reflect additional edges from the DAG.\n+        //\n+        // If we converted each node to its `cycle-head` (a\n+        // representative choice from each SCC, basically) and then\n+        // take the union of `self.parents` and `self.cross_edges`\n+        // (after canonicalization), that is basically our DAG.\n+        //\n+        // Note that both of those may well contain trivial `X -rf-> X`\n+        // cycle edges after canonicalization, though. e.g., if you\n+        // have a graph `{A -rf-> B, B -rf-> A}`, we will have unioned A and\n+        // B, but A will also be B's parent (or vice versa), and hence\n+        // when we canonicalize the parent edge it would become `A -rf->\n+        // A` (or `B -rf-> B`).\n+        self.dag\n+    }\n+\n+    fn open(&mut self, node: NodeIndex) {\n+        let index = self.stack.len();\n+        self.stack.push(node);\n+        self.colors[node.0] = Color::Grey(index);\n+        for child in self.r.inputs(node) {\n+            self.walk_edge(node, child);\n+        }\n+        self.stack.pop().unwrap();\n+        self.colors[node.0] = Color::Black;\n+\n+        if (self.r.is_input)(&self.r.in_graph.node_data(node)) {\n+            // base inputs should have no inputs\n+            assert!(self.r.inputs(node).next().is_none());\n+            debug!(\"input: `{:?}`\", self.r.in_graph.node_data(node));\n+            self.dag.input_nodes.push(node);\n+        }\n+    }\n+\n+    fn walk_edge(&mut self, parent: NodeIndex, child: NodeIndex) {\n+        debug!(\"walk_edge: {:?} -rf-> {:?}, {:?}\",\n+               self.r.in_graph.node_data(parent),\n+               self.r.in_graph.node_data(child),\n+               self.colors[child.0]);\n+\n+        // Ignore self-edges, just in case they exist.\n+        if child == parent {\n+            return;\n+        }\n+\n+        match self.colors[child.0] {\n+            Color::White => {\n+                // Not yet visited this node; start walking it.\n+                assert_eq!(self.dag.parents[child.0], child);\n+                self.dag.parents[child.0] = parent;\n+                self.open(child);\n+            }\n+\n+            Color::Grey(stack_index) => {\n+                // Back-edge; unify everything on stack between here and `stack_index`\n+                // since we are all participating in a cycle\n+                assert!(self.stack[stack_index] == child);\n+\n+                for &n in &self.stack[stack_index..] {\n+                    debug!(\"cycle `{:?}` and `{:?}`\",\n+                           self.r.in_graph.node_data(n),\n+                           self.r.in_graph.node_data(parent));\n+                    self.r.mark_cycle(n, parent);\n+                }\n+            }\n+\n+            Color::Black => {\n+                // Cross-edge, record and ignore\n+                self.dag.cross_edges.push((parent, child));\n+                debug!(\"cross-edge `{:?} -rf-> {:?}`\",\n+                       self.r.in_graph.node_data(parent),\n+                       self.r.in_graph.node_data(child));\n+            }\n+        }\n+    }\n+}"}, {"sha": "ca26f714a2a747aa978df35c5401d1dfdd46b9f8", "filename": "src/librustc_incremental/persist/preds/compress/classify/test.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Fclassify%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Fclassify%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Fclassify%2Ftest.rs?ref=eb5cb9545cfa4f1e90c92266b802edc4690f584a", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::*;\n+\n+#[test]\n+fn detect_cycles() {\n+    let (graph, nodes) = graph! {\n+        A -> C0,\n+        A -> C1,\n+        B -> C1,\n+        C0 -> C1,\n+        C1 -> C0,\n+        C0 -> D,\n+        C1 -> E,\n+    };\n+    let inputs = [\"A\", \"B\"];\n+    let outputs = [\"D\", \"E\"];\n+    let mut reduce = GraphReduce::new(&graph, |n| inputs.contains(n), |n| outputs.contains(n));\n+    Classify::new(&mut reduce).walk();\n+\n+    assert!(!reduce.in_cycle(nodes(\"A\"), nodes(\"C0\")));\n+    assert!(!reduce.in_cycle(nodes(\"B\"), nodes(\"C0\")));\n+    assert!(reduce.in_cycle(nodes(\"C0\"), nodes(\"C1\")));\n+    assert!(!reduce.in_cycle(nodes(\"D\"), nodes(\"C0\")));\n+    assert!(!reduce.in_cycle(nodes(\"E\"), nodes(\"C0\")));\n+    assert!(!reduce.in_cycle(nodes(\"E\"), nodes(\"A\")));\n+}\n+\n+/// Regr test for a bug where we forgot to pop nodes off of the stack\n+/// as we were walking. In this case, because edges are pushed to the front\n+/// of the list, we would visit OUT, then A, then IN, and then close IN (but forget\n+/// to POP. Then visit B, C, and then A, which would mark everything from A to C as\n+/// cycle. But since we failed to pop IN, the stack was `OUT, A, IN, B, C` so that\n+/// marked C and IN as being in a cycle.\n+#[test]\n+fn edge_order1() {\n+    let (graph, nodes) = graph! {\n+        A -> C,\n+        C -> B,\n+        B -> A,\n+        IN -> B,\n+        IN -> A,\n+        A -> OUT,\n+    };\n+    let inputs = [\"IN\"];\n+    let outputs = [\"OUT\"];\n+    let mut reduce = GraphReduce::new(&graph, |n| inputs.contains(n), |n| outputs.contains(n));\n+    Classify::new(&mut reduce).walk();\n+\n+    // A, B, and C are mutually in a cycle, but IN/OUT are not participating.\n+    let names = [\"A\", \"B\", \"C\", \"IN\", \"OUT\"];\n+    let cycle_names = [\"A\", \"B\", \"C\"];\n+    for &i in &names {\n+        for &j in names.iter().filter(|&&j| j != i) {\n+            let in_cycle = cycle_names.contains(&i) && cycle_names.contains(&j);\n+            assert_eq!(reduce.in_cycle(nodes(i), nodes(j)), in_cycle,\n+                       \"cycle status for nodes {} and {} is incorrect\",\n+                       i, j);\n+        }\n+    }\n+}\n+\n+/// Same as `edge_order1` but in reverse order so as to detect a failure\n+/// if we were to enqueue edges onto end of list instead.\n+#[test]\n+fn edge_order2() {\n+    let (graph, nodes) = graph! {\n+        A -> OUT,\n+        IN -> A,\n+        IN -> B,\n+        B -> A,\n+        C -> B,\n+        A -> C,\n+    };\n+    let inputs = [\"IN\"];\n+    let outputs = [\"OUT\"];\n+    let mut reduce = GraphReduce::new(&graph, |n| inputs.contains(n), |n| outputs.contains(n));\n+    Classify::new(&mut reduce).walk();\n+\n+    assert!(reduce.in_cycle(nodes(\"B\"), nodes(\"C\")));\n+\n+    assert!(!reduce.in_cycle(nodes(\"IN\"), nodes(\"A\")));\n+    assert!(!reduce.in_cycle(nodes(\"IN\"), nodes(\"B\")));\n+    assert!(!reduce.in_cycle(nodes(\"IN\"), nodes(\"C\")));\n+    assert!(!reduce.in_cycle(nodes(\"IN\"), nodes(\"OUT\")));\n+}"}, {"sha": "394be74f7835f08fc7975386a59691c477425cfd", "filename": "src/librustc_incremental/persist/preds/compress/construct.rs", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Fconstruct.rs?ref=eb5cb9545cfa4f1e90c92266b802edc4690f584a", "patch": "@@ -0,0 +1,223 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Second phase. Construct new graph. The previous phase has\n+//! converted the input graph into a DAG by detecting and unifying\n+//! cycles. It provides us with the following (which is a\n+//! representation of the DAG):\n+//!\n+//! - SCCs, in the form of a union-find repr that can convert each node to\n+//!   its *cycle head* (an arbitrarly chosen representative from the cycle)\n+//! - a vector of *leaf nodes*, just a convenience\n+//! - a vector of *parents* for each node (in some cases, nodes have no parents,\n+//!   or their parent is another member of same cycle; in that case, the vector\n+//!   will be stored `v[i] == i`, after canonicalization)\n+//! - a vector of *cross edges*, meaning add'l edges between graphs nodes beyond\n+//!   the parents.\n+\n+use rustc_data_structures::fx::FxHashMap;\n+\n+use super::*;\n+\n+pub(super) fn construct_graph<'g, N, I, O>(r: &mut GraphReduce<'g, N, I, O>, dag: Dag)\n+                                           -> Reduction<'g, N>\n+    where N: Debug + Clone, I: Fn(&N) -> bool, O: Fn(&N) -> bool,\n+{\n+    let Dag { parents: old_parents, input_nodes, output_nodes, cross_edges } = dag;\n+    let in_graph = r.in_graph;\n+\n+    debug!(\"construct_graph\");\n+\n+    // Create a canonical list of edges; this includes both parent and\n+    // cross-edges. We store this in `(target -> Vec<source>)` form.\n+    // We call the first edge to any given target its \"parent\".\n+    let mut edges = FxHashMap();\n+    let old_parent_edges = old_parents.iter().cloned().zip((0..).map(NodeIndex));\n+    for (source, target) in old_parent_edges.chain(cross_edges) {\n+        debug!(\"original edge `{:?} -rf-> {:?}`\",\n+               in_graph.node_data(source),\n+               in_graph.node_data(target));\n+        let source = r.cycle_head(source);\n+        let target = r.cycle_head(target);\n+        if source != target {\n+            let v = edges.entry(target).or_insert(vec![]);\n+            if !v.contains(&source) {\n+                debug!(\"edge `{:?} -rf-> {:?}` is edge #{} with that target\",\n+                       in_graph.node_data(source),\n+                       in_graph.node_data(target),\n+                       v.len());\n+                v.push(source);\n+            }\n+        }\n+    }\n+    let parent = |ni: NodeIndex| -> NodeIndex {\n+        edges[&ni][0]\n+    };\n+\n+    // `retain_map`: a map of those nodes that we will want to\n+    // *retain* in the ultimate graph; the key is the node index in\n+    // the old graph, the value is the node index in the new\n+    // graph. These are nodes in the following categories:\n+    //\n+    // - inputs\n+    // - work-products\n+    // - targets of a cross-edge\n+    //\n+    // The first two categories hopefully make sense. We want the\n+    // inputs so we can compare hashes later. We want the\n+    // work-products so we can tell precisely when a given\n+    // work-product is invalidated. But the last one isn't strictly\n+    // needed; we keep cross-target edges so as to minimize the total\n+    // graph size.\n+    //\n+    // Consider a graph like:\n+    //\n+    //     WP0 -rf-> Y\n+    //     WP1 -rf-> Y\n+    //     Y -rf-> INPUT0\n+    //     Y -rf-> INPUT1\n+    //     Y -rf-> INPUT2\n+    //     Y -rf-> INPUT3\n+    //\n+    // Now if we were to remove Y, we would have a total of 8 edges: both WP0 and WP1\n+    // depend on INPUT0...INPUT3. As it is, we have 6 edges.\n+    //\n+    // NB: The current rules are not optimal. For example, given this\n+    // input graph:\n+    //\n+    //     OUT0 -rf-> X\n+    //     OUT1 -rf-> X\n+    //     X -rf -> INPUT0\n+    //\n+    // we will preserve X because it has two \"consumers\" (OUT0 and\n+    // OUT1).  We could as easily skip it, but we'd have to tally up\n+    // the number of input nodes that it (transitively) reaches, and I\n+    // was too lazy to do so. This is the unit test `suboptimal`.\n+\n+    let mut retain_map = FxHashMap();\n+    let mut new_graph = Graph::new();\n+\n+    {\n+        // Start by adding start-nodes and inputs.\n+        let retained_nodes = output_nodes.iter().chain(&input_nodes).map(|&n| r.cycle_head(n));\n+\n+        // Next add in targets of cross-edges. Due to the canonicalization,\n+        // some of these may be self-edges or may may duplicate the parent\n+        // edges, so ignore those.\n+        let retained_nodes = retained_nodes.chain(\n+            edges.iter()\n+                 .filter(|&(_, ref sources)| sources.len() > 1)\n+                 .map(|(&target, _)| target));\n+\n+        // Now create the new graph, adding in the entries from the map.\n+        for n in retained_nodes {\n+            retain_map.entry(n)\n+                      .or_insert_with(|| {\n+                          let data = in_graph.node_data(n);\n+                          debug!(\"retaining node `{:?}`\", data);\n+                          new_graph.add_node(data)\n+                      });\n+        }\n+    }\n+\n+    // Given a cycle-head `ni`, converts it to the closest parent that has\n+    // been retained in the output graph.\n+    let retained_parent = |mut ni: NodeIndex| -> NodeIndex {\n+        loop {\n+            debug!(\"retained_parent({:?})\", in_graph.node_data(ni));\n+            match retain_map.get(&ni) {\n+                Some(&v) => return v,\n+                None => ni = parent(ni),\n+            }\n+        }\n+    };\n+\n+    // Now add in the edges into the graph.\n+    for (&target, sources) in &edges {\n+        if let Some(&r_target) = retain_map.get(&target) {\n+            debug!(\"adding edges that target `{:?}`\", in_graph.node_data(target));\n+            for &source in sources {\n+                debug!(\"new edge `{:?} -rf-> {:?}`\",\n+                       in_graph.node_data(source),\n+                       in_graph.node_data(target));\n+                let r_source = retained_parent(source);\n+\n+                // NB. In the input graph, we have `a -> b` if b\n+                // **reads from** a. But in the terminology of this\n+                // code, we would describe that edge as `b -> a`,\n+                // because we have edges *from* outputs *to* inputs.\n+                // Therefore, when we create our new graph, we have to\n+                // reverse the edge.\n+                new_graph.add_edge(r_target, r_source, ());\n+            }\n+        } else {\n+            assert_eq!(sources.len(), 1);\n+        }\n+    }\n+\n+    // One complication. In some cases, output nodes *may* participate in\n+    // cycles. An example:\n+    //\n+    //             [HIR0]                    [HIR1]\n+    //               |                         |\n+    //               v                         v\n+    //      TypeckClosureBody(X) -> ItemSignature(X::SomeClosureInX)\n+    //            |  ^                         | |\n+    //            |  +-------------------------+ |\n+    //            |                              |\n+    //            v                              v\n+    //           Foo                            Bar\n+    //\n+    // In these cases, the output node may not wind up as the head\n+    // of the cycle, in which case it would be absent from the\n+    // final graph. We don't wish this to happen, therefore we go\n+    // over the list of output nodes again and check for any that\n+    // are not their own cycle-head. If we find such a node, we\n+    // add it to the graph now with an edge from the cycle head.\n+    // So the graph above could get transformed into this:\n+    //\n+    //                                    [HIR0, HIR1]\n+    //                                         |\n+    //                                         v\n+    //      TypeckClosureBody(X)    ItemSignature(X::SomeClosureInX)\n+    //               ^                         | |\n+    //               +-------------------------+ |\n+    //                                           v\n+    //                                       [Foo, Bar]\n+    //\n+    // (Note that all the edges here are \"read-by\" edges, not\n+    // \"reads-from\" edges.)\n+    for &output_node in &output_nodes {\n+        let head = r.cycle_head(output_node);\n+        if output_node == head {\n+            assert!(retain_map.contains_key(&output_node));\n+        } else {\n+            assert!(!retain_map.contains_key(&output_node));\n+            let output_data = in_graph.node_data(output_node);\n+            let new_node = new_graph.add_node(output_data);\n+            let new_head_node = retain_map[&head];\n+            new_graph.add_edge(new_head_node, new_node, ());\n+        }\n+    }\n+\n+    // Finally, prepare a list of the input node indices as found in\n+    // the new graph. Note that since all input nodes are leaves in\n+    // the graph, they should never participate in a cycle.\n+    let input_nodes =\n+        input_nodes.iter()\n+                   .map(|&n| {\n+                       assert_eq!(r.cycle_head(n), n, \"input node participating in a cycle\");\n+                       retain_map[&n]\n+                   })\n+                   .collect();\n+\n+    Reduction { graph: new_graph, input_nodes: input_nodes }\n+}\n+"}, {"sha": "a286862e9551f9d9a468e9c6f26d12157173c939", "filename": "src/librustc_incremental/persist/preds/compress/dag_id.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Fdag_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Fdag_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Fdag_id.rs?ref=eb5cb9545cfa4f1e90c92266b802edc4690f584a", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc_data_structures::graph::NodeIndex;\n+use rustc_data_structures::unify::UnifyKey;\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct DagId {\n+    index: u32,\n+}\n+\n+impl DagId {\n+    pub fn from_input_index(n: NodeIndex) -> Self {\n+        DagId { index: n.0 as u32 }\n+    }\n+\n+    pub fn as_input_index(&self) -> NodeIndex {\n+        NodeIndex(self.index as usize)\n+    }\n+}\n+\n+impl UnifyKey for DagId {\n+    type Value = ();\n+\n+    fn index(&self) -> u32 {\n+        self.index\n+    }\n+\n+    fn from_index(u: u32) -> Self {\n+        DagId { index: u }\n+    }\n+\n+    fn tag(_: Option<Self>) -> &'static str {\n+        \"DagId\"\n+    }\n+}"}, {"sha": "974a2221a4575bf6f35107c044a81c03492b97dc", "filename": "src/librustc_incremental/persist/preds/compress/mod.rs", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Fmod.rs?ref=eb5cb9545cfa4f1e90c92266b802edc4690f584a", "patch": "@@ -0,0 +1,125 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Graph compression. See `README.md`.\n+\n+use rustc_data_structures::graph::{Graph, NodeIndex};\n+use rustc_data_structures::unify::UnificationTable;\n+use std::fmt::Debug;\n+\n+#[cfg(test)]\n+#[macro_use]\n+mod test_macro;\n+\n+mod construct;\n+\n+mod classify;\n+use self::classify::Classify;\n+\n+mod dag_id;\n+use self::dag_id::DagId;\n+\n+#[cfg(test)]\n+mod test;\n+\n+pub fn reduce_graph<N, I, O>(graph: &Graph<N, ()>,\n+                             is_input: I,\n+                             is_output: O) -> Reduction<N>\n+    where N: Debug + Clone,\n+          I: Fn(&N) -> bool,\n+          O: Fn(&N) -> bool,\n+{\n+    GraphReduce::new(graph, is_input, is_output).compute()\n+}\n+\n+pub struct Reduction<'q, N> where N: 'q + Debug + Clone {\n+    pub graph: Graph<&'q N, ()>,\n+    pub input_nodes: Vec<NodeIndex>,\n+}\n+\n+struct GraphReduce<'q, N, I, O>\n+    where N: 'q + Debug + Clone,\n+          I: Fn(&N) -> bool,\n+          O: Fn(&N) -> bool,\n+{\n+    in_graph: &'q Graph<N, ()>,\n+    unify: UnificationTable<DagId>,\n+    is_input: I,\n+    is_output: O,\n+}\n+\n+struct Dag {\n+    // The \"parent\" of a node is the node which reached it during the\n+    // initial DFS. To encode the case of \"no parent\" (i.e., for the\n+    // roots of the walk), we make `parents[i] == i` to start, which\n+    // turns out be convenient.\n+    parents: Vec<NodeIndex>,\n+\n+    // Additional edges beyond the parents.\n+    cross_edges: Vec<(NodeIndex, NodeIndex)>,\n+\n+    // Nodes which we found that are considered \"outputs\"\n+    output_nodes: Vec<NodeIndex>,\n+\n+    // Nodes which we found that are considered \"inputs\"\n+    input_nodes: Vec<NodeIndex>,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+struct DagNode {\n+    in_index: NodeIndex\n+}\n+\n+impl<'q, N, I, O> GraphReduce<'q, N, I, O>\n+    where N: Debug + Clone,\n+          I: Fn(&N) -> bool,\n+          O: Fn(&N) -> bool,\n+{\n+    fn new(in_graph: &'q Graph<N, ()>, is_input: I, is_output: O) -> Self {\n+        let mut unify = UnificationTable::new();\n+\n+        // create a set of unification keys whose indices\n+        // correspond to the indices from the input graph\n+        for i in 0..in_graph.len_nodes() {\n+            let k = unify.new_key(());\n+            assert!(k == DagId::from_input_index(NodeIndex(i)));\n+        }\n+\n+        GraphReduce { in_graph, unify, is_input, is_output }\n+    }\n+\n+    fn compute(mut self) -> Reduction<'q, N> {\n+        let dag = Classify::new(&mut self).walk();\n+        construct::construct_graph(&mut self, dag)\n+    }\n+\n+    fn inputs(&self, in_node: NodeIndex) -> impl Iterator<Item = NodeIndex> + 'q {\n+        self.in_graph.predecessor_nodes(in_node)\n+    }\n+\n+    fn mark_cycle(&mut self, in_node1: NodeIndex, in_node2: NodeIndex) {\n+        let dag_id1 = DagId::from_input_index(in_node1);\n+        let dag_id2 = DagId::from_input_index(in_node2);\n+        self.unify.union(dag_id1, dag_id2);\n+    }\n+\n+    /// Convert a dag-id into its cycle head representative. This will\n+    /// be a no-op unless `in_node` participates in a cycle, in which\n+    /// case a distinct node *may* be returned.\n+    fn cycle_head(&mut self, in_node: NodeIndex) -> NodeIndex {\n+        let i = DagId::from_input_index(in_node);\n+        self.unify.find(i).as_input_index()\n+    }\n+\n+    #[cfg(test)]\n+    fn in_cycle(&mut self, ni1: NodeIndex, ni2: NodeIndex) -> bool {\n+        self.cycle_head(ni1) == self.cycle_head(ni2)\n+    }\n+}"}, {"sha": "1c5130845a855ed9c75d313e707a6d8f912b0c11", "filename": "src/librustc_incremental/persist/preds/compress/test.rs", "status": "added", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Ftest.rs?ref=eb5cb9545cfa4f1e90c92266b802edc4690f584a", "patch": "@@ -0,0 +1,259 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::*;\n+\n+fn reduce(graph: &Graph<&'static str, ()>,\n+          inputs: &[&'static str],\n+          outputs: &[&'static str],\n+          expected: &[&'static str])\n+{\n+    let reduce = GraphReduce::new(&graph,\n+                                  |n| inputs.contains(n),\n+                                  |n| outputs.contains(n));\n+    let result = reduce.compute();\n+    let mut edges: Vec<String> =\n+        result.graph\n+              .all_edges()\n+              .iter()\n+              .map(|edge| format!(\"{} -> {}\",\n+                                  result.graph.node_data(edge.source()),\n+                                  result.graph.node_data(edge.target())))\n+              .collect();\n+    edges.sort();\n+    println!(\"{:#?}\", edges);\n+    assert_eq!(edges.len(), expected.len());\n+    for (expected, actual) in expected.iter().zip(&edges) {\n+        assert_eq!(expected, actual);\n+    }\n+}\n+\n+#[test]\n+fn test1() {\n+    //  +---------------+\n+    //  |               |\n+    //  |      +--------|------+\n+    //  |      |        v      v\n+    // [A] -> [C0] -> [C1]    [D]\n+    //        [  ] <- [  ] -> [E]\n+    //                  ^\n+    // [B] -------------+\n+    let (graph, _nodes) = graph! {\n+        A -> C0,\n+        A -> C1,\n+        B -> C1,\n+        C0 -> C1,\n+        C1 -> C0,\n+        C0 -> D,\n+        C1 -> E,\n+    };\n+\n+    // [A] -> [C1] -> [D]\n+    // [B] -> [  ] -> [E]\n+    reduce(&graph, &[\"A\", \"B\"], &[\"D\", \"E\"], &[\n+        \"A -> C1\",\n+        \"B -> C1\",\n+        \"C1 -> D\",\n+        \"C1 -> E\",\n+    ]);\n+}\n+\n+#[test]\n+fn test2() {\n+    //  +---------------+\n+    //  |               |\n+    //  |      +--------|------+\n+    //  |      |        v      v\n+    // [A] -> [C0] -> [C1]    [D] -> [E]\n+    //        [  ] <- [  ]\n+    //                  ^\n+    // [B] -------------+\n+    let (graph, _nodes) = graph! {\n+        A -> C0,\n+        A -> C1,\n+        B -> C1,\n+        C0 -> C1,\n+        C1 -> C0,\n+        C0 -> D,\n+        D -> E,\n+    };\n+\n+    // [A] -> [D] -> [E]\n+    // [B] -> [ ]\n+    reduce(&graph, &[\"A\", \"B\"], &[\"D\", \"E\"], &[\n+        \"A -> D\",\n+        \"B -> D\",\n+        \"D -> E\",\n+    ]);\n+}\n+\n+#[test]\n+fn test2b() {\n+    // Variant on test2 in which [B] is not\n+    // considered an input.\n+    let (graph, _nodes) = graph! {\n+        A -> C0,\n+        A -> C1,\n+        B -> C1,\n+        C0 -> C1,\n+        C1 -> C0,\n+        C0 -> D,\n+        D -> E,\n+    };\n+\n+    // [A] -> [D] -> [E]\n+    reduce(&graph, &[\"A\"], &[\"D\", \"E\"], &[\n+        \"A -> D\",\n+        \"D -> E\",\n+    ]);\n+}\n+\n+#[test]\n+fn test3() {\n+\n+    // Edges going *downwards*, so 0, 1 and 2 are inputs,\n+    // while 7, 8, and 9 are outputs.\n+    //\n+    //     0     1   2\n+    //     |      \\ /\n+    //     3---+   |\n+    //     |   |   |\n+    //     |   |   |\n+    //     4   5   6\n+    //      \\ / \\ / \\\n+    //       |   |   |\n+    //       7   8   9\n+    //\n+    // Here the end result removes node 4, instead encoding an edge\n+    // from n3 -> n7, but keeps nodes 5 and 6, as they are common\n+    // inputs to nodes 8/9.\n+\n+    let (graph, _nodes) = graph! {\n+        n0 -> n3,\n+        n3 -> n4,\n+        n3 -> n5,\n+        n4 -> n7,\n+        n5 -> n7,\n+        n5 -> n8,\n+        n1 -> n6,\n+        n2 -> n6,\n+        n6 -> n8,\n+        n6 -> n9,\n+    };\n+\n+    reduce(&graph, &[\"n0\", \"n1\", \"n2\"], &[\"n7\", \"n8\", \"n9\"], &[\n+        \"n0 -> n3\",\n+        \"n1 -> n6\",\n+        \"n2 -> n6\",\n+        \"n3 -> n5\",\n+        \"n3 -> n7\",\n+        \"n5 -> n7\",\n+        \"n5 -> n8\",\n+        \"n6 -> n8\",\n+        \"n6 -> n9\"\n+    ]);\n+}\n+\n+#[test]\n+fn test_cached_dfs_cyclic() {\n+\n+    //    0       1 <---- 2       3\n+    //    ^       |       ^       ^\n+    //    |       v       |       |\n+    //    4 ----> 5 ----> 6 ----> 7\n+    //    ^       ^       ^       ^\n+    //    |       |       |       |\n+    //    8       9      10      11\n+\n+    let (graph, _nodes) = graph! {\n+        // edges from above diagram, in columns, top-to-bottom:\n+        n4 -> n0,\n+        n8 -> n4,\n+        n4 -> n5,\n+        n1 -> n5,\n+        n9 -> n5,\n+        n2 -> n1,\n+        n5 -> n6,\n+        n6 -> n2,\n+        n10 -> n6,\n+        n6 -> n7,\n+        n7 -> n3,\n+        n11 -> n7,\n+    };\n+\n+    //    0       1  2            3\n+    //    ^       ^ /             ^\n+    //    |       |/              |\n+    //    4 ----> 5 --------------+\n+    //    ^       ^ \\             |\n+    //    |       |  \\            |\n+    //    8       9   10         11\n+\n+    reduce(&graph, &[\"n8\", \"n9\", \"n10\", \"n11\"], &[\"n0\", \"n1\", \"n2\", \"n3\"], &[\n+        \"n10 -> n5\",\n+        \"n11 -> n3\",\n+        \"n4 -> n0\",\n+        \"n4 -> n5\",\n+        \"n5 -> n1\",\n+        \"n5 -> n2\",\n+        \"n5 -> n3\",\n+        \"n8 -> n4\",\n+        \"n9 -> n5\"\n+    ]);\n+}\n+\n+/// Demonstrates the case where we don't reduce as much as we could.\n+#[test]\n+fn suboptimal() {\n+    let (graph, _nodes) = graph! {\n+        INPUT0 -> X,\n+        X -> OUTPUT0,\n+        X -> OUTPUT1,\n+    };\n+\n+    reduce(&graph, &[\"INPUT0\"], &[\"OUTPUT0\", \"OUTPUT1\"], &[\n+        \"INPUT0 -> X\",\n+        \"X -> OUTPUT0\",\n+        \"X -> OUTPUT1\"\n+    ]);\n+}\n+\n+#[test]\n+fn test_cycle_output() {\n+    //  +---------------+\n+    //  |               |\n+    //  |      +--------|------+\n+    //  |      |        v      v\n+    // [A] -> [C0] <-> [C1] <- [D]\n+    //                  +----> [E]\n+    //                          ^\n+    // [B] ----------------- ---+\n+    let (graph, _nodes) = graph! {\n+        A -> C0,\n+        A -> C1,\n+        B -> E,\n+        C0 -> C1,\n+        C1 -> C0,\n+        C0 -> D,\n+        C1 -> E,\n+        D -> C1,\n+    };\n+\n+    // [A] -> [C0] --> [D]\n+    //          +----> [E]\n+    //                  ^\n+    // [B] -------------+\n+    reduce(&graph, &[\"A\", \"B\"], &[\"D\", \"E\"], &[\n+        \"A -> C0\",\n+        \"B -> E\",\n+        \"C0 -> D\",\n+        \"C0 -> E\",\n+    ]);\n+}"}, {"sha": "31b30d2b2857cb253e97e8a1a94b581f8ae52ae2", "filename": "src/librustc_incremental/persist/preds/compress/test_macro.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Ftest_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Ftest_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Ftest_macro.rs?ref=eb5cb9545cfa4f1e90c92266b802edc4690f584a", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! graph {\n+    ($( $source:ident -> $target:ident, )*) => {\n+        {\n+            use $crate::rustc_data_structures::graph::{Graph, NodeIndex};\n+            use $crate::rustc_data_structures::fx::FxHashMap;\n+\n+            let mut graph = Graph::new();\n+            let mut nodes: FxHashMap<&'static str, NodeIndex> = FxHashMap();\n+\n+            for &name in &[ $(stringify!($source), stringify!($target)),* ] {\n+                let name: &'static str = name;\n+                nodes.entry(name)\n+                     .or_insert_with(|| graph.add_node(name));\n+            }\n+\n+            $(\n+                {\n+                    let source = nodes[&stringify!($source)];\n+                    let target = nodes[&stringify!($target)];\n+                    graph.add_edge(source, target, ());\n+                }\n+            )*\n+\n+            let f = move |name: &'static str| -> NodeIndex { nodes[&name] };\n+\n+            (graph, f)\n+        }\n+    }\n+}\n+\n+macro_rules! set {\n+    ($( $value:expr ),*) => {\n+        {\n+            use $crate::rustc_data_structures::fx::FxHashSet;\n+            let mut set = FxHashSet();\n+            $(set.insert($value);)*\n+            set\n+        }\n+    }\n+}"}, {"sha": "a80620fbde66fad189b134e9449e3d8c33283951", "filename": "src/librustc_incremental/persist/preds/mod.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs?ref=eb5cb9545cfa4f1e90c92266b802edc4690f584a", "patch": "@@ -0,0 +1,75 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::dep_graph::{DepGraphQuery, DepNode};\n+use rustc::hir::def_id::DefId;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::graph::Graph;\n+\n+use super::hash::*;\n+use ich::Fingerprint;\n+\n+mod compress;\n+\n+/// A data-structure that makes it easy to enumerate the hashable\n+/// predecessors of any given dep-node.\n+pub struct Predecessors<'query> {\n+    // A reduced version of the input graph that contains fewer nodes.\n+    // This is intended to keep all of the base inputs (i.e., HIR\n+    // nodes) and all of the \"work-products\" we may care about\n+    // later. Other nodes may be retained if it keeps the overall size\n+    // of the graph down.\n+    pub reduced_graph: Graph<&'query DepNode<DefId>, ()>,\n+\n+    // For the inputs (hir/foreign-metadata), we include hashes.\n+    pub hashes: FxHashMap<&'query DepNode<DefId>, Fingerprint>,\n+}\n+\n+impl<'q> Predecessors<'q> {\n+    pub fn new(query: &'q DepGraphQuery<DefId>, hcx: &mut HashContext) -> Self {\n+        let tcx = hcx.tcx;\n+\n+        let collect_for_metadata = tcx.sess.opts.debugging_opts.incremental_cc ||\n+            tcx.sess.opts.debugging_opts.query_dep_graph;\n+\n+        // Find the set of \"start nodes\". These are nodes that we will\n+        // possibly query later.\n+        let is_output = |node: &DepNode<DefId>| -> bool {\n+            match *node {\n+                DepNode::WorkProduct(_) => true,\n+                DepNode::MetaData(ref def_id) => collect_for_metadata && def_id.is_local(),\n+\n+                // if -Z query-dep-graph is passed, save more extended data\n+                // to enable better unit testing\n+                DepNode::TypeckTables(_) |\n+                DepNode::TransCrateItem(_) => tcx.sess.opts.debugging_opts.query_dep_graph,\n+\n+                _ => false,\n+            }\n+        };\n+\n+        // Reduce the graph to the most important nodes.\n+        let compress::Reduction { graph, input_nodes } =\n+            compress::reduce_graph(&query.graph, HashContext::is_hashable, is_output);\n+\n+        let mut hashes = FxHashMap();\n+        for input_index in input_nodes {\n+            let input = *graph.node_data(input_index);\n+            debug!(\"computing hash for input node `{:?}`\", input);\n+            hashes.entry(input)\n+                  .or_insert_with(|| hcx.hash(input).unwrap());\n+        }\n+\n+        Predecessors {\n+            reduced_graph: graph,\n+            hashes: hashes,\n+        }\n+    }\n+}"}, {"sha": "34bb125ef3f45d130dd8a53a14162103559f62f7", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 33, "deletions": 22, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb5cb9545cfa4f1e90c92266b802edc4690f584a/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=eb5cb9545cfa4f1e90c92266b802edc4690f584a", "patch": "@@ -14,6 +14,7 @@ use rustc::hir::svh::Svh;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::graph::{NodeIndex, INCOMING};\n use rustc_serialize::Encodable as RustcEncodable;\n use rustc_serialize::opaque::Encoder;\n use std::hash::Hash;\n@@ -177,8 +178,10 @@ pub fn encode_dep_graph(preds: &Predecessors,\n \n     // Create a flat list of (Input, WorkProduct) edges for\n     // serialization.\n-    let mut edges = vec![];\n-    for (&target, sources) in &preds.inputs {\n+    let mut edges = FxHashMap();\n+    for edge in preds.reduced_graph.all_edges() {\n+        let source = *preds.reduced_graph.node_data(edge.source());\n+        let target = *preds.reduced_graph.node_data(edge.target());\n         match *target {\n             DepNode::MetaData(ref def_id) => {\n                 // Metadata *targets* are always local metadata nodes. We have\n@@ -188,11 +191,10 @@ pub fn encode_dep_graph(preds: &Predecessors,\n             }\n             _ => (),\n         }\n+        debug!(\"serialize edge: {:?} -> {:?}\", source, target);\n+        let source = builder.map(source);\n         let target = builder.map(target);\n-        for &source in sources {\n-            let source = builder.map(source);\n-            edges.push((source, target.clone()));\n-        }\n+        edges.entry(source).or_insert(vec![]).push(target);\n     }\n \n     if tcx.sess.opts.debugging_opts.incremental_dump_hash {\n@@ -202,6 +204,9 @@ pub fn encode_dep_graph(preds: &Predecessors,\n     }\n \n     // Create the serialized dep-graph.\n+    let edges = edges.into_iter()\n+                     .map(|(k, v)| SerializedEdgeSet { source: k, targets: v })\n+                     .collect();\n     let graph = SerializedDepGraph {\n         edges: edges,\n         hashes: preds.hashes\n@@ -250,12 +255,10 @@ pub fn encode_metadata_hashes(tcx: TyCtxt,\n \n     let mut def_id_hashes = FxHashMap();\n \n-    for (&target, sources) in &preds.inputs {\n-        let def_id = match *target {\n-            DepNode::MetaData(def_id) => {\n-                assert!(def_id.is_local());\n-                def_id\n-            }\n+    for (index, target) in preds.reduced_graph.all_nodes().iter().enumerate() {\n+        let index = NodeIndex(index);\n+        let def_id = match *target.data {\n+            DepNode::MetaData(def_id) if def_id.is_local() => def_id,\n             _ => continue,\n         };\n \n@@ -281,13 +284,18 @@ pub fn encode_metadata_hashes(tcx: TyCtxt,\n         // is the det. hash of the def-path. This is convenient\n         // because we can sort this to get a stable ordering across\n         // compilations, even if the def-ids themselves have changed.\n-        let mut hashes: Vec<(DepNode<u64>, Fingerprint)> = sources.iter()\n-            .map(|dep_node| {\n-                let hash_dep_node = dep_node.map_def(|&def_id| Some(def_id_hash(def_id))).unwrap();\n-                let hash = preds.hashes[dep_node];\n-                (hash_dep_node, hash)\n-            })\n-            .collect();\n+        let mut hashes: Vec<(DepNode<u64>, Fingerprint)> =\n+            preds.reduced_graph\n+                 .depth_traverse(index, INCOMING)\n+                 .map(|index| preds.reduced_graph.node_data(index))\n+                 .filter(|dep_node| HashContext::is_hashable(dep_node))\n+                 .map(|dep_node| {\n+                     let hash_dep_node = dep_node.map_def(|&def_id| Some(def_id_hash(def_id)))\n+                                                 .unwrap();\n+                     let hash = preds.hashes[dep_node];\n+                     (hash_dep_node, hash)\n+                 })\n+                 .collect();\n \n         hashes.sort();\n         let mut state = IchHasher::new();\n@@ -298,9 +306,12 @@ pub fn encode_metadata_hashes(tcx: TyCtxt,\n \n         if tcx.sess.opts.debugging_opts.incremental_dump_hash {\n             println!(\"metadata hash for {:?} is {}\", def_id, hash);\n-            for dep_node in sources {\n-                println!(\"metadata hash for {:?} depends on {:?} with hash {}\",\n-                         def_id, dep_node, preds.hashes[dep_node]);\n+            for pred_index in preds.reduced_graph.depth_traverse(index, INCOMING) {\n+                let dep_node = preds.reduced_graph.node_data(pred_index);\n+                if HashContext::is_hashable(&dep_node) {\n+                    println!(\"metadata hash for {:?} depends on {:?} with hash {}\",\n+                             def_id, dep_node, preds.hashes[dep_node]);\n+                }\n             }\n         }\n "}]}