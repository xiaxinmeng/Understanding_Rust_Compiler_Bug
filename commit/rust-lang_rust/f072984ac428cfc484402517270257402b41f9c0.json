{"sha": "f072984ac428cfc484402517270257402b41f9c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwNzI5ODRhYzQyOGNmYzQ4NDQwMjUxNzI3MDI1NzQwMmI0MWY5YzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-03T11:21:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-03T11:21:51Z"}, "message": "auto merge of #13899 : bjz/rust/simd, r=pcwalton\n\ncc. @pcwalton", "tree": {"sha": "a5243689b5b862a0526861ddbc9b04da7a3b0530", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5243689b5b862a0526861ddbc9b04da7a3b0530"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f072984ac428cfc484402517270257402b41f9c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f072984ac428cfc484402517270257402b41f9c0", "html_url": "https://github.com/rust-lang/rust/commit/f072984ac428cfc484402517270257402b41f9c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f072984ac428cfc484402517270257402b41f9c0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1ca0b13718f87f3f5498843f4e13d1b0b855c7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1ca0b13718f87f3f5498843f4e13d1b0b855c7e", "html_url": "https://github.com/rust-lang/rust/commit/d1ca0b13718f87f3f5498843f4e13d1b0b855c7e"}, {"sha": "d0da4cfee7d95d37bdf41a53081996c31ec26d2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0da4cfee7d95d37bdf41a53081996c31ec26d2f", "html_url": "https://github.com/rust-lang/rust/commit/d0da4cfee7d95d37bdf41a53081996c31ec26d2f"}], "stats": {"total": 191, "additions": 159, "deletions": 32}, "files": [{"sha": "8e15083972c72819cf4f8b8b6c8af04733f887e3", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f072984ac428cfc484402517270257402b41f9c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f072984ac428cfc484402517270257402b41f9c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f072984ac428cfc484402517270257402b41f9c0", "patch": "@@ -619,6 +619,44 @@ pub fn compare_scalar_values<'a>(\n     }\n }\n \n+pub fn compare_simd_types(\n+                    cx: &Block,\n+                    lhs: ValueRef,\n+                    rhs: ValueRef,\n+                    t: ty::t,\n+                    size: uint,\n+                    op: ast::BinOp)\n+                    -> ValueRef {\n+    match ty::get(t).sty {\n+        ty::ty_float(_) => {\n+            // The comparison operators for floating point vectors are challenging.\n+            // LLVM outputs a `< size x i1 >`, but if we perform a sign extension\n+            // then bitcast to a floating point vector, the result will be `-NaN`\n+            // for each truth value. Because of this they are unsupported.\n+            cx.sess().bug(\"compare_simd_types: comparison operators \\\n+                           not supported for floating point SIMD types\")\n+        },\n+        ty::ty_uint(_) | ty::ty_int(_) => {\n+            let cmp = match op {\n+                ast::BiEq => lib::llvm::IntEQ,\n+                ast::BiNe => lib::llvm::IntNE,\n+                ast::BiLt => lib::llvm::IntSLT,\n+                ast::BiLe => lib::llvm::IntSLE,\n+                ast::BiGt => lib::llvm::IntSGT,\n+                ast::BiGe => lib::llvm::IntSGE,\n+                _ => cx.sess().bug(\"compare_simd_types: must be a comparison operator\"),\n+            };\n+            let return_ty = Type::vector(&type_of(cx.ccx(), t), size as u64);\n+            // LLVM outputs an `< size x i1 >`, so we need to perform a sign extension\n+            // to get the correctly sized type. This will compile to a single instruction\n+            // once the IR is converted to assembly if the SIMD instruction is supported\n+            // by the target architecture.\n+            SExt(cx, ICmp(cx, cmp, lhs, rhs), return_ty)\n+        },\n+        _ => cx.sess().bug(\"compare_simd_types: invalid SIMD type\"),\n+    }\n+}\n+\n pub type val_and_ty_fn<'r,'b> =\n     |&'b Block<'b>, ValueRef, ty::t|: 'r -> &'b Block<'b>;\n "}, {"sha": "2e8c60c5dc5f5ef7dd10a0cf8692c94845d498cb", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f072984ac428cfc484402517270257402b41f9c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f072984ac428cfc484402517270257402b41f9c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=f072984ac428cfc484402517270257402b41f9c0", "patch": "@@ -1259,16 +1259,15 @@ fn trans_eager_binop<'a>(\n                      -> DatumBlock<'a, Expr> {\n     let _icx = push_ctxt(\"trans_eager_binop\");\n \n-    let mut intype = {\n+    let tcx = bcx.tcx();\n+    let is_simd = ty::type_is_simd(tcx, lhs_t);\n+    let intype = {\n         if ty::type_is_bot(lhs_t) { rhs_t }\n+        else if is_simd { ty::simd_type(tcx, lhs_t) }\n         else { lhs_t }\n     };\n-    let tcx = bcx.tcx();\n-    if ty::type_is_simd(tcx, intype) {\n-        intype = ty::simd_type(tcx, intype);\n-    }\n     let is_float = ty::type_is_fp(intype);\n-    let signed = ty::type_is_signed(intype);\n+    let is_signed = ty::type_is_signed(intype);\n \n     let rhs = base::cast_shift_expr_rhs(bcx, op, lhs, rhs);\n \n@@ -1293,7 +1292,7 @@ fn trans_eager_binop<'a>(\n             // Only zero-check integers; fp /0 is NaN\n             bcx = base::fail_if_zero(bcx, binop_expr.span,\n                                      op, rhs, rhs_t);\n-            if signed {\n+            if is_signed {\n                 SDiv(bcx, lhs, rhs)\n             } else {\n                 UDiv(bcx, lhs, rhs)\n@@ -1307,7 +1306,7 @@ fn trans_eager_binop<'a>(\n             // Only zero-check integers; fp %0 is NaN\n             bcx = base::fail_if_zero(bcx, binop_expr.span,\n                                      op, rhs, rhs_t);\n-            if signed {\n+            if is_signed {\n                 SRem(bcx, lhs, rhs)\n             } else {\n                 URem(bcx, lhs, rhs)\n@@ -1319,21 +1318,21 @@ fn trans_eager_binop<'a>(\n       ast::BiBitXor => Xor(bcx, lhs, rhs),\n       ast::BiShl => Shl(bcx, lhs, rhs),\n       ast::BiShr => {\n-        if signed {\n+        if is_signed {\n             AShr(bcx, lhs, rhs)\n         } else { LShr(bcx, lhs, rhs) }\n       }\n       ast::BiEq | ast::BiNe | ast::BiLt | ast::BiGe | ast::BiLe | ast::BiGt => {\n         if ty::type_is_bot(rhs_t) {\n             C_bool(bcx.ccx(), false)\n-        } else {\n-            if !ty::type_is_scalar(rhs_t) {\n-                bcx.tcx().sess.span_bug(binop_expr.span,\n-                                        \"non-scalar comparison\");\n-            }\n+        } else if ty::type_is_scalar(rhs_t) {\n             let cmpr = base::compare_scalar_types(bcx, lhs, rhs, rhs_t, op);\n             bcx = cmpr.bcx;\n             ZExt(bcx, cmpr.val, Type::i8(bcx.ccx()))\n+        } else if is_simd {\n+            base::compare_simd_types(bcx, lhs, rhs, intype, ty::simd_size(tcx, lhs_t), op)\n+        } else {\n+            bcx.tcx().sess.span_bug(binop_expr.span, \"comparison operator unsupported for type\")\n         }\n       }\n       _ => {"}, {"sha": "efe42a93665db66db3edbf5b1809f3c8ad2e0a14", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f072984ac428cfc484402517270257402b41f9c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f072984ac428cfc484402517270257402b41f9c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=f072984ac428cfc484402517270257402b41f9c0", "patch": "@@ -2102,8 +2102,27 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n             let result_t = match op {\n                 ast::BiEq | ast::BiNe | ast::BiLt | ast::BiLe | ast::BiGe |\n-                ast::BiGt => ty::mk_bool(),\n-                _ => lhs_t\n+                ast::BiGt => {\n+                    if ty::type_is_simd(tcx, lhs_t) {\n+                        if ty::type_is_fp(ty::simd_type(tcx, lhs_t)) {\n+                            fcx.type_error_message(expr.span,\n+                                |actual| {\n+                                    format!(\"binary comparison operation `{}` not supported \\\n+                                            for floating point SIMD vector `{}`\",\n+                                            ast_util::binop_to_str(op), actual)\n+                                },\n+                                lhs_t,\n+                                None\n+                            );\n+                            ty::mk_err()\n+                        } else {\n+                            lhs_t\n+                        }\n+                    } else {\n+                        ty::mk_bool()\n+                    }\n+                },\n+                _ => lhs_t,\n             };\n \n             fcx.write_ty(expr.id, result_t);"}, {"sha": "281e879592dde592a5b5ce0ba4e1c87cc4a6dd86", "filename": "src/test/compile-fail/simd-binop.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f072984ac428cfc484402517270257402b41f9c0/src%2Ftest%2Fcompile-fail%2Fsimd-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f072984ac428cfc484402517270257402b41f9c0/src%2Ftest%2Fcompile-fail%2Fsimd-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-binop.rs?ref=f072984ac428cfc484402517270257402b41f9c0", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+#![allow(experimental)]\n+\n+use std::unstable::simd::f32x4;\n+\n+fn main() {\n+\n+    let _ = f32x4(0.0, 0.0, 0.0, 0.0) == f32x4(0.0, 0.0, 0.0, 0.0);\n+    //~^ ERROR binary comparison operation `==` not supported for floating point SIMD vector `std::unstable::simd::f32x4`\n+\n+    let _ = f32x4(0.0, 0.0, 0.0, 0.0) != f32x4(0.0, 0.0, 0.0, 0.0);\n+    //~^ ERROR binary comparison operation `!=` not supported for floating point SIMD vector `std::unstable::simd::f32x4`\n+\n+    let _ = f32x4(0.0, 0.0, 0.0, 0.0) < f32x4(0.0, 0.0, 0.0, 0.0);\n+    //~^ ERROR binary comparison operation `<` not supported for floating point SIMD vector `std::unstable::simd::f32x4`\n+\n+    let _ = f32x4(0.0, 0.0, 0.0, 0.0) <= f32x4(0.0, 0.0, 0.0, 0.0);\n+    //~^ ERROR binary comparison operation `<=` not supported for floating point SIMD vector `std::unstable::simd::f32x4`\n+\n+    let _ = f32x4(0.0, 0.0, 0.0, 0.0) >= f32x4(0.0, 0.0, 0.0, 0.0);\n+    //~^ ERROR binary comparison operation `>=` not supported for floating point SIMD vector `std::unstable::simd::f32x4`\n+\n+    let _ = f32x4(0.0, 0.0, 0.0, 0.0) > f32x4(0.0, 0.0, 0.0, 0.0);\n+    //~^ ERROR binary comparison operation `>` not supported for floating point SIMD vector `std::unstable::simd::f32x4`\n+\n+}"}, {"sha": "efcd99a04cedd86534ddb475e9dee433b831cc9a", "filename": "src/test/run-pass/simd-binop.rs", "status": "modified", "additions": 50, "deletions": 16, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f072984ac428cfc484402517270257402b41f9c0/src%2Ftest%2Frun-pass%2Fsimd-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f072984ac428cfc484402517270257402b41f9c0/src%2Ftest%2Frun-pass%2Fsimd-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-binop.rs?ref=f072984ac428cfc484402517270257402b41f9c0", "patch": "@@ -12,27 +12,61 @@\n \n use std::unstable::simd::{i32x4, f32x4, u32x4};\n \n-fn test_int(e: i32) -> i32 {\n-    let v = i32x4(e, 0i32, 0i32, 0i32);\n-    let i32x4(e2, _, _, _) = v * v + v - v;\n-    e2\n+fn eq_u32x4(u32x4(x0, x1, x2, x3): u32x4, u32x4(y0, y1, y2, y3): u32x4) -> bool {\n+    (x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)\n }\n \n-fn test_float(e: f32) -> f32 {\n-    let v = f32x4(e, 0f32, 0f32, 0f32);\n-    let f32x4(e2, _, _, _) = v * v + v - v;\n-    e2\n+fn eq_f32x4(f32x4(x0, x1, x2, x3): f32x4, f32x4(y0, y1, y2, y3): f32x4) -> bool {\n+    (x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)\n }\n \n-pub fn test_shift(e: u32) -> u32 {\n-    let v = u32x4(e, 0u32, 0u32, 0u32);\n-    let one = u32x4(1u32, 0u32, 0u32, 0u32);\n-    let u32x4(e2, _, _, _) = v << one >> one;\n-    e2\n+fn eq_i32x4(i32x4(x0, x1, x2, x3): i32x4, i32x4(y0, y1, y2, y3): i32x4) -> bool {\n+    (x0 == y0) && (x1 == y1) && (x2 == y2) && (x3 == y3)\n }\n \n pub fn main() {\n-    assert_eq!(test_int(3i32), 9i32);\n-    assert_eq!(test_float(3f32), 9f32);\n-    assert_eq!(test_shift(3u32), 3u32);\n+    // arithmetic operators\n+\n+    assert!(eq_u32x4(u32x4(1, 2, 3, 4) + u32x4(4, 3, 2, 1), u32x4(5, 5, 5, 5)));\n+    assert!(eq_u32x4(u32x4(4, 5, 6, 7) - u32x4(4, 3, 2, 1), u32x4(0, 2, 4, 6)));\n+    assert!(eq_u32x4(u32x4(1, 2, 3, 4) * u32x4(4, 3, 2, 1), u32x4(4, 6, 6, 4)));\n+    assert!(eq_u32x4(u32x4(1, 2, 3, 4) & u32x4(4, 3, 2, 1), u32x4(0, 2, 2, 0)));\n+    assert!(eq_u32x4(u32x4(1, 2, 3, 4) | u32x4(4, 3, 2, 1), u32x4(5, 3, 3, 5)));\n+    assert!(eq_u32x4(u32x4(1, 2, 3, 4) ^ u32x4(4, 3, 2, 1), u32x4(5, 1, 1, 5)));\n+    assert!(eq_u32x4(u32x4(1, 2, 3, 4) << u32x4(4, 3, 2, 1), u32x4(16, 16, 12, 8)));\n+    assert!(eq_u32x4(u32x4(1, 2, 3, 4) >> u32x4(4, 3, 2, 1), u32x4(0, 0, 0, 2)));\n+\n+    assert!(eq_i32x4(i32x4(1, 2, 3, 4) + i32x4(4, 3, 2, 1), i32x4(5, 5, 5, 5)));\n+    assert!(eq_i32x4(i32x4(1, 2, 3, 4) - i32x4(4, 3, 2, 1), i32x4(-3, -1, 1, 3)));\n+    assert!(eq_i32x4(i32x4(1, 2, 3, 4) * i32x4(4, 3, 2, 1), i32x4(4, 6, 6, 4)));\n+    assert!(eq_i32x4(i32x4(1, 2, 3, 4) & i32x4(4, 3, 2, 1), i32x4(0, 2, 2, 0)));\n+    assert!(eq_i32x4(i32x4(1, 2, 3, 4) | i32x4(4, 3, 2, 1), i32x4(5, 3, 3, 5)));\n+    assert!(eq_i32x4(i32x4(1, 2, 3, 4) ^ i32x4(4, 3, 2, 1), i32x4(5, 1, 1, 5)));\n+    assert!(eq_i32x4(i32x4(1, 2, 3, 4) << i32x4(4, 3, 2, 1), i32x4(16, 16, 12, 8)));\n+    assert!(eq_i32x4(i32x4(1, 2, 3, 4) >> i32x4(4, 3, 2, 1), i32x4(0, 0, 0, 2)));\n+\n+    assert!(eq_f32x4(f32x4(1.0, 2.0, 3.0, 4.0) + f32x4(4.0, 3.0, 2.0, 1.0),\n+            f32x4(5.0, 5.0, 5.0, 5.0)));\n+    assert!(eq_f32x4(f32x4(1.0, 2.0, 3.0, 4.0) - f32x4(4.0, 3.0, 2.0, 1.0),\n+            f32x4(-3.0, -1.0, 1.0, 3.0)));\n+    assert!(eq_f32x4(f32x4(1.0, 2.0, 3.0, 4.0) * f32x4(4.0, 3.0, 2.0, 1.0),\n+            f32x4(4.0, 6.0, 6.0, 4.0)));\n+    assert!(eq_f32x4(f32x4(1.0, 2.0, 3.0, 4.0) / f32x4(4.0, 4.0, 2.0, 1.0),\n+            f32x4(0.25, 0.5, 1.5, 4.0)));\n+\n+    // comparison operators\n+\n+    assert!(eq_u32x4(u32x4(1, 2, 3, 4) == u32x4(3, 2, 1, 0), u32x4(0, !0, 0, 0)));\n+    assert!(eq_u32x4(u32x4(1, 2, 3, 4) != u32x4(3, 2, 1, 0), u32x4(!0, 0, !0, !0)));\n+    assert!(eq_u32x4(u32x4(1, 2, 3, 4) < u32x4(3, 2, 1, 0), u32x4(!0, 0, 0, 0)));\n+    assert!(eq_u32x4(u32x4(1, 2, 3, 4) <= u32x4(3, 2, 1, 0), u32x4(!0, !0, 0, 0)));\n+    assert!(eq_u32x4(u32x4(1, 2, 3, 4) >= u32x4(3, 2, 1, 0), u32x4(0, !0, !0, !0)));\n+    assert!(eq_u32x4(u32x4(1, 2, 3, 4) > u32x4(3, 2, 1, 0), u32x4(0, 0, !0, !0)));\n+\n+    assert!(eq_i32x4(i32x4(1, 2, 3, 4) == i32x4(3, 2, 1, 0), i32x4(0, !0, 0, 0)));\n+    assert!(eq_i32x4(i32x4(1, 2, 3, 4) != i32x4(3, 2, 1, 0), i32x4(!0, 0, !0, !0)));\n+    assert!(eq_i32x4(i32x4(1, 2, 3, 4) < i32x4(3, 2, 1, 0), i32x4(!0, 0, 0, 0)));\n+    assert!(eq_i32x4(i32x4(1, 2, 3, 4) <= i32x4(3, 2, 1, 0), i32x4(!0, !0, 0, 0)));\n+    assert!(eq_i32x4(i32x4(1, 2, 3, 4) >= i32x4(3, 2, 1, 0), i32x4(0, !0, !0, !0)));\n+    assert!(eq_i32x4(i32x4(1, 2, 3, 4) > i32x4(3, 2, 1, 0), i32x4(0, 0, !0, !0)));\n }"}]}