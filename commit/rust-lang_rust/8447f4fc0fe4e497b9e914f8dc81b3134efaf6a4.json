{"sha": "8447f4fc0fe4e497b9e914f8dc81b3134efaf6a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0NDdmNGZjMGZlNGU0OTdiOWU5MTRmOGRjODFiMzEzNGVmYWY2YTQ=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-01-13T15:55:38Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-01-19T00:41:21Z"}, "message": "Add CGU size heuristic for partitioning\n\nThis addresses the concern of #47316 by estimating CGU size based on\nthe size of its MIR. Looking at the size estimate differences for a\nsmall selection of crates, this heuristic produces different orderings,\nwhich should more accurately reflect optimisation time.\n\nFixes #47316.", "tree": {"sha": "ef8d857bc7ac3a5ab7b11803ea8c88120ba4cc9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef8d857bc7ac3a5ab7b11803ea8c88120ba4cc9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8447f4fc0fe4e497b9e914f8dc81b3134efaf6a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8447f4fc0fe4e497b9e914f8dc81b3134efaf6a4", "html_url": "https://github.com/rust-lang/rust/commit/8447f4fc0fe4e497b9e914f8dc81b3134efaf6a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8447f4fc0fe4e497b9e914f8dc81b3134efaf6a4/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bd4af88bea2e6ecdd3455ed89b3ef1fc3500aa4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bd4af88bea2e6ecdd3455ed89b3ef1fc3500aa4", "html_url": "https://github.com/rust-lang/rust/commit/3bd4af88bea2e6ecdd3455ed89b3ef1fc3500aa4"}], "stats": {"total": 46, "additions": 42, "deletions": 4}, "files": [{"sha": "d8ec074b8a46457633a74ffafd27862243244396", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8447f4fc0fe4e497b9e914f8dc81b3134efaf6a4/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8447f4fc0fe4e497b9e914f8dc81b3134efaf6a4/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=8447f4fc0fe4e497b9e914f8dc81b3134efaf6a4", "patch": "@@ -110,11 +110,12 @@ use rustc::mir::mono::{Linkage, Visibility};\n use rustc::ty::{self, TyCtxt, InstanceDef};\n use rustc::ty::item_path::characteristic_def_id_of_type;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n-use std::collections::hash_map::Entry;\n+use std::collections::hash_map::{HashMap, Entry};\n use syntax::ast::NodeId;\n use syntax::symbol::{Symbol, InternedString};\n use rustc::mir::mono::MonoItem;\n use monomorphize::item::{MonoItemExt, InstantiationMode};\n+use core::usize;\n \n pub use rustc::mir::mono::CodegenUnit;\n \n@@ -229,7 +230,7 @@ pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // If the partitioning should produce a fixed count of codegen units, merge\n     // until that count is reached.\n     if let PartitioningStrategy::FixedUnitCount(count) = strategy {\n-        merge_codegen_units(&mut initial_partitioning, count, &tcx.crate_name.as_str());\n+        merge_codegen_units(tcx, &mut initial_partitioning, count, &tcx.crate_name.as_str());\n \n         debug_dump(tcx, \"POST MERGING:\", initial_partitioning.codegen_units.iter());\n     }\n@@ -404,7 +405,8 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn merge_codegen_units<'tcx>(initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n+fn merge_codegen_units<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n                              target_cgu_count: usize,\n                              crate_name: &str) {\n     assert!(target_cgu_count >= 1);\n@@ -421,12 +423,48 @@ fn merge_codegen_units<'tcx>(initial_partitioning: &mut PreInliningPartitioning<\n     // the stable sort below will keep everything nice and deterministic.\n     codegen_units.sort_by_key(|cgu| cgu.name().clone());\n \n+    // Estimate the size of a codegen unit as (approximately) the number of MIR\n+    // statements it corresponds to.\n+    fn codegen_unit_size_estimate<'a, 'tcx>(cgu: &CodegenUnit<'tcx>,\n+                                            mono_item_sizes: &HashMap<MonoItem, usize>)\n+                                            -> usize {\n+        cgu.items().keys().map(|mi| mono_item_sizes.get(mi).unwrap()).sum()\n+    }\n+\n+    fn mono_item_size_estimate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                         item: &MonoItem<'tcx>)\n+                                         -> usize {\n+        match item {\n+            MonoItem::Fn(instance) => {\n+                // Estimate the size of a function based on how many statements\n+                // it contains.\n+                let mir = tcx.instance_mir(instance.def);\n+                mir.basic_blocks().iter().map(|bb| bb.statements.len()).sum()\n+            },\n+            // Conservatively estimate the size of a static declaration\n+            // or assembly to be 1.\n+            MonoItem::Static(_) | MonoItem::GlobalAsm(_) => 1,\n+        }\n+    }\n+\n+    // Since `sort_by_key` currently recomputes the keys for each comparison,\n+    // we can save unnecessary recomputations by storing size estimates for\n+    // each `MonoItem`. Storing estimates for `CodegenUnit` might be preferable,\n+    // but its structure makes it awkward to use as a key and additionally their\n+    // sizes change as the merging occurs, requiring the map to be updated.\n+    let mut sizes: HashMap<MonoItem, usize> = HashMap::new();\n+    for mis in codegen_units.iter().map(|cgu| cgu.items().keys()) {\n+        mis.for_each(|mi| {\n+            sizes.entry(*mi).or_insert_with(|| mono_item_size_estimate(tcx, mi));\n+        });\n+    }\n+\n     // Merge the two smallest codegen units until the target size is reached.\n     // Note that \"size\" is estimated here rather inaccurately as the number of\n     // translation items in a given unit. This could be improved on.\n     while codegen_units.len() > target_cgu_count {\n         // Sort small cgus to the back\n-        codegen_units.sort_by_key(|cgu| -(cgu.items().len() as i64));\n+        codegen_units.sort_by_key(|cgu| usize::MAX - codegen_unit_size_estimate(cgu, &sizes));\n         let mut smallest = codegen_units.pop().unwrap();\n         let second_smallest = codegen_units.last_mut().unwrap();\n "}]}