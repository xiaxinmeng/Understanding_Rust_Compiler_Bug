{"sha": "c7a2e32c102057242950697da6b83b2190b00dfb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3YTJlMzJjMTAyMDU3MjQyOTUwNjk3ZGE2YjgzYjIxOTBiMDBkZmI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-24T13:43:20Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-06-01T17:31:11Z"}, "message": "ergonomic improvements to the methods in infcx", "tree": {"sha": "afdce37fb271d53cd5b90aaec7bd5ede2724ca69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afdce37fb271d53cd5b90aaec7bd5ede2724ca69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7a2e32c102057242950697da6b83b2190b00dfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7a2e32c102057242950697da6b83b2190b00dfb", "html_url": "https://github.com/rust-lang/rust/commit/c7a2e32c102057242950697da6b83b2190b00dfb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7a2e32c102057242950697da6b83b2190b00dfb/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1e895d92c83bd626dece3410b015253e55fdb74", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1e895d92c83bd626dece3410b015253e55fdb74", "html_url": "https://github.com/rust-lang/rust/commit/c1e895d92c83bd626dece3410b015253e55fdb74"}], "stats": {"total": 731, "additions": 434, "deletions": 297}, "files": [{"sha": "756e0b5f9fb6a00cf47c84f26830e8a72ccf9f83", "filename": "src/librustc/infer/at.rs", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fat.rs?ref=c7a2e32c102057242950697da6b83b2190b00dfb", "patch": "@@ -0,0 +1,310 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A nice interface for working with the infcx.  The basic idea is to\n+//! do `infcx.at(cause, param_env)`, which sets the \"cause\" of the\n+//! operation as well as the surrounding parameter environment.  Then\n+//! you can do something like `.sub(a, b)` or `.eq(a, b)` to create a\n+//! subtype or equality relationship respectively. The first argument\n+//! is always the \"expected\" output from the POV of diagnostics.\n+//!\n+//! Examples:\n+//!\n+//!     infcx.at(cause, param_env).sub(a, b)\n+//!     // requires that `a <: b`, with `a` considered the \"expected\" type\n+//!\n+//!     infcx.at(cause, param_env).sup(a, b)\n+//!     // requires that `b <: a`, with `a` considered the \"expected\" type\n+//!\n+//!     infcx.at(cause, param_env).eq(a, b)\n+//!     // requires that `a == b`, with `a` considered the \"expected\" type\n+//!\n+//! For finer-grained control, you can also do use `trace`:\n+//!\n+//!     infcx.at(...).trace(a, b).sub(&c, &d)\n+//!\n+//! This will set `a` and `b` as the \"root\" values for\n+//! error-reporting, but actually operate on `c` and `d`. This is\n+//! sometimes useful when the types of `c` and `d` are not traceable\n+//! things. (That system should probably be refactored.)\n+\n+use super::*;\n+\n+use ty::relate::{Relate, TypeRelation};\n+\n+pub struct At<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    cause: &'a ObligationCause<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+}\n+\n+pub struct Trace<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    at: At<'a, 'gcx, 'tcx>,\n+    a_is_expected: bool,\n+    trace: TypeTrace<'tcx>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+    pub fn at(&'a self,\n+              cause: &'a ObligationCause<'tcx>,\n+              param_env: ty::ParamEnv<'tcx>)\n+              -> At<'a, 'gcx, 'tcx>\n+    {\n+        At { infcx: self, cause, param_env }\n+    }\n+}\n+\n+pub trait ToTrace<'tcx>: Relate<'tcx> + Copy {\n+    fn to_trace(cause: &ObligationCause<'tcx>,\n+                a_is_expected: bool,\n+                a: Self,\n+                b: Self)\n+                -> TypeTrace<'tcx>;\n+}\n+\n+impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n+    /// Hacky routine for equating two impl headers in coherence.\n+    pub fn eq_impl_headers(self,\n+                           expected: &ty::ImplHeader<'tcx>,\n+                           actual: &ty::ImplHeader<'tcx>)\n+                           -> InferResult<'tcx, ()>\n+    {\n+        debug!(\"eq_impl_header({:?} = {:?})\", expected, actual);\n+        match (expected.trait_ref, actual.trait_ref) {\n+            (Some(a_ref), Some(b_ref)) =>\n+                self.eq(a_ref, b_ref),\n+            (None, None) =>\n+                self.eq(expected.self_ty, actual.self_ty),\n+            _ =>\n+                bug!(\"mk_eq_impl_headers given mismatched impl kinds\"),\n+        }\n+    }\n+\n+    /// Make `a <: b` where `a` may or may not be expected\n+    pub fn sub_exp<T>(self,\n+                      a_is_expected: bool,\n+                      a: T,\n+                      b: T)\n+                      -> InferResult<'tcx, ()>\n+        where T: ToTrace<'tcx>\n+    {\n+        self.trace_exp(a_is_expected, a, b).sub(&a, &b)\n+    }\n+\n+    /// Make `actual <: expected`. For example, if type-checking a\n+    /// call like `foo(x)`, where `foo: fn(i32)`, you might have\n+    /// `sup(i32, x)`, since the \"expected\" type is the type that\n+    /// appears in the signature.\n+    pub fn sup<T>(self,\n+                  expected: T,\n+                  actual: T)\n+                  -> InferResult<'tcx, ()>\n+        where T: ToTrace<'tcx>\n+    {\n+        self.sub_exp(false, actual, expected)\n+    }\n+\n+    /// Make `expected <: actual`\n+    pub fn sub<T>(self,\n+                  expected: T,\n+                  actual: T)\n+                  -> InferResult<'tcx, ()>\n+        where T: ToTrace<'tcx>\n+    {\n+        self.sub_exp(true, expected, actual)\n+    }\n+\n+    /// Make `expected <: actual`\n+    pub fn eq_exp<T>(self,\n+                     a_is_expected: bool,\n+                     a: T,\n+                     b: T)\n+                     -> InferResult<'tcx, ()>\n+        where T: ToTrace<'tcx>\n+    {\n+        self.trace_exp(a_is_expected, a, b).eq(&a, &b)\n+    }\n+\n+    /// Make `expected <: actual`\n+    pub fn eq<T>(self,\n+                 expected: T,\n+                 actual: T)\n+                 -> InferResult<'tcx, ()>\n+        where T: ToTrace<'tcx>\n+    {\n+        self.trace(expected, actual).eq(&expected, &actual)\n+    }\n+\n+    /// Compute the least-upper-bound, or mutual supertype, of two\n+    /// values. The order of the arguments doesn't matter, but since\n+    /// this can result in an error (e.g., if asked to compute LUB of\n+    /// u32 and i32), it is meaningful to call one of them the\n+    /// \"expected type\".\n+    pub fn lub<T>(self,\n+                  expected: T,\n+                  actual: T)\n+                  -> InferResult<'tcx, T>\n+        where T: ToTrace<'tcx>\n+    {\n+        self.trace(expected, actual).lub(&expected, &actual)\n+    }\n+\n+    /// Compute the greatest-lower-bound, or mutual subtype, of two\n+    /// values. As with `lub` order doesn't matter, except for error\n+    /// cases.\n+    pub fn glb<T>(self,\n+                  expected: T,\n+                  actual: T)\n+                  -> InferResult<'tcx, T>\n+        where T: ToTrace<'tcx>\n+    {\n+        self.trace(expected, actual).glb(&expected, &actual)\n+    }\n+\n+    /// Sets the \"trace\" values that will be used for\n+    /// error-repporting, but doesn't actually perform any operation\n+    /// yet (this is useful when you want to set the trace using\n+    /// distinct values from those you wish to operate upon).\n+    pub fn trace<T>(self,\n+                    expected: T,\n+                    actual: T)\n+                    -> Trace<'a, 'gcx, 'tcx>\n+        where T: ToTrace<'tcx>\n+    {\n+        self.trace_exp(true, expected, actual)\n+    }\n+\n+    /// Like `trace`, but the expected value is determined by the\n+    /// boolean argument (if true, then the first argument `a` is the\n+    /// \"expected\" value).\n+    pub fn trace_exp<T>(self,\n+                        a_is_expected: bool,\n+                        a: T,\n+                        b: T)\n+                        -> Trace<'a, 'gcx, 'tcx>\n+        where T: ToTrace<'tcx>\n+    {\n+        let trace = ToTrace::to_trace(self.cause, a_is_expected, a, b);\n+        Trace { at: self, trace: trace, a_is_expected }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> Trace<'a, 'gcx, 'tcx> {\n+    /// Make `a <: b` where `a` may or may not be expected (if\n+    /// `a_is_expected` is true, then `a` is expected).\n+    /// Make `expected <: actual`\n+    pub fn sub<T>(self,\n+                  a: &T,\n+                  b: &T)\n+                  -> InferResult<'tcx, ()>\n+        where T: Relate<'tcx>\n+    {\n+        debug!(\"sub({:?} <: {:?})\", a, b);\n+        let Trace { at, trace, a_is_expected } = self;\n+        at.infcx.commit_if_ok(|_| {\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env);\n+            fields.sub(a_is_expected)\n+                  .relate(a, b)\n+                  .map(move |_| InferOk { value: (), obligations: fields.obligations })\n+        })\n+    }\n+\n+    /// Make `a == b`; the expectation is set by the call to\n+    /// `trace()`.\n+    pub fn eq<T>(self,\n+                 a: &T,\n+                 b: &T)\n+                 -> InferResult<'tcx, ()>\n+        where T: Relate<'tcx>\n+    {\n+        debug!(\"eq({:?} == {:?})\", a, b);\n+        let Trace { at, trace, a_is_expected } = self;\n+        at.infcx.commit_if_ok(|_| {\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env);\n+            fields.equate(a_is_expected)\n+                  .relate(a, b)\n+                  .map(move |_| InferOk { value: (), obligations: fields.obligations })\n+        })\n+    }\n+\n+    pub fn lub<T>(self,\n+                  a: &T,\n+                  b: &T)\n+                  -> InferResult<'tcx, T>\n+        where T: Relate<'tcx>\n+    {\n+        debug!(\"lub({:?} \\\\/ {:?})\", a, b);\n+        let Trace { at, trace, a_is_expected } = self;\n+        at.infcx.commit_if_ok(|_| {\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env);\n+            fields.lub(a_is_expected)\n+                  .relate(a, b)\n+                  .map(move |t| InferOk { value: t, obligations: fields.obligations })\n+        })\n+    }\n+\n+    pub fn glb<T>(self,\n+                  a: &T,\n+                  b: &T)\n+                  -> InferResult<'tcx, T>\n+        where T: Relate<'tcx>\n+    {\n+        debug!(\"glb({:?} /\\\\ {:?})\", a, b);\n+        let Trace { at, trace, a_is_expected } = self;\n+        at.infcx.commit_if_ok(|_| {\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env);\n+            fields.glb(a_is_expected)\n+                  .relate(a, b)\n+                  .map(move |t| InferOk { value: t, obligations: fields.obligations })\n+        })\n+    }\n+}\n+\n+impl<'tcx> ToTrace<'tcx> for Ty<'tcx> {\n+    fn to_trace(cause: &ObligationCause<'tcx>,\n+                a_is_expected: bool,\n+                a: Self,\n+                b: Self)\n+                -> TypeTrace<'tcx>\n+    {\n+        TypeTrace {\n+            cause: cause.clone(),\n+            values: Types(ExpectedFound::new(a_is_expected, a, b))\n+        }\n+    }\n+}\n+\n+impl<'tcx> ToTrace<'tcx> for ty::TraitRef<'tcx> {\n+    fn to_trace(cause: &ObligationCause<'tcx>,\n+                a_is_expected: bool,\n+                a: Self,\n+                b: Self)\n+                -> TypeTrace<'tcx>\n+    {\n+        TypeTrace {\n+            cause: cause.clone(),\n+            values: TraitRefs(ExpectedFound::new(a_is_expected, a, b))\n+        }\n+    }\n+}\n+\n+impl<'tcx> ToTrace<'tcx> for ty::PolyTraitRef<'tcx> {\n+    fn to_trace(cause: &ObligationCause<'tcx>,\n+                a_is_expected: bool,\n+                a: Self,\n+                b: Self)\n+                -> TypeTrace<'tcx>\n+    {\n+        TypeTrace {\n+            cause: cause.clone(),\n+            values: PolyTraitRefs(ExpectedFound::new(a_is_expected, a, b))\n+        }\n+    }\n+}"}, {"sha": "f5869b8a20fab7881529092b132d00fbf5a5d26a", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 24, "deletions": 167, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=c7a2e32c102057242950697da6b83b2190b00dfb", "patch": "@@ -31,7 +31,7 @@ use ty::{TyVid, IntVid, FloatVid};\n use ty::{self, Ty, TyCtxt};\n use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n-use ty::relate::{Relate, RelateResult, TypeRelation};\n+use ty::relate::RelateResult;\n use traits::{self, ObligationCause, PredicateObligations, Reveal};\n use rustc_data_structures::unify::{self, UnificationTable};\n use std::cell::{Cell, RefCell, Ref, RefMut};\n@@ -49,6 +49,7 @@ use self::region_inference::{RegionVarBindings, RegionSnapshot};\n use self::type_variable::TypeVariableOrigin;\n use self::unify_key::ToType;\n \n+pub mod at;\n mod combine;\n mod equate;\n pub mod error_reporting;\n@@ -802,62 +803,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn equate<T>(&'a self,\n-                     a_is_expected: bool,\n-                     trace: TypeTrace<'tcx>,\n-                     param_env: ty::ParamEnv<'tcx>,\n-                     a: &T,\n-                     b: &T)\n-        -> InferResult<'tcx, T>\n-        where T: Relate<'tcx>\n-    {\n-        let mut fields = self.combine_fields(trace, param_env);\n-        let result = fields.equate(a_is_expected).relate(a, b);\n-        result.map(move |t| InferOk { value: t, obligations: fields.obligations })\n-    }\n-\n-    pub fn sub<T>(&'a self,\n-                  a_is_expected: bool,\n-                  trace: TypeTrace<'tcx>,\n-                  param_env: ty::ParamEnv<'tcx>,\n-                  a: &T,\n-                  b: &T)\n-        -> InferResult<'tcx, T>\n-        where T: Relate<'tcx>\n-    {\n-        let mut fields = self.combine_fields(trace, param_env);\n-        let result = fields.sub(a_is_expected).relate(a, b);\n-        result.map(move |t| InferOk { value: t, obligations: fields.obligations })\n-    }\n-\n-    pub fn lub<T>(&'a self,\n-                  a_is_expected: bool,\n-                  trace: TypeTrace<'tcx>,\n-                  param_env: ty::ParamEnv<'tcx>,\n-                  a: &T,\n-                  b: &T)\n-        -> InferResult<'tcx, T>\n-        where T: Relate<'tcx>\n-    {\n-        let mut fields = self.combine_fields(trace, param_env);\n-        let result = fields.lub(a_is_expected).relate(a, b);\n-        result.map(move |t| InferOk { value: t, obligations: fields.obligations })\n-    }\n-\n-    pub fn glb<T>(&'a self,\n-                  a_is_expected: bool,\n-                  trace: TypeTrace<'tcx>,\n-                  param_env: ty::ParamEnv<'tcx>,\n-                  a: &T,\n-                  b: &T)\n-        -> InferResult<'tcx, T>\n-        where T: Relate<'tcx>\n-    {\n-        let mut fields = self.combine_fields(trace, param_env);\n-        let result = fields.glb(a_is_expected).relate(a, b);\n-        result.map(move |t| InferOk { value: t, obligations: fields.obligations })\n-    }\n-\n     // Clear the \"currently in a snapshot\" flag, invoke the closure,\n     // then restore the flag to its original value. This flag is a\n     // debugging measure designed to detect cases where we start a\n@@ -1017,102 +962,35 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.region_vars.add_given(sub, sup);\n     }\n \n-    pub fn sub_types(&self,\n-                     a_is_expected: bool,\n-                     cause: &ObligationCause<'tcx>,\n-                     param_env: ty::ParamEnv<'tcx>,\n-                     a: Ty<'tcx>,\n-                     b: Ty<'tcx>)\n-                     -> InferResult<'tcx, ()>\n-    {\n-        debug!(\"sub_types({:?} <: {:?})\", a, b);\n-        self.commit_if_ok(|_| {\n-            let trace = TypeTrace::types(cause, a_is_expected, a, b);\n-            self.sub(a_is_expected, trace, param_env, &a, &b).map(|ok| ok.unit())\n-        })\n-    }\n-\n-    pub fn can_sub_types(&self,\n-                         param_env: ty::ParamEnv<'tcx>,\n-                         a: Ty<'tcx>,\n-                         b: Ty<'tcx>)\n-                         -> UnitResult<'tcx>\n+    pub fn can_sub<T>(&self,\n+                      param_env: ty::ParamEnv<'tcx>,\n+                      a: T,\n+                      b: T)\n+                      -> UnitResult<'tcx>\n+        where T: at::ToTrace<'tcx>\n     {\n+        let origin = &ObligationCause::dummy();\n         self.probe(|_| {\n-            let origin = &ObligationCause::dummy();\n-            let trace = TypeTrace::types(origin, true, a, b);\n-            self.sub(true, trace, param_env, &a, &b).map(|InferOk { obligations: _, .. }| {\n+            self.at(origin, param_env).sub(a, b).map(|InferOk { obligations: _, .. }| {\n                 // Ignore obligations, since we are unrolling\n                 // everything anyway.\n             })\n         })\n     }\n \n-    pub fn eq_types(&self,\n-                    a_is_expected: bool,\n-                    cause: &ObligationCause<'tcx>,\n-                    param_env: ty::ParamEnv<'tcx>,\n-                    a: Ty<'tcx>,\n-                    b: Ty<'tcx>)\n-        -> InferResult<'tcx, ()>\n+    pub fn can_eq<T>(&self,\n+                      param_env: ty::ParamEnv<'tcx>,\n+                      a: T,\n+                      b: T)\n+                      -> UnitResult<'tcx>\n+        where T: at::ToTrace<'tcx>\n     {\n-        self.commit_if_ok(|_| {\n-            let trace = TypeTrace::types(cause, a_is_expected, a, b);\n-            self.equate(a_is_expected, trace, param_env, &a, &b).map(|ok| ok.unit())\n-        })\n-    }\n-\n-    pub fn eq_trait_refs(&self,\n-                         a_is_expected: bool,\n-                         cause: &ObligationCause<'tcx>,\n-                         param_env: ty::ParamEnv<'tcx>,\n-                         a: ty::TraitRef<'tcx>,\n-                         b: ty::TraitRef<'tcx>)\n-        -> InferResult<'tcx, ()>\n-    {\n-        debug!(\"eq_trait_refs({:?} = {:?})\", a, b);\n-        self.commit_if_ok(|_| {\n-            let trace = TypeTrace {\n-                cause: cause.clone(),\n-                values: TraitRefs(ExpectedFound::new(a_is_expected, a, b))\n-            };\n-            self.equate(a_is_expected, trace, param_env, &a, &b).map(|ok| ok.unit())\n-        })\n-    }\n-\n-    pub fn eq_impl_headers(&self,\n-                           a_is_expected: bool,\n-                           cause: &ObligationCause<'tcx>,\n-                           param_env: ty::ParamEnv<'tcx>,\n-                           a: &ty::ImplHeader<'tcx>,\n-                           b: &ty::ImplHeader<'tcx>)\n-                           -> InferResult<'tcx, ()>\n-    {\n-        debug!(\"eq_impl_header({:?} = {:?})\", a, b);\n-        match (a.trait_ref, b.trait_ref) {\n-            (Some(a_ref), Some(b_ref)) =>\n-                self.eq_trait_refs(a_is_expected, cause, param_env, a_ref, b_ref),\n-            (None, None) =>\n-                self.eq_types(a_is_expected, cause, param_env, a.self_ty, b.self_ty),\n-            _ => bug!(\"mk_eq_impl_headers given mismatched impl kinds\"),\n-        }\n-    }\n-\n-    pub fn sub_poly_trait_refs(&self,\n-                               a_is_expected: bool,\n-                               cause: ObligationCause<'tcx>,\n-                               param_env: ty::ParamEnv<'tcx>,\n-                               a: ty::PolyTraitRef<'tcx>,\n-                               b: ty::PolyTraitRef<'tcx>)\n-        -> InferResult<'tcx, ()>\n-    {\n-        debug!(\"sub_poly_trait_refs({:?} <: {:?})\", a, b);\n-        self.commit_if_ok(|_| {\n-            let trace = TypeTrace {\n-                cause: cause,\n-                values: PolyTraitRefs(ExpectedFound::new(a_is_expected, a, b))\n-            };\n-            self.sub(a_is_expected, trace, param_env, &a, &b).map(|ok| ok.unit())\n+        let origin = &ObligationCause::dummy();\n+        self.probe(|_| {\n+            self.at(origin, param_env).eq(a, b).map(|InferOk { obligations: _, .. }| {\n+                // Ignore obligations, since we are unrolling\n+                // everything anyway.\n+            })\n         })\n     }\n \n@@ -1134,7 +1012,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             let (ty::EquatePredicate(a, b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n             let cause_span = cause.span;\n-            let eqty_ok = self.eq_types(false, cause, param_env, a, b)?;\n+            let eqty_ok = self.at(cause, param_env).eq(b, a)?;\n             self.leak_check(false, cause_span, &skol_map, snapshot)?;\n             self.pop_skolemized(skol_map, snapshot);\n             Ok(eqty_ok.unit())\n@@ -1172,7 +1050,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n \n             let cause_span = cause.span;\n-            let ok = self.sub_types(a_is_expected, cause, param_env, a, b)?;\n+            let ok = self.at(cause, param_env).sub_exp(a_is_expected, a, b)?;\n             self.leak_check(false, cause_span, &skol_map, snapshot)?;\n             self.pop_skolemized(skol_map, snapshot);\n             Ok(ok.unit())\n@@ -1606,27 +1484,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.region_vars.verify_generic_bound(origin, kind, a, bound);\n     }\n \n-    pub fn can_equate<T>(&self, param_env: ty::ParamEnv<'tcx>, a: &T, b: &T) -> UnitResult<'tcx>\n-        where T: Relate<'tcx> + fmt::Debug\n-    {\n-        debug!(\"can_equate({:?}, {:?})\", a, b);\n-        self.probe(|_| {\n-            // Gin up a dummy trace, since this won't be committed\n-            // anyhow. We should make this typetrace stuff more\n-            // generic so we don't have to do anything quite this\n-            // terrible.\n-            let trace = TypeTrace::dummy(self.tcx);\n-            self.equate(true, trace, param_env, a, b).map(|InferOk { obligations: _, .. }| {\n-                // We can intentionally ignore obligations here, since\n-                // this is part of a simple test for general\n-                // \"equatability\". However, it's not entirely clear\n-                // that we *ought* to be, perhaps a better thing would\n-                // be to use a mini-fulfillment context or something\n-                // like that.\n-            })\n-        })\n-    }\n-\n     pub fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n         let ty = self.node_type(id);\n         self.resolve_type_vars_or_error(&ty)"}, {"sha": "54fe3a42b6179050550ecd71b3899ec80d1652dc", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=c7a2e32c102057242950697da6b83b2190b00dfb", "patch": "@@ -84,12 +84,9 @@ fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     debug!(\"overlap: b_impl_header={:?}\", b_impl_header);\n \n     // Do `a` and `b` unify? If not, no overlap.\n-    let obligations = match selcx.infcx().eq_impl_headers(true,\n-                                                          &ObligationCause::dummy(),\n-                                                          param_env,\n-                                                          &a_impl_header,\n-                                                          &b_impl_header) {\n-        Ok(InferOk { obligations, .. }) => {\n+    let obligations = match selcx.infcx().at(&ObligationCause::dummy(), param_env)\n+                                         .eq_impl_headers(&a_impl_header, &b_impl_header) {\n+        Ok(InferOk { obligations, value: () }) => {\n             obligations\n         }\n         Err(_) => return None"}, {"sha": "049d5e488c946f0e0d3312c25083f2a33ebb5d5e", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=c7a2e32c102057242950697da6b83b2190b00dfb", "patch": "@@ -184,10 +184,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     obligation.cause.clone(),\n                     0\n                 );\n-                if let Err(error) = self.eq_types(\n-                    false, &obligation.cause, obligation.param_env,\n-                    data.ty, normalized.value\n-                ) {\n+                if let Err(error) = self.at(&obligation.cause, obligation.param_env)\n+                                        .eq(normalized.value, data.ty) {\n                     values = Some(infer::ValuePairs::Types(ExpectedFound {\n                         expected: normalized.value,\n                         found: data.ty,\n@@ -269,7 +267,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n                 let impl_self_ty = impl_trait_ref.self_ty();\n \n-                if let Ok(..) = self.can_equate(param_env, &trait_self_ty, &impl_self_ty) {\n+                if let Ok(..) = self.can_eq(param_env, trait_self_ty, impl_self_ty) {\n                     self_match_impls.push(def_id);\n \n                     if trait_ref.substs.types().skip(1)"}, {"sha": "dbeaf46e8be0dad9c6def6ff9e28717ef5c06bb4", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=c7a2e32c102057242950697da6b83b2190b00dfb", "patch": "@@ -181,11 +181,8 @@ fn project_and_unify_type<'cx, 'gcx, 'tcx>(\n            obligations);\n \n     let infcx = selcx.infcx();\n-    match infcx.eq_types(true,\n-                         &obligation.cause,\n-                         obligation.param_env,\n-                         normalized_ty,\n-                         obligation.predicate.ty) {\n+    match infcx.at(&obligation.cause, obligation.param_env)\n+               .eq(normalized_ty, obligation.predicate.ty) {\n         Ok(InferOk { obligations: inferred_obligations, value: () }) => {\n             obligations.extend(inferred_obligations);\n             Ok(Some(obligations))\n@@ -840,16 +837,13 @@ fn assemble_candidates_from_predicates<'cx, 'gcx, 'tcx, I>(\n                         data.to_poly_trait_ref();\n                     let obligation_poly_trait_ref =\n                         obligation_trait_ref.to_poly_trait_ref();\n-                    infcx.sub_poly_trait_refs(false,\n-                                              obligation.cause.clone(),\n-                                              obligation.param_env,\n-                                              data_poly_trait_ref,\n-                                              obligation_poly_trait_ref)\n-                        .map(|InferOk { obligations: _, value: () }| {\n-                            // FIXME(#32730) -- do we need to take obligations\n-                            // into account in any way? At the moment, no.\n-                        })\n-                        .is_ok()\n+                    infcx.at(&obligation.cause, obligation.param_env)\n+                         .sup(obligation_poly_trait_ref, data_poly_trait_ref)\n+                         .map(|InferOk { obligations: _, value: () }| {\n+                             // FIXME(#32730) -- do we need to take obligations\n+                             // into account in any way? At the moment, no.\n+                         })\n+                         .is_ok()\n                 });\n \n                 debug!(\"assemble_candidates_from_predicates: candidate={:?} \\\n@@ -1110,11 +1104,9 @@ fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n             let data_poly_trait_ref = data.to_poly_trait_ref();\n             let obligation_poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n             selcx.infcx().probe(|_| {\n-                selcx.infcx().sub_poly_trait_refs(false,\n-                                                  obligation.cause.clone(),\n-                                                  obligation.param_env,\n-                                                  data_poly_trait_ref,\n-                                                  obligation_poly_trait_ref).is_ok()\n+                selcx.infcx().at(&obligation.cause, obligation.param_env)\n+                             .sup(obligation_poly_trait_ref, data_poly_trait_ref)\n+                             .is_ok()\n             })\n         });\n "}, {"sha": "6ac26e413ce4a758e6913214923b3084468367f1", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 24, "deletions": 41, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=c7a2e32c102057242950697da6b83b2190b00dfb", "patch": "@@ -1269,12 +1269,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         -> bool\n     {\n         assert!(!skol_trait_ref.has_escaping_regions());\n-        let cause = obligation.cause.clone();\n-        match self.infcx.sub_poly_trait_refs(false,\n-                                             cause,\n-                                             obligation.param_env,\n-                                             trait_bound.clone(),\n-                                             ty::Binder(skol_trait_ref.clone())) {\n+        match self.infcx.at(&obligation.cause, obligation.param_env)\n+                        .sup(ty::Binder(skol_trait_ref), trait_bound) {\n             Ok(InferOk { obligations, .. }) => {\n                 self.inferred_obligations.extend(obligations);\n             }\n@@ -2436,11 +2432,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                -> Result<(), SelectionError<'tcx>>\n     {\n         let obligation_trait_ref = obligation_trait_ref.clone();\n-        self.infcx.sub_poly_trait_refs(false,\n-                                       obligation_cause.clone(),\n-                                       obligation_param_env,\n-                                       expected_trait_ref.clone(),\n-                                       obligation_trait_ref.clone())\n+        self.infcx\n+            .at(&obligation_cause, obligation_param_env)\n+            .sup(obligation_trait_ref, expected_trait_ref)\n             .map(|InferOk { obligations, .. }| self.inferred_obligations.extend(obligations))\n             .map_err(|e| OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n     }\n@@ -2475,12 +2469,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let new_trait = tcx.mk_dynamic(\n                     ty::Binder(tcx.mk_existential_predicates(iter)), r_b);\n                 let InferOk { obligations, .. } =\n-                    self.infcx.eq_types(false,\n-                                        &obligation.cause,\n-                                        obligation.param_env,\n-                                        new_trait,\n-                                        target)\n-                    .map_err(|_| Unimplemented)?;\n+                    self.infcx.at(&obligation.cause, obligation.param_env)\n+                              .eq(target, new_trait)\n+                              .map_err(|_| Unimplemented)?;\n                 self.inferred_obligations.extend(obligations);\n \n                 // Register one obligation for 'a: 'b.\n@@ -2540,8 +2531,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // [T; n] -> [T].\n             (&ty::TyArray(a, _), &ty::TySlice(b)) => {\n                 let InferOk { obligations, .. } =\n-                    self.infcx.eq_types(false, &obligation.cause, obligation.param_env, a, b)\n-                    .map_err(|_| Unimplemented)?;\n+                    self.infcx.at(&obligation.cause, obligation.param_env)\n+                              .eq(b, a)\n+                              .map_err(|_| Unimplemented)?;\n                 self.inferred_obligations.extend(obligations);\n             }\n \n@@ -2603,12 +2595,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 });\n                 let new_struct = tcx.mk_adt(def, tcx.mk_substs(params));\n                 let InferOk { obligations, .. } =\n-                    self.infcx.eq_types(false,\n-                                        &obligation.cause,\n-                                        obligation.param_env,\n-                                        new_struct,\n-                                        target)\n-                    .map_err(|_| Unimplemented)?;\n+                    self.infcx.at(&obligation.cause, obligation.param_env)\n+                              .eq(target, new_struct)\n+                              .map_err(|_| Unimplemented)?;\n                 self.inferred_obligations.extend(obligations);\n \n                 // Construct the nested Field<T>: Unsize<Field<U>> predicate.\n@@ -2696,15 +2685,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                skol_obligation_trait_ref);\n \n         let InferOk { obligations, .. } =\n-            self.infcx.eq_trait_refs(false,\n-                                     &obligation.cause,\n-                                     obligation.param_env,\n-                                     impl_trait_ref.value.clone(),\n-                                     skol_obligation_trait_ref)\n-            .map_err(|e| {\n-                debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e);\n-                ()\n-            })?;\n+            self.infcx.at(&obligation.cause, obligation.param_env)\n+                      .eq(skol_obligation_trait_ref, impl_trait_ref.value)\n+                      .map_err(|e| {\n+                          debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e);\n+                          ()\n+                      })?;\n         self.inferred_obligations.extend(obligations);\n \n         if let Err(e) = self.infcx.leak_check(false,\n@@ -2770,13 +2756,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                obligation,\n                poly_trait_ref);\n \n-        self.infcx.sub_poly_trait_refs(false,\n-                                       obligation.cause.clone(),\n-                                       obligation.param_env,\n-                                       poly_trait_ref,\n-                                       obligation.predicate.to_poly_trait_ref())\n-            .map(|InferOk { obligations, .. }| self.inferred_obligations.extend(obligations))\n-            .map_err(|_| ())\n+        self.infcx.at(&obligation.cause, obligation.param_env)\n+                  .sup(obligation.predicate.to_poly_trait_ref(), poly_trait_ref)\n+                  .map(|InferOk { obligations, .. }| self.inferred_obligations.extend(obligations))\n+                  .map_err(|_| ())\n     }\n \n     ///////////////////////////////////////////////////////////////////////////"}, {"sha": "689f06a359730056625988161a583642fe1eef36", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=c7a2e32c102057242950697da6b83b2190b00dfb", "patch": "@@ -228,11 +228,8 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                                                        target_substs);\n \n     // do the impls unify? If not, no specialization.\n-    match infcx.eq_trait_refs(true,\n-                              &ObligationCause::dummy(),\n-                              param_env,\n-                              source_trait_ref,\n-                              target_trait_ref) {\n+    match infcx.at(&ObligationCause::dummy(), param_env)\n+               .eq(source_trait_ref, target_trait_ref) {\n         Ok(InferOk { obligations: o, .. }) => {\n             obligations.extend(o);\n         }"}, {"sha": "da8e3b5a42ba9e5dac82cb9e4ae59ac16be42e7b", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=c7a2e32c102057242950697da6b83b2190b00dfb", "patch": "@@ -353,18 +353,20 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         infer_ok.value\n     }\n \n-    fn sub_types(&mut self, sup: Ty<'tcx>, sub: Ty<'tcx>)\n+    fn sub_types(&mut self, sub: Ty<'tcx>, sup: Ty<'tcx>)\n                  -> infer::UnitResult<'tcx>\n     {\n-        self.infcx.sub_types(false, &self.misc(self.last_span), self.param_env, sup, sub)\n-            .map(|ok| self.register_infer_ok_obligations(ok))\n+        self.infcx.at(&self.misc(self.last_span), self.param_env)\n+                  .sup(sup, sub)\n+                  .map(|ok| self.register_infer_ok_obligations(ok))\n     }\n \n     fn eq_types(&mut self, span: Span, a: Ty<'tcx>, b: Ty<'tcx>)\n                 -> infer::UnitResult<'tcx>\n     {\n-        self.infcx.eq_types(false, &self.misc(span), self.param_env, a, b)\n-            .map(|ok| self.register_infer_ok_obligations(ok))\n+        self.infcx.at(&self.misc(span), self.param_env)\n+                  .eq(b, a)\n+                  .map(|ok| self.register_infer_ok_obligations(ok))\n     }\n \n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {"}, {"sha": "30ac7b4bfb9be8d14a4c069e48c6b81184598324", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=c7a2e32c102057242950697da6b83b2190b00dfb", "patch": "@@ -64,7 +64,7 @@ use check::{Diverges, FnCtxt};\n \n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::infer::{Coercion, InferResult, InferOk, TypeTrace};\n+use rustc::infer::{Coercion, InferResult, InferOk};\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n@@ -135,11 +135,13 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n     fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         self.commit_if_ok(|_| {\n-            let trace = TypeTrace::types(&self.cause, false, a, b);\n             if self.use_lub {\n-                self.lub(false, trace, self.fcx.param_env, &a, &b)\n+                self.at(&self.cause, self.fcx.param_env)\n+                    .lub(b, a)\n             } else {\n-                self.sub(false, trace, self.fcx.param_env, &a, &b)\n+                self.at(&self.cause, self.fcx.param_env)\n+                    .sup(b, a)\n+                    .map(|InferOk { value: (), obligations }| InferOk { value: a, obligations })\n             }\n         })\n     }\n@@ -771,20 +773,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return Ok(prev_ty);\n         }\n \n-        let trace = TypeTrace::types(cause, true, prev_ty, new_ty);\n-\n         // Special-case that coercion alone cannot handle:\n         // Two function item types of differing IDs or Substs.\n         match (&prev_ty.sty, &new_ty.sty) {\n             (&ty::TyFnDef(a_def_id, a_substs, a_fty), &ty::TyFnDef(b_def_id, b_substs, b_fty)) => {\n                 // The signature must always match.\n-                let fty = self.lub(true, trace.clone(), self.param_env, &a_fty, &b_fty)\n+                let fty = self.at(cause, self.param_env)\n+                              .trace(prev_ty, new_ty)\n+                              .lub(&a_fty, &b_fty)\n                               .map(|ok| self.register_infer_ok_obligations(ok))?;\n \n                 if a_def_id == b_def_id {\n                     // Same function, maybe the parameters match.\n                     let substs = self.commit_if_ok(|_| {\n-                        self.lub(true, trace.clone(), self.param_env, &a_substs, &b_substs)\n+                        self.at(cause, self.param_env)\n+                            .trace(prev_ty, new_ty)\n+                            .lub(&a_substs, &b_substs)\n                             .map(|ok| self.register_infer_ok_obligations(ok))\n                     });\n \n@@ -853,7 +857,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             if !noop {\n                 return self.commit_if_ok(|_| {\n-                    self.lub(true, trace.clone(), self.param_env, &prev_ty, &new_ty)\n+                    self.at(cause, self.param_env)\n+                        .lub(prev_ty, new_ty)\n                         .map(|ok| self.register_infer_ok_obligations(ok))\n                 });\n             }\n@@ -866,7 +871,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     Err(e)\n                 } else {\n                     self.commit_if_ok(|_| {\n-                        self.lub(true, trace, self.param_env, &prev_ty, &new_ty)\n+                        self.at(cause, self.param_env)\n+                            .lub(prev_ty, new_ty)\n                             .map(|ok| self.register_infer_ok_obligations(ok))\n                     })\n                 }\n@@ -1109,7 +1115,8 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n             // Another example is `break` with no argument expression.\n             assert!(expression_ty.is_nil());\n             assert!(expression_ty.is_nil(), \"if let hack without unit type\");\n-            fcx.eq_types(label_expression_as_expected, cause, fcx.param_env, expression_ty, self.merged_ty())\n+            fcx.at(cause, fcx.param_env)\n+               .eq_exp(label_expression_as_expected, expression_ty, self.merged_ty())\n                .map(|infer_ok| {\n                    fcx.register_infer_ok_obligations(infer_ok);\n                    expression_ty"}, {"sha": "7633be24477c65b48a73f8b0c30b95855d16c5c4", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=c7a2e32c102057242950697da6b83b2190b00dfb", "patch": "@@ -289,7 +289,8 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         debug!(\"compare_impl_method: trait_fty={:?}\", trait_fty);\n \n-        let sub_result = infcx.sub_types(false, &cause, param_env, impl_fty, trait_fty)\n+        let sub_result = infcx.at(&cause, param_env)\n+                              .sup(trait_fty, impl_fty)\n                               .map(|InferOk { obligations, .. }| {\n                                   inh.register_predicates(obligations);\n                               });\n@@ -460,28 +461,23 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n                 impl_iter.zip(trait_iter)\n                          .zip(impl_m_iter)\n                          .zip(trait_m_iter)\n-                         .filter_map(|(((impl_arg_ty, trait_arg_ty), impl_arg), trait_arg)| {\n-                             match infcx.sub_types(true,\n-                                                   &cause,\n-                                                   param_env,\n-                                                   trait_arg_ty,\n-                                                   impl_arg_ty) {\n+                         .filter_map(|(((&impl_arg_ty, &trait_arg_ty), impl_arg), trait_arg)| {\n+                             match infcx.at(&cause, param_env).sub(trait_arg_ty, impl_arg_ty) {\n                                  Ok(_) => None,\n                                  Err(_) => Some((impl_arg.span, Some(trait_arg.span))),\n                              }\n                          })\n                          .next()\n                          .unwrap_or_else(|| {\n-                             if infcx.sub_types(false,\n-                                                &cause,\n-                                                param_env,\n-                                                impl_sig.output(),\n-                                                trait_sig.output())\n-                                     .is_err() {\n-                                         (impl_m_output.span(), Some(trait_m_output.span()))\n-                                     } else {\n-                                         (cause.span, tcx.hir.span_if_local(trait_m.def_id))\n-                                     }\n+                             if\n+                                 infcx.at(&cause, param_env)\n+                                      .sup(trait_sig.output(), impl_sig.output())\n+                                      .is_err()\n+                             {\n+                                 (impl_m_output.span(), Some(trait_m_output.span()))\n+                             } else {\n+                                 (cause.span, tcx.hir.span_if_local(trait_m.def_id))\n+                             }\n                          })\n             } else {\n                 (cause.span, tcx.hir.span_if_local(trait_m.def_id))\n@@ -760,8 +756,9 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         debug!(\"compare_const_impl: trait_ty={:?}\", trait_ty);\n \n-        let err = infcx.sub_types(false, &cause, param_env, impl_ty, trait_ty)\n-            .map(|ok| inh.register_infer_ok_obligations(ok));\n+        let err = infcx.at(&cause, param_env)\n+                       .sup(trait_ty, impl_ty)\n+                       .map(|ok| inh.register_infer_ok_obligations(ok));\n \n         if let Err(terr) = err {\n             debug!(\"checking associated const for compatibility: impl ty {:?}, trait ty {:?}\","}, {"sha": "40d53b5e97991e283e2aa18895d3e72082dde339", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=c7a2e32c102057242950697da6b83b2190b00dfb", "patch": "@@ -26,8 +26,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // Requires that the two types unify, and prints an error message if\n     // they don't.\n     pub fn demand_suptype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {\n-        let cause = self.misc(sp);\n-        match self.sub_types(false, &cause, self.param_env, actual, expected) {\n+        let cause = &self.misc(sp);\n+        match self.at(cause, self.param_env).sup(expected, actual) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n             },\n@@ -54,7 +54,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                      cause: &ObligationCause<'tcx>,\n                                      expected: Ty<'tcx>,\n                                      actual: Ty<'tcx>) -> Option<DiagnosticBuilder<'tcx>> {\n-        match self.eq_types(false, cause, self.param_env, actual, expected) {\n+        match self.at(cause, self.param_env).eq(expected, actual) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n                 None"}, {"sha": "bff9289de505585b3279e0475c4fb328d06f7f8e", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=c7a2e32c102057242950697da6b83b2190b00dfb", "patch": "@@ -92,7 +92,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n         let fresh_impl_self_ty = drop_impl_ty.subst(tcx, fresh_impl_substs);\n \n         let cause = &ObligationCause::misc(drop_impl_span, drop_impl_node_id);\n-        match infcx.eq_types(true, cause, impl_param_env, named_type, fresh_impl_self_ty) {\n+        match infcx.at(cause, impl_param_env).eq(named_type, fresh_impl_self_ty) {\n             Ok(InferOk { obligations, .. }) => {\n                 fulfillment_cx.register_predicate_obligations(infcx, obligations);\n             }"}, {"sha": "c8815f3df5aa25ecda4a4772b287a9b1eec84c21", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=c7a2e32c102057242950697da6b83b2190b00dfb", "patch": "@@ -340,7 +340,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn unify_receivers(&mut self, self_ty: Ty<'tcx>, method_self_ty: Ty<'tcx>) {\n-        match self.sub_types(false, &self.misc(self.span), self.param_env, self_ty, method_self_ty) {\n+        match self.at(&self.misc(self.span), self.param_env).sup(method_self_ty, self_ty) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n             }"}, {"sha": "f975a835923623440569dabe72c8e6ce2264400e", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=c7a2e32c102057242950697da6b83b2190b00dfb", "patch": "@@ -679,7 +679,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                     let output = fty.output().subst(self.tcx, substs);\n                     let (output, _) = self.replace_late_bound_regions_with_fresh_var(\n                         self.span, infer::FnCall, &output);\n-                    self.can_sub_types(self.param_env, output, expected).is_ok()\n+                    self.can_sub(self.param_env, output, expected).is_ok()\n                 })\n             }\n             _ => false,\n@@ -885,7 +885,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                        substs,\n                        bound);\n \n-                if self.can_equate(self.param_env, &step.self_ty, &bound.self_ty()).is_ok() {\n+                if self.can_eq(self.param_env, step.self_ty, bound.self_ty()).is_ok() {\n                     let xform_self_ty = self.xform_self_ty(&item, bound.self_ty(), bound.substs);\n \n                     debug!(\"assemble_projection_candidates: bound={:?} xform_self_ty={:?}\",\n@@ -1143,11 +1143,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         self.probe(|_| {\n             // First check that the self type can be related.\n-            let sub_obligations = match self.sub_types(false,\n-                                                       &ObligationCause::dummy(),\n-                                                       self.param_env,\n-                                                       self_ty,\n-                                                       probe.xform_self_ty) {\n+            let sub_obligations = match self.at(&ObligationCause::dummy(), self.param_env)\n+                                            .sup(probe.xform_self_ty, self_ty) {\n                 Ok(InferOk { obligations, value: () }) => obligations,\n                 Err(_) => {\n                     debug!(\"--> cannot relate self-types\");"}, {"sha": "48afd91b23337d8f422d7c1899e27c94901ef22e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c7a2e32c102057242950697da6b83b2190b00dfb", "patch": "@@ -2723,7 +2723,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // is polymorphic) and the expected return type.\n                 // No argument expectations are produced if unification fails.\n                 let origin = self.misc(call_span);\n-                let ures = self.sub_types(false, &origin, self.param_env, formal_ret, ret_ty);\n+                let ures = self.at(&origin, self.param_env).sup(ret_ty, formal_ret);\n \n                 // FIXME(#15760) can't use try! here, FromError doesn't default\n                 // to identity so the resulting type is not constrained.\n@@ -4218,7 +4218,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => return,\n         };\n         let last_expr_ty = self.expr_ty(last_expr);\n-        if self.can_sub_types(self.param_env, last_expr_ty, expected_ty).is_err() {\n+        if self.can_sub(self.param_env, last_expr_ty, expected_ty).is_err() {\n             return;\n         }\n         let original_span = original_sp(last_stmt.span, blk.span);\n@@ -4478,7 +4478,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let ty = self.tcx.type_of(impl_def_id);\n \n             let impl_ty = self.instantiate_type_scheme(span, &substs, &ty);\n-            match self.sub_types(false, &self.misc(span), self.param_env, self_ty, impl_ty) {\n+            match self.at(&self.misc(span), self.param_env).sup(impl_ty, self_ty) {\n                 Ok(ok) => self.register_infer_ok_obligations(ok),\n                 Err(_) => {\n                     span_bug!(span,"}, {"sha": "d2475a2e5b2fa077e348360392dbcbc8345f68db", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=c7a2e32c102057242950697da6b83b2190b00dfb", "patch": "@@ -1660,7 +1660,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n                     // check whether this predicate applies to our current projection\n                     let cause = self.fcx.misc(span);\n-                    match self.eq_types(false, &cause, self.fcx.param_env, ty, outlives.0) {\n+                    match self.at(&cause, self.fcx.param_env).eq(outlives.0, ty) {\n                         Ok(ok) => {\n                             self.register_infer_ok_obligations(ok);\n                             Ok(outlives.1)"}, {"sha": "377b7b069d3312ec4a71b9c3b269a78d58a07c2e", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=c7a2e32c102057242950697da6b83b2190b00dfb", "patch": "@@ -308,7 +308,7 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         // we may have to evaluate constraint\n                         // expressions in the course of execution.)\n                         // See e.g. #41936.\n-                        if let Ok(ok) = infcx.eq_types(false, &cause, param_env, b, a) {\n+                        if let Ok(ok) = infcx.at(&cause, param_env).eq(a, b) {\n                             if ok.obligations.is_empty() {\n                                 return None;\n                             }"}, {"sha": "06cb9f948c9b3927efde87894b801dba3fc6358f", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7a2e32c102057242950697da6b83b2190b00dfb/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=c7a2e32c102057242950697da6b83b2190b00dfb", "patch": "@@ -158,7 +158,7 @@ fn require_same_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tcx.infer_ctxt(()).enter(|ref infcx| {\n         let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n         let mut fulfill_cx = FulfillmentContext::new();\n-        match infcx.eq_types(false, &cause, param_env, expected, actual) {\n+        match infcx.at(&cause, param_env).eq(expected, actual) {\n             Ok(InferOk { obligations, .. }) => {\n                 fulfill_cx.register_predicate_obligations(infcx, obligations);\n             }"}]}