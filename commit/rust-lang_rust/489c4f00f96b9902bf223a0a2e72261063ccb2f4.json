{"sha": "489c4f00f96b9902bf223a0a2e72261063ccb2f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4OWM0ZjAwZjk2Yjk5MDJiZjIyM2EwYTJlNzIyNjEwNjNjY2IyZjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-24T09:43:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-24T09:43:23Z"}, "message": "Auto merge of #6756 - smoelius:clippy_utils, r=flip1995,obi-obk\n\nFactor out `clippy_utils` crate\n\nAs discussed in https://github.com/rust-lang/rust-clippy/pull/6746, this PR factors out `clippy_lints::utils` as its own crate, `clippy_utils` .\n\nThis change will allow `clippy_utils` to be used in lints outside of Clippy.\n\nThere is no plan to publish this crate on `crates.io` (see https://github.com/rust-lang/rust-clippy/pull/6746#issuecomment-780747522). Dependent crates should obtain it from GitHub.\n\nchangelog: Factor out `clippy_utils` so it can be used by external tools (not published)", "tree": {"sha": "ceba99372f4d0652faec9abcd35db82a6e7a0489", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ceba99372f4d0652faec9abcd35db82a6e7a0489"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/489c4f00f96b9902bf223a0a2e72261063ccb2f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/489c4f00f96b9902bf223a0a2e72261063ccb2f4", "html_url": "https://github.com/rust-lang/rust/commit/489c4f00f96b9902bf223a0a2e72261063ccb2f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/489c4f00f96b9902bf223a0a2e72261063ccb2f4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "045d3f34f87a620df0c9c96f5356662a5752faff", "url": "https://api.github.com/repos/rust-lang/rust/commits/045d3f34f87a620df0c9c96f5356662a5752faff", "html_url": "https://github.com/rust-lang/rust/commit/045d3f34f87a620df0c9c96f5356662a5752faff"}, {"sha": "ab7381f085d587f49949e31a02847b5a78b9ea36", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab7381f085d587f49949e31a02847b5a78b9ea36", "html_url": "https://github.com/rust-lang/rust/commit/ab7381f085d587f49949e31a02847b5a78b9ea36"}], "stats": {"total": 4992, "additions": 2529, "deletions": 2463}, "files": [{"sha": "139129d55e330af9d2f323986a1c621878152625", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "patch": "@@ -18,6 +18,7 @@ out\n *Cargo.lock\n /target\n /clippy_lints/target\n+/clippy_utils/target\n /clippy_workspace_tests/target\n /clippy_dev/target\n /rustc_tools_util/target"}, {"sha": "d5ec8597044c8d83ba2c5ebafeadd930792e761c", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "patch": "@@ -18,6 +18,7 @@ edition = \"2018\"\n \n [dependencies]\n cargo_metadata = \"0.12\"\n+clippy_utils = { path = \"../clippy_utils\" }\n if_chain = \"1.0.0\"\n itertools = \"0.9\"\n pulldown-cmark = { version = \"0.8\", default-features = false }\n@@ -38,4 +39,4 @@ syn = { version = \"1\", features = [\"full\"] }\n [features]\n deny-warnings = []\n # build clippy with internal lints enabled, off by default\n-internal-lints = []\n+internal-lints = [\"clippy_utils/internal-lints\"]"}, {"sha": "7e87f53e3fba7d2a7c8b739689d9dc416b77810e", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 1, "deletions": 574, "changes": 575, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "patch": "@@ -1,574 +1 @@\n-#![allow(clippy::float_cmp)]\n-\n-use crate::utils::{clip, sext, unsext};\n-use if_chain::if_chain;\n-use rustc_ast::ast::{self, LitFloatType, LitKind};\n-use rustc_data_structures::sync::Lrc;\n-use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::{BinOp, BinOpKind, Block, Expr, ExprKind, HirId, QPath, UnOp};\n-use rustc_lint::LateContext;\n-use rustc_middle::mir::interpret::Scalar;\n-use rustc_middle::ty::subst::{Subst, SubstsRef};\n-use rustc_middle::ty::{self, FloatTy, ScalarInt, Ty, TyCtxt};\n-use rustc_middle::{bug, span_bug};\n-use rustc_span::symbol::Symbol;\n-use std::cmp::Ordering::{self, Equal};\n-use std::convert::TryInto;\n-use std::hash::{Hash, Hasher};\n-\n-/// A `LitKind`-like enum to fold constant `Expr`s into.\n-#[derive(Debug, Clone)]\n-pub enum Constant {\n-    /// A `String` (e.g., \"abc\").\n-    Str(String),\n-    /// A binary string (e.g., `b\"abc\"`).\n-    Binary(Lrc<[u8]>),\n-    /// A single `char` (e.g., `'a'`).\n-    Char(char),\n-    /// An integer's bit representation.\n-    Int(u128),\n-    /// An `f32`.\n-    F32(f32),\n-    /// An `f64`.\n-    F64(f64),\n-    /// `true` or `false`.\n-    Bool(bool),\n-    /// An array of constants.\n-    Vec(Vec<Constant>),\n-    /// Also an array, but with only one constant, repeated N times.\n-    Repeat(Box<Constant>, u64),\n-    /// A tuple of constants.\n-    Tuple(Vec<Constant>),\n-    /// A raw pointer.\n-    RawPtr(u128),\n-    /// A reference\n-    Ref(Box<Constant>),\n-    /// A literal with syntax error.\n-    Err(Symbol),\n-}\n-\n-impl PartialEq for Constant {\n-    fn eq(&self, other: &Self) -> bool {\n-        match (self, other) {\n-            (&Self::Str(ref ls), &Self::Str(ref rs)) => ls == rs,\n-            (&Self::Binary(ref l), &Self::Binary(ref r)) => l == r,\n-            (&Self::Char(l), &Self::Char(r)) => l == r,\n-            (&Self::Int(l), &Self::Int(r)) => l == r,\n-            (&Self::F64(l), &Self::F64(r)) => {\n-                // We want `Fw32 == FwAny` and `FwAny == Fw64`, and by transitivity we must have\n-                // `Fw32 == Fw64`, so don\u2019t compare them.\n-                // `to_bits` is required to catch non-matching 0.0, -0.0, and NaNs.\n-                l.to_bits() == r.to_bits()\n-            },\n-            (&Self::F32(l), &Self::F32(r)) => {\n-                // We want `Fw32 == FwAny` and `FwAny == Fw64`, and by transitivity we must have\n-                // `Fw32 == Fw64`, so don\u2019t compare them.\n-                // `to_bits` is required to catch non-matching 0.0, -0.0, and NaNs.\n-                f64::from(l).to_bits() == f64::from(r).to_bits()\n-            },\n-            (&Self::Bool(l), &Self::Bool(r)) => l == r,\n-            (&Self::Vec(ref l), &Self::Vec(ref r)) | (&Self::Tuple(ref l), &Self::Tuple(ref r)) => l == r,\n-            (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => ls == rs && lv == rv,\n-            (&Self::Ref(ref lb), &Self::Ref(ref rb)) => *lb == *rb,\n-            // TODO: are there inter-type equalities?\n-            _ => false,\n-        }\n-    }\n-}\n-\n-impl Hash for Constant {\n-    fn hash<H>(&self, state: &mut H)\n-    where\n-        H: Hasher,\n-    {\n-        std::mem::discriminant(self).hash(state);\n-        match *self {\n-            Self::Str(ref s) => {\n-                s.hash(state);\n-            },\n-            Self::Binary(ref b) => {\n-                b.hash(state);\n-            },\n-            Self::Char(c) => {\n-                c.hash(state);\n-            },\n-            Self::Int(i) => {\n-                i.hash(state);\n-            },\n-            Self::F32(f) => {\n-                f64::from(f).to_bits().hash(state);\n-            },\n-            Self::F64(f) => {\n-                f.to_bits().hash(state);\n-            },\n-            Self::Bool(b) => {\n-                b.hash(state);\n-            },\n-            Self::Vec(ref v) | Self::Tuple(ref v) => {\n-                v.hash(state);\n-            },\n-            Self::Repeat(ref c, l) => {\n-                c.hash(state);\n-                l.hash(state);\n-            },\n-            Self::RawPtr(u) => {\n-                u.hash(state);\n-            },\n-            Self::Ref(ref r) => {\n-                r.hash(state);\n-            },\n-            Self::Err(ref s) => {\n-                s.hash(state);\n-            },\n-        }\n-    }\n-}\n-\n-impl Constant {\n-    pub fn partial_cmp(tcx: TyCtxt<'_>, cmp_type: Ty<'_>, left: &Self, right: &Self) -> Option<Ordering> {\n-        match (left, right) {\n-            (&Self::Str(ref ls), &Self::Str(ref rs)) => Some(ls.cmp(rs)),\n-            (&Self::Char(ref l), &Self::Char(ref r)) => Some(l.cmp(r)),\n-            (&Self::Int(l), &Self::Int(r)) => {\n-                if let ty::Int(int_ty) = *cmp_type.kind() {\n-                    Some(sext(tcx, l, int_ty).cmp(&sext(tcx, r, int_ty)))\n-                } else {\n-                    Some(l.cmp(&r))\n-                }\n-            },\n-            (&Self::F64(l), &Self::F64(r)) => l.partial_cmp(&r),\n-            (&Self::F32(l), &Self::F32(r)) => l.partial_cmp(&r),\n-            (&Self::Bool(ref l), &Self::Bool(ref r)) => Some(l.cmp(r)),\n-            (&Self::Tuple(ref l), &Self::Tuple(ref r)) | (&Self::Vec(ref l), &Self::Vec(ref r)) => l\n-                .iter()\n-                .zip(r.iter())\n-                .map(|(li, ri)| Self::partial_cmp(tcx, cmp_type, li, ri))\n-                .find(|r| r.map_or(true, |o| o != Ordering::Equal))\n-                .unwrap_or_else(|| Some(l.len().cmp(&r.len()))),\n-            (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => {\n-                match Self::partial_cmp(tcx, cmp_type, lv, rv) {\n-                    Some(Equal) => Some(ls.cmp(rs)),\n-                    x => x,\n-                }\n-            },\n-            (&Self::Ref(ref lb), &Self::Ref(ref rb)) => Self::partial_cmp(tcx, cmp_type, lb, rb),\n-            // TODO: are there any useful inter-type orderings?\n-            _ => None,\n-        }\n-    }\n-}\n-\n-/// Parses a `LitKind` to a `Constant`.\n-pub fn lit_to_constant(lit: &LitKind, ty: Option<Ty<'_>>) -> Constant {\n-    match *lit {\n-        LitKind::Str(ref is, _) => Constant::Str(is.to_string()),\n-        LitKind::Byte(b) => Constant::Int(u128::from(b)),\n-        LitKind::ByteStr(ref s) => Constant::Binary(Lrc::clone(s)),\n-        LitKind::Char(c) => Constant::Char(c),\n-        LitKind::Int(n, _) => Constant::Int(n),\n-        LitKind::Float(ref is, LitFloatType::Suffixed(fty)) => match fty {\n-            ast::FloatTy::F32 => Constant::F32(is.as_str().parse().unwrap()),\n-            ast::FloatTy::F64 => Constant::F64(is.as_str().parse().unwrap()),\n-        },\n-        LitKind::Float(ref is, LitFloatType::Unsuffixed) => match ty.expect(\"type of float is known\").kind() {\n-            ty::Float(FloatTy::F32) => Constant::F32(is.as_str().parse().unwrap()),\n-            ty::Float(FloatTy::F64) => Constant::F64(is.as_str().parse().unwrap()),\n-            _ => bug!(),\n-        },\n-        LitKind::Bool(b) => Constant::Bool(b),\n-        LitKind::Err(s) => Constant::Err(s),\n-    }\n-}\n-\n-pub fn constant<'tcx>(\n-    lcx: &LateContext<'tcx>,\n-    typeck_results: &ty::TypeckResults<'tcx>,\n-    e: &Expr<'_>,\n-) -> Option<(Constant, bool)> {\n-    let mut cx = ConstEvalLateContext {\n-        lcx,\n-        typeck_results,\n-        param_env: lcx.param_env,\n-        needed_resolution: false,\n-        substs: lcx.tcx.intern_substs(&[]),\n-    };\n-    cx.expr(e).map(|cst| (cst, cx.needed_resolution))\n-}\n-\n-pub fn constant_simple<'tcx>(\n-    lcx: &LateContext<'tcx>,\n-    typeck_results: &ty::TypeckResults<'tcx>,\n-    e: &Expr<'_>,\n-) -> Option<Constant> {\n-    constant(lcx, typeck_results, e).and_then(|(cst, res)| if res { None } else { Some(cst) })\n-}\n-\n-/// Creates a `ConstEvalLateContext` from the given `LateContext` and `TypeckResults`.\n-pub fn constant_context<'a, 'tcx>(\n-    lcx: &'a LateContext<'tcx>,\n-    typeck_results: &'a ty::TypeckResults<'tcx>,\n-) -> ConstEvalLateContext<'a, 'tcx> {\n-    ConstEvalLateContext {\n-        lcx,\n-        typeck_results,\n-        param_env: lcx.param_env,\n-        needed_resolution: false,\n-        substs: lcx.tcx.intern_substs(&[]),\n-    }\n-}\n-\n-pub struct ConstEvalLateContext<'a, 'tcx> {\n-    lcx: &'a LateContext<'tcx>,\n-    typeck_results: &'a ty::TypeckResults<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    needed_resolution: bool,\n-    substs: SubstsRef<'tcx>,\n-}\n-\n-impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n-    /// Simple constant folding: Insert an expression, get a constant or none.\n-    pub fn expr(&mut self, e: &Expr<'_>) -> Option<Constant> {\n-        match e.kind {\n-            ExprKind::Path(ref qpath) => self.fetch_path(qpath, e.hir_id, self.typeck_results.expr_ty(e)),\n-            ExprKind::Block(ref block, _) => self.block(block),\n-            ExprKind::Lit(ref lit) => Some(lit_to_constant(&lit.node, self.typeck_results.expr_ty_opt(e))),\n-            ExprKind::Array(ref vec) => self.multi(vec).map(Constant::Vec),\n-            ExprKind::Tup(ref tup) => self.multi(tup).map(Constant::Tuple),\n-            ExprKind::Repeat(ref value, _) => {\n-                let n = match self.typeck_results.expr_ty(e).kind() {\n-                    ty::Array(_, n) => n.try_eval_usize(self.lcx.tcx, self.lcx.param_env)?,\n-                    _ => span_bug!(e.span, \"typeck error\"),\n-                };\n-                self.expr(value).map(|v| Constant::Repeat(Box::new(v), n))\n-            },\n-            ExprKind::Unary(op, ref operand) => self.expr(operand).and_then(|o| match op {\n-                UnOp::Not => self.constant_not(&o, self.typeck_results.expr_ty(e)),\n-                UnOp::Neg => self.constant_negate(&o, self.typeck_results.expr_ty(e)),\n-                UnOp::Deref => Some(if let Constant::Ref(r) = o { *r } else { o }),\n-            }),\n-            ExprKind::If(ref cond, ref then, ref otherwise) => self.ifthenelse(cond, then, *otherwise),\n-            ExprKind::Binary(op, ref left, ref right) => self.binop(op, left, right),\n-            ExprKind::Call(ref callee, ref args) => {\n-                // We only handle a few const functions for now.\n-                if_chain! {\n-                    if args.is_empty();\n-                    if let ExprKind::Path(qpath) = &callee.kind;\n-                    let res = self.typeck_results.qpath_res(qpath, callee.hir_id);\n-                    if let Some(def_id) = res.opt_def_id();\n-                    let def_path: Vec<_> = self.lcx.get_def_path(def_id).into_iter().map(Symbol::as_str).collect();\n-                    let def_path: Vec<&str> = def_path.iter().take(4).map(|s| &**s).collect();\n-                    if let [\"core\", \"num\", int_impl, \"max_value\"] = *def_path;\n-                    then {\n-                       let value = match int_impl {\n-                           \"<impl i8>\" => i8::MAX as u128,\n-                           \"<impl i16>\" => i16::MAX as u128,\n-                           \"<impl i32>\" => i32::MAX as u128,\n-                           \"<impl i64>\" => i64::MAX as u128,\n-                           \"<impl i128>\" => i128::MAX as u128,\n-                           _ => return None,\n-                       };\n-                       Some(Constant::Int(value))\n-                    }\n-                    else {\n-                        None\n-                    }\n-                }\n-            },\n-            ExprKind::Index(ref arr, ref index) => self.index(arr, index),\n-            ExprKind::AddrOf(_, _, ref inner) => self.expr(inner).map(|r| Constant::Ref(Box::new(r))),\n-            // TODO: add other expressions.\n-            _ => None,\n-        }\n-    }\n-\n-    #[allow(clippy::cast_possible_wrap)]\n-    fn constant_not(&self, o: &Constant, ty: Ty<'_>) -> Option<Constant> {\n-        use self::Constant::{Bool, Int};\n-        match *o {\n-            Bool(b) => Some(Bool(!b)),\n-            Int(value) => {\n-                let value = !value;\n-                match *ty.kind() {\n-                    ty::Int(ity) => Some(Int(unsext(self.lcx.tcx, value as i128, ity))),\n-                    ty::Uint(ity) => Some(Int(clip(self.lcx.tcx, value, ity))),\n-                    _ => None,\n-                }\n-            },\n-            _ => None,\n-        }\n-    }\n-\n-    fn constant_negate(&self, o: &Constant, ty: Ty<'_>) -> Option<Constant> {\n-        use self::Constant::{Int, F32, F64};\n-        match *o {\n-            Int(value) => {\n-                let ity = match *ty.kind() {\n-                    ty::Int(ity) => ity,\n-                    _ => return None,\n-                };\n-                // sign extend\n-                let value = sext(self.lcx.tcx, value, ity);\n-                let value = value.checked_neg()?;\n-                // clear unused bits\n-                Some(Int(unsext(self.lcx.tcx, value, ity)))\n-            },\n-            F32(f) => Some(F32(-f)),\n-            F64(f) => Some(F64(-f)),\n-            _ => None,\n-        }\n-    }\n-\n-    /// Create `Some(Vec![..])` of all constants, unless there is any\n-    /// non-constant part.\n-    fn multi(&mut self, vec: &[Expr<'_>]) -> Option<Vec<Constant>> {\n-        vec.iter().map(|elem| self.expr(elem)).collect::<Option<_>>()\n-    }\n-\n-    /// Lookup a possibly constant expression from a `ExprKind::Path`.\n-    fn fetch_path(&mut self, qpath: &QPath<'_>, id: HirId, ty: Ty<'tcx>) -> Option<Constant> {\n-        let res = self.typeck_results.qpath_res(qpath, id);\n-        match res {\n-            Res::Def(DefKind::Const | DefKind::AssocConst, def_id) => {\n-                let substs = self.typeck_results.node_substs(id);\n-                let substs = if self.substs.is_empty() {\n-                    substs\n-                } else {\n-                    substs.subst(self.lcx.tcx, self.substs)\n-                };\n-\n-                let result = self\n-                    .lcx\n-                    .tcx\n-                    .const_eval_resolve(\n-                        self.param_env,\n-                        ty::WithOptConstParam::unknown(def_id),\n-                        substs,\n-                        None,\n-                        None,\n-                    )\n-                    .ok()\n-                    .map(|val| rustc_middle::ty::Const::from_value(self.lcx.tcx, val, ty))?;\n-                let result = miri_to_const(&result);\n-                if result.is_some() {\n-                    self.needed_resolution = true;\n-                }\n-                result\n-            },\n-            // FIXME: cover all usable cases.\n-            _ => None,\n-        }\n-    }\n-\n-    fn index(&mut self, lhs: &'_ Expr<'_>, index: &'_ Expr<'_>) -> Option<Constant> {\n-        let lhs = self.expr(lhs);\n-        let index = self.expr(index);\n-\n-        match (lhs, index) {\n-            (Some(Constant::Vec(vec)), Some(Constant::Int(index))) => match vec.get(index as usize) {\n-                Some(Constant::F32(x)) => Some(Constant::F32(*x)),\n-                Some(Constant::F64(x)) => Some(Constant::F64(*x)),\n-                _ => None,\n-            },\n-            (Some(Constant::Vec(vec)), _) => {\n-                if !vec.is_empty() && vec.iter().all(|x| *x == vec[0]) {\n-                    match vec.get(0) {\n-                        Some(Constant::F32(x)) => Some(Constant::F32(*x)),\n-                        Some(Constant::F64(x)) => Some(Constant::F64(*x)),\n-                        _ => None,\n-                    }\n-                } else {\n-                    None\n-                }\n-            },\n-            _ => None,\n-        }\n-    }\n-\n-    /// A block can only yield a constant if it only has one constant expression.\n-    fn block(&mut self, block: &Block<'_>) -> Option<Constant> {\n-        if block.stmts.is_empty() {\n-            block.expr.as_ref().and_then(|b| self.expr(b))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn ifthenelse(&mut self, cond: &Expr<'_>, then: &Expr<'_>, otherwise: Option<&Expr<'_>>) -> Option<Constant> {\n-        if let Some(Constant::Bool(b)) = self.expr(cond) {\n-            if b {\n-                self.expr(&*then)\n-            } else {\n-                otherwise.as_ref().and_then(|expr| self.expr(expr))\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn binop(&mut self, op: BinOp, left: &Expr<'_>, right: &Expr<'_>) -> Option<Constant> {\n-        let l = self.expr(left)?;\n-        let r = self.expr(right);\n-        match (l, r) {\n-            (Constant::Int(l), Some(Constant::Int(r))) => match *self.typeck_results.expr_ty_opt(left)?.kind() {\n-                ty::Int(ity) => {\n-                    let l = sext(self.lcx.tcx, l, ity);\n-                    let r = sext(self.lcx.tcx, r, ity);\n-                    let zext = |n: i128| Constant::Int(unsext(self.lcx.tcx, n, ity));\n-                    match op.node {\n-                        BinOpKind::Add => l.checked_add(r).map(zext),\n-                        BinOpKind::Sub => l.checked_sub(r).map(zext),\n-                        BinOpKind::Mul => l.checked_mul(r).map(zext),\n-                        BinOpKind::Div if r != 0 => l.checked_div(r).map(zext),\n-                        BinOpKind::Rem if r != 0 => l.checked_rem(r).map(zext),\n-                        BinOpKind::Shr => l.checked_shr(r.try_into().expect(\"invalid shift\")).map(zext),\n-                        BinOpKind::Shl => l.checked_shl(r.try_into().expect(\"invalid shift\")).map(zext),\n-                        BinOpKind::BitXor => Some(zext(l ^ r)),\n-                        BinOpKind::BitOr => Some(zext(l | r)),\n-                        BinOpKind::BitAnd => Some(zext(l & r)),\n-                        BinOpKind::Eq => Some(Constant::Bool(l == r)),\n-                        BinOpKind::Ne => Some(Constant::Bool(l != r)),\n-                        BinOpKind::Lt => Some(Constant::Bool(l < r)),\n-                        BinOpKind::Le => Some(Constant::Bool(l <= r)),\n-                        BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n-                        BinOpKind::Gt => Some(Constant::Bool(l > r)),\n-                        _ => None,\n-                    }\n-                },\n-                ty::Uint(_) => match op.node {\n-                    BinOpKind::Add => l.checked_add(r).map(Constant::Int),\n-                    BinOpKind::Sub => l.checked_sub(r).map(Constant::Int),\n-                    BinOpKind::Mul => l.checked_mul(r).map(Constant::Int),\n-                    BinOpKind::Div => l.checked_div(r).map(Constant::Int),\n-                    BinOpKind::Rem => l.checked_rem(r).map(Constant::Int),\n-                    BinOpKind::Shr => l.checked_shr(r.try_into().expect(\"shift too large\")).map(Constant::Int),\n-                    BinOpKind::Shl => l.checked_shl(r.try_into().expect(\"shift too large\")).map(Constant::Int),\n-                    BinOpKind::BitXor => Some(Constant::Int(l ^ r)),\n-                    BinOpKind::BitOr => Some(Constant::Int(l | r)),\n-                    BinOpKind::BitAnd => Some(Constant::Int(l & r)),\n-                    BinOpKind::Eq => Some(Constant::Bool(l == r)),\n-                    BinOpKind::Ne => Some(Constant::Bool(l != r)),\n-                    BinOpKind::Lt => Some(Constant::Bool(l < r)),\n-                    BinOpKind::Le => Some(Constant::Bool(l <= r)),\n-                    BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n-                    BinOpKind::Gt => Some(Constant::Bool(l > r)),\n-                    _ => None,\n-                },\n-                _ => None,\n-            },\n-            (Constant::F32(l), Some(Constant::F32(r))) => match op.node {\n-                BinOpKind::Add => Some(Constant::F32(l + r)),\n-                BinOpKind::Sub => Some(Constant::F32(l - r)),\n-                BinOpKind::Mul => Some(Constant::F32(l * r)),\n-                BinOpKind::Div => Some(Constant::F32(l / r)),\n-                BinOpKind::Rem => Some(Constant::F32(l % r)),\n-                BinOpKind::Eq => Some(Constant::Bool(l == r)),\n-                BinOpKind::Ne => Some(Constant::Bool(l != r)),\n-                BinOpKind::Lt => Some(Constant::Bool(l < r)),\n-                BinOpKind::Le => Some(Constant::Bool(l <= r)),\n-                BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n-                BinOpKind::Gt => Some(Constant::Bool(l > r)),\n-                _ => None,\n-            },\n-            (Constant::F64(l), Some(Constant::F64(r))) => match op.node {\n-                BinOpKind::Add => Some(Constant::F64(l + r)),\n-                BinOpKind::Sub => Some(Constant::F64(l - r)),\n-                BinOpKind::Mul => Some(Constant::F64(l * r)),\n-                BinOpKind::Div => Some(Constant::F64(l / r)),\n-                BinOpKind::Rem => Some(Constant::F64(l % r)),\n-                BinOpKind::Eq => Some(Constant::Bool(l == r)),\n-                BinOpKind::Ne => Some(Constant::Bool(l != r)),\n-                BinOpKind::Lt => Some(Constant::Bool(l < r)),\n-                BinOpKind::Le => Some(Constant::Bool(l <= r)),\n-                BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n-                BinOpKind::Gt => Some(Constant::Bool(l > r)),\n-                _ => None,\n-            },\n-            (l, r) => match (op.node, l, r) {\n-                (BinOpKind::And, Constant::Bool(false), _) => Some(Constant::Bool(false)),\n-                (BinOpKind::Or, Constant::Bool(true), _) => Some(Constant::Bool(true)),\n-                (BinOpKind::And, Constant::Bool(true), Some(r)) | (BinOpKind::Or, Constant::Bool(false), Some(r)) => {\n-                    Some(r)\n-                },\n-                (BinOpKind::BitXor, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l ^ r)),\n-                (BinOpKind::BitAnd, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l & r)),\n-                (BinOpKind::BitOr, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l | r)),\n-                _ => None,\n-            },\n-        }\n-    }\n-}\n-\n-pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n-    use rustc_middle::mir::interpret::ConstValue;\n-    match result.val {\n-        ty::ConstKind::Value(ConstValue::Scalar(Scalar::Int(int))) => {\n-            match result.ty.kind() {\n-                ty::Bool => Some(Constant::Bool(int == ScalarInt::TRUE)),\n-                ty::Uint(_) | ty::Int(_) => Some(Constant::Int(int.assert_bits(int.size()))),\n-                ty::Float(FloatTy::F32) => Some(Constant::F32(f32::from_bits(\n-                    int.try_into().expect(\"invalid f32 bit representation\"),\n-                ))),\n-                ty::Float(FloatTy::F64) => Some(Constant::F64(f64::from_bits(\n-                    int.try_into().expect(\"invalid f64 bit representation\"),\n-                ))),\n-                ty::RawPtr(type_and_mut) => {\n-                    if let ty::Uint(_) = type_and_mut.ty.kind() {\n-                        return Some(Constant::RawPtr(int.assert_bits(int.size())));\n-                    }\n-                    None\n-                },\n-                // FIXME: implement other conversions.\n-                _ => None,\n-            }\n-        },\n-        ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => match result.ty.kind() {\n-            ty::Ref(_, tam, _) => match tam.kind() {\n-                ty::Str => String::from_utf8(\n-                    data.inspect_with_uninit_and_ptr_outside_interpreter(start..end)\n-                        .to_owned(),\n-                )\n-                .ok()\n-                .map(Constant::Str),\n-                _ => None,\n-            },\n-            _ => None,\n-        },\n-        ty::ConstKind::Value(ConstValue::ByRef { alloc, offset: _ }) => match result.ty.kind() {\n-            ty::Array(sub_type, len) => match sub_type.kind() {\n-                ty::Float(FloatTy::F32) => match miri_to_const(len) {\n-                    Some(Constant::Int(len)) => alloc\n-                        .inspect_with_uninit_and_ptr_outside_interpreter(0..(4 * len as usize))\n-                        .to_owned()\n-                        .chunks(4)\n-                        .map(|chunk| {\n-                            Some(Constant::F32(f32::from_le_bytes(\n-                                chunk.try_into().expect(\"this shouldn't happen\"),\n-                            )))\n-                        })\n-                        .collect::<Option<Vec<Constant>>>()\n-                        .map(Constant::Vec),\n-                    _ => None,\n-                },\n-                ty::Float(FloatTy::F64) => match miri_to_const(len) {\n-                    Some(Constant::Int(len)) => alloc\n-                        .inspect_with_uninit_and_ptr_outside_interpreter(0..(8 * len as usize))\n-                        .to_owned()\n-                        .chunks(8)\n-                        .map(|chunk| {\n-                            Some(Constant::F64(f64::from_le_bytes(\n-                                chunk.try_into().expect(\"this shouldn't happen\"),\n-                            )))\n-                        })\n-                        .collect::<Option<Vec<Constant>>>()\n-                        .map(Constant::Vec),\n-                    _ => None,\n-                },\n-                // FIXME: implement other array type conversions.\n-                _ => None,\n-            },\n-            _ => None,\n-        },\n-        // FIXME: implement other conversions.\n-        _ => None,\n-    }\n-}\n+pub use clippy_utils::consts::*;"}, {"sha": "c8502e9cc74e7caa309bce96c7f487ed24650bf6", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "patch": "@@ -1,13 +1,9 @@\n // error-pattern:cargo-clippy\n \n-#![feature(bindings_after_at)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(concat_idents)]\n-#![feature(crate_visibility_modifier)]\n #![feature(drain_filter)]\n #![feature(in_band_lifetimes)]\n-#![feature(once_cell)]\n #![feature(or_patterns)]\n #![feature(rustc_private)]\n #![feature(stmt_expr_attributes)]\n@@ -149,6 +145,20 @@ macro_rules! declare_clippy_lint {\n     };\n }\n \n+#[macro_export]\n+macro_rules! sym {\n+    ( $($x:tt)* ) => { clippy_utils::sym!($($x)*) }\n+}\n+\n+#[macro_export]\n+macro_rules! unwrap_cargo_metadata {\n+    ( $($x:tt)* ) => { clippy_utils::unwrap_cargo_metadata!($($x)*) }\n+}\n+\n+macro_rules! extract_msrv_attr {\n+    ( $($x:tt)* ) => { clippy_utils::extract_msrv_attr!($($x)*); }\n+}\n+\n mod consts;\n #[macro_use]\n mod utils;"}, {"sha": "68ab8161e20e6b61d161a475b6a513c43f51920c", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1857, "changes": 1858, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "patch": "@@ -1,1862 +1,6 @@\n-#[macro_use]\n-pub mod sym_helper;\n-\n-#[allow(clippy::module_name_repetitions)]\n-pub mod ast_utils;\n-pub mod attrs;\n pub mod author;\n-pub mod camel_case;\n-pub mod comparisons;\n-pub mod conf;\n-mod diagnostics;\n-pub mod eager_or_lazy;\n-pub mod higher;\n-mod hir_utils;\n pub mod inspector;\n #[cfg(feature = \"internal-lints\")]\n pub mod internal_lints;\n-pub mod numeric_literal;\n-pub mod paths;\n-pub mod ptr;\n-pub mod qualify_min_const_fn;\n-pub mod sugg;\n-pub mod usage;\n-pub mod visitors;\n-\n-pub use self::attrs::*;\n-pub use self::diagnostics::*;\n-pub use self::hir_utils::{both, eq_expr_value, over, SpanlessEq, SpanlessHash};\n-\n-use std::borrow::Cow;\n-use std::collections::hash_map::Entry;\n-use std::hash::BuildHasherDefault;\n-\n-use if_chain::if_chain;\n-use rustc_ast::ast::{self, Attribute, BorrowKind, LitKind, Mutability};\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::Applicability;\n-use rustc_hir as hir;\n-use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use rustc_hir::Node;\n-use rustc_hir::{\n-    def, Arm, Block, Body, Constness, Crate, Expr, ExprKind, FnDecl, HirId, ImplItem, ImplItemKind, Item, ItemKind,\n-    MatchSource, Param, Pat, PatKind, Path, PathSegment, QPath, TraitItem, TraitItemKind, TraitRef, TyKind, Unsafety,\n-};\n-use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_lint::{LateContext, Level, Lint, LintContext};\n-use rustc_middle::hir::exports::Export;\n-use rustc_middle::hir::map::Map;\n-use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, layout::IntegerExt, DefIdTree, Ty, TyCtxt, TypeFoldable};\n-use rustc_semver::RustcVersion;\n-use rustc_session::Session;\n-use rustc_span::hygiene::{ExpnKind, MacroKind};\n-use rustc_span::source_map::original_sp;\n-use rustc_span::sym;\n-use rustc_span::symbol::{kw, Symbol};\n-use rustc_span::{BytePos, Pos, Span, DUMMY_SP};\n-use rustc_target::abi::Integer;\n-use rustc_trait_selection::traits::query::normalize::AtExt;\n-use smallvec::SmallVec;\n-\n-use crate::consts::{constant, Constant};\n-\n-pub fn parse_msrv(msrv: &str, sess: Option<&Session>, span: Option<Span>) -> Option<RustcVersion> {\n-    if let Ok(version) = RustcVersion::parse(msrv) {\n-        return Some(version);\n-    } else if let Some(sess) = sess {\n-        if let Some(span) = span {\n-            sess.span_err(span, &format!(\"`{}` is not a valid Rust version\", msrv));\n-        }\n-    }\n-    None\n-}\n-\n-pub fn meets_msrv(msrv: Option<&RustcVersion>, lint_msrv: &RustcVersion) -> bool {\n-    msrv.map_or(true, |msrv| msrv.meets(*lint_msrv))\n-}\n-\n-macro_rules! extract_msrv_attr {\n-    (LateContext) => {\n-        extract_msrv_attr!(@LateContext, ());\n-    };\n-    (EarlyContext) => {\n-        extract_msrv_attr!(@EarlyContext);\n-    };\n-    (@$context:ident$(, $call:tt)?) => {\n-        fn enter_lint_attrs(&mut self, cx: &rustc_lint::$context<'tcx>, attrs: &'tcx [rustc_ast::ast::Attribute]) {\n-            use $crate::utils::get_unique_inner_attr;\n-            match get_unique_inner_attr(cx.sess$($call)?, attrs, \"msrv\") {\n-                Some(msrv_attr) => {\n-                    if let Some(msrv) = msrv_attr.value_str() {\n-                        self.msrv = $crate::utils::parse_msrv(\n-                            &msrv.to_string(),\n-                            Some(cx.sess$($call)?),\n-                            Some(msrv_attr.span),\n-                        );\n-                    } else {\n-                        cx.sess$($call)?.span_err(msrv_attr.span, \"bad clippy attribute\");\n-                    }\n-                },\n-                _ => (),\n-            }\n-        }\n-    };\n-}\n-\n-/// Returns `true` if the two spans come from differing expansions (i.e., one is\n-/// from a macro and one isn't).\n-#[must_use]\n-pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n-    rhs.ctxt() != lhs.ctxt()\n-}\n-\n-/// Returns `true` if the given `NodeId` is inside a constant context\n-///\n-/// # Example\n-///\n-/// ```rust,ignore\n-/// if in_constant(cx, expr.hir_id) {\n-///     // Do something\n-/// }\n-/// ```\n-pub fn in_constant(cx: &LateContext<'_>, id: HirId) -> bool {\n-    let parent_id = cx.tcx.hir().get_parent_item(id);\n-    match cx.tcx.hir().get(parent_id) {\n-        Node::Item(&Item {\n-            kind: ItemKind::Const(..) | ItemKind::Static(..),\n-            ..\n-        })\n-        | Node::TraitItem(&TraitItem {\n-            kind: TraitItemKind::Const(..),\n-            ..\n-        })\n-        | Node::ImplItem(&ImplItem {\n-            kind: ImplItemKind::Const(..),\n-            ..\n-        })\n-        | Node::AnonConst(_) => true,\n-        Node::Item(&Item {\n-            kind: ItemKind::Fn(ref sig, ..),\n-            ..\n-        })\n-        | Node::ImplItem(&ImplItem {\n-            kind: ImplItemKind::Fn(ref sig, _),\n-            ..\n-        }) => sig.header.constness == Constness::Const,\n-        _ => false,\n-    }\n-}\n-\n-/// Returns `true` if this `span` was expanded by any macro.\n-#[must_use]\n-pub fn in_macro(span: Span) -> bool {\n-    if span.from_expansion() {\n-        !matches!(span.ctxt().outer_expn_data().kind, ExpnKind::Desugaring(..))\n-    } else {\n-        false\n-    }\n-}\n-\n-// If the snippet is empty, it's an attribute that was inserted during macro\n-// expansion and we want to ignore those, because they could come from external\n-// sources that the user has no control over.\n-// For some reason these attributes don't have any expansion info on them, so\n-// we have to check it this way until there is a better way.\n-pub fn is_present_in_source<T: LintContext>(cx: &T, span: Span) -> bool {\n-    if let Some(snippet) = snippet_opt(cx, span) {\n-        if snippet.is_empty() {\n-            return false;\n-        }\n-    }\n-    true\n-}\n-\n-/// Checks if given pattern is a wildcard (`_`)\n-pub fn is_wild<'tcx>(pat: &impl std::ops::Deref<Target = Pat<'tcx>>) -> bool {\n-    matches!(pat.kind, PatKind::Wild)\n-}\n-\n-/// Checks if type is struct, enum or union type with the given def path.\n-///\n-/// If the type is a diagnostic item, use `is_type_diagnostic_item` instead.\n-/// If you change the signature, remember to update the internal lint `MatchTypeOnDiagItem`\n-pub fn match_type(cx: &LateContext<'_>, ty: Ty<'_>, path: &[&str]) -> bool {\n-    match ty.kind() {\n-        ty::Adt(adt, _) => match_def_path(cx, adt.did, path),\n-        _ => false,\n-    }\n-}\n-\n-/// Checks if the type is equal to a diagnostic item\n-///\n-/// If you change the signature, remember to update the internal lint `MatchTypeOnDiagItem`\n-pub fn is_type_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_item: Symbol) -> bool {\n-    match ty.kind() {\n-        ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(diag_item, adt.did),\n-        _ => false,\n-    }\n-}\n-\n-/// Checks if the type is equal to a lang item\n-pub fn is_type_lang_item(cx: &LateContext<'_>, ty: Ty<'_>, lang_item: hir::LangItem) -> bool {\n-    match ty.kind() {\n-        ty::Adt(adt, _) => cx.tcx.lang_items().require(lang_item).unwrap() == adt.did,\n-        _ => false,\n-    }\n-}\n-\n-/// Checks if the method call given in `expr` belongs to the given trait.\n-pub fn match_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, path: &[&str]) -> bool {\n-    let def_id = cx.typeck_results().type_dependent_def_id(expr.hir_id).unwrap();\n-    let trt_id = cx.tcx.trait_of_item(def_id);\n-    trt_id.map_or(false, |trt_id| match_def_path(cx, trt_id, path))\n-}\n-\n-/// Checks if an expression references a variable of the given name.\n-pub fn match_var(expr: &Expr<'_>, var: Symbol) -> bool {\n-    if let ExprKind::Path(QPath::Resolved(None, ref path)) = expr.kind {\n-        if let [p] = path.segments {\n-            return p.ident.name == var;\n-        }\n-    }\n-    false\n-}\n-\n-pub fn last_path_segment<'tcx>(path: &QPath<'tcx>) -> &'tcx PathSegment<'tcx> {\n-    match *path {\n-        QPath::Resolved(_, ref path) => path.segments.last().expect(\"A path must have at least one segment\"),\n-        QPath::TypeRelative(_, ref seg) => seg,\n-        QPath::LangItem(..) => panic!(\"last_path_segment: lang item has no path segments\"),\n-    }\n-}\n-\n-pub fn single_segment_path<'tcx>(path: &QPath<'tcx>) -> Option<&'tcx PathSegment<'tcx>> {\n-    match *path {\n-        QPath::Resolved(_, ref path) => path.segments.get(0),\n-        QPath::TypeRelative(_, ref seg) => Some(seg),\n-        QPath::LangItem(..) => None,\n-    }\n-}\n-\n-/// Matches a `QPath` against a slice of segment string literals.\n-///\n-/// There is also `match_path` if you are dealing with a `rustc_hir::Path` instead of a\n-/// `rustc_hir::QPath`.\n-///\n-/// # Examples\n-/// ```rust,ignore\n-/// match_qpath(path, &[\"std\", \"rt\", \"begin_unwind\"])\n-/// ```\n-pub fn match_qpath(path: &QPath<'_>, segments: &[&str]) -> bool {\n-    match *path {\n-        QPath::Resolved(_, ref path) => match_path(path, segments),\n-        QPath::TypeRelative(ref ty, ref segment) => match ty.kind {\n-            TyKind::Path(ref inner_path) => {\n-                if let [prefix @ .., end] = segments {\n-                    if match_qpath(inner_path, prefix) {\n-                        return segment.ident.name.as_str() == *end;\n-                    }\n-                }\n-                false\n-            },\n-            _ => false,\n-        },\n-        QPath::LangItem(..) => false,\n-    }\n-}\n-\n-/// Matches a `Path` against a slice of segment string literals.\n-///\n-/// There is also `match_qpath` if you are dealing with a `rustc_hir::QPath` instead of a\n-/// `rustc_hir::Path`.\n-///\n-/// # Examples\n-///\n-/// ```rust,ignore\n-/// if match_path(&trait_ref.path, &paths::HASH) {\n-///     // This is the `std::hash::Hash` trait.\n-/// }\n-///\n-/// if match_path(ty_path, &[\"rustc\", \"lint\", \"Lint\"]) {\n-///     // This is a `rustc_middle::lint::Lint`.\n-/// }\n-/// ```\n-pub fn match_path(path: &Path<'_>, segments: &[&str]) -> bool {\n-    path.segments\n-        .iter()\n-        .rev()\n-        .zip(segments.iter().rev())\n-        .all(|(a, b)| a.ident.name.as_str() == *b)\n-}\n-\n-/// Matches a `Path` against a slice of segment string literals, e.g.\n-///\n-/// # Examples\n-/// ```rust,ignore\n-/// match_path_ast(path, &[\"std\", \"rt\", \"begin_unwind\"])\n-/// ```\n-pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n-    path.segments\n-        .iter()\n-        .rev()\n-        .zip(segments.iter().rev())\n-        .all(|(a, b)| a.ident.name.as_str() == *b)\n-}\n-\n-/// If the expression is a path to a local, returns the canonical `HirId` of the local.\n-pub fn path_to_local(expr: &Expr<'_>) -> Option<HirId> {\n-    if let ExprKind::Path(QPath::Resolved(None, ref path)) = expr.kind {\n-        if let Res::Local(id) = path.res {\n-            return Some(id);\n-        }\n-    }\n-    None\n-}\n-\n-/// Returns true if the expression is a path to a local with the specified `HirId`.\n-/// Use this function to see if an expression matches a function argument or a match binding.\n-pub fn path_to_local_id(expr: &Expr<'_>, id: HirId) -> bool {\n-    path_to_local(expr) == Some(id)\n-}\n-\n-/// Gets the definition associated to a path.\n-#[allow(clippy::shadow_unrelated)] // false positive #6563\n-pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n-    macro_rules! try_res {\n-        ($e:expr) => {\n-            match $e {\n-                Some(e) => e,\n-                None => return Res::Err,\n-            }\n-        };\n-    }\n-    fn item_child_by_name<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, name: &str) -> Option<&'tcx Export<HirId>> {\n-        tcx.item_children(def_id)\n-            .iter()\n-            .find(|item| item.ident.name.as_str() == name)\n-    }\n-\n-    let (krate, first, path) = match *path {\n-        [krate, first, ref path @ ..] => (krate, first, path),\n-        _ => return Res::Err,\n-    };\n-    let tcx = cx.tcx;\n-    let crates = tcx.crates();\n-    let krate = try_res!(crates.iter().find(|&&num| tcx.crate_name(num).as_str() == krate));\n-    let first = try_res!(item_child_by_name(tcx, krate.as_def_id(), first));\n-    let last = path\n-        .iter()\n-        .copied()\n-        // `get_def_path` seems to generate these empty segments for extern blocks.\n-        // We can just ignore them.\n-        .filter(|segment| !segment.is_empty())\n-        // for each segment, find the child item\n-        .try_fold(first, |item, segment| {\n-            let def_id = item.res.def_id();\n-            if let Some(item) = item_child_by_name(tcx, def_id, segment) {\n-                Some(item)\n-            } else if matches!(item.res, Res::Def(DefKind::Enum | DefKind::Struct, _)) {\n-                // it is not a child item so check inherent impl items\n-                tcx.inherent_impls(def_id)\n-                    .iter()\n-                    .find_map(|&impl_def_id| item_child_by_name(tcx, impl_def_id, segment))\n-            } else {\n-                None\n-            }\n-        });\n-    try_res!(last).res\n-}\n-\n-/// Convenience function to get the `DefId` of a trait by path.\n-/// It could be a trait or trait alias.\n-pub fn get_trait_def_id(cx: &LateContext<'_>, path: &[&str]) -> Option<DefId> {\n-    match path_to_res(cx, path) {\n-        Res::Def(DefKind::Trait | DefKind::TraitAlias, trait_id) => Some(trait_id),\n-        _ => None,\n-    }\n-}\n-\n-/// Checks whether a type implements a trait.\n-/// See also `get_trait_def_id`.\n-pub fn implements_trait<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    ty: Ty<'tcx>,\n-    trait_id: DefId,\n-    ty_params: &[GenericArg<'tcx>],\n-) -> bool {\n-    // Do not check on infer_types to avoid panic in evaluate_obligation.\n-    if ty.has_infer_types() {\n-        return false;\n-    }\n-    let ty = cx.tcx.erase_regions(ty);\n-    if ty.has_escaping_bound_vars() {\n-        return false;\n-    }\n-    let ty_params = cx.tcx.mk_substs(ty_params.iter());\n-    cx.tcx.type_implements_trait((trait_id, ty, ty_params, cx.param_env))\n-}\n-\n-/// Gets the `hir::TraitRef` of the trait the given method is implemented for.\n-///\n-/// Use this if you want to find the `TraitRef` of the `Add` trait in this example:\n-///\n-/// ```rust\n-/// struct Point(isize, isize);\n-///\n-/// impl std::ops::Add for Point {\n-///     type Output = Self;\n-///\n-///     fn add(self, other: Self) -> Self {\n-///         Point(0, 0)\n-///     }\n-/// }\n-/// ```\n-pub fn trait_ref_of_method<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Option<&'tcx TraitRef<'tcx>> {\n-    // Get the implemented trait for the current function\n-    let parent_impl = cx.tcx.hir().get_parent_item(hir_id);\n-    if_chain! {\n-        if parent_impl != hir::CRATE_HIR_ID;\n-        if let hir::Node::Item(item) = cx.tcx.hir().get(parent_impl);\n-        if let hir::ItemKind::Impl(impl_) = &item.kind;\n-        then { return impl_.of_trait.as_ref(); }\n-    }\n-    None\n-}\n-\n-/// Checks whether this type implements `Drop`.\n-pub fn has_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.ty_adt_def() {\n-        Some(def) => def.has_dtor(cx.tcx),\n-        None => false,\n-    }\n-}\n-\n-/// Returns the method names and argument list of nested method call expressions that make up\n-/// `expr`. method/span lists are sorted with the most recent call first.\n-pub fn method_calls<'tcx>(\n-    expr: &'tcx Expr<'tcx>,\n-    max_depth: usize,\n-) -> (Vec<Symbol>, Vec<&'tcx [Expr<'tcx>]>, Vec<Span>) {\n-    let mut method_names = Vec::with_capacity(max_depth);\n-    let mut arg_lists = Vec::with_capacity(max_depth);\n-    let mut spans = Vec::with_capacity(max_depth);\n-\n-    let mut current = expr;\n-    for _ in 0..max_depth {\n-        if let ExprKind::MethodCall(path, span, args, _) = &current.kind {\n-            if args.iter().any(|e| e.span.from_expansion()) {\n-                break;\n-            }\n-            method_names.push(path.ident.name);\n-            arg_lists.push(&**args);\n-            spans.push(*span);\n-            current = &args[0];\n-        } else {\n-            break;\n-        }\n-    }\n-\n-    (method_names, arg_lists, spans)\n-}\n-\n-/// Matches an `Expr` against a chain of methods, and return the matched `Expr`s.\n-///\n-/// For example, if `expr` represents the `.baz()` in `foo.bar().baz()`,\n-/// `method_chain_args(expr, &[\"bar\", \"baz\"])` will return a `Vec`\n-/// containing the `Expr`s for\n-/// `.bar()` and `.baz()`\n-pub fn method_chain_args<'a>(expr: &'a Expr<'_>, methods: &[&str]) -> Option<Vec<&'a [Expr<'a>]>> {\n-    let mut current = expr;\n-    let mut matched = Vec::with_capacity(methods.len());\n-    for method_name in methods.iter().rev() {\n-        // method chains are stored last -> first\n-        if let ExprKind::MethodCall(ref path, _, ref args, _) = current.kind {\n-            if path.ident.name.as_str() == *method_name {\n-                if args.iter().any(|e| e.span.from_expansion()) {\n-                    return None;\n-                }\n-                matched.push(&**args); // build up `matched` backwards\n-                current = &args[0] // go to parent expression\n-            } else {\n-                return None;\n-            }\n-        } else {\n-            return None;\n-        }\n-    }\n-    // Reverse `matched` so that it is in the same order as `methods`.\n-    matched.reverse();\n-    Some(matched)\n-}\n-\n-/// Returns `true` if the provided `def_id` is an entrypoint to a program.\n-pub fn is_entrypoint_fn(cx: &LateContext<'_>, def_id: DefId) -> bool {\n-    cx.tcx\n-        .entry_fn(LOCAL_CRATE)\n-        .map_or(false, |(entry_fn_def_id, _)| def_id == entry_fn_def_id.to_def_id())\n-}\n-\n-/// Returns `true` if the expression is in the program's `#[panic_handler]`.\n-pub fn is_in_panic_handler(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n-    let parent = cx.tcx.hir().get_parent_item(e.hir_id);\n-    let def_id = cx.tcx.hir().local_def_id(parent).to_def_id();\n-    Some(def_id) == cx.tcx.lang_items().panic_impl()\n-}\n-\n-/// Gets the name of the item the expression is in, if available.\n-pub fn get_item_name(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<Symbol> {\n-    let parent_id = cx.tcx.hir().get_parent_item(expr.hir_id);\n-    match cx.tcx.hir().find(parent_id) {\n-        Some(\n-            Node::Item(Item { ident, .. })\n-            | Node::TraitItem(TraitItem { ident, .. })\n-            | Node::ImplItem(ImplItem { ident, .. }),\n-        ) => Some(ident.name),\n-        _ => None,\n-    }\n-}\n-\n-/// Gets the name of a `Pat`, if any.\n-pub fn get_pat_name(pat: &Pat<'_>) -> Option<Symbol> {\n-    match pat.kind {\n-        PatKind::Binding(.., ref spname, _) => Some(spname.name),\n-        PatKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.ident.name),\n-        PatKind::Box(ref p) | PatKind::Ref(ref p, _) => get_pat_name(&*p),\n-        _ => None,\n-    }\n-}\n-\n-struct ContainsName {\n-    name: Symbol,\n-    result: bool,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for ContainsName {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_name(&mut self, _: Span, name: Symbol) {\n-        if self.name == name {\n-            self.result = true;\n-        }\n-    }\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n-/// Checks if an `Expr` contains a certain name.\n-pub fn contains_name(name: Symbol, expr: &Expr<'_>) -> bool {\n-    let mut cn = ContainsName { name, result: false };\n-    cn.visit_expr(expr);\n-    cn.result\n-}\n-\n-/// Returns `true` if `expr` contains a return expression\n-pub fn contains_return(expr: &hir::Expr<'_>) -> bool {\n-    struct RetCallFinder {\n-        found: bool,\n-    }\n-\n-    impl<'tcx> hir::intravisit::Visitor<'tcx> for RetCallFinder {\n-        type Map = Map<'tcx>;\n-\n-        fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-            if self.found {\n-                return;\n-            }\n-            if let hir::ExprKind::Ret(..) = &expr.kind {\n-                self.found = true;\n-            } else {\n-                hir::intravisit::walk_expr(self, expr);\n-            }\n-        }\n-\n-        fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<Self::Map> {\n-            hir::intravisit::NestedVisitorMap::None\n-        }\n-    }\n-\n-    let mut visitor = RetCallFinder { found: false };\n-    visitor.visit_expr(expr);\n-    visitor.found\n-}\n-\n-struct FindMacroCalls<'a, 'b> {\n-    names: &'a [&'b str],\n-    result: Vec<Span>,\n-}\n-\n-impl<'a, 'b, 'tcx> Visitor<'tcx> for FindMacroCalls<'a, 'b> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if self.names.iter().any(|fun| is_expn_of(expr.span, fun).is_some()) {\n-            self.result.push(expr.span);\n-        }\n-        // and check sub-expressions\n-        intravisit::walk_expr(self, expr);\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n-/// Finds calls of the specified macros in a function body.\n-pub fn find_macro_calls(names: &[&str], body: &Body<'_>) -> Vec<Span> {\n-    let mut fmc = FindMacroCalls {\n-        names,\n-        result: Vec::new(),\n-    };\n-    fmc.visit_expr(&body.value);\n-    fmc.result\n-}\n-\n-/// Converts a span to a code snippet if available, otherwise use default.\n-///\n-/// This is useful if you want to provide suggestions for your lint or more generally, if you want\n-/// to convert a given `Span` to a `str`.\n-///\n-/// # Example\n-/// ```rust,ignore\n-/// snippet(cx, expr.span, \"..\")\n-/// ```\n-pub fn snippet<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n-    snippet_opt(cx, span).map_or_else(|| Cow::Borrowed(default), From::from)\n-}\n-\n-/// Same as `snippet`, but it adapts the applicability level by following rules:\n-///\n-/// - Applicability level `Unspecified` will never be changed.\n-/// - If the span is inside a macro, change the applicability level to `MaybeIncorrect`.\n-/// - If the default value is used and the applicability level is `MachineApplicable`, change it to\n-/// `HasPlaceholders`\n-pub fn snippet_with_applicability<'a, T: LintContext>(\n-    cx: &T,\n-    span: Span,\n-    default: &'a str,\n-    applicability: &mut Applicability,\n-) -> Cow<'a, str> {\n-    if *applicability != Applicability::Unspecified && span.from_expansion() {\n-        *applicability = Applicability::MaybeIncorrect;\n-    }\n-    snippet_opt(cx, span).map_or_else(\n-        || {\n-            if *applicability == Applicability::MachineApplicable {\n-                *applicability = Applicability::HasPlaceholders;\n-            }\n-            Cow::Borrowed(default)\n-        },\n-        From::from,\n-    )\n-}\n-\n-/// Same as `snippet`, but should only be used when it's clear that the input span is\n-/// not a macro argument.\n-pub fn snippet_with_macro_callsite<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n-    snippet(cx, span.source_callsite(), default)\n-}\n-\n-/// Converts a span to a code snippet. Returns `None` if not available.\n-pub fn snippet_opt<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n-    cx.sess().source_map().span_to_snippet(span).ok()\n-}\n-\n-/// Converts a span (from a block) to a code snippet if available, otherwise use default.\n-///\n-/// This trims the code of indentation, except for the first line. Use it for blocks or block-like\n-/// things which need to be printed as such.\n-///\n-/// The `indent_relative_to` arg can be used, to provide a span, where the indentation of the\n-/// resulting snippet of the given span.\n-///\n-/// # Example\n-///\n-/// ```rust,ignore\n-/// snippet_block(cx, block.span, \"..\", None)\n-/// // where, `block` is the block of the if expr\n-///     if x {\n-///         y;\n-///     }\n-/// // will return the snippet\n-/// {\n-///     y;\n-/// }\n-/// ```\n-///\n-/// ```rust,ignore\n-/// snippet_block(cx, block.span, \"..\", Some(if_expr.span))\n-/// // where, `block` is the block of the if expr\n-///     if x {\n-///         y;\n-///     }\n-/// // will return the snippet\n-/// {\n-///         y;\n-///     } // aligned with `if`\n-/// ```\n-/// Note that the first line of the snippet always has 0 indentation.\n-pub fn snippet_block<'a, T: LintContext>(\n-    cx: &T,\n-    span: Span,\n-    default: &'a str,\n-    indent_relative_to: Option<Span>,\n-) -> Cow<'a, str> {\n-    let snip = snippet(cx, span, default);\n-    let indent = indent_relative_to.and_then(|s| indent_of(cx, s));\n-    reindent_multiline(snip, true, indent)\n-}\n-\n-/// Same as `snippet_block`, but adapts the applicability level by the rules of\n-/// `snippet_with_applicability`.\n-pub fn snippet_block_with_applicability<'a, T: LintContext>(\n-    cx: &T,\n-    span: Span,\n-    default: &'a str,\n-    indent_relative_to: Option<Span>,\n-    applicability: &mut Applicability,\n-) -> Cow<'a, str> {\n-    let snip = snippet_with_applicability(cx, span, default, applicability);\n-    let indent = indent_relative_to.and_then(|s| indent_of(cx, s));\n-    reindent_multiline(snip, true, indent)\n-}\n-\n-/// Returns a new Span that extends the original Span to the first non-whitespace char of the first\n-/// line.\n-///\n-/// ```rust,ignore\n-///     let x = ();\n-/// //          ^^\n-/// // will be converted to\n-///     let x = ();\n-/// //  ^^^^^^^^^^\n-/// ```\n-pub fn first_line_of_span<T: LintContext>(cx: &T, span: Span) -> Span {\n-    first_char_in_first_line(cx, span).map_or(span, |first_char_pos| span.with_lo(first_char_pos))\n-}\n-\n-fn first_char_in_first_line<T: LintContext>(cx: &T, span: Span) -> Option<BytePos> {\n-    let line_span = line_span(cx, span);\n-    snippet_opt(cx, line_span).and_then(|snip| {\n-        snip.find(|c: char| !c.is_whitespace())\n-            .map(|pos| line_span.lo() + BytePos::from_usize(pos))\n-    })\n-}\n-\n-/// Returns the indentation of the line of a span\n-///\n-/// ```rust,ignore\n-/// let x = ();\n-/// //      ^^ -- will return 0\n-///     let x = ();\n-/// //          ^^ -- will return 4\n-/// ```\n-pub fn indent_of<T: LintContext>(cx: &T, span: Span) -> Option<usize> {\n-    snippet_opt(cx, line_span(cx, span)).and_then(|snip| snip.find(|c: char| !c.is_whitespace()))\n-}\n-\n-/// Returns the positon just before rarrow\n-///\n-/// ```rust,ignore\n-/// fn into(self) -> () {}\n-///              ^\n-/// // in case of unformatted code\n-/// fn into2(self)-> () {}\n-///               ^\n-/// fn into3(self)   -> () {}\n-///               ^\n-/// ```\n-pub fn position_before_rarrow(s: &str) -> Option<usize> {\n-    s.rfind(\"->\").map(|rpos| {\n-        let mut rpos = rpos;\n-        let chars: Vec<char> = s.chars().collect();\n-        while rpos > 1 {\n-            if let Some(c) = chars.get(rpos - 1) {\n-                if c.is_whitespace() {\n-                    rpos -= 1;\n-                    continue;\n-                }\n-            }\n-            break;\n-        }\n-        rpos\n-    })\n-}\n-\n-/// Extends the span to the beginning of the spans line, incl. whitespaces.\n-///\n-/// ```rust,ignore\n-///        let x = ();\n-/// //             ^^\n-/// // will be converted to\n-///        let x = ();\n-/// // ^^^^^^^^^^^^^^\n-/// ```\n-fn line_span<T: LintContext>(cx: &T, span: Span) -> Span {\n-    let span = original_sp(span, DUMMY_SP);\n-    let source_map_and_line = cx.sess().source_map().lookup_line(span.lo()).unwrap();\n-    let line_no = source_map_and_line.line;\n-    let line_start = source_map_and_line.sf.lines[line_no];\n-    Span::new(line_start, span.hi(), span.ctxt())\n-}\n-\n-/// Like `snippet_block`, but add braces if the expr is not an `ExprKind::Block`.\n-/// Also takes an `Option<String>` which can be put inside the braces.\n-pub fn expr_block<'a, T: LintContext>(\n-    cx: &T,\n-    expr: &Expr<'_>,\n-    option: Option<String>,\n-    default: &'a str,\n-    indent_relative_to: Option<Span>,\n-) -> Cow<'a, str> {\n-    let code = snippet_block(cx, expr.span, default, indent_relative_to);\n-    let string = option.unwrap_or_default();\n-    if expr.span.from_expansion() {\n-        Cow::Owned(format!(\"{{ {} }}\", snippet_with_macro_callsite(cx, expr.span, default)))\n-    } else if let ExprKind::Block(_, _) = expr.kind {\n-        Cow::Owned(format!(\"{}{}\", code, string))\n-    } else if string.is_empty() {\n-        Cow::Owned(format!(\"{{ {} }}\", code))\n-    } else {\n-        Cow::Owned(format!(\"{{\\n{};\\n{}\\n}}\", code, string))\n-    }\n-}\n-\n-/// Reindent a multiline string with possibility of ignoring the first line.\n-#[allow(clippy::needless_pass_by_value)]\n-pub fn reindent_multiline(s: Cow<'_, str>, ignore_first: bool, indent: Option<usize>) -> Cow<'_, str> {\n-    let s_space = reindent_multiline_inner(&s, ignore_first, indent, ' ');\n-    let s_tab = reindent_multiline_inner(&s_space, ignore_first, indent, '\\t');\n-    reindent_multiline_inner(&s_tab, ignore_first, indent, ' ').into()\n-}\n-\n-fn reindent_multiline_inner(s: &str, ignore_first: bool, indent: Option<usize>, ch: char) -> String {\n-    let x = s\n-        .lines()\n-        .skip(ignore_first as usize)\n-        .filter_map(|l| {\n-            if l.is_empty() {\n-                None\n-            } else {\n-                // ignore empty lines\n-                Some(l.char_indices().find(|&(_, x)| x != ch).unwrap_or((l.len(), ch)).0)\n-            }\n-        })\n-        .min()\n-        .unwrap_or(0);\n-    let indent = indent.unwrap_or(0);\n-    s.lines()\n-        .enumerate()\n-        .map(|(i, l)| {\n-            if (ignore_first && i == 0) || l.is_empty() {\n-                l.to_owned()\n-            } else if x > indent {\n-                l.split_at(x - indent).1.to_owned()\n-            } else {\n-                \" \".repeat(indent - x) + l\n-            }\n-        })\n-        .collect::<Vec<String>>()\n-        .join(\"\\n\")\n-}\n-\n-/// Gets the parent expression, if any \u2013- this is useful to constrain a lint.\n-pub fn get_parent_expr<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n-    let map = &cx.tcx.hir();\n-    let hir_id = e.hir_id;\n-    let parent_id = map.get_parent_node(hir_id);\n-    if hir_id == parent_id {\n-        return None;\n-    }\n-    map.find(parent_id).and_then(|node| {\n-        if let Node::Expr(parent) = node {\n-            Some(parent)\n-        } else {\n-            None\n-        }\n-    })\n-}\n-\n-pub fn get_enclosing_block<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Option<&'tcx Block<'tcx>> {\n-    let map = &cx.tcx.hir();\n-    let enclosing_node = map\n-        .get_enclosing_scope(hir_id)\n-        .and_then(|enclosing_id| map.find(enclosing_id));\n-    enclosing_node.and_then(|node| match node {\n-        Node::Block(block) => Some(block),\n-        Node::Item(&Item {\n-            kind: ItemKind::Fn(_, _, eid),\n-            ..\n-        })\n-        | Node::ImplItem(&ImplItem {\n-            kind: ImplItemKind::Fn(_, eid),\n-            ..\n-        }) => match cx.tcx.hir().body(eid).value.kind {\n-            ExprKind::Block(ref block, _) => Some(block),\n-            _ => None,\n-        },\n-        _ => None,\n-    })\n-}\n-\n-/// Returns the base type for HIR references and pointers.\n-pub fn walk_ptrs_hir_ty<'tcx>(ty: &'tcx hir::Ty<'tcx>) -> &'tcx hir::Ty<'tcx> {\n-    match ty.kind {\n-        TyKind::Ptr(ref mut_ty) | TyKind::Rptr(_, ref mut_ty) => walk_ptrs_hir_ty(&mut_ty.ty),\n-        _ => ty,\n-    }\n-}\n-\n-/// Returns the base type for references and raw pointers, and count reference\n-/// depth.\n-pub fn walk_ptrs_ty_depth(ty: Ty<'_>) -> (Ty<'_>, usize) {\n-    fn inner(ty: Ty<'_>, depth: usize) -> (Ty<'_>, usize) {\n-        match ty.kind() {\n-            ty::Ref(_, ty, _) => inner(ty, depth + 1),\n-            _ => (ty, depth),\n-        }\n-    }\n-    inner(ty, 0)\n-}\n-\n-/// Checks whether the given expression is a constant integer of the given value.\n-/// unlike `is_integer_literal`, this version does const folding\n-pub fn is_integer_const(cx: &LateContext<'_>, e: &Expr<'_>, value: u128) -> bool {\n-    if is_integer_literal(e, value) {\n-        return true;\n-    }\n-    let map = cx.tcx.hir();\n-    let parent_item = map.get_parent_item(e.hir_id);\n-    if let Some((Constant::Int(v), _)) = map\n-        .maybe_body_owned_by(parent_item)\n-        .and_then(|body_id| constant(cx, cx.tcx.typeck_body(body_id), e))\n-    {\n-        value == v\n-    } else {\n-        false\n-    }\n-}\n-\n-/// Checks whether the given expression is a constant literal of the given value.\n-pub fn is_integer_literal(expr: &Expr<'_>, value: u128) -> bool {\n-    // FIXME: use constant folding\n-    if let ExprKind::Lit(ref spanned) = expr.kind {\n-        if let LitKind::Int(v, _) = spanned.node {\n-            return v == value;\n-        }\n-    }\n-    false\n-}\n-\n-/// Returns `true` if the given `Expr` has been coerced before.\n-///\n-/// Examples of coercions can be found in the Nomicon at\n-/// <https://doc.rust-lang.org/nomicon/coercions.html>.\n-///\n-/// See `rustc_middle::ty::adjustment::Adjustment` and `rustc_typeck::check::coercion` for more\n-/// information on adjustments and coercions.\n-pub fn is_adjusted(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n-    cx.typeck_results().adjustments().get(e.hir_id).is_some()\n-}\n-\n-/// Returns the pre-expansion span if is this comes from an expansion of the\n-/// macro `name`.\n-/// See also `is_direct_expn_of`.\n-#[must_use]\n-pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n-    loop {\n-        if span.from_expansion() {\n-            let data = span.ctxt().outer_expn_data();\n-            let new_span = data.call_site;\n-\n-            if let ExpnKind::Macro(MacroKind::Bang, mac_name) = data.kind {\n-                if mac_name.as_str() == name {\n-                    return Some(new_span);\n-                }\n-            }\n-\n-            span = new_span;\n-        } else {\n-            return None;\n-        }\n-    }\n-}\n-\n-/// Returns the pre-expansion span if the span directly comes from an expansion\n-/// of the macro `name`.\n-/// The difference with `is_expn_of` is that in\n-/// ```rust,ignore\n-/// foo!(bar!(42));\n-/// ```\n-/// `42` is considered expanded from `foo!` and `bar!` by `is_expn_of` but only\n-/// `bar!` by\n-/// `is_direct_expn_of`.\n-#[must_use]\n-pub fn is_direct_expn_of(span: Span, name: &str) -> Option<Span> {\n-    if span.from_expansion() {\n-        let data = span.ctxt().outer_expn_data();\n-        let new_span = data.call_site;\n-\n-        if let ExpnKind::Macro(MacroKind::Bang, mac_name) = data.kind {\n-            if mac_name.as_str() == name {\n-                return Some(new_span);\n-            }\n-        }\n-    }\n-\n-    None\n-}\n-\n-/// Convenience function to get the return type of a function.\n-pub fn return_ty<'tcx>(cx: &LateContext<'tcx>, fn_item: hir::HirId) -> Ty<'tcx> {\n-    let fn_def_id = cx.tcx.hir().local_def_id(fn_item);\n-    let ret_ty = cx.tcx.fn_sig(fn_def_id).output();\n-    cx.tcx.erase_late_bound_regions(ret_ty)\n-}\n-\n-/// Walks into `ty` and returns `true` if any inner type is the same as `other_ty`\n-pub fn contains_ty(ty: Ty<'_>, other_ty: Ty<'_>) -> bool {\n-    ty.walk().any(|inner| match inner.unpack() {\n-        GenericArgKind::Type(inner_ty) => ty::TyS::same_type(other_ty, inner_ty),\n-        GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => false,\n-    })\n-}\n-\n-/// Returns `true` if the given type is an `unsafe` function.\n-pub fn type_is_unsafe_function<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.kind() {\n-        ty::FnDef(..) | ty::FnPtr(_) => ty.fn_sig(cx.tcx).unsafety() == Unsafety::Unsafe,\n-        _ => false,\n-    }\n-}\n-\n-pub fn is_copy<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.is_copy_modulo_regions(cx.tcx.at(DUMMY_SP), cx.param_env)\n-}\n-\n-/// Checks if an expression is constructing a tuple-like enum variant or struct\n-pub fn is_ctor_or_promotable_const_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    if let ExprKind::Call(ref fun, _) = expr.kind {\n-        if let ExprKind::Path(ref qp) = fun.kind {\n-            let res = cx.qpath_res(qp, fun.hir_id);\n-            return match res {\n-                def::Res::Def(DefKind::Variant | DefKind::Ctor(..), ..) => true,\n-                def::Res::Def(_, def_id) => cx.tcx.is_promotable_const_fn(def_id),\n-                _ => false,\n-            };\n-        }\n-    }\n-    false\n-}\n-\n-/// Returns `true` if a pattern is refutable.\n-// TODO: should be implemented using rustc/mir_build/thir machinery\n-pub fn is_refutable(cx: &LateContext<'_>, pat: &Pat<'_>) -> bool {\n-    fn is_enum_variant(cx: &LateContext<'_>, qpath: &QPath<'_>, id: HirId) -> bool {\n-        matches!(\n-            cx.qpath_res(qpath, id),\n-            def::Res::Def(DefKind::Variant, ..) | Res::Def(DefKind::Ctor(def::CtorOf::Variant, _), _)\n-        )\n-    }\n-\n-    fn are_refutable<'a, I: Iterator<Item = &'a Pat<'a>>>(cx: &LateContext<'_>, mut i: I) -> bool {\n-        i.any(|pat| is_refutable(cx, pat))\n-    }\n-\n-    match pat.kind {\n-        PatKind::Wild => false,\n-        PatKind::Binding(_, _, _, pat) => pat.map_or(false, |pat| is_refutable(cx, pat)),\n-        PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => is_refutable(cx, pat),\n-        PatKind::Lit(..) | PatKind::Range(..) => true,\n-        PatKind::Path(ref qpath) => is_enum_variant(cx, qpath, pat.hir_id),\n-        PatKind::Or(ref pats) => {\n-            // TODO: should be the honest check, that pats is exhaustive set\n-            are_refutable(cx, pats.iter().map(|pat| &**pat))\n-        },\n-        PatKind::Tuple(ref pats, _) => are_refutable(cx, pats.iter().map(|pat| &**pat)),\n-        PatKind::Struct(ref qpath, ref fields, _) => {\n-            is_enum_variant(cx, qpath, pat.hir_id) || are_refutable(cx, fields.iter().map(|field| &*field.pat))\n-        },\n-        PatKind::TupleStruct(ref qpath, ref pats, _) => {\n-            is_enum_variant(cx, qpath, pat.hir_id) || are_refutable(cx, pats.iter().map(|pat| &**pat))\n-        },\n-        PatKind::Slice(ref head, ref middle, ref tail) => {\n-            match &cx.typeck_results().node_type(pat.hir_id).kind() {\n-                ty::Slice(..) => {\n-                    // [..] is the only irrefutable slice pattern.\n-                    !head.is_empty() || middle.is_none() || !tail.is_empty()\n-                },\n-                ty::Array(..) => are_refutable(cx, head.iter().chain(middle).chain(tail.iter()).map(|pat| &**pat)),\n-                _ => {\n-                    // unreachable!()\n-                    true\n-                },\n-            }\n-        },\n-    }\n-}\n-\n-/// Checks for the `#[automatically_derived]` attribute all `#[derive]`d\n-/// implementations have.\n-pub fn is_automatically_derived(attrs: &[ast::Attribute]) -> bool {\n-    attrs.iter().any(|attr| attr.has_name(sym::automatically_derived))\n-}\n-\n-/// Remove blocks around an expression.\n-///\n-/// Ie. `x`, `{ x }` and `{{{{ x }}}}` all give `x`. `{ x; y }` and `{}` return\n-/// themselves.\n-pub fn remove_blocks<'tcx>(mut expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n-    while let ExprKind::Block(ref block, ..) = expr.kind {\n-        match (block.stmts.is_empty(), block.expr.as_ref()) {\n-            (true, Some(e)) => expr = e,\n-            _ => break,\n-        }\n-    }\n-    expr\n-}\n-\n-pub fn is_self(slf: &Param<'_>) -> bool {\n-    if let PatKind::Binding(.., name, _) = slf.pat.kind {\n-        name.name == kw::SelfLower\n-    } else {\n-        false\n-    }\n-}\n-\n-pub fn is_self_ty(slf: &hir::Ty<'_>) -> bool {\n-    if_chain! {\n-        if let TyKind::Path(QPath::Resolved(None, ref path)) = slf.kind;\n-        if let Res::SelfTy(..) = path.res;\n-        then {\n-            return true\n-        }\n-    }\n-    false\n-}\n-\n-pub fn iter_input_pats<'tcx>(decl: &FnDecl<'_>, body: &'tcx Body<'_>) -> impl Iterator<Item = &'tcx Param<'tcx>> {\n-    (0..decl.inputs.len()).map(move |i| &body.params[i])\n-}\n-\n-/// Checks if a given expression is a match expression expanded from the `?`\n-/// operator or the `try` macro.\n-pub fn is_try<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n-    fn is_ok(arm: &Arm<'_>) -> bool {\n-        if_chain! {\n-            if let PatKind::TupleStruct(ref path, ref pat, None) = arm.pat.kind;\n-            if match_qpath(path, &paths::RESULT_OK[1..]);\n-            if let PatKind::Binding(_, hir_id, _, None) = pat[0].kind;\n-            if path_to_local_id(arm.body, hir_id);\n-            then {\n-                return true;\n-            }\n-        }\n-        false\n-    }\n-\n-    fn is_err(arm: &Arm<'_>) -> bool {\n-        if let PatKind::TupleStruct(ref path, _, _) = arm.pat.kind {\n-            match_qpath(path, &paths::RESULT_ERR[1..])\n-        } else {\n-            false\n-        }\n-    }\n-\n-    if let ExprKind::Match(_, ref arms, ref source) = expr.kind {\n-        // desugared from a `?` operator\n-        if let MatchSource::TryDesugar = *source {\n-            return Some(expr);\n-        }\n-\n-        if_chain! {\n-            if arms.len() == 2;\n-            if arms[0].guard.is_none();\n-            if arms[1].guard.is_none();\n-            if (is_ok(&arms[0]) && is_err(&arms[1])) ||\n-                (is_ok(&arms[1]) && is_err(&arms[0]));\n-            then {\n-                return Some(expr);\n-            }\n-        }\n-    }\n-\n-    None\n-}\n-\n-/// Returns `true` if the lint is allowed in the current context\n-///\n-/// Useful for skipping long running code when it's unnecessary\n-pub fn is_allowed(cx: &LateContext<'_>, lint: &'static Lint, id: HirId) -> bool {\n-    cx.tcx.lint_level_at_node(lint, id).0 == Level::Allow\n-}\n-\n-pub fn strip_pat_refs<'hir>(mut pat: &'hir Pat<'hir>) -> &'hir Pat<'hir> {\n-    while let PatKind::Ref(subpat, _) = pat.kind {\n-        pat = subpat;\n-    }\n-    pat\n-}\n-\n-pub fn int_bits(tcx: TyCtxt<'_>, ity: ty::IntTy) -> u64 {\n-    Integer::from_int_ty(&tcx, ity).size().bits()\n-}\n-\n-#[allow(clippy::cast_possible_wrap)]\n-/// Turn a constant int byte representation into an i128\n-pub fn sext(tcx: TyCtxt<'_>, u: u128, ity: ty::IntTy) -> i128 {\n-    let amt = 128 - int_bits(tcx, ity);\n-    ((u as i128) << amt) >> amt\n-}\n-\n-#[allow(clippy::cast_sign_loss)]\n-/// clip unused bytes\n-pub fn unsext(tcx: TyCtxt<'_>, u: i128, ity: ty::IntTy) -> u128 {\n-    let amt = 128 - int_bits(tcx, ity);\n-    ((u as u128) << amt) >> amt\n-}\n-\n-/// clip unused bytes\n-pub fn clip(tcx: TyCtxt<'_>, u: u128, ity: ty::UintTy) -> u128 {\n-    let bits = Integer::from_uint_ty(&tcx, ity).size().bits();\n-    let amt = 128 - bits;\n-    (u << amt) >> amt\n-}\n-\n-/// Removes block comments from the given `Vec` of lines.\n-///\n-/// # Examples\n-///\n-/// ```rust,ignore\n-/// without_block_comments(vec![\"/*\", \"foo\", \"*/\"]);\n-/// // => vec![]\n-///\n-/// without_block_comments(vec![\"bar\", \"/*\", \"foo\", \"*/\"]);\n-/// // => vec![\"bar\"]\n-/// ```\n-pub fn without_block_comments(lines: Vec<&str>) -> Vec<&str> {\n-    let mut without = vec![];\n-\n-    let mut nest_level = 0;\n-\n-    for line in lines {\n-        if line.contains(\"/*\") {\n-            nest_level += 1;\n-            continue;\n-        } else if line.contains(\"*/\") {\n-            nest_level -= 1;\n-            continue;\n-        }\n-\n-        if nest_level == 0 {\n-            without.push(line);\n-        }\n-    }\n-\n-    without\n-}\n-\n-pub fn any_parent_is_automatically_derived(tcx: TyCtxt<'_>, node: HirId) -> bool {\n-    let map = &tcx.hir();\n-    let mut prev_enclosing_node = None;\n-    let mut enclosing_node = node;\n-    while Some(enclosing_node) != prev_enclosing_node {\n-        if is_automatically_derived(map.attrs(enclosing_node)) {\n-            return true;\n-        }\n-        prev_enclosing_node = Some(enclosing_node);\n-        enclosing_node = map.get_parent_item(enclosing_node);\n-    }\n-    false\n-}\n-\n-/// Returns true if ty has `iter` or `iter_mut` methods\n-pub fn has_iter_method(cx: &LateContext<'_>, probably_ref_ty: Ty<'_>) -> Option<&'static str> {\n-    // FIXME: instead of this hard-coded list, we should check if `<adt>::iter`\n-    // exists and has the desired signature. Unfortunately FnCtxt is not exported\n-    // so we can't use its `lookup_method` method.\n-    let into_iter_collections: [&[&str]; 13] = [\n-        &paths::VEC,\n-        &paths::OPTION,\n-        &paths::RESULT,\n-        &paths::BTREESET,\n-        &paths::BTREEMAP,\n-        &paths::VEC_DEQUE,\n-        &paths::LINKED_LIST,\n-        &paths::BINARY_HEAP,\n-        &paths::HASHSET,\n-        &paths::HASHMAP,\n-        &paths::PATH_BUF,\n-        &paths::PATH,\n-        &paths::RECEIVER,\n-    ];\n-\n-    let ty_to_check = match probably_ref_ty.kind() {\n-        ty::Ref(_, ty_to_check, _) => ty_to_check,\n-        _ => probably_ref_ty,\n-    };\n-\n-    let def_id = match ty_to_check.kind() {\n-        ty::Array(..) => return Some(\"array\"),\n-        ty::Slice(..) => return Some(\"slice\"),\n-        ty::Adt(adt, _) => adt.did,\n-        _ => return None,\n-    };\n-\n-    for path in &into_iter_collections {\n-        if match_def_path(cx, def_id, path) {\n-            return Some(*path.last().unwrap());\n-        }\n-    }\n-    None\n-}\n-\n-/// Matches a function call with the given path and returns the arguments.\n-///\n-/// Usage:\n-///\n-/// ```rust,ignore\n-/// if let Some(args) = match_function_call(cx, cmp_max_call, &paths::CMP_MAX);\n-/// ```\n-pub fn match_function_call<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    expr: &'tcx Expr<'_>,\n-    path: &[&str],\n-) -> Option<&'tcx [Expr<'tcx>]> {\n-    if_chain! {\n-        if let ExprKind::Call(ref fun, ref args) = expr.kind;\n-        if let ExprKind::Path(ref qpath) = fun.kind;\n-        if let Some(fun_def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n-        if match_def_path(cx, fun_def_id, path);\n-        then {\n-            return Some(&args)\n-        }\n-    };\n-    None\n-}\n-\n-/// Checks if `Ty` is normalizable. This function is useful\n-/// to avoid crashes on `layout_of`.\n-pub fn is_normalizable<'tcx>(cx: &LateContext<'tcx>, param_env: ty::ParamEnv<'tcx>, ty: Ty<'tcx>) -> bool {\n-    cx.tcx.infer_ctxt().enter(|infcx| {\n-        let cause = rustc_middle::traits::ObligationCause::dummy();\n-        infcx.at(&cause, param_env).normalize(ty).is_ok()\n-    })\n-}\n-\n-pub fn match_def_path<'tcx>(cx: &LateContext<'tcx>, did: DefId, syms: &[&str]) -> bool {\n-    // We have to convert `syms` to `&[Symbol]` here because rustc's `match_def_path`\n-    // accepts only that. We should probably move to Symbols in Clippy as well.\n-    let syms = syms.iter().map(|p| Symbol::intern(p)).collect::<Vec<Symbol>>();\n-    cx.match_def_path(did, &syms)\n-}\n-\n-pub fn match_panic_call<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx [Expr<'tcx>]> {\n-    match_function_call(cx, expr, &paths::BEGIN_PANIC)\n-        .or_else(|| match_function_call(cx, expr, &paths::BEGIN_PANIC_FMT))\n-        .or_else(|| match_function_call(cx, expr, &paths::PANIC_ANY))\n-        .or_else(|| match_function_call(cx, expr, &paths::PANICKING_PANIC))\n-        .or_else(|| match_function_call(cx, expr, &paths::PANICKING_PANIC_FMT))\n-        .or_else(|| match_function_call(cx, expr, &paths::PANICKING_PANIC_STR))\n-}\n-\n-pub fn match_panic_def_id(cx: &LateContext<'_>, did: DefId) -> bool {\n-    match_def_path(cx, did, &paths::BEGIN_PANIC)\n-        || match_def_path(cx, did, &paths::BEGIN_PANIC_FMT)\n-        || match_def_path(cx, did, &paths::PANIC_ANY)\n-        || match_def_path(cx, did, &paths::PANICKING_PANIC)\n-        || match_def_path(cx, did, &paths::PANICKING_PANIC_FMT)\n-        || match_def_path(cx, did, &paths::PANICKING_PANIC_STR)\n-}\n-\n-/// Returns the list of condition expressions and the list of blocks in a\n-/// sequence of `if/else`.\n-/// E.g., this returns `([a, b], [c, d, e])` for the expression\n-/// `if a { c } else if b { d } else { e }`.\n-pub fn if_sequence<'tcx>(\n-    mut expr: &'tcx Expr<'tcx>,\n-) -> (SmallVec<[&'tcx Expr<'tcx>; 1]>, SmallVec<[&'tcx Block<'tcx>; 1]>) {\n-    let mut conds = SmallVec::new();\n-    let mut blocks: SmallVec<[&Block<'_>; 1]> = SmallVec::new();\n-\n-    while let ExprKind::If(ref cond, ref then_expr, ref else_expr) = expr.kind {\n-        conds.push(&**cond);\n-        if let ExprKind::Block(ref block, _) = then_expr.kind {\n-            blocks.push(block);\n-        } else {\n-            panic!(\"ExprKind::If node is not an ExprKind::Block\");\n-        }\n-\n-        if let Some(ref else_expr) = *else_expr {\n-            expr = else_expr;\n-        } else {\n-            break;\n-        }\n-    }\n-\n-    // final `else {..}`\n-    if !blocks.is_empty() {\n-        if let ExprKind::Block(ref block, _) = expr.kind {\n-            blocks.push(&**block);\n-        }\n-    }\n-\n-    (conds, blocks)\n-}\n-\n-pub fn parent_node_is_if_expr(expr: &Expr<'_>, cx: &LateContext<'_>) -> bool {\n-    let map = cx.tcx.hir();\n-    let parent_id = map.get_parent_node(expr.hir_id);\n-    let parent_node = map.get(parent_id);\n-    matches!(\n-        parent_node,\n-        Node::Expr(Expr {\n-            kind: ExprKind::If(_, _, _),\n-            ..\n-        })\n-    )\n-}\n-\n-// Finds the attribute with the given name, if any\n-pub fn attr_by_name<'a>(attrs: &'a [Attribute], name: &'_ str) -> Option<&'a Attribute> {\n-    attrs\n-        .iter()\n-        .find(|attr| attr.ident().map_or(false, |ident| ident.as_str() == name))\n-}\n-\n-// Finds the `#[must_use]` attribute, if any\n-pub fn must_use_attr(attrs: &[Attribute]) -> Option<&Attribute> {\n-    attr_by_name(attrs, \"must_use\")\n-}\n-\n-// Returns whether the type has #[must_use] attribute\n-pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.kind() {\n-        ty::Adt(ref adt, _) => must_use_attr(&cx.tcx.get_attrs(adt.did)).is_some(),\n-        ty::Foreign(ref did) => must_use_attr(&cx.tcx.get_attrs(*did)).is_some(),\n-        ty::Slice(ref ty)\n-        | ty::Array(ref ty, _)\n-        | ty::RawPtr(ty::TypeAndMut { ref ty, .. })\n-        | ty::Ref(_, ref ty, _) => {\n-            // for the Array case we don't need to care for the len == 0 case\n-            // because we don't want to lint functions returning empty arrays\n-            is_must_use_ty(cx, *ty)\n-        },\n-        ty::Tuple(ref substs) => substs.types().any(|ty| is_must_use_ty(cx, ty)),\n-        ty::Opaque(ref def_id, _) => {\n-            for (predicate, _) in cx.tcx.explicit_item_bounds(*def_id) {\n-                if let ty::PredicateKind::Trait(trait_predicate, _) = predicate.kind().skip_binder() {\n-                    if must_use_attr(&cx.tcx.get_attrs(trait_predicate.trait_ref.def_id)).is_some() {\n-                        return true;\n-                    }\n-                }\n-            }\n-            false\n-        },\n-        ty::Dynamic(binder, _) => {\n-            for predicate in binder.iter() {\n-                if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate.skip_binder() {\n-                    if must_use_attr(&cx.tcx.get_attrs(trait_ref.def_id)).is_some() {\n-                        return true;\n-                    }\n-                }\n-            }\n-            false\n-        },\n-        _ => false,\n-    }\n-}\n-\n-// check if expr is calling method or function with #[must_use] attribute\n-pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    let did = match expr.kind {\n-        ExprKind::Call(ref path, _) => if_chain! {\n-            if let ExprKind::Path(ref qpath) = path.kind;\n-            if let def::Res::Def(_, did) = cx.qpath_res(qpath, path.hir_id);\n-            then {\n-                Some(did)\n-            } else {\n-                None\n-            }\n-        },\n-        ExprKind::MethodCall(_, _, _, _) => cx.typeck_results().type_dependent_def_id(expr.hir_id),\n-        _ => None,\n-    };\n-\n-    did.map_or(false, |did| must_use_attr(&cx.tcx.get_attrs(did)).is_some())\n-}\n-\n-pub fn is_no_std_crate(krate: &Crate<'_>) -> bool {\n-    krate.item.attrs.iter().any(|attr| {\n-        if let ast::AttrKind::Normal(ref attr, _) = attr.kind {\n-            attr.path == sym::no_std\n-        } else {\n-            false\n-        }\n-    })\n-}\n-\n-/// Check if parent of a hir node is a trait implementation block.\n-/// For example, `f` in\n-/// ```rust,ignore\n-/// impl Trait for S {\n-///     fn f() {}\n-/// }\n-/// ```\n-pub fn is_trait_impl_item(cx: &LateContext<'_>, hir_id: HirId) -> bool {\n-    if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_id)) {\n-        matches!(item.kind, ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }))\n-    } else {\n-        false\n-    }\n-}\n-\n-/// Check if it's even possible to satisfy the `where` clause for the item.\n-///\n-/// `trivial_bounds` feature allows functions with unsatisfiable bounds, for example:\n-///\n-/// ```ignore\n-/// fn foo() where i32: Iterator {\n-///     for _ in 2i32 {}\n-/// }\n-/// ```\n-pub fn fn_has_unsatisfiable_preds(cx: &LateContext<'_>, did: DefId) -> bool {\n-    use rustc_trait_selection::traits;\n-    let predicates =\n-        cx.tcx\n-            .predicates_of(did)\n-            .predicates\n-            .iter()\n-            .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n-    traits::impossible_predicates(\n-        cx.tcx,\n-        traits::elaborate_predicates(cx.tcx, predicates)\n-            .map(|o| o.predicate)\n-            .collect::<Vec<_>>(),\n-    )\n-}\n-\n-/// Returns the `DefId` of the callee if the given expression is a function or method call.\n-pub fn fn_def_id(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<DefId> {\n-    match &expr.kind {\n-        ExprKind::MethodCall(..) => cx.typeck_results().type_dependent_def_id(expr.hir_id),\n-        ExprKind::Call(\n-            Expr {\n-                kind: ExprKind::Path(qpath),\n-                hir_id: path_hir_id,\n-                ..\n-            },\n-            ..,\n-        ) => cx.typeck_results().qpath_res(qpath, *path_hir_id).opt_def_id(),\n-        _ => None,\n-    }\n-}\n-\n-pub fn run_lints(cx: &LateContext<'_>, lints: &[&'static Lint], id: HirId) -> bool {\n-    lints.iter().any(|lint| {\n-        matches!(\n-            cx.tcx.lint_level_at_node(lint, id),\n-            (Level::Forbid | Level::Deny | Level::Warn, _)\n-        )\n-    })\n-}\n-\n-/// Returns true iff the given type is a primitive (a bool or char, any integer or floating-point\n-/// number type, a str, or an array, slice, or tuple of those types).\n-pub fn is_recursively_primitive_type(ty: Ty<'_>) -> bool {\n-    match ty.kind() {\n-        ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => true,\n-        ty::Ref(_, inner, _) if *inner.kind() == ty::Str => true,\n-        ty::Array(inner_type, _) | ty::Slice(inner_type) => is_recursively_primitive_type(inner_type),\n-        ty::Tuple(inner_types) => inner_types.types().all(is_recursively_primitive_type),\n-        _ => false,\n-    }\n-}\n-\n-/// Returns Option<String> where String is a textual representation of the type encapsulated in the\n-/// slice iff the given expression is a slice of primitives (as defined in the\n-/// `is_recursively_primitive_type` function) and None otherwise.\n-pub fn is_slice_of_primitives(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n-    let expr_type = cx.typeck_results().expr_ty_adjusted(expr);\n-    let expr_kind = expr_type.kind();\n-    let is_primitive = match expr_kind {\n-        ty::Slice(element_type) => is_recursively_primitive_type(element_type),\n-        ty::Ref(_, inner_ty, _) if matches!(inner_ty.kind(), &ty::Slice(_)) => {\n-            if let ty::Slice(element_type) = inner_ty.kind() {\n-                is_recursively_primitive_type(element_type)\n-            } else {\n-                unreachable!()\n-            }\n-        },\n-        _ => false,\n-    };\n-\n-    if is_primitive {\n-        // if we have wrappers like Array, Slice or Tuple, print these\n-        // and get the type enclosed in the slice ref\n-        match expr_type.peel_refs().walk().nth(1).unwrap().expect_ty().kind() {\n-            ty::Slice(..) => return Some(\"slice\".into()),\n-            ty::Array(..) => return Some(\"array\".into()),\n-            ty::Tuple(..) => return Some(\"tuple\".into()),\n-            _ => {\n-                // is_recursively_primitive_type() should have taken care\n-                // of the rest and we can rely on the type that is found\n-                let refs_peeled = expr_type.peel_refs();\n-                return Some(refs_peeled.walk().last().unwrap().to_string());\n-            },\n-        }\n-    }\n-    None\n-}\n-\n-/// returns list of all pairs (a, b) from `exprs` such that `eq(a, b)`\n-/// `hash` must be comformed with `eq`\n-pub fn search_same<T, Hash, Eq>(exprs: &[T], hash: Hash, eq: Eq) -> Vec<(&T, &T)>\n-where\n-    Hash: Fn(&T) -> u64,\n-    Eq: Fn(&T, &T) -> bool,\n-{\n-    if exprs.len() == 2 && eq(&exprs[0], &exprs[1]) {\n-        return vec![(&exprs[0], &exprs[1])];\n-    }\n-\n-    let mut match_expr_list: Vec<(&T, &T)> = Vec::new();\n-\n-    let mut map: FxHashMap<_, Vec<&_>> =\n-        FxHashMap::with_capacity_and_hasher(exprs.len(), BuildHasherDefault::default());\n-\n-    for expr in exprs {\n-        match map.entry(hash(expr)) {\n-            Entry::Occupied(mut o) => {\n-                for o in o.get() {\n-                    if eq(o, expr) {\n-                        match_expr_list.push((o, expr));\n-                    }\n-                }\n-                o.get_mut().push(expr);\n-            },\n-            Entry::Vacant(v) => {\n-                v.insert(vec![expr]);\n-            },\n-        }\n-    }\n-\n-    match_expr_list\n-}\n-\n-/// Peels off all references on the pattern. Returns the underlying pattern and the number of\n-/// references removed.\n-pub fn peel_hir_pat_refs(pat: &'a Pat<'a>) -> (&'a Pat<'a>, usize) {\n-    fn peel(pat: &'a Pat<'a>, count: usize) -> (&'a Pat<'a>, usize) {\n-        if let PatKind::Ref(pat, _) = pat.kind {\n-            peel(pat, count + 1)\n-        } else {\n-            (pat, count)\n-        }\n-    }\n-    peel(pat, 0)\n-}\n-\n-/// Peels off up to the given number of references on the expression. Returns the underlying\n-/// expression and the number of references removed.\n-pub fn peel_n_hir_expr_refs(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>, usize) {\n-    fn f(expr: &'a Expr<'a>, count: usize, target: usize) -> (&'a Expr<'a>, usize) {\n-        match expr.kind {\n-            ExprKind::AddrOf(_, _, expr) if count != target => f(expr, count + 1, target),\n-            _ => (expr, count),\n-        }\n-    }\n-    f(expr, 0, count)\n-}\n-\n-/// Peels off all references on the expression. Returns the underlying expression and the number of\n-/// references removed.\n-pub fn peel_hir_expr_refs(expr: &'a Expr<'a>) -> (&'a Expr<'a>, usize) {\n-    fn f(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>, usize) {\n-        match expr.kind {\n-            ExprKind::AddrOf(BorrowKind::Ref, _, expr) => f(expr, count + 1),\n-            _ => (expr, count),\n-        }\n-    }\n-    f(expr, 0)\n-}\n-\n-/// Peels off all references on the type. Returns the underlying type and the number of references\n-/// removed.\n-pub fn peel_mid_ty_refs(ty: Ty<'_>) -> (Ty<'_>, usize) {\n-    fn peel(ty: Ty<'_>, count: usize) -> (Ty<'_>, usize) {\n-        if let ty::Ref(_, ty, _) = ty.kind() {\n-            peel(ty, count + 1)\n-        } else {\n-            (ty, count)\n-        }\n-    }\n-    peel(ty, 0)\n-}\n-\n-/// Peels off all references on the type.Returns the underlying type, the number of references\n-/// removed, and whether the pointer is ultimately mutable or not.\n-pub fn peel_mid_ty_refs_is_mutable(ty: Ty<'_>) -> (Ty<'_>, usize, Mutability) {\n-    fn f(ty: Ty<'_>, count: usize, mutability: Mutability) -> (Ty<'_>, usize, Mutability) {\n-        match ty.kind() {\n-            ty::Ref(_, ty, Mutability::Mut) => f(ty, count + 1, mutability),\n-            ty::Ref(_, ty, Mutability::Not) => f(ty, count + 1, Mutability::Not),\n-            _ => (ty, count, mutability),\n-        }\n-    }\n-    f(ty, 0, Mutability::Mut)\n-}\n-\n-#[macro_export]\n-macro_rules! unwrap_cargo_metadata {\n-    ($cx: ident, $lint: ident, $deps: expr) => {{\n-        let mut command = cargo_metadata::MetadataCommand::new();\n-        if !$deps {\n-            command.no_deps();\n-        }\n-\n-        match command.exec() {\n-            Ok(metadata) => metadata,\n-            Err(err) => {\n-                span_lint($cx, $lint, DUMMY_SP, &format!(\"could not read cargo metadata: {}\", err));\n-                return;\n-            },\n-        }\n-    }};\n-}\n-\n-pub fn is_hir_ty_cfg_dependant(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> bool {\n-    if_chain! {\n-        if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind;\n-        if let Res::Def(_, def_id) = path.res;\n-        then {\n-            cx.tcx.has_attr(def_id, sym::cfg) || cx.tcx.has_attr(def_id, sym::cfg_attr)\n-        } else {\n-            false\n-        }\n-    }\n-}\n-\n-/// Check if the resolution of a given path is an `Ok` variant of `Result`.\n-pub fn is_ok_ctor(cx: &LateContext<'_>, res: Res) -> bool {\n-    if let Some(ok_id) = cx.tcx.lang_items().result_ok_variant() {\n-        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n-            if let Some(variant_id) = cx.tcx.parent(id) {\n-                return variant_id == ok_id;\n-            }\n-        }\n-    }\n-    false\n-}\n-\n-/// Check if the resolution of a given path is a `Some` variant of `Option`.\n-pub fn is_some_ctor(cx: &LateContext<'_>, res: Res) -> bool {\n-    if let Some(some_id) = cx.tcx.lang_items().option_some_variant() {\n-        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n-            if let Some(variant_id) = cx.tcx.parent(id) {\n-                return variant_id == some_id;\n-            }\n-        }\n-    }\n-    false\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::{reindent_multiline, without_block_comments};\n-\n-    #[test]\n-    fn test_reindent_multiline_single_line() {\n-        assert_eq!(\"\", reindent_multiline(\"\".into(), false, None));\n-        assert_eq!(\"...\", reindent_multiline(\"...\".into(), false, None));\n-        assert_eq!(\"...\", reindent_multiline(\"    ...\".into(), false, None));\n-        assert_eq!(\"...\", reindent_multiline(\"\\t...\".into(), false, None));\n-        assert_eq!(\"...\", reindent_multiline(\"\\t\\t...\".into(), false, None));\n-    }\n-\n-    #[test]\n-    #[rustfmt::skip]\n-    fn test_reindent_multiline_block() {\n-        assert_eq!(\"\\\n-    if x {\n-        y\n-    } else {\n-        z\n-    }\", reindent_multiline(\"    if x {\n-            y\n-        } else {\n-            z\n-        }\".into(), false, None));\n-        assert_eq!(\"\\\n-    if x {\n-    \\ty\n-    } else {\n-    \\tz\n-    }\", reindent_multiline(\"    if x {\n-        \\ty\n-        } else {\n-        \\tz\n-        }\".into(), false, None));\n-    }\n-\n-    #[test]\n-    #[rustfmt::skip]\n-    fn test_reindent_multiline_empty_line() {\n-        assert_eq!(\"\\\n-    if x {\n-        y\n-\n-    } else {\n-        z\n-    }\", reindent_multiline(\"    if x {\n-            y\n-\n-        } else {\n-            z\n-        }\".into(), false, None));\n-    }\n-\n-    #[test]\n-    #[rustfmt::skip]\n-    fn test_reindent_multiline_lines_deeper() {\n-        assert_eq!(\"\\\n-        if x {\n-            y\n-        } else {\n-            z\n-        }\", reindent_multiline(\"\\\n-    if x {\n-        y\n-    } else {\n-        z\n-    }\".into(), true, Some(8)));\n-    }\n-\n-    #[test]\n-    fn test_without_block_comments_lines_without_block_comments() {\n-        let result = without_block_comments(vec![\"/*\", \"\", \"*/\"]);\n-        println!(\"result: {:?}\", result);\n-        assert!(result.is_empty());\n-\n-        let result = without_block_comments(vec![\"\", \"/*\", \"\", \"*/\", \"#[crate_type = \\\"lib\\\"]\", \"/*\", \"\", \"*/\", \"\"]);\n-        assert_eq!(result, vec![\"\", \"#[crate_type = \\\"lib\\\"]\", \"\"]);\n-\n-        let result = without_block_comments(vec![\"/* rust\", \"\", \"*/\"]);\n-        assert!(result.is_empty());\n-\n-        let result = without_block_comments(vec![\"/* one-line comment */\"]);\n-        assert!(result.is_empty());\n-\n-        let result = without_block_comments(vec![\"/* nested\", \"/* multi-line\", \"comment\", \"*/\", \"test\", \"*/\"]);\n-        assert!(result.is_empty());\n-\n-        let result = without_block_comments(vec![\"/* nested /* inline /* comment */ test */ */\"]);\n-        assert!(result.is_empty());\n \n-        let result = without_block_comments(vec![\"foo\", \"bar\", \"baz\"]);\n-        assert_eq!(result, vec![\"foo\", \"bar\", \"baz\"]);\n-    }\n-}\n+pub use clippy_utils::*;"}, {"sha": "9c01badb04cc9e6856341bbf5b596d3335cb02b6", "filename": "clippy_utils/Cargo.toml", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2FCargo.toml?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "patch": "@@ -0,0 +1,19 @@\n+[package]\n+name = \"clippy_utils\"\n+version = \"0.1.52\"\n+authors = [\"The Rust Clippy Developers\"]\n+edition = \"2018\"\n+publish = false\n+\n+[dependencies]\n+if_chain = \"1.0.0\"\n+itertools = \"0.9\"\n+regex-syntax = \"0.6\"\n+serde = { version = \"1.0\", features = [\"derive\"] }\n+smallvec = { version = \"1\", features = [\"union\"] }\n+toml = \"0.5.3\"\n+unicode-normalization = \"0.1\"\n+rustc-semver=\"1.1.0\"\n+\n+[features]\n+internal-lints = []"}, {"sha": "7ec0e103c0002e2e9d85aad8c1a396ed5dee376e", "filename": "clippy_utils/src/ast_utils.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fast_utils.rs?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "patch": "@@ -4,7 +4,7 @@\n \n #![allow(clippy::similar_names, clippy::wildcard_imports, clippy::enum_glob_use)]\n \n-use crate::utils::{both, over};\n+use crate::{both, over};\n use rustc_ast::ptr::P;\n use rustc_ast::{self as ast, *};\n use rustc_span::symbol::Ident;", "previous_filename": "clippy_lints/src/utils/ast_utils.rs"}, {"sha": "eefcbabd835d2b669cf65be463c4130b366b66e7", "filename": "clippy_utils/src/ast_utils/ident_iter.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fast_utils%2Fident_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fast_utils%2Fident_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fast_utils%2Fident_iter.rs?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "previous_filename": "clippy_lints/src/utils/ast_utils/ident_iter.rs"}, {"sha": "8d28421d70d707fdec87dcbf03a059f5d63ada2c", "filename": "clippy_utils/src/attrs.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fattrs.rs?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "previous_filename": "clippy_lints/src/utils/attrs.rs"}, {"sha": "ba1c01ebc9f76d2523340b2bd7c56cd482142293", "filename": "clippy_utils/src/camel_case.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fcamel_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fcamel_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fcamel_case.rs?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "previous_filename": "clippy_lints/src/utils/camel_case.rs"}, {"sha": "7a18d5e818fb1c607298209b6b344ef6a484021d", "filename": "clippy_utils/src/comparisons.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fcomparisons.rs?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "previous_filename": "clippy_lints/src/utils/comparisons.rs"}, {"sha": "7d7b35c21680d907bf4b772570b2126e7778679d", "filename": "clippy_utils/src/conf.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fconf.rs?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "previous_filename": "clippy_lints/src/utils/conf.rs"}, {"sha": "802c01055a68c84d68dd4307c841c6b67bcfa334", "filename": "clippy_utils/src/consts.rs", "status": "added", "additions": 574, "deletions": 0, "changes": 574, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fconsts.rs?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "patch": "@@ -0,0 +1,574 @@\n+#![allow(clippy::float_cmp)]\n+\n+use crate::{clip, sext, unsext};\n+use if_chain::if_chain;\n+use rustc_ast::ast::{self, LitFloatType, LitKind};\n+use rustc_data_structures::sync::Lrc;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::{BinOp, BinOpKind, Block, Expr, ExprKind, HirId, QPath, UnOp};\n+use rustc_lint::LateContext;\n+use rustc_middle::mir::interpret::Scalar;\n+use rustc_middle::ty::subst::{Subst, SubstsRef};\n+use rustc_middle::ty::{self, FloatTy, ScalarInt, Ty, TyCtxt};\n+use rustc_middle::{bug, span_bug};\n+use rustc_span::symbol::Symbol;\n+use std::cmp::Ordering::{self, Equal};\n+use std::convert::TryInto;\n+use std::hash::{Hash, Hasher};\n+\n+/// A `LitKind`-like enum to fold constant `Expr`s into.\n+#[derive(Debug, Clone)]\n+pub enum Constant {\n+    /// A `String` (e.g., \"abc\").\n+    Str(String),\n+    /// A binary string (e.g., `b\"abc\"`).\n+    Binary(Lrc<[u8]>),\n+    /// A single `char` (e.g., `'a'`).\n+    Char(char),\n+    /// An integer's bit representation.\n+    Int(u128),\n+    /// An `f32`.\n+    F32(f32),\n+    /// An `f64`.\n+    F64(f64),\n+    /// `true` or `false`.\n+    Bool(bool),\n+    /// An array of constants.\n+    Vec(Vec<Constant>),\n+    /// Also an array, but with only one constant, repeated N times.\n+    Repeat(Box<Constant>, u64),\n+    /// A tuple of constants.\n+    Tuple(Vec<Constant>),\n+    /// A raw pointer.\n+    RawPtr(u128),\n+    /// A reference\n+    Ref(Box<Constant>),\n+    /// A literal with syntax error.\n+    Err(Symbol),\n+}\n+\n+impl PartialEq for Constant {\n+    fn eq(&self, other: &Self) -> bool {\n+        match (self, other) {\n+            (&Self::Str(ref ls), &Self::Str(ref rs)) => ls == rs,\n+            (&Self::Binary(ref l), &Self::Binary(ref r)) => l == r,\n+            (&Self::Char(l), &Self::Char(r)) => l == r,\n+            (&Self::Int(l), &Self::Int(r)) => l == r,\n+            (&Self::F64(l), &Self::F64(r)) => {\n+                // We want `Fw32 == FwAny` and `FwAny == Fw64`, and by transitivity we must have\n+                // `Fw32 == Fw64`, so don\u2019t compare them.\n+                // `to_bits` is required to catch non-matching 0.0, -0.0, and NaNs.\n+                l.to_bits() == r.to_bits()\n+            },\n+            (&Self::F32(l), &Self::F32(r)) => {\n+                // We want `Fw32 == FwAny` and `FwAny == Fw64`, and by transitivity we must have\n+                // `Fw32 == Fw64`, so don\u2019t compare them.\n+                // `to_bits` is required to catch non-matching 0.0, -0.0, and NaNs.\n+                f64::from(l).to_bits() == f64::from(r).to_bits()\n+            },\n+            (&Self::Bool(l), &Self::Bool(r)) => l == r,\n+            (&Self::Vec(ref l), &Self::Vec(ref r)) | (&Self::Tuple(ref l), &Self::Tuple(ref r)) => l == r,\n+            (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => ls == rs && lv == rv,\n+            (&Self::Ref(ref lb), &Self::Ref(ref rb)) => *lb == *rb,\n+            // TODO: are there inter-type equalities?\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl Hash for Constant {\n+    fn hash<H>(&self, state: &mut H)\n+    where\n+        H: Hasher,\n+    {\n+        std::mem::discriminant(self).hash(state);\n+        match *self {\n+            Self::Str(ref s) => {\n+                s.hash(state);\n+            },\n+            Self::Binary(ref b) => {\n+                b.hash(state);\n+            },\n+            Self::Char(c) => {\n+                c.hash(state);\n+            },\n+            Self::Int(i) => {\n+                i.hash(state);\n+            },\n+            Self::F32(f) => {\n+                f64::from(f).to_bits().hash(state);\n+            },\n+            Self::F64(f) => {\n+                f.to_bits().hash(state);\n+            },\n+            Self::Bool(b) => {\n+                b.hash(state);\n+            },\n+            Self::Vec(ref v) | Self::Tuple(ref v) => {\n+                v.hash(state);\n+            },\n+            Self::Repeat(ref c, l) => {\n+                c.hash(state);\n+                l.hash(state);\n+            },\n+            Self::RawPtr(u) => {\n+                u.hash(state);\n+            },\n+            Self::Ref(ref r) => {\n+                r.hash(state);\n+            },\n+            Self::Err(ref s) => {\n+                s.hash(state);\n+            },\n+        }\n+    }\n+}\n+\n+impl Constant {\n+    pub fn partial_cmp(tcx: TyCtxt<'_>, cmp_type: Ty<'_>, left: &Self, right: &Self) -> Option<Ordering> {\n+        match (left, right) {\n+            (&Self::Str(ref ls), &Self::Str(ref rs)) => Some(ls.cmp(rs)),\n+            (&Self::Char(ref l), &Self::Char(ref r)) => Some(l.cmp(r)),\n+            (&Self::Int(l), &Self::Int(r)) => {\n+                if let ty::Int(int_ty) = *cmp_type.kind() {\n+                    Some(sext(tcx, l, int_ty).cmp(&sext(tcx, r, int_ty)))\n+                } else {\n+                    Some(l.cmp(&r))\n+                }\n+            },\n+            (&Self::F64(l), &Self::F64(r)) => l.partial_cmp(&r),\n+            (&Self::F32(l), &Self::F32(r)) => l.partial_cmp(&r),\n+            (&Self::Bool(ref l), &Self::Bool(ref r)) => Some(l.cmp(r)),\n+            (&Self::Tuple(ref l), &Self::Tuple(ref r)) | (&Self::Vec(ref l), &Self::Vec(ref r)) => l\n+                .iter()\n+                .zip(r.iter())\n+                .map(|(li, ri)| Self::partial_cmp(tcx, cmp_type, li, ri))\n+                .find(|r| r.map_or(true, |o| o != Ordering::Equal))\n+                .unwrap_or_else(|| Some(l.len().cmp(&r.len()))),\n+            (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => {\n+                match Self::partial_cmp(tcx, cmp_type, lv, rv) {\n+                    Some(Equal) => Some(ls.cmp(rs)),\n+                    x => x,\n+                }\n+            },\n+            (&Self::Ref(ref lb), &Self::Ref(ref rb)) => Self::partial_cmp(tcx, cmp_type, lb, rb),\n+            // TODO: are there any useful inter-type orderings?\n+            _ => None,\n+        }\n+    }\n+}\n+\n+/// Parses a `LitKind` to a `Constant`.\n+pub fn lit_to_constant(lit: &LitKind, ty: Option<Ty<'_>>) -> Constant {\n+    match *lit {\n+        LitKind::Str(ref is, _) => Constant::Str(is.to_string()),\n+        LitKind::Byte(b) => Constant::Int(u128::from(b)),\n+        LitKind::ByteStr(ref s) => Constant::Binary(Lrc::clone(s)),\n+        LitKind::Char(c) => Constant::Char(c),\n+        LitKind::Int(n, _) => Constant::Int(n),\n+        LitKind::Float(ref is, LitFloatType::Suffixed(fty)) => match fty {\n+            ast::FloatTy::F32 => Constant::F32(is.as_str().parse().unwrap()),\n+            ast::FloatTy::F64 => Constant::F64(is.as_str().parse().unwrap()),\n+        },\n+        LitKind::Float(ref is, LitFloatType::Unsuffixed) => match ty.expect(\"type of float is known\").kind() {\n+            ty::Float(FloatTy::F32) => Constant::F32(is.as_str().parse().unwrap()),\n+            ty::Float(FloatTy::F64) => Constant::F64(is.as_str().parse().unwrap()),\n+            _ => bug!(),\n+        },\n+        LitKind::Bool(b) => Constant::Bool(b),\n+        LitKind::Err(s) => Constant::Err(s),\n+    }\n+}\n+\n+pub fn constant<'tcx>(\n+    lcx: &LateContext<'tcx>,\n+    typeck_results: &ty::TypeckResults<'tcx>,\n+    e: &Expr<'_>,\n+) -> Option<(Constant, bool)> {\n+    let mut cx = ConstEvalLateContext {\n+        lcx,\n+        typeck_results,\n+        param_env: lcx.param_env,\n+        needed_resolution: false,\n+        substs: lcx.tcx.intern_substs(&[]),\n+    };\n+    cx.expr(e).map(|cst| (cst, cx.needed_resolution))\n+}\n+\n+pub fn constant_simple<'tcx>(\n+    lcx: &LateContext<'tcx>,\n+    typeck_results: &ty::TypeckResults<'tcx>,\n+    e: &Expr<'_>,\n+) -> Option<Constant> {\n+    constant(lcx, typeck_results, e).and_then(|(cst, res)| if res { None } else { Some(cst) })\n+}\n+\n+/// Creates a `ConstEvalLateContext` from the given `LateContext` and `TypeckResults`.\n+pub fn constant_context<'a, 'tcx>(\n+    lcx: &'a LateContext<'tcx>,\n+    typeck_results: &'a ty::TypeckResults<'tcx>,\n+) -> ConstEvalLateContext<'a, 'tcx> {\n+    ConstEvalLateContext {\n+        lcx,\n+        typeck_results,\n+        param_env: lcx.param_env,\n+        needed_resolution: false,\n+        substs: lcx.tcx.intern_substs(&[]),\n+    }\n+}\n+\n+pub struct ConstEvalLateContext<'a, 'tcx> {\n+    lcx: &'a LateContext<'tcx>,\n+    typeck_results: &'a ty::TypeckResults<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    needed_resolution: bool,\n+    substs: SubstsRef<'tcx>,\n+}\n+\n+impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n+    /// Simple constant folding: Insert an expression, get a constant or none.\n+    pub fn expr(&mut self, e: &Expr<'_>) -> Option<Constant> {\n+        match e.kind {\n+            ExprKind::Path(ref qpath) => self.fetch_path(qpath, e.hir_id, self.typeck_results.expr_ty(e)),\n+            ExprKind::Block(ref block, _) => self.block(block),\n+            ExprKind::Lit(ref lit) => Some(lit_to_constant(&lit.node, self.typeck_results.expr_ty_opt(e))),\n+            ExprKind::Array(ref vec) => self.multi(vec).map(Constant::Vec),\n+            ExprKind::Tup(ref tup) => self.multi(tup).map(Constant::Tuple),\n+            ExprKind::Repeat(ref value, _) => {\n+                let n = match self.typeck_results.expr_ty(e).kind() {\n+                    ty::Array(_, n) => n.try_eval_usize(self.lcx.tcx, self.lcx.param_env)?,\n+                    _ => span_bug!(e.span, \"typeck error\"),\n+                };\n+                self.expr(value).map(|v| Constant::Repeat(Box::new(v), n))\n+            },\n+            ExprKind::Unary(op, ref operand) => self.expr(operand).and_then(|o| match op {\n+                UnOp::Not => self.constant_not(&o, self.typeck_results.expr_ty(e)),\n+                UnOp::Neg => self.constant_negate(&o, self.typeck_results.expr_ty(e)),\n+                UnOp::Deref => Some(if let Constant::Ref(r) = o { *r } else { o }),\n+            }),\n+            ExprKind::If(ref cond, ref then, ref otherwise) => self.ifthenelse(cond, then, *otherwise),\n+            ExprKind::Binary(op, ref left, ref right) => self.binop(op, left, right),\n+            ExprKind::Call(ref callee, ref args) => {\n+                // We only handle a few const functions for now.\n+                if_chain! {\n+                    if args.is_empty();\n+                    if let ExprKind::Path(qpath) = &callee.kind;\n+                    let res = self.typeck_results.qpath_res(qpath, callee.hir_id);\n+                    if let Some(def_id) = res.opt_def_id();\n+                    let def_path: Vec<_> = self.lcx.get_def_path(def_id).into_iter().map(Symbol::as_str).collect();\n+                    let def_path: Vec<&str> = def_path.iter().take(4).map(|s| &**s).collect();\n+                    if let [\"core\", \"num\", int_impl, \"max_value\"] = *def_path;\n+                    then {\n+                       let value = match int_impl {\n+                           \"<impl i8>\" => i8::MAX as u128,\n+                           \"<impl i16>\" => i16::MAX as u128,\n+                           \"<impl i32>\" => i32::MAX as u128,\n+                           \"<impl i64>\" => i64::MAX as u128,\n+                           \"<impl i128>\" => i128::MAX as u128,\n+                           _ => return None,\n+                       };\n+                       Some(Constant::Int(value))\n+                    }\n+                    else {\n+                        None\n+                    }\n+                }\n+            },\n+            ExprKind::Index(ref arr, ref index) => self.index(arr, index),\n+            ExprKind::AddrOf(_, _, ref inner) => self.expr(inner).map(|r| Constant::Ref(Box::new(r))),\n+            // TODO: add other expressions.\n+            _ => None,\n+        }\n+    }\n+\n+    #[allow(clippy::cast_possible_wrap)]\n+    fn constant_not(&self, o: &Constant, ty: Ty<'_>) -> Option<Constant> {\n+        use self::Constant::{Bool, Int};\n+        match *o {\n+            Bool(b) => Some(Bool(!b)),\n+            Int(value) => {\n+                let value = !value;\n+                match *ty.kind() {\n+                    ty::Int(ity) => Some(Int(unsext(self.lcx.tcx, value as i128, ity))),\n+                    ty::Uint(ity) => Some(Int(clip(self.lcx.tcx, value, ity))),\n+                    _ => None,\n+                }\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    fn constant_negate(&self, o: &Constant, ty: Ty<'_>) -> Option<Constant> {\n+        use self::Constant::{Int, F32, F64};\n+        match *o {\n+            Int(value) => {\n+                let ity = match *ty.kind() {\n+                    ty::Int(ity) => ity,\n+                    _ => return None,\n+                };\n+                // sign extend\n+                let value = sext(self.lcx.tcx, value, ity);\n+                let value = value.checked_neg()?;\n+                // clear unused bits\n+                Some(Int(unsext(self.lcx.tcx, value, ity)))\n+            },\n+            F32(f) => Some(F32(-f)),\n+            F64(f) => Some(F64(-f)),\n+            _ => None,\n+        }\n+    }\n+\n+    /// Create `Some(Vec![..])` of all constants, unless there is any\n+    /// non-constant part.\n+    fn multi(&mut self, vec: &[Expr<'_>]) -> Option<Vec<Constant>> {\n+        vec.iter().map(|elem| self.expr(elem)).collect::<Option<_>>()\n+    }\n+\n+    /// Lookup a possibly constant expression from a `ExprKind::Path`.\n+    fn fetch_path(&mut self, qpath: &QPath<'_>, id: HirId, ty: Ty<'tcx>) -> Option<Constant> {\n+        let res = self.typeck_results.qpath_res(qpath, id);\n+        match res {\n+            Res::Def(DefKind::Const | DefKind::AssocConst, def_id) => {\n+                let substs = self.typeck_results.node_substs(id);\n+                let substs = if self.substs.is_empty() {\n+                    substs\n+                } else {\n+                    substs.subst(self.lcx.tcx, self.substs)\n+                };\n+\n+                let result = self\n+                    .lcx\n+                    .tcx\n+                    .const_eval_resolve(\n+                        self.param_env,\n+                        ty::WithOptConstParam::unknown(def_id),\n+                        substs,\n+                        None,\n+                        None,\n+                    )\n+                    .ok()\n+                    .map(|val| rustc_middle::ty::Const::from_value(self.lcx.tcx, val, ty))?;\n+                let result = miri_to_const(&result);\n+                if result.is_some() {\n+                    self.needed_resolution = true;\n+                }\n+                result\n+            },\n+            // FIXME: cover all usable cases.\n+            _ => None,\n+        }\n+    }\n+\n+    fn index(&mut self, lhs: &'_ Expr<'_>, index: &'_ Expr<'_>) -> Option<Constant> {\n+        let lhs = self.expr(lhs);\n+        let index = self.expr(index);\n+\n+        match (lhs, index) {\n+            (Some(Constant::Vec(vec)), Some(Constant::Int(index))) => match vec.get(index as usize) {\n+                Some(Constant::F32(x)) => Some(Constant::F32(*x)),\n+                Some(Constant::F64(x)) => Some(Constant::F64(*x)),\n+                _ => None,\n+            },\n+            (Some(Constant::Vec(vec)), _) => {\n+                if !vec.is_empty() && vec.iter().all(|x| *x == vec[0]) {\n+                    match vec.get(0) {\n+                        Some(Constant::F32(x)) => Some(Constant::F32(*x)),\n+                        Some(Constant::F64(x)) => Some(Constant::F64(*x)),\n+                        _ => None,\n+                    }\n+                } else {\n+                    None\n+                }\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    /// A block can only yield a constant if it only has one constant expression.\n+    fn block(&mut self, block: &Block<'_>) -> Option<Constant> {\n+        if block.stmts.is_empty() {\n+            block.expr.as_ref().and_then(|b| self.expr(b))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn ifthenelse(&mut self, cond: &Expr<'_>, then: &Expr<'_>, otherwise: Option<&Expr<'_>>) -> Option<Constant> {\n+        if let Some(Constant::Bool(b)) = self.expr(cond) {\n+            if b {\n+                self.expr(&*then)\n+            } else {\n+                otherwise.as_ref().and_then(|expr| self.expr(expr))\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn binop(&mut self, op: BinOp, left: &Expr<'_>, right: &Expr<'_>) -> Option<Constant> {\n+        let l = self.expr(left)?;\n+        let r = self.expr(right);\n+        match (l, r) {\n+            (Constant::Int(l), Some(Constant::Int(r))) => match *self.typeck_results.expr_ty_opt(left)?.kind() {\n+                ty::Int(ity) => {\n+                    let l = sext(self.lcx.tcx, l, ity);\n+                    let r = sext(self.lcx.tcx, r, ity);\n+                    let zext = |n: i128| Constant::Int(unsext(self.lcx.tcx, n, ity));\n+                    match op.node {\n+                        BinOpKind::Add => l.checked_add(r).map(zext),\n+                        BinOpKind::Sub => l.checked_sub(r).map(zext),\n+                        BinOpKind::Mul => l.checked_mul(r).map(zext),\n+                        BinOpKind::Div if r != 0 => l.checked_div(r).map(zext),\n+                        BinOpKind::Rem if r != 0 => l.checked_rem(r).map(zext),\n+                        BinOpKind::Shr => l.checked_shr(r.try_into().expect(\"invalid shift\")).map(zext),\n+                        BinOpKind::Shl => l.checked_shl(r.try_into().expect(\"invalid shift\")).map(zext),\n+                        BinOpKind::BitXor => Some(zext(l ^ r)),\n+                        BinOpKind::BitOr => Some(zext(l | r)),\n+                        BinOpKind::BitAnd => Some(zext(l & r)),\n+                        BinOpKind::Eq => Some(Constant::Bool(l == r)),\n+                        BinOpKind::Ne => Some(Constant::Bool(l != r)),\n+                        BinOpKind::Lt => Some(Constant::Bool(l < r)),\n+                        BinOpKind::Le => Some(Constant::Bool(l <= r)),\n+                        BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n+                        BinOpKind::Gt => Some(Constant::Bool(l > r)),\n+                        _ => None,\n+                    }\n+                },\n+                ty::Uint(_) => match op.node {\n+                    BinOpKind::Add => l.checked_add(r).map(Constant::Int),\n+                    BinOpKind::Sub => l.checked_sub(r).map(Constant::Int),\n+                    BinOpKind::Mul => l.checked_mul(r).map(Constant::Int),\n+                    BinOpKind::Div => l.checked_div(r).map(Constant::Int),\n+                    BinOpKind::Rem => l.checked_rem(r).map(Constant::Int),\n+                    BinOpKind::Shr => l.checked_shr(r.try_into().expect(\"shift too large\")).map(Constant::Int),\n+                    BinOpKind::Shl => l.checked_shl(r.try_into().expect(\"shift too large\")).map(Constant::Int),\n+                    BinOpKind::BitXor => Some(Constant::Int(l ^ r)),\n+                    BinOpKind::BitOr => Some(Constant::Int(l | r)),\n+                    BinOpKind::BitAnd => Some(Constant::Int(l & r)),\n+                    BinOpKind::Eq => Some(Constant::Bool(l == r)),\n+                    BinOpKind::Ne => Some(Constant::Bool(l != r)),\n+                    BinOpKind::Lt => Some(Constant::Bool(l < r)),\n+                    BinOpKind::Le => Some(Constant::Bool(l <= r)),\n+                    BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n+                    BinOpKind::Gt => Some(Constant::Bool(l > r)),\n+                    _ => None,\n+                },\n+                _ => None,\n+            },\n+            (Constant::F32(l), Some(Constant::F32(r))) => match op.node {\n+                BinOpKind::Add => Some(Constant::F32(l + r)),\n+                BinOpKind::Sub => Some(Constant::F32(l - r)),\n+                BinOpKind::Mul => Some(Constant::F32(l * r)),\n+                BinOpKind::Div => Some(Constant::F32(l / r)),\n+                BinOpKind::Rem => Some(Constant::F32(l % r)),\n+                BinOpKind::Eq => Some(Constant::Bool(l == r)),\n+                BinOpKind::Ne => Some(Constant::Bool(l != r)),\n+                BinOpKind::Lt => Some(Constant::Bool(l < r)),\n+                BinOpKind::Le => Some(Constant::Bool(l <= r)),\n+                BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n+                BinOpKind::Gt => Some(Constant::Bool(l > r)),\n+                _ => None,\n+            },\n+            (Constant::F64(l), Some(Constant::F64(r))) => match op.node {\n+                BinOpKind::Add => Some(Constant::F64(l + r)),\n+                BinOpKind::Sub => Some(Constant::F64(l - r)),\n+                BinOpKind::Mul => Some(Constant::F64(l * r)),\n+                BinOpKind::Div => Some(Constant::F64(l / r)),\n+                BinOpKind::Rem => Some(Constant::F64(l % r)),\n+                BinOpKind::Eq => Some(Constant::Bool(l == r)),\n+                BinOpKind::Ne => Some(Constant::Bool(l != r)),\n+                BinOpKind::Lt => Some(Constant::Bool(l < r)),\n+                BinOpKind::Le => Some(Constant::Bool(l <= r)),\n+                BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n+                BinOpKind::Gt => Some(Constant::Bool(l > r)),\n+                _ => None,\n+            },\n+            (l, r) => match (op.node, l, r) {\n+                (BinOpKind::And, Constant::Bool(false), _) => Some(Constant::Bool(false)),\n+                (BinOpKind::Or, Constant::Bool(true), _) => Some(Constant::Bool(true)),\n+                (BinOpKind::And, Constant::Bool(true), Some(r)) | (BinOpKind::Or, Constant::Bool(false), Some(r)) => {\n+                    Some(r)\n+                },\n+                (BinOpKind::BitXor, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l ^ r)),\n+                (BinOpKind::BitAnd, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l & r)),\n+                (BinOpKind::BitOr, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l | r)),\n+                _ => None,\n+            },\n+        }\n+    }\n+}\n+\n+pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n+    use rustc_middle::mir::interpret::ConstValue;\n+    match result.val {\n+        ty::ConstKind::Value(ConstValue::Scalar(Scalar::Int(int))) => {\n+            match result.ty.kind() {\n+                ty::Bool => Some(Constant::Bool(int == ScalarInt::TRUE)),\n+                ty::Uint(_) | ty::Int(_) => Some(Constant::Int(int.assert_bits(int.size()))),\n+                ty::Float(FloatTy::F32) => Some(Constant::F32(f32::from_bits(\n+                    int.try_into().expect(\"invalid f32 bit representation\"),\n+                ))),\n+                ty::Float(FloatTy::F64) => Some(Constant::F64(f64::from_bits(\n+                    int.try_into().expect(\"invalid f64 bit representation\"),\n+                ))),\n+                ty::RawPtr(type_and_mut) => {\n+                    if let ty::Uint(_) = type_and_mut.ty.kind() {\n+                        return Some(Constant::RawPtr(int.assert_bits(int.size())));\n+                    }\n+                    None\n+                },\n+                // FIXME: implement other conversions.\n+                _ => None,\n+            }\n+        },\n+        ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => match result.ty.kind() {\n+            ty::Ref(_, tam, _) => match tam.kind() {\n+                ty::Str => String::from_utf8(\n+                    data.inspect_with_uninit_and_ptr_outside_interpreter(start..end)\n+                        .to_owned(),\n+                )\n+                .ok()\n+                .map(Constant::Str),\n+                _ => None,\n+            },\n+            _ => None,\n+        },\n+        ty::ConstKind::Value(ConstValue::ByRef { alloc, offset: _ }) => match result.ty.kind() {\n+            ty::Array(sub_type, len) => match sub_type.kind() {\n+                ty::Float(FloatTy::F32) => match miri_to_const(len) {\n+                    Some(Constant::Int(len)) => alloc\n+                        .inspect_with_uninit_and_ptr_outside_interpreter(0..(4 * len as usize))\n+                        .to_owned()\n+                        .chunks(4)\n+                        .map(|chunk| {\n+                            Some(Constant::F32(f32::from_le_bytes(\n+                                chunk.try_into().expect(\"this shouldn't happen\"),\n+                            )))\n+                        })\n+                        .collect::<Option<Vec<Constant>>>()\n+                        .map(Constant::Vec),\n+                    _ => None,\n+                },\n+                ty::Float(FloatTy::F64) => match miri_to_const(len) {\n+                    Some(Constant::Int(len)) => alloc\n+                        .inspect_with_uninit_and_ptr_outside_interpreter(0..(8 * len as usize))\n+                        .to_owned()\n+                        .chunks(8)\n+                        .map(|chunk| {\n+                            Some(Constant::F64(f64::from_le_bytes(\n+                                chunk.try_into().expect(\"this shouldn't happen\"),\n+                            )))\n+                        })\n+                        .collect::<Option<Vec<Constant>>>()\n+                        .map(Constant::Vec),\n+                    _ => None,\n+                },\n+                // FIXME: implement other array type conversions.\n+                _ => None,\n+            },\n+            _ => None,\n+        },\n+        // FIXME: implement other conversions.\n+        _ => None,\n+    }\n+}"}, {"sha": "269be217c2d875bf3db450a39940705666154459", "filename": "clippy_utils/src/diagnostics.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fdiagnostics.rs?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "previous_filename": "clippy_lints/src/utils/diagnostics.rs"}, {"sha": "52a33e9b1704c300d8e1ffcf0bcdffcfd9071930", "filename": "clippy_utils/src/eager_or_lazy.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Feager_or_lazy.rs?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "patch": "@@ -9,7 +9,7 @@\n //!  - or-fun-call\n //!  - option-if-let-else\n \n-use crate::utils::{is_ctor_or_promotable_const_function, is_type_diagnostic_item, match_type, paths};\n+use crate::{is_ctor_or_promotable_const_function, is_type_diagnostic_item, match_type, paths};\n use rustc_hir::def::{DefKind, Res};\n \n use rustc_hir::intravisit;", "previous_filename": "clippy_lints/src/utils/eager_or_lazy.rs"}, {"sha": "be22df7109af792da83e68d6263cc14668572579", "filename": "clippy_utils/src/higher.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhigher.rs?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "patch": "@@ -3,7 +3,7 @@\n \n #![deny(clippy::missing_docs_in_private_items)]\n \n-use crate::utils::{is_expn_of, match_def_path, paths};\n+use crate::{is_expn_of, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_hir as hir;", "previous_filename": "clippy_lints/src/utils/higher.rs"}, {"sha": "81be9254cbe1a3db8aa180acc936c2e7c2055af9", "filename": "clippy_utils/src/hir_utils.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "patch": "@@ -1,5 +1,5 @@\n use crate::consts::{constant_context, constant_simple};\n-use crate::utils::differing_macro_contexts;\n+use crate::differing_macro_contexts;\n use rustc_ast::ast::InlineAsmTemplatePiece;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};", "previous_filename": "clippy_lints/src/utils/hir_utils.rs"}, {"sha": "5e0f0f084cbeb64915a55f0d68f6f269557557e4", "filename": "clippy_utils/src/lib.rs", "status": "added", "additions": 1886, "deletions": 0, "changes": 1886, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "patch": "@@ -0,0 +1,1886 @@\n+#![feature(box_patterns)]\n+#![feature(in_band_lifetimes)]\n+#![feature(once_cell)]\n+#![feature(or_patterns)]\n+#![feature(rustc_private)]\n+#![recursion_limit = \"512\"]\n+#![allow(clippy::missing_errors_doc, clippy::missing_panics_doc, clippy::must_use_candidate)]\n+\n+// FIXME: switch to something more ergonomic here, once available.\n+// (Currently there is no way to opt into sysroot crates without `extern crate`.)\n+extern crate rustc_ast;\n+extern crate rustc_ast_pretty;\n+extern crate rustc_data_structures;\n+extern crate rustc_errors;\n+extern crate rustc_hir;\n+extern crate rustc_hir_pretty;\n+extern crate rustc_infer;\n+extern crate rustc_lint;\n+extern crate rustc_middle;\n+extern crate rustc_mir;\n+extern crate rustc_session;\n+extern crate rustc_span;\n+extern crate rustc_target;\n+extern crate rustc_trait_selection;\n+extern crate rustc_typeck;\n+\n+#[macro_use]\n+pub mod sym_helper;\n+\n+#[allow(clippy::module_name_repetitions)]\n+pub mod ast_utils;\n+pub mod attrs;\n+pub mod camel_case;\n+pub mod comparisons;\n+pub mod conf;\n+pub mod consts;\n+mod diagnostics;\n+pub mod eager_or_lazy;\n+pub mod higher;\n+mod hir_utils;\n+pub mod numeric_literal;\n+pub mod paths;\n+pub mod ptr;\n+pub mod qualify_min_const_fn;\n+pub mod sugg;\n+pub mod usage;\n+pub mod visitors;\n+\n+pub use self::attrs::*;\n+pub use self::diagnostics::*;\n+pub use self::hir_utils::{both, eq_expr_value, over, SpanlessEq, SpanlessHash};\n+\n+use std::borrow::Cow;\n+use std::collections::hash_map::Entry;\n+use std::hash::BuildHasherDefault;\n+\n+use if_chain::if_chain;\n+use rustc_ast::ast::{self, Attribute, BorrowKind, LitKind, Mutability};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n+use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc_hir::Node;\n+use rustc_hir::{\n+    def, Arm, Block, Body, Constness, Crate, Expr, ExprKind, FnDecl, HirId, ImplItem, ImplItemKind, Item, ItemKind,\n+    MatchSource, Param, Pat, PatKind, Path, PathSegment, QPath, TraitItem, TraitItemKind, TraitRef, TyKind, Unsafety,\n+};\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_lint::{LateContext, Level, Lint, LintContext};\n+use rustc_middle::hir::exports::Export;\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n+use rustc_middle::ty::{self, layout::IntegerExt, DefIdTree, Ty, TyCtxt, TypeFoldable};\n+use rustc_semver::RustcVersion;\n+use rustc_session::Session;\n+use rustc_span::hygiene::{ExpnKind, MacroKind};\n+use rustc_span::source_map::original_sp;\n+use rustc_span::sym;\n+use rustc_span::symbol::{kw, Symbol};\n+use rustc_span::{BytePos, Pos, Span, DUMMY_SP};\n+use rustc_target::abi::Integer;\n+use rustc_trait_selection::traits::query::normalize::AtExt;\n+use smallvec::SmallVec;\n+\n+use crate::consts::{constant, Constant};\n+\n+pub fn parse_msrv(msrv: &str, sess: Option<&Session>, span: Option<Span>) -> Option<RustcVersion> {\n+    if let Ok(version) = RustcVersion::parse(msrv) {\n+        return Some(version);\n+    } else if let Some(sess) = sess {\n+        if let Some(span) = span {\n+            sess.span_err(span, &format!(\"`{}` is not a valid Rust version\", msrv));\n+        }\n+    }\n+    None\n+}\n+\n+pub fn meets_msrv(msrv: Option<&RustcVersion>, lint_msrv: &RustcVersion) -> bool {\n+    msrv.map_or(true, |msrv| msrv.meets(*lint_msrv))\n+}\n+\n+#[macro_export]\n+macro_rules! extract_msrv_attr {\n+    (LateContext) => {\n+        extract_msrv_attr!(@LateContext, ());\n+    };\n+    (EarlyContext) => {\n+        extract_msrv_attr!(@EarlyContext);\n+    };\n+    (@$context:ident$(, $call:tt)?) => {\n+        fn enter_lint_attrs(&mut self, cx: &rustc_lint::$context<'tcx>, attrs: &'tcx [rustc_ast::ast::Attribute]) {\n+            use $crate::get_unique_inner_attr;\n+            match get_unique_inner_attr(cx.sess$($call)?, attrs, \"msrv\") {\n+                Some(msrv_attr) => {\n+                    if let Some(msrv) = msrv_attr.value_str() {\n+                        self.msrv = $crate::parse_msrv(\n+                            &msrv.to_string(),\n+                            Some(cx.sess$($call)?),\n+                            Some(msrv_attr.span),\n+                        );\n+                    } else {\n+                        cx.sess$($call)?.span_err(msrv_attr.span, \"bad clippy attribute\");\n+                    }\n+                },\n+                _ => (),\n+            }\n+        }\n+    };\n+}\n+\n+/// Returns `true` if the two spans come from differing expansions (i.e., one is\n+/// from a macro and one isn't).\n+#[must_use]\n+pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n+    rhs.ctxt() != lhs.ctxt()\n+}\n+\n+/// Returns `true` if the given `NodeId` is inside a constant context\n+///\n+/// # Example\n+///\n+/// ```rust,ignore\n+/// if in_constant(cx, expr.hir_id) {\n+///     // Do something\n+/// }\n+/// ```\n+pub fn in_constant(cx: &LateContext<'_>, id: HirId) -> bool {\n+    let parent_id = cx.tcx.hir().get_parent_item(id);\n+    match cx.tcx.hir().get(parent_id) {\n+        Node::Item(&Item {\n+            kind: ItemKind::Const(..) | ItemKind::Static(..),\n+            ..\n+        })\n+        | Node::TraitItem(&TraitItem {\n+            kind: TraitItemKind::Const(..),\n+            ..\n+        })\n+        | Node::ImplItem(&ImplItem {\n+            kind: ImplItemKind::Const(..),\n+            ..\n+        })\n+        | Node::AnonConst(_) => true,\n+        Node::Item(&Item {\n+            kind: ItemKind::Fn(ref sig, ..),\n+            ..\n+        })\n+        | Node::ImplItem(&ImplItem {\n+            kind: ImplItemKind::Fn(ref sig, _),\n+            ..\n+        }) => sig.header.constness == Constness::Const,\n+        _ => false,\n+    }\n+}\n+\n+/// Returns `true` if this `span` was expanded by any macro.\n+#[must_use]\n+pub fn in_macro(span: Span) -> bool {\n+    if span.from_expansion() {\n+        !matches!(span.ctxt().outer_expn_data().kind, ExpnKind::Desugaring(..))\n+    } else {\n+        false\n+    }\n+}\n+\n+// If the snippet is empty, it's an attribute that was inserted during macro\n+// expansion and we want to ignore those, because they could come from external\n+// sources that the user has no control over.\n+// For some reason these attributes don't have any expansion info on them, so\n+// we have to check it this way until there is a better way.\n+pub fn is_present_in_source<T: LintContext>(cx: &T, span: Span) -> bool {\n+    if let Some(snippet) = snippet_opt(cx, span) {\n+        if snippet.is_empty() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+/// Checks if given pattern is a wildcard (`_`)\n+pub fn is_wild<'tcx>(pat: &impl std::ops::Deref<Target = Pat<'tcx>>) -> bool {\n+    matches!(pat.kind, PatKind::Wild)\n+}\n+\n+/// Checks if type is struct, enum or union type with the given def path.\n+///\n+/// If the type is a diagnostic item, use `is_type_diagnostic_item` instead.\n+/// If you change the signature, remember to update the internal lint `MatchTypeOnDiagItem`\n+pub fn match_type(cx: &LateContext<'_>, ty: Ty<'_>, path: &[&str]) -> bool {\n+    match ty.kind() {\n+        ty::Adt(adt, _) => match_def_path(cx, adt.did, path),\n+        _ => false,\n+    }\n+}\n+\n+/// Checks if the type is equal to a diagnostic item\n+///\n+/// If you change the signature, remember to update the internal lint `MatchTypeOnDiagItem`\n+pub fn is_type_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_item: Symbol) -> bool {\n+    match ty.kind() {\n+        ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(diag_item, adt.did),\n+        _ => false,\n+    }\n+}\n+\n+/// Checks if the type is equal to a lang item\n+pub fn is_type_lang_item(cx: &LateContext<'_>, ty: Ty<'_>, lang_item: hir::LangItem) -> bool {\n+    match ty.kind() {\n+        ty::Adt(adt, _) => cx.tcx.lang_items().require(lang_item).unwrap() == adt.did,\n+        _ => false,\n+    }\n+}\n+\n+/// Checks if the method call given in `expr` belongs to the given trait.\n+pub fn match_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, path: &[&str]) -> bool {\n+    let def_id = cx.typeck_results().type_dependent_def_id(expr.hir_id).unwrap();\n+    let trt_id = cx.tcx.trait_of_item(def_id);\n+    trt_id.map_or(false, |trt_id| match_def_path(cx, trt_id, path))\n+}\n+\n+/// Checks if an expression references a variable of the given name.\n+pub fn match_var(expr: &Expr<'_>, var: Symbol) -> bool {\n+    if let ExprKind::Path(QPath::Resolved(None, ref path)) = expr.kind {\n+        if let [p] = path.segments {\n+            return p.ident.name == var;\n+        }\n+    }\n+    false\n+}\n+\n+pub fn last_path_segment<'tcx>(path: &QPath<'tcx>) -> &'tcx PathSegment<'tcx> {\n+    match *path {\n+        QPath::Resolved(_, ref path) => path.segments.last().expect(\"A path must have at least one segment\"),\n+        QPath::TypeRelative(_, ref seg) => seg,\n+        QPath::LangItem(..) => panic!(\"last_path_segment: lang item has no path segments\"),\n+    }\n+}\n+\n+pub fn single_segment_path<'tcx>(path: &QPath<'tcx>) -> Option<&'tcx PathSegment<'tcx>> {\n+    match *path {\n+        QPath::Resolved(_, ref path) => path.segments.get(0),\n+        QPath::TypeRelative(_, ref seg) => Some(seg),\n+        QPath::LangItem(..) => None,\n+    }\n+}\n+\n+/// Matches a `QPath` against a slice of segment string literals.\n+///\n+/// There is also `match_path` if you are dealing with a `rustc_hir::Path` instead of a\n+/// `rustc_hir::QPath`.\n+///\n+/// # Examples\n+/// ```rust,ignore\n+/// match_qpath(path, &[\"std\", \"rt\", \"begin_unwind\"])\n+/// ```\n+pub fn match_qpath(path: &QPath<'_>, segments: &[&str]) -> bool {\n+    match *path {\n+        QPath::Resolved(_, ref path) => match_path(path, segments),\n+        QPath::TypeRelative(ref ty, ref segment) => match ty.kind {\n+            TyKind::Path(ref inner_path) => {\n+                if let [prefix @ .., end] = segments {\n+                    if match_qpath(inner_path, prefix) {\n+                        return segment.ident.name.as_str() == *end;\n+                    }\n+                }\n+                false\n+            },\n+            _ => false,\n+        },\n+        QPath::LangItem(..) => false,\n+    }\n+}\n+\n+/// Matches a `Path` against a slice of segment string literals.\n+///\n+/// There is also `match_qpath` if you are dealing with a `rustc_hir::QPath` instead of a\n+/// `rustc_hir::Path`.\n+///\n+/// # Examples\n+///\n+/// ```rust,ignore\n+/// if match_path(&trait_ref.path, &paths::HASH) {\n+///     // This is the `std::hash::Hash` trait.\n+/// }\n+///\n+/// if match_path(ty_path, &[\"rustc\", \"lint\", \"Lint\"]) {\n+///     // This is a `rustc_middle::lint::Lint`.\n+/// }\n+/// ```\n+pub fn match_path(path: &Path<'_>, segments: &[&str]) -> bool {\n+    path.segments\n+        .iter()\n+        .rev()\n+        .zip(segments.iter().rev())\n+        .all(|(a, b)| a.ident.name.as_str() == *b)\n+}\n+\n+/// Matches a `Path` against a slice of segment string literals, e.g.\n+///\n+/// # Examples\n+/// ```rust,ignore\n+/// match_path_ast(path, &[\"std\", \"rt\", \"begin_unwind\"])\n+/// ```\n+pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n+    path.segments\n+        .iter()\n+        .rev()\n+        .zip(segments.iter().rev())\n+        .all(|(a, b)| a.ident.name.as_str() == *b)\n+}\n+\n+/// If the expression is a path to a local, returns the canonical `HirId` of the local.\n+pub fn path_to_local(expr: &Expr<'_>) -> Option<HirId> {\n+    if let ExprKind::Path(QPath::Resolved(None, ref path)) = expr.kind {\n+        if let Res::Local(id) = path.res {\n+            return Some(id);\n+        }\n+    }\n+    None\n+}\n+\n+/// Returns true if the expression is a path to a local with the specified `HirId`.\n+/// Use this function to see if an expression matches a function argument or a match binding.\n+pub fn path_to_local_id(expr: &Expr<'_>, id: HirId) -> bool {\n+    path_to_local(expr) == Some(id)\n+}\n+\n+/// Gets the definition associated to a path.\n+#[allow(clippy::shadow_unrelated)] // false positive #6563\n+pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n+    macro_rules! try_res {\n+        ($e:expr) => {\n+            match $e {\n+                Some(e) => e,\n+                None => return Res::Err,\n+            }\n+        };\n+    }\n+    fn item_child_by_name<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, name: &str) -> Option<&'tcx Export<HirId>> {\n+        tcx.item_children(def_id)\n+            .iter()\n+            .find(|item| item.ident.name.as_str() == name)\n+    }\n+\n+    let (krate, first, path) = match *path {\n+        [krate, first, ref path @ ..] => (krate, first, path),\n+        _ => return Res::Err,\n+    };\n+    let tcx = cx.tcx;\n+    let crates = tcx.crates();\n+    let krate = try_res!(crates.iter().find(|&&num| tcx.crate_name(num).as_str() == krate));\n+    let first = try_res!(item_child_by_name(tcx, krate.as_def_id(), first));\n+    let last = path\n+        .iter()\n+        .copied()\n+        // `get_def_path` seems to generate these empty segments for extern blocks.\n+        // We can just ignore them.\n+        .filter(|segment| !segment.is_empty())\n+        // for each segment, find the child item\n+        .try_fold(first, |item, segment| {\n+            let def_id = item.res.def_id();\n+            if let Some(item) = item_child_by_name(tcx, def_id, segment) {\n+                Some(item)\n+            } else if matches!(item.res, Res::Def(DefKind::Enum | DefKind::Struct, _)) {\n+                // it is not a child item so check inherent impl items\n+                tcx.inherent_impls(def_id)\n+                    .iter()\n+                    .find_map(|&impl_def_id| item_child_by_name(tcx, impl_def_id, segment))\n+            } else {\n+                None\n+            }\n+        });\n+    try_res!(last).res\n+}\n+\n+/// Convenience function to get the `DefId` of a trait by path.\n+/// It could be a trait or trait alias.\n+pub fn get_trait_def_id(cx: &LateContext<'_>, path: &[&str]) -> Option<DefId> {\n+    match path_to_res(cx, path) {\n+        Res::Def(DefKind::Trait | DefKind::TraitAlias, trait_id) => Some(trait_id),\n+        _ => None,\n+    }\n+}\n+\n+/// Checks whether a type implements a trait.\n+/// See also `get_trait_def_id`.\n+pub fn implements_trait<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    ty: Ty<'tcx>,\n+    trait_id: DefId,\n+    ty_params: &[GenericArg<'tcx>],\n+) -> bool {\n+    // Do not check on infer_types to avoid panic in evaluate_obligation.\n+    if ty.has_infer_types() {\n+        return false;\n+    }\n+    let ty = cx.tcx.erase_regions(ty);\n+    if ty.has_escaping_bound_vars() {\n+        return false;\n+    }\n+    let ty_params = cx.tcx.mk_substs(ty_params.iter());\n+    cx.tcx.type_implements_trait((trait_id, ty, ty_params, cx.param_env))\n+}\n+\n+/// Gets the `hir::TraitRef` of the trait the given method is implemented for.\n+///\n+/// Use this if you want to find the `TraitRef` of the `Add` trait in this example:\n+///\n+/// ```rust\n+/// struct Point(isize, isize);\n+///\n+/// impl std::ops::Add for Point {\n+///     type Output = Self;\n+///\n+///     fn add(self, other: Self) -> Self {\n+///         Point(0, 0)\n+///     }\n+/// }\n+/// ```\n+pub fn trait_ref_of_method<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Option<&'tcx TraitRef<'tcx>> {\n+    // Get the implemented trait for the current function\n+    let parent_impl = cx.tcx.hir().get_parent_item(hir_id);\n+    if_chain! {\n+        if parent_impl != hir::CRATE_HIR_ID;\n+        if let hir::Node::Item(item) = cx.tcx.hir().get(parent_impl);\n+        if let hir::ItemKind::Impl(impl_) = &item.kind;\n+        then { return impl_.of_trait.as_ref(); }\n+    }\n+    None\n+}\n+\n+/// Checks whether this type implements `Drop`.\n+pub fn has_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+    match ty.ty_adt_def() {\n+        Some(def) => def.has_dtor(cx.tcx),\n+        None => false,\n+    }\n+}\n+\n+/// Returns the method names and argument list of nested method call expressions that make up\n+/// `expr`. method/span lists are sorted with the most recent call first.\n+pub fn method_calls<'tcx>(\n+    expr: &'tcx Expr<'tcx>,\n+    max_depth: usize,\n+) -> (Vec<Symbol>, Vec<&'tcx [Expr<'tcx>]>, Vec<Span>) {\n+    let mut method_names = Vec::with_capacity(max_depth);\n+    let mut arg_lists = Vec::with_capacity(max_depth);\n+    let mut spans = Vec::with_capacity(max_depth);\n+\n+    let mut current = expr;\n+    for _ in 0..max_depth {\n+        if let ExprKind::MethodCall(path, span, args, _) = &current.kind {\n+            if args.iter().any(|e| e.span.from_expansion()) {\n+                break;\n+            }\n+            method_names.push(path.ident.name);\n+            arg_lists.push(&**args);\n+            spans.push(*span);\n+            current = &args[0];\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    (method_names, arg_lists, spans)\n+}\n+\n+/// Matches an `Expr` against a chain of methods, and return the matched `Expr`s.\n+///\n+/// For example, if `expr` represents the `.baz()` in `foo.bar().baz()`,\n+/// `method_chain_args(expr, &[\"bar\", \"baz\"])` will return a `Vec`\n+/// containing the `Expr`s for\n+/// `.bar()` and `.baz()`\n+pub fn method_chain_args<'a>(expr: &'a Expr<'_>, methods: &[&str]) -> Option<Vec<&'a [Expr<'a>]>> {\n+    let mut current = expr;\n+    let mut matched = Vec::with_capacity(methods.len());\n+    for method_name in methods.iter().rev() {\n+        // method chains are stored last -> first\n+        if let ExprKind::MethodCall(ref path, _, ref args, _) = current.kind {\n+            if path.ident.name.as_str() == *method_name {\n+                if args.iter().any(|e| e.span.from_expansion()) {\n+                    return None;\n+                }\n+                matched.push(&**args); // build up `matched` backwards\n+                current = &args[0] // go to parent expression\n+            } else {\n+                return None;\n+            }\n+        } else {\n+            return None;\n+        }\n+    }\n+    // Reverse `matched` so that it is in the same order as `methods`.\n+    matched.reverse();\n+    Some(matched)\n+}\n+\n+/// Returns `true` if the provided `def_id` is an entrypoint to a program.\n+pub fn is_entrypoint_fn(cx: &LateContext<'_>, def_id: DefId) -> bool {\n+    cx.tcx\n+        .entry_fn(LOCAL_CRATE)\n+        .map_or(false, |(entry_fn_def_id, _)| def_id == entry_fn_def_id.to_def_id())\n+}\n+\n+/// Returns `true` if the expression is in the program's `#[panic_handler]`.\n+pub fn is_in_panic_handler(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n+    let parent = cx.tcx.hir().get_parent_item(e.hir_id);\n+    let def_id = cx.tcx.hir().local_def_id(parent).to_def_id();\n+    Some(def_id) == cx.tcx.lang_items().panic_impl()\n+}\n+\n+/// Gets the name of the item the expression is in, if available.\n+pub fn get_item_name(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<Symbol> {\n+    let parent_id = cx.tcx.hir().get_parent_item(expr.hir_id);\n+    match cx.tcx.hir().find(parent_id) {\n+        Some(\n+            Node::Item(Item { ident, .. })\n+            | Node::TraitItem(TraitItem { ident, .. })\n+            | Node::ImplItem(ImplItem { ident, .. }),\n+        ) => Some(ident.name),\n+        _ => None,\n+    }\n+}\n+\n+/// Gets the name of a `Pat`, if any.\n+pub fn get_pat_name(pat: &Pat<'_>) -> Option<Symbol> {\n+    match pat.kind {\n+        PatKind::Binding(.., ref spname, _) => Some(spname.name),\n+        PatKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.ident.name),\n+        PatKind::Box(ref p) | PatKind::Ref(ref p, _) => get_pat_name(&*p),\n+        _ => None,\n+    }\n+}\n+\n+struct ContainsName {\n+    name: Symbol,\n+    result: bool,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for ContainsName {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_name(&mut self, _: Span, name: Symbol) {\n+        if self.name == name {\n+            self.result = true;\n+        }\n+    }\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+/// Checks if an `Expr` contains a certain name.\n+pub fn contains_name(name: Symbol, expr: &Expr<'_>) -> bool {\n+    let mut cn = ContainsName { name, result: false };\n+    cn.visit_expr(expr);\n+    cn.result\n+}\n+\n+/// Returns `true` if `expr` contains a return expression\n+pub fn contains_return(expr: &hir::Expr<'_>) -> bool {\n+    struct RetCallFinder {\n+        found: bool,\n+    }\n+\n+    impl<'tcx> hir::intravisit::Visitor<'tcx> for RetCallFinder {\n+        type Map = Map<'tcx>;\n+\n+        fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n+            if self.found {\n+                return;\n+            }\n+            if let hir::ExprKind::Ret(..) = &expr.kind {\n+                self.found = true;\n+            } else {\n+                hir::intravisit::walk_expr(self, expr);\n+            }\n+        }\n+\n+        fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<Self::Map> {\n+            hir::intravisit::NestedVisitorMap::None\n+        }\n+    }\n+\n+    let mut visitor = RetCallFinder { found: false };\n+    visitor.visit_expr(expr);\n+    visitor.found\n+}\n+\n+struct FindMacroCalls<'a, 'b> {\n+    names: &'a [&'b str],\n+    result: Vec<Span>,\n+}\n+\n+impl<'a, 'b, 'tcx> Visitor<'tcx> for FindMacroCalls<'a, 'b> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if self.names.iter().any(|fun| is_expn_of(expr.span, fun).is_some()) {\n+            self.result.push(expr.span);\n+        }\n+        // and check sub-expressions\n+        intravisit::walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+/// Finds calls of the specified macros in a function body.\n+pub fn find_macro_calls(names: &[&str], body: &Body<'_>) -> Vec<Span> {\n+    let mut fmc = FindMacroCalls {\n+        names,\n+        result: Vec::new(),\n+    };\n+    fmc.visit_expr(&body.value);\n+    fmc.result\n+}\n+\n+/// Converts a span to a code snippet if available, otherwise use default.\n+///\n+/// This is useful if you want to provide suggestions for your lint or more generally, if you want\n+/// to convert a given `Span` to a `str`.\n+///\n+/// # Example\n+/// ```rust,ignore\n+/// snippet(cx, expr.span, \"..\")\n+/// ```\n+pub fn snippet<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n+    snippet_opt(cx, span).map_or_else(|| Cow::Borrowed(default), From::from)\n+}\n+\n+/// Same as `snippet`, but it adapts the applicability level by following rules:\n+///\n+/// - Applicability level `Unspecified` will never be changed.\n+/// - If the span is inside a macro, change the applicability level to `MaybeIncorrect`.\n+/// - If the default value is used and the applicability level is `MachineApplicable`, change it to\n+/// `HasPlaceholders`\n+pub fn snippet_with_applicability<'a, T: LintContext>(\n+    cx: &T,\n+    span: Span,\n+    default: &'a str,\n+    applicability: &mut Applicability,\n+) -> Cow<'a, str> {\n+    if *applicability != Applicability::Unspecified && span.from_expansion() {\n+        *applicability = Applicability::MaybeIncorrect;\n+    }\n+    snippet_opt(cx, span).map_or_else(\n+        || {\n+            if *applicability == Applicability::MachineApplicable {\n+                *applicability = Applicability::HasPlaceholders;\n+            }\n+            Cow::Borrowed(default)\n+        },\n+        From::from,\n+    )\n+}\n+\n+/// Same as `snippet`, but should only be used when it's clear that the input span is\n+/// not a macro argument.\n+pub fn snippet_with_macro_callsite<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n+    snippet(cx, span.source_callsite(), default)\n+}\n+\n+/// Converts a span to a code snippet. Returns `None` if not available.\n+pub fn snippet_opt<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n+    cx.sess().source_map().span_to_snippet(span).ok()\n+}\n+\n+/// Converts a span (from a block) to a code snippet if available, otherwise use default.\n+///\n+/// This trims the code of indentation, except for the first line. Use it for blocks or block-like\n+/// things which need to be printed as such.\n+///\n+/// The `indent_relative_to` arg can be used, to provide a span, where the indentation of the\n+/// resulting snippet of the given span.\n+///\n+/// # Example\n+///\n+/// ```rust,ignore\n+/// snippet_block(cx, block.span, \"..\", None)\n+/// // where, `block` is the block of the if expr\n+///     if x {\n+///         y;\n+///     }\n+/// // will return the snippet\n+/// {\n+///     y;\n+/// }\n+/// ```\n+///\n+/// ```rust,ignore\n+/// snippet_block(cx, block.span, \"..\", Some(if_expr.span))\n+/// // where, `block` is the block of the if expr\n+///     if x {\n+///         y;\n+///     }\n+/// // will return the snippet\n+/// {\n+///         y;\n+///     } // aligned with `if`\n+/// ```\n+/// Note that the first line of the snippet always has 0 indentation.\n+pub fn snippet_block<'a, T: LintContext>(\n+    cx: &T,\n+    span: Span,\n+    default: &'a str,\n+    indent_relative_to: Option<Span>,\n+) -> Cow<'a, str> {\n+    let snip = snippet(cx, span, default);\n+    let indent = indent_relative_to.and_then(|s| indent_of(cx, s));\n+    reindent_multiline(snip, true, indent)\n+}\n+\n+/// Same as `snippet_block`, but adapts the applicability level by the rules of\n+/// `snippet_with_applicability`.\n+pub fn snippet_block_with_applicability<'a, T: LintContext>(\n+    cx: &T,\n+    span: Span,\n+    default: &'a str,\n+    indent_relative_to: Option<Span>,\n+    applicability: &mut Applicability,\n+) -> Cow<'a, str> {\n+    let snip = snippet_with_applicability(cx, span, default, applicability);\n+    let indent = indent_relative_to.and_then(|s| indent_of(cx, s));\n+    reindent_multiline(snip, true, indent)\n+}\n+\n+/// Returns a new Span that extends the original Span to the first non-whitespace char of the first\n+/// line.\n+///\n+/// ```rust,ignore\n+///     let x = ();\n+/// //          ^^\n+/// // will be converted to\n+///     let x = ();\n+/// //  ^^^^^^^^^^\n+/// ```\n+pub fn first_line_of_span<T: LintContext>(cx: &T, span: Span) -> Span {\n+    first_char_in_first_line(cx, span).map_or(span, |first_char_pos| span.with_lo(first_char_pos))\n+}\n+\n+fn first_char_in_first_line<T: LintContext>(cx: &T, span: Span) -> Option<BytePos> {\n+    let line_span = line_span(cx, span);\n+    snippet_opt(cx, line_span).and_then(|snip| {\n+        snip.find(|c: char| !c.is_whitespace())\n+            .map(|pos| line_span.lo() + BytePos::from_usize(pos))\n+    })\n+}\n+\n+/// Returns the indentation of the line of a span\n+///\n+/// ```rust,ignore\n+/// let x = ();\n+/// //      ^^ -- will return 0\n+///     let x = ();\n+/// //          ^^ -- will return 4\n+/// ```\n+pub fn indent_of<T: LintContext>(cx: &T, span: Span) -> Option<usize> {\n+    snippet_opt(cx, line_span(cx, span)).and_then(|snip| snip.find(|c: char| !c.is_whitespace()))\n+}\n+\n+/// Returns the positon just before rarrow\n+///\n+/// ```rust,ignore\n+/// fn into(self) -> () {}\n+///              ^\n+/// // in case of unformatted code\n+/// fn into2(self)-> () {}\n+///               ^\n+/// fn into3(self)   -> () {}\n+///               ^\n+/// ```\n+pub fn position_before_rarrow(s: &str) -> Option<usize> {\n+    s.rfind(\"->\").map(|rpos| {\n+        let mut rpos = rpos;\n+        let chars: Vec<char> = s.chars().collect();\n+        while rpos > 1 {\n+            if let Some(c) = chars.get(rpos - 1) {\n+                if c.is_whitespace() {\n+                    rpos -= 1;\n+                    continue;\n+                }\n+            }\n+            break;\n+        }\n+        rpos\n+    })\n+}\n+\n+/// Extends the span to the beginning of the spans line, incl. whitespaces.\n+///\n+/// ```rust,ignore\n+///        let x = ();\n+/// //             ^^\n+/// // will be converted to\n+///        let x = ();\n+/// // ^^^^^^^^^^^^^^\n+/// ```\n+fn line_span<T: LintContext>(cx: &T, span: Span) -> Span {\n+    let span = original_sp(span, DUMMY_SP);\n+    let source_map_and_line = cx.sess().source_map().lookup_line(span.lo()).unwrap();\n+    let line_no = source_map_and_line.line;\n+    let line_start = source_map_and_line.sf.lines[line_no];\n+    Span::new(line_start, span.hi(), span.ctxt())\n+}\n+\n+/// Like `snippet_block`, but add braces if the expr is not an `ExprKind::Block`.\n+/// Also takes an `Option<String>` which can be put inside the braces.\n+pub fn expr_block<'a, T: LintContext>(\n+    cx: &T,\n+    expr: &Expr<'_>,\n+    option: Option<String>,\n+    default: &'a str,\n+    indent_relative_to: Option<Span>,\n+) -> Cow<'a, str> {\n+    let code = snippet_block(cx, expr.span, default, indent_relative_to);\n+    let string = option.unwrap_or_default();\n+    if expr.span.from_expansion() {\n+        Cow::Owned(format!(\"{{ {} }}\", snippet_with_macro_callsite(cx, expr.span, default)))\n+    } else if let ExprKind::Block(_, _) = expr.kind {\n+        Cow::Owned(format!(\"{}{}\", code, string))\n+    } else if string.is_empty() {\n+        Cow::Owned(format!(\"{{ {} }}\", code))\n+    } else {\n+        Cow::Owned(format!(\"{{\\n{};\\n{}\\n}}\", code, string))\n+    }\n+}\n+\n+/// Reindent a multiline string with possibility of ignoring the first line.\n+#[allow(clippy::needless_pass_by_value)]\n+pub fn reindent_multiline(s: Cow<'_, str>, ignore_first: bool, indent: Option<usize>) -> Cow<'_, str> {\n+    let s_space = reindent_multiline_inner(&s, ignore_first, indent, ' ');\n+    let s_tab = reindent_multiline_inner(&s_space, ignore_first, indent, '\\t');\n+    reindent_multiline_inner(&s_tab, ignore_first, indent, ' ').into()\n+}\n+\n+fn reindent_multiline_inner(s: &str, ignore_first: bool, indent: Option<usize>, ch: char) -> String {\n+    let x = s\n+        .lines()\n+        .skip(ignore_first as usize)\n+        .filter_map(|l| {\n+            if l.is_empty() {\n+                None\n+            } else {\n+                // ignore empty lines\n+                Some(l.char_indices().find(|&(_, x)| x != ch).unwrap_or((l.len(), ch)).0)\n+            }\n+        })\n+        .min()\n+        .unwrap_or(0);\n+    let indent = indent.unwrap_or(0);\n+    s.lines()\n+        .enumerate()\n+        .map(|(i, l)| {\n+            if (ignore_first && i == 0) || l.is_empty() {\n+                l.to_owned()\n+            } else if x > indent {\n+                l.split_at(x - indent).1.to_owned()\n+            } else {\n+                \" \".repeat(indent - x) + l\n+            }\n+        })\n+        .collect::<Vec<String>>()\n+        .join(\"\\n\")\n+}\n+\n+/// Gets the parent expression, if any \u2013- this is useful to constrain a lint.\n+pub fn get_parent_expr<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    let map = &cx.tcx.hir();\n+    let hir_id = e.hir_id;\n+    let parent_id = map.get_parent_node(hir_id);\n+    if hir_id == parent_id {\n+        return None;\n+    }\n+    map.find(parent_id).and_then(|node| {\n+        if let Node::Expr(parent) = node {\n+            Some(parent)\n+        } else {\n+            None\n+        }\n+    })\n+}\n+\n+pub fn get_enclosing_block<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Option<&'tcx Block<'tcx>> {\n+    let map = &cx.tcx.hir();\n+    let enclosing_node = map\n+        .get_enclosing_scope(hir_id)\n+        .and_then(|enclosing_id| map.find(enclosing_id));\n+    enclosing_node.and_then(|node| match node {\n+        Node::Block(block) => Some(block),\n+        Node::Item(&Item {\n+            kind: ItemKind::Fn(_, _, eid),\n+            ..\n+        })\n+        | Node::ImplItem(&ImplItem {\n+            kind: ImplItemKind::Fn(_, eid),\n+            ..\n+        }) => match cx.tcx.hir().body(eid).value.kind {\n+            ExprKind::Block(ref block, _) => Some(block),\n+            _ => None,\n+        },\n+        _ => None,\n+    })\n+}\n+\n+/// Returns the base type for HIR references and pointers.\n+pub fn walk_ptrs_hir_ty<'tcx>(ty: &'tcx hir::Ty<'tcx>) -> &'tcx hir::Ty<'tcx> {\n+    match ty.kind {\n+        TyKind::Ptr(ref mut_ty) | TyKind::Rptr(_, ref mut_ty) => walk_ptrs_hir_ty(&mut_ty.ty),\n+        _ => ty,\n+    }\n+}\n+\n+/// Returns the base type for references and raw pointers, and count reference\n+/// depth.\n+pub fn walk_ptrs_ty_depth(ty: Ty<'_>) -> (Ty<'_>, usize) {\n+    fn inner(ty: Ty<'_>, depth: usize) -> (Ty<'_>, usize) {\n+        match ty.kind() {\n+            ty::Ref(_, ty, _) => inner(ty, depth + 1),\n+            _ => (ty, depth),\n+        }\n+    }\n+    inner(ty, 0)\n+}\n+\n+/// Checks whether the given expression is a constant integer of the given value.\n+/// unlike `is_integer_literal`, this version does const folding\n+pub fn is_integer_const(cx: &LateContext<'_>, e: &Expr<'_>, value: u128) -> bool {\n+    if is_integer_literal(e, value) {\n+        return true;\n+    }\n+    let map = cx.tcx.hir();\n+    let parent_item = map.get_parent_item(e.hir_id);\n+    if let Some((Constant::Int(v), _)) = map\n+        .maybe_body_owned_by(parent_item)\n+        .and_then(|body_id| constant(cx, cx.tcx.typeck_body(body_id), e))\n+    {\n+        value == v\n+    } else {\n+        false\n+    }\n+}\n+\n+/// Checks whether the given expression is a constant literal of the given value.\n+pub fn is_integer_literal(expr: &Expr<'_>, value: u128) -> bool {\n+    // FIXME: use constant folding\n+    if let ExprKind::Lit(ref spanned) = expr.kind {\n+        if let LitKind::Int(v, _) = spanned.node {\n+            return v == value;\n+        }\n+    }\n+    false\n+}\n+\n+/// Returns `true` if the given `Expr` has been coerced before.\n+///\n+/// Examples of coercions can be found in the Nomicon at\n+/// <https://doc.rust-lang.org/nomicon/coercions.html>.\n+///\n+/// See `rustc_middle::ty::adjustment::Adjustment` and `rustc_typeck::check::coercion` for more\n+/// information on adjustments and coercions.\n+pub fn is_adjusted(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n+    cx.typeck_results().adjustments().get(e.hir_id).is_some()\n+}\n+\n+/// Returns the pre-expansion span if is this comes from an expansion of the\n+/// macro `name`.\n+/// See also `is_direct_expn_of`.\n+#[must_use]\n+pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n+    loop {\n+        if span.from_expansion() {\n+            let data = span.ctxt().outer_expn_data();\n+            let new_span = data.call_site;\n+\n+            if let ExpnKind::Macro(MacroKind::Bang, mac_name) = data.kind {\n+                if mac_name.as_str() == name {\n+                    return Some(new_span);\n+                }\n+            }\n+\n+            span = new_span;\n+        } else {\n+            return None;\n+        }\n+    }\n+}\n+\n+/// Returns the pre-expansion span if the span directly comes from an expansion\n+/// of the macro `name`.\n+/// The difference with `is_expn_of` is that in\n+/// ```rust,ignore\n+/// foo!(bar!(42));\n+/// ```\n+/// `42` is considered expanded from `foo!` and `bar!` by `is_expn_of` but only\n+/// `bar!` by\n+/// `is_direct_expn_of`.\n+#[must_use]\n+pub fn is_direct_expn_of(span: Span, name: &str) -> Option<Span> {\n+    if span.from_expansion() {\n+        let data = span.ctxt().outer_expn_data();\n+        let new_span = data.call_site;\n+\n+        if let ExpnKind::Macro(MacroKind::Bang, mac_name) = data.kind {\n+            if mac_name.as_str() == name {\n+                return Some(new_span);\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+/// Convenience function to get the return type of a function.\n+pub fn return_ty<'tcx>(cx: &LateContext<'tcx>, fn_item: hir::HirId) -> Ty<'tcx> {\n+    let fn_def_id = cx.tcx.hir().local_def_id(fn_item);\n+    let ret_ty = cx.tcx.fn_sig(fn_def_id).output();\n+    cx.tcx.erase_late_bound_regions(ret_ty)\n+}\n+\n+/// Walks into `ty` and returns `true` if any inner type is the same as `other_ty`\n+pub fn contains_ty(ty: Ty<'_>, other_ty: Ty<'_>) -> bool {\n+    ty.walk().any(|inner| match inner.unpack() {\n+        GenericArgKind::Type(inner_ty) => ty::TyS::same_type(other_ty, inner_ty),\n+        GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => false,\n+    })\n+}\n+\n+/// Returns `true` if the given type is an `unsafe` function.\n+pub fn type_is_unsafe_function<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+    match ty.kind() {\n+        ty::FnDef(..) | ty::FnPtr(_) => ty.fn_sig(cx.tcx).unsafety() == Unsafety::Unsafe,\n+        _ => false,\n+    }\n+}\n+\n+pub fn is_copy<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+    ty.is_copy_modulo_regions(cx.tcx.at(DUMMY_SP), cx.param_env)\n+}\n+\n+/// Checks if an expression is constructing a tuple-like enum variant or struct\n+pub fn is_ctor_or_promotable_const_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    if let ExprKind::Call(ref fun, _) = expr.kind {\n+        if let ExprKind::Path(ref qp) = fun.kind {\n+            let res = cx.qpath_res(qp, fun.hir_id);\n+            return match res {\n+                def::Res::Def(DefKind::Variant | DefKind::Ctor(..), ..) => true,\n+                def::Res::Def(_, def_id) => cx.tcx.is_promotable_const_fn(def_id),\n+                _ => false,\n+            };\n+        }\n+    }\n+    false\n+}\n+\n+/// Returns `true` if a pattern is refutable.\n+// TODO: should be implemented using rustc/mir_build/thir machinery\n+pub fn is_refutable(cx: &LateContext<'_>, pat: &Pat<'_>) -> bool {\n+    fn is_enum_variant(cx: &LateContext<'_>, qpath: &QPath<'_>, id: HirId) -> bool {\n+        matches!(\n+            cx.qpath_res(qpath, id),\n+            def::Res::Def(DefKind::Variant, ..) | Res::Def(DefKind::Ctor(def::CtorOf::Variant, _), _)\n+        )\n+    }\n+\n+    fn are_refutable<'a, I: Iterator<Item = &'a Pat<'a>>>(cx: &LateContext<'_>, mut i: I) -> bool {\n+        i.any(|pat| is_refutable(cx, pat))\n+    }\n+\n+    match pat.kind {\n+        PatKind::Wild => false,\n+        PatKind::Binding(_, _, _, pat) => pat.map_or(false, |pat| is_refutable(cx, pat)),\n+        PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => is_refutable(cx, pat),\n+        PatKind::Lit(..) | PatKind::Range(..) => true,\n+        PatKind::Path(ref qpath) => is_enum_variant(cx, qpath, pat.hir_id),\n+        PatKind::Or(ref pats) => {\n+            // TODO: should be the honest check, that pats is exhaustive set\n+            are_refutable(cx, pats.iter().map(|pat| &**pat))\n+        },\n+        PatKind::Tuple(ref pats, _) => are_refutable(cx, pats.iter().map(|pat| &**pat)),\n+        PatKind::Struct(ref qpath, ref fields, _) => {\n+            is_enum_variant(cx, qpath, pat.hir_id) || are_refutable(cx, fields.iter().map(|field| &*field.pat))\n+        },\n+        PatKind::TupleStruct(ref qpath, ref pats, _) => {\n+            is_enum_variant(cx, qpath, pat.hir_id) || are_refutable(cx, pats.iter().map(|pat| &**pat))\n+        },\n+        PatKind::Slice(ref head, ref middle, ref tail) => {\n+            match &cx.typeck_results().node_type(pat.hir_id).kind() {\n+                ty::Slice(..) => {\n+                    // [..] is the only irrefutable slice pattern.\n+                    !head.is_empty() || middle.is_none() || !tail.is_empty()\n+                },\n+                ty::Array(..) => are_refutable(cx, head.iter().chain(middle).chain(tail.iter()).map(|pat| &**pat)),\n+                _ => {\n+                    // unreachable!()\n+                    true\n+                },\n+            }\n+        },\n+    }\n+}\n+\n+/// Checks for the `#[automatically_derived]` attribute all `#[derive]`d\n+/// implementations have.\n+pub fn is_automatically_derived(attrs: &[ast::Attribute]) -> bool {\n+    attrs.iter().any(|attr| attr.has_name(sym::automatically_derived))\n+}\n+\n+/// Remove blocks around an expression.\n+///\n+/// Ie. `x`, `{ x }` and `{{{{ x }}}}` all give `x`. `{ x; y }` and `{}` return\n+/// themselves.\n+pub fn remove_blocks<'tcx>(mut expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n+    while let ExprKind::Block(ref block, ..) = expr.kind {\n+        match (block.stmts.is_empty(), block.expr.as_ref()) {\n+            (true, Some(e)) => expr = e,\n+            _ => break,\n+        }\n+    }\n+    expr\n+}\n+\n+pub fn is_self(slf: &Param<'_>) -> bool {\n+    if let PatKind::Binding(.., name, _) = slf.pat.kind {\n+        name.name == kw::SelfLower\n+    } else {\n+        false\n+    }\n+}\n+\n+pub fn is_self_ty(slf: &hir::Ty<'_>) -> bool {\n+    if_chain! {\n+        if let TyKind::Path(QPath::Resolved(None, ref path)) = slf.kind;\n+        if let Res::SelfTy(..) = path.res;\n+        then {\n+            return true\n+        }\n+    }\n+    false\n+}\n+\n+pub fn iter_input_pats<'tcx>(decl: &FnDecl<'_>, body: &'tcx Body<'_>) -> impl Iterator<Item = &'tcx Param<'tcx>> {\n+    (0..decl.inputs.len()).map(move |i| &body.params[i])\n+}\n+\n+/// Checks if a given expression is a match expression expanded from the `?`\n+/// operator or the `try` macro.\n+pub fn is_try<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n+    fn is_ok(arm: &Arm<'_>) -> bool {\n+        if_chain! {\n+            if let PatKind::TupleStruct(ref path, ref pat, None) = arm.pat.kind;\n+            if match_qpath(path, &paths::RESULT_OK[1..]);\n+            if let PatKind::Binding(_, hir_id, _, None) = pat[0].kind;\n+            if path_to_local_id(arm.body, hir_id);\n+            then {\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+\n+    fn is_err(arm: &Arm<'_>) -> bool {\n+        if let PatKind::TupleStruct(ref path, _, _) = arm.pat.kind {\n+            match_qpath(path, &paths::RESULT_ERR[1..])\n+        } else {\n+            false\n+        }\n+    }\n+\n+    if let ExprKind::Match(_, ref arms, ref source) = expr.kind {\n+        // desugared from a `?` operator\n+        if let MatchSource::TryDesugar = *source {\n+            return Some(expr);\n+        }\n+\n+        if_chain! {\n+            if arms.len() == 2;\n+            if arms[0].guard.is_none();\n+            if arms[1].guard.is_none();\n+            if (is_ok(&arms[0]) && is_err(&arms[1])) ||\n+                (is_ok(&arms[1]) && is_err(&arms[0]));\n+            then {\n+                return Some(expr);\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+/// Returns `true` if the lint is allowed in the current context\n+///\n+/// Useful for skipping long running code when it's unnecessary\n+pub fn is_allowed(cx: &LateContext<'_>, lint: &'static Lint, id: HirId) -> bool {\n+    cx.tcx.lint_level_at_node(lint, id).0 == Level::Allow\n+}\n+\n+pub fn strip_pat_refs<'hir>(mut pat: &'hir Pat<'hir>) -> &'hir Pat<'hir> {\n+    while let PatKind::Ref(subpat, _) = pat.kind {\n+        pat = subpat;\n+    }\n+    pat\n+}\n+\n+pub fn int_bits(tcx: TyCtxt<'_>, ity: ty::IntTy) -> u64 {\n+    Integer::from_int_ty(&tcx, ity).size().bits()\n+}\n+\n+#[allow(clippy::cast_possible_wrap)]\n+/// Turn a constant int byte representation into an i128\n+pub fn sext(tcx: TyCtxt<'_>, u: u128, ity: ty::IntTy) -> i128 {\n+    let amt = 128 - int_bits(tcx, ity);\n+    ((u as i128) << amt) >> amt\n+}\n+\n+#[allow(clippy::cast_sign_loss)]\n+/// clip unused bytes\n+pub fn unsext(tcx: TyCtxt<'_>, u: i128, ity: ty::IntTy) -> u128 {\n+    let amt = 128 - int_bits(tcx, ity);\n+    ((u as u128) << amt) >> amt\n+}\n+\n+/// clip unused bytes\n+pub fn clip(tcx: TyCtxt<'_>, u: u128, ity: ty::UintTy) -> u128 {\n+    let bits = Integer::from_uint_ty(&tcx, ity).size().bits();\n+    let amt = 128 - bits;\n+    (u << amt) >> amt\n+}\n+\n+/// Removes block comments from the given `Vec` of lines.\n+///\n+/// # Examples\n+///\n+/// ```rust,ignore\n+/// without_block_comments(vec![\"/*\", \"foo\", \"*/\"]);\n+/// // => vec![]\n+///\n+/// without_block_comments(vec![\"bar\", \"/*\", \"foo\", \"*/\"]);\n+/// // => vec![\"bar\"]\n+/// ```\n+pub fn without_block_comments(lines: Vec<&str>) -> Vec<&str> {\n+    let mut without = vec![];\n+\n+    let mut nest_level = 0;\n+\n+    for line in lines {\n+        if line.contains(\"/*\") {\n+            nest_level += 1;\n+            continue;\n+        } else if line.contains(\"*/\") {\n+            nest_level -= 1;\n+            continue;\n+        }\n+\n+        if nest_level == 0 {\n+            without.push(line);\n+        }\n+    }\n+\n+    without\n+}\n+\n+pub fn any_parent_is_automatically_derived(tcx: TyCtxt<'_>, node: HirId) -> bool {\n+    let map = &tcx.hir();\n+    let mut prev_enclosing_node = None;\n+    let mut enclosing_node = node;\n+    while Some(enclosing_node) != prev_enclosing_node {\n+        if is_automatically_derived(map.attrs(enclosing_node)) {\n+            return true;\n+        }\n+        prev_enclosing_node = Some(enclosing_node);\n+        enclosing_node = map.get_parent_item(enclosing_node);\n+    }\n+    false\n+}\n+\n+/// Returns true if ty has `iter` or `iter_mut` methods\n+pub fn has_iter_method(cx: &LateContext<'_>, probably_ref_ty: Ty<'_>) -> Option<&'static str> {\n+    // FIXME: instead of this hard-coded list, we should check if `<adt>::iter`\n+    // exists and has the desired signature. Unfortunately FnCtxt is not exported\n+    // so we can't use its `lookup_method` method.\n+    let into_iter_collections: [&[&str]; 13] = [\n+        &paths::VEC,\n+        &paths::OPTION,\n+        &paths::RESULT,\n+        &paths::BTREESET,\n+        &paths::BTREEMAP,\n+        &paths::VEC_DEQUE,\n+        &paths::LINKED_LIST,\n+        &paths::BINARY_HEAP,\n+        &paths::HASHSET,\n+        &paths::HASHMAP,\n+        &paths::PATH_BUF,\n+        &paths::PATH,\n+        &paths::RECEIVER,\n+    ];\n+\n+    let ty_to_check = match probably_ref_ty.kind() {\n+        ty::Ref(_, ty_to_check, _) => ty_to_check,\n+        _ => probably_ref_ty,\n+    };\n+\n+    let def_id = match ty_to_check.kind() {\n+        ty::Array(..) => return Some(\"array\"),\n+        ty::Slice(..) => return Some(\"slice\"),\n+        ty::Adt(adt, _) => adt.did,\n+        _ => return None,\n+    };\n+\n+    for path in &into_iter_collections {\n+        if match_def_path(cx, def_id, path) {\n+            return Some(*path.last().unwrap());\n+        }\n+    }\n+    None\n+}\n+\n+/// Matches a function call with the given path and returns the arguments.\n+///\n+/// Usage:\n+///\n+/// ```rust,ignore\n+/// if let Some(args) = match_function_call(cx, cmp_max_call, &paths::CMP_MAX);\n+/// ```\n+pub fn match_function_call<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    path: &[&str],\n+) -> Option<&'tcx [Expr<'tcx>]> {\n+    if_chain! {\n+        if let ExprKind::Call(ref fun, ref args) = expr.kind;\n+        if let ExprKind::Path(ref qpath) = fun.kind;\n+        if let Some(fun_def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n+        if match_def_path(cx, fun_def_id, path);\n+        then {\n+            return Some(&args)\n+        }\n+    };\n+    None\n+}\n+\n+/// Checks if `Ty` is normalizable. This function is useful\n+/// to avoid crashes on `layout_of`.\n+pub fn is_normalizable<'tcx>(cx: &LateContext<'tcx>, param_env: ty::ParamEnv<'tcx>, ty: Ty<'tcx>) -> bool {\n+    cx.tcx.infer_ctxt().enter(|infcx| {\n+        let cause = rustc_middle::traits::ObligationCause::dummy();\n+        infcx.at(&cause, param_env).normalize(ty).is_ok()\n+    })\n+}\n+\n+pub fn match_def_path<'tcx>(cx: &LateContext<'tcx>, did: DefId, syms: &[&str]) -> bool {\n+    // We have to convert `syms` to `&[Symbol]` here because rustc's `match_def_path`\n+    // accepts only that. We should probably move to Symbols in Clippy as well.\n+    let syms = syms.iter().map(|p| Symbol::intern(p)).collect::<Vec<Symbol>>();\n+    cx.match_def_path(did, &syms)\n+}\n+\n+pub fn match_panic_call<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx [Expr<'tcx>]> {\n+    match_function_call(cx, expr, &paths::BEGIN_PANIC)\n+        .or_else(|| match_function_call(cx, expr, &paths::BEGIN_PANIC_FMT))\n+        .or_else(|| match_function_call(cx, expr, &paths::PANIC_ANY))\n+        .or_else(|| match_function_call(cx, expr, &paths::PANICKING_PANIC))\n+        .or_else(|| match_function_call(cx, expr, &paths::PANICKING_PANIC_FMT))\n+        .or_else(|| match_function_call(cx, expr, &paths::PANICKING_PANIC_STR))\n+}\n+\n+pub fn match_panic_def_id(cx: &LateContext<'_>, did: DefId) -> bool {\n+    match_def_path(cx, did, &paths::BEGIN_PANIC)\n+        || match_def_path(cx, did, &paths::BEGIN_PANIC_FMT)\n+        || match_def_path(cx, did, &paths::PANIC_ANY)\n+        || match_def_path(cx, did, &paths::PANICKING_PANIC)\n+        || match_def_path(cx, did, &paths::PANICKING_PANIC_FMT)\n+        || match_def_path(cx, did, &paths::PANICKING_PANIC_STR)\n+}\n+\n+/// Returns the list of condition expressions and the list of blocks in a\n+/// sequence of `if/else`.\n+/// E.g., this returns `([a, b], [c, d, e])` for the expression\n+/// `if a { c } else if b { d } else { e }`.\n+pub fn if_sequence<'tcx>(\n+    mut expr: &'tcx Expr<'tcx>,\n+) -> (SmallVec<[&'tcx Expr<'tcx>; 1]>, SmallVec<[&'tcx Block<'tcx>; 1]>) {\n+    let mut conds = SmallVec::new();\n+    let mut blocks: SmallVec<[&Block<'_>; 1]> = SmallVec::new();\n+\n+    while let ExprKind::If(ref cond, ref then_expr, ref else_expr) = expr.kind {\n+        conds.push(&**cond);\n+        if let ExprKind::Block(ref block, _) = then_expr.kind {\n+            blocks.push(block);\n+        } else {\n+            panic!(\"ExprKind::If node is not an ExprKind::Block\");\n+        }\n+\n+        if let Some(ref else_expr) = *else_expr {\n+            expr = else_expr;\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    // final `else {..}`\n+    if !blocks.is_empty() {\n+        if let ExprKind::Block(ref block, _) = expr.kind {\n+            blocks.push(&**block);\n+        }\n+    }\n+\n+    (conds, blocks)\n+}\n+\n+pub fn parent_node_is_if_expr(expr: &Expr<'_>, cx: &LateContext<'_>) -> bool {\n+    let map = cx.tcx.hir();\n+    let parent_id = map.get_parent_node(expr.hir_id);\n+    let parent_node = map.get(parent_id);\n+    matches!(\n+        parent_node,\n+        Node::Expr(Expr {\n+            kind: ExprKind::If(_, _, _),\n+            ..\n+        })\n+    )\n+}\n+\n+// Finds the attribute with the given name, if any\n+pub fn attr_by_name<'a>(attrs: &'a [Attribute], name: &'_ str) -> Option<&'a Attribute> {\n+    attrs\n+        .iter()\n+        .find(|attr| attr.ident().map_or(false, |ident| ident.as_str() == name))\n+}\n+\n+// Finds the `#[must_use]` attribute, if any\n+pub fn must_use_attr(attrs: &[Attribute]) -> Option<&Attribute> {\n+    attr_by_name(attrs, \"must_use\")\n+}\n+\n+// Returns whether the type has #[must_use] attribute\n+pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+    match ty.kind() {\n+        ty::Adt(ref adt, _) => must_use_attr(&cx.tcx.get_attrs(adt.did)).is_some(),\n+        ty::Foreign(ref did) => must_use_attr(&cx.tcx.get_attrs(*did)).is_some(),\n+        ty::Slice(ref ty)\n+        | ty::Array(ref ty, _)\n+        | ty::RawPtr(ty::TypeAndMut { ref ty, .. })\n+        | ty::Ref(_, ref ty, _) => {\n+            // for the Array case we don't need to care for the len == 0 case\n+            // because we don't want to lint functions returning empty arrays\n+            is_must_use_ty(cx, *ty)\n+        },\n+        ty::Tuple(ref substs) => substs.types().any(|ty| is_must_use_ty(cx, ty)),\n+        ty::Opaque(ref def_id, _) => {\n+            for (predicate, _) in cx.tcx.explicit_item_bounds(*def_id) {\n+                if let ty::PredicateKind::Trait(trait_predicate, _) = predicate.kind().skip_binder() {\n+                    if must_use_attr(&cx.tcx.get_attrs(trait_predicate.trait_ref.def_id)).is_some() {\n+                        return true;\n+                    }\n+                }\n+            }\n+            false\n+        },\n+        ty::Dynamic(binder, _) => {\n+            for predicate in binder.iter() {\n+                if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate.skip_binder() {\n+                    if must_use_attr(&cx.tcx.get_attrs(trait_ref.def_id)).is_some() {\n+                        return true;\n+                    }\n+                }\n+            }\n+            false\n+        },\n+        _ => false,\n+    }\n+}\n+\n+// check if expr is calling method or function with #[must_use] attribute\n+pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    let did = match expr.kind {\n+        ExprKind::Call(ref path, _) => if_chain! {\n+            if let ExprKind::Path(ref qpath) = path.kind;\n+            if let def::Res::Def(_, did) = cx.qpath_res(qpath, path.hir_id);\n+            then {\n+                Some(did)\n+            } else {\n+                None\n+            }\n+        },\n+        ExprKind::MethodCall(_, _, _, _) => cx.typeck_results().type_dependent_def_id(expr.hir_id),\n+        _ => None,\n+    };\n+\n+    did.map_or(false, |did| must_use_attr(&cx.tcx.get_attrs(did)).is_some())\n+}\n+\n+pub fn is_no_std_crate(krate: &Crate<'_>) -> bool {\n+    krate.item.attrs.iter().any(|attr| {\n+        if let ast::AttrKind::Normal(ref attr, _) = attr.kind {\n+            attr.path == sym::no_std\n+        } else {\n+            false\n+        }\n+    })\n+}\n+\n+/// Check if parent of a hir node is a trait implementation block.\n+/// For example, `f` in\n+/// ```rust,ignore\n+/// impl Trait for S {\n+///     fn f() {}\n+/// }\n+/// ```\n+pub fn is_trait_impl_item(cx: &LateContext<'_>, hir_id: HirId) -> bool {\n+    if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_id)) {\n+        matches!(item.kind, ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }))\n+    } else {\n+        false\n+    }\n+}\n+\n+/// Check if it's even possible to satisfy the `where` clause for the item.\n+///\n+/// `trivial_bounds` feature allows functions with unsatisfiable bounds, for example:\n+///\n+/// ```ignore\n+/// fn foo() where i32: Iterator {\n+///     for _ in 2i32 {}\n+/// }\n+/// ```\n+pub fn fn_has_unsatisfiable_preds(cx: &LateContext<'_>, did: DefId) -> bool {\n+    use rustc_trait_selection::traits;\n+    let predicates =\n+        cx.tcx\n+            .predicates_of(did)\n+            .predicates\n+            .iter()\n+            .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n+    traits::impossible_predicates(\n+        cx.tcx,\n+        traits::elaborate_predicates(cx.tcx, predicates)\n+            .map(|o| o.predicate)\n+            .collect::<Vec<_>>(),\n+    )\n+}\n+\n+/// Returns the `DefId` of the callee if the given expression is a function or method call.\n+pub fn fn_def_id(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<DefId> {\n+    match &expr.kind {\n+        ExprKind::MethodCall(..) => cx.typeck_results().type_dependent_def_id(expr.hir_id),\n+        ExprKind::Call(\n+            Expr {\n+                kind: ExprKind::Path(qpath),\n+                hir_id: path_hir_id,\n+                ..\n+            },\n+            ..,\n+        ) => cx.typeck_results().qpath_res(qpath, *path_hir_id).opt_def_id(),\n+        _ => None,\n+    }\n+}\n+\n+pub fn run_lints(cx: &LateContext<'_>, lints: &[&'static Lint], id: HirId) -> bool {\n+    lints.iter().any(|lint| {\n+        matches!(\n+            cx.tcx.lint_level_at_node(lint, id),\n+            (Level::Forbid | Level::Deny | Level::Warn, _)\n+        )\n+    })\n+}\n+\n+/// Returns true iff the given type is a primitive (a bool or char, any integer or floating-point\n+/// number type, a str, or an array, slice, or tuple of those types).\n+pub fn is_recursively_primitive_type(ty: Ty<'_>) -> bool {\n+    match ty.kind() {\n+        ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => true,\n+        ty::Ref(_, inner, _) if *inner.kind() == ty::Str => true,\n+        ty::Array(inner_type, _) | ty::Slice(inner_type) => is_recursively_primitive_type(inner_type),\n+        ty::Tuple(inner_types) => inner_types.types().all(is_recursively_primitive_type),\n+        _ => false,\n+    }\n+}\n+\n+/// Returns Option<String> where String is a textual representation of the type encapsulated in the\n+/// slice iff the given expression is a slice of primitives (as defined in the\n+/// `is_recursively_primitive_type` function) and None otherwise.\n+pub fn is_slice_of_primitives(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n+    let expr_type = cx.typeck_results().expr_ty_adjusted(expr);\n+    let expr_kind = expr_type.kind();\n+    let is_primitive = match expr_kind {\n+        ty::Slice(element_type) => is_recursively_primitive_type(element_type),\n+        ty::Ref(_, inner_ty, _) if matches!(inner_ty.kind(), &ty::Slice(_)) => {\n+            if let ty::Slice(element_type) = inner_ty.kind() {\n+                is_recursively_primitive_type(element_type)\n+            } else {\n+                unreachable!()\n+            }\n+        },\n+        _ => false,\n+    };\n+\n+    if is_primitive {\n+        // if we have wrappers like Array, Slice or Tuple, print these\n+        // and get the type enclosed in the slice ref\n+        match expr_type.peel_refs().walk().nth(1).unwrap().expect_ty().kind() {\n+            ty::Slice(..) => return Some(\"slice\".into()),\n+            ty::Array(..) => return Some(\"array\".into()),\n+            ty::Tuple(..) => return Some(\"tuple\".into()),\n+            _ => {\n+                // is_recursively_primitive_type() should have taken care\n+                // of the rest and we can rely on the type that is found\n+                let refs_peeled = expr_type.peel_refs();\n+                return Some(refs_peeled.walk().last().unwrap().to_string());\n+            },\n+        }\n+    }\n+    None\n+}\n+\n+/// returns list of all pairs (a, b) from `exprs` such that `eq(a, b)`\n+/// `hash` must be comformed with `eq`\n+pub fn search_same<T, Hash, Eq>(exprs: &[T], hash: Hash, eq: Eq) -> Vec<(&T, &T)>\n+where\n+    Hash: Fn(&T) -> u64,\n+    Eq: Fn(&T, &T) -> bool,\n+{\n+    if exprs.len() == 2 && eq(&exprs[0], &exprs[1]) {\n+        return vec![(&exprs[0], &exprs[1])];\n+    }\n+\n+    let mut match_expr_list: Vec<(&T, &T)> = Vec::new();\n+\n+    let mut map: FxHashMap<_, Vec<&_>> =\n+        FxHashMap::with_capacity_and_hasher(exprs.len(), BuildHasherDefault::default());\n+\n+    for expr in exprs {\n+        match map.entry(hash(expr)) {\n+            Entry::Occupied(mut o) => {\n+                for o in o.get() {\n+                    if eq(o, expr) {\n+                        match_expr_list.push((o, expr));\n+                    }\n+                }\n+                o.get_mut().push(expr);\n+            },\n+            Entry::Vacant(v) => {\n+                v.insert(vec![expr]);\n+            },\n+        }\n+    }\n+\n+    match_expr_list\n+}\n+\n+/// Peels off all references on the pattern. Returns the underlying pattern and the number of\n+/// references removed.\n+pub fn peel_hir_pat_refs(pat: &'a Pat<'a>) -> (&'a Pat<'a>, usize) {\n+    fn peel(pat: &'a Pat<'a>, count: usize) -> (&'a Pat<'a>, usize) {\n+        if let PatKind::Ref(pat, _) = pat.kind {\n+            peel(pat, count + 1)\n+        } else {\n+            (pat, count)\n+        }\n+    }\n+    peel(pat, 0)\n+}\n+\n+/// Peels off up to the given number of references on the expression. Returns the underlying\n+/// expression and the number of references removed.\n+pub fn peel_n_hir_expr_refs(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>, usize) {\n+    fn f(expr: &'a Expr<'a>, count: usize, target: usize) -> (&'a Expr<'a>, usize) {\n+        match expr.kind {\n+            ExprKind::AddrOf(_, _, expr) if count != target => f(expr, count + 1, target),\n+            _ => (expr, count),\n+        }\n+    }\n+    f(expr, 0, count)\n+}\n+\n+/// Peels off all references on the expression. Returns the underlying expression and the number of\n+/// references removed.\n+pub fn peel_hir_expr_refs(expr: &'a Expr<'a>) -> (&'a Expr<'a>, usize) {\n+    fn f(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>, usize) {\n+        match expr.kind {\n+            ExprKind::AddrOf(BorrowKind::Ref, _, expr) => f(expr, count + 1),\n+            _ => (expr, count),\n+        }\n+    }\n+    f(expr, 0)\n+}\n+\n+/// Peels off all references on the type. Returns the underlying type and the number of references\n+/// removed.\n+pub fn peel_mid_ty_refs(ty: Ty<'_>) -> (Ty<'_>, usize) {\n+    fn peel(ty: Ty<'_>, count: usize) -> (Ty<'_>, usize) {\n+        if let ty::Ref(_, ty, _) = ty.kind() {\n+            peel(ty, count + 1)\n+        } else {\n+            (ty, count)\n+        }\n+    }\n+    peel(ty, 0)\n+}\n+\n+/// Peels off all references on the type.Returns the underlying type, the number of references\n+/// removed, and whether the pointer is ultimately mutable or not.\n+pub fn peel_mid_ty_refs_is_mutable(ty: Ty<'_>) -> (Ty<'_>, usize, Mutability) {\n+    fn f(ty: Ty<'_>, count: usize, mutability: Mutability) -> (Ty<'_>, usize, Mutability) {\n+        match ty.kind() {\n+            ty::Ref(_, ty, Mutability::Mut) => f(ty, count + 1, mutability),\n+            ty::Ref(_, ty, Mutability::Not) => f(ty, count + 1, Mutability::Not),\n+            _ => (ty, count, mutability),\n+        }\n+    }\n+    f(ty, 0, Mutability::Mut)\n+}\n+\n+#[macro_export]\n+macro_rules! unwrap_cargo_metadata {\n+    ($cx: ident, $lint: ident, $deps: expr) => {{\n+        let mut command = cargo_metadata::MetadataCommand::new();\n+        if !$deps {\n+            command.no_deps();\n+        }\n+\n+        match command.exec() {\n+            Ok(metadata) => metadata,\n+            Err(err) => {\n+                span_lint($cx, $lint, DUMMY_SP, &format!(\"could not read cargo metadata: {}\", err));\n+                return;\n+            },\n+        }\n+    }};\n+}\n+\n+pub fn is_hir_ty_cfg_dependant(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> bool {\n+    if_chain! {\n+        if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind;\n+        if let Res::Def(_, def_id) = path.res;\n+        then {\n+            cx.tcx.has_attr(def_id, sym::cfg) || cx.tcx.has_attr(def_id, sym::cfg_attr)\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+/// Check if the resolution of a given path is an `Ok` variant of `Result`.\n+pub fn is_ok_ctor(cx: &LateContext<'_>, res: Res) -> bool {\n+    if let Some(ok_id) = cx.tcx.lang_items().result_ok_variant() {\n+        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n+            if let Some(variant_id) = cx.tcx.parent(id) {\n+                return variant_id == ok_id;\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+/// Check if the resolution of a given path is a `Some` variant of `Option`.\n+pub fn is_some_ctor(cx: &LateContext<'_>, res: Res) -> bool {\n+    if let Some(some_id) = cx.tcx.lang_items().option_some_variant() {\n+        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n+            if let Some(variant_id) = cx.tcx.parent(id) {\n+                return variant_id == some_id;\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::{reindent_multiline, without_block_comments};\n+\n+    #[test]\n+    fn test_reindent_multiline_single_line() {\n+        assert_eq!(\"\", reindent_multiline(\"\".into(), false, None));\n+        assert_eq!(\"...\", reindent_multiline(\"...\".into(), false, None));\n+        assert_eq!(\"...\", reindent_multiline(\"    ...\".into(), false, None));\n+        assert_eq!(\"...\", reindent_multiline(\"\\t...\".into(), false, None));\n+        assert_eq!(\"...\", reindent_multiline(\"\\t\\t...\".into(), false, None));\n+    }\n+\n+    #[test]\n+    #[rustfmt::skip]\n+    fn test_reindent_multiline_block() {\n+        assert_eq!(\"\\\n+    if x {\n+        y\n+    } else {\n+        z\n+    }\", reindent_multiline(\"    if x {\n+            y\n+        } else {\n+            z\n+        }\".into(), false, None));\n+        assert_eq!(\"\\\n+    if x {\n+    \\ty\n+    } else {\n+    \\tz\n+    }\", reindent_multiline(\"    if x {\n+        \\ty\n+        } else {\n+        \\tz\n+        }\".into(), false, None));\n+    }\n+\n+    #[test]\n+    #[rustfmt::skip]\n+    fn test_reindent_multiline_empty_line() {\n+        assert_eq!(\"\\\n+    if x {\n+        y\n+\n+    } else {\n+        z\n+    }\", reindent_multiline(\"    if x {\n+            y\n+\n+        } else {\n+            z\n+        }\".into(), false, None));\n+    }\n+\n+    #[test]\n+    #[rustfmt::skip]\n+    fn test_reindent_multiline_lines_deeper() {\n+        assert_eq!(\"\\\n+        if x {\n+            y\n+        } else {\n+            z\n+        }\", reindent_multiline(\"\\\n+    if x {\n+        y\n+    } else {\n+        z\n+    }\".into(), true, Some(8)));\n+    }\n+\n+    #[test]\n+    fn test_without_block_comments_lines_without_block_comments() {\n+        let result = without_block_comments(vec![\"/*\", \"\", \"*/\"]);\n+        println!(\"result: {:?}\", result);\n+        assert!(result.is_empty());\n+\n+        let result = without_block_comments(vec![\"\", \"/*\", \"\", \"*/\", \"#[crate_type = \\\"lib\\\"]\", \"/*\", \"\", \"*/\", \"\"]);\n+        assert_eq!(result, vec![\"\", \"#[crate_type = \\\"lib\\\"]\", \"\"]);\n+\n+        let result = without_block_comments(vec![\"/* rust\", \"\", \"*/\"]);\n+        assert!(result.is_empty());\n+\n+        let result = without_block_comments(vec![\"/* one-line comment */\"]);\n+        assert!(result.is_empty());\n+\n+        let result = without_block_comments(vec![\"/* nested\", \"/* multi-line\", \"comment\", \"*/\", \"test\", \"*/\"]);\n+        assert!(result.is_empty());\n+\n+        let result = without_block_comments(vec![\"/* nested /* inline /* comment */ test */ */\"]);\n+        assert!(result.is_empty());\n+\n+        let result = without_block_comments(vec![\"foo\", \"bar\", \"baz\"]);\n+        assert_eq!(result, vec![\"foo\", \"bar\", \"baz\"]);\n+    }\n+}"}, {"sha": "d02603d7702c7f3c6a8f7f48d30b29a027ff7e00", "filename": "clippy_utils/src/numeric_literal.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fnumeric_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fnumeric_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fnumeric_literal.rs?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "previous_filename": "clippy_lints/src/utils/numeric_literal.rs"}, {"sha": "432cc5b59f684ddac760861f8ab4906746de5fb3", "filename": "clippy_utils/src/paths.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "previous_filename": "clippy_lints/src/utils/paths.rs"}, {"sha": "baeff08e02cd8f6738678b71e2cdf1d039f772ef", "filename": "clippy_utils/src/ptr.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fptr.rs?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{get_pat_name, match_var, snippet};\n+use crate::{get_pat_name, match_var, snippet};\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc_hir::{Body, BodyId, Expr, ExprKind, Param};\n use rustc_lint::LateContext;", "previous_filename": "clippy_lints/src/utils/ptr.rs"}, {"sha": "a482017afeb136339277386cd0f78be46d91c3cf", "filename": "clippy_utils/src/qualify_min_const_fn.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "previous_filename": "clippy_lints/src/utils/qualify_min_const_fn.rs"}, {"sha": "d4f6f4281d368ef32bef21978057a9b5a21cdb87", "filename": "clippy_utils/src/sugg.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "patch": "@@ -1,7 +1,7 @@\n //! Contains utility functions to generate suggestions.\n #![deny(clippy::missing_docs_in_private_items)]\n \n-use crate::utils::{higher, snippet, snippet_opt, snippet_with_macro_callsite};\n+use crate::{higher, snippet, snippet_opt, snippet_with_macro_callsite};\n use rustc_ast::util::parser::AssocOp;\n use rustc_ast::{ast, token};\n use rustc_ast_pretty::pprust::token_kind_to_string;", "previous_filename": "clippy_lints/src/utils/sugg.rs"}, {"sha": "f47dc80ebade8222716a721293eb00b50e80aa52", "filename": "clippy_utils/src/sym_helper.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fsym_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fsym_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsym_helper.rs?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "previous_filename": "clippy_lints/src/utils/sym_helper.rs"}, {"sha": "d577827dcf3ccc0aea320ef53630127b01e44010", "filename": "clippy_utils/src/usage.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fusage.rs?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils;\n+use crate as utils;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::Res;", "previous_filename": "clippy_lints/src/utils/usage.rs"}, {"sha": "5a8c629e3338c41683de26a237968a33bb1cda8b", "filename": "clippy_utils/src/visitors.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::path_to_local_id;\n+use crate::path_to_local_id;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, walk_expr, NestedVisitorMap, Visitor};\n use rustc_hir::{Arm, Body, Expr, HirId, Stmt};", "previous_filename": "clippy_lints/src/utils/visitors.rs"}, {"sha": "f62c2d29c707e3e45eb143bdc0fc4895021eebf0", "filename": "doc/adding_lints.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/doc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/doc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fadding_lints.md?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "patch": "@@ -292,7 +292,7 @@ the next section. Let's worry about the details later and emit our lint for\n \n Depending on how complex we want our lint message to be, we can choose from a\n variety of lint emission functions. They can all be found in\n-[`clippy_lints/src/utils/diagnostics.rs`][diagnostics].\n+[`clippy_utils/src/diagnostics.rs`][diagnostics].\n \n `span_lint_and_help` seems most appropriate in this case. It allows us to\n provide an extra help message and we can't really suggest a better name\n@@ -321,7 +321,7 @@ When code or an identifier must appear in a message or label, it should be\n surrounded with single grave accents \\`.\n \n [check_fn]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.EarlyLintPass.html#method.check_fn\n-[diagnostics]: https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/utils/diagnostics.rs\n+[diagnostics]: https://github.com/rust-lang/rust-clippy/blob/master/clippy_utils/src/diagnostics.rs\n [the rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/diagnostics.html\n \n ## Adding the lint logic\n@@ -537,7 +537,7 @@ directory. Adding a configuration to a lint can be useful for thresholds or to c\n behavior that can be seen as a false positive for some users. Adding a configuration is done \n in the following steps:\n \n-1. Adding a new configuration entry to [clippy_lints::utils::conf](/clippy_lints/src/utils/conf.rs)\n+1. Adding a new configuration entry to [clippy_utils::conf](/clippy_utils/src/conf.rs)\n     like this:\n     ```rust\n     /// Lint: LINT_NAME. <The configuration field doc comment>\n@@ -636,7 +636,7 @@ documentation currently. This is unfortunate, but in most cases you can probably\n get away with copying things from existing similar lints. If you are stuck,\n don't hesitate to ask on [Zulip] or in the issue/PR.\n \n-[utils]: https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/utils/mod.rs\n+[utils]: https://github.com/rust-lang/rust-clippy/blob/master/clippy_utils/src/lib.rs\n [if_chain]: https://docs.rs/if_chain/*/if_chain/\n [from_expansion]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html#method.from_expansion\n [in_external_macro]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/lint/fn.in_external_macro.html"}, {"sha": "abac1227b4ff389cee02b348ddf01ad9a5346b78", "filename": "doc/common_tools_writing_lints.md", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/doc%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/doc%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fcommon_tools_writing_lints.md?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "patch": "@@ -78,7 +78,7 @@ impl LateLintPass<'_> for MyStructLint {\n There are two ways to do this, depending if the target trait is part of lang items.\n \n ```rust\n-use crate::utils::{implements_trait, match_trait_method, paths};\n+use clippy_utils::{implements_trait, match_trait_method, paths};\n \n impl LateLintPass<'_> for MyStructLint {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n@@ -112,7 +112,7 @@ We access lang items through the type context `tcx`. `tcx` is of type [`TyCtxt`]\n To check if our type defines a method called `some_method`:\n \n ```rust\n-use crate::utils::{is_type_diagnostic_item, return_ty};\n+use clippy_utils::{is_type_diagnostic_item, return_ty};\n \n impl<'tcx> LateLintPass<'tcx> for MyTypeImpl {\n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx ImplItem<'_>) {\n@@ -135,7 +135,7 @@ impl<'tcx> LateLintPass<'tcx> for MyTypeImpl {\n \n # Dealing with macros\n \n-There are several helpers in Clippy's utils to deal with macros:\n+There are several helpers in [`clippy_utils`][utils] to deal with macros:\n \n - `in_macro()`: detect if the given span is expanded by a macro\n \n@@ -199,4 +199,5 @@ assert_eq!(differing_macro_contexts(x_is_some_span, x_unwrap_span), true);\n [LateContext]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/struct.LateContext.html\n [TyCtxt]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TyCtxt.html\n [pat_ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TypeckResults.html#method.pat_ty\n-[paths]: ../clippy_lints/src/utils/paths.rs\n+[paths]: ../clippy_utils/src/paths.rs\n+[utils]: https://github.com/rust-lang/rust-clippy/blob/master/clippy_utils/src/lib.rs"}, {"sha": "1c954c57a8549e0af4024d8ba0b9b16ecf9765bd", "filename": "tests/versioncheck.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/489c4f00f96b9902bf223a0a2e72261063ccb2f4/tests%2Fversioncheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/489c4f00f96b9902bf223a0a2e72261063ccb2f4/tests%2Fversioncheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fversioncheck.rs?ref=489c4f00f96b9902bf223a0a2e72261063ccb2f4", "patch": "@@ -2,21 +2,24 @@\n use rustc_tools_util::VersionInfo;\n \n #[test]\n-fn check_that_clippy_lints_has_the_same_version_as_clippy() {\n+fn check_that_clippy_lints_and_clippy_utils_have_the_same_version_as_clippy() {\n     let clippy_meta = cargo_metadata::MetadataCommand::new()\n         .no_deps()\n         .exec()\n         .expect(\"could not obtain cargo metadata\");\n-    std::env::set_current_dir(std::env::current_dir().unwrap().join(\"clippy_lints\")).unwrap();\n-    let clippy_lints_meta = cargo_metadata::MetadataCommand::new()\n-        .no_deps()\n-        .exec()\n-        .expect(\"could not obtain cargo metadata\");\n-    assert_eq!(clippy_lints_meta.packages[0].version, clippy_meta.packages[0].version);\n-    for package in &clippy_meta.packages[0].dependencies {\n-        if package.name == \"clippy_lints\" {\n-            assert!(package.req.matches(&clippy_lints_meta.packages[0].version));\n-            return;\n+\n+    for krate in &[\"clippy_lints\", \"clippy_utils\"] {\n+        let krate_meta = clippy_meta\n+            .packages\n+            .iter()\n+            .find(|package| package.name == *krate)\n+            .expect(\"could not obtain cargo metadata\");\n+        assert_eq!(krate_meta.version, clippy_meta.packages[0].version);\n+        for package in &clippy_meta.packages[0].dependencies {\n+            if package.name == *krate {\n+                assert!(package.req.matches(&krate_meta.version));\n+                break;\n+            }\n         }\n     }\n }"}]}