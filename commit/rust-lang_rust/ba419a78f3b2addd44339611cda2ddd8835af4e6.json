{"sha": "ba419a78f3b2addd44339611cda2ddd8835af4e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhNDE5YTc4ZjNiMmFkZGQ0NDMzOTYxMWNkYTJkZGQ4ODM1YWY0ZTY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-06-11T15:47:47Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-07-08T09:36:45Z"}, "message": "Cleanup of some pattern related code", "tree": {"sha": "0883dd9258cf7276dc233cc9b4caac90efc19015", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0883dd9258cf7276dc233cc9b4caac90efc19015"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba419a78f3b2addd44339611cda2ddd8835af4e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba419a78f3b2addd44339611cda2ddd8835af4e6", "html_url": "https://github.com/rust-lang/rust/commit/ba419a78f3b2addd44339611cda2ddd8835af4e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba419a78f3b2addd44339611cda2ddd8835af4e6/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3c94b25cbf71505b6389151901a948f23bda683", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3c94b25cbf71505b6389151901a948f23bda683", "html_url": "https://github.com/rust-lang/rust/commit/d3c94b25cbf71505b6389151901a948f23bda683"}], "stats": {"total": 307, "additions": 94, "deletions": 213}, "files": [{"sha": "6551e0129f88493dacffff9044ca34b10ea112db", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 39, "deletions": 99, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/ba419a78f3b2addd44339611cda2ddd8835af4e6/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba419a78f3b2addd44339611cda2ddd8835af4e6/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=ba419a78f3b2addd44339611cda2ddd8835af4e6", "patch": "@@ -945,52 +945,41 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     /// The core driver for walking a pattern; `match_mode` must be\n     /// established up front, e.g. via `determine_pat_move_mode` (see\n     /// also `walk_irrefutable_pat` for patterns that stand alone).\n-    fn walk_pat(&mut self,\n-                cmt_discr: mc::cmt<'tcx>,\n-                pat: &hir::Pat,\n-                match_mode: MatchMode) {\n-        debug!(\"walk_pat cmt_discr={:?} pat={:?}\", cmt_discr,\n-               pat);\n+    fn walk_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &hir::Pat, match_mode: MatchMode) {\n+        debug!(\"walk_pat cmt_discr={:?} pat={:?}\", cmt_discr, pat);\n \n         let tcx = &self.tcx();\n         let mc = &self.mc;\n         let infcx = self.mc.infcx;\n         let delegate = &mut self.delegate;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n-            match pat.node {\n-                PatKind::Binding(bmode, _, _) => {\n-                    debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\",\n-                           cmt_pat,\n-                           pat,\n-                           match_mode);\n-\n-                    // pat_ty: the type of the binding being produced.\n-                    let pat_ty = return_if_err!(infcx.node_ty(pat.id));\n-\n-                    // Each match binding is effectively an assignment to the\n-                    // binding being produced.\n-                    if let Ok(binding_cmt) = mc.cat_def(pat.id, pat.span, pat_ty,\n-                                                        tcx.expect_def(pat.id)) {\n-                        delegate.mutate(pat.id, pat.span, binding_cmt, MutateMode::Init);\n-                    }\n+            if let PatKind::Binding(bmode, _, _) = pat.node {\n+                debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\", cmt_pat, pat, match_mode);\n \n-                    // It is also a borrow or copy/move of the value being matched.\n-                    match bmode {\n-                        hir::BindByRef(m) => {\n-                            if let ty::TyRef(&r, _) = pat_ty.sty {\n-                                let bk = ty::BorrowKind::from_mutbl(m);\n-                                delegate.borrow(pat.id, pat.span, cmt_pat,\n-                                                r, bk, RefBinding);\n-                            }\n-                        }\n-                        hir::BindByValue(..) => {\n-                            let mode = copy_or_move(infcx, &cmt_pat, PatBindingMove);\n-                            debug!(\"walk_pat binding consuming pat\");\n-                            delegate.consume_pat(pat, cmt_pat, mode);\n+                // pat_ty: the type of the binding being produced.\n+                let pat_ty = return_if_err!(infcx.node_ty(pat.id));\n+\n+                // Each match binding is effectively an assignment to the\n+                // binding being produced.\n+                if let Ok(binding_cmt) = mc.cat_def(pat.id, pat.span, pat_ty,\n+                                                    tcx.expect_def(pat.id)) {\n+                    delegate.mutate(pat.id, pat.span, binding_cmt, MutateMode::Init);\n+                }\n+\n+                // It is also a borrow or copy/move of the value being matched.\n+                match bmode {\n+                    hir::BindByRef(m) => {\n+                        if let ty::TyRef(&r, _) = pat_ty.sty {\n+                            let bk = ty::BorrowKind::from_mutbl(m);\n+                            delegate.borrow(pat.id, pat.span, cmt_pat, r, bk, RefBinding);\n                         }\n                     }\n+                    hir::BindByValue(..) => {\n+                        let mode = copy_or_move(infcx, &cmt_pat, PatBindingMove);\n+                        debug!(\"walk_pat binding consuming pat\");\n+                        delegate.consume_pat(pat, cmt_pat, mode);\n+                    }\n                 }\n-                _ => {}\n             }\n         }));\n \n@@ -999,72 +988,23 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         // to the above loop's visit of than the bindings that form\n         // the leaves of the pattern tree structure.\n         return_if_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n-            match pat.node {\n-                PatKind::Struct(..) | PatKind::TupleStruct(..) |\n-                PatKind::Path(..) | PatKind::QPath(..) => {\n-                    match tcx.expect_def(pat.id) {\n-                        Def::Variant(enum_did, variant_did) => {\n-                            let downcast_cmt =\n-                                if tcx.lookup_adt_def(enum_did).is_univariant() {\n-                                    cmt_pat\n-                                } else {\n-                                    let cmt_pat_ty = cmt_pat.ty;\n-                                    mc.cat_downcast(pat, cmt_pat, cmt_pat_ty, variant_did)\n-                                };\n-\n-                            debug!(\"variant downcast_cmt={:?} pat={:?}\",\n-                                   downcast_cmt,\n-                                   pat);\n-\n-                            delegate.matched_pat(pat, downcast_cmt, match_mode);\n-                        }\n-\n-                        Def::Struct(..) | Def::TyAlias(..) => {\n-                            // A struct (in either the value or type\n-                            // namespace; we encounter the former on\n-                            // e.g. patterns for unit structs).\n-\n-                            debug!(\"struct cmt_pat={:?} pat={:?}\",\n-                                   cmt_pat,\n-                                   pat);\n-\n-                            delegate.matched_pat(pat, cmt_pat, match_mode);\n-                        }\n-\n-                        Def::Const(..) | Def::AssociatedConst(..) => {\n-                            // This is a leaf (i.e. identifier binding\n-                            // or constant value to match); thus no\n-                            // `matched_pat` call.\n-                        }\n+            match tcx.expect_def_or_none(pat.id) {\n+                Some(Def::Variant(enum_did, variant_did)) => {\n+                    let downcast_cmt = if tcx.lookup_adt_def(enum_did).is_univariant() {\n+                        cmt_pat\n+                    } else {\n+                        let cmt_pat_ty = cmt_pat.ty;\n+                        mc.cat_downcast(pat, cmt_pat, cmt_pat_ty, variant_did)\n+                    };\n \n-                        def => {\n-                            // An enum type should never be in a pattern.\n-                            // Remaining cases are e.g. Def::Fn, to\n-                            // which identifiers within patterns\n-                            // should not resolve. However, we do\n-                            // encouter this when using the\n-                            // expr-use-visitor during typeck. So just\n-                            // ignore it, an error should have been\n-                            // reported.\n-\n-                            if !tcx.sess.has_errors() {\n-                                span_bug!(pat.span,\n-                                          \"Pattern has unexpected def: {:?} and type {:?}\",\n-                                          def,\n-                                          cmt_pat.ty);\n-                            }\n-                        }\n-                    }\n+                    debug!(\"variant downcast_cmt={:?} pat={:?}\", downcast_cmt, pat);\n+                    delegate.matched_pat(pat, downcast_cmt, match_mode);\n                 }\n-\n-                PatKind::Wild | PatKind::Tuple(..) | PatKind::Box(..) |\n-                PatKind::Ref(..) | PatKind::Lit(..) | PatKind::Range(..) |\n-                PatKind::Vec(..) | PatKind::Binding(..) => {\n-                    // Each of these cases does not\n-                    // correspond to an enum variant or struct, so we\n-                    // do not do any `matched_pat` calls for these\n-                    // cases either.\n+                Some(Def::Struct(..)) | Some(Def::TyAlias(..)) | Some(Def::AssociatedTy(..)) => {\n+                    debug!(\"struct cmt_pat={:?} pat={:?}\", cmt_pat, pat);\n+                    delegate.matched_pat(pat, cmt_pat, match_mode);\n                 }\n+                _ => {}\n             }\n         }));\n     }"}, {"sha": "3776a904923c9e8a5099bd6493c2a3f43e2791bc", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 43, "deletions": 81, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/ba419a78f3b2addd44339611cda2ddd8835af4e6/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba419a78f3b2addd44339611cda2ddd8835af4e6/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=ba419a78f3b2addd44339611cda2ddd8835af4e6", "patch": "@@ -1050,9 +1050,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     }\n \n     // FIXME(#19596) This is a workaround, but there should be a better way to do this\n-    fn cat_pattern_<F>(&self, cmt: cmt<'tcx>, pat: &hir::Pat, op: &mut F)\n-                       -> McResult<()>\n-        where F : FnMut(&MemCategorizationContext<'a, 'gcx, 'tcx>, cmt<'tcx>, &hir::Pat),\n+    fn cat_pattern_<F>(&self, cmt: cmt<'tcx>, pat: &hir::Pat, op: &mut F) -> McResult<()>\n+        where F : FnMut(&MemCategorizationContext<'a, 'gcx, 'tcx>, cmt<'tcx>, &hir::Pat)\n     {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against.\n@@ -1099,21 +1098,14 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // step out of sync again. So you'll see below that we always\n         // get the type of the *subpattern* and use that.\n \n-        debug!(\"cat_pattern: {:?} cmt={:?}\",\n-               pat,\n-               cmt);\n-\n-        (*op)(self, cmt.clone(), pat);\n+        debug!(\"cat_pattern: {:?} cmt={:?}\", pat, cmt);\n \n-        let opt_def = self.tcx().expect_def_or_none(pat.id);\n-        if opt_def == Some(Def::Err) {\n-            return Err(());\n-        }\n+        op(self, cmt.clone(), pat);\n \n         // Note: This goes up here (rather than within the PatKind::TupleStruct arm\n-        // alone) because struct patterns can refer to struct types or\n-        // to struct variants within enums.\n-        let cmt = match opt_def {\n+        // alone) because PatKind::Struct can also refer to variants.\n+        let cmt = match self.tcx().expect_def_or_none(pat.id) {\n+            Some(Def::Err) => return Err(()),\n             Some(Def::Variant(enum_did, variant_did))\n                 // univariant enums do not need downcasts\n                 if !self.tcx().lookup_adt_def(enum_did).is_univariant() => {\n@@ -1123,66 +1115,33 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         };\n \n         match pat.node {\n-          PatKind::Wild => {\n-            // _\n-          }\n-\n           PatKind::TupleStruct(_, ref subpats, ddpos) => {\n-            match opt_def {\n-                Some(Def::Variant(enum_def, def_id)) => {\n-                    // variant(x, y, z)\n-                    let expected_len = self.tcx().lookup_adt_def(enum_def)\n-                                                 .variant_with_id(def_id).fields.len();\n-                    for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n-                        let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n-\n-                        let subcmt =\n-                            self.cat_imm_interior(\n-                                pat, cmt.clone(), subpat_ty,\n-                                InteriorField(PositionalField(i)));\n-\n-                        self.cat_pattern_(subcmt, &subpat, op)?;\n-                    }\n+            let expected_len = match self.tcx().expect_def(pat.id) {\n+                Def::Variant(enum_def, def_id) => {\n+                    self.tcx().lookup_adt_def(enum_def).variant_with_id(def_id).fields.len()\n                 }\n-                Some(Def::Struct(..)) => {\n-                    let expected_len = match self.pat_ty(&pat)?.sty {\n+                Def::Struct(..) => {\n+                    match self.pat_ty(&pat)?.sty {\n                         ty::TyStruct(adt_def, _) => {\n                             adt_def.struct_variant().fields.len()\n                         }\n                         ref ty => {\n                             span_bug!(pat.span, \"tuple struct pattern unexpected type {:?}\", ty);\n                         }\n-                    };\n-\n-                    for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n-                        let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n-                        let cmt_field =\n-                            self.cat_imm_interior(\n-                                pat, cmt.clone(), subpat_ty,\n-                                InteriorField(PositionalField(i)));\n-                        self.cat_pattern_(cmt_field, &subpat, op)?;\n                     }\n                 }\n-                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => {\n-                    for subpat in subpats {\n-                        self.cat_pattern_(cmt.clone(), &subpat, op)?;\n-                    }\n-                }\n-                _ => {\n-                    span_bug!(\n-                        pat.span,\n-                        \"enum pattern didn't resolve to enum or struct {:?}\",\n-                        opt_def);\n+                def => {\n+                    span_bug!(pat.span, \"tuple struct pattern didn't resolve \\\n+                                         to variant or struct {:?}\", def);\n                 }\n-            }\n-          }\n-\n-          PatKind::Path(..) | PatKind::QPath(..) | PatKind::Binding(_, _, None) => {\n-              // Lone constant, or unit variant or identifier: ignore\n-          }\n+            };\n \n-          PatKind::Binding(_, _, Some(ref subpat)) => {\n-              self.cat_pattern_(cmt, &subpat, op)?;\n+            for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n+                let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n+                let subcmt = self.cat_imm_interior(pat, cmt.clone(), subpat_ty,\n+                                                   InteriorField(PositionalField(i)));\n+                self.cat_pattern_(subcmt, &subpat, op)?;\n+            }\n           }\n \n           PatKind::Struct(_, ref field_pats, _) => {\n@@ -1194,6 +1153,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n           }\n \n+          PatKind::Binding(_, _, Some(ref subpat)) => {\n+              self.cat_pattern_(cmt, &subpat, op)?;\n+          }\n+\n           PatKind::Tuple(ref subpats, ddpos) => {\n             // (p1, ..., pN)\n             let expected_len = match self.pat_ty(&pat)?.sty {\n@@ -1202,10 +1165,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n                 let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n-                let subcmt =\n-                    self.cat_imm_interior(\n-                        pat, cmt.clone(), subpat_ty,\n-                        InteriorField(PositionalField(i)));\n+                let subcmt = self.cat_imm_interior(pat, cmt.clone(), subpat_ty,\n+                                                   InteriorField(PositionalField(i)));\n                 self.cat_pattern_(subcmt, &subpat, op)?;\n             }\n           }\n@@ -1215,25 +1176,26 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // PatKind::Ref since that information is already contained\n             // in the type.\n             let subcmt = self.cat_deref(pat, cmt, 0, None)?;\n-              self.cat_pattern_(subcmt, &subpat, op)?;\n+            self.cat_pattern_(subcmt, &subpat, op)?;\n           }\n \n           PatKind::Vec(ref before, ref slice, ref after) => {\n-              let context = InteriorOffsetKind::Pattern;\n-              let elt_cmt = self.cat_index(pat, cmt, context)?;\n-              for before_pat in before {\n-                  self.cat_pattern_(elt_cmt.clone(), &before_pat, op)?;\n-              }\n-              if let Some(ref slice_pat) = *slice {\n-                  self.cat_pattern_(elt_cmt.clone(), &slice_pat, op)?;\n-              }\n-              for after_pat in after {\n-                  self.cat_pattern_(elt_cmt.clone(), &after_pat, op)?;\n-              }\n+            let context = InteriorOffsetKind::Pattern;\n+            let elt_cmt = self.cat_index(pat, cmt, context)?;\n+            for before_pat in before {\n+                self.cat_pattern_(elt_cmt.clone(), &before_pat, op)?;\n+            }\n+            if let Some(ref slice_pat) = *slice {\n+                self.cat_pattern_(elt_cmt.clone(), &slice_pat, op)?;\n+            }\n+            for after_pat in after {\n+                self.cat_pattern_(elt_cmt.clone(), &after_pat, op)?;\n+            }\n           }\n \n-          PatKind::Lit(_) | PatKind::Range(_, _) => {\n-              /*always ok*/\n+          PatKind::Path(..) | PatKind::QPath(..) | PatKind::Binding(_, _, None) |\n+          PatKind::Lit(..) | PatKind::Range(..) | PatKind::Wild => {\n+            // always ok\n           }\n         }\n "}, {"sha": "33c778f8725d7ec2f530a522df5d256376d86c30", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ba419a78f3b2addd44339611cda2ddd8835af4e6/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba419a78f3b2addd44339611cda2ddd8835af4e6/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=ba419a78f3b2addd44339611cda2ddd8835af4e6", "patch": "@@ -784,18 +784,14 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n                     left_ty: Ty, max_slice_length: usize) -> Vec<Constructor> {\n     let pat = raw_pat(p);\n     match pat.node {\n-        PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) =>\n+        PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) | PatKind::QPath(..) =>\n             match cx.tcx.expect_def(pat.id) {\n-                Def::Const(..) | Def::AssociatedConst(..) =>\n-                    span_bug!(pat.span, \"const pattern should've \\\n-                                         been rewritten\"),\n-                Def::Struct(..) | Def::TyAlias(..) => vec![Single],\n                 Def::Variant(_, id) => vec![Variant(id)],\n-                def => span_bug!(pat.span, \"pat_constructors: unexpected \\\n-                                            definition {:?}\", def),\n+                Def::Struct(..) | Def::TyAlias(..) | Def::AssociatedTy(..) => vec![Single],\n+                Def::Const(..) | Def::AssociatedConst(..) =>\n+                    span_bug!(pat.span, \"const pattern should've been rewritten\"),\n+                def => span_bug!(pat.span, \"pat_constructors: unexpected definition {:?}\", def),\n             },\n-        PatKind::QPath(..) =>\n-            span_bug!(pat.span, \"const pattern should've been rewritten\"),\n         PatKind::Lit(ref expr) =>\n             vec![ConstantValue(eval_const_expr(cx.tcx, &expr))],\n         PatKind::Range(ref lo, ref hi) =>\n@@ -899,7 +895,7 @@ pub fn specialize<'a, 'b, 'tcx>(\n         PatKind::Binding(..) | PatKind::Wild =>\n             Some(vec![dummy_pat; arity]),\n \n-        PatKind::Path(..) => {\n+        PatKind::Path(..) | PatKind::QPath(..) => {\n             match cx.tcx.expect_def(pat_id) {\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n                     span_bug!(pat_span, \"const pattern should've \\\n@@ -934,10 +930,6 @@ pub fn specialize<'a, 'b, 'tcx>(\n             }\n         }\n \n-        PatKind::QPath(_, _) => {\n-            span_bug!(pat_span, \"const pattern should've been rewritten\")\n-        }\n-\n         PatKind::Struct(_, ref pattern_fields, _) => {\n             let adt = cx.tcx.node_id_to_type(pat_id).ty_adt_def().unwrap();\n             let variant = constructor.variant_for_adt(adt);"}, {"sha": "654108c14df87ad8e495cf536eb3940733b296cf", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ba419a78f3b2addd44339611cda2ddd8835af4e6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba419a78f3b2addd44339611cda2ddd8835af4e6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=ba419a78f3b2addd44339611cda2ddd8835af4e6", "patch": "@@ -13,7 +13,7 @@ use hair::cx::Cx;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_const_eval as const_eval;\n use rustc::hir::def::Def;\n-use rustc::hir::pat_util::{EnumerateAndAdjustIterator, pat_is_resolved_const};\n+use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::ty::{self, Ty};\n use rustc::mir::repr::*;\n use rustc::hir::{self, PatKind};\n@@ -76,9 +76,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                 PatternKind::Range { lo: lo, hi: hi }\n             },\n \n-            PatKind::Path(..) | PatKind::QPath(..)\n-                if pat_is_resolved_const(&self.cx.tcx.def_map.borrow(), pat) =>\n-            {\n+            PatKind::Path(..) | PatKind::QPath(..) => {\n                 match self.cx.tcx.expect_def(pat.id) {\n                     Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                         let tcx = self.cx.tcx.global_tcx();\n@@ -104,11 +102,9 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                             }\n                         }\n                     }\n-                    def =>\n-                        span_bug!(\n-                            pat.span,\n-                            \"def not a constant: {:?}\",\n-                            def),\n+                    _ => {\n+                        self.variant_or_leaf(pat, vec![])\n+                    }\n                 }\n             }\n \n@@ -199,10 +195,6 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-            PatKind::Path(..) => {\n-                self.variant_or_leaf(pat, vec![])\n-            }\n-\n             PatKind::TupleStruct(_, ref subpatterns, ddpos) => {\n                 let pat_ty = self.cx.tcx.node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n@@ -253,10 +245,6 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n \n                 self.variant_or_leaf(pat, subpatterns)\n             }\n-\n-            PatKind::QPath(..) => {\n-                span_bug!(pat.span, \"unexpanded macro or bad constant etc\");\n-            }\n         };\n \n         Pattern {\n@@ -325,7 +313,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-            Def::Struct(..) | Def::TyAlias(..) => {\n+            Def::Struct(..) | Def::TyAlias(..) | Def::AssociatedTy(..) => {\n                 PatternKind::Leaf { subpatterns: subpatterns }\n             }\n "}, {"sha": "acaf9b9b2faeed9d57b1b4da9a0cccd4b3b26238", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ba419a78f3b2addd44339611cda2ddd8835af4e6/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba419a78f3b2addd44339611cda2ddd8835af4e6/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=ba419a78f3b2addd44339611cda2ddd8835af4e6", "patch": "@@ -436,7 +436,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n             hir::ExprPath(..) => {\n-\n                 if let Def::Struct(..) = self.tcx.expect_def(expr.id) {\n                     let expr_ty = self.tcx.expr_ty(expr);\n                     let def = match expr_ty.sty {"}]}