{"sha": "e34ad763639eda0e6174fc89ee31d808ec0d1536", "node_id": "C_kwDOAAsO6NoAKGUzNGFkNzYzNjM5ZWRhMGU2MTc0ZmM4OWVlMzFkODA4ZWMwZDE1MzY", "commit": {"author": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2023-03-28T10:25:30Z"}, "committer": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2023-03-28T17:37:16Z"}, "message": "Remove ~const from alloc", "tree": {"sha": "4837cd2acd10e3919286f8d9d5466032ca4ee27b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4837cd2acd10e3919286f8d9d5466032ca4ee27b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e34ad763639eda0e6174fc89ee31d808ec0d1536", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e34ad763639eda0e6174fc89ee31d808ec0d1536", "html_url": "https://github.com/rust-lang/rust/commit/e34ad763639eda0e6174fc89ee31d808ec0d1536", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e34ad763639eda0e6174fc89ee31d808ec0d1536/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbc064b341be231403d181402a786cce7f1c73f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbc064b341be231403d181402a786cce7f1c73f1", "html_url": "https://github.com/rust-lang/rust/commit/cbc064b341be231403d181402a786cce7f1c73f1"}], "stats": {"total": 73, "additions": 19, "deletions": 54}, "files": [{"sha": "6f2ba957bcda0995ac98952ae60666991d7df76b", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e34ad763639eda0e6174fc89ee31d808ec0d1536/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34ad763639eda0e6174fc89ee31d808ec0d1536/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=e34ad763639eda0e6174fc89ee31d808ec0d1536", "patch": "@@ -14,8 +14,6 @@ use core::ptr::{self, NonNull};\n #[doc(inline)]\n pub use core::alloc::*;\n \n-use core::marker::Destruct;\n-\n #[cfg(test)]\n mod tests;\n \n@@ -331,16 +329,12 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n \n #[cfg_attr(not(test), lang = \"box_free\")]\n #[inline]\n-#[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n // This signature has to be the same as `Box`, otherwise an ICE will happen.\n // When an additional parameter to `Box` is added (like `A: Allocator`), this has to be added here as\n // well.\n // For example if `Box` is changed to  `struct Box<T: ?Sized, A: Allocator>(Unique<T>, A)`,\n // this function has to be changed to `fn box_free<T: ?Sized, A: Allocator>(Unique<T>, A)` as well.\n-pub(crate) const unsafe fn box_free<T: ?Sized, A: ~const Allocator + ~const Destruct>(\n-    ptr: Unique<T>,\n-    alloc: A,\n-) {\n+pub(crate) unsafe fn box_free<T: ?Sized, A: Allocator>(ptr: Unique<T>, alloc: A) {\n     unsafe {\n         let size = size_of_val(ptr.as_ref());\n         let align = min_align_of_val(ptr.as_ref());"}, {"sha": "0c8c796ae9b819b33aa874aa8bb1057fffe4ad71", "filename": "library/alloc/src/borrow.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e34ad763639eda0e6174fc89ee31d808ec0d1536/library%2Falloc%2Fsrc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34ad763639eda0e6174fc89ee31d808ec0d1536/library%2Falloc%2Fsrc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fborrow.rs?ref=e34ad763639eda0e6174fc89ee31d808ec0d1536", "patch": "@@ -328,10 +328,9 @@ impl<B: ?Sized + ToOwned> Cow<'_, B> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_deref\", issue = \"88955\")]\n-impl<B: ?Sized + ToOwned> const Deref for Cow<'_, B>\n+impl<B: ?Sized + ToOwned> Deref for Cow<'_, B>\n where\n-    B::Owned: ~const Borrow<B>,\n+    B::Owned: Borrow<B>,\n {\n     type Target = B;\n "}, {"sha": "09041bb119bb762346cbaa731e2c1776fe6220bb", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 16, "deletions": 28, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e34ad763639eda0e6174fc89ee31d808ec0d1536/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34ad763639eda0e6174fc89ee31d808ec0d1536/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=e34ad763639eda0e6174fc89ee31d808ec0d1536", "patch": "@@ -159,7 +159,7 @@ use core::hash::{Hash, Hasher};\n use core::iter::FromIterator;\n use core::iter::{FusedIterator, Iterator};\n use core::marker::Tuple;\n-use core::marker::{Destruct, Unpin, Unsize};\n+use core::marker::{Unpin, Unsize};\n use core::mem;\n use core::ops::{\n     CoerceUnsized, Deref, DerefMut, DispatchFromDyn, Generator, GeneratorState, Receiver,\n@@ -376,12 +376,11 @@ impl<T, A: Allocator> Box<T, A> {\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[must_use]\n     #[inline]\n-    pub const fn new_in(x: T, alloc: A) -> Self\n+    pub fn new_in(x: T, alloc: A) -> Self\n     where\n-        A: ~const Allocator + ~const Destruct,\n+        A: Allocator,\n     {\n         let mut boxed = Self::new_uninit_in(alloc);\n         unsafe {\n@@ -406,12 +405,10 @@ impl<T, A: Allocator> Box<T, A> {\n     /// # Ok::<(), std::alloc::AllocError>(())\n     /// ```\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[inline]\n-    pub const fn try_new_in(x: T, alloc: A) -> Result<Self, AllocError>\n+    pub fn try_new_in(x: T, alloc: A) -> Result<Self, AllocError>\n     where\n-        T: ~const Destruct,\n-        A: ~const Allocator + ~const Destruct,\n+        A: Allocator,\n     {\n         let mut boxed = Self::try_new_uninit_in(alloc)?;\n         unsafe {\n@@ -441,13 +438,12 @@ impl<T, A: Allocator> Box<T, A> {\n     /// assert_eq!(*five, 5)\n     /// ```\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[cfg(not(no_global_oom_handling))]\n     #[must_use]\n     // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n-    pub const fn new_uninit_in(alloc: A) -> Box<mem::MaybeUninit<T>, A>\n+    pub fn new_uninit_in(alloc: A) -> Box<mem::MaybeUninit<T>, A>\n     where\n-        A: ~const Allocator + ~const Destruct,\n+        A: Allocator,\n     {\n         let layout = Layout::new::<mem::MaybeUninit<T>>();\n         // NOTE: Prefer match over unwrap_or_else since closure sometimes not inlineable.\n@@ -482,10 +478,9 @@ impl<T, A: Allocator> Box<T, A> {\n     /// ```\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n-    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n-    pub const fn try_new_uninit_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError>\n+    pub fn try_new_uninit_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError>\n     where\n-        A: ~const Allocator + ~const Destruct,\n+        A: Allocator,\n     {\n         let layout = Layout::new::<mem::MaybeUninit<T>>();\n         let ptr = alloc.allocate(layout)?.cast();\n@@ -513,13 +508,12 @@ impl<T, A: Allocator> Box<T, A> {\n     ///\n     /// [zeroed]: mem::MaybeUninit::zeroed\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[cfg(not(no_global_oom_handling))]\n     // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[must_use]\n-    pub const fn new_zeroed_in(alloc: A) -> Box<mem::MaybeUninit<T>, A>\n+    pub fn new_zeroed_in(alloc: A) -> Box<mem::MaybeUninit<T>, A>\n     where\n-        A: ~const Allocator + ~const Destruct,\n+        A: Allocator,\n     {\n         let layout = Layout::new::<mem::MaybeUninit<T>>();\n         // NOTE: Prefer match over unwrap_or_else since closure sometimes not inlineable.\n@@ -554,10 +548,9 @@ impl<T, A: Allocator> Box<T, A> {\n     /// [zeroed]: mem::MaybeUninit::zeroed\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n-    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n-    pub const fn try_new_zeroed_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError>\n+    pub fn try_new_zeroed_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError>\n     where\n-        A: ~const Allocator + ~const Destruct,\n+        A: Allocator,\n     {\n         let layout = Layout::new::<mem::MaybeUninit<T>>();\n         let ptr = alloc.allocate_zeroed(layout)?.cast();\n@@ -573,12 +566,11 @@ impl<T, A: Allocator> Box<T, A> {\n     /// construct a (pinned) `Box` in a different way than with [`Box::new_in`].\n     #[cfg(not(no_global_oom_handling))]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[must_use]\n     #[inline(always)]\n-    pub const fn pin_in(x: T, alloc: A) -> Pin<Self>\n+    pub fn pin_in(x: T, alloc: A) -> Pin<Self>\n     where\n-        A: 'static + ~const Allocator + ~const Destruct,\n+        A: 'static + Allocator,\n     {\n         Self::into_pin(Self::new_in(x, alloc))\n     }\n@@ -605,12 +597,8 @@ impl<T, A: Allocator> Box<T, A> {\n     /// assert_eq!(Box::into_inner(c), 5);\n     /// ```\n     #[unstable(feature = \"box_into_inner\", issue = \"80437\")]\n-    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[inline]\n-    pub const fn into_inner(boxed: Self) -> T\n-    where\n-        Self: ~const Destruct,\n-    {\n+    pub fn into_inner(boxed: Self) -> T {\n         *boxed\n     }\n }"}, {"sha": "68ebd8e35ee3d75dda0ddb873f6c25ff5f80dffc", "filename": "library/alloc/tests/boxed.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e34ad763639eda0e6174fc89ee31d808ec0d1536/library%2Falloc%2Ftests%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34ad763639eda0e6174fc89ee31d808ec0d1536/library%2Falloc%2Ftests%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fboxed.rs?ref=e34ad763639eda0e6174fc89ee31d808ec0d1536", "patch": "@@ -179,18 +179,3 @@ unsafe impl const Allocator for ConstAllocator {\n         self\n     }\n }\n-\n-#[test]\n-fn const_box() {\n-    const VALUE: u32 = {\n-        let mut boxed = Box::new_in(1u32, ConstAllocator);\n-        assert!(*boxed == 1);\n-\n-        *boxed = 42;\n-        assert!(*boxed == 42);\n-\n-        *Box::leak(boxed)\n-    };\n-\n-    assert!(VALUE == 42);\n-}"}, {"sha": "c27ca642e9b1f38b67fa96ab97c70060ad894b8e", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e34ad763639eda0e6174fc89ee31d808ec0d1536/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34ad763639eda0e6174fc89ee31d808ec0d1536/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=e34ad763639eda0e6174fc89ee31d808ec0d1536", "patch": "@@ -3,7 +3,6 @@\n #![feature(assert_matches)]\n #![feature(btree_drain_filter)]\n #![feature(cow_is_borrowed)]\n-#![feature(const_box)]\n #![feature(const_convert)]\n #![feature(const_cow_is_borrowed)]\n #![feature(const_heap)]"}]}