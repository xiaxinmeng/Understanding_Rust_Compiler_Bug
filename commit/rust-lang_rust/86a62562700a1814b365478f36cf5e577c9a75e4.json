{"sha": "86a62562700a1814b365478f36cf5e577c9a75e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2YTYyNTYyNzAwYTE4MTRiMzY1NDc4ZjM2Y2Y1ZTU3N2M5YTc1ZTQ=", "commit": {"author": {"name": "diwic", "email": "diwic@users.noreply.github.com", "date": "2016-05-24T05:28:32Z"}, "committer": {"name": "diwic", "email": "diwic@users.noreply.github.com", "date": "2016-05-24T05:28:32Z"}, "message": "panic.rs: fix docs (recover -> catch_unwind)\n\nThe current docs are a bit inconsistent. First, change all references of \"recover\" to \"catch_unwind\" because the function was renamed. Second, consistently use the term \"unwind safe\" instead of \"panic safe\", \"exception safe\" and \"recover safe\" (all these terms were used previously).", "tree": {"sha": "c207160c108e6e62a0bcbc1ad9b763e45faee2cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c207160c108e6e62a0bcbc1ad9b763e45faee2cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86a62562700a1814b365478f36cf5e577c9a75e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86a62562700a1814b365478f36cf5e577c9a75e4", "html_url": "https://github.com/rust-lang/rust/commit/86a62562700a1814b365478f36cf5e577c9a75e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86a62562700a1814b365478f36cf5e577c9a75e4/comments", "author": {"login": "diwic", "id": 9721510, "node_id": "MDQ6VXNlcjk3MjE1MTA=", "avatar_url": "https://avatars.githubusercontent.com/u/9721510?v=4", "gravatar_id": "", "url": "https://api.github.com/users/diwic", "html_url": "https://github.com/diwic", "followers_url": "https://api.github.com/users/diwic/followers", "following_url": "https://api.github.com/users/diwic/following{/other_user}", "gists_url": "https://api.github.com/users/diwic/gists{/gist_id}", "starred_url": "https://api.github.com/users/diwic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/diwic/subscriptions", "organizations_url": "https://api.github.com/users/diwic/orgs", "repos_url": "https://api.github.com/users/diwic/repos", "events_url": "https://api.github.com/users/diwic/events{/privacy}", "received_events_url": "https://api.github.com/users/diwic/received_events", "type": "User", "site_admin": false}, "committer": {"login": "diwic", "id": 9721510, "node_id": "MDQ6VXNlcjk3MjE1MTA=", "avatar_url": "https://avatars.githubusercontent.com/u/9721510?v=4", "gravatar_id": "", "url": "https://api.github.com/users/diwic", "html_url": "https://github.com/diwic", "followers_url": "https://api.github.com/users/diwic/followers", "following_url": "https://api.github.com/users/diwic/following{/other_user}", "gists_url": "https://api.github.com/users/diwic/gists{/gist_id}", "starred_url": "https://api.github.com/users/diwic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/diwic/subscriptions", "organizations_url": "https://api.github.com/users/diwic/orgs", "repos_url": "https://api.github.com/users/diwic/repos", "events_url": "https://api.github.com/users/diwic/events{/privacy}", "received_events_url": "https://api.github.com/users/diwic/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57ef015132ec09345b88d2ec20a9d9809b5d3dfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/57ef015132ec09345b88d2ec20a9d9809b5d3dfc", "html_url": "https://github.com/rust-lang/rust/commit/57ef015132ec09345b88d2ec20a9d9809b5d3dfc"}], "stats": {"total": 70, "additions": 35, "deletions": 35}, "files": [{"sha": "6770eafeac905f3a5bce25a6ee89421de23ff598", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/86a62562700a1814b365478f36cf5e577c9a75e4/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a62562700a1814b365478f36cf5e577c9a75e4/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=86a62562700a1814b365478f36cf5e577c9a75e4", "patch": "@@ -39,14 +39,14 @@ pub fn take_handler() -> Box<Fn(&PanicInfo) + 'static + Sync + Send> {\n     take_hook()\n }\n \n-/// A marker trait which represents \"panic safe\" types in Rust.\n+/// A marker trait which represents \"unwind safe\" types in Rust.\n ///\n /// This trait is implemented by default for many types and behaves similarly in\n /// terms of inference of implementation to the `Send` and `Sync` traits. The\n-/// purpose of this trait is to encode what types are safe to cross a `recover`\n-/// boundary with no fear of panic safety.\n+/// purpose of this trait is to encode what types are safe to cross a `catch_unwind`\n+/// boundary with no fear of unwind safety.\n ///\n-/// ## What is panic safety?\n+/// ## What is unwind safety?\n ///\n /// In Rust a function can \"return\" early if it either panics or calls a\n /// function which transitively panics. This sort of control flow is not always\n@@ -59,62 +59,62 @@ pub fn take_handler() -> Box<Fn(&PanicInfo) + 'static + Sync + Send> {\n ///\n /// Typically in Rust, it is difficult to perform step (2) because catching a\n /// panic involves either spawning a thread (which in turns makes it difficult\n-/// to later witness broken invariants) or using the `recover` function in this\n+/// to later witness broken invariants) or using the `catch_unwind` function in this\n /// module. Additionally, even if an invariant is witnessed, it typically isn't a\n-/// problem in Rust because there's no uninitialized values (like in C or C++).\n+/// problem in Rust because there are no uninitialized values (like in C or C++).\n ///\n /// It is possible, however, for **logical** invariants to be broken in Rust,\n-/// which can end up causing behavioral bugs. Another key aspect of panic safety\n+/// which can end up causing behavioral bugs. Another key aspect of unwind safety\n /// in Rust is that, in the absence of `unsafe` code, a panic cannot lead to\n /// memory unsafety.\n ///\n-/// That was a bit of a whirlwind tour of panic safety, but for more information\n-/// about panic safety and how it applies to Rust, see an [associated RFC][rfc].\n+/// That was a bit of a whirlwind tour of unwind safety, but for more information\n+/// about unwind safety and how it applies to Rust, see an [associated RFC][rfc].\n ///\n /// [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md\n ///\n /// ## What is `UnwindSafe`?\n ///\n-/// Now that we've got an idea of what panic safety is in Rust, it's also\n+/// Now that we've got an idea of what unwind safety is in Rust, it's also\n /// important to understand what this trait represents. As mentioned above, one\n-/// way to witness broken invariants is through the `recover` function in this\n+/// way to witness broken invariants is through the `catch_unwind` function in this\n /// module as it allows catching a panic and then re-using the environment of\n /// the closure.\n ///\n /// Simply put, a type `T` implements `UnwindSafe` if it cannot easily allow\n-/// witnessing a broken invariant through the use of `recover` (catching a\n+/// witnessing a broken invariant through the use of `catch_unwind` (catching a\n /// panic). This trait is a marker trait, so it is automatically implemented for\n-/// many types, and it is also structurally composed (e.g. a struct is recover\n-/// safe if all of its components are recover safe).\n+/// many types, and it is also structurally composed (e.g. a struct is unwind\n+/// safe if all of its components are unwind safe).\n ///\n /// Note, however, that this is not an unsafe trait, so there is not a succinct\n /// contract that this trait is providing. Instead it is intended as more of a\n-/// \"speed bump\" to alert users of `recover` that broken invariants may be\n+/// \"speed bump\" to alert users of `catch_unwind` that broken invariants may be\n /// witnessed and may need to be accounted for.\n ///\n /// ## Who implements `UnwindSafe`?\n ///\n /// Types such as `&mut T` and `&RefCell<T>` are examples which are **not**\n-/// recover safe. The general idea is that any mutable state which can be shared\n-/// across `recover` is not recover safe by default. This is because it is very\n-/// easy to witness a broken invariant outside of `recover` as the data is\n+/// unwind safe. The general idea is that any mutable state which can be shared\n+/// across `catch_unwind` is not unwind safe by default. This is because it is very\n+/// easy to witness a broken invariant outside of `catch_unwind` as the data is\n /// simply accessed as usual.\n ///\n-/// Types like `&Mutex<T>`, however, are recover safe because they implement\n+/// Types like `&Mutex<T>`, however, are unwind safe because they implement\n /// poisoning by default. They still allow witnessing a broken invariant, but\n /// they already provide their own \"speed bumps\" to do so.\n ///\n /// ## When should `UnwindSafe` be used?\n ///\n /// Is not intended that most types or functions need to worry about this trait.\n-/// It is only used as a bound on the `recover` function and as mentioned above,\n+/// It is only used as a bound on the `catch_unwind` function and as mentioned above,\n /// the lack of `unsafe` means it is mostly an advisory. The `AssertUnwindSafe`\n /// wrapper struct in this module can be used to force this trait to be\n-/// implemented for any closed over variables passed to the `recover` function\n+/// implemented for any closed over variables passed to the `catch_unwind` function\n /// (more on this below).\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n #[rustc_on_unimplemented = \"the type {Self} may not be safely transferred \\\n-                            across a recover boundary\"]\n+                            across an unwind boundary\"]\n pub trait UnwindSafe {}\n \n /// Deprecated, renamed to UnwindSafe\n@@ -126,7 +126,7 @@ pub trait RecoverSafe {}\n impl<T: UnwindSafe> RecoverSafe for T {}\n \n /// A marker trait representing types where a shared reference is considered\n-/// recover safe.\n+/// unwind safe.\n ///\n /// This trait is namely not implemented by `UnsafeCell`, the root of all\n /// interior mutability.\n@@ -136,31 +136,31 @@ impl<T: UnwindSafe> RecoverSafe for T {}\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n #[rustc_on_unimplemented = \"the type {Self} contains interior mutability \\\n                             and a reference may not be safely transferrable \\\n-                            across a recover boundary\"]\n+                            across a catch_unwind boundary\"]\n pub trait RefUnwindSafe {}\n \n-/// A simple wrapper around a type to assert that it is panic safe.\n+/// A simple wrapper around a type to assert that it is unwind safe.\n ///\n-/// When using `recover` it may be the case that some of the closed over\n-/// variables are not panic safe. For example if `&mut T` is captured the\n-/// compiler will generate a warning indicating that it is not panic safe. It\n+/// When using `catch_unwind` it may be the case that some of the closed over\n+/// variables are not unwind safe. For example if `&mut T` is captured the\n+/// compiler will generate a warning indicating that it is not unwind safe. It\n /// may not be the case, however, that this is actually a problem due to the\n-/// specific usage of `recover` if panic safety is specifically taken into\n+/// specific usage of `catch_unwind` if unwind safety is specifically taken into\n /// account. This wrapper struct is useful for a quick and lightweight\n-/// annotation that a variable is indeed panic safe.\n+/// annotation that a variable is indeed unwind safe.\n ///\n /// # Examples\n ///\n /// One way to use `AssertUnwindSafe` is to assert that the entire closure\n-/// itself is recover safe, bypassing all checks for all variables:\n+/// itself is unwind safe, bypassing all checks for all variables:\n ///\n /// ```\n /// use std::panic::{self, AssertUnwindSafe};\n ///\n /// let mut variable = 4;\n ///\n /// // This code will not compile because the closure captures `&mut variable`\n-/// // which is not considered panic safe by default.\n+/// // which is not considered unwind safe by default.\n ///\n /// // panic::catch_unwind(|| {\n /// //     variable += 3;\n@@ -239,7 +239,7 @@ impl<T> UnwindSafe for AssertUnwindSafe<T> {}\n impl<T> UnwindSafe for AssertRecoverSafe<T> {}\n \n // not covered via the Shared impl above b/c the inner contents use\n-// Cell/AtomicUsize, but the usage here is recover safe so we can lift the\n+// Cell/AtomicUsize, but the usage here is unwind safe so we can lift the\n // impl up one level to Arc/Rc itself\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n impl<T: RefUnwindSafe + ?Sized> UnwindSafe for Rc<T> {}\n@@ -352,9 +352,9 @@ impl<R, F: FnOnce() -> R> FnOnce<()> for AssertRecoverSafe<F> {\n /// that all captured variables are safe to cross this boundary. The purpose of\n /// this bound is to encode the concept of [exception safety][rfc] in the type\n /// system. Most usage of this function should not need to worry about this\n-/// bound as programs are naturally panic safe without `unsafe` code. If it\n+/// bound as programs are naturally unwind safe without `unsafe` code. If it\n /// becomes a problem the associated `AssertUnwindSafe` wrapper type in this\n-/// module can be used to quickly assert that the usage here is indeed exception\n+/// module can be used to quickly assert that the usage here is indeed unwind\n /// safe.\n ///\n /// [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md"}]}