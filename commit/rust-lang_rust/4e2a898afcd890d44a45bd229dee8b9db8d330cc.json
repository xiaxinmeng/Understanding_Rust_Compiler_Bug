{"sha": "4e2a898afcd890d44a45bd229dee8b9db8d330cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlMmE4OThhZmNkODkwZDQ0YTQ1YmQyMjlkZWU4YjlkYjhkMzMwY2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-22T16:11:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-22T16:11:38Z"}, "message": "Auto merge of #25784 - geofft:subprocess-signal-masks, r=alexcrichton\n\nUNIX specifies that signal dispositions and masks get inherited to child processes, but in general, programs are not very robust to being started with non-default signal dispositions or to signals being blocked. For example, libstd sets `SIGPIPE` to be ignored, on the grounds that Rust code using libstd will get the `EPIPE` errno and handle it correctly. But shell pipelines are built around the assumption that `SIGPIPE` will have its default behavior of killing the process, so that things like `head` work:\r\n\r\n```\r\ngeofft@titan:/tmp$ for i in `seq 1 20`; do echo \"$i\"; done | head -1\r\n1\r\ngeofft@titan:/tmp$ cat bash.rs\r\nfn main() {\r\n        std::process::Command::new(\"bash\").status();\r\n}\r\ngeofft@titan:/tmp$ ./bash\r\ngeofft@titan:/tmp$ for i in `seq 1 20`; do echo \"$i\"; done | head -1\r\n1\r\nbash: echo: write error: Broken pipe\r\nbash: echo: write error: Broken pipe\r\nbash: echo: write error: Broken pipe\r\nbash: echo: write error: Broken pipe\r\nbash: echo: write error: Broken pipe\r\n[...]\r\n```\r\n\r\nHere, `head` is supposed to terminate the input process quietly, but the bash subshell has inherited the ignored disposition of `SIGPIPE` from its Rust grandparent process. So it gets a bunch of `EPIPE`s that it doesn't know what to do with, and treats it as a generic, transient error. You can see similar behavior with `find / | head`, `yes | head`, etc.\r\n\r\nThis PR resets Rust's `SIGPIPE` handler, as well as any signal mask that may have been set, before spawning a child. Setting a signal mask, and then using a dedicated thread or something like `signalfd` to dequeue signals, is one of two reasonable ways for a library to process signals. See carllerche/mio#16 for more discussion about this approach to signal handling and why it needs a change to `std::process`. The other approach is for the library to set a signal-handling function (`signal()` / `sigaction()`): in that case, dispositions are reset to the default behavior on exec (since the function pointer isn't valid across exec), so we don't have to care about that here.\r\n\r\nAs part of this PR, I noticed that we had two somewhat-overlapping sets of bindings to signal functionality in `libstd`. One dated to old-IO and probably the old runtime, and was mostly unused. The other is currently used by `stack_overflow.rs`. I consolidated the two bindings into one set, and double-checked them by hand against all supported platforms' headers. This probably means it's safe to enable `stack_overflow.rs` on more targets, but I'm not including such a change in this PR.\r\n\r\nr? @alexcrichton\r\ncc @Zoxc for changes to `stack_overflow.rs`", "tree": {"sha": "8ac7c508782bf1b880c6e7a624025f52e5413e60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ac7c508782bf1b880c6e7a624025f52e5413e60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e2a898afcd890d44a45bd229dee8b9db8d330cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e2a898afcd890d44a45bd229dee8b9db8d330cc", "html_url": "https://github.com/rust-lang/rust/commit/4e2a898afcd890d44a45bd229dee8b9db8d330cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e2a898afcd890d44a45bd229dee8b9db8d330cc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2287b4b628cb6f4d66578e1298cd9f34e9ef77db", "url": "https://api.github.com/repos/rust-lang/rust/commits/2287b4b628cb6f4d66578e1298cd9f34e9ef77db", "html_url": "https://github.com/rust-lang/rust/commit/2287b4b628cb6f4d66578e1298cd9f34e9ef77db"}, {"sha": "a8dbb92b471cae1d3f8225857f5553311dd8aeb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8dbb92b471cae1d3f8225857f5553311dd8aeb3", "html_url": "https://github.com/rust-lang/rust/commit/a8dbb92b471cae1d3f8225857f5553311dd8aeb3"}], "stats": {"total": 705, "additions": 344, "deletions": 361}, "files": [{"sha": "e27e4ba5af2cfef796865d179ed93e6779004448", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e2a898afcd890d44a45bd229dee8b9db8d330cc/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2a898afcd890d44a45bd229dee8b9db8d330cc/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=4e2a898afcd890d44a45bd229dee8b9db8d330cc", "patch": "@@ -148,8 +148,6 @@\n #![feature(vec_push_all)]\n #![feature(wrapping)]\n #![feature(zero_one)]\n-#![cfg_attr(all(unix, not(target_os = \"macos\"), not(target_os = \"ios\")),\n-            feature(num_bits_bytes))]\n #![cfg_attr(windows, feature(str_utf16))]\n #![cfg_attr(test, feature(float_from_str_radix, range_inclusive, float_extras))]\n #![cfg_attr(test, feature(test, rustc_private, float_consts))]"}, {"sha": "a8127b3200f36da26b6eb01e278078f12c7c7a6a", "filename": "src/libstd/process.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4e2a898afcd890d44a45bd229dee8b9db8d330cc/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2a898afcd890d44a45bd229dee8b9db8d330cc/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=4e2a898afcd890d44a45bd229dee8b9db8d330cc", "patch": "@@ -769,24 +769,6 @@ mod tests {\n         }\n     }\n \n-    #[cfg(all(unix, not(target_os=\"android\")))]\n-    pub fn pwd_cmd() -> Command {\n-        Command::new(\"pwd\")\n-    }\n-    #[cfg(target_os=\"android\")]\n-    pub fn pwd_cmd() -> Command {\n-        let mut cmd = Command::new(\"/system/bin/sh\");\n-        cmd.arg(\"-c\").arg(\"pwd\");\n-        cmd\n-    }\n-\n-    #[cfg(windows)]\n-    pub fn pwd_cmd() -> Command {\n-        let mut cmd = Command::new(\"cmd\");\n-        cmd.arg(\"/c\").arg(\"cd\");\n-        cmd\n-    }\n-\n     #[cfg(all(unix, not(target_os=\"android\")))]\n     pub fn env_cmd() -> Command {\n         Command::new(\"env\")"}, {"sha": "99a6731c57d95317d597a8ddf4ac2c02f8ff03d8", "filename": "src/libstd/sys/unix/c.rs", "status": "modified", "additions": 216, "deletions": 205, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/4e2a898afcd890d44a45bd229dee8b9db8d330cc/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2a898afcd890d44a45bd229dee8b9db8d330cc/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=4e2a898afcd890d44a45bd229dee8b9db8d330cc", "patch": "@@ -8,15 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! C definitions used by libnative that don't belong in liblibc\n+//! C definitions used by std::sys that don't belong in liblibc\n+\n+// These are definitions sufficient for the users in this directory.\n+// This is not a general-purpose binding to this functionality, and in\n+// some cases (notably the definition of siginfo_t), we intentionally\n+// have incomplete bindings so that we don't need to fight with unions.\n+//\n+// Note that these types need to match the definitions from the platform\n+// libc (currently glibc on Linux), not the kernel definitions / the\n+// syscall interface.  This has a few weirdnesses, like glibc's sigset_t\n+// being 1024 bits on all platforms. If you're adding a new GNU/Linux\n+// port, check glibc's sysdeps/unix/sysv/linux, not the kernel headers.\n \n #![allow(dead_code)]\n #![allow(non_camel_case_types)]\n \n-pub use self::select::fd_set;\n-pub use self::signal::{sigaction, siginfo, sigset_t};\n-pub use self::signal::{SA_ONSTACK, SA_RESTART, SA_RESETHAND, SA_NOCLDSTOP};\n-pub use self::signal::{SA_NODEFER, SA_NOCLDWAIT, SA_SIGINFO, SIGCHLD};\n+pub use self::signal_os::{sigaction, siginfo, sigset_t, sigaltstack};\n+pub use self::signal_os::{SA_ONSTACK, SA_SIGINFO, SIGBUS, SIGSTKSZ, SIG_SETMASK};\n \n use libc;\n \n@@ -26,45 +35,21 @@ use libc;\n           target_os = \"dragonfly\",\n           target_os = \"bitrig\",\n           target_os = \"openbsd\"))]\n-mod consts {\n-    use libc;\n-    pub const FIONBIO: libc::c_ulong = 0x8004667e;\n-    pub const FIOCLEX: libc::c_ulong = 0x20006601;\n-    pub const FIONCLEX: libc::c_ulong = 0x20006602;\n-}\n+pub const FIOCLEX: libc::c_ulong = 0x20006601;\n+\n #[cfg(any(all(target_os = \"linux\",\n               any(target_arch = \"x86\",\n                   target_arch = \"x86_64\",\n                   target_arch = \"arm\",\n                   target_arch = \"aarch64\")),\n           target_os = \"android\"))]\n-mod consts {\n-    use libc;\n-    pub const FIONBIO: libc::c_ulong = 0x5421;\n-    pub const FIOCLEX: libc::c_ulong = 0x5451;\n-    pub const FIONCLEX: libc::c_ulong = 0x5450;\n-}\n+pub const FIOCLEX: libc::c_ulong = 0x5451;\n+\n #[cfg(all(target_os = \"linux\",\n           any(target_arch = \"mips\",\n               target_arch = \"mipsel\",\n               target_arch = \"powerpc\")))]\n-mod consts {\n-    use libc;\n-    pub const FIONBIO: libc::c_ulong = 0x667e;\n-    pub const FIOCLEX: libc::c_ulong = 0x6601;\n-    pub const FIONCLEX: libc::c_ulong = 0x6600;\n-}\n-pub use self::consts::*;\n-\n-#[cfg(any(target_os = \"macos\",\n-          target_os = \"ios\",\n-          target_os = \"freebsd\",\n-          target_os = \"dragonfly\",\n-          target_os = \"bitrig\",\n-          target_os = \"openbsd\"))]\n-pub const MSG_DONTWAIT: libc::c_int = 0x80;\n-#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-pub const MSG_DONTWAIT: libc::c_int = 0x40;\n+pub const FIOCLEX: libc::c_ulong = 0x6601;\n \n pub const WNOHANG: libc::c_int = 1;\n \n@@ -122,14 +107,14 @@ pub struct passwd {\n     pub pw_shell: *mut libc::c_char,\n }\n \n+// This is really a function pointer (or a union of multiple function\n+// pointers), except for constants like SIG_DFL.\n+pub type sighandler_t = *mut libc::c_void;\n+\n+pub const SIG_DFL: sighandler_t = 0 as sighandler_t;\n+pub const SIG_ERR: sighandler_t = !0 as sighandler_t;\n+\n extern {\n-    pub fn gettimeofday(timeval: *mut libc::timeval,\n-                        tzp: *mut libc::c_void) -> libc::c_int;\n-    pub fn select(nfds: libc::c_int,\n-                  readfds: *mut fd_set,\n-                  writefds: *mut fd_set,\n-                  errorfds: *mut fd_set,\n-                  timeout: *mut libc::timeval) -> libc::c_int;\n     pub fn getsockopt(sockfd: libc::c_int,\n                       level: libc::c_int,\n                       optname: libc::c_int,\n@@ -141,14 +126,21 @@ extern {\n     pub fn waitpid(pid: libc::pid_t, status: *mut libc::c_int,\n                    options: libc::c_int) -> libc::pid_t;\n \n+    pub fn raise(signum: libc::c_int) -> libc::c_int;\n+\n     pub fn sigaction(signum: libc::c_int,\n                      act: *const sigaction,\n                      oldact: *mut sigaction) -> libc::c_int;\n \n-    pub fn sigaddset(set: *mut sigset_t, signum: libc::c_int) -> libc::c_int;\n-    pub fn sigdelset(set: *mut sigset_t, signum: libc::c_int) -> libc::c_int;\n+    pub fn sigaltstack(ss: *const sigaltstack,\n+                       oss: *mut sigaltstack) -> libc::c_int;\n+\n+    #[cfg(not(target_os = \"android\"))]\n     pub fn sigemptyset(set: *mut sigset_t) -> libc::c_int;\n \n+    pub fn pthread_sigmask(how: libc::c_int, set: *const sigset_t,\n+                           oldset: *mut sigset_t) -> libc::c_int;\n+\n     #[cfg(not(target_os = \"ios\"))]\n     pub fn getpwuid_r(uid: libc::uid_t,\n                       pwd: *mut passwd,\n@@ -165,161 +157,188 @@ extern {\n                     -> *mut libc::c_char;\n }\n \n-#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-mod select {\n-    pub const FD_SETSIZE: usize = 1024;\n-\n-    #[repr(C)]\n-    pub struct fd_set {\n-        fds_bits: [i32; (FD_SETSIZE / 32)]\n-    }\n-\n-    pub fn fd_set(set: &mut fd_set, fd: i32) {\n-        set.fds_bits[(fd / 32) as usize] |= 1 << ((fd % 32) as usize);\n-    }\n-}\n-\n-#[cfg(any(target_os = \"android\",\n-          target_os = \"freebsd\",\n-          target_os = \"dragonfly\",\n-          target_os = \"bitrig\",\n-          target_os = \"openbsd\",\n-          target_os = \"linux\"))]\n-mod select {\n-    use usize;\n-    use libc;\n-\n-    pub const FD_SETSIZE: usize = 1024;\n-\n-    #[repr(C)]\n-    pub struct fd_set {\n-        // FIXME: shouldn't this be a c_ulong?\n-        fds_bits: [libc::uintptr_t; (FD_SETSIZE / usize::BITS)]\n-    }\n-\n-    pub fn fd_set(set: &mut fd_set, fd: i32) {\n-        let fd = fd as usize;\n-        set.fds_bits[fd / usize::BITS] |= 1 << (fd % usize::BITS);\n-    }\n+// Ugh. This is only available as an inline until Android API 21.\n+#[cfg(target_os = \"android\")]\n+pub unsafe fn sigemptyset(set: *mut sigset_t) -> libc::c_int {\n+    use intrinsics;\n+    intrinsics::write_bytes(set, 0, 1);\n+    return 0;\n }\n \n-#[cfg(any(all(target_os = \"linux\",\n-              any(target_arch = \"x86\",\n-                  target_arch = \"x86_64\",\n-                  target_arch = \"arm\",\n-                  target_arch = \"aarch64\")),\n+#[cfg(any(target_os = \"linux\",\n           target_os = \"android\"))]\n-mod signal {\n+mod signal_os {\n+    pub use self::arch::{SA_ONSTACK, SA_SIGINFO, SIGBUS, SIG_SETMASK,\n+                         sigaction, sigaltstack};\n     use libc;\n \n-    pub const SA_NOCLDSTOP: libc::c_ulong = 0x00000001;\n-    pub const SA_NOCLDWAIT: libc::c_ulong = 0x00000002;\n-    pub const SA_NODEFER: libc::c_ulong = 0x40000000;\n-    pub const SA_ONSTACK: libc::c_ulong = 0x08000000;\n-    pub const SA_RESETHAND: libc::c_ulong = 0x80000000;\n-    pub const SA_RESTART: libc::c_ulong = 0x10000000;\n-    pub const SA_SIGINFO: libc::c_ulong = 0x00000004;\n-    pub const SIGCHLD: libc::c_int = 17;\n-\n-    // This definition is not as accurate as it could be, {pid, uid, status} is\n-    // actually a giant union. Currently we're only interested in these fields,\n-    // however.\n+    #[cfg(any(target_arch = \"x86\",\n+              target_arch = \"x86_64\",\n+              target_arch = \"arm\",\n+              target_arch = \"mips\",\n+              target_arch = \"mipsel\"))]\n+    pub const SIGSTKSZ: libc::size_t = 8192;\n+\n+    // This is smaller on musl and Android, but no harm in being generous.\n+    #[cfg(any(target_arch = \"aarch64\",\n+              target_arch = \"powerpc\"))]\n+    pub const SIGSTKSZ: libc::size_t = 16384;\n+\n+    // This definition is intentionally a subset of the C structure: the\n+    // fields after si_code are actually a giant union. We're only\n+    // interested in si_addr for this module, though.\n     #[repr(C)]\n     pub struct siginfo {\n-        si_signo: libc::c_int,\n-        si_errno: libc::c_int,\n-        si_code: libc::c_int,\n-        pub pid: libc::pid_t,\n-        pub uid: libc::uid_t,\n-        pub status: libc::c_int,\n+        _signo: libc::c_int,\n+        _errno: libc::c_int,\n+        _code: libc::c_int,\n+        // This structure will need extra padding here for MIPS64.\n+        pub si_addr: *mut libc::c_void\n     }\n \n+    #[cfg(all(target_os = \"linux\", target_pointer_width = \"32\"))]\n     #[repr(C)]\n-    pub struct sigaction {\n-        pub sa_handler: extern fn(libc::c_int),\n-        pub sa_mask: sigset_t,\n-        pub sa_flags: libc::c_ulong,\n-        sa_restorer: *mut libc::c_void,\n-    }\n-\n-    unsafe impl ::marker::Send for sigaction { }\n-    unsafe impl ::marker::Sync for sigaction { }\n-\n-    #[repr(C)]\n-    #[cfg(target_pointer_width = \"32\")]\n     pub struct sigset_t {\n         __val: [libc::c_ulong; 32],\n     }\n \n+    #[cfg(all(target_os = \"linux\", target_pointer_width = \"64\"))]\n     #[repr(C)]\n-    #[cfg(target_pointer_width = \"64\")]\n     pub struct sigset_t {\n         __val: [libc::c_ulong; 16],\n     }\n-}\n \n-#[cfg(all(target_os = \"linux\",\n-          any(target_arch = \"mips\",\n-              target_arch = \"mipsel\",\n-              target_arch = \"powerpc\")))]\n-mod signal {\n-    use libc;\n-\n-    pub const SA_NOCLDSTOP: libc::c_ulong = 0x00000001;\n-    pub const SA_NOCLDWAIT: libc::c_ulong = 0x00010000;\n-    pub const SA_NODEFER: libc::c_ulong = 0x40000000;\n-    pub const SA_ONSTACK: libc::c_ulong = 0x08000000;\n-    pub const SA_RESETHAND: libc::c_ulong = 0x80000000;\n-    pub const SA_RESTART: libc::c_ulong = 0x10000000;\n-    pub const SA_SIGINFO: libc::c_ulong = 0x00000008;\n-    pub const SIGCHLD: libc::c_int = 18;\n-\n-    // This definition is not as accurate as it could be, {pid, uid, status} is\n-    // actually a giant union. Currently we're only interested in these fields,\n-    // however.\n-    #[repr(C)]\n-    pub struct siginfo {\n-        si_signo: libc::c_int,\n-        si_code: libc::c_int,\n-        si_errno: libc::c_int,\n-        pub pid: libc::pid_t,\n-        pub uid: libc::uid_t,\n-        pub status: libc::c_int,\n+    // Android for MIPS has a 128-bit sigset_t, but we don't currently\n+    // support it. Android for AArch64 technically has a structure of a\n+    // single ulong.\n+    #[cfg(target_os = \"android\")]\n+    pub type sigset_t = libc::c_ulong;\n+\n+    #[cfg(any(target_arch = \"x86\",\n+              target_arch = \"x86_64\",\n+              target_arch = \"powerpc\",\n+              target_arch = \"arm\",\n+              target_arch = \"aarch64\"))]\n+    mod arch {\n+        use libc;\n+        use super::super::sighandler_t;\n+        use super::sigset_t;\n+\n+        pub const SA_ONSTACK: libc::c_ulong = 0x08000000;\n+        pub const SA_SIGINFO: libc::c_ulong = 0x00000004;\n+\n+        pub const SIGBUS: libc::c_int = 7;\n+\n+        pub const SIG_SETMASK: libc::c_int = 2;\n+\n+        #[cfg(target_os = \"linux\")]\n+        #[repr(C)]\n+        pub struct sigaction {\n+            pub sa_sigaction: sighandler_t,\n+            pub sa_mask: sigset_t,\n+            pub sa_flags: libc::c_ulong,\n+            _restorer: *mut libc::c_void,\n+        }\n+\n+        #[cfg(all(target_os = \"android\", target_pointer_width = \"32\"))]\n+        #[repr(C)]\n+        pub struct sigaction {\n+            pub sa_sigaction: sighandler_t,\n+            pub sa_flags: libc::c_ulong,\n+            _restorer: *mut libc::c_void,\n+            pub sa_mask: sigset_t,\n+        }\n+\n+        #[cfg(all(target_os = \"android\", target_pointer_width = \"64\"))]\n+        #[repr(C)]\n+        pub struct sigaction {\n+            pub sa_flags: libc::c_uint,\n+            pub sa_sigaction: sighandler_t,\n+            pub sa_mask: sigset_t,\n+            _restorer: *mut libc::c_void,\n+        }\n+\n+        #[repr(C)]\n+        pub struct sigaltstack {\n+            pub ss_sp: *mut libc::c_void,\n+            pub ss_flags: libc::c_int,\n+            pub ss_size: libc::size_t\n+        }\n     }\n \n-    #[repr(C)]\n-    pub struct sigaction {\n-        pub sa_flags: libc::c_uint,\n-        pub sa_handler: extern fn(libc::c_int),\n-        pub sa_mask: sigset_t,\n-        sa_restorer: *mut libc::c_void,\n-        sa_resv: [libc::c_int; 1],\n-    }\n-\n-    unsafe impl ::marker::Send for sigaction { }\n-    unsafe impl ::marker::Sync for sigaction { }\n-\n-    #[repr(C)]\n-    pub struct sigset_t {\n-        __val: [libc::c_ulong; 32],\n+    #[cfg(any(target_arch = \"mips\",\n+              target_arch = \"mipsel\"))]\n+    mod arch {\n+        use libc;\n+        use super::super::sighandler_t;\n+        use super::sigset_t;\n+\n+        pub const SA_ONSTACK: libc::c_ulong = 0x08000000;\n+        pub const SA_SIGINFO: libc::c_ulong = 0x00000008;\n+\n+        pub const SIGBUS: libc::c_int = 10;\n+\n+        pub const SIG_SETMASK: libc::c_int = 3;\n+\n+        #[cfg(all(target_os = \"linux\", not(target_env = \"musl\")))]\n+        #[repr(C)]\n+        pub struct sigaction {\n+            pub sa_flags: libc::c_uint,\n+            pub sa_sigaction: sighandler_t,\n+            pub sa_mask: sigset_t,\n+            _restorer: *mut libc::c_void,\n+            _resv: [libc::c_int; 1],\n+        }\n+\n+        #[cfg(target_env = \"musl\")]\n+        #[repr(C)]\n+        pub struct sigaction {\n+            pub sa_sigaction: sighandler_t,\n+            pub sa_mask: sigset_t,\n+            pub sa_flags: libc::c_ulong,\n+            _restorer: *mut libc::c_void,\n+        }\n+\n+        #[cfg(target_os = \"android\")]\n+        #[repr(C)]\n+        pub struct sigaction {\n+            pub sa_flags: libc::c_uint,\n+            pub sa_sigaction: sighandler_t,\n+            pub sa_mask: sigset_t,\n+        }\n+\n+        #[repr(C)]\n+        pub struct sigaltstack {\n+            pub ss_sp: *mut libc::c_void,\n+            pub ss_size: libc::size_t,\n+            pub ss_flags: libc::c_int,\n+        }\n     }\n }\n \n #[cfg(any(target_os = \"macos\",\n           target_os = \"ios\",\n           target_os = \"freebsd\",\n-          target_os = \"dragonfly\"))]\n-mod signal {\n+          target_os = \"dragonfly\",\n+          target_os = \"bitrig\",\n+          target_os = \"openbsd\"))]\n+mod signal_os {\n     use libc;\n+    use super::sighandler_t;\n \n     pub const SA_ONSTACK: libc::c_int = 0x0001;\n-    pub const SA_RESTART: libc::c_int = 0x0002;\n-    pub const SA_RESETHAND: libc::c_int = 0x0004;\n-    pub const SA_NOCLDSTOP: libc::c_int = 0x0008;\n-    pub const SA_NODEFER: libc::c_int = 0x0010;\n-    pub const SA_NOCLDWAIT: libc::c_int = 0x0020;\n     pub const SA_SIGINFO: libc::c_int = 0x0040;\n-    pub const SIGCHLD: libc::c_int = 20;\n+\n+    pub const SIGBUS: libc::c_int = 10;\n+\n+    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+    pub const SIGSTKSZ: libc::size_t = 131072;\n+    // FreeBSD's is actually arch-dependent, but never more than 40960.\n+    // No harm in being generous.\n+    #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n+    pub const SIGSTKSZ: libc::size_t = 40960;\n+\n+    pub const SIG_SETMASK: libc::c_int = 3;\n \n     #[cfg(any(target_os = \"macos\",\n               target_os = \"ios\"))]\n@@ -329,61 +348,53 @@ mod signal {\n     pub struct sigset_t {\n         bits: [u32; 4],\n     }\n+    #[cfg(any(target_os = \"bitrig\", target_os = \"openbsd\"))]\n+    pub type sigset_t = libc::c_uint;\n \n     // This structure has more fields, but we're not all that interested in\n     // them.\n+    #[cfg(any(target_os = \"macos\", target_os = \"ios\",\n+              target_os = \"freebsd\", target_os = \"dragonfly\"))]\n+    #[repr(C)]\n+    pub struct siginfo {\n+        pub _signo: libc::c_int,\n+        pub _errno: libc::c_int,\n+        pub _code: libc::c_int,\n+        pub _pid: libc::pid_t,\n+        pub _uid: libc::uid_t,\n+        pub _status: libc::c_int,\n+        pub si_addr: *mut libc::c_void\n+    }\n+    #[cfg(any(target_os = \"bitrig\", target_os = \"openbsd\"))]\n     #[repr(C)]\n     pub struct siginfo {\n         pub si_signo: libc::c_int,\n-        pub si_errno: libc::c_int,\n         pub si_code: libc::c_int,\n-        pub pid: libc::pid_t,\n-        pub uid: libc::uid_t,\n-        pub status: libc::c_int,\n+        pub si_errno: libc::c_int,\n+        pub si_addr: *mut libc::c_void\n     }\n \n+    #[cfg(any(target_os = \"macos\", target_os = \"ios\",\n+              target_os = \"bitrig\", target_os = \"openbsd\"))]\n     #[repr(C)]\n     pub struct sigaction {\n-        pub sa_handler: extern fn(libc::c_int),\n-        pub sa_flags: libc::c_int,\n+        pub sa_sigaction: sighandler_t,\n         pub sa_mask: sigset_t,\n+        pub sa_flags: libc::c_int,\n     }\n-}\n-\n-#[cfg(any(target_os = \"bitrig\", target_os = \"openbsd\"))]\n-mod signal {\n-    use libc;\n-\n-    pub const SA_ONSTACK: libc::c_int = 0x0001;\n-    pub const SA_RESTART: libc::c_int = 0x0002;\n-    pub const SA_RESETHAND: libc::c_int = 0x0004;\n-    pub const SA_NOCLDSTOP: libc::c_int = 0x0008;\n-    pub const SA_NODEFER: libc::c_int = 0x0010;\n-    pub const SA_NOCLDWAIT: libc::c_int = 0x0020;\n-    pub const SA_SIGINFO: libc::c_int = 0x0040;\n-    pub const SIGCHLD: libc::c_int = 20;\n-\n-    pub type sigset_t = libc::c_uint;\n \n-    // This structure has more fields, but we're not all that interested in\n-    // them.\n+    #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))]\n     #[repr(C)]\n-    pub struct siginfo {\n-        pub si_signo: libc::c_int,\n-        pub si_code: libc::c_int,\n-        pub si_errno: libc::c_int,\n-        // FIXME: Bitrig has a crazy union here in the siginfo, I think this\n-        // layout will still work tho.  The status might be off by the size of\n-        // a clock_t by my reading, but we can fix this later.\n-        pub pid: libc::pid_t,\n-        pub uid: libc::uid_t,\n-        pub status: libc::c_int,\n+    pub struct sigaction {\n+        pub sa_sigaction: sighandler_t,\n+        pub sa_flags: libc::c_int,\n+        pub sa_mask: sigset_t,\n     }\n \n     #[repr(C)]\n-    pub struct sigaction {\n-        pub sa_handler: extern fn(libc::c_int),\n-        pub sa_mask: sigset_t,\n-        pub sa_flags: libc::c_int,\n+    pub struct sigaltstack {\n+        pub ss_sp: *mut libc::c_void,\n+        pub ss_size: libc::size_t,\n+        pub ss_flags: libc::c_int,\n     }\n }"}, {"sha": "695d0ddfaaf61f455cbb4faa23d3b276d91418c6", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/4e2a898afcd890d44a45bd229dee8b9db8d330cc/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2a898afcd890d44a45bd229dee8b9db8d330cc/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=4e2a898afcd890d44a45bd229dee8b9db8d330cc", "patch": "@@ -17,6 +17,7 @@ use ffi::{OsString, OsStr, CString, CStr};\n use fmt;\n use io::{self, Error, ErrorKind};\n use libc::{self, pid_t, c_void, c_int, gid_t, uid_t};\n+use mem;\n use ptr;\n use sys::fd::FileDesc;\n use sys::fs::{File, OpenOptions};\n@@ -313,6 +314,23 @@ impl Process {\n         if !envp.is_null() {\n             *sys::os::environ() = envp as *const _;\n         }\n+\n+        // Reset signal handling so the child process starts in a\n+        // standardized state. libstd ignores SIGPIPE, and signal-handling\n+        // libraries often set a mask. Child processes inherit ignored\n+        // signals and the signal mask from their parent, but most\n+        // UNIX programs do not reset these things on their own, so we\n+        // need to clean things up now to avoid confusing the program\n+        // we're about to run.\n+        let mut set: c::sigset_t = mem::uninitialized();\n+        if c::sigemptyset(&mut set) != 0 ||\n+           c::pthread_sigmask(c::SIG_SETMASK, &set, ptr::null_mut()) != 0 ||\n+           libc::funcs::posix01::signal::signal(\n+               libc::SIGPIPE, mem::transmute(c::SIG_DFL)\n+           ) == mem::transmute(c::SIG_ERR) {\n+            fail(&mut output);\n+        }\n+\n         let _ = libc::execvp(*argv, argv);\n         fail(&mut output)\n     }\n@@ -418,3 +436,69 @@ fn translate_status(status: c_int) -> ExitStatus {\n         ExitStatus::Signal(imp::WTERMSIG(status))\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use prelude::v1::*;\n+\n+    use ffi::OsStr;\n+    use mem;\n+    use ptr;\n+    use libc;\n+    use slice;\n+    use sys::{self, c, cvt, pipe};\n+\n+    #[cfg(not(target_os = \"android\"))]\n+    extern {\n+        fn sigaddset(set: *mut c::sigset_t, signum: libc::c_int) -> libc::c_int;\n+    }\n+\n+    #[cfg(target_os = \"android\")]\n+    unsafe fn sigaddset(set: *mut c::sigset_t, signum: libc::c_int) -> libc::c_int {\n+        let raw = slice::from_raw_parts_mut(set as *mut u8, mem::size_of::<c::sigset_t>());\n+        let bit = (signum - 1) as usize;\n+        raw[bit / 8] |= 1 << (bit % 8);\n+        return 0;\n+    }\n+\n+    #[test]\n+    fn test_process_mask() {\n+        unsafe {\n+            // Test to make sure that a signal mask does not get inherited.\n+            let cmd = Command::new(OsStr::new(\"cat\"));\n+            let (stdin_read, stdin_write) = sys::pipe::anon_pipe().unwrap();\n+            let (stdout_read, stdout_write) = sys::pipe::anon_pipe().unwrap();\n+\n+            let mut set: c::sigset_t = mem::uninitialized();\n+            let mut old_set: c::sigset_t = mem::uninitialized();\n+            cvt(c::sigemptyset(&mut set)).unwrap();\n+            cvt(sigaddset(&mut set, libc::SIGINT)).unwrap();\n+            cvt(c::pthread_sigmask(c::SIG_SETMASK, &set, &mut old_set)).unwrap();\n+\n+            let cat = Process::spawn(&cmd, Stdio::Raw(stdin_read.raw()),\n+                                           Stdio::Raw(stdout_write.raw()),\n+                                           Stdio::None).unwrap();\n+            drop(stdin_read);\n+            drop(stdout_write);\n+\n+            cvt(c::pthread_sigmask(c::SIG_SETMASK, &old_set, ptr::null_mut())).unwrap();\n+\n+            cvt(libc::funcs::posix88::signal::kill(cat.id() as libc::pid_t, libc::SIGINT)).unwrap();\n+            // We need to wait until SIGINT is definitely delivered. The\n+            // easiest way is to write something to cat, and try to read it\n+            // back: if SIGINT is unmasked, it'll get delivered when cat is\n+            // next scheduled.\n+            let _ = stdin_write.write(b\"Hello\");\n+            drop(stdin_write);\n+\n+            // Either EOF or failure (EPIPE) is okay.\n+            let mut buf = [0; 5];\n+            if let Ok(ret) = stdout_read.read(&mut buf) {\n+                assert!(ret == 0);\n+            }\n+\n+            cat.wait().unwrap();\n+        }\n+    }\n+}"}, {"sha": "52494a17b9d24f314a44b4504d15fc1e8aa5ce4b", "filename": "src/libstd/sys/unix/stack_overflow.rs", "status": "modified", "additions": 5, "deletions": 136, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/4e2a898afcd890d44a45bd229dee8b9db8d330cc/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2a898afcd890d44a45bd229dee8b9db8d330cc/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs?ref=4e2a898afcd890d44a45bd229dee8b9db8d330cc", "patch": "@@ -44,11 +44,12 @@ mod imp {\n     use mem;\n     use ptr;\n     use intrinsics;\n-    use self::signal::{siginfo, sigaction, SIGBUS, SIG_DFL,\n-                       SA_SIGINFO, SA_ONSTACK, sigaltstack,\n-                       SIGSTKSZ};\n+    use sys::c::{siginfo, sigaction, SIGBUS, SIG_DFL,\n+                 SA_SIGINFO, SA_ONSTACK, sigaltstack,\n+                 SIGSTKSZ, sighandler_t, raise};\n     use libc;\n     use libc::funcs::posix88::mman::{mmap, munmap};\n+    use libc::funcs::posix01::signal::signal;\n     use libc::consts::os::posix88::{SIGSEGV,\n                                     PROT_READ,\n                                     PROT_WRITE,\n@@ -120,7 +121,7 @@ mod imp {\n \n     pub unsafe fn make_handler() -> Handler {\n         let alt_stack = mmap(ptr::null_mut(),\n-                             signal::SIGSTKSZ,\n+                             SIGSTKSZ,\n                              PROT_READ | PROT_WRITE,\n                              MAP_PRIVATE | MAP_ANON,\n                              -1,\n@@ -143,138 +144,6 @@ mod imp {\n     pub unsafe fn drop_handler(handler: &mut Handler) {\n         munmap(handler._data, SIGSTKSZ);\n     }\n-\n-    pub type sighandler_t = *mut libc::c_void;\n-\n-    #[cfg(any(all(target_os = \"linux\", target_arch = \"x86\"), // may not match\n-              all(target_os = \"linux\", target_arch = \"x86_64\"),\n-              all(target_os = \"linux\", target_arch = \"arm\"), // may not match\n-              all(target_os = \"linux\", target_arch = \"aarch64\"),\n-              all(target_os = \"linux\", target_arch = \"mips\"), // may not match\n-              all(target_os = \"linux\", target_arch = \"mipsel\"), // may not match\n-              all(target_os = \"linux\", target_arch = \"powerpc\"), // may not match\n-              target_os = \"android\"))] // may not match\n-    mod signal {\n-        use libc;\n-        pub use super::sighandler_t;\n-\n-        pub static SA_ONSTACK: libc::c_int = 0x08000000;\n-        pub static SA_SIGINFO: libc::c_int = 0x00000004;\n-        pub static SIGBUS: libc::c_int = 7;\n-\n-        pub static SIGSTKSZ: libc::size_t = 8192;\n-\n-        pub const SIG_DFL: sighandler_t = 0 as sighandler_t;\n-\n-        // This definition is not as accurate as it could be, {si_addr} is\n-        // actually a giant union. Currently we're only interested in that field,\n-        // however.\n-        #[repr(C)]\n-        pub struct siginfo {\n-            si_signo: libc::c_int,\n-            si_errno: libc::c_int,\n-            si_code: libc::c_int,\n-            pub si_addr: *mut libc::c_void\n-        }\n-\n-        #[repr(C)]\n-        pub struct sigaction {\n-            pub sa_sigaction: sighandler_t,\n-            pub sa_mask: sigset_t,\n-            pub sa_flags: libc::c_int,\n-            sa_restorer: *mut libc::c_void,\n-        }\n-\n-        #[cfg(target_pointer_width = \"32\")]\n-        #[repr(C)]\n-        pub struct sigset_t {\n-            __val: [libc::c_ulong; 32],\n-        }\n-        #[cfg(target_pointer_width = \"64\")]\n-        #[repr(C)]\n-        pub struct sigset_t {\n-            __val: [libc::c_ulong; 16],\n-        }\n-\n-        #[repr(C)]\n-        pub struct sigaltstack {\n-            pub ss_sp: *mut libc::c_void,\n-            pub ss_flags: libc::c_int,\n-            pub ss_size: libc::size_t\n-        }\n-\n-    }\n-\n-    #[cfg(any(target_os = \"macos\",\n-              target_os = \"bitrig\",\n-              target_os = \"openbsd\"))]\n-    mod signal {\n-        use libc;\n-        pub use super::sighandler_t;\n-\n-        pub const SA_ONSTACK: libc::c_int = 0x0001;\n-        pub const SA_SIGINFO: libc::c_int = 0x0040;\n-        pub const SIGBUS: libc::c_int = 10;\n-\n-        #[cfg(target_os = \"macos\")]\n-        pub const SIGSTKSZ: libc::size_t = 131072;\n-        #[cfg(any(target_os = \"bitrig\", target_os = \"openbsd\"))]\n-        pub const SIGSTKSZ: libc::size_t = 40960;\n-\n-        pub const SIG_DFL: sighandler_t = 0 as sighandler_t;\n-\n-        pub type sigset_t = u32;\n-\n-        // This structure has more fields, but we're not all that interested in\n-        // them.\n-        #[cfg(target_os = \"macos\")]\n-        #[repr(C)]\n-        pub struct siginfo {\n-            pub si_signo: libc::c_int,\n-            pub si_errno: libc::c_int,\n-            pub si_code: libc::c_int,\n-            pub pid: libc::pid_t,\n-            pub uid: libc::uid_t,\n-            pub status: libc::c_int,\n-            pub si_addr: *mut libc::c_void\n-        }\n-\n-        #[cfg(any(target_os = \"bitrig\", target_os = \"openbsd\"))]\n-        #[repr(C)]\n-        pub struct siginfo {\n-            pub si_signo: libc::c_int,\n-            pub si_code: libc::c_int,\n-            pub si_errno: libc::c_int,\n-            //union\n-            pub si_addr: *mut libc::c_void\n-        }\n-\n-        #[repr(C)]\n-        pub struct sigaltstack {\n-            pub ss_sp: *mut libc::c_void,\n-            pub ss_size: libc::size_t,\n-            pub ss_flags: libc::c_int\n-        }\n-\n-        #[repr(C)]\n-        pub struct sigaction {\n-            pub sa_sigaction: sighandler_t,\n-            pub sa_mask: sigset_t,\n-            pub sa_flags: libc::c_int,\n-        }\n-    }\n-\n-    extern {\n-        pub fn signal(signum: libc::c_int, handler: sighandler_t) -> sighandler_t;\n-        pub fn raise(signum: libc::c_int) -> libc::c_int;\n-\n-        pub fn sigaction(signum: libc::c_int,\n-                         act: *const sigaction,\n-                         oldact: *mut sigaction) -> libc::c_int;\n-\n-        pub fn sigaltstack(ss: *const sigaltstack,\n-                           oss: *mut sigaltstack) -> libc::c_int;\n-    }\n }\n \n #[cfg(not(any(target_os = \"linux\","}, {"sha": "5bff4fa080a34d2aa4f2220807342ea06b6edf91", "filename": "src/test/run-pass/process-sigpipe.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4e2a898afcd890d44a45bd229dee8b9db8d330cc/src%2Ftest%2Frun-pass%2Fprocess-sigpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2a898afcd890d44a45bd229dee8b9db8d330cc/src%2Ftest%2Frun-pass%2Fprocess-sigpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-sigpipe.rs?ref=4e2a898afcd890d44a45bd229dee8b9db8d330cc", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-android since the dynamic linker sets a SIGPIPE handler (to do\n+// a crash report) so inheritance is moot on the entire platform\n+\n+// libstd ignores SIGPIPE, and other libraries may set signal masks.\n+// Make sure that these behaviors don't get inherited to children\n+// spawned via std::process, since they're needed for traditional UNIX\n+// filter behavior. This test checks that `yes | head` terminates\n+// (instead of running forever), and that it does not print an error\n+// message about a broken pipe.\n+\n+use std::process;\n+use std::thread;\n+\n+#[cfg(unix)]\n+fn main() {\n+    // Just in case `yes` doesn't check for EPIPE...\n+    thread::spawn(|| {\n+        thread::sleep_ms(5000);\n+        process::exit(1);\n+    });\n+    let output = process::Command::new(\"sh\").arg(\"-c\").arg(\"yes | head\").output().unwrap();\n+    assert!(output.status.success());\n+    assert!(output.stderr.len() == 0);\n+}\n+\n+#[cfg(not(unix))]\n+fn main() {\n+    // Not worried about signal masks on other platforms\n+}"}]}