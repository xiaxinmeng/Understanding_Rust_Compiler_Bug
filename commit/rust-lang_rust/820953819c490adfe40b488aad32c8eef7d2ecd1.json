{"sha": "820953819c490adfe40b488aad32c8eef7d2ecd1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyMDk1MzgxOWM0OTBhZGZlNDBiNDg4YWFkMzJjOGVlZjdkMmVjZDE=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-09-26T17:12:49Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-10-11T16:09:48Z"}, "message": "Add `relaxed_delim_match` parameter", "tree": {"sha": "f265e693e3f5c8b23ce86d66dd13a393a3341be7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f265e693e3f5c8b23ce86d66dd13a393a3341be7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/820953819c490adfe40b488aad32c8eef7d2ecd1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl+DLkwACgkQtAh+UQ6Y\nsWSeRQ//dVB3ER91uZl1sbC2uvgkmJX/c288p22HguOYC40ZfpuTRKpMhy+08x04\nrOVTP91NzULcQsCY7WKequwedDw8ORy0O0tXSj0FBoG1nUz8mGxREJP4AJtVbBwt\nX0kefdLS1UUf+tY1JQrspWacZ3AiUcriiTAwbLvxa/Ydrghx/lo2e7BVHLCR/xNt\nnKPj4Mgl+oLYhK4aBq1Fw1uG1kAhyU5e/Jd5WvQ6fDx5wTdqgRgohjC42RoBQgEp\npewiZ8wV1pB32tp6qHGxRC1CQGUAHU4IWIbGpc3z4F8BCHArYec4jtU6kjpl0+nf\nHdMJa0vDyKgV8veKw88sS6wkVASrQwRQrQ1lVvl4FBFF98UhQvyVe8N672FcPEZW\nxtmd0CQC/gNPpOCDp+NRxH+M/9aZoxVKqk67ppPIOmfIPcyZM0RqLL3Y34JX5EAH\nL5KnrAGegzGkutTQxCmQO4LsAW8hgcIhfxMM9plq4Le7dSWBKI3GxzmMLGlIjeyQ\nkQ3nVadT2alvF1CiuGpj+kuVPGraHRQagrEOLr/xkKy+cjX7K/+3eMMP1lDEmpqR\nRY9Gju9yq3545z+nKdFZewCbEnxz5TmSr/fnS3Oap+lYIwrLoqzeXwJd6HO2i2wY\nThg5Jif++lbEY8DGnWRiYyLlaF7hJFClKpwWSqooPPNQDRIS2v4=\n=h6Dy\n-----END PGP SIGNATURE-----", "payload": "tree f265e693e3f5c8b23ce86d66dd13a393a3341be7\nparent ea468f427016bbf89819199bb8420afc27e64a7f\nauthor Aaron Hill <aa1ronham@gmail.com> 1601140369 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1602432588 -0400\n\nAdd `relaxed_delim_match` parameter\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/820953819c490adfe40b488aad32c8eef7d2ecd1", "html_url": "https://github.com/rust-lang/rust/commit/820953819c490adfe40b488aad32c8eef7d2ecd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/820953819c490adfe40b488aad32c8eef7d2ecd1/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea468f427016bbf89819199bb8420afc27e64a7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea468f427016bbf89819199bb8420afc27e64a7f", "html_url": "https://github.com/rust-lang/rust/commit/ea468f427016bbf89819199bb8420afc27e64a7f"}], "stats": {"total": 69, "additions": 53, "deletions": 16}, "files": [{"sha": "dbdabdbb8e506053b0ce62cc3b61069326f1eb39", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 53, "deletions": 16, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/820953819c490adfe40b488aad32c8eef7d2ecd1/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/820953819c490adfe40b488aad32c8eef7d2ecd1/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=820953819c490adfe40b488aad32c8eef7d2ecd1", "patch": "@@ -7,8 +7,8 @@\n #![feature(or_patterns)]\n \n use rustc_ast as ast;\n-use rustc_ast::token::{self, Nonterminal, Token, TokenKind};\n-use rustc_ast::tokenstream::{self, TokenStream, TokenTree};\n+use rustc_ast::token::{self, DelimToken, Nonterminal, Token, TokenKind};\n+use rustc_ast::tokenstream::{self, Spacing, TokenStream, TokenTree};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Diagnostic, FatalError, Level, PResult};\n@@ -329,9 +329,8 @@ pub fn nt_to_tokenstream(nt: &Nonterminal, sess: &ParseSess, span: Span) -> Toke\n     // modifications, including adding/removing typically non-semantic\n     // tokens such as extra braces and commas, don't happen.\n     if let Some(tokens) = tokens {\n-        // If the streams match, then the AST hasn't been modified. Return the captured\n-        // `TokenStream`.\n-        if tokenstream_probably_equal_for_proc_macro(&tokens, &reparsed_tokens, sess) {\n+        // Compare with a non-relaxed delim match to start.\n+        if tokenstream_probably_equal_for_proc_macro(&tokens, &reparsed_tokens, sess, false) {\n             return tokens;\n         }\n \n@@ -340,23 +339,33 @@ pub fn nt_to_tokenstream(nt: &Nonterminal, sess: &ParseSess, span: Span) -> Toke\n         // token stream to match up with inserted parenthesis in the reparsed stream.\n         let source_with_parens = pprust::nonterminal_to_string(nt);\n         let filename_with_parens = FileName::macro_expansion_source_code(&source_with_parens);\n-        let tokens_with_parens = parse_stream_from_source_str(\n+        let reparsed_tokens_with_parens = parse_stream_from_source_str(\n             filename_with_parens,\n             source_with_parens,\n             sess,\n             Some(span),\n         );\n \n-        if tokenstream_probably_equal_for_proc_macro(&tokens, &tokens_with_parens, sess) {\n+        // Compare with a relaxed delim match - we want inserted parenthesis in the\n+        // reparsed stream to match `None`-delimiters in the original stream.\n+        if tokenstream_probably_equal_for_proc_macro(\n+            &tokens,\n+            &reparsed_tokens_with_parens,\n+            sess,\n+            true,\n+        ) {\n             return tokens;\n         }\n \n         info!(\n             \"cached tokens found, but they're not \\\"probably equal\\\", \\\n                 going with stringified version\"\n         );\n-        info!(\"cached tokens: {:?}\", tokens);\n-        info!(\"reparsed tokens: {:?}\", reparsed_tokens);\n+        info!(\"cached   tokens: {}\", pprust::tts_to_string(&tokens));\n+        info!(\"reparsed tokens: {}\", pprust::tts_to_string(&reparsed_tokens_with_parens));\n+\n+        info!(\"cached   tokens debug: {:?}\", tokens);\n+        info!(\"reparsed tokens debug: {:?}\", reparsed_tokens_with_parens);\n     }\n     reparsed_tokens\n }\n@@ -370,6 +379,7 @@ pub fn tokenstream_probably_equal_for_proc_macro(\n     tokens: &TokenStream,\n     reparsed_tokens: &TokenStream,\n     sess: &ParseSess,\n+    relaxed_delim_match: bool,\n ) -> bool {\n     // When checking for `probably_eq`, we ignore certain tokens that aren't\n     // preserved in the AST. Because they are not preserved, the pretty\n@@ -495,7 +505,9 @@ pub fn tokenstream_probably_equal_for_proc_macro(\n     let tokens = tokens.trees().flat_map(|t| expand_token(t, sess));\n     let reparsed_tokens = reparsed_tokens.trees().flat_map(|t| expand_token(t, sess));\n \n-    tokens.eq_by(reparsed_tokens, |t, rt| tokentree_probably_equal_for_proc_macro(&t, &rt, sess))\n+    tokens.eq_by(reparsed_tokens, |t, rt| {\n+        tokentree_probably_equal_for_proc_macro(&t, &rt, sess, relaxed_delim_match)\n+    })\n }\n \n // See comments in `Nonterminal::to_tokenstream` for why we care about\n@@ -507,17 +519,42 @@ pub fn tokentree_probably_equal_for_proc_macro(\n     token: &TokenTree,\n     reparsed_token: &TokenTree,\n     sess: &ParseSess,\n+    relaxed_delim_match: bool,\n ) -> bool {\n     match (token, reparsed_token) {\n         (TokenTree::Token(token), TokenTree::Token(reparsed_token)) => {\n             token_probably_equal_for_proc_macro(token, reparsed_token)\n         }\n-        (TokenTree::Delimited(_, delim, tts), TokenTree::Delimited(_, delim2, tts2)) => {\n-            // `NoDelim` delimiters can appear in the captured tokenstream, but not\n-            // in the reparsed tokenstream. Allow them to match with anything, so\n-            // that we check if the two streams are structurally equivalent.\n-            (delim == delim2 || *delim == DelimToken::NoDelim || *delim2 == DelimToken::NoDelim)\n-                && tokenstream_probably_equal_for_proc_macro(&tts, &tts2, sess)\n+        (\n+            TokenTree::Delimited(_, delim, tokens),\n+            TokenTree::Delimited(_, reparsed_delim, reparsed_tokens),\n+        ) if delim == reparsed_delim => tokenstream_probably_equal_for_proc_macro(\n+            tokens,\n+            reparsed_tokens,\n+            sess,\n+            relaxed_delim_match,\n+        ),\n+        (TokenTree::Delimited(_, DelimToken::NoDelim, tokens), reparsed_token) => {\n+            if relaxed_delim_match {\n+                if let TokenTree::Delimited(_, DelimToken::Paren, reparsed_tokens) = reparsed_token\n+                {\n+                    if tokenstream_probably_equal_for_proc_macro(\n+                        tokens,\n+                        reparsed_tokens,\n+                        sess,\n+                        relaxed_delim_match,\n+                    ) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            tokens.len() == 1\n+                && tokentree_probably_equal_for_proc_macro(\n+                    &tokens.trees().next().unwrap(),\n+                    reparsed_token,\n+                    sess,\n+                    relaxed_delim_match,\n+                )\n         }\n         _ => false,\n     }"}]}