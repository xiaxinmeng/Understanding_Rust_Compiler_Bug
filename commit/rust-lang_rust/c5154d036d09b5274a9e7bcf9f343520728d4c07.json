{"sha": "c5154d036d09b5274a9e7bcf9f343520728d4c07", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1MTU0ZDAzNmQwOWI1Mjc0YTllN2JjZjlmMzQzNTIwNzI4ZDRjMDc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-08-01T20:07:45Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-08-01T20:07:45Z"}, "message": "use FnLike to recognize functions for us", "tree": {"sha": "a77c5f14a5a221ff6db7ff2d45202d216646ea83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a77c5f14a5a221ff6db7ff2d45202d216646ea83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5154d036d09b5274a9e7bcf9f343520728d4c07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5154d036d09b5274a9e7bcf9f343520728d4c07", "html_url": "https://github.com/rust-lang/rust/commit/c5154d036d09b5274a9e7bcf9f343520728d4c07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5154d036d09b5274a9e7bcf9f343520728d4c07/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f910bcbbcbd47b372670e0a347fcde340d25e5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f910bcbbcbd47b372670e0a347fcde340d25e5e", "html_url": "https://github.com/rust-lang/rust/commit/8f910bcbbcbd47b372670e0a347fcde340d25e5e"}], "stats": {"total": 135, "additions": 72, "deletions": 63}, "files": [{"sha": "1b7eb1585671e392b14cd0f32c3fd86cca59f640", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c5154d036d09b5274a9e7bcf9f343520728d4c07/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5154d036d09b5274a9e7bcf9f343520728d4c07/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=c5154d036d09b5274a9e7bcf9f343520728d4c07", "patch": "@@ -192,6 +192,18 @@ impl<'a> FnLikeNode<'a> {\n         }\n     }\n \n+    pub fn unsafety(self) -> ast::Unsafety {\n+        match self.kind() {\n+            FnKind::ItemFn(_, _, unsafety, ..) => {\n+                unsafety\n+            }\n+            FnKind::Method(_, m, ..) => {\n+                m.unsafety\n+            }\n+            _ => ast::Unsafety::Normal\n+        }\n+    }\n+\n     pub fn kind(self) -> FnKind<'a> {\n         let item = |p: ItemFnParts<'a>| -> FnKind<'a> {\n             FnKind::ItemFn(p.name, p.generics, p.unsafety, p.constness, p.abi, p.vis, p.attrs)"}, {"sha": "2afaa0701181b28448da7489b95a63cae4268898", "filename": "src/librustc_mir/transform/add_validation.rs", "status": "modified", "additions": 60, "deletions": 63, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/c5154d036d09b5274a9e7bcf9f343520728d4c07/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5154d036d09b5274a9e7bcf9f343520728d4c07/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs?ref=c5154d036d09b5274a9e7bcf9f343520728d4c07", "patch": "@@ -14,8 +14,6 @@\n //! of MIR building, and only after this pass we think of the program has having the\n //! normal MIR semantics.\n \n-use syntax_pos::Span;\n-use syntax::ast::NodeId;\n use rustc::ty::{self, TyCtxt, RegionKind};\n use rustc::hir;\n use rustc::mir::*;\n@@ -84,9 +82,11 @@ fn lval_context<'a, 'tcx, D>(\n \n /// Check if this function contains an unsafe block or is an unsafe function.\n fn fn_contains_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource) -> bool {\n-    use rustc::hir::intravisit::{self, Visitor};\n+    use rustc::hir::intravisit::{self, Visitor, FnKind};\n+    use rustc::hir::map::blocks::FnLikeNode;\n     use rustc::hir::map::Node;\n \n+    /// Decide if this is an unsafe block\n     fn block_is_unsafe(block: &hir::Block) -> bool {\n         use rustc::hir::BlockCheckMode::*;\n \n@@ -98,77 +98,74 @@ fn fn_contains_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource) ->\n         }\n     }\n \n-    let fn_node_id = match src {\n-        MirSource::Fn(node_id) => node_id,\n+    /// Decide if this FnLike is a closure\n+    fn fn_is_closure<'a>(fn_like: FnLikeNode<'a>) -> bool {\n+        match fn_like.kind() {\n+            FnKind::Closure(_) => true,\n+            FnKind::Method(..) | FnKind::ItemFn(..) => false,\n+        }\n+    }\n+\n+    let fn_like = match src {\n+        MirSource::Fn(node_id) => {\n+            match FnLikeNode::from_node(tcx.hir.get(node_id)) {\n+                Some(fn_like) => fn_like,\n+                None => return false, // e.g. struct ctor shims -- such auto-generated code cannot\n+                                      // contain unsafe.\n+            }\n+        },\n         _ => return false, // only functions can have unsafe\n     };\n \n-    struct FindUnsafe<'b, 'tcx> where 'tcx : 'b {\n-        map: &'b hir::map::Map<'tcx>,\n-        found_unsafe: bool,\n+    // Test if the function is marked unsafe.\n+    if fn_like.unsafety() == hir::Unsafety::Unsafe {\n+        return true;\n     }\n-    let mut finder = FindUnsafe { map: &tcx.hir, found_unsafe: false };\n-    // Run the visitor on the NodeId we got.  Seems like there is no uniform way to do that.\n-    match tcx.hir.find(fn_node_id) {\n-        Some(Node::NodeItem(item)) => finder.visit_item(item),\n-        Some(Node::NodeImplItem(item)) => finder.visit_impl_item(item),\n-        Some(Node::NodeTraitItem(item)) => finder.visit_trait_item(item),\n-        Some(Node::NodeExpr(item)) => {\n-            // This is a closure.\n-            // We also have to walk up the parents and check that there is no unsafe block\n-            // there.\n-            let mut cur = fn_node_id;\n-            loop {\n-                // Go further upwards.\n-                let parent = tcx.hir.get_parent_node(cur);\n-                if cur == parent {\n-                    break;\n+\n+    // For closures, we need to walk up the parents and see if we are inside an unsafe fn or\n+    // unsafe block.\n+    if fn_is_closure(fn_like) {\n+        let mut cur = fn_like.id();\n+        loop {\n+            // Go further upwards.\n+            let parent = tcx.hir.get_parent_node(cur);\n+            if cur == parent {\n+                bug!(\"Closures muts be inside a non-closure fn_like\");\n+            }\n+            cur = parent;\n+            // Check if this is an unsafe block\n+            match tcx.hir.find(cur) {\n+                Some(Node::NodeExpr(&hir::Expr { node: hir::ExprBlock(ref block), ..})) => {\n+                    if block_is_unsafe(&*block) {\n+                        // Found an unsafe block, we can bail out here.\n+                        return true;\n+                    }\n                 }\n-                cur = parent;\n-                // Check if this is a a block\n-                match tcx.hir.find(cur) {\n-                    Some(Node::NodeExpr(&hir::Expr { node: hir::ExprBlock(ref block), ..})) => {\n-                        if block_is_unsafe(&*block) {\n-                            // Found an unsafe block, we can bail out here.\n-                            return true;\n-                        }\n+                _ => {},\n+            }\n+            // Check if this is a non-closure fn_like, at which point we have to stop moving up\n+            if let Some(fn_like) = FnLikeNode::from_node(tcx.hir.get(cur)) {\n+                if !fn_is_closure(fn_like) {\n+                    if fn_like.unsafety() == hir::Unsafety::Unsafe {\n+                        return true;\n                     }\n-                    _ => {},\n+                    break;\n                 }\n             }\n-            // Finally, visit the closure itself.\n-            finder.visit_expr(item);\n         }\n-        Some(Node::NodeStructCtor(_)) => {\n-            // Auto-generated tuple struct ctor.  Cannot contain unsafe code.\n-            return false;\n-        },\n-        Some(_) | None =>\n-            bug!(\"Expected function, method or closure, found {}\",\n-                 tcx.hir.node_to_string(fn_node_id)),\n-    };\n+    }\n \n-    impl<'b, 'tcx> Visitor<'tcx> for FindUnsafe<'b, 'tcx> {\n-        fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n-            intravisit::NestedVisitorMap::OnlyBodies(self.map)\n-        }\n+    // Visit the entire body of the function and check for unsafe blocks in there\n+    struct FindUnsafe {\n+        found_unsafe: bool,\n+    }\n+    let mut finder = FindUnsafe { found_unsafe: false };\n+    // Run the visitor on the NodeId we got.  Seems like there is no uniform way to do that.\n+    finder.visit_body(tcx.hir.body(fn_like.body()));\n \n-        fn visit_fn(&mut self, fk: intravisit::FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n-                    b: hir::BodyId, s: Span, id: NodeId)\n-        {\n-            assert!(!self.found_unsafe, \"We should never see a fn when we already saw unsafe\");\n-            let is_unsafe = match fk {\n-                intravisit::FnKind::ItemFn(_, _, unsafety, ..) => unsafety == hir::Unsafety::Unsafe,\n-                intravisit::FnKind::Method(_, sig, ..) => sig.unsafety == hir::Unsafety::Unsafe,\n-                intravisit::FnKind::Closure(_) => false,\n-            };\n-            if is_unsafe {\n-                // This is unsafe, and we are done.\n-                self.found_unsafe = true;\n-            } else {\n-                // Go on searching.\n-                intravisit::walk_fn(self, fk, fd, b, s, id)\n-            }\n+    impl<'tcx> Visitor<'tcx> for FindUnsafe {\n+        fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n+            intravisit::NestedVisitorMap::None\n         }\n \n         fn visit_block(&mut self, b: &'tcx hir::Block) {"}]}