{"sha": "148f737c199a5c9dd6d349751072add3cc458533", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0OGY3MzdjMTk5YTVjOWRkNmQzNDk3NTEwNzJhZGQzY2M0NTg1MzM=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-10-10T09:18:07Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-10-22T23:40:06Z"}, "message": "std::rand: add distributions::Range for generating [lo, hi).\n\nThis reifies the computations required for uniformity done by\n(the old) `Rng.gen_integer_range` (now Rng.gen_range), so that they can\nbe amortised over many invocations, if it is called in a loop.\n\nAlso, it makes it correct, but using a trait + impls for each type,\nrather than trying to coerce `Int` + `u64` to do the right thing. This\nalso makes it more extensible, e.g. big integers could & should\nimplement SampleRange.", "tree": {"sha": "6d11d443541b4076a8336b791fa374d00d259432", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d11d443541b4076a8336b791fa374d00d259432"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/148f737c199a5c9dd6d349751072add3cc458533", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/148f737c199a5c9dd6d349751072add3cc458533", "html_url": "https://github.com/rust-lang/rust/commit/148f737c199a5c9dd6d349751072add3cc458533", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/148f737c199a5c9dd6d349751072add3cc458533/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1420272ddc174996c532e14623d9f897ba5e7a9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1420272ddc174996c532e14623d9f897ba5e7a9d", "html_url": "https://github.com/rust-lang/rust/commit/1420272ddc174996c532e14623d9f897ba5e7a9d"}], "stats": {"total": 339, "additions": 287, "deletions": 52}, "files": [{"sha": "429f7adf5f537776529e3455dd294393f30bbc02", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/148f737c199a5c9dd6d349751072add3cc458533/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/148f737c199a5c9dd6d349751072add3cc458533/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=148f737c199a5c9dd6d349751072add3cc458533", "patch": "@@ -318,7 +318,7 @@ mod test {\n         use std::vec;\n \n         do 1000.times {\n-            let times = task_rng().gen_integer_range(1u, 100);\n+            let times = task_rng().gen_range(1u, 100);\n             let v = vec::from_fn(times, |_| random::<u8>());\n             assert_eq!(v.to_base64(STANDARD).from_base64().unwrap(), v);\n         }"}, {"sha": "bb3524a7d490263f0c138e02266886f91505deed", "filename": "src/libextra/crypto/cryptoutil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/148f737c199a5c9dd6d349751072add3cc458533/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/148f737c199a5c9dd6d349751072add3cc458533/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs?ref=148f737c199a5c9dd6d349751072add3cc458533", "patch": "@@ -365,7 +365,7 @@ pub mod test {\n         digest.reset();\n \n         while count < total_size {\n-            let next: uint = rng.gen_integer_range(0, 2 * blocksize + 1);\n+            let next: uint = rng.gen_range(0, 2 * blocksize + 1);\n             let remaining = total_size - count;\n             let size = if next > remaining { remaining } else { next };\n             digest.input(buffer.slice_to(size));"}, {"sha": "3f3b588e8bc183a04701a81ba76d1a0932b38dff", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/148f737c199a5c9dd6d349751072add3cc458533/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/148f737c199a5c9dd6d349751072add3cc458533/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=148f737c199a5c9dd6d349751072add3cc458533", "patch": "@@ -113,7 +113,7 @@ mod tests {\n         let mut r = rand::rng();\n         let mut words = ~[];\n         do 20.times {\n-            let range = r.gen_integer_range(1u, 10);\n+            let range = r.gen_range(1u, 10);\n             words.push(r.gen_vec::<u8>(range));\n         }\n         do 20.times {"}, {"sha": "2a456f8de3ebe42c58d1da94af58369fcfc229fe", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/148f737c199a5c9dd6d349751072add3cc458533/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/148f737c199a5c9dd6d349751072add3cc458533/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=148f737c199a5c9dd6d349751072add3cc458533", "patch": "@@ -1069,8 +1069,8 @@ mod big_tests {\n             isSorted(arr);\n \n             do 3.times {\n-                let i1 = rng.gen_integer_range(0u, n);\n-                let i2 = rng.gen_integer_range(0u, n);\n+                let i1 = rng.gen_range(0u, n);\n+                let i2 = rng.gen_range(0u, n);\n                 arr.swap(i1, i2);\n             }\n             tim_sort(arr); // 3sort\n@@ -1088,7 +1088,7 @@ mod big_tests {\n             isSorted(arr);\n \n             do (n/100).times {\n-                let idx = rng.gen_integer_range(0u, n);\n+                let idx = rng.gen_range(0u, n);\n                 arr[idx] = rng.gen();\n             }\n             tim_sort(arr);\n@@ -1141,8 +1141,8 @@ mod big_tests {\n             isSorted(arr);\n \n             do 3.times {\n-                let i1 = rng.gen_integer_range(0u, n);\n-                let i2 = rng.gen_integer_range(0u, n);\n+                let i1 = rng.gen_range(0u, n);\n+                let i2 = rng.gen_range(0u, n);\n                 arr.swap(i1, i2);\n             }\n             tim_sort(arr); // 3sort\n@@ -1160,7 +1160,7 @@ mod big_tests {\n             isSorted(arr);\n \n             do (n/100).times {\n-                let idx = rng.gen_integer_range(0u, n);\n+                let idx = rng.gen_range(0u, n);\n                 arr[idx] = @rng.gen();\n             }\n             tim_sort(arr);"}, {"sha": "7ef9ba76b995d481e57edd6507b790457f91ac13", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/148f737c199a5c9dd6d349751072add3cc458533/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/148f737c199a5c9dd6d349751072add3cc458533/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=148f737c199a5c9dd6d349751072add3cc458533", "patch": "@@ -1028,7 +1028,7 @@ mod test_treemap {\n             }\n \n             do 30.times {\n-                let r = rng.gen_integer_range(0, ctrl.len());\n+                let r = rng.gen_range(0, ctrl.len());\n                 let (key, _) = ctrl.remove(r);\n                 assert!(map.remove(&key));\n                 check_structure(&map);"}, {"sha": "b31e72bc697cdf21218e8361d02b77eb4d3d8dc2", "filename": "src/libstd/rand/distributions.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/148f737c199a5c9dd6d349751072add3cc458533/src%2Flibstd%2Frand%2Fdistributions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/148f737c199a5c9dd6d349751072add3cc458533/src%2Flibstd%2Frand%2Fdistributions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions.rs?ref=148f737c199a5c9dd6d349751072add3cc458533", "patch": "@@ -23,6 +23,10 @@\n use num;\n use rand::{Rng,Rand};\n \n+pub use self::range::Range;\n+\n+pub mod range;\n+\n /// Things that can be used to create a random instance of `Support`.\n pub trait Sample<Support> {\n     /// Generate a random value of `Support`, using `rng` as the"}, {"sha": "178f5106d2848445ea3facd359e0c16a7f29e1f2", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 33, "deletions": 37, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/148f737c199a5c9dd6d349751072add3cc458533/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/148f737c199a5c9dd6d349751072add3cc458533/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=148f737c199a5c9dd6d349751072add3cc458533", "patch": "@@ -55,17 +55,20 @@ fn main () {\n use mem::size_of;\n use unstable::raw::Slice;\n use cast;\n+use cmp::Ord;\n use container::Container;\n use iter::{Iterator, range};\n use local_data;\n use prelude::*;\n use str;\n-use u64;\n use vec;\n \n pub use self::isaac::{IsaacRng, Isaac64Rng};\n pub use self::os::OSRng;\n \n+use self::distributions::{Range, IndependentSample};\n+use self::distributions::range::SampleRange;\n+\n pub mod distributions;\n pub mod isaac;\n pub mod os;\n@@ -218,14 +221,14 @@ pub trait Rng {\n         vec::from_fn(len, |_| self.gen())\n     }\n \n-    /// Generate a random primitive integer in the range [`low`,\n-    /// `high`). Fails if `low >= high`.\n+    /// Generate a random value in the range [`low`, `high`). Fails if\n+    /// `low >= high`.\n     ///\n-    /// This gives a uniform distribution (assuming this RNG is itself\n-    /// uniform), even for edge cases like `gen_integer_range(0u8,\n-    /// 170)`, which a naive modulo operation would return numbers\n-    /// less than 85 with double the probability to those greater than\n-    /// 85.\n+    /// This is a convenience wrapper around\n+    /// `distributions::Range`. If this function will be called\n+    /// repeatedly with the same arguments, one should use `Range`, as\n+    /// that will amortize the computations that allow for perfect\n+    /// uniformity, as they only happen on initialization.\n     ///\n     /// # Example\n     ///\n@@ -235,22 +238,15 @@ pub trait Rng {\n     ///\n     /// fn main() {\n     ///    let mut rng = rand::task_rng();\n-    ///    let n: uint = rng.gen_integer_range(0u, 10);\n+    ///    let n: uint = rng.gen_range(0u, 10);\n     ///    println!(\"{}\", n);\n-    ///    let m: int = rng.gen_integer_range(-40, 400);\n+    ///    let m: float = rng.gen_range(-40.0, 1.3e5);\n     ///    println!(\"{}\", m);\n     /// }\n     /// ```\n-    fn gen_integer_range<T: Rand + Int>(&mut self, low: T, high: T) -> T {\n-        assert!(low < high, \"RNG.gen_integer_range called with low >= high\");\n-        let range = (high - low).to_u64().unwrap();\n-        let accept_zone = u64::max_value - u64::max_value % range;\n-        loop {\n-            let rand = self.gen::<u64>();\n-            if rand < accept_zone {\n-                return low + NumCast::from(rand % range).unwrap();\n-            }\n-        }\n+    fn gen_range<T: Ord + SampleRange>(&mut self, low: T, high: T) -> T {\n+        assert!(low < high, \"Rng.gen_range called with low >= high\");\n+        Range::new(low, high).ind_sample(self)\n     }\n \n     /// Return a bool with a 1 in n chance of true\n@@ -267,7 +263,7 @@ pub trait Rng {\n     /// }\n     /// ```\n     fn gen_weighted_bool(&mut self, n: uint) -> bool {\n-        n == 0 || self.gen_integer_range(0, n) == 0\n+        n == 0 || self.gen_range(0, n) == 0\n     }\n \n     /// Return a random string of the specified length composed of\n@@ -317,7 +313,7 @@ pub trait Rng {\n         if values.is_empty() {\n             None\n         } else {\n-            Some(&values[self.gen_integer_range(0u, values.len())])\n+            Some(&values[self.gen_range(0u, values.len())])\n         }\n     }\n \n@@ -368,7 +364,7 @@ pub trait Rng {\n         if total == 0u {\n             return None;\n         }\n-        let chosen = self.gen_integer_range(0u, total);\n+        let chosen = self.gen_range(0u, total);\n         let mut so_far = 0u;\n         for item in v.iter() {\n             so_far += item.weight;\n@@ -447,7 +443,7 @@ pub trait Rng {\n             // invariant: elements with index >= i have been locked in place.\n             i -= 1u;\n             // lock element i in place.\n-            values.swap(i, self.gen_integer_range(0u, i + 1u));\n+            values.swap(i, self.gen_range(0u, i + 1u));\n         }\n     }\n \n@@ -473,7 +469,7 @@ pub trait Rng {\n                 continue\n             }\n \n-            let k = self.gen_integer_range(0, i + 1);\n+            let k = self.gen_range(0, i + 1);\n             if k < reservoir.len() {\n                 reservoir[k] = elem\n             }\n@@ -760,36 +756,36 @@ mod test {\n     }\n \n     #[test]\n-    fn test_gen_integer_range() {\n+    fn test_gen_range() {\n         let mut r = rng();\n         for _ in range(0, 1000) {\n-            let a = r.gen_integer_range(-3i, 42);\n+            let a = r.gen_range(-3i, 42);\n             assert!(a >= -3 && a < 42);\n-            assert_eq!(r.gen_integer_range(0, 1), 0);\n-            assert_eq!(r.gen_integer_range(-12, -11), -12);\n+            assert_eq!(r.gen_range(0, 1), 0);\n+            assert_eq!(r.gen_range(-12, -11), -12);\n         }\n \n         for _ in range(0, 1000) {\n-            let a = r.gen_integer_range(10, 42);\n+            let a = r.gen_range(10, 42);\n             assert!(a >= 10 && a < 42);\n-            assert_eq!(r.gen_integer_range(0, 1), 0);\n-            assert_eq!(r.gen_integer_range(3_000_000u, 3_000_001), 3_000_000);\n+            assert_eq!(r.gen_range(0, 1), 0);\n+            assert_eq!(r.gen_range(3_000_000u, 3_000_001), 3_000_000);\n         }\n \n     }\n \n     #[test]\n     #[should_fail]\n-    fn test_gen_integer_range_fail_int() {\n+    fn test_gen_range_fail_int() {\n         let mut r = rng();\n-        r.gen_integer_range(5i, -2);\n+        r.gen_range(5i, -2);\n     }\n \n     #[test]\n     #[should_fail]\n-    fn test_gen_integer_range_fail_uint() {\n+    fn test_gen_range_fail_uint() {\n         let mut r = rng();\n-        r.gen_integer_range(5u, 2u);\n+        r.gen_range(5u, 2u);\n     }\n \n     #[test]\n@@ -894,7 +890,7 @@ mod test {\n         let mut r = task_rng();\n         r.gen::<int>();\n         assert_eq!(r.shuffle(~[1, 1, 1]), ~[1, 1, 1]);\n-        assert_eq!(r.gen_integer_range(0u, 1u), 0u);\n+        assert_eq!(r.gen_range(0u, 1u), 0u);\n     }\n \n     #[test]"}, {"sha": "1b805a0b8f7638a57fb71c9f500651d112df1572", "filename": "src/libstd/rand/range.rs", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/148f737c199a5c9dd6d349751072add3cc458533/src%2Flibstd%2Frand%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/148f737c199a5c9dd6d349751072add3cc458533/src%2Flibstd%2Frand%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Frange.rs?ref=148f737c199a5c9dd6d349751072add3cc458533", "patch": "@@ -0,0 +1,235 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Generating numbers between two others.\n+\n+// this is surprisingly complicated to be both generic & correct\n+\n+use cmp::Ord;\n+use num::Bounded;\n+use rand::Rng;\n+use rand::distributions::{Sample, IndependentSample};\n+\n+/// Sample values uniformly between two bounds.\n+///\n+/// This gives a uniform distribution (assuming the RNG used to sample\n+/// it is itself uniform & the `SampleRange` implementation for the\n+/// given type is correct), even for edge cases like `low = 0u8`,\n+/// `high = 170u8`, for which a naive modulo operation would return\n+/// numbers less than 85 with double the probability to those greater\n+/// than 85.\n+///\n+/// Types should attempt to sample in `[low, high)`, i.e., not\n+/// including `high`, but this may be very difficult. All the\n+/// primitive integer types satisfy this property, and the float types\n+/// normally satisfy it, but rounding may mean `high` can occur.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::rand;\n+/// use std::rand::distributions::{IndependentSample, Range};\n+///\n+/// fn main() {\n+///     let between = Range::new(10u, 10000u);\n+///     let rng = rand::task_rng();\n+///     let mut sum = 0;\n+///     for _ in range(0, 1000) {\n+///         sum += between.ind_sample(rng);\n+///     }\n+///     println!(\"{}\", sum);\n+/// }\n+/// ```\n+pub struct Range<X> {\n+    priv low: X,\n+    priv range: X,\n+    priv accept_zone: X\n+}\n+\n+impl<X: SampleRange + Ord> Range<X> {\n+    /// Create a new `Range` instance that samples uniformly from\n+    /// `[low, high)`. Fails if `low >= high`.\n+    pub fn new(low: X, high: X) -> Range<X> {\n+        assert!(low < high, \"Range::new called with `low >= high`\");\n+        SampleRange::construct_range(low, high)\n+    }\n+}\n+\n+impl<Sup: SampleRange> Sample<Sup> for Range<Sup> {\n+    #[inline]\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> Sup { self.ind_sample(rng) }\n+}\n+impl<Sup: SampleRange> IndependentSample<Sup> for Range<Sup> {\n+    fn ind_sample<R: Rng>(&self, rng: &mut R) -> Sup {\n+        SampleRange::sample_range(self, rng)\n+    }\n+}\n+\n+/// The helper trait for types that have a sensible way to sample\n+/// uniformly between two values. This should not be used directly,\n+/// and is only to facilitate `Range`.\n+pub trait SampleRange {\n+    /// Construct the `Range` object that `sample_range`\n+    /// requires. This should not ever be called directly, only via\n+    /// `Range::new`, which will check that `low < high`, so this\n+    /// function doesn't have to repeat the check.\n+    fn construct_range(low: Self, high: Self) -> Range<Self>;\n+\n+    /// Sample a value from the given `Range` with the given `Rng` as\n+    /// a source of randomness.\n+    fn sample_range<R: Rng>(r: &Range<Self>, rng: &mut R) -> Self;\n+}\n+\n+macro_rules! integer_impl {\n+    ($ty:ty, $unsigned:ty) => {\n+        impl SampleRange for $ty {\n+            // we play free and fast with unsigned vs signed here\n+            // (when $ty is signed), but that's fine, since the\n+            // contract of this macro is for $ty and $unsigned to be\n+            // \"bit-equal\", so casting between them is a no-op & a\n+            // bijection.\n+\n+            fn construct_range(low: $ty, high: $ty) -> Range<$ty> {\n+                let range = high as $unsigned - low as $unsigned;\n+                let unsigned_max: $unsigned = Bounded::max_value();\n+\n+                // this is the largest number that fits into $unsigned\n+                // that `range` divides evenly, so, if we've sampled\n+                // `n` uniformly from this region, then `n % range` is\n+                // uniform in [0, range)\n+                let zone = unsigned_max - unsigned_max % range;\n+\n+                Range {\n+                    low: low,\n+                    range: range as $ty,\n+                    accept_zone: zone as $ty\n+                }\n+            }\n+            #[inline]\n+            fn sample_range<R: Rng>(r: &Range<$ty>, rng: &mut R) -> $ty {\n+                loop {\n+                    // rejection sample\n+                    let v = rng.gen::<$unsigned>();\n+                    // until we find something that fits into the\n+                    // region which r.range evenly divides (this will\n+                    // be uniformly distributed)\n+                    if v < r.accept_zone as $unsigned {\n+                        // and return it, with some adjustments\n+                        return r.low + (v % r.range as $unsigned) as $ty;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+integer_impl! { i8, u8 }\n+integer_impl! { i16, u16 }\n+integer_impl! { i32, u32 }\n+integer_impl! { i64, u64 }\n+integer_impl! { int, uint }\n+integer_impl! { u8, u8 }\n+integer_impl! { u16, u16 }\n+integer_impl! { u32, u32 }\n+integer_impl! { u64, u64 }\n+integer_impl! { uint, uint }\n+\n+macro_rules! float_impl {\n+    ($ty:ty) => {\n+        impl SampleRange for $ty {\n+            fn construct_range(low: $ty, high: $ty) -> Range<$ty> {\n+                Range {\n+                    low: low,\n+                    range: high - low,\n+                    accept_zone: 0.0 // unused\n+                }\n+            }\n+            fn sample_range<R: Rng>(r: &Range<$ty>, rng: &mut R) -> $ty {\n+                r.low + r.range * rng.gen()\n+            }\n+        }\n+    }\n+}\n+\n+float_impl! { f32 }\n+float_impl! { f64 }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use rand::*;\n+    use num::Bounded;\n+    use iter::range;\n+    use option::{Some, None};\n+    use vec::ImmutableVector;\n+\n+    #[should_fail]\n+    #[test]\n+    fn test_range_bad_limits_equal() {\n+        Range::new(10, 10);\n+    }\n+    #[should_fail]\n+    #[test]\n+    fn test_range_bad_limits_flipped() {\n+        Range::new(10, 5);\n+    }\n+\n+    #[test]\n+    fn test_integers() {\n+        let rng = task_rng();\n+        macro_rules! t (\n+            ($($ty:ty),*) => {{\n+                $(\n+                   let v: &[($ty, $ty)] = [(0, 10),\n+                                           (10, 127),\n+                                           (Bounded::min_value(), Bounded::max_value())];\n+                   for &(low, high) in v.iter() {\n+                        let mut sampler: Range<$ty> = Range::new(low, high);\n+                        for _ in range(0, 1000) {\n+                            let v = sampler.sample(rng);\n+                            assert!(low <= v && v < high);\n+                            let v = sampler.ind_sample(rng);\n+                            assert!(low <= v && v < high);\n+                        }\n+                    }\n+                 )*\n+            }}\n+        );\n+        t!(i8, i16, i32, i64, int,\n+           u8, u16, u32, u64, uint)\n+    }\n+\n+    #[test]\n+    fn test_floats() {\n+        let rng = task_rng();\n+        macro_rules! t (\n+            ($($ty:ty),*) => {{\n+                $(\n+                   let v: &[($ty, $ty)] = [(0.0, 100.0),\n+                                           (-1e35, -1e25),\n+                                           (1e-35, 1e-25),\n+                                           (-1e35, 1e35)];\n+                   for &(low, high) in v.iter() {\n+                        let mut sampler: Range<$ty> = Range::new(low, high);\n+                        for _ in range(0, 1000) {\n+                            let v = sampler.sample(rng);\n+                            assert!(low <= v && v < high);\n+                            let v = sampler.ind_sample(rng);\n+                            assert!(low <= v && v < high);\n+                        }\n+                    }\n+                 )*\n+            }}\n+        );\n+\n+        t!(f32, f64)\n+    }\n+\n+}"}, {"sha": "967dedd94a620ccc77fe318f463f049a6c567c88", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/148f737c199a5c9dd6d349751072add3cc458533/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/148f737c199a5c9dd6d349751072add3cc458533/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=148f737c199a5c9dd6d349751072add3cc458533", "patch": "@@ -1117,7 +1117,7 @@ mod test {\n             let total = stress_factor() + 10;\n             let mut rng = rand::rng();\n             do total.times {\n-                let msgs = rng.gen_integer_range(0u, 10);\n+                let msgs = rng.gen_range(0u, 10);\n                 let pipe_clone = pipe.clone();\n                 let end_chan_clone = end_chan.clone();\n                 do spawntask_random {"}, {"sha": "c1090d360106e8118134da3352a7b442c5410c9c", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/148f737c199a5c9dd6d349751072add3cc458533/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/148f737c199a5c9dd6d349751072add3cc458533/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=148f737c199a5c9dd6d349751072add3cc458533", "patch": "@@ -431,7 +431,7 @@ impl Scheduler {\n     fn try_steals(&mut self) -> Option<~Task> {\n         let work_queues = &mut self.work_queues;\n         let len = work_queues.len();\n-        let start_index = self.rng.gen_integer_range(0, len);\n+        let start_index = self.rng.gen_range(0, len);\n         for index in range(0, len).map(|i| (i + start_index) % len) {\n             match work_queues[index].steal() {\n                 Some(task) => {"}, {"sha": "dbd1edffe7827ce09960d51bd631814574ad70e7", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/148f737c199a5c9dd6d349751072add3cc458533/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/148f737c199a5c9dd6d349751072add3cc458533/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=148f737c199a5c9dd6d349751072add3cc458533", "patch": "@@ -90,7 +90,7 @@ fn vec_plus() {\n     let mut v = ~[];\n     let mut i = 0;\n     while i < 1500 {\n-        let rv = vec::from_elem(r.gen_integer_range(0u, i + 1), i);\n+        let rv = vec::from_elem(r.gen_range(0u, i + 1), i);\n         if r.gen() {\n             v.push_all_move(rv);\n         } else {\n@@ -106,7 +106,7 @@ fn vec_append() {\n     let mut v = ~[];\n     let mut i = 0;\n     while i < 1500 {\n-        let rv = vec::from_elem(r.gen_integer_range(0u, i + 1), i);\n+        let rv = vec::from_elem(r.gen_range(0u, i + 1), i);\n         if r.gen() {\n             v = vec::append(v, rv);\n         }\n@@ -122,7 +122,7 @@ fn vec_push_all() {\n \n     let mut v = ~[];\n     for i in range(0u, 1500) {\n-        let mut rv = vec::from_elem(r.gen_integer_range(0u, i + 1), i);\n+        let mut rv = vec::from_elem(r.gen_range(0u, i + 1), i);\n         if r.gen() {\n             v.push_all(rv);\n         }"}]}