{"sha": "cef94ecedfc87fcf570c76fc1dad674592dcdb98", "node_id": "C_kwDOAAsO6NoAKGNlZjk0ZWNlZGZjODdmY2Y1NzBjNzZmYzFkYWQ2NzQ1OTJkY2RiOTg", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-06-16T19:53:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-06-16T19:53:23Z"}, "message": "Rollup merge of #112665 - compiler-errors:assumption-takes-clause, r=lcnr\n\nMake assumption functions in new solver take `Binder<'tcx, Clause<'tcx>>`\n\nWe just use an if-let to match on an optional clause at all the places where we transition from `Predicate` -> `Clause`, but I assume that when things like item-bounds and param-env start to only store `Clause`s then those can just be trivially dropped.\n\nr? ``@lcnr``", "tree": {"sha": "4ad5da1da7b1956005932c0da367c22ada5cf1f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ad5da1da7b1956005932c0da367c22ada5cf1f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cef94ecedfc87fcf570c76fc1dad674592dcdb98", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkjL2zCRBK7hj4Ov3rIwAAjVUIAGOGSF/lJ9DAswdRLlWxqE19\nBf+MJw0JF6PUX7zEWa+yTgaO++VRu2QClS78W+/1WghmGWwXCOXSNNP1x5DGXk6K\nm8cs7CH3p+It1usA3goqIHNQ54Qb+Oen4uSNRDmTVo1xPIA15TKOOe/C/fmQ3oI6\nq1XkBa7M+l7gtQTj66vvNpwl8KKyhgJOdSdCFn64PA+KAz4pBpXi5g0gC2oF9kdh\nVfiL1n1fTY24DWAczyD4ePNzlb1y9rXXK5KeFdAq/asZTCgNbWKHWOACGnhhuNOC\nMVxZyleFIxB7E67db7EhVCXXgDmumkVzdSAVH/rDf3TkLX2F5jpXL/TIWA97/jw=\n=xSD5\n-----END PGP SIGNATURE-----\n", "payload": "tree 4ad5da1da7b1956005932c0da367c22ada5cf1f4\nparent 38fc6be325f57e6e149bc2b60985870d48280018\nparent b4ba7c4f93c1279c55271404937f064a78355e2f\nauthor Michael Goulet <michael@errs.io> 1686945203 -0700\ncommitter GitHub <noreply@github.com> 1686945203 -0700\n\nRollup merge of #112665 - compiler-errors:assumption-takes-clause, r=lcnr\n\nMake assumption functions in new solver take `Binder<'tcx, Clause<'tcx>>`\n\nWe just use an if-let to match on an optional clause at all the places where we transition from `Predicate` -> `Clause`, but I assume that when things like item-bounds and param-env start to only store `Clause`s then those can just be trivially dropped.\n\nr? ``@lcnr``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cef94ecedfc87fcf570c76fc1dad674592dcdb98", "html_url": "https://github.com/rust-lang/rust/commit/cef94ecedfc87fcf570c76fc1dad674592dcdb98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cef94ecedfc87fcf570c76fc1dad674592dcdb98/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38fc6be325f57e6e149bc2b60985870d48280018", "url": "https://api.github.com/repos/rust-lang/rust/commits/38fc6be325f57e6e149bc2b60985870d48280018", "html_url": "https://github.com/rust-lang/rust/commit/38fc6be325f57e6e149bc2b60985870d48280018"}, {"sha": "b4ba7c4f93c1279c55271404937f064a78355e2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4ba7c4f93c1279c55271404937f064a78355e2f", "html_url": "https://github.com/rust-lang/rust/commit/b4ba7c4f93c1279c55271404937f064a78355e2f"}], "stats": {"total": 124, "additions": 98, "deletions": 26}, "files": [{"sha": "ff5d99794f1e2b3c3d89b5445543774d14391b55", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/cef94ecedfc87fcf570c76fc1dad674592dcdb98/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cef94ecedfc87fcf570c76fc1dad674592dcdb98/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=cef94ecedfc87fcf570c76fc1dad674592dcdb98", "patch": "@@ -586,6 +586,24 @@ pub enum Clause<'tcx> {\n     ConstArgHasType(Const<'tcx>, Ty<'tcx>),\n }\n \n+impl<'tcx> Binder<'tcx, Clause<'tcx>> {\n+    pub fn as_trait_clause(self) -> Option<Binder<'tcx, TraitPredicate<'tcx>>> {\n+        if let ty::Clause::Trait(trait_clause) = self.skip_binder() {\n+            Some(self.rebind(trait_clause))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn as_projection_clause(self) -> Option<Binder<'tcx, ProjectionPredicate<'tcx>>> {\n+        if let ty::Clause::Projection(projection_clause) = self.skip_binder() {\n+            Some(self.rebind(projection_clause))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub enum PredicateKind<'tcx> {\n@@ -1203,6 +1221,17 @@ impl<'tcx> ToPredicate<'tcx> for TraitRef<'tcx> {\n     }\n }\n \n+impl<'tcx> ToPredicate<'tcx, Binder<'tcx, Clause<'tcx>>> for TraitRef<'tcx> {\n+    #[inline(always)]\n+    fn to_predicate(self, _tcx: TyCtxt<'tcx>) -> Binder<'tcx, Clause<'tcx>> {\n+        Binder::dummy(Clause::Trait(TraitPredicate {\n+            trait_ref: self,\n+            constness: ty::BoundConstness::NotConst,\n+            polarity: ty::ImplPolarity::Positive,\n+        }))\n+    }\n+}\n+\n impl<'tcx> ToPredicate<'tcx> for Binder<'tcx, TraitRef<'tcx>> {\n     #[inline(always)]\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n@@ -1211,6 +1240,14 @@ impl<'tcx> ToPredicate<'tcx> for Binder<'tcx, TraitRef<'tcx>> {\n     }\n }\n \n+impl<'tcx> ToPredicate<'tcx, Binder<'tcx, Clause<'tcx>>> for Binder<'tcx, TraitRef<'tcx>> {\n+    #[inline(always)]\n+    fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Binder<'tcx, Clause<'tcx>> {\n+        let pred: PolyTraitPredicate<'tcx> = self.to_predicate(tcx);\n+        pred.to_predicate(tcx)\n+    }\n+}\n+\n impl<'tcx> ToPredicate<'tcx, PolyTraitPredicate<'tcx>> for Binder<'tcx, TraitRef<'tcx>> {\n     #[inline(always)]\n     fn to_predicate(self, _: TyCtxt<'tcx>) -> PolyTraitPredicate<'tcx> {\n@@ -1240,6 +1277,12 @@ impl<'tcx> ToPredicate<'tcx> for PolyTraitPredicate<'tcx> {\n     }\n }\n \n+impl<'tcx> ToPredicate<'tcx, Binder<'tcx, Clause<'tcx>>> for PolyTraitPredicate<'tcx> {\n+    fn to_predicate(self, _tcx: TyCtxt<'tcx>) -> Binder<'tcx, Clause<'tcx>> {\n+        self.map_bound(|p| Clause::Trait(p))\n+    }\n+}\n+\n impl<'tcx> ToPredicate<'tcx> for PolyRegionOutlivesPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         self.map_bound(|p| PredicateKind::Clause(Clause::RegionOutlives(p))).to_predicate(tcx)\n@@ -1258,6 +1301,12 @@ impl<'tcx> ToPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n     }\n }\n \n+impl<'tcx> ToPredicate<'tcx, Binder<'tcx, Clause<'tcx>>> for PolyProjectionPredicate<'tcx> {\n+    fn to_predicate(self, _tcx: TyCtxt<'tcx>) -> Binder<'tcx, Clause<'tcx>> {\n+        self.map_bound(|p| Clause::Projection(p))\n+    }\n+}\n+\n impl<'tcx> ToPredicate<'tcx> for TraitPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         PredicateKind::Clause(Clause::Trait(self)).to_predicate(tcx)\n@@ -1327,6 +1376,23 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateKind::TypeWellFormedFromEnv(..) => None,\n         }\n     }\n+\n+    pub fn as_clause(self) -> Option<Binder<'tcx, Clause<'tcx>>> {\n+        let predicate = self.kind();\n+        match predicate.skip_binder() {\n+            PredicateKind::Clause(clause) => Some(predicate.rebind(clause)),\n+            PredicateKind::AliasRelate(..)\n+            | PredicateKind::Subtype(..)\n+            | PredicateKind::Coerce(..)\n+            | PredicateKind::WellFormed(..)\n+            | PredicateKind::ObjectSafe(..)\n+            | PredicateKind::ClosureKind(..)\n+            | PredicateKind::ConstEvaluatable(..)\n+            | PredicateKind::ConstEquate(..)\n+            | PredicateKind::Ambiguous\n+            | PredicateKind::TypeWellFormedFromEnv(..) => None,\n+        }\n+    }\n }\n \n /// Represents the bounds declared on a particular set of type"}, {"sha": "e6eddf24844cfa00cfb71230b821319416d1669c", "filename": "compiler/rustc_trait_selection/src/solve/assembly/mod.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cef94ecedfc87fcf570c76fc1dad674592dcdb98/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cef94ecedfc87fcf570c76fc1dad674592dcdb98/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs?ref=cef94ecedfc87fcf570c76fc1dad674592dcdb98", "patch": "@@ -105,7 +105,7 @@ pub(super) trait GoalKind<'tcx>:\n     fn probe_and_match_goal_against_assumption(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n+        assumption: ty::Binder<'tcx, ty::Clause<'tcx>>,\n         then: impl FnOnce(&mut EvalCtxt<'_, 'tcx>) -> QueryResult<'tcx>,\n     ) -> QueryResult<'tcx>;\n \n@@ -115,7 +115,7 @@ pub(super) trait GoalKind<'tcx>:\n     fn consider_implied_clause(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n+        assumption: ty::Binder<'tcx, ty::Clause<'tcx>>,\n         requirements: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>,\n     ) -> QueryResult<'tcx> {\n         Self::probe_and_match_goal_against_assumption(ecx, goal, assumption, |ecx| {\n@@ -131,7 +131,7 @@ pub(super) trait GoalKind<'tcx>:\n     fn consider_alias_bound_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n+        assumption: ty::Binder<'tcx, ty::Clause<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         Self::probe_and_match_goal_against_assumption(ecx, goal, assumption, |ecx| {\n             ecx.validate_alias_bound_self_from_param_env(goal)\n@@ -144,7 +144,7 @@ pub(super) trait GoalKind<'tcx>:\n     fn consider_object_bound_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n+        assumption: ty::Binder<'tcx, ty::Clause<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         Self::probe_and_match_goal_against_assumption(ecx, goal, assumption, |ecx| {\n             let tcx = ecx.tcx();\n@@ -467,11 +467,13 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         candidates: &mut Vec<Candidate<'tcx>>,\n     ) {\n         for (i, assumption) in goal.param_env.caller_bounds().iter().enumerate() {\n-            match G::consider_implied_clause(self, goal, assumption, []) {\n-                Ok(result) => {\n-                    candidates.push(Candidate { source: CandidateSource::ParamEnv(i), result })\n+            if let Some(clause) = assumption.as_clause() {\n+                match G::consider_implied_clause(self, goal, clause, []) {\n+                    Ok(result) => {\n+                        candidates.push(Candidate { source: CandidateSource::ParamEnv(i), result })\n+                    }\n+                    Err(NoSolution) => (),\n                 }\n-                Err(NoSolution) => (),\n             }\n         }\n     }\n@@ -517,11 +519,13 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n \n         for assumption in self.tcx().item_bounds(alias_ty.def_id).subst(self.tcx(), alias_ty.substs)\n         {\n-            match G::consider_alias_bound_candidate(self, goal, assumption) {\n-                Ok(result) => {\n-                    candidates.push(Candidate { source: CandidateSource::AliasBound, result })\n+            if let Some(clause) = assumption.as_clause() {\n+                match G::consider_alias_bound_candidate(self, goal, clause) {\n+                    Ok(result) => {\n+                        candidates.push(Candidate { source: CandidateSource::AliasBound, result })\n+                    }\n+                    Err(NoSolution) => (),\n                 }\n-                Err(NoSolution) => (),\n             }\n         }\n     }\n@@ -675,18 +679,20 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             // projection predicates that we reach by elaborating the principal trait ref,\n             // since that'll cause ambiguity.\n             //\n-            // We can remove this when we have implemented intersections in responses.\n+            // We can remove this when we have implemented lifetime intersections in responses.\n             if assumption.to_opt_poly_projection_pred().is_some()\n                 && !own_bounds.contains(&assumption)\n             {\n                 continue;\n             }\n \n-            match G::consider_object_bound_candidate(self, goal, assumption) {\n-                Ok(result) => {\n-                    candidates.push(Candidate { source: CandidateSource::BuiltinImpl, result })\n+            if let Some(clause) = assumption.as_clause() {\n+                match G::consider_object_bound_candidate(self, goal, clause) {\n+                    Ok(result) => {\n+                        candidates.push(Candidate { source: CandidateSource::BuiltinImpl, result })\n+                    }\n+                    Err(NoSolution) => (),\n                 }\n-                Err(NoSolution) => (),\n             }\n         }\n     }"}, {"sha": "8303bab4c36f3aa71529bfb60365a01041df3df8", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cef94ecedfc87fcf570c76fc1dad674592dcdb98/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cef94ecedfc87fcf570c76fc1dad674592dcdb98/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=cef94ecedfc87fcf570c76fc1dad674592dcdb98", "patch": "@@ -105,15 +105,15 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n     fn probe_and_match_goal_against_assumption(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n+        assumption: ty::Binder<'tcx, ty::Clause<'tcx>>,\n         then: impl FnOnce(&mut EvalCtxt<'_, 'tcx>) -> QueryResult<'tcx>,\n     ) -> QueryResult<'tcx> {\n-        if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred()\n-            && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n+        if let Some(projection_pred) = assumption.as_projection_clause()\n+            && projection_pred.projection_def_id() == goal.predicate.def_id()\n         {\n             ecx.probe(|ecx| {\n                 let assumption_projection_pred =\n-                    ecx.instantiate_binder_with_infer(poly_projection_pred);\n+                    ecx.instantiate_binder_with_infer(projection_pred);\n                 ecx.eq(\n                     goal.param_env,\n                     goal.predicate.projection_ty,"}, {"sha": "60cf386a289f946b1a632d1647b371f1e14b5a0a", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cef94ecedfc87fcf570c76fc1dad674592dcdb98/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cef94ecedfc87fcf570c76fc1dad674592dcdb98/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=cef94ecedfc87fcf570c76fc1dad674592dcdb98", "patch": "@@ -81,17 +81,17 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n     fn probe_and_match_goal_against_assumption(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n+        assumption: ty::Binder<'tcx, ty::Clause<'tcx>>,\n         then: impl FnOnce(&mut EvalCtxt<'_, 'tcx>) -> QueryResult<'tcx>,\n     ) -> QueryResult<'tcx> {\n-        if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred()\n-            && poly_trait_pred.def_id() == goal.predicate.def_id()\n-            && poly_trait_pred.polarity() == goal.predicate.polarity\n+        if let Some(trait_clause) = assumption.as_trait_clause()\n+            && trait_clause.def_id() == goal.predicate.def_id()\n+            && trait_clause.polarity() == goal.predicate.polarity\n         {\n             // FIXME: Constness\n             ecx.probe(|ecx| {\n                 let assumption_trait_pred =\n-                    ecx.instantiate_binder_with_infer(poly_trait_pred);\n+                    ecx.instantiate_binder_with_infer(trait_clause);\n                 ecx.eq(\n                     goal.param_env,\n                     goal.predicate.trait_ref,"}]}