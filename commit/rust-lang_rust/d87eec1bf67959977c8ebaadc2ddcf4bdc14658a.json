{"sha": "d87eec1bf67959977c8ebaadc2ddcf4bdc14658a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4N2VlYzFiZjY3OTU5OTc3YzhlYmFhZGMyZGRjZjRiZGMxNDY1OGE=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2021-02-23T15:12:28Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2021-02-23T17:25:55Z"}, "message": "Add #[rustc_legacy_const_generics]", "tree": {"sha": "1f777c2c1702ec27d57c346a8c9f7c1b876df372", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f777c2c1702ec27d57c346a8c9f7c1b876df372"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d87eec1bf67959977c8ebaadc2ddcf4bdc14658a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d87eec1bf67959977c8ebaadc2ddcf4bdc14658a", "html_url": "https://github.com/rust-lang/rust/commit/d87eec1bf67959977c8ebaadc2ddcf4bdc14658a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d87eec1bf67959977c8ebaadc2ddcf4bdc14658a/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b471a3f5fe57e5c6e08acf665f2094422415a3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b471a3f5fe57e5c6e08acf665f2094422415a3d", "html_url": "https://github.com/rust-lang/rust/commit/9b471a3f5fe57e5c6e08acf665f2094422415a3d"}], "stats": {"total": 312, "additions": 310, "deletions": 2}, "files": [{"sha": "145a9784010519c0a325b880523cdfa844d2dad1", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 88, "deletions": 2, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/d87eec1bf67959977c8ebaadc2ddcf4bdc14658a/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d87eec1bf67959977c8ebaadc2ddcf4bdc14658a/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=d87eec1bf67959977c8ebaadc2ddcf4bdc14658a", "patch": "@@ -9,7 +9,9 @@ use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n+use rustc_hir::definitions::DefPathData;\n use rustc_session::parse::feature_err;\n+use rustc_span::hygiene::ExpnId;\n use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{hygiene::ForLoopLoc, DUMMY_SP};\n@@ -42,8 +44,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }\n                 ExprKind::Tup(ref elts) => hir::ExprKind::Tup(self.lower_exprs(elts)),\n                 ExprKind::Call(ref f, ref args) => {\n-                    let f = self.lower_expr(f);\n-                    hir::ExprKind::Call(f, self.lower_exprs(args))\n+                    if let Some(legacy_args) = self.legacy_const_generic_args(f) {\n+                        self.lower_legacy_const_generics((**f).clone(), args.clone(), &legacy_args)\n+                    } else {\n+                        let f = self.lower_expr(f);\n+                        hir::ExprKind::Call(f, self.lower_exprs(args))\n+                    }\n                 }\n                 ExprKind::MethodCall(ref seg, ref args, span) => {\n                     let hir_seg = self.arena.alloc(self.lower_path_segment(\n@@ -292,6 +298,86 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n+    /// Checks if an expression refers to a function marked with\n+    /// `#[rustc_legacy_const_generics]` and returns the argument index list\n+    /// from the attribute.\n+    fn legacy_const_generic_args(&mut self, expr: &Expr) -> Option<Vec<usize>> {\n+        if let ExprKind::Path(None, path) = &expr.kind {\n+            if path.segments.last().unwrap().args.is_some() {\n+                return None;\n+            }\n+            if let Some(partial_res) = self.resolver.get_partial_res(expr.id) {\n+                if partial_res.unresolved_segments() != 0 {\n+                    return None;\n+                }\n+                if let Res::Def(hir::def::DefKind::Fn, def_id) = partial_res.base_res() {\n+                    let attrs = self.item_attrs(def_id);\n+                    let attr = attrs\n+                        .iter()\n+                        .find(|a| self.sess.check_name(a, sym::rustc_legacy_const_generics))?;\n+                    let mut ret = vec![];\n+                    for meta in attr.meta_item_list()? {\n+                        match meta.literal()?.kind {\n+                            LitKind::Int(a, _) => {\n+                                ret.push(a as usize);\n+                            }\n+                            _ => panic!(\"invalid arg index\"),\n+                        }\n+                    }\n+                    return Some(ret);\n+                }\n+            }\n+        }\n+        None\n+    }\n+\n+    fn lower_legacy_const_generics(\n+        &mut self,\n+        mut f: Expr,\n+        args: Vec<AstP<Expr>>,\n+        legacy_args_idx: &[usize],\n+    ) -> hir::ExprKind<'hir> {\n+        let path = match f.kind {\n+            ExprKind::Path(None, ref mut path) => path,\n+            _ => unreachable!(),\n+        };\n+\n+        // Split the arguments into const generics and normal arguments\n+        let mut real_args = vec![];\n+        let mut generic_args = vec![];\n+        for (idx, arg) in args.into_iter().enumerate() {\n+            if legacy_args_idx.contains(&idx) {\n+                let parent_def_id = self.current_hir_id_owner.last().unwrap().0;\n+                let node_id = self.resolver.next_node_id();\n+\n+                // Add a definition for the in-band const def.\n+                self.resolver.create_def(\n+                    parent_def_id,\n+                    node_id,\n+                    DefPathData::AnonConst,\n+                    ExpnId::root(),\n+                    arg.span,\n+                );\n+\n+                let anon_const = AnonConst { id: node_id, value: arg };\n+                generic_args.push(AngleBracketedArg::Arg(GenericArg::Const(anon_const)));\n+            } else {\n+                real_args.push(arg);\n+            }\n+        }\n+\n+        // Add generic args to the last element of the path\n+        path.segments.last_mut().unwrap().args =\n+            Some(AstP(GenericArgs::AngleBracketed(AngleBracketedArgs {\n+                span: DUMMY_SP,\n+                args: generic_args,\n+            })));\n+\n+        // Now lower everything as normal.\n+        let f = self.lower_expr(&f);\n+        hir::ExprKind::Call(f, self.lower_exprs(&real_args))\n+    }\n+\n     /// Emit an error and lower `ast::ExprKind::Let(pat, scrutinee)` into:\n     /// ```rust\n     /// match scrutinee { pats => true, _ => false }"}, {"sha": "4a43854121127ded9778dd95de7187676e04928b", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d87eec1bf67959977c8ebaadc2ddcf4bdc14658a/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d87eec1bf67959977c8ebaadc2ddcf4bdc14658a/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=d87eec1bf67959977c8ebaadc2ddcf4bdc14658a", "patch": "@@ -175,6 +175,8 @@ pub trait ResolverAstLowering {\n \n     fn item_generics_num_lifetimes(&self, def: DefId, sess: &Session) -> usize;\n \n+    fn item_attrs(&self, def_id: DefId, sess: &Session) -> Vec<ast::Attribute>;\n+\n     /// Obtains resolution for a `NodeId` with a single resolution.\n     fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes>;\n \n@@ -2826,6 +2828,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             )\n         }\n     }\n+\n+    fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> {\n+        if let Some(_local_def_id) = def_id.as_local() {\n+            // TODO: This doesn't actually work, items doesn't include everything?\n+            //self.items[&hir::ItemId { def_id: local_def_id }].attrs.into()\n+            Vec::new()\n+        } else {\n+            self.resolver.item_attrs(def_id, self.sess)\n+        }\n+    }\n }\n \n fn body_ids(bodies: &BTreeMap<hir::BodyId, hir::Body<'_>>) -> Vec<hir::BodyId> {"}, {"sha": "072062dd615d874942f0102884b342199bd17fd5", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d87eec1bf67959977c8ebaadc2ddcf4bdc14658a/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d87eec1bf67959977c8ebaadc2ddcf4bdc14658a/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=d87eec1bf67959977c8ebaadc2ddcf4bdc14658a", "patch": "@@ -470,6 +470,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n \n     rustc_attr!(rustc_promotable, AssumedUsed, template!(Word), IMPL_DETAIL),\n     rustc_attr!(rustc_args_required_const, AssumedUsed, template!(List: \"N\"), INTERNAL_UNSTABLE),\n+    rustc_attr!(rustc_legacy_const_generics, AssumedUsed, template!(List: \"N\"), INTERNAL_UNSTABLE),\n \n     // ==========================================================================\n     // Internal attributes, Layout related:"}, {"sha": "0f860d11dc21a551b7baa68ca42e6f1e47ab9c84", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d87eec1bf67959977c8ebaadc2ddcf4bdc14658a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d87eec1bf67959977c8ebaadc2ddcf4bdc14658a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=d87eec1bf67959977c8ebaadc2ddcf4bdc14658a", "patch": "@@ -468,6 +468,10 @@ impl CStore {\n     pub fn num_def_ids(&self, cnum: CrateNum) -> usize {\n         self.get_crate_data(cnum).num_def_ids()\n     }\n+\n+    pub fn item_attrs(&self, def_id: DefId, sess: &Session) -> Vec<ast::Attribute> {\n+        self.get_crate_data(def_id.krate).get_item_attrs(def_id.index, sess).collect()\n+    }\n }\n \n impl CrateStore for CStore {"}, {"sha": "947cca3c725c5a043130415e349d5d226d12c643", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/d87eec1bf67959977c8ebaadc2ddcf4bdc14658a/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d87eec1bf67959977c8ebaadc2ddcf4bdc14658a/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=d87eec1bf67959977c8ebaadc2ddcf4bdc14658a", "patch": "@@ -91,6 +91,8 @@ impl CheckAttrVisitor<'tcx> {\n                 self.check_rustc_allow_const_fn_unstable(hir_id, &attr, span, target)\n             } else if self.tcx.sess.check_name(attr, sym::naked) {\n                 self.check_naked(hir_id, attr, span, target)\n+            } else if self.tcx.sess.check_name(attr, sym::rustc_legacy_const_generics) {\n+                self.check_rustc_legacy_const_generics(&attr, span, target, item)\n             } else {\n                 // lint-only checks\n                 if self.tcx.sess.check_name(attr, sym::cold) {\n@@ -750,6 +752,79 @@ impl CheckAttrVisitor<'tcx> {\n         }\n     }\n \n+    /// Checks if `#[rustc_legacy_const_generics]` is applied to a function and has a valid argument.\n+    fn check_rustc_legacy_const_generics(\n+        &self,\n+        attr: &Attribute,\n+        span: &Span,\n+        target: Target,\n+        item: Option<ItemLike<'_>>,\n+    ) -> bool {\n+        let is_function = matches!(target, Target::Fn | Target::Method(..) | Target::ForeignFn);\n+        if !is_function {\n+            self.tcx\n+                .sess\n+                .struct_span_err(attr.span, \"attribute should be applied to a function\")\n+                .span_label(*span, \"not a function\")\n+                .emit();\n+            return false;\n+        }\n+\n+        let list = match attr.meta_item_list() {\n+            // The attribute form is validated on AST.\n+            None => return false,\n+            Some(it) => it,\n+        };\n+\n+        let mut invalid_args = vec![];\n+        for meta in list {\n+            if let Some(LitKind::Int(val, _)) = meta.literal().map(|lit| &lit.kind) {\n+                if let Some(ItemLike::Item(Item {\n+                    kind: ItemKind::Fn(FnSig { decl, .. }, generics, _),\n+                    ..\n+                }))\n+                | Some(ItemLike::ForeignItem(ForeignItem {\n+                    kind: ForeignItemKind::Fn(decl, _, generics),\n+                    ..\n+                })) = item\n+                {\n+                    let arg_count = decl.inputs.len() as u128 + generics.params.len() as u128;\n+                    if *val >= arg_count {\n+                        let span = meta.span();\n+                        self.tcx\n+                            .sess\n+                            .struct_span_err(span, \"index exceeds number of arguments\")\n+                            .span_label(\n+                                span,\n+                                format!(\n+                                    \"there {} only {} argument{}\",\n+                                    if arg_count != 1 { \"are\" } else { \"is\" },\n+                                    arg_count,\n+                                    pluralize!(arg_count)\n+                                ),\n+                            )\n+                            .emit();\n+                        return false;\n+                    }\n+                } else {\n+                    bug!(\"should be a function item\");\n+                }\n+            } else {\n+                invalid_args.push(meta.span());\n+            }\n+        }\n+\n+        if !invalid_args.is_empty() {\n+            self.tcx\n+                .sess\n+                .struct_span_err(invalid_args, \"arguments should be non-negative integers\")\n+                .emit();\n+            false\n+        } else {\n+            true\n+        }\n+    }\n+\n     /// Checks if `#[link_section]` is applied to a function or static.\n     fn check_link_section(&self, hir_id: HirId, attr: &Attribute, span: &Span, target: Target) {\n         match target {"}, {"sha": "7e663444595cb1334bbd0d2617bb1e4b369dba11", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d87eec1bf67959977c8ebaadc2ddcf4bdc14658a/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d87eec1bf67959977c8ebaadc2ddcf4bdc14658a/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=d87eec1bf67959977c8ebaadc2ddcf4bdc14658a", "patch": "@@ -1076,6 +1076,10 @@ impl ResolverAstLowering for Resolver<'_> {\n         self.cstore().item_generics_num_lifetimes(def_id, sess)\n     }\n \n+    fn item_attrs(&self, def_id: DefId, sess: &Session) -> Vec<ast::Attribute> {\n+        self.cstore().item_attrs(def_id, sess)\n+    }\n+\n     fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes> {\n         self.partial_res_map.get(&id).cloned()\n     }"}, {"sha": "a3dadc372a9ade3643a8d6d738338234396d8e5b", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d87eec1bf67959977c8ebaadc2ddcf4bdc14658a/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d87eec1bf67959977c8ebaadc2ddcf4bdc14658a/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=d87eec1bf67959977c8ebaadc2ddcf4bdc14658a", "patch": "@@ -973,6 +973,7 @@ symbols! {\n         rustc_layout,\n         rustc_layout_scalar_valid_range_end,\n         rustc_layout_scalar_valid_range_start,\n+        rustc_legacy_const_generics,\n         rustc_macro_transparency,\n         rustc_mir,\n         rustc_nonnull_optimization_guaranteed,"}, {"sha": "67352a2fbbb1cc689e3b0fb0939804c58a7d7981", "filename": "src/test/ui/auxiliary/legacy-const-generics.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d87eec1bf67959977c8ebaadc2ddcf4bdc14658a/src%2Ftest%2Fui%2Fauxiliary%2Flegacy-const-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d87eec1bf67959977c8ebaadc2ddcf4bdc14658a/src%2Ftest%2Fui%2Fauxiliary%2Flegacy-const-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauxiliary%2Flegacy-const-generics.rs?ref=d87eec1bf67959977c8ebaadc2ddcf4bdc14658a", "patch": "@@ -0,0 +1,6 @@\n+#![feature(rustc_attrs)]\n+\n+#[rustc_legacy_const_generics(1)]\n+pub fn foo<const Y: usize>(x: usize, z: usize) -> [usize; 3] {\n+    [x, Y, z]\n+}"}, {"sha": "e044cd7a1f50578dbeecbbe9e949358160f7fd32", "filename": "src/test/ui/invalid-rustc_legacy_const_generics-arguments.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d87eec1bf67959977c8ebaadc2ddcf4bdc14658a/src%2Ftest%2Fui%2Finvalid-rustc_legacy_const_generics-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d87eec1bf67959977c8ebaadc2ddcf4bdc14658a/src%2Ftest%2Fui%2Finvalid-rustc_legacy_const_generics-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-rustc_legacy_const_generics-arguments.rs?ref=d87eec1bf67959977c8ebaadc2ddcf4bdc14658a", "patch": "@@ -0,0 +1,35 @@\n+#![feature(rustc_attrs)]\n+\n+#[rustc_legacy_const_generics(0)] //~ ERROR index exceeds number of arguments\n+fn foo1() {}\n+\n+#[rustc_legacy_const_generics(1)] //~ ERROR index exceeds number of arguments\n+fn foo2(_: u8) {}\n+\n+#[rustc_legacy_const_generics(2)] //~ ERROR index exceeds number of arguments\n+fn foo3<const X: usize>(_: u8) {}\n+\n+#[rustc_legacy_const_generics(a)] //~ ERROR arguments should be non-negative integers\n+fn foo4() {}\n+\n+#[rustc_legacy_const_generics(1, a, 2, b)] //~ ERROR arguments should be non-negative integers\n+fn foo5(_: u8, _: u8, _: u8) {}\n+\n+#[rustc_legacy_const_generics(0)] //~ ERROR attribute should be applied to a function\n+struct S;\n+\n+#[rustc_legacy_const_generics(0usize)] //~ ERROR suffixed literals are not allowed in attributes\n+fn foo6(_: u8) {}\n+\n+extern {\n+    #[rustc_legacy_const_generics(1)] //~ ERROR index exceeds number of arguments\n+    fn foo7(_: u8);\n+}\n+\n+#[rustc_legacy_const_generics] //~ ERROR malformed `rustc_legacy_const_generics` attribute\n+fn bar1() {}\n+\n+#[rustc_legacy_const_generics = 1] //~ ERROR malformed `rustc_legacy_const_generics` attribute\n+fn bar2() {}\n+\n+fn main() {}"}, {"sha": "92fad6792577987d0c428360b09e535e3000fcb0", "filename": "src/test/ui/invalid-rustc_legacy_const_generics-arguments.stderr", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/d87eec1bf67959977c8ebaadc2ddcf4bdc14658a/src%2Ftest%2Fui%2Finvalid-rustc_legacy_const_generics-arguments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d87eec1bf67959977c8ebaadc2ddcf4bdc14658a/src%2Ftest%2Fui%2Finvalid-rustc_legacy_const_generics-arguments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-rustc_legacy_const_generics-arguments.stderr?ref=d87eec1bf67959977c8ebaadc2ddcf4bdc14658a", "patch": "@@ -0,0 +1,66 @@\n+error: suffixed literals are not allowed in attributes\n+  --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:21:31\n+   |\n+LL | #[rustc_legacy_const_generics(0usize)]\n+   |                               ^^^^^^\n+   |\n+   = help: instead of using a suffixed literal (`1u8`, `1.0f32`, etc.), use an unsuffixed version (`1`, `1.0`, etc.)\n+\n+error: malformed `rustc_legacy_const_generics` attribute input\n+  --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:29:1\n+   |\n+LL | #[rustc_legacy_const_generics]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[rustc_legacy_const_generics(N)]`\n+\n+error: malformed `rustc_legacy_const_generics` attribute input\n+  --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:32:1\n+   |\n+LL | #[rustc_legacy_const_generics = 1]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[rustc_legacy_const_generics(N)]`\n+\n+error: index exceeds number of arguments\n+  --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:3:31\n+   |\n+LL | #[rustc_legacy_const_generics(0)]\n+   |                               ^ there are only 0 arguments\n+\n+error: index exceeds number of arguments\n+  --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:6:31\n+   |\n+LL | #[rustc_legacy_const_generics(1)]\n+   |                               ^ there is only 1 argument\n+\n+error: index exceeds number of arguments\n+  --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:9:31\n+   |\n+LL | #[rustc_legacy_const_generics(2)]\n+   |                               ^ there are only 2 arguments\n+\n+error: arguments should be non-negative integers\n+  --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:12:31\n+   |\n+LL | #[rustc_legacy_const_generics(a)]\n+   |                               ^\n+\n+error: arguments should be non-negative integers\n+  --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:15:34\n+   |\n+LL | #[rustc_legacy_const_generics(1, a, 2, b)]\n+   |                                  ^     ^\n+\n+error: attribute should be applied to a function\n+  --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:18:1\n+   |\n+LL | #[rustc_legacy_const_generics(0)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | struct S;\n+   | --------- not a function\n+\n+error: index exceeds number of arguments\n+  --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:25:35\n+   |\n+LL |     #[rustc_legacy_const_generics(1)]\n+   |                                   ^ there is only 1 argument\n+\n+error: aborting due to 10 previous errors\n+"}, {"sha": "00ab4b6cccf3a4a5b7c0f67d9032ce154ab9d1f2", "filename": "src/test/ui/legacy-const-generics.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d87eec1bf67959977c8ebaadc2ddcf4bdc14658a/src%2Ftest%2Fui%2Flegacy-const-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d87eec1bf67959977c8ebaadc2ddcf4bdc14658a/src%2Ftest%2Fui%2Flegacy-const-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flegacy-const-generics.rs?ref=d87eec1bf67959977c8ebaadc2ddcf4bdc14658a", "patch": "@@ -0,0 +1,18 @@\n+// aux-build:legacy-const-generics.rs\n+// run-pass\n+\n+#![feature(rustc_attrs)]\n+\n+extern crate legacy_const_generics;\n+\n+#[rustc_legacy_const_generics(1)]\n+pub fn bar<const Y: usize>(x: usize, z: usize) -> [usize; 3] {\n+    [x, Y, z]\n+}\n+\n+fn main() {\n+    assert_eq!(legacy_const_generics::foo(0 + 0, 1 + 1, 2 + 2), [0, 2, 4]);\n+    assert_eq!(legacy_const_generics::foo::<{1 + 1}>(0 + 0, 2 + 2), [0, 2, 4]);\n+    // TODO: Only works cross-crate\n+    //assert_eq!(bar(0, 1, 2), [0, 1, 2]);\n+}"}]}