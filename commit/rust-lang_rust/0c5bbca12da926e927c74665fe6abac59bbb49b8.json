{"sha": "0c5bbca12da926e927c74665fe6abac59bbb49b8", "node_id": "C_kwDOAAsO6NoAKDBjNWJiY2ExMmRhOTI2ZTkyN2M3NDY2NWZlNmFiYWM1OWJiYjQ5Yjg", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2023-02-16T06:10:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-16T06:10:19Z"}, "message": "Rollup merge of #106372 - joboet:solid_id_parking, r=m-ou-se\n\nUse id-based thread parking on SOLID\n\nBy using the [`slp_tsk`/`wup_tsk`](https://cs.uwaterloo.ca/~brecht/courses/702/Possible-Readings/embedded/uITRON-4.0-specification.pdf) system functions instead of an event-flag structure, `Parker` becomes cheaper to construct and SOLID can share the implementation used by NetBSD and SGX.\n\nping ``@kawadakk``\nr? ``@m-ou-se``\n``@rustbot`` label +T-libs", "tree": {"sha": "2f0328d32ceee401b9c37c4581c51cf6289cd0d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f0328d32ceee401b9c37c4581c51cf6289cd0d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c5bbca12da926e927c74665fe6abac59bbb49b8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj7cjLCRBK7hj4Ov3rIwAApq4IABZIHQ/nXHqHIRmgjxyFfluD\nvCzxySG7XbnZMA462ByxHhiEgSlcZ6Z7QF9XmKldNBT6Cd7qpbtkrCYYEHXqojz2\nKYPhi69kZ1doUGjZa9cSlnGrP/kzzUij59JI4Upz8Ket6zXYqr2KyRf20eVPu6OG\nUoAa59bBaUWkeKa+Skvo9w0R8GjrZyhZw4tXV6A6fBDcTEf8gK0clFgX2YoTO5hv\nPLpIX2MXVWPktPlyn0C+zDVX5oB0C5rJfaCpoznNAWrnsrvWg2ju5U37ggB3xrZN\n2JYgAbx1xvLnI0njP/4Se41lsau09rD1SVXnXwBfggfhwsAmLY4Ia0Mf5Zv7DzA=\n=r1b2\n-----END PGP SIGNATURE-----\n", "payload": "tree 2f0328d32ceee401b9c37c4581c51cf6289cd0d5\nparent dc7a676778706bde3b50ff6d4fe81e2955bd4847\nparent 78245286dcde9f2cf99a370ec0cd4383fa684404\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1676527819 +0530\ncommitter GitHub <noreply@github.com> 1676527819 +0530\n\nRollup merge of #106372 - joboet:solid_id_parking, r=m-ou-se\n\nUse id-based thread parking on SOLID\n\nBy using the [`slp_tsk`/`wup_tsk`](https://cs.uwaterloo.ca/~brecht/courses/702/Possible-Readings/embedded/uITRON-4.0-specification.pdf) system functions instead of an event-flag structure, `Parker` becomes cheaper to construct and SOLID can share the implementation used by NetBSD and SGX.\n\nping ``@kawadakk``\nr? ``@m-ou-se``\n``@rustbot`` label +T-libs\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c5bbca12da926e927c74665fe6abac59bbb49b8", "html_url": "https://github.com/rust-lang/rust/commit/0c5bbca12da926e927c74665fe6abac59bbb49b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c5bbca12da926e927c74665fe6abac59bbb49b8/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc7a676778706bde3b50ff6d4fe81e2955bd4847", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc7a676778706bde3b50ff6d4fe81e2955bd4847", "html_url": "https://github.com/rust-lang/rust/commit/dc7a676778706bde3b50ff6d4fe81e2955bd4847"}, {"sha": "78245286dcde9f2cf99a370ec0cd4383fa684404", "url": "https://api.github.com/repos/rust-lang/rust/commits/78245286dcde9f2cf99a370ec0cd4383fa684404", "html_url": "https://github.com/rust-lang/rust/commit/78245286dcde9f2cf99a370ec0cd4383fa684404"}], "stats": {"total": 219, "additions": 40, "deletions": 179}, "files": [{"sha": "fe9934439d152fddbfa0c417abae9c8a465a7cf6", "filename": "library/std/src/sys/itron/thread_parking.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0c5bbca12da926e927c74665fe6abac59bbb49b8/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread_parking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5bbca12da926e927c74665fe6abac59bbb49b8/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread_parking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread_parking.rs?ref=0c5bbca12da926e927c74665fe6abac59bbb49b8", "patch": "@@ -0,0 +1,37 @@\n+use super::abi;\n+use super::error::expect_success_aborting;\n+use super::time::with_tmos;\n+use crate::time::Duration;\n+\n+pub type ThreadId = abi::ID;\n+\n+pub use super::task::current_task_id_aborting as current;\n+\n+pub fn park(_hint: usize) {\n+    match unsafe { abi::slp_tsk() } {\n+        abi::E_OK | abi::E_RLWAI => {}\n+        err => {\n+            expect_success_aborting(err, &\"slp_tsk\");\n+        }\n+    }\n+}\n+\n+pub fn park_timeout(dur: Duration, _hint: usize) {\n+    match with_tmos(dur, |tmo| unsafe { abi::tslp_tsk(tmo) }) {\n+        abi::E_OK | abi::E_RLWAI | abi::E_TMOUT => {}\n+        err => {\n+            expect_success_aborting(err, &\"tslp_tsk\");\n+        }\n+    }\n+}\n+\n+pub fn unpark(id: ThreadId, _hint: usize) {\n+    match unsafe { abi::wup_tsk(id) } {\n+        // It is allowed to try to wake up a destroyed or unrelated task, so we ignore all\n+        // errors that could result from that situation.\n+        abi::E_OK | abi::E_NOEXS | abi::E_OBJ | abi::E_QOVR => {}\n+        err => {\n+            expect_success_aborting(err, &\"wup_tsk\");\n+        }\n+    }\n+}"}, {"sha": "e432edd207754e5151252c136a0946d0821d1a6a", "filename": "library/std/src/sys/itron/wait_flag.rs", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fwait_flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fwait_flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fwait_flag.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,72 +0,0 @@\n-use crate::mem::MaybeUninit;\n-use crate::time::Duration;\n-\n-use super::{\n-    abi,\n-    error::{expect_success, fail},\n-    time::with_tmos,\n-};\n-\n-const CLEAR: abi::FLGPTN = 0;\n-const RAISED: abi::FLGPTN = 1;\n-\n-/// A thread parking primitive that is not susceptible to race conditions,\n-/// but provides no atomic ordering guarantees and allows only one `raise` per wait.\n-pub struct WaitFlag {\n-    flag: abi::ID,\n-}\n-\n-impl WaitFlag {\n-    /// Creates a new wait flag.\n-    pub fn new() -> WaitFlag {\n-        let flag = expect_success(\n-            unsafe {\n-                abi::acre_flg(&abi::T_CFLG {\n-                    flgatr: abi::TA_FIFO | abi::TA_WSGL | abi::TA_CLR,\n-                    iflgptn: CLEAR,\n-                })\n-            },\n-            &\"acre_flg\",\n-        );\n-\n-        WaitFlag { flag }\n-    }\n-\n-    /// Wait for the wait flag to be raised.\n-    pub fn wait(&self) {\n-        let mut token = MaybeUninit::uninit();\n-        expect_success(\n-            unsafe { abi::wai_flg(self.flag, RAISED, abi::TWF_ORW, token.as_mut_ptr()) },\n-            &\"wai_flg\",\n-        );\n-    }\n-\n-    /// Wait for the wait flag to be raised or the timeout to occur.\n-    ///\n-    /// Returns whether the flag was raised (`true`) or the operation timed out (`false`).\n-    pub fn wait_timeout(&self, dur: Duration) -> bool {\n-        let mut token = MaybeUninit::uninit();\n-        let res = with_tmos(dur, |tmout| unsafe {\n-            abi::twai_flg(self.flag, RAISED, abi::TWF_ORW, token.as_mut_ptr(), tmout)\n-        });\n-\n-        match res {\n-            abi::E_OK => true,\n-            abi::E_TMOUT => false,\n-            error => fail(error, &\"twai_flg\"),\n-        }\n-    }\n-\n-    /// Raise the wait flag.\n-    ///\n-    /// Calls to this function should be balanced with the number of successful waits.\n-    pub fn raise(&self) {\n-        expect_success(unsafe { abi::set_flg(self.flag, RAISED) }, &\"set_flg\");\n-    }\n-}\n-\n-impl Drop for WaitFlag {\n-    fn drop(&mut self) {\n-        expect_success(unsafe { abi::del_flg(self.flag) }, &\"del_flg\");\n-    }\n-}"}, {"sha": "923d27fd9369d40219d1777cfef77e5e1332909f", "filename": "library/std/src/sys/solid/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c5bbca12da926e927c74665fe6abac59bbb49b8/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5bbca12da926e927c74665fe6abac59bbb49b8/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs?ref=0c5bbca12da926e927c74665fe6abac59bbb49b8", "patch": "@@ -13,9 +13,9 @@ mod itron {\n     pub(super) mod spin;\n     pub(super) mod task;\n     pub mod thread;\n+    pub mod thread_parking;\n     pub(super) mod time;\n     use super::unsupported;\n-    pub mod wait_flag;\n }\n \n pub mod alloc;\n@@ -43,8 +43,8 @@ pub use self::itron::thread;\n pub mod memchr;\n pub mod thread_local_dtor;\n pub mod thread_local_key;\n+pub use self::itron::thread_parking;\n pub mod time;\n-pub use self::itron::wait_flag;\n \n mod rwlock;\n "}, {"sha": "e8e028bb3308f1c480b2ced3e33d6ebda6d370ab", "filename": "library/std/src/sys_common/thread_parking/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c5bbca12da926e927c74665fe6abac59bbb49b8/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5bbca12da926e927c74665fe6abac59bbb49b8/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fmod.rs?ref=0c5bbca12da926e927c74665fe6abac59bbb49b8", "patch": "@@ -14,12 +14,10 @@ cfg_if::cfg_if! {\n     } else if #[cfg(any(\n         target_os = \"netbsd\",\n         all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n+        target_os = \"solid_asp3\",\n     ))] {\n         mod id;\n         pub use id::Parker;\n-    } else if #[cfg(target_os = \"solid_asp3\")] {\n-        mod wait_flag;\n-        pub use wait_flag::Parker;\n     } else if #[cfg(any(windows, target_family = \"unix\"))] {\n         pub use crate::sys::thread_parking::Parker;\n     } else {"}, {"sha": "d0f8899a94eb8507ff233f5d8321bf576fc8827e", "filename": "library/std/src/sys_common/thread_parking/wait_flag.rs", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/dc7a676778706bde3b50ff6d4fe81e2955bd4847/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fwait_flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7a676778706bde3b50ff6d4fe81e2955bd4847/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fwait_flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fwait_flag.rs?ref=dc7a676778706bde3b50ff6d4fe81e2955bd4847", "patch": "@@ -1,102 +0,0 @@\n-//! A wait-flag-based thread parker.\n-//!\n-//! Some operating systems provide low-level parking primitives like wait counts,\n-//! event flags or semaphores which are not susceptible to race conditions (meaning\n-//! the wakeup can occur before the wait operation). To implement the `std` thread\n-//! parker on top of these primitives, we only have to ensure that parking is fast\n-//! when the thread token is available, the atomic ordering guarantees are maintained\n-//! and spurious wakeups are minimized.\n-//!\n-//! To achieve this, this parker uses an atomic variable with three states: `EMPTY`,\n-//! `PARKED` and `NOTIFIED`:\n-//! * `EMPTY` means the token has not been made available, but the thread is not\n-//!    currently waiting on it.\n-//! * `PARKED` means the token is not available and the thread is parked.\n-//! * `NOTIFIED` means the token is available.\n-//!\n-//! `park` and `park_timeout` change the state from `EMPTY` to `PARKED` and from\n-//! `NOTIFIED` to `EMPTY`. If the state was `NOTIFIED`, the thread was unparked and\n-//! execution can continue without calling into the OS. If the state was `EMPTY`,\n-//! the token is not available and the thread waits on the primitive (here called\n-//! \"wait flag\").\n-//!\n-//! `unpark` changes the state to `NOTIFIED`. If the state was `PARKED`, the thread\n-//! is or will be sleeping on the wait flag, so we raise it.\n-\n-use crate::pin::Pin;\n-use crate::sync::atomic::AtomicI8;\n-use crate::sync::atomic::Ordering::{Acquire, Relaxed, Release};\n-use crate::sys::wait_flag::WaitFlag;\n-use crate::time::Duration;\n-\n-const EMPTY: i8 = 0;\n-const PARKED: i8 = -1;\n-const NOTIFIED: i8 = 1;\n-\n-pub struct Parker {\n-    state: AtomicI8,\n-    wait_flag: WaitFlag,\n-}\n-\n-impl Parker {\n-    /// Construct a parker for the current thread. The UNIX parker\n-    /// implementation requires this to happen in-place.\n-    pub unsafe fn new_in_place(parker: *mut Parker) {\n-        parker.write(Parker { state: AtomicI8::new(EMPTY), wait_flag: WaitFlag::new() })\n-    }\n-\n-    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n-    pub unsafe fn park(self: Pin<&Self>) {\n-        match self.state.fetch_sub(1, Acquire) {\n-            // NOTIFIED => EMPTY\n-            NOTIFIED => return,\n-            // EMPTY => PARKED\n-            EMPTY => (),\n-            _ => panic!(\"inconsistent park state\"),\n-        }\n-\n-        // Avoid waking up from spurious wakeups (these are quite likely, see below).\n-        loop {\n-            self.wait_flag.wait();\n-\n-            match self.state.compare_exchange(NOTIFIED, EMPTY, Acquire, Relaxed) {\n-                Ok(_) => return,\n-                Err(PARKED) => (),\n-                Err(_) => panic!(\"inconsistent park state\"),\n-            }\n-        }\n-    }\n-\n-    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n-    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n-        match self.state.fetch_sub(1, Acquire) {\n-            NOTIFIED => return,\n-            EMPTY => (),\n-            _ => panic!(\"inconsistent park state\"),\n-        }\n-\n-        self.wait_flag.wait_timeout(dur);\n-\n-        // Either a wakeup or a timeout occurred. Wakeups may be spurious, as there can be\n-        // a race condition when `unpark` is performed between receiving the timeout and\n-        // resetting the state, resulting in the eventflag being set unnecessarily. `park`\n-        // is protected against this by looping until the token is actually given, but\n-        // here we cannot easily tell.\n-\n-        // Use `swap` to provide acquire ordering.\n-        match self.state.swap(EMPTY, Acquire) {\n-            NOTIFIED => (),\n-            PARKED => (),\n-            _ => panic!(\"inconsistent park state\"),\n-        }\n-    }\n-\n-    // This implementation doesn't require `Pin`, but other implementations do.\n-    pub fn unpark(self: Pin<&Self>) {\n-        let state = self.state.swap(NOTIFIED, Release);\n-\n-        if state == PARKED {\n-            self.wait_flag.raise();\n-        }\n-    }\n-}"}]}