{"sha": "16331f1a42842ecdbf3dbcd6805df47564660266", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2MzMxZjFhNDI4NDJlY2RiZjNkYmNkNjgwNWRmNDc1NjQ2NjAyNjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-03T02:23:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-03T02:23:03Z"}, "message": "Auto merge of #28820 - steveklabnik:rollup, r=steveklabnik\n\n- Successful merges: #28736, #28805, #28812, #28814, #28819\n- Failed merges:", "tree": {"sha": "1539ad481a99c88265e06610e33027383415e829", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1539ad481a99c88265e06610e33027383415e829"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16331f1a42842ecdbf3dbcd6805df47564660266", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16331f1a42842ecdbf3dbcd6805df47564660266", "html_url": "https://github.com/rust-lang/rust/commit/16331f1a42842ecdbf3dbcd6805df47564660266", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16331f1a42842ecdbf3dbcd6805df47564660266/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98df45830a04498c9207c4251a16ef6c80629146", "url": "https://api.github.com/repos/rust-lang/rust/commits/98df45830a04498c9207c4251a16ef6c80629146", "html_url": "https://github.com/rust-lang/rust/commit/98df45830a04498c9207c4251a16ef6c80629146"}, {"sha": "92cff9f0d9aa1c76d57060c21520624d729416ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/92cff9f0d9aa1c76d57060c21520624d729416ca", "html_url": "https://github.com/rust-lang/rust/commit/92cff9f0d9aa1c76d57060c21520624d729416ca"}], "stats": {"total": 299, "additions": 264, "deletions": 35}, "files": [{"sha": "2fce37eccae1caa2e72460e1e68751e1b1cd3f99", "filename": "src/doc/reference.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16331f1a42842ecdbf3dbcd6805df47564660266/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/16331f1a42842ecdbf3dbcd6805df47564660266/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=16331f1a42842ecdbf3dbcd6805df47564660266", "patch": "@@ -77,9 +77,12 @@ An identifier is any nonempty Unicode[^non_ascii_idents] string of the following\n   gated. This is expected to improve soon.\n \n Either\n+\n    * The first character has property `XID_start`\n    * The remaining characters have property `XID_continue`\n+\n Or\n+\n    * The first character is `_`\n    * The identifier is more than one character, `_` alone is not an identifier\n    * The remaining characters have property `XID_continue`"}, {"sha": "1e1b2e2d4588be03d8258dbfb923e30a4b8ff2d1", "filename": "src/doc/trpl/documentation.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16331f1a42842ecdbf3dbcd6805df47564660266/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/16331f1a42842ecdbf3dbcd6805df47564660266/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdocumentation.md?ref=16331f1a42842ecdbf3dbcd6805df47564660266", "patch": "@@ -279,6 +279,8 @@ println!(\"{}\", x + y);\n \n Here's an explanation, rendered:\n \n+-------------------------------------------------------------------------------\n+\n First, we set `x` to five:\n \n ```rust\n@@ -303,8 +305,12 @@ Finally, we print the sum of `x` and `y`:\n println!(\"{}\", x + y);\n ```\n \n+-------------------------------------------------------------------------------\n+\n Here's the same explanation, in raw text:\n \n+-------------------------------------------------------------------------------\n+\n > First, we set `x` to five:\n >\n > ```text\n@@ -329,6 +335,8 @@ Here's the same explanation, in raw text:\n > println!(\"{}\", x + y);\n > ```\n \n+-------------------------------------------------------------------------------\n+\n By repeating all parts of the example, you can ensure that your example still\n compiles, while only showing the parts that are relevant to that part of your\n explanation."}, {"sha": "271dbffcc2e41217342112f0d12cb6109730a109", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 111, "deletions": 18, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/16331f1a42842ecdbf3dbcd6805df47564660266/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16331f1a42842ecdbf3dbcd6805df47564660266/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=16331f1a42842ecdbf3dbcd6805df47564660266", "patch": "@@ -92,26 +92,61 @@ impl String {\n         panic!(\"not available with cfg(test)\");\n     }\n \n-    /// Returns the vector as a string buffer, if possible, taking care not to\n-    /// copy it.\n+    /// Converts a vector of bytes to a `String`.\n+    ///\n+    /// A string slice (`&str`) is made of bytes (`u8`), and a vector of bytes\n+    /// (`Vec<u8>`) is made of bytes, so this function converts between the\n+    /// two. Not all byte slices are valid `String`s, however: `String`\n+    /// requires that it is valid UTF-8. `from_utf8()` checks to ensure that\n+    /// the bytes are valid UTF-8, and then does the conversion.\n+    ///\n+    /// If you are sure that the byte slice is valid UTF-8, and you don't want\n+    /// to incur the overhead of the validity check, there is an unsafe version\n+    /// of this function, [`from_utf8_unchecked()`][fromutf8], which has the\n+    /// same behavior but skips the check.\n+    ///\n+    /// [fromutf8]: struct.String.html#method.from_utf8_unchecked\n+    ///\n+    /// This method will take care to not copy the vector, for efficiency's\n+    /// sake.\n+    ///\n+    /// If you need a `&str` instead of a `String`, consider\n+    /// [`str::from_utf8()`][str].\n+    ///\n+    /// [str]: ../str/fn.from_utf8.html\n     ///\n     /// # Failure\n     ///\n-    /// If the given vector is not valid UTF-8, then the original vector and the\n-    /// corresponding error is returned.\n+    /// Returns `Err` if the slice is not UTF-8 with a description as to why the\n+    /// provided bytes are not UTF-8. The vector you moved in is also included.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let hello_vec = vec![104, 101, 108, 108, 111];\n-    /// let s = String::from_utf8(hello_vec).unwrap();\n-    /// assert_eq!(s, \"hello\");\n-    ///\n-    /// let invalid_vec = vec![240, 144, 128];\n-    /// let s = String::from_utf8(invalid_vec).err().unwrap();\n-    /// let err = s.utf8_error();\n-    /// assert_eq!(s.into_bytes(), [240, 144, 128]);\n+    /// // some bytes, in a vector\n+    /// let sparkle_heart = vec![240, 159, 146, 150];\n+    ///\n+    /// // We know these bytes are valid, so just use `unwrap()`.\n+    /// let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n+    ///\n+    /// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n     /// ```\n+    ///\n+    /// Incorrect bytes:\n+    ///\n+    /// ```\n+    /// // some invalid bytes, in a vector\n+    /// let sparkle_heart = vec![0, 159, 146, 150];\n+    ///\n+    /// assert!(String::from_utf8(sparkle_heart).is_err());\n+    /// ```\n+    ///\n+    /// See the docs for [`FromUtf8Error`][error] for more details on what you\n+    /// can do with this error.\n+    ///\n+    /// [error]: struct.FromUtf8Error.html\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf8(vec: Vec<u8>) -> Result<String, FromUtf8Error> {\n@@ -121,15 +156,49 @@ impl String {\n         }\n     }\n \n-    /// Converts a vector of bytes to a new UTF-8 string.\n-    /// Any invalid UTF-8 sequences are replaced with U+FFFD REPLACEMENT CHARACTER.\n+    /// Converts a slice of bytes to a `String`, including invalid characters.\n+    ///\n+    /// A string slice (`&str`) is made of bytes (`u8`), and a slice of bytes\n+    /// (`&[u8]`) is made of bytes, so this function converts between the two.\n+    /// Not all byte slices are valid string slices, however: `&str` requires\n+    /// that it is valid UTF-8. During this conversion, `from_utf8_lossy()`\n+    /// will replace any invalid UTF-8 sequences with\n+    /// `U+FFFD REPLACEMENT CHARACTER`, which looks like this: \ufffd\n+    ///\n+    /// If you are sure that the byte slice is valid UTF-8, and you don't want\n+    /// to incur the overhead of the conversion, there is an unsafe version\n+    /// of this function, [`from_utf8_unchecked()`][fromutf8], which has the\n+    /// same behavior but skips the checks.\n+    ///\n+    /// [fromutf8]: struct.String.html#method.from_utf8_unchecked\n+    ///\n+    /// If you need a `&str` instead of a `String`, consider\n+    /// [`str::from_utf8()`][str].\n+    ///\n+    /// [str]: ../str/fn.from_utf8.html\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// // some bytes, in a vector\n+    /// let sparkle_heart = vec![240, 159, 146, 150];\n+    ///\n+    /// // We know these bytes are valid, so just use `unwrap()`.\n+    /// let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n+    ///\n+    /// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n     /// ```\n+    ///\n+    /// Incorrect bytes:\n+    ///\n+    /// ```\n+    /// // some invalid bytes\n     /// let input = b\"Hello \\xF0\\x90\\x80World\";\n     /// let output = String::from_utf8_lossy(input);\n-    /// assert_eq!(output, \"Hello \\u{FFFD}World\");\n+    ///\n+    /// assert_eq!(\"Hello \ufffdWorld\", output);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> Cow<'a, str> {\n@@ -309,9 +378,33 @@ impl String {\n         }\n     }\n \n-    /// Converts a vector of bytes to a new `String` without checking if\n-    /// it contains valid UTF-8. This is unsafe because it assumes that\n-    /// the UTF-8-ness of the vector has already been validated.\n+    /// Converts a vector of bytes to a `String` without checking that the\n+    /// string contains valid UTF-8.\n+    ///\n+    /// See the safe version, [`from_utrf8()`][fromutf8], for more.\n+    ///\n+    /// [fromutf8]: struct.String.html#method.from_utf8\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This function is unsafe because it does not check that the bytes passed to\n+    /// it are valid UTF-8. If this constraint is violated, undefined behavior\n+    /// results, as the rest of Rust assumes that `String`s are valid UTF-8.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// // some bytes, in a vector\n+    /// let sparkle_heart = vec![240, 159, 146, 150];\n+    ///\n+    /// let sparkle_heart = unsafe {\n+    ///     String::from_utf8_unchecked(sparkle_heart)\n+    /// };\n+    ///\n+    /// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn from_utf8_unchecked(bytes: Vec<u8>) -> String {"}, {"sha": "9f1439ea3880767d7362a70dffac610db1eae723", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 119, "deletions": 5, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/16331f1a42842ecdbf3dbcd6805df47564660266/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16331f1a42842ecdbf3dbcd6805df47564660266/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=16331f1a42842ecdbf3dbcd6805df47564660266", "patch": "@@ -119,7 +119,11 @@ impl fmt::Display for ParseBoolError {\n Section: Creating a string\n */\n \n-/// Errors which can occur when attempting to interpret a byte slice as a `str`.\n+/// Errors which can occur when attempting to interpret a sequence of `u8`\n+/// as a string.\n+///\n+/// As such, the `from_utf8` family of functions and methods for both `String`s\n+/// and `&str`s make use of this error, for example.\n #[derive(Copy, Eq, PartialEq, Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Utf8Error {\n@@ -132,21 +136,104 @@ impl Utf8Error {\n     ///\n     /// It is the maximum index such that `from_utf8(input[..index])`\n     /// would return `Some(_)`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(utf8_error)]\n+    ///\n+    /// use std::str;\n+    ///\n+    /// // some invalid bytes, in a vector\n+    /// let sparkle_heart = vec![0, 159, 146, 150];\n+    ///\n+    /// // std::str::from_utf8 returns a Utf8Error\n+    /// let error = str::from_utf8(&sparkle_heart).unwrap_err();\n+    ///\n+    /// // the first byte is invalid here\n+    /// assert_eq!(1, error.valid_up_to());\n+    /// ```\n     #[unstable(feature = \"utf8_error\", reason = \"method just added\",\n                issue = \"27734\")]\n     pub fn valid_up_to(&self) -> usize { self.valid_up_to }\n }\n \n-/// Converts a slice of bytes to a string slice without performing any\n-/// allocations.\n+/// Converts a slice of bytes to a string slice.\n ///\n-/// Once the slice has been validated as UTF-8, it is transmuted in-place and\n-/// returned as a '&str' instead of a '&[u8]'\n+/// A string slice (`&str`) is made of bytes (`u8`), and a byte slice (`&[u8]`)\n+/// is made of bytes, so this function converts between the two. Not all byte\n+/// slices are valid string slices, however: `&str` requires that it is valid\n+/// UTF-8. `from_utf8()` checks to ensure that the bytes are valid UTF-8, and\n+/// then does the conversion.\n+///\n+/// If you are sure that the byte slice is valid UTF-8, and you don't want to\n+/// incur the overhead of the validity check, there is an unsafe version of\n+/// this function, [`from_utf8_unchecked()`][fromutf8], which has the same\n+/// behavior but skips the check.\n+///\n+/// [fromutf8]: fn.from_utf8.html\n+///\n+/// If you need a `String` instead of a `&str`, consider\n+/// [`String::from_utf8()`][string].\n+///\n+/// [string]: ../string/struct.String.html#method.from_utf8\n+///\n+/// Because you can stack-allocate a `[u8; N]`, and you can take a `&[u8]` of\n+/// it, this function is one way to have a stack-allocated string. There is\n+/// an example of this in the examples section below.\n ///\n /// # Failure\n ///\n /// Returns `Err` if the slice is not UTF-8 with a description as to why the\n /// provided slice is not UTF-8.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::str;\n+///\n+/// // some bytes, in a vector\n+/// let sparkle_heart = vec![240, 159, 146, 150];\n+///\n+/// // We know these bytes are valid, so just use `unwrap()`.\n+/// let sparkle_heart = str::from_utf8(&sparkle_heart).unwrap();\n+///\n+/// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n+/// ```\n+///\n+/// Incorrect bytes:\n+///\n+/// ```\n+/// use std::str;\n+///\n+/// // some invalid bytes, in a vector\n+/// let sparkle_heart = vec![0, 159, 146, 150];\n+///\n+/// assert!(str::from_utf8(&sparkle_heart).is_err());\n+/// ```\n+///\n+/// See the docs for [`Utf8Error`][error] for more details on the kinds of\n+/// errors that can be returned.\n+///\n+/// [error]: struct.Utf8Error.html\n+///\n+/// A \"stack allocated string\":\n+///\n+/// ```\n+/// use std::str;\n+///\n+/// // some bytes, in a stack-allocated array\n+/// let sparkle_heart = [240, 159, 146, 150];\n+///\n+/// // We know these bytes are valid, so just use `unwrap()`.\n+/// let sparkle_heart = str::from_utf8(&sparkle_heart).unwrap();\n+///\n+/// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n     try!(run_utf8_validation_iterator(&mut v.iter()));\n@@ -155,6 +242,33 @@ pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n \n /// Converts a slice of bytes to a string slice without checking\n /// that the string contains valid UTF-8.\n+///\n+/// See the safe version, [`from_utrf8()`][fromutf8], for more.\n+///\n+/// [fromutf8]: fn.from_utf8.html\n+///\n+/// # Unsafety\n+///\n+/// This function is unsafe because it does not check that the bytes passed to\n+/// it are valid UTF-8. If this constraint is violated, undefined behavior\n+/// results, as the rest of Rust assumes that `&str`s are valid UTF-8.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::str;\n+///\n+/// // some bytes, in a vector\n+/// let sparkle_heart = vec![240, 159, 146, 150];\n+///\n+/// let sparkle_heart = unsafe {\n+///     str::from_utf8_unchecked(&sparkle_heart)\n+/// };\n+///\n+/// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n+/// ```\n #[inline(always)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {"}, {"sha": "5a6d76168322402f27d991b96a67fa1dacb8ecd2", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/16331f1a42842ecdbf3dbcd6805df47564660266/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/16331f1a42842ecdbf3dbcd6805df47564660266/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=16331f1a42842ecdbf3dbcd6805df47564660266", "patch": "@@ -133,7 +133,7 @@\n     $(document).on(\"keypress\", handleShortcut);\n     $(document).on(\"keydown\", handleShortcut);\n     $(document).on(\"click\", function(ev) {\n-        if (!$(e.target).closest(\"#help > div\").length) {\n+        if (!$(ev.target).closest(\"#help > div\").length) {\n             $(\"#help\").addClass(\"hidden\");\n             $(\"body\").removeClass(\"blur\");\n         }\n@@ -515,23 +515,20 @@\n                 var $active = $results.filter('.highlighted');\n \n                 if (e.which === 38) { // up\n-                    e.preventDefault();\n                     if (!$active.length || !$active.prev()) {\n                         return;\n                     }\n \n                     $active.prev().addClass('highlighted');\n                     $active.removeClass('highlighted');\n                 } else if (e.which === 40) { // down\n-                    e.preventDefault();\n                     if (!$active.length) {\n                         $results.first().addClass('highlighted');\n                     } else if ($active.next().length) {\n                         $active.next().addClass('highlighted');\n                         $active.removeClass('highlighted');\n                     }\n                 } else if (e.which === 13) { // return\n-                    e.preventDefault();\n                     if ($active.length) {\n                         document.location.href = $active.find('a').prop('href');\n                     }\n@@ -722,20 +719,29 @@\n         }\n \n         function startSearch() {\n-\n-            $(\".search-input\").on(\"keyup\",function() {\n+            var searchTimeout;\n+            $(\".search-input\").on(\"keyup input\",function() {\n+                clearTimeout(searchTimeout);\n                 if ($(this).val().length === 0) {\n                     window.history.replaceState(\"\", \"std - Rust\", \"?search=\");\n                     $('#main.content').removeClass('hidden');\n                     $('#search.content').addClass('hidden');\n+                } else {\n+                    searchTimeout = setTimeout(search, 500);\n                 }\n             });\n-\n-            var keyUpTimeout;\n-            $('.do-search').on('click', search);\n-            $('.search-input').on('keyup', function() {\n-                clearTimeout(keyUpTimeout);\n-                keyUpTimeout = setTimeout(search, 500);\n+            $('.search-form').on('submit', function(e){\n+                e.preventDefault();\n+                clearTimeout(searchTimeout);\n+                search();\n+            });\n+            $('.search-input').on('change paste', function(e) {\n+                // Do NOT e.preventDefault() here. It will prevent pasting.\n+                clearTimeout(searchTimeout);\n+                // zero-timeout necessary here because at the time of event handler execution the\n+                // pasted content is not in the input field yet. Shouldn\u2019t make any difference for\n+                // change, though.\n+                setTimeout(search, 0);\n             });\n \n             // Push and pop states are used to add search results to the browser"}, {"sha": "1442224cf9a7699f4f81f510173afb7bf6380350", "filename": "src/test/run-make/compile-stdin/Makefile", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16331f1a42842ecdbf3dbcd6805df47564660266/src%2Ftest%2Frun-make%2Fcompile-stdin%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/16331f1a42842ecdbf3dbcd6805df47564660266/src%2Ftest%2Frun-make%2Fcompile-stdin%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcompile-stdin%2FMakefile?ref=16331f1a42842ecdbf3dbcd6805df47564660266", "patch": "@@ -0,0 +1,5 @@\n+-include ../tools.mk\n+\n+all:\n+\techo 'fn main(){}' | $(RUSTC) -\n+\t$(call RUN,rust_out)"}]}