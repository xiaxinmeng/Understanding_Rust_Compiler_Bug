{"sha": "87779aef0bae771658ebd31336d918e575a05730", "node_id": "C_kwDOAAsO6NoAKDg3Nzc5YWVmMGJhZTc3MTY1OGViZDMxMzM2ZDkxOGU1NzVhMDU3MzA", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2022-10-29T21:51:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-29T21:51:36Z"}, "message": "Merge pull request #287 from rust-lang/feature/pointer-vectors\n\nVectors of pointers", "tree": {"sha": "c02f45aaf659af4710b1fd194b71018ee73b996f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c02f45aaf659af4710b1fd194b71018ee73b996f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87779aef0bae771658ebd31336d918e575a05730", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjXaBoCRBK7hj4Ov3rIwAA9xEIAHBezNwsvsC9JeL7YZAIGxqk\noe0iME4BIH7OpVQ4DyUun+amjuC6S6zkyYrd/P39h19ZUhv07GRyJGzJ6K8dj+XX\nXhI6XIC4ywumfdyrgHDGW4kYg2oOcau/bIjXktlDj9eH7fLU26IwOQK1vqBLCBtt\n1izaTv6OeSWDMoUX7DR/pueakAFdYm1T2w5XHnAIIcYfqhxz1G4dwvoz3f1xefPr\nzuS2xmUlIe9sZ8CweFxNIepngmCl/ar05J3T7sL1oflGGRkllS4fm/sWAANUiits\nLmQKbdf4aQoM0p87u9225Sklak6LLBZ1brmw6rwKZ7D4qVo6Kg8Hmrwf7Iq/y/0=\n=7Xk8\n-----END PGP SIGNATURE-----\n", "payload": "tree c02f45aaf659af4710b1fd194b71018ee73b996f\nparent 7c80b6967ace2b669dc921e67d637c0d546318a9\nparent 469c620bded61d265ef020b2442b1f639b2d8c10\nauthor Caleb Zulawski <caleb.zulawski@gmail.com> 1667080296 -0400\ncommitter GitHub <noreply@github.com> 1667080296 -0400\n\nMerge pull request #287 from rust-lang/feature/pointer-vectors\n\nVectors of pointers"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87779aef0bae771658ebd31336d918e575a05730", "html_url": "https://github.com/rust-lang/rust/commit/87779aef0bae771658ebd31336d918e575a05730", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87779aef0bae771658ebd31336d918e575a05730/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c80b6967ace2b669dc921e67d637c0d546318a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c80b6967ace2b669dc921e67d637c0d546318a9", "html_url": "https://github.com/rust-lang/rust/commit/7c80b6967ace2b669dc921e67d637c0d546318a9"}, {"sha": "469c620bded61d265ef020b2442b1f639b2d8c10", "url": "https://api.github.com/repos/rust-lang/rust/commits/469c620bded61d265ef020b2442b1f639b2d8c10", "html_url": "https://github.com/rust-lang/rust/commit/469c620bded61d265ef020b2442b1f639b2d8c10"}], "stats": {"total": 747, "additions": 658, "deletions": 89}, "files": [{"sha": "65a3f845ffca74022127bf319ffccf5c77bacf38", "filename": "crates/core_simd/src/cast.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/87779aef0bae771658ebd31336d918e575a05730/crates%2Fcore_simd%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87779aef0bae771658ebd31336d918e575a05730/crates%2Fcore_simd%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fcast.rs?ref=87779aef0bae771658ebd31336d918e575a05730", "patch": "@@ -0,0 +1,55 @@\n+use crate::simd::SimdElement;\n+\n+/// Supporting trait for `Simd::cast`.  Typically doesn't need to be used directly.\n+///\n+/// # Safety\n+/// Implementing this trait asserts that the type is a valid vector element for the `simd_cast` or\n+/// `simd_as` intrinsics.\n+pub unsafe trait SimdCast: SimdElement {}\n+\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for i8 {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for i16 {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for i32 {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for i64 {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for isize {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for u8 {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for u16 {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for u32 {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for u64 {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for usize {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for f32 {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for f64 {}\n+\n+/// Supporting trait for `Simd::cast_ptr`.  Typically doesn't need to be used directly.\n+///\n+/// # Safety\n+/// Implementing this trait asserts that the type is a valid vector element for the `simd_cast_ptr`\n+/// intrinsic.\n+pub unsafe trait SimdCastPtr<T> {}\n+\n+// Safety: pointers can be cast to other pointer types\n+unsafe impl<T, U> SimdCastPtr<T> for *const U\n+where\n+    U: core::ptr::Pointee,\n+    T: core::ptr::Pointee<Metadata = U::Metadata>,\n+{\n+}\n+// Safety: pointers can be cast to other pointer types\n+unsafe impl<T, U> SimdCastPtr<T> for *mut U\n+where\n+    U: core::ptr::Pointee,\n+    T: core::ptr::Pointee<Metadata = U::Metadata>,\n+{\n+}"}, {"sha": "dc7f52a4d576cf1d31f4841c60c974791cf1bff8", "filename": "crates/core_simd/src/elements.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87779aef0bae771658ebd31336d918e575a05730/crates%2Fcore_simd%2Fsrc%2Felements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87779aef0bae771658ebd31336d918e575a05730/crates%2Fcore_simd%2Fsrc%2Felements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Felements.rs?ref=87779aef0bae771658ebd31336d918e575a05730", "patch": "@@ -1,11 +1,15 @@\n+mod const_ptr;\n mod float;\n mod int;\n+mod mut_ptr;\n mod uint;\n \n mod sealed {\n     pub trait Sealed {}\n }\n \n+pub use const_ptr::*;\n pub use float::*;\n pub use int::*;\n+pub use mut_ptr::*;\n pub use uint::*;"}, {"sha": "f7227a56d58dce6a13573b785b289bfb7d80ac21", "filename": "crates/core_simd/src/elements/const_ptr.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/87779aef0bae771658ebd31336d918e575a05730/crates%2Fcore_simd%2Fsrc%2Felements%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87779aef0bae771658ebd31336d918e575a05730/crates%2Fcore_simd%2Fsrc%2Felements%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Felements%2Fconst_ptr.rs?ref=87779aef0bae771658ebd31336d918e575a05730", "patch": "@@ -0,0 +1,139 @@\n+use super::sealed::Sealed;\n+use crate::simd::{intrinsics, LaneCount, Mask, Simd, SimdPartialEq, SupportedLaneCount};\n+\n+/// Operations on SIMD vectors of constant pointers.\n+pub trait SimdConstPtr: Copy + Sealed {\n+    /// Vector of `usize` with the same number of lanes.\n+    type Usize;\n+\n+    /// Vector of `isize` with the same number of lanes.\n+    type Isize;\n+\n+    /// Vector of mutable pointers to the same type.\n+    type MutPtr;\n+\n+    /// Mask type used for manipulating this SIMD vector type.\n+    type Mask;\n+\n+    /// Returns `true` for each lane that is null.\n+    fn is_null(self) -> Self::Mask;\n+\n+    /// Changes constness without changing the type.\n+    fn as_mut(self) -> Self::MutPtr;\n+\n+    /// Gets the \"address\" portion of the pointer.\n+    ///\n+    /// This method discards pointer semantic metadata, so the result cannot be\n+    /// directly cast into a valid pointer.\n+    ///\n+    /// This method semantically discards *provenance* and\n+    /// *address-space* information. To properly restore that information, use [`Self::with_addr`].\n+    ///\n+    /// Equivalent to calling [`pointer::addr`] on each lane.\n+    fn addr(self) -> Self::Usize;\n+\n+    /// Creates a new pointer with the given address.\n+    ///\n+    /// This performs the same operation as a cast, but copies the *address-space* and\n+    /// *provenance* of `self` to the new pointer.\n+    ///\n+    /// Equivalent to calling [`pointer::with_addr`] on each lane.\n+    fn with_addr(self, addr: Self::Usize) -> Self;\n+\n+    /// Gets the \"address\" portion of the pointer, and \"exposes\" the provenance part for future use\n+    /// in [`Self::from_exposed_addr`].\n+    fn expose_addr(self) -> Self::Usize;\n+\n+    /// Convert an address back to a pointer, picking up a previously \"exposed\" provenance.\n+    ///\n+    /// Equivalent to calling [`core::ptr::from_exposed_addr`] on each lane.\n+    fn from_exposed_addr(addr: Self::Usize) -> Self;\n+\n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    ///\n+    /// Equivalent to calling [`pointer::wrapping_offset`] on each lane.\n+    fn wrapping_offset(self, offset: Self::Isize) -> Self;\n+\n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    ///\n+    /// Equivalent to calling [`pointer::wrapping_add`] on each lane.\n+    fn wrapping_add(self, count: Self::Usize) -> Self;\n+\n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    ///\n+    /// Equivalent to calling [`pointer::wrapping_sub`] on each lane.\n+    fn wrapping_sub(self, count: Self::Usize) -> Self;\n+}\n+\n+impl<T, const LANES: usize> Sealed for Simd<*const T, LANES> where\n+    LaneCount<LANES>: SupportedLaneCount\n+{\n+}\n+\n+impl<T, const LANES: usize> SimdConstPtr for Simd<*const T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Usize = Simd<usize, LANES>;\n+    type Isize = Simd<isize, LANES>;\n+    type MutPtr = Simd<*mut T, LANES>;\n+    type Mask = Mask<isize, LANES>;\n+\n+    #[inline]\n+    fn is_null(self) -> Self::Mask {\n+        Simd::splat(core::ptr::null()).simd_eq(self)\n+    }\n+\n+    #[inline]\n+    fn as_mut(self) -> Self::MutPtr {\n+        self.cast_ptr()\n+    }\n+\n+    #[inline]\n+    fn addr(self) -> Self::Usize {\n+        // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n+        // provenance).\n+        unsafe { core::mem::transmute_copy(&self) }\n+    }\n+\n+    #[inline]\n+    fn with_addr(self, addr: Self::Usize) -> Self {\n+        // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+        //\n+        // In the mean-time, this operation is defined to be \"as if\" it was\n+        // a wrapping_offset, so we can emulate it as such. This should properly\n+        // restore pointer provenance even under today's compiler.\n+        self.cast_ptr::<*const u8>()\n+            .wrapping_offset(addr.cast::<isize>() - self.addr().cast::<isize>())\n+            .cast_ptr()\n+    }\n+\n+    #[inline]\n+    fn expose_addr(self) -> Self::Usize {\n+        // Safety: `self` is a pointer vector\n+        unsafe { intrinsics::simd_expose_addr(self) }\n+    }\n+\n+    #[inline]\n+    fn from_exposed_addr(addr: Self::Usize) -> Self {\n+        // Safety: `self` is a pointer vector\n+        unsafe { intrinsics::simd_from_exposed_addr(addr) }\n+    }\n+\n+    #[inline]\n+    fn wrapping_offset(self, count: Self::Isize) -> Self {\n+        // Safety: simd_arith_offset takes a vector of pointers and a vector of offsets\n+        unsafe { intrinsics::simd_arith_offset(self, count) }\n+    }\n+\n+    #[inline]\n+    fn wrapping_add(self, count: Self::Usize) -> Self {\n+        self.wrapping_offset(count.cast())\n+    }\n+\n+    #[inline]\n+    fn wrapping_sub(self, count: Self::Usize) -> Self {\n+        self.wrapping_offset(-count.cast::<isize>())\n+    }\n+}"}, {"sha": "e2fd438ef8fb75a7e820b41bcf21518473077572", "filename": "crates/core_simd/src/elements/mut_ptr.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/87779aef0bae771658ebd31336d918e575a05730/crates%2Fcore_simd%2Fsrc%2Felements%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87779aef0bae771658ebd31336d918e575a05730/crates%2Fcore_simd%2Fsrc%2Felements%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Felements%2Fmut_ptr.rs?ref=87779aef0bae771658ebd31336d918e575a05730", "patch": "@@ -0,0 +1,134 @@\n+use super::sealed::Sealed;\n+use crate::simd::{intrinsics, LaneCount, Mask, Simd, SimdPartialEq, SupportedLaneCount};\n+\n+/// Operations on SIMD vectors of mutable pointers.\n+pub trait SimdMutPtr: Copy + Sealed {\n+    /// Vector of `usize` with the same number of lanes.\n+    type Usize;\n+\n+    /// Vector of `isize` with the same number of lanes.\n+    type Isize;\n+\n+    /// Vector of constant pointers to the same type.\n+    type ConstPtr;\n+\n+    /// Mask type used for manipulating this SIMD vector type.\n+    type Mask;\n+\n+    /// Returns `true` for each lane that is null.\n+    fn is_null(self) -> Self::Mask;\n+\n+    /// Changes constness without changing the type.\n+    fn as_const(self) -> Self::ConstPtr;\n+\n+    /// Gets the \"address\" portion of the pointer.\n+    ///\n+    /// This method discards pointer semantic metadata, so the result cannot be\n+    /// directly cast into a valid pointer.\n+    ///\n+    /// Equivalent to calling [`pointer::addr`] on each lane.\n+    fn addr(self) -> Self::Usize;\n+\n+    /// Creates a new pointer with the given address.\n+    ///\n+    /// This performs the same operation as a cast, but copies the *address-space* and\n+    /// *provenance* of `self` to the new pointer.\n+    ///\n+    /// Equivalent to calling [`pointer::with_addr`] on each lane.\n+    fn with_addr(self, addr: Self::Usize) -> Self;\n+\n+    /// Gets the \"address\" portion of the pointer, and \"exposes\" the provenance part for future use\n+    /// in [`Self::from_exposed_addr`].\n+    fn expose_addr(self) -> Self::Usize;\n+\n+    /// Convert an address back to a pointer, picking up a previously \"exposed\" provenance.\n+    ///\n+    /// Equivalent to calling [`core::ptr::from_exposed_addr_mut`] on each lane.\n+    fn from_exposed_addr(addr: Self::Usize) -> Self;\n+\n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    ///\n+    /// Equivalent to calling [`pointer::wrapping_offset`] on each lane.\n+    fn wrapping_offset(self, offset: Self::Isize) -> Self;\n+\n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    ///\n+    /// Equivalent to calling [`pointer::wrapping_add`] on each lane.\n+    fn wrapping_add(self, count: Self::Usize) -> Self;\n+\n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    ///\n+    /// Equivalent to calling [`pointer::wrapping_sub`] on each lane.\n+    fn wrapping_sub(self, count: Self::Usize) -> Self;\n+}\n+\n+impl<T, const LANES: usize> Sealed for Simd<*mut T, LANES> where LaneCount<LANES>: SupportedLaneCount\n+{}\n+\n+impl<T, const LANES: usize> SimdMutPtr for Simd<*mut T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Usize = Simd<usize, LANES>;\n+    type Isize = Simd<isize, LANES>;\n+    type ConstPtr = Simd<*const T, LANES>;\n+    type Mask = Mask<isize, LANES>;\n+\n+    #[inline]\n+    fn is_null(self) -> Self::Mask {\n+        Simd::splat(core::ptr::null_mut()).simd_eq(self)\n+    }\n+\n+    #[inline]\n+    fn as_const(self) -> Self::ConstPtr {\n+        self.cast_ptr()\n+    }\n+\n+    #[inline]\n+    fn addr(self) -> Self::Usize {\n+        // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n+        // provenance).\n+        unsafe { core::mem::transmute_copy(&self) }\n+    }\n+\n+    #[inline]\n+    fn with_addr(self, addr: Self::Usize) -> Self {\n+        // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+        //\n+        // In the mean-time, this operation is defined to be \"as if\" it was\n+        // a wrapping_offset, so we can emulate it as such. This should properly\n+        // restore pointer provenance even under today's compiler.\n+        self.cast_ptr::<*mut u8>()\n+            .wrapping_offset(addr.cast::<isize>() - self.addr().cast::<isize>())\n+            .cast_ptr()\n+    }\n+\n+    #[inline]\n+    fn expose_addr(self) -> Self::Usize {\n+        // Safety: `self` is a pointer vector\n+        unsafe { intrinsics::simd_expose_addr(self) }\n+    }\n+\n+    #[inline]\n+    fn from_exposed_addr(addr: Self::Usize) -> Self {\n+        // Safety: `self` is a pointer vector\n+        unsafe { intrinsics::simd_from_exposed_addr(addr) }\n+    }\n+\n+    #[inline]\n+    fn wrapping_offset(self, count: Self::Isize) -> Self {\n+        // Safety: simd_arith_offset takes a vector of pointers and a vector of offsets\n+        unsafe { intrinsics::simd_arith_offset(self, count) }\n+    }\n+\n+    #[inline]\n+    fn wrapping_add(self, count: Self::Usize) -> Self {\n+        self.wrapping_offset(count.cast())\n+    }\n+\n+    #[inline]\n+    fn wrapping_sub(self, count: Self::Usize) -> Self {\n+        self.wrapping_offset(-count.cast::<isize>())\n+    }\n+}"}, {"sha": "80763c07272781d7e370fa788249e0b26382dded", "filename": "crates/core_simd/src/eq.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/87779aef0bae771658ebd31336d918e575a05730/crates%2Fcore_simd%2Fsrc%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87779aef0bae771658ebd31336d918e575a05730/crates%2Fcore_simd%2Fsrc%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Feq.rs?ref=87779aef0bae771658ebd31336d918e575a05730", "patch": "@@ -1,4 +1,6 @@\n-use crate::simd::{intrinsics, LaneCount, Mask, Simd, SimdElement, SupportedLaneCount};\n+use crate::simd::{\n+    intrinsics, LaneCount, Mask, Simd, SimdConstPtr, SimdElement, SimdMutPtr, SupportedLaneCount,\n+};\n \n /// Parallel `PartialEq`.\n pub trait SimdPartialEq {\n@@ -71,3 +73,37 @@ macro_rules! impl_mask {\n }\n \n impl_mask! { i8, i16, i32, i64, isize }\n+\n+impl<T, const LANES: usize> SimdPartialEq for Simd<*const T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Mask = Mask<isize, LANES>;\n+\n+    #[inline]\n+    fn simd_eq(self, other: Self) -> Self::Mask {\n+        self.addr().simd_eq(other.addr())\n+    }\n+\n+    #[inline]\n+    fn simd_ne(self, other: Self) -> Self::Mask {\n+        self.addr().simd_ne(other.addr())\n+    }\n+}\n+\n+impl<T, const LANES: usize> SimdPartialEq for Simd<*mut T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Mask = Mask<isize, LANES>;\n+\n+    #[inline]\n+    fn simd_eq(self, other: Self) -> Self::Mask {\n+        self.addr().simd_eq(other.addr())\n+    }\n+\n+    #[inline]\n+    fn simd_ne(self, other: Self) -> Self::Mask {\n+        self.addr().simd_ne(other.addr())\n+    }\n+}"}, {"sha": "d5466822b93c6b191badcd23a94ceba14796e73f", "filename": "crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/87779aef0bae771658ebd31336d918e575a05730/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87779aef0bae771658ebd31336d918e575a05730/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=87779aef0bae771658ebd31336d918e575a05730", "patch": "@@ -61,9 +61,6 @@ extern \"platform-intrinsic\" {\n     /// xor\n     pub(crate) fn simd_xor<T>(x: T, y: T) -> T;\n \n-    /// getelementptr (without inbounds)\n-    pub(crate) fn simd_arith_offset<T, U>(ptrs: T, offsets: U) -> T;\n-\n     /// fptoui/fptosi/uitofp/sitofp\n     /// casting floats to integers is truncating, so it is safe to convert values like e.g. 1.5\n     /// but the truncated value must fit in the target type or the result is poison.\n@@ -151,4 +148,17 @@ extern \"platform-intrinsic\" {\n     pub(crate) fn simd_select<M, T>(m: M, yes: T, no: T) -> T;\n     #[allow(unused)]\n     pub(crate) fn simd_select_bitmask<M, T>(m: M, yes: T, no: T) -> T;\n+\n+    /// getelementptr (without inbounds)\n+    /// equivalent to wrapping_offset\n+    pub(crate) fn simd_arith_offset<T, U>(ptr: T, offset: U) -> T;\n+\n+    /// equivalent to `T as U` semantics, specifically for pointers\n+    pub(crate) fn simd_cast_ptr<T, U>(ptr: T) -> U;\n+\n+    /// expose a pointer as an address\n+    pub(crate) fn simd_expose_addr<T, U>(ptr: T) -> U;\n+\n+    /// convert an exposed address back to a pointer\n+    pub(crate) fn simd_from_exposed_addr<T, U>(addr: T) -> U;\n }"}, {"sha": "828731629692cdf1dfb1845db8c41e7cb9698ea8", "filename": "crates/core_simd/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87779aef0bae771658ebd31336d918e575a05730/crates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87779aef0bae771658ebd31336d918e575a05730/crates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flib.rs?ref=87779aef0bae771658ebd31336d918e575a05730", "patch": "@@ -7,7 +7,9 @@\n     repr_simd,\n     simd_ffi,\n     staged_api,\n-    stdsimd\n+    stdsimd,\n+    strict_provenance,\n+    ptr_metadata\n )]\n #![cfg_attr(feature = \"generic_const_exprs\", feature(generic_const_exprs))]\n #![cfg_attr(feature = \"generic_const_exprs\", allow(incomplete_features))]"}, {"sha": "ece026a448b73e521bbf59dc99c506849a7c4cf0", "filename": "crates/core_simd/src/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87779aef0bae771658ebd31336d918e575a05730/crates%2Fcore_simd%2Fsrc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87779aef0bae771658ebd31336d918e575a05730/crates%2Fcore_simd%2Fsrc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmod.rs?ref=87779aef0bae771658ebd31336d918e575a05730", "patch": "@@ -7,6 +7,7 @@ pub(crate) mod intrinsics;\n mod to_bytes;\n \n mod alias;\n+mod cast;\n mod elements;\n mod eq;\n mod fmt;\n@@ -24,6 +25,7 @@ pub mod simd {\n     pub(crate) use crate::core_simd::intrinsics;\n \n     pub use crate::core_simd::alias::*;\n+    pub use crate::core_simd::cast::*;\n     pub use crate::core_simd::elements::*;\n     pub use crate::core_simd::eq::*;\n     pub use crate::core_simd::lane_count::{LaneCount, SupportedLaneCount};"}, {"sha": "1ae9cd061fb2d23f731655bfc82e736cdbe20ec9", "filename": "crates/core_simd/src/ord.rs", "status": "modified", "additions": 101, "deletions": 1, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/87779aef0bae771658ebd31336d918e575a05730/crates%2Fcore_simd%2Fsrc%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87779aef0bae771658ebd31336d918e575a05730/crates%2Fcore_simd%2Fsrc%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Ford.rs?ref=87779aef0bae771658ebd31336d918e575a05730", "patch": "@@ -1,4 +1,6 @@\n-use crate::simd::{intrinsics, LaneCount, Mask, Simd, SimdPartialEq, SupportedLaneCount};\n+use crate::simd::{\n+    intrinsics, LaneCount, Mask, Simd, SimdConstPtr, SimdMutPtr, SimdPartialEq, SupportedLaneCount,\n+};\n \n /// Parallel `PartialOrd`.\n pub trait SimdPartialOrd: SimdPartialEq {\n@@ -211,3 +213,101 @@ macro_rules! impl_mask {\n }\n \n impl_mask! { i8, i16, i32, i64, isize }\n+\n+impl<T, const LANES: usize> SimdPartialOrd for Simd<*const T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn simd_lt(self, other: Self) -> Self::Mask {\n+        self.addr().simd_lt(other.addr())\n+    }\n+\n+    #[inline]\n+    fn simd_le(self, other: Self) -> Self::Mask {\n+        self.addr().simd_le(other.addr())\n+    }\n+\n+    #[inline]\n+    fn simd_gt(self, other: Self) -> Self::Mask {\n+        self.addr().simd_gt(other.addr())\n+    }\n+\n+    #[inline]\n+    fn simd_ge(self, other: Self) -> Self::Mask {\n+        self.addr().simd_ge(other.addr())\n+    }\n+}\n+\n+impl<T, const LANES: usize> SimdOrd for Simd<*const T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn simd_max(self, other: Self) -> Self {\n+        self.simd_lt(other).select(other, self)\n+    }\n+\n+    #[inline]\n+    fn simd_min(self, other: Self) -> Self {\n+        self.simd_gt(other).select(other, self)\n+    }\n+\n+    #[inline]\n+    fn simd_clamp(self, min: Self, max: Self) -> Self {\n+        assert!(\n+            min.simd_le(max).all(),\n+            \"each lane in `min` must be less than or equal to the corresponding lane in `max`\",\n+        );\n+        self.simd_max(min).simd_min(max)\n+    }\n+}\n+\n+impl<T, const LANES: usize> SimdPartialOrd for Simd<*mut T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn simd_lt(self, other: Self) -> Self::Mask {\n+        self.addr().simd_lt(other.addr())\n+    }\n+\n+    #[inline]\n+    fn simd_le(self, other: Self) -> Self::Mask {\n+        self.addr().simd_le(other.addr())\n+    }\n+\n+    #[inline]\n+    fn simd_gt(self, other: Self) -> Self::Mask {\n+        self.addr().simd_gt(other.addr())\n+    }\n+\n+    #[inline]\n+    fn simd_ge(self, other: Self) -> Self::Mask {\n+        self.addr().simd_ge(other.addr())\n+    }\n+}\n+\n+impl<T, const LANES: usize> SimdOrd for Simd<*mut T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn simd_max(self, other: Self) -> Self {\n+        self.simd_lt(other).select(other, self)\n+    }\n+\n+    #[inline]\n+    fn simd_min(self, other: Self) -> Self {\n+        self.simd_gt(other).select(other, self)\n+    }\n+\n+    #[inline]\n+    fn simd_clamp(self, min: Self, max: Self) -> Self {\n+        assert!(\n+            min.simd_le(max).all(),\n+            \"each lane in `min` must be less than or equal to the corresponding lane in `max`\",\n+        );\n+        self.simd_max(min).simd_min(max)\n+    }\n+}"}, {"sha": "c5d68f1b921f2a91e79ea301a79bbbd39a0eeb13", "filename": "crates/core_simd/src/vector.rs", "status": "modified", "additions": 48, "deletions": 12, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/87779aef0bae771658ebd31336d918e575a05730/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87779aef0bae771658ebd31336d918e575a05730/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=87779aef0bae771658ebd31336d918e575a05730", "patch": "@@ -1,8 +1,6 @@\n-// Vectors of pointers are not for public use at the current time.\n-pub(crate) mod ptr;\n-\n use crate::simd::{\n-    intrinsics, LaneCount, Mask, MaskElement, SimdPartialOrd, SupportedLaneCount, Swizzle,\n+    intrinsics, LaneCount, Mask, MaskElement, SimdCast, SimdCastPtr, SimdConstPtr, SimdMutPtr,\n+    SimdPartialOrd, SupportedLaneCount, Swizzle,\n };\n \n /// A SIMD vector of `LANES` elements of type `T`. `Simd<T, N>` has the same shape as [`[T; N]`](array), but operates like `T`.\n@@ -211,11 +209,26 @@ where\n     #[must_use]\n     #[inline]\n     #[cfg(not(bootstrap))]\n-    pub fn cast<U: SimdElement>(self) -> Simd<U, LANES> {\n-        // Safety: The input argument is a vector of a valid SIMD element type.\n+    pub fn cast<U: SimdCast>(self) -> Simd<U, LANES>\n+    where\n+        T: SimdCast,\n+    {\n+        // Safety: supported types are guaranteed by SimdCast\n         unsafe { intrinsics::simd_as(self) }\n     }\n \n+    /// Lanewise casts pointers to another pointer type.\n+    #[must_use]\n+    #[inline]\n+    pub fn cast_ptr<U>(self) -> Simd<U, LANES>\n+    where\n+        T: SimdCastPtr<U>,\n+        U: SimdElement,\n+    {\n+        // Safety: supported types are guaranteed by SimdCastPtr\n+        unsafe { intrinsics::simd_cast_ptr(self) }\n+    }\n+\n     /// Rounds toward zero and converts to the same-width integer type, assuming that\n     /// the value is finite and fits in that type.\n     ///\n@@ -234,11 +247,10 @@ where\n     #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub unsafe fn to_int_unchecked<I>(self) -> Simd<I, LANES>\n     where\n-        T: core::convert::FloatToInt<I>,\n-        I: SimdElement,\n+        T: core::convert::FloatToInt<I> + SimdCast,\n+        I: SimdCast,\n     {\n-        // Safety: `self` is a vector, and `FloatToInt` ensures the type can be casted to\n-        // an integer.\n+        // Safety: supported types are guaranteed by SimdCast, the caller is responsible for the extra invariants\n         unsafe { intrinsics::simd_cast(self) }\n     }\n \n@@ -349,7 +361,7 @@ where\n         idxs: Simd<usize, LANES>,\n         or: Self,\n     ) -> Self {\n-        let base_ptr = crate::simd::ptr::SimdConstPtr::splat(slice.as_ptr());\n+        let base_ptr = Simd::<*const T, LANES>::splat(slice.as_ptr());\n         // Ferris forgive me, I have done pointer arithmetic here.\n         let ptrs = base_ptr.wrapping_add(idxs);\n         // Safety: The ptrs have been bounds-masked to prevent memory-unsafe reads insha'allah\n@@ -457,7 +469,7 @@ where\n         // 3. &mut [T] which will become our base ptr.\n         unsafe {\n             // Now Entering \u2622\ufe0f *mut T Zone\n-            let base_ptr = crate::simd::ptr::SimdMutPtr::splat(slice.as_mut_ptr());\n+            let base_ptr = Simd::<*mut T, LANES>::splat(slice.as_mut_ptr());\n             // Ferris forgive me, I have done pointer arithmetic here.\n             let ptrs = base_ptr.wrapping_add(idxs);\n             // The ptrs have been bounds-masked to prevent memory-unsafe writes insha'allah\n@@ -739,3 +751,27 @@ impl Sealed for f64 {}\n unsafe impl SimdElement for f64 {\n     type Mask = i64;\n }\n+\n+impl<T> Sealed for *const T {}\n+\n+// Safety: (thin) const pointers are valid SIMD element types, and are supported by this API\n+//\n+// Fat pointers may be supported in the future.\n+unsafe impl<T> SimdElement for *const T\n+where\n+    T: core::ptr::Pointee<Metadata = ()>,\n+{\n+    type Mask = isize;\n+}\n+\n+impl<T> Sealed for *mut T {}\n+\n+// Safety: (thin) mut pointers are valid SIMD element types, and are supported by this API\n+//\n+// Fat pointers may be supported in the future.\n+unsafe impl<T> SimdElement for *mut T\n+where\n+    T: core::ptr::Pointee<Metadata = ()>,\n+{\n+    type Mask = isize;\n+}"}, {"sha": "fa756344db91ae3d57b1096848849fe957e18345", "filename": "crates/core_simd/src/vector/ptr.rs", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7c80b6967ace2b669dc921e67d637c0d546318a9/crates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c80b6967ace2b669dc921e67d637c0d546318a9/crates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs?ref=7c80b6967ace2b669dc921e67d637c0d546318a9", "patch": "@@ -1,51 +0,0 @@\n-//! Private implementation details of public gather/scatter APIs.\n-use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n-\n-/// A vector of *const T.\n-#[derive(Debug, Copy, Clone)]\n-#[repr(simd)]\n-pub(crate) struct SimdConstPtr<T, const LANES: usize>([*const T; LANES]);\n-\n-impl<T, const LANES: usize> SimdConstPtr<T, LANES>\n-where\n-    LaneCount<LANES>: SupportedLaneCount,\n-    T: Sized,\n-{\n-    #[inline]\n-    #[must_use]\n-    pub fn splat(ptr: *const T) -> Self {\n-        Self([ptr; LANES])\n-    }\n-\n-    #[inline]\n-    #[must_use]\n-    pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n-        // Safety: this intrinsic doesn't have a precondition\n-        unsafe { intrinsics::simd_arith_offset(self, addend) }\n-    }\n-}\n-\n-/// A vector of *mut T. Be very careful around potential aliasing.\n-#[derive(Debug, Copy, Clone)]\n-#[repr(simd)]\n-pub(crate) struct SimdMutPtr<T, const LANES: usize>([*mut T; LANES]);\n-\n-impl<T, const LANES: usize> SimdMutPtr<T, LANES>\n-where\n-    LaneCount<LANES>: SupportedLaneCount,\n-    T: Sized,\n-{\n-    #[inline]\n-    #[must_use]\n-    pub fn splat(ptr: *mut T) -> Self {\n-        Self([ptr; LANES])\n-    }\n-\n-    #[inline]\n-    #[must_use]\n-    pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n-        // Safety: this intrinsic doesn't have a precondition\n-        unsafe { intrinsics::simd_arith_offset(self, addend) }\n-    }\n-}"}, {"sha": "8eb0bd84042bdaaf6ce6734724309111b929d2bb", "filename": "crates/core_simd/tests/pointers.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/87779aef0bae771658ebd31336d918e575a05730/crates%2Fcore_simd%2Ftests%2Fpointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87779aef0bae771658ebd31336d918e575a05730/crates%2Fcore_simd%2Ftests%2Fpointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fpointers.rs?ref=87779aef0bae771658ebd31336d918e575a05730", "patch": "@@ -0,0 +1,59 @@\n+#![feature(portable_simd, strict_provenance)]\n+\n+use core_simd::{Simd, SimdConstPtr, SimdMutPtr};\n+\n+macro_rules! common_tests {\n+    { $constness:ident } => {\n+        test_helpers::test_lanes! {\n+            fn is_null<const LANES: usize>() {\n+                test_helpers::test_unary_mask_elementwise(\n+                    &Simd::<*$constness u32, LANES>::is_null,\n+                    &<*$constness u32>::is_null,\n+                    &|_| true,\n+                );\n+            }\n+\n+            fn addr<const LANES: usize>() {\n+                test_helpers::test_unary_elementwise(\n+                    &Simd::<*$constness u32, LANES>::addr,\n+                    &<*$constness u32>::addr,\n+                    &|_| true,\n+                );\n+            }\n+\n+            fn wrapping_offset<const LANES: usize>() {\n+                test_helpers::test_binary_elementwise(\n+                    &Simd::<*$constness u32, LANES>::wrapping_offset,\n+                    &<*$constness u32>::wrapping_offset,\n+                    &|_, _| true,\n+                );\n+            }\n+\n+            fn wrapping_add<const LANES: usize>() {\n+                test_helpers::test_binary_elementwise(\n+                    &Simd::<*$constness u32, LANES>::wrapping_add,\n+                    &<*$constness u32>::wrapping_add,\n+                    &|_, _| true,\n+                );\n+            }\n+\n+            fn wrapping_sub<const LANES: usize>() {\n+                test_helpers::test_binary_elementwise(\n+                    &Simd::<*$constness u32, LANES>::wrapping_sub,\n+                    &<*$constness u32>::wrapping_sub,\n+                    &|_, _| true,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+mod const_ptr {\n+    use super::*;\n+    common_tests! { const }\n+}\n+\n+mod mut_ptr {\n+    use super::*;\n+    common_tests! { mut }\n+}"}, {"sha": "7d91260d838a63b6be90f19e0e1de9d0e45d3eb0", "filename": "crates/test_helpers/src/biteq.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/87779aef0bae771658ebd31336d918e575a05730/crates%2Ftest_helpers%2Fsrc%2Fbiteq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87779aef0bae771658ebd31336d918e575a05730/crates%2Ftest_helpers%2Fsrc%2Fbiteq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Fbiteq.rs?ref=87779aef0bae771658ebd31336d918e575a05730", "patch": "@@ -55,6 +55,26 @@ macro_rules! impl_float_biteq {\n \n impl_float_biteq! { f32, f64 }\n \n+impl<T> BitEq for *const T {\n+    fn biteq(&self, other: &Self) -> bool {\n+        self == other\n+    }\n+\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        write!(f, \"{:?}\", self)\n+    }\n+}\n+\n+impl<T> BitEq for *mut T {\n+    fn biteq(&self, other: &Self) -> bool {\n+        self == other\n+    }\n+\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        write!(f, \"{:?}\", self)\n+    }\n+}\n+\n impl<T: BitEq, const N: usize> BitEq for [T; N] {\n     fn biteq(&self, other: &Self) -> bool {\n         self.iter()"}, {"sha": "5f2a928b5e4bb29bb526231eef6cbf29c3155dd5", "filename": "crates/test_helpers/src/lib.rs", "status": "modified", "additions": 43, "deletions": 20, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/87779aef0bae771658ebd31336d918e575a05730/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87779aef0bae771658ebd31336d918e575a05730/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Flib.rs?ref=87779aef0bae771658ebd31336d918e575a05730", "patch": "@@ -38,6 +38,28 @@ impl_num! { usize }\n impl_num! { f32 }\n impl_num! { f64 }\n \n+impl<T> DefaultStrategy for *const T {\n+    type Strategy = proptest::strategy::Map<proptest::num::isize::Any, fn(isize) -> *const T>;\n+    fn default_strategy() -> Self::Strategy {\n+        fn map<T>(x: isize) -> *const T {\n+            x as _\n+        }\n+        use proptest::strategy::Strategy;\n+        proptest::num::isize::ANY.prop_map(map)\n+    }\n+}\n+\n+impl<T> DefaultStrategy for *mut T {\n+    type Strategy = proptest::strategy::Map<proptest::num::isize::Any, fn(isize) -> *mut T>;\n+    fn default_strategy() -> Self::Strategy {\n+        fn map<T>(x: isize) -> *mut T {\n+            x as _\n+        }\n+        use proptest::strategy::Strategy;\n+        proptest::num::isize::ANY.prop_map(map)\n+    }\n+}\n+\n #[cfg(not(target_arch = \"wasm32\"))]\n impl DefaultStrategy for u128 {\n     type Strategy = proptest::num::u128::Any;\n@@ -135,21 +157,21 @@ pub fn test_unary_elementwise<Scalar, ScalarResult, Vector, VectorResult, const\n     fs: &dyn Fn(Scalar) -> ScalarResult,\n     check: &dyn Fn([Scalar; LANES]) -> bool,\n ) where\n-    Scalar: Copy + Default + core::fmt::Debug + DefaultStrategy,\n-    ScalarResult: Copy + Default + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n+    Scalar: Copy + core::fmt::Debug + DefaultStrategy,\n+    ScalarResult: Copy + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n     Vector: Into<[Scalar; LANES]> + From<[Scalar; LANES]> + Copy,\n     VectorResult: Into<[ScalarResult; LANES]> + From<[ScalarResult; LANES]> + Copy,\n {\n     test_1(&|x: [Scalar; LANES]| {\n         proptest::prop_assume!(check(x));\n         let result_1: [ScalarResult; LANES] = fv(x.into()).into();\n-        let result_2: [ScalarResult; LANES] = {\n-            let mut result = [ScalarResult::default(); LANES];\n-            for (i, o) in x.iter().zip(result.iter_mut()) {\n-                *o = fs(*i);\n-            }\n-            result\n-        };\n+        let result_2: [ScalarResult; LANES] = x\n+            .iter()\n+            .copied()\n+            .map(fs)\n+            .collect::<Vec<_>>()\n+            .try_into()\n+            .unwrap();\n         crate::prop_assert_biteq!(result_1, result_2);\n         Ok(())\n     });\n@@ -162,7 +184,7 @@ pub fn test_unary_mask_elementwise<Scalar, Vector, Mask, const LANES: usize>(\n     fs: &dyn Fn(Scalar) -> bool,\n     check: &dyn Fn([Scalar; LANES]) -> bool,\n ) where\n-    Scalar: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    Scalar: Copy + core::fmt::Debug + DefaultStrategy,\n     Vector: Into<[Scalar; LANES]> + From<[Scalar; LANES]> + Copy,\n     Mask: Into<[bool; LANES]> + From<[bool; LANES]> + Copy,\n {\n@@ -196,23 +218,24 @@ pub fn test_binary_elementwise<\n     fs: &dyn Fn(Scalar1, Scalar2) -> ScalarResult,\n     check: &dyn Fn([Scalar1; LANES], [Scalar2; LANES]) -> bool,\n ) where\n-    Scalar1: Copy + Default + core::fmt::Debug + DefaultStrategy,\n-    Scalar2: Copy + Default + core::fmt::Debug + DefaultStrategy,\n-    ScalarResult: Copy + Default + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n+    Scalar1: Copy + core::fmt::Debug + DefaultStrategy,\n+    Scalar2: Copy + core::fmt::Debug + DefaultStrategy,\n+    ScalarResult: Copy + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n     Vector1: Into<[Scalar1; LANES]> + From<[Scalar1; LANES]> + Copy,\n     Vector2: Into<[Scalar2; LANES]> + From<[Scalar2; LANES]> + Copy,\n     VectorResult: Into<[ScalarResult; LANES]> + From<[ScalarResult; LANES]> + Copy,\n {\n     test_2(&|x: [Scalar1; LANES], y: [Scalar2; LANES]| {\n         proptest::prop_assume!(check(x, y));\n         let result_1: [ScalarResult; LANES] = fv(x.into(), y.into()).into();\n-        let result_2: [ScalarResult; LANES] = {\n-            let mut result = [ScalarResult::default(); LANES];\n-            for ((i1, i2), o) in x.iter().zip(y.iter()).zip(result.iter_mut()) {\n-                *o = fs(*i1, *i2);\n-            }\n-            result\n-        };\n+        let result_2: [ScalarResult; LANES] = x\n+            .iter()\n+            .copied()\n+            .zip(y.iter().copied())\n+            .map(|(x, y)| fs(x, y))\n+            .collect::<Vec<_>>()\n+            .try_into()\n+            .unwrap();\n         crate::prop_assert_biteq!(result_1, result_2);\n         Ok(())\n     });"}]}