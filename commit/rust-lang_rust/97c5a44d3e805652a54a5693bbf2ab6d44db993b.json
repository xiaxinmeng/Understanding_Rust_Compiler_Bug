{"sha": "97c5a44d3e805652a54a5693bbf2ab6d44db993b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3YzVhNDRkM2U4MDU2NTJhNTRhNTY5M2JiZjJhYjZkNDRkYjk5M2I=", "commit": {"author": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-07-06T00:47:42Z"}, "committer": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-07-07T10:51:09Z"}, "message": "De-share trait_ref\n\nAlso, makes the pretty-printer use & instead of @ as much as possible,\nwhich will help with later changes, though in the interim has produced\nsome... interesting constructs.", "tree": {"sha": "d80edf6d0f724bcb435200078501f2564bd9f5f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d80edf6d0f724bcb435200078501f2564bd9f5f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97c5a44d3e805652a54a5693bbf2ab6d44db993b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97c5a44d3e805652a54a5693bbf2ab6d44db993b", "html_url": "https://github.com/rust-lang/rust/commit/97c5a44d3e805652a54a5693bbf2ab6d44db993b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97c5a44d3e805652a54a5693bbf2ab6d44db993b/comments", "author": null, "committer": null, "parents": [{"sha": "62c83bb17be9a47799d702a9470aa7a84012c782", "url": "https://api.github.com/repos/rust-lang/rust/commits/62c83bb17be9a47799d702a9470aa7a84012c782", "html_url": "https://github.com/rust-lang/rust/commit/62c83bb17be9a47799d702a9470aa7a84012c782"}], "stats": {"total": 255, "additions": 128, "deletions": 127}, "files": [{"sha": "0f71eeff5a2f15fbd406e2aae378a46f9b110058", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=97c5a44d3e805652a54a5693bbf2ab6d44db993b", "patch": "@@ -98,10 +98,10 @@ fn fold_foreign_mod(\n fn fold_item_underscore(cx: @Context, item: &ast::item_,\n                         fld: @fold::ast_fold) -> ast::item_ {\n     let item = match *item {\n-        ast::item_impl(ref a, b, c, ref methods) => {\n+        ast::item_impl(ref a, ref b, c, ref methods) => {\n             let methods = methods.iter().filter(|m| method_in_cfg(cx, **m))\n                 .transform(|x| *x).collect();\n-            ast::item_impl(/*bad*/ copy *a, b, c, methods)\n+            ast::item_impl(/*bad*/ copy *a, /*bad*/ copy *b, c, methods)\n         }\n         ast::item_trait(ref a, ref b, ref methods) => {\n             let methods = methods.iter().filter(|m| trait_method_in_cfg(cx, *m) )"}, {"sha": "1e508d0813184559f93a99f343ae493495e0be7d", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=97c5a44d3e805652a54a5693bbf2ab6d44db993b", "patch": "@@ -1141,7 +1141,7 @@ fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: &str,\n \n     let r = get_attributes(md);\n     for r.iter().advance |attr| {\n-        out.write_str(fmt!(\"%s\\n\", pprust::attribute_to_str(*attr, intr)));\n+        out.write_str(fmt!(\"%s\\n\", pprust::attribute_to_str(attr, intr)));\n     }\n \n     out.write_str(\"\\n\\n\");"}, {"sha": "9b4c39b3fc78c40d1ac060a00bd80f4470c08d1c", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=97c5a44d3e805652a54a5693bbf2ab6d44db993b", "patch": "@@ -1003,7 +1003,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                         index);\n         }\n       }\n-      item_impl(ref generics, opt_trait, ty, ref methods) => {\n+      item_impl(ref generics, ref opt_trait, ty, ref methods) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));"}, {"sha": "0c493fe9e81c90bccf69d00de6d5064968cc1de6", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=97c5a44d3e805652a54a5693bbf2ab6d44db993b", "patch": "@@ -117,7 +117,7 @@ fn check_item(item: @item, (cx, visitor): (Context, visit::vt<Context>)) {\n     // If this is a destructor, check kinds.\n     if !attrs_contains_name(item.attrs, \"unsafe_destructor\") {\n         match item.node {\n-            item_impl(_, Some(trait_ref), self_type, _) => {\n+            item_impl(_, Some(ref trait_ref), self_type, _) => {\n                 match cx.tcx.def_map.find(&trait_ref.ref_id) {\n                     None => cx.tcx.sess.bug(\"trait ref not in def map!\"),\n                     Some(&trait_def) => {"}, {"sha": "70833813cc0877f7cef8669dcf1367b1cc50759a", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=97c5a44d3e805652a54a5693bbf2ab6d44db993b", "patch": "@@ -141,7 +141,7 @@ impl ReachableContext {\n                             }\n                         }\n                     }\n-                    item_impl(ref generics, trait_ref, _, ref methods) => {\n+                    item_impl(ref generics, ref trait_ref, _, ref methods) => {\n                         // XXX(pcwalton): We conservatively assume any methods\n                         // on a trait implementation are reachable, when this\n                         // is not the case. We could be more precise by only"}, {"sha": "3b90d72deb12d80fef4df00d6e6b9f8be8216d48", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=97c5a44d3e805652a54a5693bbf2ab6d44db993b", "patch": "@@ -3533,7 +3533,7 @@ impl Resolver {\n             }\n \n             item_impl(ref generics,\n-                      implemented_traits,\n+                      ref implemented_traits,\n                       self_type,\n                       ref methods) => {\n                 self.resolve_implementation(item.id,\n@@ -3811,7 +3811,7 @@ impl Resolver {\n                                         type_parameter_bound: &TyParamBound,\n                                         visitor: ResolveVisitor) {\n         match *type_parameter_bound {\n-            TraitTyParamBound(tref) => {\n+            TraitTyParamBound(ref tref) => {\n                 self.resolve_trait_reference(tref, visitor, TraitBoundingTypeParameter)\n             }\n             RegionTyParamBound => {}\n@@ -3913,7 +3913,7 @@ impl Resolver {\n     pub fn resolve_implementation(@mut self,\n                                   id: node_id,\n                                   generics: &Generics,\n-                                  opt_trait_reference: Option<@trait_ref>,\n+                                  opt_trait_reference: &Option<trait_ref>,\n                                   self_type: @Ty,\n                                   methods: &[@method],\n                                   visitor: ResolveVisitor) {\n@@ -3929,7 +3929,7 @@ impl Resolver {\n             // Resolve the trait reference, if necessary.\n             let original_trait_refs;\n             match opt_trait_reference {\n-                Some(trait_reference) => {\n+                &Some(ref trait_reference) => {\n                     self.resolve_trait_reference(trait_reference, visitor, TraitImplementation);\n \n                     // Record the current set of trait references.\n@@ -3944,7 +3944,7 @@ impl Resolver {\n                         &mut self.current_trait_refs,\n                         Some(new_trait_refs)));\n                 }\n-                None => {\n+                &None => {\n                     original_trait_refs = None;\n                 }\n             }"}, {"sha": "129208a9aa37eabc1210674ab5aa33959a377e4b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=97c5a44d3e805652a54a5693bbf2ab6d44db993b", "patch": "@@ -3624,12 +3624,12 @@ pub fn impl_trait_ref(cx: ctxt, id: ast::def_id) -> Option<@TraitRef> {\n             debug!(\"(impl_trait_ref) searching for trait impl %?\", id);\n             match cx.items.find(&id.node) {\n                 Some(&ast_map::node_item(@ast::item {\n-                                         node: ast::item_impl(_, opt_trait, _, _),\n+                                         node: ast::item_impl(_, ref opt_trait, _, _),\n                                          _},\n                                          _)) => {\n                     match opt_trait {\n-                        Some(t) => Some(ty::node_id_to_trait_ref(cx, t.ref_id)),\n-                        None => None\n+                        &Some(ref t) => Some(ty::node_id_to_trait_ref(cx, t.ref_id)),\n+                        &None => None\n                     }\n                 }\n                 _ => None"}, {"sha": "e224654f2d352f1713001d1c8e39148ae73d6b04", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=97c5a44d3e805652a54a5693bbf2ab6d44db993b", "patch": "@@ -764,7 +764,7 @@ fn conv_builtin_bounds(tcx: ty::ctxt, ast_bounds: &Option<OptVec<ast::TyParamBou\n             let mut builtin_bounds = ty::EmptyBuiltinBounds();\n             for bound_vec.iter().advance |ast_bound| {\n                 match *ast_bound {\n-                    ast::TraitTyParamBound(b) => {\n+                    ast::TraitTyParamBound(ref b) => {\n                         match lookup_def_tcx(tcx, b.path.span, b.ref_id) {\n                             ast::def_trait(trait_did) => {\n                                 if try_add_builtin_trait(tcx,"}, {"sha": "aef0e4b200b97bc4497a1560e2f55e20e803336b", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=97c5a44d3e805652a54a5693bbf2ab6d44db993b", "patch": "@@ -207,9 +207,11 @@ impl CoherenceChecker {\n //                       self.crate_context.tcx.sess.str_of(item.ident));\n \n                 match item.node {\n-                    item_impl(_, opt_trait, _, _) => {\n-                        self.check_implementation(item,\n-                                                  opt_trait.iter().transform(|&x| x).collect());\n+                    item_impl(_, ref opt_trait, _, _) => {\n+                        let opt_trait : ~[trait_ref] = opt_trait.iter()\n+                                                                .transform(|&x| x)\n+                                                                .collect();\n+                        self.check_implementation(item, opt_trait);\n                     }\n                     _ => {\n                         // Nothing to do.\n@@ -238,7 +240,7 @@ impl CoherenceChecker {\n \n     pub fn check_implementation(&self,\n                                 item: @item,\n-                                associated_traits: ~[@trait_ref]) {\n+                                associated_traits: &[trait_ref]) {\n         let tcx = self.crate_context.tcx;\n         let self_type = ty::lookup_item_type(tcx, local_def(item.id));\n \n@@ -646,7 +648,7 @@ impl CoherenceChecker {\n                                               a trait or new type instead\");\n                         }\n                     }\n-                    item_impl(_, Some(trait_ref), _, _) => {\n+                    item_impl(_, Some(ref trait_ref), _, _) => {\n                         // `for_ty` is `Type` in `impl Trait for Type`\n                         let for_ty =\n                             ty::node_id_to_type(self.crate_context.tcx,\n@@ -678,7 +680,7 @@ impl CoherenceChecker {\n         })));\n     }\n \n-    pub fn trait_ref_to_trait_def_id(&self, trait_ref: @trait_ref) -> def_id {\n+    pub fn trait_ref_to_trait_def_id(&self, trait_ref: &trait_ref) -> def_id {\n         let def_map = self.crate_context.tcx.def_map;\n         let trait_def = def_map.get_copy(&trait_ref.ref_id);\n         let trait_id = def_id_of_def(trait_def);\n@@ -805,7 +807,7 @@ impl CoherenceChecker {\n                 // Check that we have implementations of every trait method\n                 for trait_refs.iter().advance |trait_ref| {\n                     let trait_did =\n-                        self.trait_ref_to_trait_def_id(*trait_ref);\n+                        self.trait_ref_to_trait_def_id(trait_ref);\n                     self.please_check_that_trait_methods_are_implemented(\n                         &mut methods,\n                         trait_did,\n@@ -817,7 +819,7 @@ impl CoherenceChecker {\n                 // if a method of that name is not inherent to the\n                 // impl, use the provided definition in the trait.\n                 for trait_refs.iter().advance |trait_ref| {\n-                    let trait_did = self.trait_ref_to_trait_def_id(*trait_ref);\n+                    let trait_did = self.trait_ref_to_trait_def_id(trait_ref);\n                     self.add_provided_methods_to_impl(\n                         &mut methods,\n                         &trait_did,"}, {"sha": "60f97a0ae0a069122793a7ce36c5f0cb305a34ad", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=97c5a44d3e805652a54a5693bbf2ab6d44db993b", "patch": "@@ -378,15 +378,15 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n                           id: ast::node_id,\n                           sp: codemap::span,\n                           rp: Option<ty::region_variance>,\n-                          ast_trait_refs: &[@ast::trait_ref],\n+                          ast_trait_refs: &[ast::trait_ref],\n                           generics: &ast::Generics)\n {\n     let tcx = ccx.tcx;\n     if tcx.supertraits.contains_key(&local_def(id)) { return; }\n \n     let self_ty = ty::mk_self(ccx.tcx, local_def(id));\n     let mut ty_trait_refs: ~[@ty::TraitRef] = ~[];\n-    for ast_trait_refs.iter().advance |&ast_trait_ref| {\n+    for ast_trait_refs.iter().advance |ast_trait_ref| {\n         let trait_ref = instantiate_trait_ref(ccx, ast_trait_ref, rp,\n                                               generics, self_ty);\n \n@@ -441,7 +441,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n                 fmt!(\"method `%s` has a `%s` declaration in the impl, \\\n                       but not in the trait\",\n                      tcx.sess.str_of(trait_m.ident),\n-                     explicit_self_to_str(impl_m.explicit_self, tcx.sess.intr())));\n+                     explicit_self_to_str(&impl_m.explicit_self, tcx.sess.intr())));\n             return;\n         }\n         (_, &ast::sty_static) => {\n@@ -450,7 +450,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n                 fmt!(\"method `%s` has a `%s` declaration in the trait, \\\n                       but not in the impl\",\n                      tcx.sess.str_of(trait_m.ident),\n-                     explicit_self_to_str(trait_m.explicit_self, tcx.sess.intr())));\n+                     explicit_self_to_str(&trait_m.explicit_self, tcx.sess.intr())));\n             return;\n         }\n         _ => {\n@@ -813,7 +813,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n                                generics,\n                                rp);\n       }\n-      ast::item_impl(ref generics, opt_trait_ref, selfty, ref ms) => {\n+      ast::item_impl(ref generics, ref opt_trait_ref, selfty, ref ms) => {\n         let i_ty_generics = ty_generics(ccx, rp, generics, 0);\n         let region_parameterization =\n             RegionParameterization::from_variance_and_generics(rp, generics);\n@@ -839,7 +839,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n                                   &i_ty_generics, generics,\n                                   parent_visibility);\n         for opt_trait_ref.iter().advance |t| {\n-            check_methods_against_trait(ccx, generics, rp, selfty, *t, cms);\n+            check_methods_against_trait(ccx, generics, rp, selfty, t, cms);\n         }\n       }\n       ast::item_trait(ref generics, ref supertraits, ref trait_methods) => {\n@@ -1184,7 +1184,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n         };\n         for ast_bounds.iter().advance |ast_bound| {\n             match *ast_bound {\n-                TraitTyParamBound(b) => {\n+                TraitTyParamBound(ref b) => {\n                     let ty = ty::mk_param(ccx.tcx, param_ty.idx, param_ty.def_id);\n                     let trait_ref = instantiate_trait_ref(ccx, b, rp, generics, ty);\n                     if !astconv::try_add_builtin_trait("}, {"sha": "a222f03820fce63a63b126181acccc029c8e0c16", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=97c5a44d3e805652a54a5693bbf2ab6d44db993b", "patch": "@@ -132,7 +132,7 @@ pub static crate_node_id: node_id = 0;\n // the \"special\" built-in traits (see middle::lang_items) and\n // detects Copy, Send, Send, and Freeze.\n pub enum TyParamBound {\n-    TraitTyParamBound(@trait_ref),\n+    TraitTyParamBound(trait_ref),\n     RegionTyParamBound\n }\n \n@@ -1002,9 +1002,9 @@ pub enum item_ {\n     item_ty(@Ty, Generics),\n     item_enum(enum_def, Generics),\n     item_struct(@struct_def, Generics),\n-    item_trait(Generics, ~[@trait_ref], ~[trait_method]),\n+    item_trait(Generics, ~[trait_ref], ~[trait_method]),\n     item_impl(Generics,\n-              Option<@trait_ref>, // (optional) trait this impl implements\n+              Option<trait_ref>, // (optional) trait this impl implements\n               @Ty, // self\n               ~[@method]),\n     // a macro invocation (which includes macro definition)"}, {"sha": "565f181ab8598431549f5b66b704ebc9cb050c62", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=97c5a44d3e805652a54a5693bbf2ab6d44db993b", "patch": "@@ -580,7 +580,7 @@ pub fn view_path_id(p: &view_path) -> node_id {\n \n /// Returns true if the given struct def is tuple-like; i.e. that its fields\n /// are unnamed.\n-pub fn struct_def_is_tuple_like(struct_def: @ast::struct_def) -> bool {\n+pub fn struct_def_is_tuple_like(struct_def: &ast::struct_def) -> bool {\n     struct_def.ctor_id.is_some()\n }\n "}, {"sha": "68b011e4fd7a51764fad53e0d7e954b88fc5e9d8", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=97c5a44d3e805652a54a5693bbf2ab6d44db993b", "patch": "@@ -68,7 +68,7 @@ pub trait AstBuilder {\n \n     fn typaram(&self, id: ast::ident, bounds: @OptVec<ast::TyParamBound>) -> ast::TyParam;\n \n-    fn trait_ref(&self, path: ast::Path) -> @ast::trait_ref;\n+    fn trait_ref(&self, path: ast::Path) -> ast::trait_ref;\n     fn typarambound(&self, path: ast::Path) -> ast::TyParamBound;\n     fn lifetime(&self, span: span, ident: ast::ident) -> ast::Lifetime;\n \n@@ -358,8 +358,8 @@ impl AstBuilder for @ExtCtxt {\n         }\n     }\n \n-    fn trait_ref(&self, path: ast::Path) -> @ast::trait_ref {\n-        @ast::trait_ref {\n+    fn trait_ref(&self, path: ast::Path) -> ast::trait_ref {\n+        ast::trait_ref {\n             path: path,\n             ref_id: self.next_id()\n         }"}, {"sha": "9e6776363a82db7e1a91bebfc82d6c445eec3689", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=97c5a44d3e805652a54a5693bbf2ab6d44db993b", "patch": "@@ -26,7 +26,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt,\n     cx.print_backtrace();\n     io::stdout().write_line(\n         print::pprust::tt_to_str(\n-            ast::tt_delim(vec::to_owned(tt)),\n+            &ast::tt_delim(vec::to_owned(tt)),\n             get_ident_interner()));\n \n     //trivial expression"}, {"sha": "6de504c66fd88937313b3a364f3dd2bf164a6a85", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=97c5a44d3e805652a54a5693bbf2ab6d44db993b", "patch": "@@ -82,7 +82,7 @@ pub fn add_new_extension(cx: @ExtCtxt,\n             io::println(fmt!(\"%s! { %s }\",\n                              cx.str_of(name),\n                              print::pprust::tt_to_str(\n-                                 ast::tt_delim(vec::to_owned(arg)),\n+                                 &ast::tt_delim(vec::to_owned(arg)),\n                                  get_ident_interner())));\n         }\n "}, {"sha": "85eb499069bd5cee1715eb8fbcc5ebb772c117f3", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=97c5a44d3e805652a54a5693bbf2ab6d44db993b", "patch": "@@ -162,7 +162,7 @@ pub fn fold_fn_decl(decl: &ast::fn_decl, fld: @ast_fold) -> ast::fn_decl {\n \n fn fold_ty_param_bound(tpb: &TyParamBound, fld: @ast_fold) -> TyParamBound {\n     match *tpb {\n-        TraitTyParamBound(ty) => TraitTyParamBound(fold_trait_ref(ty, fld)),\n+        TraitTyParamBound(ref ty) => TraitTyParamBound(fold_trait_ref(ty, fld)),\n         RegionTyParamBound => RegionTyParamBound\n     }\n }\n@@ -296,10 +296,10 @@ pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n             let struct_def = fold_struct_def(*struct_def, fld);\n             item_struct(struct_def, /* FIXME (#2543) */ copy *generics)\n         }\n-        item_impl(ref generics, ifce, ty, ref methods) => {\n+        item_impl(ref generics, ref ifce, ty, ref methods) => {\n             item_impl(\n                 fold_generics(generics, fld),\n-                ifce.map(|p| fold_trait_ref(*p, fld)),\n+                ifce.map(|p| fold_trait_ref(p, fld)),\n                 fld.fold_ty(ty),\n                 methods.map(|x| fld.fold_method(*x))\n             )\n@@ -313,7 +313,7 @@ pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n             };\n             item_trait(\n                 fold_generics(generics, fld),\n-                traits.map(|p| fold_trait_ref(*p, fld)),\n+                traits.map(|p| fold_trait_ref(p, fld)),\n                 methods\n             )\n         }\n@@ -335,8 +335,8 @@ fn fold_struct_def(struct_def: @ast::struct_def, fld: @ast_fold)\n     }\n }\n \n-fn fold_trait_ref(p: @trait_ref, fld: @ast_fold) -> @trait_ref {\n-    @ast::trait_ref {\n+fn fold_trait_ref(p: &trait_ref, fld: @ast_fold) -> trait_ref {\n+    ast::trait_ref {\n         path: fld.fold_path(&p.path),\n         ref_id: fld.new_id(p.ref_id),\n     }"}, {"sha": "8f1bffdaa789eebc2194e208e35b6c303626d34d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=97c5a44d3e805652a54a5693bbf2ab6d44db993b", "patch": "@@ -3566,7 +3566,7 @@ impl Parser {\n             // New-style trait. Reinterpret the type as a trait.\n             let opt_trait_ref = match ty.node {\n                 ty_path(ref path, @None, node_id) => {\n-                    Some(@trait_ref {\n+                    Some(trait_ref {\n                         path: /* bad */ copy *path,\n                         ref_id: node_id\n                     })\n@@ -3608,15 +3608,15 @@ impl Parser {\n     }\n \n     // parse a::B<~str,int>\n-    fn parse_trait_ref(&self) -> @trait_ref {\n-        @ast::trait_ref {\n+    fn parse_trait_ref(&self) -> trait_ref {\n+        ast::trait_ref {\n             path: self.parse_path_with_tps(false),\n             ref_id: self.get_id(),\n         }\n     }\n \n     // parse B + C<~str,int> + D\n-    fn parse_trait_ref_list(&self, ket: &token::Token) -> ~[@trait_ref] {\n+    fn parse_trait_ref_list(&self, ket: &token::Token) -> ~[trait_ref] {\n         self.parse_seq_to_before_end(\n             ket,\n             seq_sep_trailing_disallowed(token::BINOP(token::PLUS)),"}, {"sha": "d90055caffb96396e6c8068ab2f7ed55b05a104a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 75, "deletions": 76, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=97c5a44d3e805652a54a5693bbf2ab6d44db993b", "patch": "@@ -34,9 +34,9 @@ use std::uint;\n // The @ps is stored here to prevent recursive type.\n pub enum ann_node<'self> {\n     node_block(@ps, &'self ast::blk),\n-    node_item(@ps, @ast::item),\n-    node_expr(@ps, @ast::expr),\n-    node_pat(@ps, @ast::pat),\n+    node_item(@ps, &'self ast::item),\n+    node_expr(@ps, &'self ast::expr),\n+    node_pat(@ps, &'self ast::pat),\n }\n pub struct pp_ann {\n     pre: @fn(ann_node),\n@@ -106,7 +106,7 @@ pub static default_columns: uint = 78u;\n pub fn print_crate(cm: @CodeMap,\n                    intr: @ident_interner,\n                    span_diagnostic: @diagnostic::span_handler,\n-                   crate: @ast::crate,\n+                   crate: &ast::crate,\n                    filename: @str,\n                    in: @io::Reader,\n                    out: @io::Writer,\n@@ -136,41 +136,41 @@ pub fn print_crate(cm: @CodeMap,\n     print_crate_(s, crate);\n }\n \n-pub fn print_crate_(s: @ps, crate: @ast::crate) {\n+pub fn print_crate_(s: @ps, crate: &ast::crate) {\n     print_mod(s, &crate.node.module, crate.node.attrs);\n     print_remaining_comments(s);\n     eof(s.s);\n }\n \n-pub fn ty_to_str(ty: @ast::Ty, intr: @ident_interner) -> ~str {\n+pub fn ty_to_str(ty: &ast::Ty, intr: @ident_interner) -> ~str {\n     to_str(ty, print_type, intr)\n }\n \n-pub fn pat_to_str(pat: @ast::pat, intr: @ident_interner) -> ~str {\n+pub fn pat_to_str(pat: &ast::pat, intr: @ident_interner) -> ~str {\n     to_str(pat, print_irrefutable_pat, intr)\n }\n \n-pub fn expr_to_str(e: @ast::expr, intr: @ident_interner) -> ~str {\n+pub fn expr_to_str(e: &ast::expr, intr: @ident_interner) -> ~str {\n     to_str(e, print_expr, intr)\n }\n \n pub fn lifetime_to_str(e: &ast::Lifetime, intr: @ident_interner) -> ~str {\n     to_str(e, print_lifetime, intr)\n }\n \n-pub fn tt_to_str(tt: ast::token_tree, intr: @ident_interner) -> ~str {\n-    to_str(&tt, print_tt, intr)\n+pub fn tt_to_str(tt: &ast::token_tree, intr: @ident_interner) -> ~str {\n+    to_str(tt, print_tt, intr)\n }\n \n pub fn tts_to_str(tts: &[ast::token_tree], intr: @ident_interner) -> ~str {\n-    to_str(tts, print_tts, intr)\n+    to_str(&tts, print_tts, intr)\n }\n \n pub fn stmt_to_str(s: &ast::stmt, intr: @ident_interner) -> ~str {\n     to_str(s, print_stmt, intr)\n }\n \n-pub fn item_to_str(i: @ast::item, intr: @ident_interner) -> ~str {\n+pub fn item_to_str(i: &ast::item, intr: @ident_interner) -> ~str {\n     to_str(i, print_item, intr)\n }\n \n@@ -208,11 +208,11 @@ pub fn block_to_str(blk: &ast::blk, intr: @ident_interner) -> ~str {\n     }\n }\n \n-pub fn meta_item_to_str(mi: @ast::meta_item, intr: @ident_interner) -> ~str {\n+pub fn meta_item_to_str(mi: &ast::meta_item, intr: @ident_interner) -> ~str {\n     to_str(mi, print_meta_item, intr)\n }\n \n-pub fn attribute_to_str(attr: ast::attribute, intr: @ident_interner) -> ~str {\n+pub fn attribute_to_str(attr: &ast::attribute, intr: @ident_interner) -> ~str {\n     to_str(attr, print_attribute, intr)\n }\n \n@@ -314,39 +314,38 @@ pub fn synth_comment(s: @ps, text: ~str) {\n     word(s.s, \"*/\");\n }\n \n-pub fn commasep<IN: Copy>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN)) {\n+pub fn commasep<T>(s: @ps, b: breaks, elts: &[T], op: &fn(@ps, &T)) {\n     box(s, 0u, b);\n     let mut first = true;\n     for elts.iter().advance |elt| {\n         if first { first = false; } else { word_space(s, \",\"); }\n-        op(s, copy *elt);\n+        op(s, elt);\n     }\n     end(s);\n }\n \n \n-pub fn commasep_cmnt<IN: Copy>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN),\n-                               get_span: &fn(IN) -> codemap::span) {\n+pub fn commasep_cmnt<T>(s: @ps, b: breaks, elts: &[T], op: &fn(@ps, &T),\n+                               get_span: &fn(&T) -> codemap::span) {\n     box(s, 0u, b);\n     let len = elts.len();\n     let mut i = 0u;\n     for elts.iter().advance |elt| {\n-        maybe_print_comment(s, get_span(copy *elt).hi);\n-        op(s, copy *elt);\n+        maybe_print_comment(s, get_span(elt).hi);\n+        op(s, elt);\n         i += 1u;\n         if i < len {\n             word(s.s, \",\");\n-            maybe_print_trailing_comment(s, get_span(copy *elt),\n-                                         Some(get_span(copy elts[i]).hi));\n+            maybe_print_trailing_comment(s, get_span(elt),\n+                                         Some(get_span(&elts[i]).hi));\n             space_if_not_bol(s);\n         }\n     }\n     end(s);\n }\n \n pub fn commasep_exprs(s: @ps, b: breaks, exprs: &[@ast::expr]) {\n-    fn expr_span(expr: @ast::expr) -> codemap::span { return expr.span; }\n-    commasep_cmnt(s, b, exprs, print_expr, expr_span);\n+    commasep_cmnt(s, b, exprs, |p, &e| print_expr(p, e), |e| e.span);\n }\n \n pub fn print_mod(s: @ps, _mod: &ast::_mod, attrs: &[ast::attribute]) {\n@@ -373,7 +372,7 @@ pub fn print_opt_lifetime(s: @ps, lifetime: &Option<ast::Lifetime>) {\n     }\n }\n \n-pub fn print_type(s: @ps, ty: @ast::Ty) {\n+pub fn print_type(s: @ps, ty: &ast::Ty) {\n     maybe_print_comment(s, ty.span.lo);\n     ibox(s, 0u);\n     match ty.node {\n@@ -399,7 +398,7 @@ pub fn print_type(s: @ps, ty: @ast::Ty) {\n       }\n       ast::ty_tup(ref elts) => {\n         popen(s);\n-        commasep(s, inconsistent, *elts, print_type);\n+        commasep(s, inconsistent, *elts, |p, &t| print_type(p, t));\n         if elts.len() == 1 {\n             word(s.s, \",\");\n         }\n@@ -443,7 +442,7 @@ pub fn print_type(s: @ps, ty: @ast::Ty) {\n     end(s);\n }\n \n-pub fn print_foreign_item(s: @ps, item: @ast::foreign_item) {\n+pub fn print_foreign_item(s: @ps, item: &ast::foreign_item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n@@ -470,7 +469,7 @@ pub fn print_foreign_item(s: @ps, item: @ast::foreign_item) {\n     }\n }\n \n-pub fn print_item(s: @ps, item: @ast::item) {\n+pub fn print_item(s: @ps, item: &ast::item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n@@ -560,20 +559,20 @@ pub fn print_item(s: @ps, item: @ast::item) {\n           print_struct(s, struct_def, generics, item.ident, item.span);\n       }\n \n-      ast::item_impl(ref generics, opt_trait, ty, ref methods) => {\n+      ast::item_impl(ref generics, ref opt_trait, ty, ref methods) => {\n         head(s, visibility_qualified(item.vis, \"impl\"));\n         if generics.is_parameterized() {\n             print_generics(s, generics);\n             space(s.s);\n         }\n \n         match opt_trait {\n-            Some(t) => {\n+            &Some(ref t) => {\n                 print_trait_ref(s, t);\n                 space(s.s);\n                 word_space(s, \"for\");\n             }\n-            None => ()\n+            &None => ()\n         };\n \n         print_type(s, ty);\n@@ -618,7 +617,7 @@ pub fn print_item(s: @ps, item: @ast::item) {\n         print_ident(s, item.ident);\n         cbox(s, indent_unit);\n         popen(s);\n-        print_tts(s, *tts);\n+        print_tts(s, &(tts.as_slice()));\n         pclose(s);\n         end(s);\n       }\n@@ -681,7 +680,7 @@ pub fn print_visibility(s: @ps, vis: ast::visibility) {\n }\n \n pub fn print_struct(s: @ps,\n-                    struct_def: @ast::struct_def,\n+                    struct_def: &ast::struct_def,\n                     generics: &ast::Generics,\n                     ident: ast::ident,\n                     span: codemap::span) {\n@@ -738,7 +737,7 @@ pub fn print_struct(s: @ps,\n /// expression arguments as expressions). It can be done! I think.\n pub fn print_tt(s: @ps, tt: &ast::token_tree) {\n     match *tt {\n-      ast::tt_delim(ref tts) => print_tts(s, *tts),\n+      ast::tt_delim(ref tts) => print_tts(s, &(tts.as_slice())),\n       ast::tt_tok(_, ref tk) => {\n           word(s.s, parse::token::to_str(s.intr, tk));\n       }\n@@ -759,7 +758,7 @@ pub fn print_tt(s: @ps, tt: &ast::token_tree) {\n     }\n }\n \n-pub fn print_tts(s: @ps, tts: &[ast::token_tree]) {\n+pub fn print_tts(s: @ps, tts: & &[ast::token_tree]) {\n     ibox(s, 0);\n     for tts.iter().enumerate().advance |(i, tt)| {\n         if i != 0 {\n@@ -777,7 +776,7 @@ pub fn print_variant(s: @ps, v: &ast::variant) {\n             print_ident(s, v.node.name);\n             if !args.is_empty() {\n                 popen(s);\n-                fn print_variant_arg(s: @ps, arg: ast::variant_arg) {\n+                fn print_variant_arg(s: @ps, arg: &ast::variant_arg) {\n                     print_type(s, arg.ty);\n                 }\n                 commasep(s, consistent, *args, print_variant_arg);\n@@ -817,7 +816,7 @@ pub fn print_trait_method(s: @ps, m: &ast::trait_method) {\n     }\n }\n \n-pub fn print_method(s: @ps, meth: @ast::method) {\n+pub fn print_method(s: @ps, meth: &ast::method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, meth.span.lo);\n     print_outer_attributes(s, meth.attrs);\n@@ -832,7 +831,7 @@ pub fn print_outer_attributes(s: @ps, attrs: &[ast::attribute]) {\n     let mut count = 0;\n     for attrs.iter().advance |attr| {\n         match attr.node.style {\n-          ast::attr_outer => { print_attribute(s, *attr); count += 1; }\n+          ast::attr_outer => { print_attribute(s, attr); count += 1; }\n           _ => {/* fallthrough */ }\n         }\n     }\n@@ -844,7 +843,7 @@ pub fn print_inner_attributes(s: @ps, attrs: &[ast::attribute]) {\n     for attrs.iter().advance |attr| {\n         match attr.node.style {\n           ast::attr_inner => {\n-            print_attribute(s, *attr);\n+            print_attribute(s, attr);\n             if !attr.node.is_sugared_doc {\n                 word(s.s, \";\");\n             }\n@@ -856,11 +855,11 @@ pub fn print_inner_attributes(s: @ps, attrs: &[ast::attribute]) {\n     if count > 0 { hardbreak_if_not_bol(s); }\n }\n \n-pub fn print_attribute(s: @ps, attr: ast::attribute) {\n+pub fn print_attribute(s: @ps, attr: &ast::attribute) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, attr.span.lo);\n     if attr.node.is_sugared_doc {\n-        let meta = attr::attr_meta(attr);\n+        let meta = attr::attr_meta(*attr);\n         let comment = attr::get_meta_item_value_str(meta).get();\n         word(s.s, comment);\n     } else {\n@@ -963,7 +962,7 @@ pub fn print_possibly_embedded_block_(s: @ps,\n     (s.ann.post)(ann_node);\n }\n \n-pub fn print_if(s: @ps, test: @ast::expr, blk: &ast::blk,\n+pub fn print_if(s: @ps, test: &ast::expr, blk: &ast::blk,\n                 elseopt: Option<@ast::expr>, chk: bool) {\n     head(s, \"if\");\n     if chk { word_nbsp(s, \"check\"); }\n@@ -1009,7 +1008,7 @@ pub fn print_mac(s: @ps, m: &ast::mac) {\n         print_path(s, pth, false);\n         word(s.s, \"!\");\n         popen(s);\n-        print_tts(s, *tts);\n+        print_tts(s, &tts.as_slice());\n         pclose(s);\n       }\n     }\n@@ -1088,15 +1087,15 @@ pub fn print_call_post(s: @ps,\n     }\n }\n \n-pub fn print_expr(s: @ps, expr: @ast::expr) {\n-    fn print_field(s: @ps, field: ast::field) {\n+pub fn print_expr(s: @ps, expr: &ast::expr) {\n+    fn print_field(s: @ps, field: &ast::field) {\n         ibox(s, indent_unit);\n         print_ident(s, field.node.ident);\n         word_space(s, \":\");\n         print_expr(s, field.node.expr);\n         end(s);\n     }\n-    fn get_span(field: ast::field) -> codemap::span { return field.span; }\n+    fn get_span(field: &ast::field) -> codemap::span { return field.span; }\n \n     maybe_print_comment(s, expr.span.lo);\n     ibox(s, indent_unit);\n@@ -1173,7 +1172,7 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n         print_ident(s, ident);\n         if tys.len() > 0u {\n             word(s.s, \"::<\");\n-            commasep(s, inconsistent, *tys, print_type);\n+            commasep(s, inconsistent, *tys, |p, &e| print_type(p, e));\n             word(s.s, \">\");\n         }\n         print_call_post(s, sugar, &blk, &mut base_args);\n@@ -1349,7 +1348,7 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n         print_ident(s, id);\n         if tys.len() > 0u {\n             word(s.s, \"::<\");\n-            commasep(s, inconsistent, *tys, print_type);\n+            commasep(s, inconsistent, *tys, |p, &e| print_type(p, e));\n             word(s.s, \">\");\n         }\n       }\n@@ -1434,15 +1433,15 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n     end(s);\n }\n \n-pub fn print_local_decl(s: @ps, loc: @ast::local) {\n+pub fn print_local_decl(s: @ps, loc: &ast::local) {\n     print_irrefutable_pat(s, loc.node.pat);\n     match loc.node.ty.node {\n       ast::ty_infer => (),\n       _ => { word_space(s, \":\"); print_type(s, loc.node.ty); }\n     }\n }\n \n-pub fn print_decl(s: @ps, decl: @ast::decl) {\n+pub fn print_decl(s: @ps, decl: &ast::decl) {\n     maybe_print_comment(s, decl.span.lo);\n     match decl.node {\n       ast::decl_local(ref loc) => {\n@@ -1454,7 +1453,7 @@ pub fn print_decl(s: @ps, decl: @ast::decl) {\n             word_nbsp(s, \"mut\");\n         }\n \n-        fn print_local(s: @ps, loc: @ast::local) {\n+        fn print_local(s: @ps, loc: &ast::local) {\n             ibox(s, indent_unit);\n             print_local_decl(s, loc);\n             end(s);\n@@ -1479,7 +1478,7 @@ pub fn print_ident(s: @ps, ident: ast::ident) {\n     word(s.s, ident_to_str(&ident));\n }\n \n-pub fn print_for_decl(s: @ps, loc: @ast::local, coll: @ast::expr) {\n+pub fn print_for_decl(s: @ps, loc: &ast::local, coll: &ast::expr) {\n     print_local_decl(s, loc);\n     space(s.s);\n     word_space(s, \"in\");\n@@ -1511,7 +1510,7 @@ fn print_path_(s: @ps, path: &ast::Path, colons_before_params: bool,\n                 }\n             }\n \n-            commasep(s, inconsistent, path.types, print_type);\n+            commasep(s, inconsistent, path.types, |p, &e| print_type(p, e));\n \n             word(s.s, \">\");\n         }\n@@ -1527,15 +1526,15 @@ pub fn print_bounded_path(s: @ps, path: &ast::Path,\n     print_path_(s, path, false, bounds)\n }\n \n-pub fn print_irrefutable_pat(s: @ps, pat: @ast::pat) {\n+pub fn print_irrefutable_pat(s: @ps, pat: &ast::pat) {\n     print_pat(s, pat, false)\n }\n \n-pub fn print_refutable_pat(s: @ps, pat: @ast::pat) {\n+pub fn print_refutable_pat(s: @ps, pat: &ast::pat) {\n     print_pat(s, pat, true)\n }\n \n-pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n+pub fn print_pat(s: @ps, pat: &ast::pat, refutable: bool) {\n     maybe_print_comment(s, pat.span.lo);\n     let ann_node = node_pat(s, pat);\n     (s.ann.pre)(ann_node);\n@@ -1570,7 +1569,7 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n             if !args.is_empty() {\n               popen(s);\n               commasep(s, inconsistent, *args,\n-                       |s, p| print_pat(s, p, refutable));\n+                       |s, &p| print_pat(s, p, refutable));\n               pclose(s);\n             } else { }\n           }\n@@ -1579,14 +1578,14 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n       ast::pat_struct(ref path, ref fields, etc) => {\n         print_path(s, path, true);\n         word(s.s, \"{\");\n-        fn print_field(s: @ps, f: ast::field_pat, refutable: bool) {\n+        fn print_field(s: @ps, f: &ast::field_pat, refutable: bool) {\n             cbox(s, indent_unit);\n             print_ident(s, f.ident);\n             word_space(s, \":\");\n             print_pat(s, f.pat, refutable);\n             end(s);\n         }\n-        fn get_span(f: ast::field_pat) -> codemap::span { return f.pat.span; }\n+        fn get_span(f: &ast::field_pat) -> codemap::span { return f.pat.span; }\n         commasep_cmnt(s, consistent, *fields,\n                       |s, f| print_field(s,f,refutable),\n                       get_span);\n@@ -1598,7 +1597,7 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n       }\n       ast::pat_tup(ref elts) => {\n         popen(s);\n-        commasep(s, inconsistent, *elts, |s, p| print_pat(s, p, refutable));\n+        commasep(s, inconsistent, *elts, |s, &p| print_pat(s, p, refutable));\n         if elts.len() == 1 {\n             word(s.s, \",\");\n         }\n@@ -1625,7 +1624,7 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n       }\n       ast::pat_vec(ref before, slice, ref after) => {\n         word(s.s, \"[\");\n-        do commasep(s, inconsistent, *before) |s, p| {\n+        do commasep(s, inconsistent, *before) |s, &p| {\n             print_pat(s, p, refutable);\n         }\n         for slice.iter().advance |&p| {\n@@ -1634,7 +1633,7 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n             print_pat(s, p, refutable);\n             if !after.is_empty() { word_space(s, \",\"); }\n         }\n-        do commasep(s, inconsistent, *after) |s, p| {\n+        do commasep(s, inconsistent, *after) |s, &p| {\n             print_pat(s, p, refutable);\n         }\n         word(s.s, \"]\");\n@@ -1643,8 +1642,8 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n     (s.ann.post)(ann_node);\n }\n \n-pub fn explicit_self_to_str(explicit_self: ast::explicit_self_, intr: @ident_interner) -> ~str {\n-    to_str(explicit_self, |a, b| { print_explicit_self(a, b); () }, intr)\n+pub fn explicit_self_to_str(explicit_self: &ast::explicit_self_, intr: @ident_interner) -> ~str {\n+    to_str(explicit_self, |a, &b| { print_explicit_self(a, b); () }, intr)\n }\n \n // Returns whether it printed anything\n@@ -1748,7 +1747,7 @@ pub fn print_bounds(s: @ps, bounds: &OptVec<ast::TyParamBound>,\n             }\n \n             match *bound {\n-                TraitTyParamBound(tref) => print_trait_ref(s, tref),\n+                TraitTyParamBound(ref tref) => print_trait_ref(s, tref),\n                 RegionTyParamBound => word(s.s, \"'static\"),\n             }\n         }\n@@ -1784,12 +1783,12 @@ pub fn print_generics(s: @ps, generics: &ast::Generics) {\n         }\n \n         commasep(s, inconsistent, ints,\n-                 |s, i| print_item(s, generics, i));\n+                 |s, &i| print_item(s, generics, i));\n         word(s.s, \">\");\n     }\n }\n \n-pub fn print_meta_item(s: @ps, item: @ast::meta_item) {\n+pub fn print_meta_item(s: @ps, item: &ast::meta_item) {\n     ibox(s, indent_unit);\n     match item.node {\n       ast::meta_word(name) => word(s.s, name),\n@@ -1804,16 +1803,16 @@ pub fn print_meta_item(s: @ps, item: @ast::meta_item) {\n         commasep(\n             s,\n             consistent,\n-            /* FIXME (#2543) */ copy *items,\n-            print_meta_item\n+            items.as_slice(),\n+            |p, &i| print_meta_item(p, i)\n         );\n         pclose(s);\n       }\n     }\n     end(s);\n }\n \n-pub fn print_view_path(s: @ps, vp: @ast::view_path) {\n+pub fn print_view_path(s: @ps, vp: &ast::view_path) {\n     match vp.node {\n       ast::view_path_simple(ident, ref path, _) => {\n         if path.idents[path.idents.len()-1u] != ident {\n@@ -1841,7 +1840,7 @@ pub fn print_view_path(s: @ps, vp: @ast::view_path) {\n }\n \n pub fn print_view_paths(s: @ps, vps: &[@ast::view_path]) {\n-    commasep(s, inconsistent, vps, print_view_path);\n+    commasep(s, inconsistent, vps, |p, &vp| print_view_path(p, vp));\n }\n \n pub fn print_view_item(s: @ps, item: &ast::view_item) {\n@@ -1855,7 +1854,7 @@ pub fn print_view_item(s: @ps, item: &ast::view_item) {\n             print_ident(s, id);\n             if !mta.is_empty() {\n                 popen(s);\n-                commasep(s, consistent, *mta, print_meta_item);\n+                commasep(s, consistent, *mta, |p, &i| print_meta_item(p, i));\n                 pclose(s);\n             }\n         }\n@@ -2003,7 +2002,7 @@ pub fn print_remaining_comments(s: @ps) {\n     }\n }\n \n-pub fn print_literal(s: @ps, lit: @ast::lit) {\n+pub fn print_literal(s: @ps, lit: &ast::lit) {\n     maybe_print_comment(s, lit.span.lo);\n     match next_lit(s, lit.span.lo) {\n       Some(ref ltrl) => {\n@@ -2056,7 +2055,7 @@ pub fn print_literal(s: @ps, lit: @ast::lit) {\n     }\n }\n \n-pub fn lit_to_str(l: @ast::lit) -> ~str {\n+pub fn lit_to_str(l: &ast::lit) -> ~str {\n     return to_str(l, print_literal, parse::token::mk_fake_ident_interner());\n }\n \n@@ -2139,10 +2138,10 @@ pub fn print_string(s: @ps, st: &str) {\n     word(s.s, \"\\\"\");\n }\n \n-pub fn to_str<T: Copy>(t: T, f: @fn(@ps, T), intr: @ident_interner) -> ~str {\n+pub fn to_str<T>(t: &T, f: &fn(@ps, &T), intr: @ident_interner) -> ~str {\n     do io::with_str_writer |wr| {\n         let s = rust_printer(wr, intr);\n-        f(s, copy t);\n+        f(s, t);\n         eof(s.s);\n     }\n }"}, {"sha": "4be9ef13db27bd52952204969f578e0d0d2a30ee", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c5a44d3e805652a54a5693bbf2ab6d44db993b/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=97c5a44d3e805652a54a5693bbf2ab6d44db993b", "patch": "@@ -183,7 +183,7 @@ pub fn visit_item<E: Copy>(i: &item, (e, v): (E, vt<E>)) {\n         }\n         item_impl(ref tps, ref traits, ty, ref methods) => {\n             (v.visit_generics)(tps, (copy e, v));\n-            for traits.iter().advance |&p| {\n+            for traits.iter().advance |p| {\n                 visit_trait_ref(p, (copy e, v));\n             }\n             (v.visit_ty)(ty, (copy e, v));\n@@ -336,7 +336,7 @@ pub fn visit_ty_param_bounds<E: Copy>(bounds: &OptVec<TyParamBound>,\n                                       (e, v): (E, vt<E>)) {\n     for bounds.iter().advance |bound| {\n         match *bound {\n-            TraitTyParamBound(ty) => visit_trait_ref(ty, (copy e, v)),\n+            TraitTyParamBound(ref ty) => visit_trait_ref(ty, (copy e, v)),\n             RegionTyParamBound => {}\n         }\n     }"}]}