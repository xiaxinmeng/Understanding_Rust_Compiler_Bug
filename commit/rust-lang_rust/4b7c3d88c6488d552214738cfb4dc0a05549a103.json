{"sha": "4b7c3d88c6488d552214738cfb4dc0a05549a103", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiN2MzZDg4YzY0ODhkNTUyMjE0NzM4Y2ZiNGRjMGEwNTU0OWExMDM=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-05-13T23:39:50Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-05-17T19:41:59Z"}, "message": "Make `fold` standalone.\n\n`fold` is currently implemented via `try_fold`, but implementing it\ndirectly results in slightly less LLVM IR being generated, speeding up\ncompilation of some benchmarks.\n\n(And likewise for `rfold`.)\n\nThe commit adds `fold` implementations to all the iterators that lack\none but do have a `try_fold` implementation. Most of these just call the\n`try_fold` implementation directly.", "tree": {"sha": "23c081447f15d1cc890156b97cef2b514bb0005c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23c081447f15d1cc890156b97cef2b514bb0005c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b7c3d88c6488d552214738cfb4dc0a05549a103", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b7c3d88c6488d552214738cfb4dc0a05549a103", "html_url": "https://github.com/rust-lang/rust/commit/4b7c3d88c6488d552214738cfb4dc0a05549a103", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b7c3d88c6488d552214738cfb4dc0a05549a103/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34cce58d81f006a5406fcae918db4492e6cf2784", "url": "https://api.github.com/repos/rust-lang/rust/commits/34cce58d81f006a5406fcae918db4492e6cf2784", "html_url": "https://github.com/rust-lang/rust/commit/34cce58d81f006a5406fcae918db4492e6cf2784"}], "stats": {"total": 161, "additions": 124, "deletions": 37}, "files": [{"sha": "939a26cb70232910c6e8183ce713b400577fcdc1", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/4b7c3d88c6488d552214738cfb4dc0a05549a103/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b7c3d88c6488d552214738cfb4dc0a05549a103/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=4b7c3d88c6488d552214738cfb4dc0a05549a103", "patch": "@@ -512,6 +512,9 @@ where\n             acc = self.iter.try_fold(acc, &mut f)?;\n         }\n     }\n+\n+    // No `fold` override, because `fold` doesn't make much sense for `Cycle`,\n+    // and we can't do anything better than the default.\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -643,6 +646,25 @@ where\n         }\n         from_fn(nth(&mut self.iter, self.step)).try_fold(acc, f)\n     }\n+\n+    fn fold<Acc, F>(mut self, mut acc: Acc, mut f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn nth<I: Iterator>(iter: &mut I, step: usize) -> impl FnMut() -> Option<I::Item> + '_ {\n+            move || iter.nth(step)\n+        }\n+\n+        if self.first_take {\n+            self.first_take = false;\n+            match self.iter.next() {\n+                None => return acc,\n+                Some(x) => acc = f(acc, x),\n+            }\n+        }\n+        from_fn(nth(&mut self.iter, self.step)).fold(acc, f)\n+    }\n }\n \n impl<I> StepBy<I>\n@@ -1767,6 +1789,20 @@ where\n             self.iter.try_fold(init, check(flag, p, fold)).into_try()\n         }\n     }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(fold)).unwrap()\n+    }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -1838,6 +1874,20 @@ where\n         })\n         .into_try()\n     }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(fold)).unwrap()\n+    }\n }\n \n /// An iterator that skips over `n` elements of `iter`.\n@@ -2105,6 +2155,20 @@ where\n             self.iter.try_fold(init, check(n, fold)).into_try()\n         }\n     }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(fold)).unwrap()\n+    }\n }\n \n #[stable(feature = \"double_ended_take_iterator\", since = \"1.38.0\")]\n@@ -2237,6 +2301,20 @@ where\n         let f = &mut self.f;\n         self.iter.try_fold(init, scan(state, f, fold)).into_try()\n     }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(fold)).unwrap()\n+    }\n }\n \n /// An iterator that calls a function with a reference to each element before\n@@ -2444,4 +2522,17 @@ where\n             })\n             .into_try()\n     }\n+\n+    fn fold<B, F>(mut self, init: B, fold: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(fold)).unwrap()\n+    }\n }"}, {"sha": "6ac9576a46db23d8876c6adfc6f427999defb360", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4b7c3d88c6488d552214738cfb4dc0a05549a103/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b7c3d88c6488d552214738cfb4dc0a05549a103/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=4b7c3d88c6488d552214738cfb4dc0a05549a103", "patch": "@@ -658,6 +658,19 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n         Try::from_ok(accum)\n     }\n \n+    #[inline]\n+    fn fold<B, F>(mut self, init: B, f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(f)).unwrap()\n+    }\n     #[inline]\n     fn last(mut self) -> Option<A> {\n         self.next_back()"}, {"sha": "cceb373d552a86ba682c5f63121bf6496979f2fa", "filename": "src/libcore/iter/traits/double_ended.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4b7c3d88c6488d552214738cfb4dc0a05549a103/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b7c3d88c6488d552214738cfb4dc0a05549a103/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=4b7c3d88c6488d552214738cfb4dc0a05549a103", "patch": "@@ -221,17 +221,16 @@ pub trait DoubleEndedIterator: Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_rfold\", since = \"1.27.0\")]\n-    fn rfold<B, F>(mut self, accum: B, f: F) -> B\n+    fn rfold<B, F>(mut self, init: B, mut f: F) -> B\n     where\n         Self: Sized,\n         F: FnMut(B, Self::Item) -> B,\n     {\n-        #[inline]\n-        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n-            move |acc, x| Ok(f(acc, x))\n+        let mut accum = init;\n+        while let Some(x) = self.next_back() {\n+            accum = f(accum, x);\n         }\n-\n-        self.try_rfold(accum, ok(f)).unwrap()\n+        accum\n     }\n \n     /// Searches for an element of an iterator from the back that satisfies a predicate."}, {"sha": "d20c6790d4ae370f03e675e6ccf5422c68d5c02d", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4b7c3d88c6488d552214738cfb4dc0a05549a103/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b7c3d88c6488d552214738cfb4dc0a05549a103/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=4b7c3d88c6488d552214738cfb4dc0a05549a103", "patch": "@@ -1826,7 +1826,7 @@ pub trait Iterator {\n     ///\n     /// # Note to Implementors\n     ///\n-    /// Most of the other (forward) methods have default implementations in\n+    /// Several of the other (forward) methods have default implementations in\n     /// terms of this one, so try to implement this explicitly if it can\n     /// do something better than the default `for` loop implementation.\n     ///\n@@ -1944,6 +1944,15 @@ pub trait Iterator {\n     /// may not terminate for infinite iterators, even on traits for which a\n     /// result is determinable in finite time.\n     ///\n+    /// # Note to Implementors\n+    ///\n+    /// Several of the other (forward) methods have default implementations in\n+    /// terms of this one, so try to implement this explicitly if it can\n+    /// do something better than the default `for` loop implementation.\n+    ///\n+    /// In particular, try to have this call `fold()` on the internal parts\n+    /// from which this iterator is composed.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1992,17 +2001,16 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn fold<B, F>(mut self, init: B, f: F) -> B\n+    fn fold<B, F>(mut self, init: B, mut f: F) -> B\n     where\n         Self: Sized,\n         F: FnMut(B, Self::Item) -> B,\n     {\n-        #[inline]\n-        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n-            move |acc, x| Ok(f(acc, x))\n+        let mut accum = init;\n+        while let Some(x) = self.next() {\n+            accum = f(accum, x);\n         }\n-\n-        self.try_fold(init, ok(f)).unwrap()\n+        accum\n     }\n \n     /// The same as [`fold()`](#method.fold), but uses the first element in the"}, {"sha": "ec58f7068abac0b276f9304b313d7574efebd647", "filename": "src/test/codegen/iter-fold-closure-no-dupes.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/34cce58d81f006a5406fcae918db4492e6cf2784/src%2Ftest%2Fcodegen%2Fiter-fold-closure-no-dupes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34cce58d81f006a5406fcae918db4492e6cf2784/src%2Ftest%2Fcodegen%2Fiter-fold-closure-no-dupes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fiter-fold-closure-no-dupes.rs?ref=34cce58d81f006a5406fcae918db4492e6cf2784", "patch": "@@ -1,14 +0,0 @@\n-//! Check that fold closures aren't duplicated for each iterator type.\n-// compile-flags: -C opt-level=0\n-\n-fn main() {\n-    (0i32..10).by_ref().count();\n-    (0i32..=10).by_ref().count();\n-}\n-\n-// `count` calls `fold`, which calls `try_fold` -- find the `fold` closure:\n-// CHECK: {{^define.*Iterator::fold::.*closure}}\n-//\n-// Only one closure is needed for both `count` calls, even from different\n-// monomorphized iterator types, as it's only generic over the item type.\n-// CHECK-NOT: {{^define.*Iterator::fold::.*closure}}"}, {"sha": "fbeafd5f395827b8774b5bd1695f4e2560a1d015", "filename": "src/test/codegen/iter-fold-closure-no-iterator.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/34cce58d81f006a5406fcae918db4492e6cf2784/src%2Ftest%2Fcodegen%2Fiter-fold-closure-no-iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34cce58d81f006a5406fcae918db4492e6cf2784/src%2Ftest%2Fcodegen%2Fiter-fold-closure-no-iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fiter-fold-closure-no-iterator.rs?ref=34cce58d81f006a5406fcae918db4492e6cf2784", "patch": "@@ -1,10 +0,0 @@\n-//! Check that fold closures aren't generic in the iterator type.\n-// compile-flags: -C opt-level=0\n-\n-fn main() {\n-    (0i32..10).by_ref().count();\n-}\n-\n-// `count` calls `fold`, which calls `try_fold` -- that `fold` closure should\n-// not be generic in the iterator type, only in the item type.\n-// CHECK-NOT: {{^define.*Iterator::fold::.*closure.*Range}}"}]}