{"sha": "1146560e1a53d26d04b33548d4eeb8e083d78509", "node_id": "C_kwDOAAsO6NoAKDExNDY1NjBlMWE1M2QyNmQwNGIzMzU0OGQ0ZWViOGUwODNkNzg1MDk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-06T09:17:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-06T09:17:14Z"}, "message": "Auto merge of #106529 - Dylan-DPC:rollup-mvncmrk, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #106400 (Point at expressions where inference refines an unexpected type)\n - #106491 (Fix error-index redirect to work with the back button.)\n - #106494 (Add regression test for #58355)\n - #106499 (fix [type error] for error E0029 and E0277)\n - #106502 (rustdoc: remove legacy user-select CSS)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "e7ce4d2e544fde6e35123ed0106d8b8a4775b889", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7ce4d2e544fde6e35123ed0106d8b8a4775b889"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1146560e1a53d26d04b33548d4eeb8e083d78509", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1146560e1a53d26d04b33548d4eeb8e083d78509", "html_url": "https://github.com/rust-lang/rust/commit/1146560e1a53d26d04b33548d4eeb8e083d78509", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1146560e1a53d26d04b33548d4eeb8e083d78509/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce8fbe79013df9c2909f34198d3bff72e572cfd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce8fbe79013df9c2909f34198d3bff72e572cfd5", "html_url": "https://github.com/rust-lang/rust/commit/ce8fbe79013df9c2909f34198d3bff72e572cfd5"}, {"sha": "dd97619b1fe3358e1664f3e04ef88d9372677c45", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd97619b1fe3358e1664f3e04ef88d9372677c45", "html_url": "https://github.com/rust-lang/rust/commit/dd97619b1fe3358e1664f3e04ef88d9372677c45"}], "stats": {"total": 539, "additions": 515, "deletions": 24}, "files": [{"sha": "cf070eb962f09bf46d0def52c36913a839a8116c", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 220, "deletions": 3, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/1146560e1a53d26d04b33548d4eeb8e083d78509/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1146560e1a53d26d04b33548d4eeb8e083d78509/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=1146560e1a53d26d04b33548d4eeb8e083d78509", "patch": "@@ -1,21 +1,26 @@\n use crate::FnCtxt;\n use rustc_ast::util::parser::PREC_POSTFIX;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::MultiSpan;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n+use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{is_range_literal, Node};\n use rustc_infer::infer::InferOk;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::middle::stability::EvalResult;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n-use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::{self, Article, AssocItem, Ty, TypeAndMut};\n+use rustc_middle::ty::fold::{BottomUpFolder, TypeFolder};\n+use rustc_middle::ty::print::{with_forced_trimmed_paths, with_no_trimmed_paths};\n+use rustc_middle::ty::relate::TypeRelation;\n+use rustc_middle::ty::{self, Article, AssocItem, Ty, TypeAndMut, TypeVisitable};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{BytePos, Span};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::method_chain::CollectAllMismatches;\n use rustc_trait_selection::traits::ObligationCause;\n \n use super::method::probe;\n@@ -40,7 +45,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.annotate_alternative_method_deref(err, expr, error);\n \n         // Use `||` to give these suggestions a precedence\n-        let _ = self.suggest_missing_parentheses(err, expr)\n+        let suggested = self.suggest_missing_parentheses(err, expr)\n             || self.suggest_remove_last_method_call(err, expr, expected)\n             || self.suggest_associated_const(err, expr, expected)\n             || self.suggest_deref_ref_or_into(err, expr, expected, expr_ty, expected_ty_expr)\n@@ -54,6 +59,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             || self.suggest_copied_or_cloned(err, expr, expr_ty, expected)\n             || self.suggest_into(err, expr, expr_ty, expected)\n             || self.suggest_floating_point_literal(err, expr, expected);\n+        if !suggested {\n+            self.point_at_expr_source_of_inferred_type(err, expr, expr_ty, expected);\n+        }\n     }\n \n     pub fn emit_coerce_suggestions(\n@@ -205,6 +213,215 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         (expected, Some(err))\n     }\n \n+    pub fn point_at_expr_source_of_inferred_type(\n+        &self,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+        found: Ty<'tcx>,\n+        expected: Ty<'tcx>,\n+    ) -> bool {\n+        let map = self.tcx.hir();\n+\n+        let hir::ExprKind::Path(hir::QPath::Resolved(None, p)) = expr.kind else { return false; };\n+        let [hir::PathSegment { ident, args: None, .. }] = p.segments else { return false; };\n+        let hir::def::Res::Local(hir_id) = p.res else { return false; };\n+        let Some(hir::Node::Pat(pat)) = map.find(hir_id) else { return false; };\n+        let Some(hir::Node::Local(hir::Local {\n+            ty: None,\n+            init: Some(init),\n+            ..\n+        })) = map.find_parent(pat.hir_id) else { return false; };\n+        let Some(ty) = self.node_ty_opt(init.hir_id) else { return false; };\n+        if ty.is_closure() || init.span.overlaps(expr.span) || pat.span.from_expansion() {\n+            return false;\n+        }\n+\n+        // Locate all the usages of the relevant binding.\n+        struct FindExprs<'hir> {\n+            hir_id: hir::HirId,\n+            uses: Vec<&'hir hir::Expr<'hir>>,\n+        }\n+        impl<'v> Visitor<'v> for FindExprs<'v> {\n+            fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n+                if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = ex.kind\n+                    && let hir::def::Res::Local(hir_id) = path.res\n+                    && hir_id == self.hir_id\n+                {\n+                    self.uses.push(ex);\n+                }\n+                hir::intravisit::walk_expr(self, ex);\n+            }\n+        }\n+\n+        let mut expr_finder = FindExprs { hir_id, uses: vec![] };\n+        let id = map.get_parent_item(hir_id);\n+        let hir_id: hir::HirId = id.into();\n+\n+        let Some(node) = map.find(hir_id) else { return false; };\n+        let Some(body_id) = node.body_id() else { return false; };\n+        let body = map.body(body_id);\n+        expr_finder.visit_expr(body.value);\n+        // Hack to make equality checks on types with inference variables and regions useful.\n+        let mut eraser = BottomUpFolder {\n+            tcx: self.tcx,\n+            lt_op: |_| self.tcx.lifetimes.re_erased,\n+            ct_op: |c| c,\n+            ty_op: |t| match *t.kind() {\n+                ty::Infer(ty::TyVar(vid)) => self.tcx.mk_ty_infer(ty::TyVar(self.root_var(vid))),\n+                ty::Infer(ty::IntVar(_)) => {\n+                    self.tcx.mk_ty_infer(ty::IntVar(ty::IntVid { index: 0 }))\n+                }\n+                ty::Infer(ty::FloatVar(_)) => {\n+                    self.tcx.mk_ty_infer(ty::FloatVar(ty::FloatVid { index: 0 }))\n+                }\n+                _ => t,\n+            },\n+        };\n+        let mut prev = eraser.fold_ty(ty);\n+        let mut prev_span = None;\n+\n+        for binding in expr_finder.uses {\n+            // In every expression where the binding is referenced, we will look at that\n+            // expression's type and see if it is where the incorrect found type was fully\n+            // \"materialized\" and point at it. We will also try to provide a suggestion there.\n+            if let Some(hir::Node::Expr(expr)\n+            | hir::Node::Stmt(hir::Stmt {\n+                kind: hir::StmtKind::Expr(expr) | hir::StmtKind::Semi(expr),\n+                ..\n+            })) = &map.find_parent(binding.hir_id)\n+                && let hir::ExprKind::MethodCall(segment, rcvr, args, _span) = expr.kind\n+                && rcvr.hir_id == binding.hir_id\n+                && let Some(def_id) = self.typeck_results.borrow().type_dependent_def_id(expr.hir_id)\n+            {\n+                // We special case methods, because they can influence inference through the\n+                // call's arguments and we can provide a more explicit span.\n+                let sig = self.tcx.fn_sig(def_id);\n+                let def_self_ty = sig.input(0).skip_binder();\n+                let rcvr_ty = self.node_ty(rcvr.hir_id);\n+                // Get the evaluated type *after* calling the method call, so that the influence\n+                // of the arguments can be reflected in the receiver type. The receiver\n+                // expression has the type *before* theis analysis is done.\n+                let ty = match self.lookup_probe(\n+                    segment.ident,\n+                    rcvr_ty,\n+                    expr,\n+                    probe::ProbeScope::TraitsInScope,\n+                ) {\n+                    Ok(pick) => pick.self_ty,\n+                    Err(_) => rcvr_ty,\n+                };\n+                // Remove one layer of references to account for `&mut self` and\n+                // `&self`, so that we can compare it against the binding.\n+                let (ty, def_self_ty) = match (ty.kind(), def_self_ty.kind()) {\n+                    (ty::Ref(_, ty, a), ty::Ref(_, self_ty, b)) if a == b => (*ty, *self_ty),\n+                    _ => (ty, def_self_ty),\n+                };\n+                let mut param_args = FxHashMap::default();\n+                let mut param_expected = FxHashMap::default();\n+                let mut param_found = FxHashMap::default();\n+                if self.can_eq(self.param_env, ty, found).is_ok() {\n+                    // We only point at the first place where the found type was inferred.\n+                    for (i, param_ty) in sig.inputs().skip_binder().iter().skip(1).enumerate() {\n+                        if def_self_ty.contains(*param_ty) && let ty::Param(_) = param_ty.kind() {\n+                            // We found an argument that references a type parameter in `Self`,\n+                            // so we assume that this is the argument that caused the found\n+                            // type, which we know already because of `can_eq` above was first\n+                            // inferred in this method call.\n+                            let arg = &args[i];\n+                            let arg_ty = self.node_ty(arg.hir_id);\n+                            err.span_label(\n+                                arg.span,\n+                                &format!(\n+                                    \"this is of type `{arg_ty}`, which causes `{ident}` to be \\\n+                                     inferred as `{ty}`\",\n+                                ),\n+                            );\n+                            param_args.insert(param_ty, (arg, arg_ty));\n+                        }\n+                    }\n+                }\n+\n+                // Here we find, for a type param `T`, the type that `T` is in the current\n+                // method call *and* in the original expected type. That way, we can see if we\n+                // can give any structured suggestion for the function argument.\n+                let mut c = CollectAllMismatches {\n+                    infcx: &self.infcx,\n+                    param_env: self.param_env,\n+                    errors: vec![],\n+                };\n+                let _ = c.relate(def_self_ty, ty);\n+                for error in c.errors {\n+                    if let TypeError::Sorts(error) = error {\n+                        param_found.insert(error.expected, error.found);\n+                    }\n+                }\n+                c.errors = vec![];\n+                let _ = c.relate(def_self_ty, expected);\n+                for error in c.errors {\n+                    if let TypeError::Sorts(error) = error {\n+                        param_expected.insert(error.expected, error.found);\n+                    }\n+                }\n+                for (param, (arg, arg_ty)) in param_args.iter() {\n+                    let Some(expected) = param_expected.get(param) else { continue; };\n+                    let Some(found) = param_found.get(param) else { continue; };\n+                    if self.can_eq(self.param_env, *arg_ty, *found).is_err() { continue; }\n+                    self.emit_coerce_suggestions(err, arg, *found, *expected, None, None);\n+                }\n+\n+                let ty = eraser.fold_ty(ty);\n+                if ty.references_error() {\n+                    break;\n+                }\n+                if ty != prev\n+                    && param_args.is_empty()\n+                    && self.can_eq(self.param_env, ty, found).is_ok()\n+                {\n+                    // We only point at the first place where the found type was inferred.\n+                    err.span_label(\n+                        segment.ident.span,\n+                        with_forced_trimmed_paths!(format!(\n+                            \"here the type of `{ident}` is inferred to be `{ty}`\",\n+                        )),\n+                    );\n+                    break;\n+                } else if !param_args.is_empty() {\n+                    break;\n+                }\n+                prev = ty;\n+            } else {\n+                let ty = eraser.fold_ty(self.node_ty(binding.hir_id));\n+                if ty.references_error() {\n+                    break;\n+                }\n+                if ty != prev\n+                    && let Some(span) = prev_span\n+                    && self.can_eq(self.param_env, ty, found).is_ok()\n+                {\n+                    // We only point at the first place where the found type was inferred.\n+                    // We use the *previous* span because if the type is known *here* it means\n+                    // it was *evaluated earlier*. We don't do this for method calls because we\n+                    // evaluate the method's self type eagerly, but not in any other case.\n+                    err.span_label(\n+                        span,\n+                        with_forced_trimmed_paths!(format!(\n+                            \"here the type of `{ident}` is inferred to be `{ty}`\",\n+                        )),\n+                    );\n+                    break;\n+                }\n+                prev = ty;\n+            }\n+            if binding.hir_id == expr.hir_id {\n+                // Do not look at expressions that come after the expression we were originally\n+                // evaluating and had a type error.\n+                break;\n+            }\n+            prev_span = Some(binding.span);\n+        }\n+        true\n+    }\n+\n     fn annotate_expected_due_to_let_ty(\n         &self,\n         err: &mut Diagnostic,"}, {"sha": "6ed1bc051a5fa406b0845d0579527fdb78071f6f", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1146560e1a53d26d04b33548d4eeb8e083d78509/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1146560e1a53d26d04b33548d4eeb8e083d78509/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=1146560e1a53d26d04b33548d4eeb8e083d78509", "patch": "@@ -234,6 +234,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ) => self.check_expr_path(qpath, expr, args),\n             _ => self.check_expr_kind(expr, expected),\n         });\n+        let ty = self.resolve_vars_if_possible(ty);\n \n         // Warn for non-block expressions with diverging children.\n         match expr.kind {"}, {"sha": "7d6b4aaebf4ea93c4313699c7d0208c065273088", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1146560e1a53d26d04b33548d4eeb8e083d78509/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1146560e1a53d26d04b33548d4eeb8e083d78509/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=1146560e1a53d26d04b33548d4eeb8e083d78509", "patch": "@@ -798,6 +798,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 full_call_span,\n                 format!(\"arguments to this {} are incorrect\", call_name),\n             );\n+            if let (Some(callee_ty), hir::ExprKind::MethodCall(_, rcvr, _, _)) =\n+                (callee_ty, &call_expr.kind)\n+            {\n+                // Type that would have accepted this argument if it hadn't been inferred earlier.\n+                // FIXME: We leave an inference variable for now, but it'd be nice to get a more\n+                // specific type to increase the accuracy of the diagnostic.\n+                let expected = self.infcx.next_ty_var(TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::MiscVariable,\n+                    span: full_call_span,\n+                });\n+                self.point_at_expr_source_of_inferred_type(&mut err, rcvr, expected, callee_ty);\n+            }\n             // Call out where the function is defined\n             self.label_fn_like(\n                 &mut err,"}, {"sha": "e0304fa2d3b98b017f04ca6927c86e06d40639d7", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1146560e1a53d26d04b33548d4eeb8e083d78509/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1146560e1a53d26d04b33548d4eeb8e083d78509/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=1146560e1a53d26d04b33548d4eeb8e083d78509", "patch": "@@ -553,6 +553,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             (lhs, Some((true, rhs_ty, rhs_sp))) => one_side_err(rhs_sp, rhs_ty, lhs),\n             _ => span_bug!(span, \"Impossible, verified above.\"),\n         }\n+        if (lhs, rhs).references_error() {\n+            err.downgrade_to_delayed_bug();\n+        }\n         if self.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\n                 \"In a match expression, only numbers and characters can be matched \\"}, {"sha": "749e960bfd03090876186167b6b6247b5eb44efc", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1146560e1a53d26d04b33548d4eeb8e083d78509/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1146560e1a53d26d04b33548d4eeb8e083d78509/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=1146560e1a53d26d04b33548d4eeb8e083d78509", "patch": "@@ -61,7 +61,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                 .as_local()\n                 .map_or(false, |def_id| self.opaque_type_origin(def_id, span).is_some())\n         };\n-        let value = value.fold_with(&mut ty::fold::BottomUpFolder {\n+        let value = value.fold_with(&mut BottomUpFolder {\n             tcx: self.tcx,\n             lt_op: |lt| lt,\n             ct_op: |ct| ct,"}, {"sha": "1d39cf60e2616c61afeee225c167c1f6ebe0ecb6", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1146560e1a53d26d04b33548d4eeb8e083d78509/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1146560e1a53d26d04b33548d4eeb8e083d78509/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=1146560e1a53d26d04b33548d4eeb8e083d78509", "patch": "@@ -1407,7 +1407,6 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n         self.note_obligation_cause(&mut err, &obligation);\n         self.point_at_returns_when_relevant(&mut err, &obligation);\n-\n         err.emit();\n     }\n }"}, {"sha": "aa98ab801587b3b98d220bdbbef7f6b3db10d999", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1146560e1a53d26d04b33548d4eeb8e083d78509/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1146560e1a53d26d04b33548d4eeb8e083d78509/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=1146560e1a53d26d04b33548d4eeb8e083d78509", "patch": "@@ -248,7 +248,7 @@ pub trait TypeErrCtxtExt<'tcx> {\n \n     fn point_at_returns_when_relevant(\n         &self,\n-        err: &mut Diagnostic,\n+        err: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n         obligation: &PredicateObligation<'tcx>,\n     );\n \n@@ -1685,7 +1685,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n     fn point_at_returns_when_relevant(\n         &self,\n-        err: &mut Diagnostic,\n+        err: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n         obligation: &PredicateObligation<'tcx>,\n     ) {\n         match obligation.cause.code().peel_derives() {\n@@ -1707,7 +1707,15 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             for expr in &visitor.returns {\n                 if let Some(returned_ty) = typeck_results.node_type_opt(expr.hir_id) {\n                     let ty = self.resolve_vars_if_possible(returned_ty);\n-                    err.span_label(expr.span, &format!(\"this returned value is of type `{}`\", ty));\n+                    if ty.references_error() {\n+                        // don't print out the [type error] here\n+                        err.delay_as_bug();\n+                    } else {\n+                        err.span_label(\n+                            expr.span,\n+                            &format!(\"this returned value is of type `{}`\", ty),\n+                        );\n+                    }\n                 }\n             }\n         }"}, {"sha": "05a12d3d4d4a2d16c35047bf835529ff05d858aa", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=1146560e1a53d26d04b33548d4eeb8e083d78509", "patch": "@@ -538,8 +538,6 @@ ul.block, .block li {\n \toverflow: initial;\n \ttext-align: right;\n \t-webkit-user-select: none;\n-\t-moz-user-select: none;\n-\t-ms-user-select: none;\n \tuser-select: none;\n \tpadding: 14px 8px;\n \tcolor: var(--src-line-numbers-span-color);"}, {"sha": "3b62fdece403b922c15a37a532c20997e35f24e5", "filename": "src/test/ui/type/issue-58355.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftest%2Fui%2Ftype%2Fissue-58355.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftest%2Fui%2Ftype%2Fissue-58355.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fissue-58355.rs?ref=1146560e1a53d26d04b33548d4eeb8e083d78509", "patch": "@@ -0,0 +1,7 @@\n+#![crate_type = \"lib\"]\n+\n+pub fn foo(callback: fn() -> dyn ToString) {\n+    let mut x: Option<Box<dyn Fn() -> dyn ToString>> = None;\n+    x = Some(Box::new(callback));\n+    //~^ ERROR: the size for values of type `dyn ToString` cannot be known at compilation time\n+}"}, {"sha": "6f89a7b004999a5812f72be17bfa80cdc32907d5", "filename": "src/test/ui/type/issue-58355.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftest%2Fui%2Ftype%2Fissue-58355.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftest%2Fui%2Ftype%2Fissue-58355.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fissue-58355.stderr?ref=1146560e1a53d26d04b33548d4eeb8e083d78509", "patch": "@@ -0,0 +1,13 @@\n+error[E0277]: the size for values of type `dyn ToString` cannot be known at compilation time\n+  --> $DIR/issue-58355.rs:5:14\n+   |\n+LL |     x = Some(Box::new(callback));\n+   |              ^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: within `fn() -> dyn ToString`, the trait `Sized` is not implemented for `dyn ToString`\n+   = note: required because it appears within the type `fn() -> dyn ToString`\n+   = note: required for the cast from `fn() -> dyn ToString` to the object type `dyn Fn() -> (dyn ToString + 'static)`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "de133e5599cf96fb8d0efce000d83a58eb5f957f", "filename": "src/test/ui/type/type-check/assignment-in-if.stderr", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.stderr?ref=1146560e1a53d26d04b33548d4eeb8e083d78509", "patch": "@@ -67,6 +67,9 @@ LL |             x == 5\n error[E0308]: mismatched types\n   --> $DIR/assignment-in-if.rs:44:18\n    |\n+LL |     if y = (Foo { foo: x }) {\n+   |                        - here the type of `x` is inferred to be `usize`\n+...\n LL |     if x == x && x = x && x == x {\n    |        ------    ^ expected `bool`, found `usize`\n    |        |\n@@ -75,6 +78,9 @@ LL |     if x == x && x = x && x == x {\n error[E0308]: mismatched types\n   --> $DIR/assignment-in-if.rs:44:22\n    |\n+LL |     if y = (Foo { foo: x }) {\n+   |                        - here the type of `x` is inferred to be `usize`\n+...\n LL |     if x == x && x = x && x == x {\n    |                      ^ expected `bool`, found `usize`\n \n@@ -92,6 +98,9 @@ LL |     if x == x && x == x && x == x {\n error[E0308]: mismatched types\n   --> $DIR/assignment-in-if.rs:51:28\n    |\n+LL |     if y = (Foo { foo: x }) {\n+   |                        - here the type of `x` is inferred to be `usize`\n+...\n LL |     if x == x && x == x && x = x {\n    |        ----------------    ^ expected `bool`, found `usize`\n    |        |"}, {"sha": "6557d7fa1911afc3fa5ea3a871c762b3fffdf468", "filename": "src/test/ui/type/type-check/point-at-inference-2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-2.rs?ref=1146560e1a53d26d04b33548d4eeb8e083d78509", "patch": "@@ -0,0 +1,13 @@\n+fn bar(_: Vec<i32>) {}\n+fn baz(_: &Vec<&i32>) {}\n+fn main() {\n+    let v = vec![&1];\n+    bar(v); //~ ERROR E0308\n+    let v = vec![];\n+    baz(&v);\n+    baz(&v);\n+    bar(v); //~ ERROR E0308\n+    let v = vec![];\n+    baz(&v);\n+    bar(v); //~ ERROR E0308\n+}"}, {"sha": "13227c5e245bdf9748ab3a4f4f398e09d5ce05b2", "filename": "src/test/ui/type/type-check/point-at-inference-2.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-2.stderr?ref=1146560e1a53d26d04b33548d4eeb8e083d78509", "patch": "@@ -0,0 +1,56 @@\n+error[E0308]: mismatched types\n+  --> $DIR/point-at-inference-2.rs:5:9\n+   |\n+LL |     bar(v);\n+   |     --- ^ expected `i32`, found `&{integer}`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+   = note: expected struct `Vec<i32>`\n+              found struct `Vec<&{integer}>`\n+note: function defined here\n+  --> $DIR/point-at-inference-2.rs:1:4\n+   |\n+LL | fn bar(_: Vec<i32>) {}\n+   |    ^^^ -----------\n+\n+error[E0308]: mismatched types\n+  --> $DIR/point-at-inference-2.rs:9:9\n+   |\n+LL |     baz(&v);\n+   |          - here the type of `v` is inferred to be `Vec<&i32>`\n+LL |     baz(&v);\n+LL |     bar(v);\n+   |     --- ^ expected `i32`, found `&i32`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+   = note: expected struct `Vec<i32>`\n+              found struct `Vec<&i32>`\n+note: function defined here\n+  --> $DIR/point-at-inference-2.rs:1:4\n+   |\n+LL | fn bar(_: Vec<i32>) {}\n+   |    ^^^ -----------\n+\n+error[E0308]: mismatched types\n+  --> $DIR/point-at-inference-2.rs:12:9\n+   |\n+LL |     baz(&v);\n+   |          - here the type of `v` is inferred to be `Vec<&i32>`\n+LL |     bar(v);\n+   |     --- ^ expected `i32`, found `&i32`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+   = note: expected struct `Vec<i32>`\n+              found struct `Vec<&i32>`\n+note: function defined here\n+  --> $DIR/point-at-inference-2.rs:1:4\n+   |\n+LL | fn bar(_: Vec<i32>) {}\n+   |    ^^^ -----------\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "1a960133ceba9ab2f858ed0e099c792b91cb24c0", "filename": "src/test/ui/type/type-check/point-at-inference-3.fixed", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.fixed?ref=1146560e1a53d26d04b33548d4eeb8e083d78509", "patch": "@@ -0,0 +1,12 @@\n+// run-rustfix\n+fn main() {\n+    let mut v = Vec::new();\n+    v.push(0i32);\n+    //~^ NOTE this is of type `i32`, which causes `v` to be inferred as `Vec<i32>`\n+    v.push(0);\n+    v.push(1i32); //~ ERROR mismatched types\n+    //~^ NOTE expected `i32`, found `u32`\n+    //~| NOTE arguments to this method are incorrect\n+    //~| NOTE associated function defined here\n+    //~| HELP change the type of the numeric literal from `u32` to `i32`\n+}"}, {"sha": "92910ae1a31141e82618bda673ae8ae6f55e1ae0", "filename": "src/test/ui/type/type-check/point-at-inference-3.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.rs?ref=1146560e1a53d26d04b33548d4eeb8e083d78509", "patch": "@@ -0,0 +1,12 @@\n+// run-rustfix\n+fn main() {\n+    let mut v = Vec::new();\n+    v.push(0i32);\n+    //~^ NOTE this is of type `i32`, which causes `v` to be inferred as `Vec<i32>`\n+    v.push(0);\n+    v.push(1u32); //~ ERROR mismatched types\n+    //~^ NOTE expected `i32`, found `u32`\n+    //~| NOTE arguments to this method are incorrect\n+    //~| NOTE associated function defined here\n+    //~| HELP change the type of the numeric literal from `u32` to `i32`\n+}"}, {"sha": "999c3148362f615873293e4869fc2cea0682dd8c", "filename": "src/test/ui/type/type-check/point-at-inference-3.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.stderr?ref=1146560e1a53d26d04b33548d4eeb8e083d78509", "patch": "@@ -0,0 +1,21 @@\n+error[E0308]: mismatched types\n+  --> $DIR/point-at-inference-3.rs:7:12\n+   |\n+LL |     v.push(0i32);\n+   |            ---- this is of type `i32`, which causes `v` to be inferred as `Vec<i32>`\n+...\n+LL |     v.push(1u32);\n+   |       ---- ^^^^ expected `i32`, found `u32`\n+   |       |\n+   |       arguments to this method are incorrect\n+   |\n+note: associated function defined here\n+  --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n+help: change the type of the numeric literal from `u32` to `i32`\n+   |\n+LL |     v.push(1i32);\n+   |             ~~~\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "f41fbe59fba6c26b67786c9791f1bebc0d930273", "filename": "src/test/ui/type/type-check/point-at-inference.fixed", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.fixed?ref=1146560e1a53d26d04b33548d4eeb8e083d78509", "patch": "@@ -0,0 +1,13 @@\n+// run-rustfix\n+fn bar(_: Vec<i32>) {}\n+fn baz(_: &impl std::any::Any) {}\n+fn main() {\n+    let v = vec![1, 2, 3, 4, 5];\n+    let mut foo = vec![];\n+    baz(&foo);\n+    for i in &v {\n+        foo.push(*i);\n+    }\n+    baz(&foo);\n+    bar(foo); //~ ERROR E0308\n+}"}, {"sha": "6419e42e70d12512c8bab82eac5d40f5f6a79e7a", "filename": "src/test/ui/type/type-check/point-at-inference.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.rs?ref=1146560e1a53d26d04b33548d4eeb8e083d78509", "patch": "@@ -0,0 +1,13 @@\n+// run-rustfix\n+fn bar(_: Vec<i32>) {}\n+fn baz(_: &impl std::any::Any) {}\n+fn main() {\n+    let v = vec![1, 2, 3, 4, 5];\n+    let mut foo = vec![];\n+    baz(&foo);\n+    for i in &v {\n+        foo.push(i);\n+    }\n+    baz(&foo);\n+    bar(foo); //~ ERROR E0308\n+}"}, {"sha": "70428fe841b9c9425127119005f37b6cb480a7d0", "filename": "src/test/ui/type/type-check/point-at-inference.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.stderr?ref=1146560e1a53d26d04b33548d4eeb8e083d78509", "patch": "@@ -0,0 +1,26 @@\n+error[E0308]: mismatched types\n+  --> $DIR/point-at-inference.rs:12:9\n+   |\n+LL |         foo.push(i);\n+   |                  - this is of type `&{integer}`, which causes `foo` to be inferred as `Vec<&{integer}>`\n+...\n+LL |     bar(foo);\n+   |     --- ^^^ expected `i32`, found `&{integer}`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+   = note: expected struct `Vec<i32>`\n+              found struct `Vec<&{integer}>`\n+note: function defined here\n+  --> $DIR/point-at-inference.rs:2:4\n+   |\n+LL | fn bar(_: Vec<i32>) {}\n+   |    ^^^ -----------\n+help: consider dereferencing the borrow\n+   |\n+LL |         foo.push(*i);\n+   |                  +\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "bf01751d5f6eeefb65e3e87765304c878d549783", "filename": "src/test/ui/typeck/issue-105946.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftest%2Fui%2Ftypeck%2Fissue-105946.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftest%2Fui%2Ftypeck%2Fissue-105946.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-105946.rs?ref=1146560e1a53d26d04b33548d4eeb8e083d78509", "patch": "@@ -0,0 +1,12 @@\n+fn digit() -> str {\n+  return {};\n+  //~^ ERROR: mismatched types [E0308]\n+}\n+fn main() {\n+    let [_y..] = [box 1, box 2];\n+    //~^ ERROR: cannot find value `_y` in this scope [E0425]\n+    //~| ERROR: `X..` patterns in slices are experimental [E0658]\n+    //~| ERROR: box expression syntax is experimental; you can call `Box::new` instead [E0658]\n+    //~| ERROR: box expression syntax is experimental; you can call `Box::new` instead [E0658]\n+    //~| ERROR: pattern requires 1 element but array has 2 [E0527]\n+}"}, {"sha": "d803de4df47276ebdd70a8f345d7eb0f075b51cd", "filename": "src/test/ui/typeck/issue-105946.stderr", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftest%2Fui%2Ftypeck%2Fissue-105946.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftest%2Fui%2Ftypeck%2Fissue-105946.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-105946.stderr?ref=1146560e1a53d26d04b33548d4eeb8e083d78509", "patch": "@@ -0,0 +1,49 @@\n+error[E0425]: cannot find value `_y` in this scope\n+  --> $DIR/issue-105946.rs:6:10\n+   |\n+LL |     let [_y..] = [box 1, box 2];\n+   |          ^^ not found in this scope\n+\n+error[E0658]: `X..` patterns in slices are experimental\n+  --> $DIR/issue-105946.rs:6:10\n+   |\n+LL |     let [_y..] = [box 1, box 2];\n+   |          ^^^^\n+   |\n+   = note: see issue #67264 <https://github.com/rust-lang/rust/issues/67264> for more information\n+   = help: add `#![feature(half_open_range_patterns_in_slices)]` to the crate attributes to enable\n+\n+error[E0658]: box expression syntax is experimental; you can call `Box::new` instead\n+  --> $DIR/issue-105946.rs:6:19\n+   |\n+LL |     let [_y..] = [box 1, box 2];\n+   |                   ^^^^^\n+   |\n+   = note: see issue #49733 <https://github.com/rust-lang/rust/issues/49733> for more information\n+   = help: add `#![feature(box_syntax)]` to the crate attributes to enable\n+\n+error[E0658]: box expression syntax is experimental; you can call `Box::new` instead\n+  --> $DIR/issue-105946.rs:6:26\n+   |\n+LL |     let [_y..] = [box 1, box 2];\n+   |                          ^^^^^\n+   |\n+   = note: see issue #49733 <https://github.com/rust-lang/rust/issues/49733> for more information\n+   = help: add `#![feature(box_syntax)]` to the crate attributes to enable\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-105946.rs:2:10\n+   |\n+LL |   return {};\n+   |          ^^ expected `str`, found `()`\n+\n+error[E0527]: pattern requires 1 element but array has 2\n+  --> $DIR/issue-105946.rs:6:9\n+   |\n+LL |     let [_y..] = [box 1, box 2];\n+   |         ^^^^^^ expected 2 elements\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors have detailed explanations: E0308, E0425, E0527, E0658.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "2701ad917bb0954febe9554c1a0db24d85663a47", "filename": "src/tools/error_index_generator/book_config.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftools%2Ferror_index_generator%2Fbook_config.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftools%2Ferror_index_generator%2Fbook_config.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fbook_config.toml?ref=1146560e1a53d26d04b33548d4eeb8e083d78509", "patch": "@@ -7,6 +7,7 @@ src = \"\"\n git-repository-url = \"https://github.com/rust-lang/rust/\"\n additional-css = [\"error-index.css\"]\n additional-js = [\"error-index.js\"]\n+input-404 = \"\"\n \n [output.html.search]\n enable = true"}, {"sha": "98eda97e236cbf3642a85da5551e79ef1cd980d4", "filename": "src/tools/error_index_generator/main.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fmain.rs?ref=1146560e1a53d26d04b33548d4eeb8e083d78509", "patch": "@@ -98,8 +98,7 @@ fn add_rust_attribute_on_codeblock(explanation: &str) -> String {\n \n fn render_html(output_path: &Path) -> Result<(), Box<dyn Error>> {\n     let mut introduction = format!(\n-        \"<script src='redirect.js'></script>\n-# Rust error codes index\n+        \"# Rust error codes index\n \n This page lists all the error codes emitted by the Rust compiler.\n \n@@ -149,7 +148,12 @@ This page lists all the error codes emitted by the Rust compiler.\n     book.book.sections.push(BookItem::Chapter(chapter));\n     book.build()?;\n \n-    // We can't put this content into another file, otherwise `mbdbook` will also put it into the\n+    // The error-index used to be generated manually (without mdbook), and the\n+    // index was located at the top level. Now that it is generated with\n+    // mdbook, error-index.html has moved to error_codes/error-index.html.\n+    // This adds a redirect so that old links go to the new location.\n+    //\n+    // We can't put this content into another file, otherwise `mdbook` will also put it into the\n     // output directory, making a duplicate.\n     fs::write(\n         output_path.join(\"error-index.html\"),\n@@ -163,14 +167,10 @@ This page lists all the error codes emitted by the Rust compiler.\n     </head>\n     <body>\n         <div>If you are not automatically redirected to the error code index, please <a id=\"index-link\" href=\"./error_codes/error-index.html\">here</a>.\n-        <script>document.getElementById(\"index-link\").click()</script>\n     </body>\n </html>\"#,\n     )?;\n \n-    // No need for a 404 file, it's already handled by the server.\n-    fs::remove_file(output_path.join(\"error_codes/404.html\"))?;\n-\n     Ok(())\n }\n "}, {"sha": "c80cbf297afffeab665939ebfd2491e21ceace1c", "filename": "src/tools/error_index_generator/redirect.js", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftools%2Ferror_index_generator%2Fredirect.js", "raw_url": "https://github.com/rust-lang/rust/raw/1146560e1a53d26d04b33548d4eeb8e083d78509/src%2Ftools%2Ferror_index_generator%2Fredirect.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fredirect.js?ref=1146560e1a53d26d04b33548d4eeb8e083d78509", "patch": "@@ -3,14 +3,10 @@\n         let code = window.location.hash.replace(/^#/, '');\n         // We have to make sure this pattern matches to avoid inadvertently creating an\n         // open redirect.\n-        if (!/^E[0-9]+$/.test(code)) {\n+        if (/^E[0-9]+$/.test(code)) {\n+            window.location.replace('./error_codes/' + code + '.html');\n             return;\n         }\n-        if (window.location.pathname.indexOf(\"/error_codes/\") !== -1) {\n-            // We're not at the top level, so we don't prepend with \"./error_codes/\".\n-            window.location = './' + code + '.html';\n-        } else {\n-            window.location = './error_codes/' + code + '.html';\n-        }\n     }\n+    window.location.replace('./error_codes/error-index.html');\n })()"}]}