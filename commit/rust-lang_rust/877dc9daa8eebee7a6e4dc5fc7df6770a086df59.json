{"sha": "877dc9daa8eebee7a6e4dc5fc7df6770a086df59", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3N2RjOWRhYThlZWJlZTdhNmU0ZGM1ZmM3ZGY2NzcwYTA4NmRmNTk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-22T01:40:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-22T01:40:03Z"}, "message": "Rollup merge of #67439 - Centril:clean-hair-slice, r=matthewjasper\n\nCleanup `lower_pattern_unadjusted` & Improve slice pat typeck\n\nFollowing up on https://github.com/rust-lang/rust/pull/67318, in this PR, the HAIR lowering of patterns (`lower_pattern_unadjusted`) is cleaned up with a focus on slice patterns (in particular, some dead code is removed). Moreover, `check_pat_slice` is refactored some more.\n\nr? @matthewjasper", "tree": {"sha": "97f8f018315c532bc1aee3ee0fbaf84fa8366369", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97f8f018315c532bc1aee3ee0fbaf84fa8366369"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/877dc9daa8eebee7a6e4dc5fc7df6770a086df59", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd/slzCRBK7hj4Ov3rIwAAdHIIAGCFpgzmF7k36yUxHN41pCM1\nDDq4IUA0NR4GwJm3bUHTYzaz7BxUlAJNZh+yUDsBZ3kdfoVEL1bl1Lv7RMeVXLqf\nOocSnL/cd5NTRSlQU61esifqslKNue2qNCRCvppAJGn3l7jTs1Ngpr0KHO6xtOKN\ny1j0IxINYozAl4Z6lNSR4qig/AlbUCjfwCJi9xnn4hR2q3l588mZOYalqHzTtomH\nrHwcvX7JtnbLdET92febzz8rC2kFenNnk0F0GYQIr54YIg6gslHzJRnm1TT6CW87\nEcbmIjuI4VSYgkTw8wbX/r6oRMZagg7grMO2tRkvd8caoUVF8KX2DXjMGCF6j0I=\n=qBN2\n-----END PGP SIGNATURE-----\n", "payload": "tree 97f8f018315c532bc1aee3ee0fbaf84fa8366369\nparent 35ff2f1df3ee2cd51edf2bbeddec474b970987fc\nparent 7353ff20d66267df821d9d161b914ef8fc513304\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1576978803 +0100\ncommitter GitHub <noreply@github.com> 1576978803 +0100\n\nRollup merge of #67439 - Centril:clean-hair-slice, r=matthewjasper\n\nCleanup `lower_pattern_unadjusted` & Improve slice pat typeck\n\nFollowing up on https://github.com/rust-lang/rust/pull/67318, in this PR, the HAIR lowering of patterns (`lower_pattern_unadjusted`) is cleaned up with a focus on slice patterns (in particular, some dead code is removed). Moreover, `check_pat_slice` is refactored some more.\n\nr? @matthewjasper\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/877dc9daa8eebee7a6e4dc5fc7df6770a086df59", "html_url": "https://github.com/rust-lang/rust/commit/877dc9daa8eebee7a6e4dc5fc7df6770a086df59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/877dc9daa8eebee7a6e4dc5fc7df6770a086df59/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35ff2f1df3ee2cd51edf2bbeddec474b970987fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/35ff2f1df3ee2cd51edf2bbeddec474b970987fc", "html_url": "https://github.com/rust-lang/rust/commit/35ff2f1df3ee2cd51edf2bbeddec474b970987fc"}, {"sha": "7353ff20d66267df821d9d161b914ef8fc513304", "url": "https://api.github.com/repos/rust-lang/rust/commits/7353ff20d66267df821d9d161b914ef8fc513304", "html_url": "https://github.com/rust-lang/rust/commit/7353ff20d66267df821d9d161b914ef8fc513304"}], "stats": {"total": 258, "additions": 96, "deletions": 162}, "files": [{"sha": "f267be812c3d276ccfc90f45f27e986068e142a9", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/877dc9daa8eebee7a6e4dc5fc7df6770a086df59/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/877dc9daa8eebee7a6e4dc5fc7df6770a086df59/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=877dc9daa8eebee7a6e4dc5fc7df6770a086df59", "patch": "@@ -620,10 +620,11 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n enum SliceKind {\n     /// Patterns of length `n` (`[x, y]`).\n     FixedLen(u64),\n-    /// Patterns using the `..` notation (`[x, .., y]`). Captures any array constructor of `length\n-    /// >= i + j`. In the case where `array_len` is `Some(_)`, this indicates that we only care\n-    /// about the first `i` and the last `j` values of the array, and everything in between is a\n-    /// wildcard `_`.\n+    /// Patterns using the `..` notation (`[x, .., y]`).\n+    /// Captures any array constructor of `length >= i + j`.\n+    /// In the case where `array_len` is `Some(_)`,\n+    /// this indicates that we only care about the first `i` and the last `j` values of the array,\n+    /// and everything in between is a wildcard `_`.\n     VarLen(u64, u64),\n }\n "}, {"sha": "9d0a67151fb60083e7f86032277cdce3852234f6", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 41, "deletions": 121, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/877dc9daa8eebee7a6e4dc5fc7df6770a086df59/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/877dc9daa8eebee7a6e4dc5fc7df6770a086df59/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=877dc9daa8eebee7a6e4dc5fc7df6770a086df59", "patch": "@@ -445,6 +445,11 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat) -> Pat<'tcx> {\n         let mut ty = self.tables.node_type(pat.hir_id);\n \n+        if let ty::Error = ty.kind {\n+            // Avoid ICEs (e.g., #50577 and #50585).\n+            return Pat { span: pat.span, ty, kind: Box::new(PatKind::Wild) };\n+        }\n+\n         let kind = match pat.kind {\n             hir::PatKind::Wild => PatKind::Wild,\n \n@@ -544,57 +549,19 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             }\n \n             hir::PatKind::Slice(ref prefix, ref slice, ref suffix) => {\n-                match ty.kind {\n-                    ty::Ref(_, ty, _) =>\n-                        PatKind::Deref {\n-                            subpattern: Pat {\n-                                ty,\n-                                span: pat.span,\n-                                kind: Box::new(self.slice_or_array_pattern(\n-                                    pat.span, ty, prefix, slice, suffix))\n-                            },\n-                        },\n-                    ty::Slice(..) |\n-                    ty::Array(..) =>\n-                        self.slice_or_array_pattern(pat.span, ty, prefix, slice, suffix),\n-                    ty::Error => { // Avoid ICE\n-                        return Pat { span: pat.span, ty, kind: Box::new(PatKind::Wild) };\n-                    }\n-                    _ =>\n-                        span_bug!(\n-                            pat.span,\n-                            \"unexpanded type for vector pattern: {:?}\",\n-                            ty),\n-                }\n+                self.slice_or_array_pattern(pat.span, ty, prefix, slice, suffix)\n             }\n \n-            hir::PatKind::Tuple(ref subpatterns, ddpos) => {\n-                match ty.kind {\n-                    ty::Tuple(ref tys) => {\n-                        let subpatterns =\n-                            subpatterns.iter()\n-                                       .enumerate_and_adjust(tys.len(), ddpos)\n-                                       .map(|(i, subpattern)| FieldPat {\n-                                            field: Field::new(i),\n-                                            pattern: self.lower_pattern(subpattern)\n-                                       })\n-                                       .collect();\n-\n-                        PatKind::Leaf { subpatterns }\n-                    }\n-                    ty::Error => { // Avoid ICE (#50577)\n-                        return Pat { span: pat.span, ty, kind: Box::new(PatKind::Wild) };\n-                    }\n+            hir::PatKind::Tuple(ref pats, ddpos) => {\n+                let tys = match ty.kind {\n+                    ty::Tuple(ref tys) => tys,\n                     _ => span_bug!(pat.span, \"unexpected type for tuple pattern: {:?}\", ty),\n-                }\n+                };\n+                let subpatterns = self.lower_tuple_subpats(pats, tys.len(), ddpos);\n+                PatKind::Leaf { subpatterns }\n             }\n \n             hir::PatKind::Binding(_, id, ident, ref sub) => {\n-                let var_ty = self.tables.node_type(pat.hir_id);\n-                if let ty::Error = var_ty.kind {\n-                    // Avoid ICE\n-                    return Pat { span: pat.span, ty, kind: Box::new(PatKind::Wild) };\n-                };\n                 let bm = *self.tables.pat_binding_modes().get(pat.hir_id)\n                                                          .expect(\"missing binding mode\");\n                 let (mutability, mode) = match bm {\n@@ -609,13 +576,14 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n \n                 // A ref x pattern is the same node used for x, and as such it has\n                 // x's type, which is &T, where we want T (the type being matched).\n+                let var_ty = ty;\n                 if let ty::BindByReference(_) = bm {\n                     if let ty::Ref(_, rty, _) = ty.kind {\n                         ty = rty;\n                     } else {\n                         bug!(\"`ref {}` has wrong type {}\", ident, ty);\n                     }\n-                }\n+                };\n \n                 PatKind::Binding {\n                     mutability,\n@@ -627,28 +595,14 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 }\n             }\n \n-            hir::PatKind::TupleStruct(ref qpath, ref subpatterns, ddpos) => {\n+            hir::PatKind::TupleStruct(ref qpath, ref pats, ddpos) => {\n                 let res = self.tables.qpath_res(qpath, pat.hir_id);\n                 let adt_def = match ty.kind {\n                     ty::Adt(adt_def, _) => adt_def,\n-                    ty::Error => { // Avoid ICE (#50585)\n-                        return Pat { span: pat.span, ty, kind: Box::new(PatKind::Wild) };\n-                    }\n-                    _ => span_bug!(pat.span,\n-                                   \"tuple struct pattern not applied to an ADT {:?}\",\n-                                   ty),\n+                    _ => span_bug!(pat.span, \"tuple struct pattern not applied to an ADT {:?}\", ty),\n                 };\n                 let variant_def = adt_def.variant_of_res(res);\n-\n-                let subpatterns =\n-                        subpatterns.iter()\n-                                   .enumerate_and_adjust(variant_def.fields.len(), ddpos)\n-                                   .map(|(i, field)| FieldPat {\n-                                       field: Field::new(i),\n-                                       pattern: self.lower_pattern(field),\n-                                   })\n-                    .collect();\n-\n+                let subpatterns = self.lower_tuple_subpats(pats, variant_def.fields.len(), ddpos);\n                 self.lower_variant_or_leaf(res, pat.hir_id, pat.span, ty, subpatterns)\n             }\n \n@@ -668,11 +622,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 self.lower_variant_or_leaf(res, pat.hir_id, pat.span, ty, subpatterns)\n             }\n \n-            hir::PatKind::Or(ref pats) => {\n-                PatKind::Or {\n-                    pats: pats.iter().map(|p| self.lower_pattern(p)).collect(),\n-                }\n-            }\n+            hir::PatKind::Or(ref pats) => PatKind::Or { pats: self.lower_patterns(pats) },\n         };\n \n         Pat {\n@@ -682,80 +632,50 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn lower_tuple_subpats(\n+        &mut self,\n+        pats: &'tcx [P<hir::Pat>],\n+        expected_len: usize,\n+        gap_pos: Option<usize>,\n+    ) -> Vec<FieldPat<'tcx>> {\n+        pats.iter()\n+            .enumerate_and_adjust(expected_len, gap_pos)\n+            .map(|(i, subpattern)| FieldPat {\n+                field: Field::new(i),\n+                pattern: self.lower_pattern(subpattern)\n+            })\n+            .collect()\n+    }\n+\n     fn lower_patterns(&mut self, pats: &'tcx [P<hir::Pat>]) -> Vec<Pat<'tcx>> {\n         pats.iter().map(|p| self.lower_pattern(p)).collect()\n     }\n \n-    fn lower_opt_pattern(&mut self, pat: &'tcx Option<P<hir::Pat>>) -> Option<Pat<'tcx>>\n-    {\n+    fn lower_opt_pattern(&mut self, pat: &'tcx Option<P<hir::Pat>>) -> Option<Pat<'tcx>> {\n         pat.as_ref().map(|p| self.lower_pattern(p))\n     }\n \n-    fn flatten_nested_slice_patterns(\n-        &mut self,\n-        prefix: Vec<Pat<'tcx>>,\n-        slice: Option<Pat<'tcx>>,\n-        suffix: Vec<Pat<'tcx>>)\n-        -> (Vec<Pat<'tcx>>, Option<Pat<'tcx>>, Vec<Pat<'tcx>>)\n-    {\n-        let orig_slice = match slice {\n-            Some(orig_slice) => orig_slice,\n-            None => return (prefix, slice, suffix)\n-        };\n-        let orig_prefix = prefix;\n-        let orig_suffix = suffix;\n-\n-        // dance because of intentional borrow-checker stupidity.\n-        let kind = *orig_slice.kind;\n-        match kind {\n-            PatKind::Slice { prefix, slice, mut suffix } |\n-            PatKind::Array { prefix, slice, mut suffix } => {\n-                let mut orig_prefix = orig_prefix;\n-\n-                orig_prefix.extend(prefix);\n-                suffix.extend(orig_suffix);\n-\n-                (orig_prefix, slice, suffix)\n-            }\n-            _ => {\n-                (orig_prefix, Some(Pat {\n-                    kind: box kind, ..orig_slice\n-                }), orig_suffix)\n-            }\n-        }\n-    }\n-\n     fn slice_or_array_pattern(\n         &mut self,\n         span: Span,\n         ty: Ty<'tcx>,\n         prefix: &'tcx [P<hir::Pat>],\n         slice: &'tcx Option<P<hir::Pat>>,\n-        suffix: &'tcx [P<hir::Pat>])\n-        -> PatKind<'tcx>\n-    {\n+        suffix: &'tcx [P<hir::Pat>],\n+    ) -> PatKind<'tcx> {\n         let prefix = self.lower_patterns(prefix);\n         let slice = self.lower_opt_pattern(slice);\n         let suffix = self.lower_patterns(suffix);\n-        let (prefix, slice, suffix) =\n-            self.flatten_nested_slice_patterns(prefix, slice, suffix);\n-\n         match ty.kind {\n-            ty::Slice(..) => {\n-                // matching a slice or fixed-length array\n-                PatKind::Slice { prefix: prefix, slice: slice, suffix: suffix }\n-            }\n-\n+            // Matching a slice, `[T]`.\n+            ty::Slice(..) => PatKind::Slice { prefix, slice, suffix },\n+            // Fixed-length array, `[T; len]`.\n             ty::Array(_, len) => {\n-                // fixed-length array\n                 let len = len.eval_usize(self.tcx, self.param_env);\n                 assert!(len >= prefix.len() as u64 + suffix.len() as u64);\n-                PatKind::Array { prefix: prefix, slice: slice, suffix: suffix }\n-            }\n-\n-            _ => {\n-                span_bug!(span, \"bad slice pattern type {:?}\", ty);\n+                PatKind::Array { prefix, slice, suffix }\n             }\n+            _ => span_bug!(span, \"bad slice pattern type {:?}\", ty),\n         }\n     }\n "}, {"sha": "ec6439c6d77295a8acde46ac86350a93e1a1b139", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 50, "deletions": 37, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/877dc9daa8eebee7a6e4dc5fc7df6770a086df59/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/877dc9daa8eebee7a6e4dc5fc7df6770a086df59/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=877dc9daa8eebee7a6e4dc5fc7df6770a086df59", "patch": "@@ -1174,47 +1174,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         def_bm: BindingMode,\n         discrim_span: Option<Span>,\n     ) -> Ty<'tcx> {\n-        let tcx = self.tcx;\n-        let expected_ty = self.structurally_resolved_type(span, expected);\n-        let (inner_ty, slice_ty) = match expected_ty.kind {\n+        let err = self.tcx.types.err;\n+        let expected = self.structurally_resolved_type(span, expected);\n+        let (inner_ty, slice_ty, expected) = match expected.kind {\n             // An array, so we might have something like `let [a, b, c] = [0, 1, 2];`.\n-            ty::Array(inner_ty, size) => {\n-                let slice_ty = if let Some(size) = size.try_eval_usize(tcx, self.param_env) {\n-                    // Now we know the length...\n-                    let min_len = before.len() as u64 + after.len() as u64;\n-                    if slice.is_none() {\n-                        // ...and since there is no variable-length pattern,\n-                        // we require an exact match between the number of elements\n-                        // in the array pattern and as provided by the matched type.\n-                        if min_len != size {\n-                            self.error_scrutinee_inconsistent_length(span, min_len, size)\n-                        }\n-                        tcx.types.err\n-                    } else if let Some(rest) = size.checked_sub(min_len) {\n-                        // The variable-length pattern was there,\n-                        // so it has an array type with the remaining elements left as its size...\n-                        tcx.mk_array(inner_ty, rest)\n-                    } else {\n-                        // ...however, in this case, there were no remaining elements.\n-                        // That is, the slice pattern requires more than the array type offers.\n-                        self.error_scrutinee_with_rest_inconsistent_length(span, min_len, size);\n-                        tcx.types.err\n-                    }\n-                } else {\n-                    // No idea what the length is, which happens if we have e.g.,\n-                    // `let [a, b] = arr` where `arr: [T; N]` where `const N: usize`.\n-                    self.error_scrutinee_unfixed_length(span);\n-                    tcx.types.err\n-                };\n-                (inner_ty, slice_ty)\n+            ty::Array(inner_ty, len) => {\n+                let min = before.len() as u64 + after.len() as u64;\n+                let slice_ty = self.check_array_pat_len(span, slice, len, min)\n+                    .map_or(err, |len| self.tcx.mk_array(inner_ty, len));\n+                (inner_ty, slice_ty, expected)\n             }\n-            ty::Slice(inner_ty) => (inner_ty, expected_ty),\n+            ty::Slice(inner_ty) => (inner_ty, expected, expected),\n             // The expected type must be an array or slice, but was neither, so error.\n             _ => {\n-                if !expected_ty.references_error() {\n-                    self.error_expected_array_or_slice(span, expected_ty);\n+                if !expected.references_error() {\n+                    self.error_expected_array_or_slice(span, expected);\n                 }\n-                (tcx.types.err, tcx.types.err)\n+                (err, err, err)\n             }\n         };\n \n@@ -1230,7 +1206,44 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         for elt in after {\n             self.check_pat(&elt, inner_ty, def_bm, discrim_span);\n         }\n-        expected_ty\n+        expected\n+    }\n+\n+    /// Type check the length of an array pattern.\n+    ///\n+    /// Return the length of the variable length pattern,\n+    /// if it exists and there are no errors.\n+    fn check_array_pat_len(\n+        &self,\n+        span: Span,\n+        slice: Option<&'tcx Pat>,\n+        len: &ty::Const<'tcx>,\n+        min_len: u64,\n+    ) -> Option<u64> {\n+        if let Some(len) = len.try_eval_usize(self.tcx, self.param_env) {\n+            // Now we know the length...\n+            if slice.is_none() {\n+                // ...and since there is no variable-length pattern,\n+                // we require an exact match between the number of elements\n+                // in the array pattern and as provided by the matched type.\n+                if min_len != len {\n+                    self.error_scrutinee_inconsistent_length(span, min_len, len);\n+                }\n+            } else if let r @ Some(_) = len.checked_sub(min_len) {\n+                // The variable-length pattern was there,\n+                // so it has an array type with the remaining elements left as its size...\n+                return r;\n+            } else {\n+                // ...however, in this case, there were no remaining elements.\n+                // That is, the slice pattern requires more than the array type offers.\n+                self.error_scrutinee_with_rest_inconsistent_length(span, min_len, len);\n+            }\n+        } else {\n+            // No idea what the length is, which happens if we have e.g.,\n+            // `let [a, b] = arr` where `arr: [T; N]` where `const N: usize`.\n+            self.error_scrutinee_unfixed_length(span);\n+        }\n+        None\n     }\n \n     fn error_scrutinee_inconsistent_length(&self, span: Span, min_len: u64, size: u64) {"}]}