{"sha": "a7f375789bab1a4e4a291c963081a8ca7d2b6bd7", "node_id": "C_kwDOAAsO6NoAKGE3ZjM3NTc4OWJhYjFhNGU0YTI5MWM5NjMwODFhOGNhN2QyYjZiZDc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-26T12:10:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-26T12:10:54Z"}, "message": "Auto merge of #91840 - JakobDegen:fix_early_otherwise, r=oli-obk\n\nFix the unsoundness in the `early_otherwise_branch` mir opt pass\n\nCloses #78496 .\n\nThis change is a significant rewrite of much of the pass. Exactly what it does is documented in the source file (with ascii art!), and all the changes that are made to the MIR that are not trivially sound are carefully documented. That being said, this is my first time touching MIR, so there are probably some invariants I did not know about that I broke.\n\nThis version of the optimization is also somewhat more flexible than the original; for example, we do not care how or where the value on which the parent is switching is computed. There is no requirement that any types be the same. This could be made even more flexible in the future by allowing a wider range of statements in the bodies of `BBC, BBD` (as long as they are all the same of course). This should be a good first step though.\n\nProbably needs a perf run.\n\nr? `@oli-obk` who reviewed things the last time this was touched", "tree": {"sha": "5cdf6442b3247b01ed8199acb554575cfe3883fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5cdf6442b3247b01ed8199acb554575cfe3883fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7", "html_url": "https://github.com/rust-lang/rust/commit/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "788b1fe5b79a8b74215022f9df49b0eae68a50b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/788b1fe5b79a8b74215022f9df49b0eae68a50b9", "html_url": "https://github.com/rust-lang/rust/commit/788b1fe5b79a8b74215022f9df49b0eae68a50b9"}, {"sha": "c0c13b709e4a5ffb2ef1799d606719b4b5ad9e3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0c13b709e4a5ffb2ef1799d606719b4b5ad9e3a", "html_url": "https://github.com/rust-lang/rust/commit/c0c13b709e4a5ffb2ef1799d606719b4b5ad9e3a"}], "stats": {"total": 897, "additions": 526, "deletions": 371}, "files": [{"sha": "9a6b6532ce88f00ef97f99e769b4ee73b9b1fc16", "filename": "compiler/rustc_mir_transform/src/early_otherwise_branch.rs", "status": "modified", "additions": 307, "deletions": 274, "changes": 581, "blob_url": "https://github.com/rust-lang/rust/blob/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7/compiler%2Frustc_mir_transform%2Fsrc%2Fearly_otherwise_branch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7/compiler%2Frustc_mir_transform%2Fsrc%2Fearly_otherwise_branch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fearly_otherwise_branch.rs?ref=a7f375789bab1a4e4a291c963081a8ca7d2b6bd7", "patch": "@@ -1,12 +1,12 @@\n use rustc_middle::mir::patch::MirPatch;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::{Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use std::fmt::Debug;\n \n use super::simplify::simplify_cfg;\n \n /// This pass optimizes something like\n-/// ```text\n+/// ```ignore (syntax-highlighting-only)\n /// let x: Option<()>;\n /// let y: Option<()>;\n /// match (x,y) {\n@@ -15,144 +15,201 @@ use super::simplify::simplify_cfg;\n /// }\n /// ```\n /// into something like\n-/// ```text\n+/// ```ignore (syntax-highlighting-only)\n /// let x: Option<()>;\n /// let y: Option<()>;\n-/// let discriminant_x = // get discriminant of x\n-/// let discriminant_y = // get discriminant of y\n-/// if discriminant_x != discriminant_y || discriminant_x == None {1} else {0}\n+/// let discriminant_x = std::mem::discriminant(x);\n+/// let discriminant_y = std::mem::discriminant(y);\n+/// if discriminant_x == discriminant_y {\n+///     match x {\n+///         Some(_) => 0,\n+///         _ => 1, // <----\n+///     } //               | Actually the same bb\n+/// } else { //            |\n+///     1 // <--------------\n+/// }\n+/// ```\n+///\n+/// Specifically, it looks for instances of control flow like this:\n+/// ```text\n+///\n+///     =================\n+///     |      BB1      |\n+///     |---------------|                  ============================\n+///     |     ...       |         /------> |            BBC           |\n+///     |---------------|         |        |--------------------------|\n+///     |  switchInt(Q) |         |        |   _cl = discriminant(P)  |\n+///     |       c       | --------/        |--------------------------|\n+///     |       d       | -------\\         |       switchInt(_cl)     |\n+///     |      ...      |        |         |            c             | ---> BBC.2\n+///     |    otherwise  | --\\    |    /--- |         otherwise        |\n+///     =================   |    |    |    ============================\n+///                         |    |    |\n+///     =================   |    |    |\n+///     |      BBU      | <-|    |    |    ============================\n+///     |---------------|   |    \\-------> |            BBD           |\n+///     |---------------|   |         |    |--------------------------|\n+///     |  unreachable  |   |         |    |   _dl = discriminant(P)  |\n+///     =================   |         |    |--------------------------|\n+///                         |         |    |       switchInt(_dl)     |\n+///     =================   |         |    |            d             | ---> BBD.2\n+///     |      BB9      | <--------------- |         otherwise        |\n+///     |---------------|                  ============================\n+///     |      ...      |\n+///     =================\n /// ```\n+/// Where the `otherwise` branch on `BB1` is permitted to either go to `BBU` or to `BB9`. In the\n+/// code:\n+///  - `BB1` is `parent` and `BBC, BBD` are children\n+///  - `P` is `child_place`\n+///  - `child_ty` is the type of `_cl`.\n+///  - `Q` is `parent_op`.\n+///  - `parent_ty` is the type of `Q`.\n+///  - `BB9` is `destination`\n+/// All this is then transformed into:\n+/// ```text\n+///\n+///     =======================\n+///     |          BB1        |\n+///     |---------------------|                  ============================\n+///     |          ...        |         /------> |           BBEq           |\n+///     | _s = discriminant(P)|         |        |--------------------------|\n+///     | _t = Ne(Q, _s)      |         |        |--------------------------|\n+///     |---------------------|         |        |       switchInt(Q)       |\n+///     |     switchInt(_t)   |         |        |            c             | ---> BBC.2\n+///     |        false        | --------/        |            d             | ---> BBD.2\n+///     |       otherwise     | ---------------- |         otherwise        |\n+///     =======================       |          ============================\n+///                                   |\n+///     =================             |\n+///     |      BB9      | <-----------/\n+///     |---------------|\n+///     |      ...      |\n+///     =================\n+/// ```\n+///\n+/// This is only correct for some `P`, since `P` is now computed outside the original `switchInt`.\n+/// The filter on which `P` are allowed (together with discussion of its correctness) is found in\n+/// `may_hoist`.\n pub struct EarlyOtherwiseBranch;\n \n impl<'tcx> MirPass<'tcx> for EarlyOtherwiseBranch {\n     fn is_enabled(&self, sess: &rustc_session::Session) -> bool {\n-        //  FIXME(#78496)\n-        sess.opts.debugging_opts.unsound_mir_opts && sess.mir_opt_level() >= 3\n+        sess.mir_opt_level() >= 2\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         trace!(\"running EarlyOtherwiseBranch on {:?}\", body.source);\n \n-        // we are only interested in this bb if the terminator is a switchInt\n-        let bbs_with_switch =\n-            body.basic_blocks().iter_enumerated().filter(|(_, bb)| is_switch(bb.terminator()));\n+        let mut should_cleanup = false;\n \n-        let opts_to_apply: Vec<OptimizationToApply<'tcx>> = bbs_with_switch\n-            .flat_map(|(bb_idx, bb)| {\n-                let switch = bb.terminator();\n-                let helper = Helper { body, tcx };\n-                let infos = helper.go(bb, switch)?;\n-                Some(OptimizationToApply { infos, basic_block_first_switch: bb_idx })\n-            })\n-            .collect();\n-\n-        let should_cleanup = !opts_to_apply.is_empty();\n+        // Also consider newly generated bbs in the same pass\n+        for i in 0..body.basic_blocks().len() {\n+            let bbs = body.basic_blocks();\n+            let parent = BasicBlock::from_usize(i);\n+            let Some(opt_data) = evaluate_candidate(tcx, body, parent) else {\n+                continue\n+            };\n \n-        for opt_to_apply in opts_to_apply {\n-            if !tcx.consider_optimizing(|| format!(\"EarlyOtherwiseBranch {:?}\", &opt_to_apply)) {\n+            if !tcx.consider_optimizing(|| format!(\"EarlyOtherwiseBranch {:?}\", &opt_data)) {\n                 break;\n             }\n \n-            trace!(\"SUCCESS: found optimization possibility to apply: {:?}\", &opt_to_apply);\n+            trace!(\"SUCCESS: found optimization possibility to apply: {:?}\", &opt_data);\n \n-            let statements_before =\n-                body.basic_blocks()[opt_to_apply.basic_block_first_switch].statements.len();\n-            let end_of_block_location = Location {\n-                block: opt_to_apply.basic_block_first_switch,\n-                statement_index: statements_before,\n+            should_cleanup = true;\n+\n+            let TerminatorKind::SwitchInt {\n+                discr: parent_op,\n+                switch_ty: parent_ty,\n+                targets: parent_targets\n+            } = &bbs[parent].terminator().kind else {\n+                unreachable!()\n+            };\n+            // Always correct since we can only switch on `Copy` types\n+            let parent_op = match parent_op {\n+                Operand::Move(x) => Operand::Copy(*x),\n+                Operand::Copy(x) => Operand::Copy(*x),\n+                Operand::Constant(x) => Operand::Constant(x.clone()),\n             };\n+            let statements_before = bbs[parent].statements.len();\n+            let parent_end = Location { block: parent, statement_index: statements_before };\n \n             let mut patch = MirPatch::new(body);\n \n-            // create temp to store second discriminant in\n-            let discr_type = opt_to_apply.infos[0].second_switch_info.discr_ty;\n-            let discr_span = opt_to_apply.infos[0].second_switch_info.discr_source_info.span;\n-            let second_discriminant_temp = patch.new_temp(discr_type, discr_span);\n+            // create temp to store second discriminant in, `_s` in example above\n+            let second_discriminant_temp =\n+                patch.new_temp(opt_data.child_ty, opt_data.child_source.span);\n \n-            patch.add_statement(\n-                end_of_block_location,\n-                StatementKind::StorageLive(second_discriminant_temp),\n-            );\n+            patch.add_statement(parent_end, StatementKind::StorageLive(second_discriminant_temp));\n \n             // create assignment of discriminant\n-            let place_of_adt_to_get_discriminant_of =\n-                opt_to_apply.infos[0].second_switch_info.place_of_adt_discr_read;\n             patch.add_assign(\n-                end_of_block_location,\n+                parent_end,\n                 Place::from(second_discriminant_temp),\n-                Rvalue::Discriminant(place_of_adt_to_get_discriminant_of),\n+                Rvalue::Discriminant(opt_data.child_place),\n             );\n \n-            // create temp to store NotEqual comparison between the two discriminants\n-            let not_equal = BinOp::Ne;\n-            let not_equal_res_type = not_equal.ty(tcx, discr_type, discr_type);\n-            let not_equal_temp = patch.new_temp(not_equal_res_type, discr_span);\n-            patch.add_statement(end_of_block_location, StatementKind::StorageLive(not_equal_temp));\n-\n-            // create NotEqual comparison between the two discriminants\n-            let first_descriminant_place =\n-                opt_to_apply.infos[0].first_switch_info.discr_used_in_switch;\n-            let not_equal_rvalue = Rvalue::BinaryOp(\n-                not_equal,\n-                Box::new((\n-                    Operand::Copy(Place::from(second_discriminant_temp)),\n-                    Operand::Copy(first_descriminant_place),\n-                )),\n+            // create temp to store inequality comparison between the two discriminants, `_t` in\n+            // example above\n+            let nequal = BinOp::Ne;\n+            let comp_res_type = nequal.ty(tcx, parent_ty, opt_data.child_ty);\n+            let comp_temp = patch.new_temp(comp_res_type, opt_data.child_source.span);\n+            patch.add_statement(parent_end, StatementKind::StorageLive(comp_temp));\n+\n+            // create inequality comparison between the two discriminants\n+            let comp_rvalue = Rvalue::BinaryOp(\n+                nequal,\n+                Box::new((parent_op.clone(), Operand::Move(Place::from(second_discriminant_temp)))),\n             );\n             patch.add_statement(\n-                end_of_block_location,\n-                StatementKind::Assign(Box::new((Place::from(not_equal_temp), not_equal_rvalue))),\n+                parent_end,\n+                StatementKind::Assign(Box::new((Place::from(comp_temp), comp_rvalue))),\n             );\n \n-            let new_targets = opt_to_apply\n-                .infos\n-                .iter()\n-                .flat_map(|x| x.second_switch_info.targets_with_values.iter())\n-                .cloned();\n-\n-            let targets = SwitchTargets::new(\n-                new_targets,\n-                opt_to_apply.infos[0].first_switch_info.otherwise_bb,\n-            );\n-\n-            // new block that jumps to the correct discriminant case. This block is switched to if the discriminants are equal\n-            let new_switch_data = BasicBlockData::new(Some(Terminator {\n-                source_info: opt_to_apply.infos[0].second_switch_info.discr_source_info,\n+            let eq_new_targets = parent_targets.iter().map(|(value, child)| {\n+                let TerminatorKind::SwitchInt{ targets, .. } = &bbs[child].terminator().kind else {\n+                    unreachable!()\n+                };\n+                (value, targets.target_for_value(value))\n+            });\n+            let eq_targets = SwitchTargets::new(eq_new_targets, opt_data.destination);\n+\n+            // Create `bbEq` in example above\n+            let eq_switch = BasicBlockData::new(Some(Terminator {\n+                source_info: bbs[parent].terminator().source_info,\n                 kind: TerminatorKind::SwitchInt {\n-                    // the first and second discriminants are equal, so just pick one\n-                    discr: Operand::Copy(first_descriminant_place),\n-                    switch_ty: discr_type,\n-                    targets,\n+                    // switch on the first discriminant, so we can mark the second one as dead\n+                    discr: parent_op,\n+                    switch_ty: opt_data.child_ty,\n+                    targets: eq_targets,\n                 },\n             }));\n \n-            let new_switch_bb = patch.new_block(new_switch_data);\n+            let eq_bb = patch.new_block(eq_switch);\n \n-            // switch on the NotEqual. If true, then jump to the `otherwise` case.\n-            // If false, then jump to a basic block that then jumps to the correct disciminant case\n-            let true_case = opt_to_apply.infos[0].first_switch_info.otherwise_bb;\n-            let false_case = new_switch_bb;\n+            // Jump to it on the basis of the inequality comparison\n+            let true_case = opt_data.destination;\n+            let false_case = eq_bb;\n             patch.patch_terminator(\n-                opt_to_apply.basic_block_first_switch,\n+                parent,\n                 TerminatorKind::if_(\n                     tcx,\n-                    Operand::Move(Place::from(not_equal_temp)),\n+                    Operand::Move(Place::from(comp_temp)),\n                     true_case,\n                     false_case,\n                 ),\n             );\n \n             // generate StorageDead for the second_discriminant_temp not in use anymore\n-            patch.add_statement(\n-                end_of_block_location,\n-                StatementKind::StorageDead(second_discriminant_temp),\n-            );\n+            patch.add_statement(parent_end, StatementKind::StorageDead(second_discriminant_temp));\n \n-            // Generate a StorageDead for not_equal_temp in each of the targets, since we moved it into the switch\n+            // Generate a StorageDead for comp_temp in each of the targets, since we moved it into\n+            // the switch\n             for bb in [false_case, true_case].iter() {\n                 patch.add_statement(\n                     Location { block: *bb, statement_index: 0 },\n-                    StatementKind::StorageDead(not_equal_temp),\n+                    StatementKind::StorageDead(comp_temp),\n                 );\n             }\n \n@@ -167,201 +224,177 @@ impl<'tcx> MirPass<'tcx> for EarlyOtherwiseBranch {\n     }\n }\n \n-fn is_switch(terminator: &Terminator<'_>) -> bool {\n-    matches!(terminator.kind, TerminatorKind::SwitchInt { .. })\n-}\n-\n-struct Helper<'a, 'tcx> {\n-    body: &'a Body<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n-}\n-\n-#[derive(Debug, Clone)]\n-struct SwitchDiscriminantInfo<'tcx> {\n-    /// Type of the discriminant being switched on\n-    discr_ty: Ty<'tcx>,\n-    /// The basic block that the otherwise branch points to\n-    otherwise_bb: BasicBlock,\n-    /// Target along with the value being branched from. Otherwise is not included\n-    targets_with_values: Vec<(u128, BasicBlock)>,\n-    discr_source_info: SourceInfo,\n-    /// The place of the discriminant used in the switch\n-    discr_used_in_switch: Place<'tcx>,\n-    /// The place of the adt that has its discriminant read\n-    place_of_adt_discr_read: Place<'tcx>,\n-    /// The type of the adt that has its discriminant read\n-    type_adt_matched_on: Ty<'tcx>,\n-}\n-\n-#[derive(Debug)]\n-struct OptimizationToApply<'tcx> {\n-    infos: Vec<OptimizationInfo<'tcx>>,\n-    /// Basic block of the original first switch\n-    basic_block_first_switch: BasicBlock,\n+/// Returns true if computing the discriminant of `place` may be hoisted out of the branch\n+fn may_hoist<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, place: Place<'tcx>) -> bool {\n+    for (place, proj) in place.iter_projections() {\n+        match proj {\n+            // Dereferencing in the computation of `place` might cause issues from one of two\n+            // cateogires. First, the referrent might be invalid. We protect against this by\n+            // dereferencing references only (not pointers). Second, the use of a reference may\n+            // invalidate other references that are used later (for aliasing reasons). Consider\n+            // where such an invalidated reference may appear:\n+            //  - In `Q`: Not possible since `Q` is used as the operand of a `SwitchInt` and so\n+            //    cannot contain referenced data.\n+            //  - In `BBU`: Not possible since that block contains only the `unreachable` terminator\n+            //  - In `BBC.2, BBD.2`: Not possible, since `discriminant(P)` was computed prior to\n+            //    reaching that block in the input to our transformation, and so any data\n+            //    invalidated by that computation could not have been used there.\n+            //  - In `BB9`: Not possible since control flow might have reached `BB9` via the\n+            //    `otherwise` branch in `BBC, BBD` in the input to our transformation, which would\n+            //    have invalidated the data when computing `discriminant(P)`\n+            // So dereferencing here is correct.\n+            ProjectionElem::Deref => match place.ty(body.local_decls(), tcx).ty.kind() {\n+                ty::Ref(..) => {}\n+                _ => return false,\n+            },\n+            // Field projections are always valid\n+            ProjectionElem::Field(..) => {}\n+            // We cannot allow\n+            // downcasts either, since the correctness of the downcast may depend on the parent\n+            // branch being taken. An easy example of this is\n+            // ```\n+            // Q = discriminant(_3)\n+            // P = (_3 as Variant)\n+            // ```\n+            // However, checking if the child and parent place are the same and only erroring then\n+            // is not sufficient either, since the `discriminant(_3) == 1` (or whatever) check may\n+            // be replaced by another optimization pass with any other condition that can be proven\n+            // equivalent.\n+            ProjectionElem::Downcast(..) => {\n+                return false;\n+            }\n+            // We cannot allow indexing since the index may be out of bounds.\n+            _ => {\n+                return false;\n+            }\n+        }\n+    }\n+    true\n }\n \n #[derive(Debug)]\n-struct OptimizationInfo<'tcx> {\n-    /// Info about the first switch and discriminant\n-    first_switch_info: SwitchDiscriminantInfo<'tcx>,\n-    /// Info about the second switch and discriminant\n-    second_switch_info: SwitchDiscriminantInfo<'tcx>,\n+struct OptimizationData<'tcx> {\n+    destination: BasicBlock,\n+    child_place: Place<'tcx>,\n+    child_ty: Ty<'tcx>,\n+    child_source: SourceInfo,\n }\n \n-impl<'tcx> Helper<'_, 'tcx> {\n-    pub fn go(\n-        &self,\n-        bb: &BasicBlockData<'tcx>,\n-        switch: &Terminator<'tcx>,\n-    ) -> Option<Vec<OptimizationInfo<'tcx>>> {\n-        // try to find the statement that defines the discriminant that is used for the switch\n-        let discr = self.find_switch_discriminant_info(bb, switch)?;\n-\n-        // go through each target, finding a discriminant read, and a switch\n-        let results = discr\n-            .targets_with_values\n-            .iter()\n-            .map(|(value, target)| self.find_discriminant_switch_pairing(&discr, *target, *value));\n-\n-        // if the optimization did not apply for one of the targets, then abort\n-        if results.clone().any(|x| x.is_none()) || results.len() == 0 {\n-            trace!(\"NO: not all of the targets matched the pattern for optimization\");\n-            return None;\n+fn evaluate_candidate<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body: &Body<'tcx>,\n+    parent: BasicBlock,\n+) -> Option<OptimizationData<'tcx>> {\n+    let bbs = body.basic_blocks();\n+    let TerminatorKind::SwitchInt {\n+        targets,\n+        switch_ty: parent_ty,\n+        ..\n+    } = &bbs[parent].terminator().kind else {\n+        return None\n+    };\n+    let parent_dest = {\n+        let poss = targets.otherwise();\n+        // If the fallthrough on the parent is trivially unreachable, we can let the\n+        // children choose the destination\n+        if bbs[poss].statements.len() == 0\n+            && bbs[poss].terminator().kind == TerminatorKind::Unreachable\n+        {\n+            None\n+        } else {\n+            Some(poss)\n         }\n-\n-        Some(results.flatten().collect())\n+    };\n+    let Some((_, child)) = targets.iter().next() else {\n+        return None\n+    };\n+    let child_terminator = &bbs[child].terminator();\n+    let TerminatorKind::SwitchInt {\n+        switch_ty: child_ty,\n+        targets: child_targets,\n+        ..\n+    } = &child_terminator.kind else {\n+        return None\n+    };\n+    if child_ty != parent_ty {\n+        return None;\n+    }\n+    let Some(StatementKind::Assign(boxed))\n+        = &bbs[child].statements.first().map(|x| &x.kind) else {\n+        return None;\n+    };\n+    let (_, Rvalue::Discriminant(child_place)) = &**boxed else {\n+        return None;\n+    };\n+    let destination = parent_dest.unwrap_or(child_targets.otherwise());\n+\n+    // Verify that the optimization is legal in general\n+    // We can hoist evaluating the child discriminant out of the branch\n+    if !may_hoist(tcx, body, *child_place) {\n+        return None;\n     }\n \n-    fn find_discriminant_switch_pairing(\n-        &self,\n-        discr_info: &SwitchDiscriminantInfo<'tcx>,\n-        target: BasicBlock,\n-        value: u128,\n-    ) -> Option<OptimizationInfo<'tcx>> {\n-        let bb = &self.body.basic_blocks()[target];\n-        // find switch\n-        let terminator = bb.terminator();\n-        if is_switch(terminator) {\n-            let this_bb_discr_info = self.find_switch_discriminant_info(bb, terminator)?;\n-\n-            // the types of the two adts matched on have to be equalfor this optimization to apply\n-            if discr_info.type_adt_matched_on != this_bb_discr_info.type_adt_matched_on {\n-                trace!(\n-                    \"NO: types do not match. LHS: {:?}, RHS: {:?}\",\n-                    discr_info.type_adt_matched_on,\n-                    this_bb_discr_info.type_adt_matched_on\n-                );\n-                return None;\n-            }\n-\n-            // the otherwise branch of the two switches have to point to the same bb\n-            if discr_info.otherwise_bb != this_bb_discr_info.otherwise_bb {\n-                trace!(\"NO: otherwise target is not the same\");\n-                return None;\n-            }\n-\n-            // check that the value being matched on is the same. The\n-            if !this_bb_discr_info.targets_with_values.iter().any(|x| x.0 == value) {\n-                trace!(\"NO: values being matched on are not the same\");\n-                return None;\n-            }\n-\n-            // only allow optimization if the left and right of the tuple being matched are the same variants.\n-            // so the following should not optimize\n-            //  ```rust\n-            // let x: Option<()>;\n-            // let y: Option<()>;\n-            // match (x,y) {\n-            //     (Some(_), None) => {},\n-            //     _ => {}\n-            // }\n-            //  ```\n-            // We check this by seeing that the value of the first discriminant is the only other discriminant value being used as a target in the second switch\n-            if !(this_bb_discr_info.targets_with_values.len() == 1\n-                && this_bb_discr_info.targets_with_values[0].0 == value)\n-            {\n-                trace!(\n-                    \"NO: The second switch did not have only 1 target (besides otherwise) that had the same value as the value from the first switch that got us here\"\n-                );\n-                return None;\n-            }\n-\n-            // when the second place is a projection of the first one, it's not safe to calculate their discriminant values sequentially.\n-            // for example, this should not be optimized:\n-            //\n-            // ```rust\n-            // enum E<'a> { Empty, Some(&'a E<'a>), }\n-            // let Some(Some(_)) = e;\n-            // ```\n-            //\n-            // ```mir\n-            // bb0: {\n-            //   _2 = discriminant(*_1)\n-            //   switchInt(_2) -> [...]\n-            // }\n-            // bb1: {\n-            //   _3 = discriminant(*(((*_1) as Some).0: &E))\n-            //   switchInt(_3) -> [...]\n-            // }\n-            // ```\n-            let discr_place = discr_info.place_of_adt_discr_read;\n-            let this_discr_place = this_bb_discr_info.place_of_adt_discr_read;\n-            if discr_place.local == this_discr_place.local\n-                && this_discr_place.projection.starts_with(discr_place.projection)\n-            {\n-                trace!(\"NO: one target is the projection of another\");\n-                return None;\n-            }\n-\n-            // if we reach this point, the optimization applies, and we should be able to optimize this case\n-            // store the info that is needed to apply the optimization\n-\n-            Some(OptimizationInfo {\n-                first_switch_info: discr_info.clone(),\n-                second_switch_info: this_bb_discr_info,\n-            })\n-        } else {\n-            None\n+    // Verify that the optimization is legal for each branch\n+    for (value, child) in targets.iter() {\n+        if !verify_candidate_branch(&bbs[child], value, *child_place, destination) {\n+            return None;\n         }\n     }\n+    Some(OptimizationData {\n+        destination,\n+        child_place: *child_place,\n+        child_ty,\n+        child_source: child_terminator.source_info,\n+    })\n+}\n \n-    fn find_switch_discriminant_info(\n-        &self,\n-        bb: &BasicBlockData<'tcx>,\n-        switch: &Terminator<'tcx>,\n-    ) -> Option<SwitchDiscriminantInfo<'tcx>> {\n-        match &switch.kind {\n-            TerminatorKind::SwitchInt { discr, targets, .. } => {\n-                let discr_local = discr.place()?.as_local()?;\n-                // the declaration of the discriminant read. Place of this read is being used in the switch\n-                let discr_decl = &self.body.local_decls()[discr_local];\n-                let discr_ty = discr_decl.ty;\n-                // the otherwise target lies as the last element\n-                let otherwise_bb = targets.otherwise();\n-                let targets_with_values = targets.iter().collect();\n-\n-                // find the place of the adt where the discriminant is being read from\n-                // assume this is the last statement of the block\n-                let place_of_adt_discr_read = match bb.statements.last()?.kind {\n-                    StatementKind::Assign(box (_, Rvalue::Discriminant(adt_place))) => {\n-                        Some(adt_place)\n-                    }\n-                    _ => None,\n-                }?;\n-\n-                let type_adt_matched_on = place_of_adt_discr_read.ty(self.body, self.tcx).ty;\n-\n-                Some(SwitchDiscriminantInfo {\n-                    discr_used_in_switch: discr.place()?,\n-                    discr_ty,\n-                    otherwise_bb,\n-                    targets_with_values,\n-                    discr_source_info: discr_decl.source_info,\n-                    place_of_adt_discr_read,\n-                    type_adt_matched_on,\n-                })\n-            }\n-            _ => unreachable!(\"must only be passed terminator that is a switch\"),\n-        }\n+fn verify_candidate_branch<'tcx>(\n+    branch: &BasicBlockData<'tcx>,\n+    value: u128,\n+    place: Place<'tcx>,\n+    destination: BasicBlock,\n+) -> bool {\n+    // In order for the optimization to be correct, the branch must...\n+    // ...have exactly one statement\n+    if branch.statements.len() != 1 {\n+        return false;\n+    }\n+    // ...assign the descriminant of `place` in that statement\n+    let StatementKind::Assign(boxed) = &branch.statements[0].kind else {\n+        return false\n+    };\n+    let (discr_place, Rvalue::Discriminant(from_place)) = &**boxed else {\n+        return false\n+    };\n+    if *from_place != place {\n+        return false;\n+    }\n+    // ...make that assignment to a local\n+    if discr_place.projection.len() != 0 {\n+        return false;\n+    }\n+    // ...terminate on a `SwitchInt` that invalidates that local\n+    let TerminatorKind::SwitchInt{ discr: switch_op, targets, .. } = &branch.terminator().kind else {\n+        return false\n+    };\n+    if *switch_op != Operand::Move(*discr_place) {\n+        return false;\n+    }\n+    // ...fall through to `destination` if the switch misses\n+    if destination != targets.otherwise() {\n+        return false;\n+    }\n+    // ...have a branch for value `value`\n+    let mut iter = targets.iter();\n+    let Some((target_value, _)) = iter.next() else {\n+        return false;\n+    };\n+    if target_value != value {\n+        return false;\n+    }\n+    // ...and have no more branches\n+    if let Some(_) = iter.next() {\n+        return false;\n     }\n+    return true;\n }"}, {"sha": "3fe23633852ed4c1a26c2f3fd84d0cf9a94424da", "filename": "src/test/mir-opt/early_otherwise_branch.opt1.EarlyOtherwiseBranch.diff", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch.opt1.EarlyOtherwiseBranch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch.opt1.EarlyOtherwiseBranch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch.opt1.EarlyOtherwiseBranch.diff?ref=a7f375789bab1a4e4a291c963081a8ca7d2b6bd7", "patch": "@@ -12,8 +12,8 @@\n       let mut _7: isize;                   // in scope 0 at $DIR/early_otherwise_branch.rs:5:10: 5:17\n       let _8: u32;                         // in scope 0 at $DIR/early_otherwise_branch.rs:5:15: 5:16\n       let _9: u32;                         // in scope 0 at $DIR/early_otherwise_branch.rs:5:24: 5:25\n-+     let mut _10: isize;                  // in scope 0 at $DIR/early_otherwise_branch.rs:5:19: 5:26\n-+     let mut _11: bool;                   // in scope 0 at $DIR/early_otherwise_branch.rs:5:19: 5:26\n++     let mut _10: isize;                  // in scope 0 at $DIR/early_otherwise_branch.rs:4:5: 4:17\n++     let mut _11: bool;                   // in scope 0 at $DIR/early_otherwise_branch.rs:4:5: 4:17\n       scope 1 {\n           debug a => _8;                   // in scope 1 at $DIR/early_otherwise_branch.rs:5:15: 5:16\n           debug b => _9;                   // in scope 1 at $DIR/early_otherwise_branch.rs:5:24: 5:25\n@@ -34,7 +34,7 @@\n +         StorageLive(_10);                // scope 0 at $DIR/early_otherwise_branch.rs:4:5: 4:17\n +         _10 = discriminant((_3.1: std::option::Option<u32>)); // scope 0 at $DIR/early_otherwise_branch.rs:4:5: 4:17\n +         StorageLive(_11);                // scope 0 at $DIR/early_otherwise_branch.rs:4:5: 4:17\n-+         _11 = Ne(_10, _7);               // scope 0 at $DIR/early_otherwise_branch.rs:4:5: 4:17\n++         _11 = Ne(_7, move _10);          // scope 0 at $DIR/early_otherwise_branch.rs:4:5: 4:17\n +         StorageDead(_10);                // scope 0 at $DIR/early_otherwise_branch.rs:4:5: 4:17\n +         switchInt(move _11) -> [false: bb4, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:4:5: 4:17\n       }\n@@ -70,8 +70,8 @@\n +     }\n + \n +     bb4: {\n-+         StorageDead(_11);                // scope 0 at $DIR/early_otherwise_branch.rs:5:19: 5:26\n-+         switchInt(_7) -> [1_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:5:19: 5:26\n++         StorageDead(_11);                // scope 0 at $DIR/early_otherwise_branch.rs:4:5: 4:17\n++         switchInt(_7) -> [1_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:4:5: 4:17\n       }\n   }\n   "}, {"sha": "6d149b89edbb9cabb242bf6ac35ffd6705ff0aa9", "filename": "src/test/mir-opt/early_otherwise_branch.opt2.EarlyOtherwiseBranch.diff", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch.opt2.EarlyOtherwiseBranch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch.opt2.EarlyOtherwiseBranch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch.opt2.EarlyOtherwiseBranch.diff?ref=a7f375789bab1a4e4a291c963081a8ca7d2b6bd7", "patch": "@@ -13,8 +13,8 @@\n       let mut _8: isize;                   // in scope 0 at $DIR/early_otherwise_branch.rs:13:10: 13:17\n       let _9: u32;                         // in scope 0 at $DIR/early_otherwise_branch.rs:13:15: 13:16\n       let _10: u32;                        // in scope 0 at $DIR/early_otherwise_branch.rs:13:24: 13:25\n-+     let mut _11: isize;                  // in scope 0 at $DIR/early_otherwise_branch.rs:14:16: 14:20\n-+     let mut _12: bool;                   // in scope 0 at $DIR/early_otherwise_branch.rs:14:16: 14:20\n++     let mut _11: isize;                  // in scope 0 at $DIR/early_otherwise_branch.rs:12:5: 12:17\n++     let mut _12: bool;                   // in scope 0 at $DIR/early_otherwise_branch.rs:12:5: 12:17\n       scope 1 {\n           debug a => _9;                   // in scope 1 at $DIR/early_otherwise_branch.rs:13:15: 13:16\n           debug b => _10;                  // in scope 1 at $DIR/early_otherwise_branch.rs:13:24: 13:25\n@@ -35,7 +35,7 @@\n +         StorageLive(_11);                // scope 0 at $DIR/early_otherwise_branch.rs:12:5: 12:17\n +         _11 = discriminant((_3.1: std::option::Option<u32>)); // scope 0 at $DIR/early_otherwise_branch.rs:12:5: 12:17\n +         StorageLive(_12);                // scope 0 at $DIR/early_otherwise_branch.rs:12:5: 12:17\n-+         _12 = Ne(_11, _8);               // scope 0 at $DIR/early_otherwise_branch.rs:12:5: 12:17\n++         _12 = Ne(_8, move _11);          // scope 0 at $DIR/early_otherwise_branch.rs:12:5: 12:17\n +         StorageDead(_11);                // scope 0 at $DIR/early_otherwise_branch.rs:12:5: 12:17\n +         switchInt(move _12) -> [false: bb5, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:12:5: 12:17\n       }\n@@ -84,8 +84,8 @@\n +     }\n + \n +     bb5: {\n-+         StorageDead(_12);                // scope 0 at $DIR/early_otherwise_branch.rs:14:16: 14:20\n-+         switchInt(_8) -> [0_isize: bb3, 1_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:14:16: 14:20\n++         StorageDead(_12);                // scope 0 at $DIR/early_otherwise_branch.rs:12:5: 12:17\n++         switchInt(_8) -> [0_isize: bb3, 1_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:12:5: 12:17\n       }\n   }\n   "}, {"sha": "2aa22737bde2cbe4bf89014291eb15fbb14ad118", "filename": "src/test/mir-opt/early_otherwise_branch.opt3.EarlyOtherwiseBranch.diff", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch.opt3.EarlyOtherwiseBranch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch.opt3.EarlyOtherwiseBranch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch.opt3.EarlyOtherwiseBranch.diff?ref=a7f375789bab1a4e4a291c963081a8ca7d2b6bd7", "patch": "@@ -0,0 +1,77 @@\n+- // MIR for `opt3` before EarlyOtherwiseBranch\n++ // MIR for `opt3` after EarlyOtherwiseBranch\n+  \n+  fn opt3(_1: Option<u32>, _2: Option<bool>) -> u32 {\n+      debug x => _1;                       // in scope 0 at $DIR/early_otherwise_branch.rs:21:9: 21:10\n+      debug y => _2;                       // in scope 0 at $DIR/early_otherwise_branch.rs:21:25: 21:26\n+      let mut _0: u32;                     // return place in scope 0 at $DIR/early_otherwise_branch.rs:21:45: 21:48\n+      let mut _3: (std::option::Option<u32>, std::option::Option<bool>); // in scope 0 at $DIR/early_otherwise_branch.rs:22:11: 22:17\n+      let mut _4: std::option::Option<u32>; // in scope 0 at $DIR/early_otherwise_branch.rs:22:12: 22:13\n+      let mut _5: std::option::Option<bool>; // in scope 0 at $DIR/early_otherwise_branch.rs:22:15: 22:16\n+      let mut _6: isize;                   // in scope 0 at $DIR/early_otherwise_branch.rs:23:19: 23:26\n+      let mut _7: isize;                   // in scope 0 at $DIR/early_otherwise_branch.rs:23:10: 23:17\n+      let _8: u32;                         // in scope 0 at $DIR/early_otherwise_branch.rs:23:15: 23:16\n+      let _9: bool;                        // in scope 0 at $DIR/early_otherwise_branch.rs:23:24: 23:25\n++     let mut _10: isize;                  // in scope 0 at $DIR/early_otherwise_branch.rs:22:5: 22:17\n++     let mut _11: bool;                   // in scope 0 at $DIR/early_otherwise_branch.rs:22:5: 22:17\n+      scope 1 {\n+          debug a => _8;                   // in scope 1 at $DIR/early_otherwise_branch.rs:23:15: 23:16\n+          debug b => _9;                   // in scope 1 at $DIR/early_otherwise_branch.rs:23:24: 23:25\n+      }\n+  \n+      bb0: {\n+          StorageLive(_3);                 // scope 0 at $DIR/early_otherwise_branch.rs:22:11: 22:17\n+          StorageLive(_4);                 // scope 0 at $DIR/early_otherwise_branch.rs:22:12: 22:13\n+          _4 = _1;                         // scope 0 at $DIR/early_otherwise_branch.rs:22:12: 22:13\n+          StorageLive(_5);                 // scope 0 at $DIR/early_otherwise_branch.rs:22:15: 22:16\n+          _5 = _2;                         // scope 0 at $DIR/early_otherwise_branch.rs:22:15: 22:16\n+          (_3.0: std::option::Option<u32>) = move _4; // scope 0 at $DIR/early_otherwise_branch.rs:22:11: 22:17\n+          (_3.1: std::option::Option<bool>) = move _5; // scope 0 at $DIR/early_otherwise_branch.rs:22:11: 22:17\n+          StorageDead(_5);                 // scope 0 at $DIR/early_otherwise_branch.rs:22:16: 22:17\n+          StorageDead(_4);                 // scope 0 at $DIR/early_otherwise_branch.rs:22:16: 22:17\n+          _7 = discriminant((_3.0: std::option::Option<u32>)); // scope 0 at $DIR/early_otherwise_branch.rs:22:11: 22:17\n+-         switchInt(move _7) -> [1_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:22:5: 22:17\n++         StorageLive(_10);                // scope 0 at $DIR/early_otherwise_branch.rs:22:5: 22:17\n++         _10 = discriminant((_3.1: std::option::Option<bool>)); // scope 0 at $DIR/early_otherwise_branch.rs:22:5: 22:17\n++         StorageLive(_11);                // scope 0 at $DIR/early_otherwise_branch.rs:22:5: 22:17\n++         _11 = Ne(_7, move _10);          // scope 0 at $DIR/early_otherwise_branch.rs:22:5: 22:17\n++         StorageDead(_10);                // scope 0 at $DIR/early_otherwise_branch.rs:22:5: 22:17\n++         switchInt(move _11) -> [false: bb4, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:22:5: 22:17\n+      }\n+  \n+      bb1: {\n++         StorageDead(_11);                // scope 0 at $DIR/early_otherwise_branch.rs:24:14: 24:15\n+          _0 = const 1_u32;                // scope 0 at $DIR/early_otherwise_branch.rs:24:14: 24:15\n+-         goto -> bb4;                     // scope 0 at $DIR/early_otherwise_branch.rs:24:14: 24:15\n++         goto -> bb3;                     // scope 0 at $DIR/early_otherwise_branch.rs:24:14: 24:15\n+      }\n+  \n+      bb2: {\n+-         _6 = discriminant((_3.1: std::option::Option<bool>)); // scope 0 at $DIR/early_otherwise_branch.rs:22:11: 22:17\n+-         switchInt(move _6) -> [1_isize: bb3, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:22:5: 22:17\n+-     }\n+- \n+-     bb3: {\n+          StorageLive(_8);                 // scope 0 at $DIR/early_otherwise_branch.rs:23:15: 23:16\n+          _8 = (((_3.0: std::option::Option<u32>) as Some).0: u32); // scope 0 at $DIR/early_otherwise_branch.rs:23:15: 23:16\n+          StorageLive(_9);                 // scope 0 at $DIR/early_otherwise_branch.rs:23:24: 23:25\n+          _9 = (((_3.1: std::option::Option<bool>) as Some).0: bool); // scope 0 at $DIR/early_otherwise_branch.rs:23:24: 23:25\n+          _0 = const 0_u32;                // scope 1 at $DIR/early_otherwise_branch.rs:23:31: 23:32\n+          StorageDead(_9);                 // scope 0 at $DIR/early_otherwise_branch.rs:23:31: 23:32\n+          StorageDead(_8);                 // scope 0 at $DIR/early_otherwise_branch.rs:23:31: 23:32\n+-         goto -> bb4;                     // scope 0 at $DIR/early_otherwise_branch.rs:23:31: 23:32\n++         goto -> bb3;                     // scope 0 at $DIR/early_otherwise_branch.rs:23:31: 23:32\n+      }\n+  \n+-     bb4: {\n++     bb3: {\n+          StorageDead(_3);                 // scope 0 at $DIR/early_otherwise_branch.rs:26:1: 26:2\n+          return;                          // scope 0 at $DIR/early_otherwise_branch.rs:26:2: 26:2\n++     }\n++ \n++     bb4: {\n++         StorageDead(_11);                // scope 0 at $DIR/early_otherwise_branch.rs:22:5: 22:17\n++         switchInt(_7) -> [1_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:22:5: 22:17\n+      }\n+  }\n+  "}, {"sha": "e0ebcfeebfcc79622f24369c0dc9166911d8add3", "filename": "src/test/mir-opt/early_otherwise_branch.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch.rs?ref=a7f375789bab1a4e4a291c963081a8ca7d2b6bd7", "patch": "@@ -16,7 +16,17 @@ fn opt2(x: Option<u32>, y: Option<u32>) -> u32 {\n     }\n }\n \n+// optimize despite different types\n+// EMIT_MIR early_otherwise_branch.opt3.EarlyOtherwiseBranch.diff\n+fn opt3(x: Option<u32>, y: Option<bool>) -> u32 {\n+    match (x, y) {\n+        (Some(a), Some(b)) => 0,\n+        _ => 1,\n+    }\n+}\n+\n fn main() {\n     opt1(None, Some(0));\n     opt2(None, Some(0));\n+    opt3(None, Some(false));\n }"}, {"sha": "8b78f3ce20247477210439c9e3fa3e9e32f7e624", "filename": "src/test/mir-opt/early_otherwise_branch_3_element_tuple.opt1.EarlyOtherwiseBranch.diff", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_3_element_tuple.opt1.EarlyOtherwiseBranch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_3_element_tuple.opt1.EarlyOtherwiseBranch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_3_element_tuple.opt1.EarlyOtherwiseBranch.diff?ref=a7f375789bab1a4e4a291c963081a8ca7d2b6bd7", "patch": "@@ -16,10 +16,10 @@\n       let _11: u32;                        // in scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:6:15: 6:16\n       let _12: u32;                        // in scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:6:24: 6:25\n       let _13: u32;                        // in scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:6:33: 6:34\n-+     let mut _14: isize;                  // in scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:6:19: 6:26\n-+     let mut _15: bool;                   // in scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:6:19: 6:26\n-+     let mut _16: isize;                  // in scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:6:28: 6:35\n-+     let mut _17: bool;                   // in scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:6:28: 6:35\n++     let mut _14: isize;                  // in scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:5:5: 5:20\n++     let mut _15: bool;                   // in scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:5:5: 5:20\n++     let mut _16: isize;                  // in scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:5:5: 5:20\n++     let mut _17: bool;                   // in scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:5:5: 5:20\n       scope 1 {\n           debug a => _11;                  // in scope 1 at $DIR/early_otherwise_branch_3_element_tuple.rs:6:15: 6:16\n           debug b => _12;                  // in scope 1 at $DIR/early_otherwise_branch_3_element_tuple.rs:6:24: 6:25\n@@ -45,7 +45,7 @@\n +         StorageLive(_14);                // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:5:5: 5:20\n +         _14 = discriminant((_4.1: std::option::Option<u32>)); // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:5:5: 5:20\n +         StorageLive(_15);                // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:5:5: 5:20\n-+         _15 = Ne(_14, _10);              // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:5:5: 5:20\n++         _15 = Ne(_10, move _14);         // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:5:5: 5:20\n +         StorageDead(_14);                // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:5:5: 5:20\n +         switchInt(move _15) -> [false: bb5, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:5:5: 5:20\n       }\n@@ -92,8 +92,8 @@\n +     }\n + \n +     bb5: {\n-+         StorageDead(_15);                // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:6:19: 6:26\n-+         switchInt(_10) -> [1_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:6:19: 6:26\n++         StorageDead(_15);                // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:5:5: 5:20\n++         switchInt(_10) -> [1_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:5:5: 5:20\n       }\n   }\n   "}, {"sha": "fc2dcb251099fd54b18e41b039f64ed772510700", "filename": "src/test/mir-opt/early_otherwise_branch_68867.try_sum.EarlyOtherwiseBranch.before-SimplifyConstCondition-final.after.diff", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_68867.try_sum.EarlyOtherwiseBranch.before-SimplifyConstCondition-final.after.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_68867.try_sum.EarlyOtherwiseBranch.before-SimplifyConstCondition-final.after.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_68867.try_sum.EarlyOtherwiseBranch.before-SimplifyConstCondition-final.after.diff?ref=a7f375789bab1a4e4a291c963081a8ca7d2b6bd7", "patch": "@@ -36,8 +36,8 @@\n       let mut _31: f32;                    // in scope 0 at $DIR/early_otherwise_branch_68867.rs:25:50: 25:55\n       let mut _32: !;                      // in scope 0 at $DIR/early_otherwise_branch_68867.rs:26:14: 26:28\n       let mut _33: ();                     // in scope 0 at $DIR/early_otherwise_branch_68867.rs:26:25: 26:27\n-+     let mut _34: isize;                  // in scope 0 at $DIR/early_otherwise_branch_68867.rs:22:21: 22:30\n-+     let mut _35: bool;                   // in scope 0 at $DIR/early_otherwise_branch_68867.rs:22:21: 22:30\n++     let mut _34: isize;                  // in scope 0 at $DIR/early_otherwise_branch_68867.rs:21:8: 21:24\n++     let mut _35: bool;                   // in scope 0 at $DIR/early_otherwise_branch_68867.rs:21:8: 21:24\n       scope 1 {\n -         debug one => _12;                // in scope 1 at $DIR/early_otherwise_branch_68867.rs:22:14: 22:17\n -         debug other => _13;              // in scope 1 at $DIR/early_otherwise_branch_68867.rs:22:24: 22:29\n@@ -85,7 +85,7 @@\n +         StorageLive(_34);                // scope 0 at $DIR/early_otherwise_branch_68867.rs:21:8: 21:24\n +         _34 = discriminant((*(_4.1: &ViewportPercentageLength))); // scope 0 at $DIR/early_otherwise_branch_68867.rs:21:8: 21:24\n +         StorageLive(_35);                // scope 0 at $DIR/early_otherwise_branch_68867.rs:21:8: 21:24\n-+         _35 = Ne(_34, _11);              // scope 0 at $DIR/early_otherwise_branch_68867.rs:21:8: 21:24\n++         _35 = Ne(_11, move _34);         // scope 0 at $DIR/early_otherwise_branch_68867.rs:21:8: 21:24\n +         StorageDead(_34);                // scope 0 at $DIR/early_otherwise_branch_68867.rs:21:8: 21:24\n +         switchInt(move _35) -> [false: bb7, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch_68867.rs:21:8: 21:24\n       }\n@@ -293,8 +293,8 @@\n -         StorageDead(_3);                 // scope 0 at $DIR/early_otherwise_branch_68867.rs:27:6: 27:7\n -         StorageDead(_4);                 // scope 0 at $DIR/early_otherwise_branch_68867.rs:28:1: 28:2\n -         return;                          // scope 0 at $DIR/early_otherwise_branch_68867.rs:28:2: 28:2\n-+         StorageDead(_35);                // scope 0 at $DIR/early_otherwise_branch_68867.rs:22:21: 22:30\n-+         switchInt(_11) -> [0_isize: bb2, 1_isize: bb3, 2_isize: bb4, 3_isize: bb5, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch_68867.rs:22:21: 22:30\n++         StorageDead(_35);                // scope 0 at $DIR/early_otherwise_branch_68867.rs:21:8: 21:24\n++         switchInt(_11) -> [0_isize: bb2, 1_isize: bb3, 2_isize: bb4, 3_isize: bb5, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch_68867.rs:21:8: 21:24\n       }\n   }\n   "}, {"sha": "28c650d72dc1dfb96701dccf0f9599f9a11fbe5c", "filename": "src/test/mir-opt/early_otherwise_branch_68867.try_sum.EarlyOtherwiseBranch.diff", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_68867.try_sum.EarlyOtherwiseBranch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_68867.try_sum.EarlyOtherwiseBranch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_68867.try_sum.EarlyOtherwiseBranch.diff?ref=a7f375789bab1a4e4a291c963081a8ca7d2b6bd7", "patch": "@@ -36,8 +36,8 @@\n       let mut _31: f32;                    // in scope 0 at $DIR/early_otherwise_branch_68867.rs:25:50: 25:55\n       let mut _32: !;                      // in scope 0 at $DIR/early_otherwise_branch_68867.rs:26:14: 26:28\n       let mut _33: ();                     // in scope 0 at $DIR/early_otherwise_branch_68867.rs:26:25: 26:27\n-+     let mut _34: isize;                  // in scope 0 at $DIR/early_otherwise_branch_68867.rs:22:21: 22:30\n-+     let mut _35: bool;                   // in scope 0 at $DIR/early_otherwise_branch_68867.rs:22:21: 22:30\n++     let mut _34: isize;                  // in scope 0 at $DIR/early_otherwise_branch_68867.rs:21:8: 21:24\n++     let mut _35: bool;                   // in scope 0 at $DIR/early_otherwise_branch_68867.rs:21:8: 21:24\n       scope 1 {\n           debug one => _12;                // in scope 1 at $DIR/early_otherwise_branch_68867.rs:22:14: 22:17\n           debug other => _13;              // in scope 1 at $DIR/early_otherwise_branch_68867.rs:22:24: 22:29\n@@ -71,7 +71,7 @@\n +         StorageLive(_34);                // scope 0 at $DIR/early_otherwise_branch_68867.rs:21:8: 21:24\n +         _34 = discriminant((*(_4.1: &ViewportPercentageLength))); // scope 0 at $DIR/early_otherwise_branch_68867.rs:21:8: 21:24\n +         StorageLive(_35);                // scope 0 at $DIR/early_otherwise_branch_68867.rs:21:8: 21:24\n-+         _35 = Ne(_34, _11);              // scope 0 at $DIR/early_otherwise_branch_68867.rs:21:8: 21:24\n++         _35 = Ne(_11, move _34);         // scope 0 at $DIR/early_otherwise_branch_68867.rs:21:8: 21:24\n +         StorageDead(_34);                // scope 0 at $DIR/early_otherwise_branch_68867.rs:21:8: 21:24\n +         switchInt(move _35) -> [false: bb7, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch_68867.rs:21:8: 21:24\n       }\n@@ -209,8 +209,8 @@\n +     }\n + \n +     bb7: {\n-+         StorageDead(_35);                // scope 0 at $DIR/early_otherwise_branch_68867.rs:22:21: 22:30\n-+         switchInt(_11) -> [0_isize: bb2, 1_isize: bb3, 2_isize: bb4, 3_isize: bb5, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch_68867.rs:22:21: 22:30\n++         StorageDead(_35);                // scope 0 at $DIR/early_otherwise_branch_68867.rs:21:8: 21:24\n++         switchInt(_11) -> [0_isize: bb2, 1_isize: bb3, 2_isize: bb4, 3_isize: bb5, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch_68867.rs:21:8: 21:24\n       }\n   }\n   "}, {"sha": "66ea828bf682c422077200f86e3e2efdf0abeffa", "filename": "src/test/mir-opt/early_otherwise_branch_noopt.noopt2.EarlyOtherwiseBranch.diff", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/788b1fe5b79a8b74215022f9df49b0eae68a50b9/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_noopt.noopt2.EarlyOtherwiseBranch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/788b1fe5b79a8b74215022f9df49b0eae68a50b9/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_noopt.noopt2.EarlyOtherwiseBranch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_noopt.noopt2.EarlyOtherwiseBranch.diff?ref=788b1fe5b79a8b74215022f9df49b0eae68a50b9", "patch": "@@ -1,60 +0,0 @@\n-- // MIR for `noopt2` before EarlyOtherwiseBranch\n-+ // MIR for `noopt2` after EarlyOtherwiseBranch\n-  \n-  fn noopt2(_1: Option<u32>, _2: Option<bool>) -> u32 {\n-      debug x => _1;                       // in scope 0 at $DIR/early_otherwise_branch_noopt.rs:18:11: 18:12\n-      debug y => _2;                       // in scope 0 at $DIR/early_otherwise_branch_noopt.rs:18:27: 18:28\n-      let mut _0: u32;                     // return place in scope 0 at $DIR/early_otherwise_branch_noopt.rs:18:47: 18:50\n-      let mut _3: (std::option::Option<u32>, std::option::Option<bool>); // in scope 0 at $DIR/early_otherwise_branch_noopt.rs:19:11: 19:17\n-      let mut _4: std::option::Option<u32>; // in scope 0 at $DIR/early_otherwise_branch_noopt.rs:19:12: 19:13\n-      let mut _5: std::option::Option<bool>; // in scope 0 at $DIR/early_otherwise_branch_noopt.rs:19:15: 19:16\n-      let mut _6: isize;                   // in scope 0 at $DIR/early_otherwise_branch_noopt.rs:20:19: 20:26\n-      let mut _7: isize;                   // in scope 0 at $DIR/early_otherwise_branch_noopt.rs:20:10: 20:17\n-      let _8: u32;                         // in scope 0 at $DIR/early_otherwise_branch_noopt.rs:20:15: 20:16\n-      let _9: bool;                        // in scope 0 at $DIR/early_otherwise_branch_noopt.rs:20:24: 20:25\n-      scope 1 {\n-          debug a => _8;                   // in scope 1 at $DIR/early_otherwise_branch_noopt.rs:20:15: 20:16\n-          debug b => _9;                   // in scope 1 at $DIR/early_otherwise_branch_noopt.rs:20:24: 20:25\n-      }\n-  \n-      bb0: {\n-          StorageLive(_3);                 // scope 0 at $DIR/early_otherwise_branch_noopt.rs:19:11: 19:17\n-          StorageLive(_4);                 // scope 0 at $DIR/early_otherwise_branch_noopt.rs:19:12: 19:13\n-          _4 = _1;                         // scope 0 at $DIR/early_otherwise_branch_noopt.rs:19:12: 19:13\n-          StorageLive(_5);                 // scope 0 at $DIR/early_otherwise_branch_noopt.rs:19:15: 19:16\n-          _5 = _2;                         // scope 0 at $DIR/early_otherwise_branch_noopt.rs:19:15: 19:16\n-          (_3.0: std::option::Option<u32>) = move _4; // scope 0 at $DIR/early_otherwise_branch_noopt.rs:19:11: 19:17\n-          (_3.1: std::option::Option<bool>) = move _5; // scope 0 at $DIR/early_otherwise_branch_noopt.rs:19:11: 19:17\n-          StorageDead(_5);                 // scope 0 at $DIR/early_otherwise_branch_noopt.rs:19:16: 19:17\n-          StorageDead(_4);                 // scope 0 at $DIR/early_otherwise_branch_noopt.rs:19:16: 19:17\n-          _7 = discriminant((_3.0: std::option::Option<u32>)); // scope 0 at $DIR/early_otherwise_branch_noopt.rs:19:11: 19:17\n-          switchInt(move _7) -> [1_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch_noopt.rs:19:5: 19:17\n-      }\n-  \n-      bb1: {\n-          _0 = const 1_u32;                // scope 0 at $DIR/early_otherwise_branch_noopt.rs:21:14: 21:15\n-          goto -> bb4;                     // scope 0 at $DIR/early_otherwise_branch_noopt.rs:21:14: 21:15\n-      }\n-  \n-      bb2: {\n-          _6 = discriminant((_3.1: std::option::Option<bool>)); // scope 0 at $DIR/early_otherwise_branch_noopt.rs:19:11: 19:17\n-          switchInt(move _6) -> [1_isize: bb3, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch_noopt.rs:19:5: 19:17\n-      }\n-  \n-      bb3: {\n-          StorageLive(_8);                 // scope 0 at $DIR/early_otherwise_branch_noopt.rs:20:15: 20:16\n-          _8 = (((_3.0: std::option::Option<u32>) as Some).0: u32); // scope 0 at $DIR/early_otherwise_branch_noopt.rs:20:15: 20:16\n-          StorageLive(_9);                 // scope 0 at $DIR/early_otherwise_branch_noopt.rs:20:24: 20:25\n-          _9 = (((_3.1: std::option::Option<bool>) as Some).0: bool); // scope 0 at $DIR/early_otherwise_branch_noopt.rs:20:24: 20:25\n-          _0 = const 0_u32;                // scope 1 at $DIR/early_otherwise_branch_noopt.rs:20:31: 20:32\n-          StorageDead(_9);                 // scope 0 at $DIR/early_otherwise_branch_noopt.rs:20:31: 20:32\n-          StorageDead(_8);                 // scope 0 at $DIR/early_otherwise_branch_noopt.rs:20:31: 20:32\n-          goto -> bb4;                     // scope 0 at $DIR/early_otherwise_branch_noopt.rs:20:31: 20:32\n-      }\n-  \n-      bb4: {\n-          StorageDead(_3);                 // scope 0 at $DIR/early_otherwise_branch_noopt.rs:23:1: 23:2\n-          return;                          // scope 0 at $DIR/early_otherwise_branch_noopt.rs:23:2: 23:2\n-      }\n-  }\n-  "}, {"sha": "1f8c59df35fff019ad64595fbbc5f13c7976a0ff", "filename": "src/test/mir-opt/early_otherwise_branch_noopt.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_noopt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_noopt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_noopt.rs?ref=a7f375789bab1a4e4a291c963081a8ca7d2b6bd7", "patch": "@@ -13,16 +13,6 @@ fn noopt1(x: Option<u32>, y: Option<u32>) -> u32 {\n     }\n }\n \n-// must not optimize as the types being matched on are not identical\n-// EMIT_MIR early_otherwise_branch_noopt.noopt2.EarlyOtherwiseBranch.diff\n-fn noopt2(x: Option<u32>, y: Option<bool>) -> u32 {\n-    match (x, y) {\n-        (Some(a), Some(b)) => 0,\n-        _ => 1,\n-    }\n-}\n-\n fn main() {\n     noopt1(None, Some(0));\n-    noopt2(None, Some(true));\n }"}, {"sha": "a272266066246ce21169db924e061d480a578125", "filename": "src/test/mir-opt/early_otherwise_branch_soundness.no_deref_ptr.EarlyOtherwiseBranch.diff", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_soundness.no_deref_ptr.EarlyOtherwiseBranch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_soundness.no_deref_ptr.EarlyOtherwiseBranch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_soundness.no_deref_ptr.EarlyOtherwiseBranch.diff?ref=a7f375789bab1a4e4a291c963081a8ca7d2b6bd7", "patch": "@@ -0,0 +1,43 @@\n+- // MIR for `no_deref_ptr` before EarlyOtherwiseBranch\n++ // MIR for `no_deref_ptr` after EarlyOtherwiseBranch\n+  \n+  fn no_deref_ptr(_1: Option<i32>, _2: *const Option<i32>) -> i32 {\n+      debug a => _1;                       // in scope 0 at $DIR/early_otherwise_branch_soundness.rs:18:24: 18:25\n+      debug b => _2;                       // in scope 0 at $DIR/early_otherwise_branch_soundness.rs:18:40: 18:41\n+      let mut _0: i32;                     // return place in scope 0 at $DIR/early_otherwise_branch_soundness.rs:18:66: 18:69\n+      let mut _3: isize;                   // in scope 0 at $DIR/early_otherwise_branch_soundness.rs:21:9: 21:16\n+      let mut _4: isize;                   // in scope 0 at $DIR/early_otherwise_branch_soundness.rs:22:13: 22:20\n+      let _5: i32;                         // in scope 0 at $DIR/early_otherwise_branch_soundness.rs:22:18: 22:19\n+      scope 1 {\n+          debug v => _5;                   // in scope 1 at $DIR/early_otherwise_branch_soundness.rs:22:18: 22:19\n+      }\n+  \n+      bb0: {\n+          _3 = discriminant(_1);           // scope 0 at $DIR/early_otherwise_branch_soundness.rs:19:11: 19:12\n+          switchInt(move _3) -> [1_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch_soundness.rs:19:5: 19:12\n+      }\n+  \n+      bb1: {\n+          _0 = const 0_i32;                // scope 0 at $DIR/early_otherwise_branch_soundness.rs:25:14: 25:15\n+          return;                          // scope 0 at $DIR/early_otherwise_branch_soundness.rs:25:14: 25:15\n+      }\n+  \n+      bb2: {\n+          _4 = discriminant((*_2));        // scope 0 at $DIR/early_otherwise_branch_soundness.rs:21:26: 21:28\n+          switchInt(move _4) -> [1_isize: bb4, otherwise: bb3]; // scope 0 at $DIR/early_otherwise_branch_soundness.rs:21:20: 21:28\n+      }\n+  \n+      bb3: {\n+          _0 = const 0_i32;                // scope 0 at $DIR/early_otherwise_branch_soundness.rs:23:18: 23:19\n+          return;                          // scope 0 at $DIR/early_otherwise_branch_soundness.rs:23:18: 23:19\n+      }\n+  \n+      bb4: {\n+          StorageLive(_5);                 // scope 0 at $DIR/early_otherwise_branch_soundness.rs:22:18: 22:19\n+          _5 = (((*_2) as Some).0: i32);   // scope 0 at $DIR/early_otherwise_branch_soundness.rs:22:18: 22:19\n+          _0 = _5;                         // scope 1 at $DIR/early_otherwise_branch_soundness.rs:22:24: 22:25\n+          StorageDead(_5);                 // scope 0 at $DIR/early_otherwise_branch_soundness.rs:22:24: 22:25\n+          return;                          // scope 0 at $DIR/early_otherwise_branch_soundness.rs:22:24: 22:25\n+      }\n+  }\n+  "}, {"sha": "56b7c9a2db47815e93b688c19054e01a1eb35e42", "filename": "src/test/mir-opt/early_otherwise_branch_soundness.no_downcast.EarlyOtherwiseBranch.diff", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_soundness.no_downcast.EarlyOtherwiseBranch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_soundness.no_downcast.EarlyOtherwiseBranch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_soundness.no_downcast.EarlyOtherwiseBranch.diff?ref=a7f375789bab1a4e4a291c963081a8ca7d2b6bd7", "patch": "@@ -0,0 +1,30 @@\n+- // MIR for `no_downcast` before EarlyOtherwiseBranch\n++ // MIR for `no_downcast` after EarlyOtherwiseBranch\n+  \n+  fn no_downcast(_1: &E) -> u32 {\n+      debug e => _1;                       // in scope 0 at $DIR/early_otherwise_branch_soundness.rs:12:16: 12:17\n+      let mut _0: u32;                     // return place in scope 0 at $DIR/early_otherwise_branch_soundness.rs:12:26: 12:29\n+      let mut _2: isize;                   // in scope 0 at $DIR/early_otherwise_branch_soundness.rs:13:20: 13:30\n+      let mut _3: isize;                   // in scope 0 at $DIR/early_otherwise_branch_soundness.rs:13:12: 13:31\n+  \n+      bb0: {\n+          _3 = discriminant((*_1));        // scope 0 at $DIR/early_otherwise_branch_soundness.rs:13:12: 13:31\n+          switchInt(move _3) -> [1_isize: bb1, otherwise: bb3]; // scope 0 at $DIR/early_otherwise_branch_soundness.rs:13:12: 13:31\n+      }\n+  \n+      bb1: {\n+          _2 = discriminant((*(((*_1) as Some).0: &E))); // scope 0 at $DIR/early_otherwise_branch_soundness.rs:13:12: 13:31\n+          switchInt(move _2) -> [1_isize: bb2, otherwise: bb3]; // scope 0 at $DIR/early_otherwise_branch_soundness.rs:13:12: 13:31\n+      }\n+  \n+      bb2: {\n+          _0 = const 1_u32;                // scope 0 at $DIR/early_otherwise_branch_soundness.rs:13:38: 13:39\n+          return;                          // scope 0 at $DIR/early_otherwise_branch_soundness.rs:13:5: 13:52\n+      }\n+  \n+      bb3: {\n+          _0 = const 2_u32;                // scope 0 at $DIR/early_otherwise_branch_soundness.rs:13:49: 13:50\n+          return;                          // scope 0 at $DIR/early_otherwise_branch_soundness.rs:13:5: 13:52\n+      }\n+  }\n+  "}, {"sha": "d2513213d796f7591efe2a5fadc7774df2aa9dab", "filename": "src/test/mir-opt/early_otherwise_branch_soundness.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_soundness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f375789bab1a4e4a291c963081a8ca7d2b6bd7/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_soundness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_soundness.rs?ref=a7f375789bab1a4e4a291c963081a8ca7d2b6bd7", "patch": "@@ -0,0 +1,32 @@\n+// compile-flags: -Z mir-opt-level=4 -Zunsound-mir-opts\n+\n+// Tests various cases that the `early_otherwise_branch` opt should *not* optimize\n+\n+// From #78496\n+enum E<'a> {\n+    Empty,\n+    Some(&'a E<'a>),\n+}\n+\n+// EMIT_MIR early_otherwise_branch_soundness.no_downcast.EarlyOtherwiseBranch.diff\n+fn no_downcast(e: &E) -> u32 {\n+    if let E::Some(E::Some(_)) = e { 1 } else { 2 }\n+}\n+\n+// SAFETY: if `a` is `Some`, `b` must point to a valid, initialized value\n+// EMIT_MIR early_otherwise_branch_soundness.no_deref_ptr.EarlyOtherwiseBranch.diff\n+unsafe fn no_deref_ptr(a: Option<i32>, b: *const Option<i32>) -> i32 {\n+    match a {\n+        // `*b` being correct depends on `a == Some(_)`\n+        Some(_) => match *b {\n+            Some(v) => v,\n+            _ => 0,\n+        },\n+        _ => 0,\n+    }\n+}\n+\n+fn main() {\n+    no_downcast(&E::Empty);\n+    unsafe { no_deref_ptr(None, std::ptr::null()) };\n+}"}]}