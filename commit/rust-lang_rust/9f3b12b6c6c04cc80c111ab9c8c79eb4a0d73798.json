{"sha": "9f3b12b6c6c04cc80c111ab9c8c79eb4a0d73798", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmM2IxMmI2YzZjMDRjYzgwYzExMWFiOWM4Yzc5ZWI0YTBkNzM3OTg=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-06-12T01:33:58Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-06-12T01:34:24Z"}, "message": "Change llsize_real to use LLVMSizeOfTypeInBits. Add comments.", "tree": {"sha": "37a2c37330636edb1e95a30528585633b5d5e838", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37a2c37330636edb1e95a30528585633b5d5e838"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f3b12b6c6c04cc80c111ab9c8c79eb4a0d73798", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f3b12b6c6c04cc80c111ab9c8c79eb4a0d73798", "html_url": "https://github.com/rust-lang/rust/commit/9f3b12b6c6c04cc80c111ab9c8c79eb4a0d73798", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f3b12b6c6c04cc80c111ab9c8c79eb4a0d73798/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b75199634a74035a5cfde4b199321257436807fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/b75199634a74035a5cfde4b199321257436807fc", "html_url": "https://github.com/rust-lang/rust/commit/b75199634a74035a5cfde4b199321257436807fc"}], "stats": {"total": 62, "additions": 52, "deletions": 10}, "files": [{"sha": "4e4f9829dfbc8afb1b2cd97cbce60f29dee2d187", "filename": "src/rustc/lib/llvm.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9f3b12b6c6c04cc80c111ab9c8c79eb4a0d73798/src%2Frustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3b12b6c6c04cc80c111ab9c8c79eb4a0d73798/src%2Frustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flib%2Fllvm.rs?ref=9f3b12b6c6c04cc80c111ab9c8c79eb4a0d73798", "patch": "@@ -783,9 +783,16 @@ native mod llvm {\n     /** Adds the target data to the given pass manager. The pass manager\n         references the target data only weakly. */\n     fn LLVMAddTargetData(TD: TargetDataRef, PM: PassManagerRef);\n-    /** Returns the size of a type. */\n+    /** Number of bytes clobbered when doing a Store to *T. */\n     fn LLVMStoreSizeOfType(TD: TargetDataRef, Ty: TypeRef) -> c_ulonglong;\n+\n+    /** Number of bytes clobbered when doing a Store to *T. */\n+    fn LLVMSizeOfTypeInBits(TD: TargetDataRef, Ty: TypeRef) -> c_ulonglong;\n+\n+    /** Distance between successive elements in an array of T.\n+    Includes ABI padding. */\n     fn LLVMABISizeOfType(TD: TargetDataRef, Ty: TypeRef) -> c_uint;\n+\n     /** Returns the preferred alignment of a type. */\n     fn LLVMPreferredAlignmentOfType(TD: TargetDataRef,\n                                     Ty: TypeRef) -> c_uint;"}, {"sha": "414693c628758561b2ddd10c8bdaafb8eb5c9c15", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f3b12b6c6c04cc80c111ab9c8c79eb4a0d73798/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3b12b6c6c04cc80c111ab9c8c79eb4a0d73798/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=9f3b12b6c6c04cc80c111ab9c8c79eb4a0d73798", "patch": "@@ -31,6 +31,14 @@ impl methods for reflector {\n         do_spill_noroot(self.bcx, ss)\n     }\n \n+    fn c_size_and_align(t: ty::t) -> [ValueRef] {\n+        let tr = type_of::type_of(self.bcx.ccx(), t);\n+        let s = shape::llsize_of_real(self.bcx.ccx(), tr);\n+        let a = shape::llalign_of_min(self.bcx.ccx(), tr);\n+        ret [self.c_uint(s),\n+             self.c_uint(a)];\n+    }\n+\n     fn visit(ty_name: str, args: [ValueRef]) {\n         let tcx = self.bcx.tcx();\n         let mth_idx = option::get(ty::method_idx(\"visit_\" + ty_name,"}, {"sha": "b875b2adc2fa0f43598f066288789d8f9ae0f20a", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 36, "deletions": 9, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9f3b12b6c6c04cc80c111ab9c8c79eb4a0d73798/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3b12b6c6c04cc80c111ab9c8c79eb4a0d73798/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=9f3b12b6c6c04cc80c111ab9c8c79eb4a0d73798", "patch": "@@ -635,33 +635,60 @@ type tag_metrics = {\n     payload_align: ValueRef\n };\n \n-// Returns the real size of the given type for the current target.\n-fn llsize_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n+// Returns the number of bytes clobbered by a Store to this type.\n+fn llsize_of_store(cx: @crate_ctxt, t: TypeRef) -> uint {\n     ret llvm::LLVMStoreSizeOfType(cx.td.lltd, t) as uint;\n }\n \n+// Returns the number of bytes between successive elements of type T in an\n+// array of T. This is the \"ABI\" size. It includes any ABI-mandated padding.\n fn llsize_of_alloc(cx: @crate_ctxt, t: TypeRef) -> uint {\n     ret llvm::LLVMABISizeOfType(cx.td.lltd, t) as uint;\n }\n \n+// Returns, as near as we can figure, the \"real\" size of a type. As in, the\n+// bits in this number of bytes actually carry data related to the datum\n+// with the type. Not junk, padding, accidentally-damaged words, or\n+// whatever. Rounds up to the nearest byte though, so if you have a 1-bit\n+// value, we return 1 here, not 0. Most of rustc works in bytes.\n+fn llsize_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n+    let nbits = llvm::LLVMSizeOfTypeInBits(cx.td.lltd, t) as uint;\n+    if nbits & 7u != 0u {\n+        // Not an even number of bytes, spills into \"next\" byte.\n+        1u + (nbits >> 3)\n+    } else {\n+        nbits >> 3\n+    }\n+}\n+\n+// Returns the \"default\" size of t, which is calculated by casting null to a\n+// *T and then doing gep(1) on it and measuring the result. Really, look in\n+// the LLVM sources. It does that. So this is likely similar to the ABI size\n+// (i.e. including alignment-padding), but goodness knows which alignment it\n+// winds up using. Probably the ABI one? Not recommended.\n+fn llsize_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n+    ret llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMSizeOf(t), cx.int_type,\n+                               False);\n+}\n+\n // Returns the preferred alignment of the given type for the current target.\n // The preffered alignment may be larger than the alignment used when\n-// packing the type into structs\n+// packing the type into structs. This will be used for things like\n+// allocations inside a stack frame, which LLVM has a free hand in.\n fn llalign_of_pref(cx: @crate_ctxt, t: TypeRef) -> uint {\n     ret llvm::LLVMPreferredAlignmentOfType(cx.td.lltd, t) as uint;\n }\n \n // Returns the minimum alignment of a type required by the plattform.\n-// This is the alignment that will be used for struct fields.\n+// This is the alignment that will be used for struct fields, arrays,\n+// and similar ABI-mandated things.\n fn llalign_of_min(cx: @crate_ctxt, t: TypeRef) -> uint {\n     ret llvm::LLVMABIAlignmentOfType(cx.td.lltd, t) as uint;\n }\n \n-fn llsize_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n-    ret llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMSizeOf(t), cx.int_type,\n-                               False);\n-}\n-\n+// Returns the \"default\" alignment of t, which is calculated by casting\n+// null to a record containing a single-bit followed by a t value, then\n+// doing gep(0,1) to get at the trailing (and presumably padded) t cell.\n fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n     ret llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMAlignOf(t), cx.int_type,\n                                False);"}]}