{"sha": "3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiYzRkMWExMjA2YWQ1ZjRiYjMxNDc1ZTE3ZmMxOGVjZjg1NWVkOGU=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2013-06-20T05:15:50Z"}, "committer": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-06-20T14:43:02Z"}, "message": "Remove all #[cfg(stage0)]-protected code\n\nNew snapshot means this can all go. Also removes places that have\ncomments that say they are workarounds for stage0 errors.", "tree": {"sha": "3cec5e46a4f4a7b7b689f75b56e18ebc3f966bb4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3cec5e46a4f4a7b7b689f75b56e18ebc3f966bb4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e", "html_url": "https://github.com/rust-lang/rust/commit/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6759ce4fd2083595193c93c3fd72383d24a73a5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6759ce4fd2083595193c93c3fd72383d24a73a5e", "html_url": "https://github.com/rust-lang/rust/commit/6759ce4fd2083595193c93c3fd72383d24a73a5e"}], "stats": {"total": 384, "additions": 15, "deletions": 369}, "files": [{"sha": "c626260043ee9e97d615081770b4194808c11fc0", "filename": "src/libextra/num/complex.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibextra%2Fnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibextra%2Fnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fcomplex.rs?ref=3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e", "patch": "@@ -80,7 +80,6 @@ impl<T: Clone + Num> Cmplx<T> {\n     }\n }\n \n-#[cfg(not(stage0))] // Fixed by #4228\n impl<T: Clone + Algebraic + Num> Cmplx<T> {\n     /// Calculate |self|\n     #[inline]\n@@ -89,7 +88,6 @@ impl<T: Clone + Algebraic + Num> Cmplx<T> {\n     }\n }\n \n-#[cfg(not(stage0))] // Fixed by #4228\n impl<T: Clone + Trigonometric + Algebraic + Num> Cmplx<T> {\n     /// Calculate the principal Arg of self.\n     #[inline]"}, {"sha": "d4c85ef51362d008d0847405a4e21f6d153140a3", "filename": "src/libextra/std.rc", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibextra%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibextra%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstd.rc?ref=3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e", "patch": "@@ -32,16 +32,10 @@ Rust extras are part of the standard Rust distribution.\n #[deny(non_camel_case_types)];\n #[deny(missing_doc)];\n \n-// NOTE: remove these two attributes after the next snapshot\n-#[no_core]; // for stage0\n-#[allow(unrecognized_lint)]; // otherwise stage0 is seriously ugly\n-\n #[no_std];\n \n extern mod core(name = \"std\", vers = \"0.7-pre\");\n \n-#[cfg(stage0)]\n-use core::{str, unstable};\n use core::str::{StrSlice, OwnedStr};\n \n pub use core::os;"}, {"sha": "005238a564e85ec45fff32267d0d1c5db7e3e7f2", "filename": "src/libextra/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e", "patch": "@@ -275,7 +275,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n         let mut i = 0u;\n         let len = strs.len();\n         while i < len {\n-            match strs[i] { // can't use let due to stage0 bugs\n+            match strs[i] { // can't use let due to let-pattern bugs\n                 (ref needle, value) => {\n                     if match_str(ss, pos, *needle) {\n                         return Some((value, pos + needle.len()));"}, {"sha": "fd22a7e79c6efcae3464baee37bc4c4a77116759", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e", "patch": "@@ -174,19 +174,6 @@ pub fn get_absolute_rpath(lib: &Path) -> Path {\n     os::make_absolute(lib).dir_path()\n }\n \n-#[cfg(stage0)]\n-pub fn get_install_prefix_rpath(target_triple: &str) -> Path {\n-    let install_prefix = env!(\"CFG_PREFIX\");\n-\n-    if install_prefix.is_empty() {\n-        fail!(\"rustc compiled without CFG_PREFIX environment variable\");\n-    }\n-\n-    let tlib = filesearch::relative_target_lib_path(target_triple);\n-    os::make_absolute(&Path(install_prefix).push_rel(&tlib))\n-}\n-\n-#[cfg(not(stage0))]\n pub fn get_install_prefix_rpath(target_triple: &str) -> Path {\n     let install_prefix = env!(\"CFG_PREFIX\");\n "}, {"sha": "43b3397094b526fc56e348e3964ee4c408a24025", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e", "patch": "@@ -521,25 +521,6 @@ pub fn build_target_config(sopts: @session::options,\n     return target_cfg;\n }\n \n-#[cfg(stage0)]\n-pub fn host_triple() -> ~str {\n-    // Get the host triple out of the build environment. This ensures that our\n-    // idea of the host triple is the same as for the set of libraries we've\n-    // actually built.  We can't just take LLVM's host triple because they\n-    // normalize all ix86 architectures to i386.\n-    //\n-    // Instead of grabbing the host triple (for the current host), we grab (at\n-    // compile time) the target triple that this rustc is built with and\n-    // calling that (at runtime) the host triple.\n-    let ht = env!(\"CFG_COMPILER_TRIPLE\");\n-    return if ht != ~\"\" {\n-            ht\n-        } else {\n-            fail!(\"rustc built without CFG_COMPILER_TRIPLE\")\n-        };\n-}\n-\n-#[cfg(not(stage0))]\n pub fn host_triple() -> ~str {\n     // Get the host triple out of the build environment. This ensures that our\n     // idea of the host triple is the same as for the set of libraries we've"}, {"sha": "08cba4d51cd342025131dc9fb727c7384e4621a8", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e", "patch": "@@ -749,11 +749,7 @@ impl Liveness {\n             None => {\n                 // Vanilla 'break' or 'loop', so use the enclosing\n                 // loop scope\n-                let len = { // FIXME(#5074) stage0\n-                    let loop_scope = &mut *self.loop_scope;\n-                    loop_scope.len()\n-                };\n-                if len == 0 {\n+                if self.loop_scope.len() == 0 {\n                     self.tcx.sess.span_bug(sp, \"break outside loop\");\n                 } else {\n                     // FIXME(#5275): this shouldn't have to be a method..."}, {"sha": "a050467529ac08476efbea48a265a629378d5903", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e", "patch": "@@ -1318,7 +1318,7 @@ pub fn cleanup_and_leave(bcx: block,\n         match cur.kind {\n             block_scope(inf) if !inf.empty_cleanups() => {\n                 let (sub_cx, dest, inf_cleanups) = {\n-                    let inf = &mut *inf; // FIXME(#5074) workaround stage0\n+                    let inf = &mut *inf;\n                     let mut skip = 0;\n                     let mut dest = None;\n                     {"}, {"sha": "207f986efd925007b05cdd727863bd2829a420d1", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e", "patch": "@@ -248,16 +248,9 @@ fn lookup_vtable(vcx: &VtableContext,\n                     // Nothing found. Continue.\n                 }\n                 Some(implementations) => {\n-                    let len = { // FIXME(#5074): stage0 requires it\n-                        let implementations: &mut ~[@Impl] = *implementations;\n-                        implementations.len()\n-                    };\n-\n                     // implementations is the list of all impls in scope for\n                     // trait_ref. (Usually, there's just one.)\n-                    for uint::range(0, len) |i| {\n-                        let im = implementations[i];\n-\n+                    for implementations.iter().advance |im| {\n                         // im is one specific impl of trait_ref.\n \n                         // First, ensure we haven't processed this impl yet."}, {"sha": "d71820a67b35ff0956cd5938e9061de4caf37608", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e", "patch": "@@ -520,12 +520,8 @@ impl CoherenceChecker {\n \n         match extension_methods.find(&trait_def_id) {\n             Some(impls) => {\n-                let len = { // FIXME(#5074) stage0 requires this\n-                    let impls: &mut ~[@Impl] = *impls;\n-                    impls.len()\n-                };\n-                for uint::range(0, len) |i| {\n-                    f(impls[i]);\n+                for impls.iter().advance |&im| {\n+                    f(im);\n                 }\n             }\n             None => { /* no impls? */ }"}, {"sha": "021dd6648cbf0676695a78241dbc59a07d64e2cc", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e", "patch": "@@ -28,16 +28,8 @@ extern mod core(name = \"std\");\n extern mod extra(name = \"extra\");\n extern mod syntax;\n \n-// For deriving(Encodable) purposes...\n-#[cfg(stage0)]\n-extern mod std(name = \"extra\", vers = \"0.7-pre\");\n-#[cfg(not(stage0))]\n extern mod std(name = \"std\", vers = \"0.7-pre\");\n \n-// For bootstrapping purposes.\n-#[cfg(stage0)]\n-pub use core::unstable;\n-\n use core::prelude::*;\n \n use driver::driver::{host_triple, optgroups, early_error};"}, {"sha": "30b6b030dba296b1cf68e4a906b8ff9a4cad0edd", "filename": "src/libstd/cast.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibstd%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibstd%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcast.rs?ref=3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e", "patch": "@@ -14,21 +14,8 @@ use sys;\n use unstable::intrinsics;\n \n /// Casts the value at `src` to U. The two types must have the same length.\n-#[cfg(stage0)]\n-pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n-    let mut dest: U = intrinsics::uninit();\n-    {\n-        let dest_ptr: *mut u8 = transmute(&mut dest);\n-        let src_ptr: *u8 = transmute(src);\n-        intrinsics::memmove64(dest_ptr,\n-                              src_ptr,\n-                              sys::size_of::<U>() as u64);\n-    }\n-    dest\n-}\n-\n /// Casts the value at `src` to U. The two types must have the same length.\n-#[cfg(target_word_size = \"32\", not(stage0))]\n+#[cfg(target_word_size = \"32\")]\n #[inline]\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n     let mut dest: U = intrinsics::uninit();\n@@ -39,7 +26,7 @@ pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n }\n \n /// Casts the value at `src` to U. The two types must have the same length.\n-#[cfg(target_word_size = \"64\", not(stage0))]\n+#[cfg(target_word_size = \"64\")]\n #[inline]\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n     let mut dest: U = intrinsics::uninit();"}, {"sha": "6911c00e55ba645c686431ca71697b6bd5b02261", "filename": "src/libstd/core.rc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibstd%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibstd%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcore.rc?ref=3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e", "patch": "@@ -57,10 +57,6 @@ they contained the following prologue:\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"lib\"];\n \n-// NOTE: remove these two attributes after the next snapshot\n-#[no_core]; // for stage0\n-#[allow(unrecognized_lint)]; // otherwise stage0 is seriously ugly\n-\n // Don't link to std. We are std.\n #[no_std];\n "}, {"sha": "e5e8a4cb601817c5e63f6420245148d66f7f3323", "filename": "src/libstd/io.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e", "patch": "@@ -1654,9 +1654,7 @@ impl Writer for BytesWriter {\n         vec::reserve(bytes, count);\n \n         unsafe {\n-            // Silly stage0 borrow check workaround...\n-            let casted: &mut ~[u8] = cast::transmute_copy(&bytes);\n-            vec::raw::set_len(casted, count);\n+            vec::raw::set_len(bytes, count);\n \n             let view = vec::mut_slice(*bytes, *self.pos, count);\n             vec::bytes::copy_memory(view, v, v_len);"}, {"sha": "7f89d454be1106cf0787ad003cd084ae924f670d", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 6, "deletions": 63, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e", "patch": "@@ -75,21 +75,7 @@ pub fn is_not_null<T>(ptr: *const T) -> bool { !is_null(ptr) }\n  * and destination may overlap.\n  */\n #[inline]\n-#[cfg(target_word_size = \"32\", stage0)]\n-pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n-    use unstable::intrinsics::memmove32;\n-    let n = count * sys::size_of::<T>();\n-    memmove32(dst as *mut u8, src as *u8, n as u32);\n-}\n-\n-/**\n- * Copies data from one location to another.\n- *\n- * Copies `count` elements (not bytes) from `src` to `dst`. The source\n- * and destination may overlap.\n- */\n-#[inline]\n-#[cfg(target_word_size = \"32\", not(stage0))]\n+#[cfg(target_word_size = \"32\")]\n pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n     use unstable::intrinsics::memmove32;\n     memmove32(dst, src as *T, count as u32);\n@@ -102,21 +88,7 @@ pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n  * and destination may overlap.\n  */\n #[inline]\n-#[cfg(target_word_size = \"64\", stage0)]\n-pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n-    use unstable::intrinsics::memmove64;\n-    let n = count * sys::size_of::<T>();\n-    memmove64(dst as *mut u8, src as *u8, n as u64);\n-}\n-\n-/**\n- * Copies data from one location to another.\n- *\n- * Copies `count` elements (not bytes) from `src` to `dst`. The source\n- * and destination may overlap.\n- */\n-#[inline]\n-#[cfg(target_word_size = \"64\", not(stage0))]\n+#[cfg(target_word_size = \"64\")]\n pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n     use unstable::intrinsics::memmove64;\n     memmove64(dst, src as *T, count as u64);\n@@ -129,21 +101,7 @@ pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n  * and destination may *not* overlap.\n  */\n #[inline]\n-#[cfg(target_word_size = \"32\", stage0)]\n-pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n-    use unstable::intrinsics::memmove32;\n-    let n = count * sys::size_of::<T>();\n-    memmove32(dst as *mut u8, src as *u8, n as u32);\n-}\n-\n-/**\n- * Copies data from one location to another.\n- *\n- * Copies `count` elements (not bytes) from `src` to `dst`. The source\n- * and destination may *not* overlap.\n- */\n-#[inline]\n-#[cfg(target_word_size = \"32\", not(stage0))]\n+#[cfg(target_word_size = \"32\")]\n pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n     use unstable::intrinsics::memcpy32;\n     memcpy32(dst, src as *T, count as u32);\n@@ -156,21 +114,7 @@ pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: u\n  * and destination may *not* overlap.\n  */\n #[inline]\n-#[cfg(target_word_size = \"64\", stage0)]\n-pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n-    use unstable::intrinsics::memmove64;\n-    let n = count * sys::size_of::<T>();\n-    memmove64(dst as *mut u8, src as *u8, n as u64);\n-}\n-\n-/**\n- * Copies data from one location to another.\n- *\n- * Copies `count` elements (not bytes) from `src` to `dst`. The source\n- * and destination may *not* overlap.\n- */\n-#[inline]\n-#[cfg(target_word_size = \"64\", not(stage0))]\n+#[cfg(target_word_size = \"64\")]\n pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n     use unstable::intrinsics::memcpy64;\n     memcpy64(dst, src as *T, count as u64);\n@@ -181,7 +125,7 @@ pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: u\n  * bytes of memory starting at `dst` to `c`.\n  */\n #[inline]\n-#[cfg(target_word_size = \"32\", not(stage0))]\n+#[cfg(target_word_size = \"32\")]\n pub unsafe fn set_memory<T>(dst: *mut T, c: u8, count: uint) {\n     use unstable::intrinsics::memset32;\n     memset32(dst, c, count as u32);\n@@ -192,7 +136,7 @@ pub unsafe fn set_memory<T>(dst: *mut T, c: u8, count: uint) {\n  * bytes of memory starting at `dst` to `c`.\n  */\n #[inline]\n-#[cfg(target_word_size = \"64\", not(stage0))]\n+#[cfg(target_word_size = \"64\")]\n pub unsafe fn set_memory<T>(dst: *mut T, c: u8, count: uint) {\n     use unstable::intrinsics::memset64;\n     memset64(dst, c, count as u64);\n@@ -592,7 +536,6 @@ pub mod ptr_tests {\n     }\n \n     #[test]\n-    #[cfg(not(stage0))]\n     fn test_set_memory() {\n         let mut xs = [0u8, ..20];\n         let ptr = vec::raw::to_mut_ptr(xs);"}, {"sha": "134250077853a304069a777749513073d91681be", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e", "patch": "@@ -130,36 +130,23 @@ pub extern \"rust-intrinsic\" {\n \n     /// Equivalent to the `llvm.memcpy.p0i8.0i8.i32` intrinsic, with a size of\n     /// `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`\n-    #[cfg(not(stage0))]\n     pub fn memcpy32<T>(dst: *mut T, src: *T, count: u32);\n     /// Equivalent to the `llvm.memcpy.p0i8.0i8.i64` intrinsic, with a size of\n     /// `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`\n-    #[cfg(not(stage0))]\n     pub fn memcpy64<T>(dst: *mut T, src: *T, count: u64);\n \n-    /// Equivalent to the `llvm.memmove.p0i8.0i8.i32` intrinsic.\n-    #[cfg(stage0)]\n-    pub fn memmove32(dst: *mut u8, src: *u8, size: u32);\n-    /// Equivalent to the `llvm.memmove.p0i8.0i8.i64` intrinsic.\n-    #[cfg(stage0)]\n-    pub fn memmove64(dst: *mut u8, src: *u8, size: u64);\n-\n     /// Equivalent to the `llvm.memmove.p0i8.0i8.i32` intrinsic, with a size of\n     /// `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`\n-    #[cfg(not(stage0))]\n     pub fn memmove32<T>(dst: *mut T, src: *T, count: u32);\n     /// Equivalent to the `llvm.memmove.p0i8.0i8.i64` intrinsic, with a size of\n     /// `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`\n-    #[cfg(not(stage0))]\n     pub fn memmove64<T>(dst: *mut T, src: *T, count: u64);\n \n     /// Equivalent to the `llvm.memset.p0i8.i32` intrinsic, with a size of\n     /// `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`\n-    #[cfg(not(stage0))]\n     pub fn memset32<T>(dst: *mut T, val: u8, count: u32);\n     /// Equivalent to the `llvm.memset.p0i8.i64` intrinsic, with a size of\n     /// `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`\n-    #[cfg(not(stage0))]\n     pub fn memset64<T>(dst: *mut T, val: u8, count: u64);\n \n     pub fn sqrtf32(x: f32) -> f32;"}, {"sha": "555342d3d60a97f1faac822ea7fd9b3d379b2f01", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 166, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e", "patch": "@@ -402,94 +402,6 @@ impl ident_interner {\n \n \n // return a fresh interner, preloaded with special identifiers.\n-#[cfg(stage0)]\n-fn mk_fresh_ident_interner() -> @ident_interner {\n-    // the indices here must correspond to the numbers in\n-    // special_idents.\n-    let init_vec = ~[\n-        \"_\",                  // 0\n-        \"anon\",               // 1\n-        \"\",                   // 2\n-        \"unary\",              // 3\n-        \"!\",                  // 4\n-        \"[]\",                 // 5\n-        \"unary-\",             // 6\n-        \"__extensions__\",     // 7\n-        \"self\",               // 8\n-        \"item\",               // 9\n-        \"block\",              // 10\n-        \"stmt\",               // 11\n-        \"pat\",                // 12\n-        \"expr\",               // 13\n-        \"ty\",                 // 14\n-        \"ident\",              // 15\n-        \"path\",               // 16\n-        \"tt\",                 // 17\n-        \"matchers\",           // 18\n-        \"str\",                // 19\n-        \"TyVisitor\",          // 20\n-        \"arg\",                // 21\n-        \"descrim\",            // 22\n-        \"__rust_abi\",         // 23\n-        \"__rust_stack_shim\",  // 24\n-        \"TyDesc\",             // 25\n-        \"main\",               // 26\n-        \"<opaque>\",           // 27\n-        \"blk\",                // 28\n-        \"static\",             // 29\n-        \"intrinsic\",          // 30\n-        \"__foreign_mod__\",    // 31\n-        \"__field__\",          // 32\n-        \"C\",                  // 33\n-        \"Self\",               // 34\n-\n-        \"as\",                 // 35\n-        \"break\",              // 36\n-        \"const\",              // 37\n-        \"copy\",               // 38\n-        \"do\",                 // 39\n-        \"drop\",               // 40\n-        \"else\",               // 41\n-        \"enum\",               // 42\n-        \"extern\",             // 43\n-        \"false\",              // 44\n-        \"fn\",                 // 45\n-        \"for\",                // 46\n-        \"if\",                 // 47\n-        \"impl\",               // 48\n-        \"let\",                // 49\n-        \"__log\",              // 50\n-        \"loop\",               // 51\n-        \"match\",              // 52\n-        \"mod\",                // 53\n-        \"mut\",                // 54\n-        \"once\",               // 55\n-        \"priv\",               // 56\n-        \"pub\",                // 57\n-        \"pure\",               // 58\n-        \"ref\",                // 59\n-        \"return\",             // 60\n-        \"static\",             // 29 -- also a special ident\n-        \"self\",               //  8 -- also a special ident\n-        \"struct\",             // 61\n-        \"super\",              // 62\n-        \"true\",               // 63\n-        \"trait\",              // 64\n-        \"type\",               // 65\n-        \"unsafe\",             // 66\n-        \"use\",                // 67\n-        \"while\",              // 68\n-\n-        \"be\",                 // 69\n-    ];\n-\n-    @ident_interner {\n-        interner: interner::StrInterner::prefill(init_vec)\n-    }\n-}\n-\n-// return a fresh interner, preloaded with special identifiers.\n-#[cfg(not(stage0))]\n fn mk_fresh_ident_interner() -> @ident_interner {\n     // the indices here must correspond to the numbers in\n     // special_idents.\n@@ -700,48 +612,6 @@ pub mod keywords {\n     }\n \n     impl Keyword {\n-        #[cfg(stage0)]\n-        pub fn to_ident(&self) -> ident {\n-            match *self {\n-                As => ident { name: 35, ctxt: 0 },\n-                Break => ident { name: 36, ctxt: 0 },\n-                Const => ident { name: 37, ctxt: 0 },\n-                Copy => ident { name: 38, ctxt: 0 },\n-                Do => ident { name: 39, ctxt: 0 },\n-                Else => ident { name: 41, ctxt: 0 },\n-                Enum => ident { name: 42, ctxt: 0 },\n-                Extern => ident { name: 43, ctxt: 0 },\n-                False => ident { name: 44, ctxt: 0 },\n-                Fn => ident { name: 45, ctxt: 0 },\n-                For => ident { name: 46, ctxt: 0 },\n-                If => ident { name: 47, ctxt: 0 },\n-                Impl => ident { name: 48, ctxt: 0 },\n-                Let => ident { name: 49, ctxt: 0 },\n-                __Log => ident { name: 50, ctxt: 0 },\n-                Loop => ident { name: 51, ctxt: 0 },\n-                Match => ident { name: 52, ctxt: 0 },\n-                Mod => ident { name: 53, ctxt: 0 },\n-                Mut => ident { name: 54, ctxt: 0 },\n-                Once => ident { name: 55, ctxt: 0 },\n-                Priv => ident { name: 56, ctxt: 0 },\n-                Pub => ident { name: 57, ctxt: 0 },\n-                Pure => ident { name: 58, ctxt: 0 },\n-                Ref => ident { name: 59, ctxt: 0 },\n-                Return => ident { name: 60, ctxt: 0 },\n-                Static => ident { name: 29, ctxt: 0 },\n-                Self => ident { name: 8, ctxt: 0 },\n-                Struct => ident { name: 61, ctxt: 0 },\n-                Super => ident { name: 62, ctxt: 0 },\n-                True => ident { name: 63, ctxt: 0 },\n-                Trait => ident { name: 64, ctxt: 0 },\n-                Type => ident { name: 65, ctxt: 0 },\n-                Unsafe => ident { name: 66, ctxt: 0 },\n-                Use => ident { name: 67, ctxt: 0 },\n-                While => ident { name: 68, ctxt: 0 },\n-                Be => ident { name: 69, ctxt: 0 },\n-            }\n-        }\n-        #[cfg(not(stage0))]\n         pub fn to_ident(&self) -> ident {\n             match *self {\n                 As => ident { name: 35, ctxt: 0 },\n@@ -792,18 +662,6 @@ pub fn is_keyword(kw: keywords::Keyword, tok: &Token) -> bool {\n     }\n }\n \n-#[cfg(stage0)]\n-pub fn is_any_keyword(tok: &Token) -> bool {\n-    match *tok {\n-        token::IDENT(sid, false) => match sid.name {\n-            8 | 29 | 35 .. 69 => true,\n-            _ => false,\n-        },\n-        _ => false\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n pub fn is_any_keyword(tok: &Token) -> bool {\n     match *tok {\n         token::IDENT(sid, false) => match sid.name {\n@@ -814,18 +672,6 @@ pub fn is_any_keyword(tok: &Token) -> bool {\n     }\n }\n \n-#[cfg(stage0)]\n-pub fn is_strict_keyword(tok: &Token) -> bool {\n-    match *tok {\n-        token::IDENT(sid, false) => match sid.name {\n-            8 | 29 | 35 .. 68 => true,\n-            _ => false,\n-        },\n-        _ => false,\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n pub fn is_strict_keyword(tok: &Token) -> bool {\n     match *tok {\n         token::IDENT(sid, false) => match sid.name {\n@@ -836,18 +682,6 @@ pub fn is_strict_keyword(tok: &Token) -> bool {\n     }\n }\n \n-#[cfg(stage0)]\n-pub fn is_reserved_keyword(tok: &Token) -> bool {\n-    match *tok {\n-        token::IDENT(sid, false) => match sid.name {\n-            69 => true,\n-            _ => false,\n-        },\n-        _ => false,\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n pub fn is_reserved_keyword(tok: &Token) -> bool {\n     match *tok {\n         token::IDENT(sid, false) => match sid.name {"}, {"sha": "278600bc0394cf4768f6c6b87bbce7824107ed7e", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e", "patch": "@@ -30,17 +30,8 @@ extern mod core(name = \"std\");\n extern mod extra(name = \"extra\");\n \n // For deriving(Encodable) purposes...\n-#[cfg(stage0)]\n-extern mod std(name = \"extra\");\n-#[cfg(not(stage0))]\n extern mod std(name = \"std\");\n \n-// For bootstrapping purposes.\n-#[cfg(stage0)]\n-pub use core::str;\n-#[cfg(stage0)]\n-pub use core::unstable;\n-\n use core::prelude::*;\n \n pub mod util {"}, {"sha": "e476fa0ad5e07aa9308be4e46c28102edd92df49", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e", "patch": "@@ -732,17 +732,10 @@ rust_task_deref(rust_task *task) {\n // Must call on rust stack.\n extern \"C\" CDECL void\n rust_call_tydesc_glue(void *root, size_t *tydesc, size_t glue_index) {\n-#ifdef _RUST_STAGE0\n-    void (*glue_fn)(void *, void *, void *, void *) =\n-        (void (*)(void *, void *, void *, void *))tydesc[glue_index];\n-    if (glue_fn)\n-        glue_fn(0, 0, 0, root);\n-#else\n     void (*glue_fn)(void *, void *, void *) =\n         (void (*)(void *, void *, void *))tydesc[glue_index];\n     if (glue_fn)\n         glue_fn(0, 0, root);\n-#endif\n }\n \n // Don't run on the Rust stack!\n@@ -762,11 +755,7 @@ class raw_thread: public rust_thread {\n \n     virtual void run() {\n         record_sp_limit(0);\n-#ifdef _RUST_STAGE0\n-        fn.f(NULL, fn.env, NULL);\n-#else\n         fn.f(fn.env, NULL);\n-#endif\n     }\n };\n "}, {"sha": "fe1b4622137eb0ad28f28bb9ec132fc47a984bad", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e", "patch": "@@ -162,11 +162,7 @@ void task_start_wrapper(spawn_args *a)\n \n     bool threw_exception = false;\n     try {\n-#ifdef _RUST_STAGE0\n-        a->f(NULL, a->envptr, a->argptr);\n-#else\n         a->f(a->envptr, a->argptr);\n-#endif\n     } catch (rust_task *ex) {\n         assert(ex == task && \"Expected this task to be thrown for unwinding\");\n         threw_exception = true;\n@@ -187,11 +183,7 @@ void task_start_wrapper(spawn_args *a)\n     if(env) {\n         // free the environment (which should be a unique closure).\n         const type_desc *td = env->td;\n-#ifdef _RUST_STAGE0\n-        td->drop_glue(NULL, NULL, NULL, box_body(env));\n-#else\n         td->drop_glue(NULL, NULL, box_body(env));\n-#endif\n         task->kernel->region()->free(env);\n     }\n "}, {"sha": "6d36d2c960a2d4fdb739a4b05eda20bf39ab76d7", "filename": "src/rt/rust_type.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Frt%2Frust_type.h", "raw_url": "https://github.com/rust-lang/rust/raw/3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e/src%2Frt%2Frust_type.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_type.h?ref=3bc4d1a1206ad5f4bb31475e17fc18ecf855ed8e", "patch": "@@ -21,19 +21,11 @@ struct rust_opaque_box;\n // - the main function: has a NULL environment, but uses the void* arg\n // - unique closures of type fn~(): have a non-NULL environment, but\n //   no arguments (and hence the final void*) is harmless\n-#ifdef _RUST_STAGE0\n-typedef void (*CDECL spawn_fn)(void *, rust_opaque_box*, void *);\n-#else\n typedef void (*CDECL spawn_fn)(rust_opaque_box*, void *);\n-#endif\n \n struct type_desc;\n \n-#ifdef _RUST_STAGE0\n-typedef void CDECL (glue_fn)(void *, void *, const type_desc **, void *);\n-#else\n typedef void CDECL (glue_fn)(void *, const type_desc **, void *);\n-#endif\n \n // Corresponds to the boxed data in the @ region.  The body follows the\n // header; you can obtain a ptr via box_body() below."}]}