{"sha": "f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "node_id": "C_kwDOAAsO6NoAKGYxMzJiY2YzYmRmNmQzZmY5YmU3ZDAyZThkMDA4OGI5OTAwN2NkNWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-30T05:04:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-30T05:04:45Z"}, "message": "Auto merge of #94081 - oli-obk:lazy_tait_take_two, r=nikomatsakis\n\nLazy type-alias-impl-trait take two\n\n### user visible change 1: RPIT inference from recursive call sites\n\nLazy TAIT has an insta-stable change. The following snippet now compiles, because opaque types can now have their hidden type set from wherever the opaque type is mentioned.\n\n```rust\nfn bar(b: bool) -> impl std::fmt::Debug {\n    if b {\n        return 42\n    }\n    let x: u32 = bar(false); // this errors on stable\n    99\n}\n```\n\nThe return type of `bar` stays opaque, you can't do `bar(false) + 42`, you need to actually mention the hidden type.\n\n### user visible change 2: divergence between RPIT and TAIT in return statements\n\nNote that `return` statements and the trailing return expression are special with RPIT (but not TAIT). So\n\n```rust\n#![feature(type_alias_impl_trait)]\ntype Foo = impl std::fmt::Debug;\n\nfn foo(b: bool) -> Foo {\n    if b {\n        return vec![42];\n    }\n    std::iter::empty().collect() //~ ERROR `Foo` cannot be built from an iterator\n}\n\nfn bar(b: bool) -> impl std::fmt::Debug {\n    if b {\n        return vec![42]\n    }\n    std::iter::empty().collect() // Works, magic (accidentally stabilized, not intended)\n}\n```\n\nBut when we are working with the return value of a recursive call, the behavior of RPIT and TAIT is the same:\n\n```rust\ntype Foo = impl std::fmt::Debug;\n\nfn foo(b: bool) -> Foo {\n    if b {\n        return vec![];\n    }\n    let mut x = foo(false);\n    x = std::iter::empty().collect(); //~ ERROR `Foo` cannot be built from an iterator\n    vec![]\n}\n\nfn bar(b: bool) -> impl std::fmt::Debug {\n    if b {\n        return vec![];\n    }\n    let mut x = bar(false);\n    x = std::iter::empty().collect(); //~ ERROR `impl Debug` cannot be built from an iterator\n    vec![]\n}\n```\n\n### user visible change 3: TAIT does not merge types across branches\n\nIn contrast to RPIT, TAIT does not merge types across branches, so the following does not compile.\n\n```rust\ntype Foo = impl std::fmt::Debug;\n\nfn foo(b: bool) -> Foo {\n    if b {\n        vec![42_i32]\n    } else {\n        std::iter::empty().collect()\n        //~^ ERROR `Foo` cannot be built from an iterator over elements of type `_`\n    }\n}\n```\n\nIt is easy to support, but we should make an explicit decision to include the additional complexity in the implementation (it's not much, see a721052457cf513487fb4266e3ade65c29b272d2 which needs to be reverted to enable this).\n\n### PR formalities\n\nprevious attempt: #92007\n\nThis PR also includes #92306 and #93783, as they were reverted along with #92007 in #93893\n\nfixes #93411\nfixes #88236\nfixes #89312\nfixes #87340\nfixes #86800\nfixes #86719\nfixes #84073\nfixes #83919\nfixes #82139\nfixes #77987\nfixes #74282\nfixes #67830\nfixes #62742\nfixes #54895", "tree": {"sha": "a05f563d1b317376019f4856c5d80c45708de370", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a05f563d1b317376019f4856c5d80c45708de370"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "html_url": "https://github.com/rust-lang/rust/commit/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1446d17b8f4bd3ff8dbfb129a7674165e06f9f4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1446d17b8f4bd3ff8dbfb129a7674165e06f9f4c", "html_url": "https://github.com/rust-lang/rust/commit/1446d17b8f4bd3ff8dbfb129a7674165e06f9f4c"}, {"sha": "638f84d782e9d8ad4fe5f35fea75088c11986e51", "url": "https://api.github.com/repos/rust-lang/rust/commits/638f84d782e9d8ad4fe5f35fea75088c11986e51", "html_url": "https://github.com/rust-lang/rust/commit/638f84d782e9d8ad4fe5f35fea75088c11986e51"}], "stats": {"total": 7690, "additions": 5204, "deletions": 2486}, "files": [{"sha": "8601fbe27f3fa27c0f0e08b181585829a22bc888", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 91, "deletions": 21, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -2,9 +2,13 @@ use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed};\n use rustc_infer::infer::canonical::Canonical;\n use rustc_infer::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc_infer::infer::region_constraints::Constraint;\n+use rustc_infer::infer::region_constraints::RegionConstraintData;\n+use rustc_infer::infer::RegionVariableOrigin;\n use rustc_infer::infer::{InferCtxt, RegionResolutionError, SubregionOrigin, TyCtxtInferExt as _};\n use rustc_infer::traits::{Normalized, ObligationCause, TraitEngine, TraitEngineExt};\n use rustc_middle::ty::error::TypeError;\n+use rustc_middle::ty::RegionVid;\n+use rustc_middle::ty::UniverseIndex;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::type_op;\n@@ -76,6 +80,15 @@ crate trait ToUniverseInfo<'tcx> {\n     fn to_universe_info(self, base_universe: ty::UniverseIndex) -> UniverseInfo<'tcx>;\n }\n \n+impl<'tcx> ToUniverseInfo<'tcx> for crate::type_check::InstantiateOpaqueType<'tcx> {\n+    fn to_universe_info(self, base_universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n+        UniverseInfo(UniverseInfoInner::TypeOp(Rc::new(crate::type_check::InstantiateOpaqueType {\n+            base_universe: Some(base_universe),\n+            ..self\n+        })))\n+    }\n+}\n+\n impl<'tcx> ToUniverseInfo<'tcx>\n     for Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::prove_predicate::ProvePredicate<'tcx>>>\n {\n@@ -116,6 +129,12 @@ impl<'tcx, F, G> ToUniverseInfo<'tcx> for Canonical<'tcx, type_op::custom::Custo\n     }\n }\n \n+impl<'tcx> ToUniverseInfo<'tcx> for ! {\n+    fn to_universe_info(self, _base_universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n+        self\n+    }\n+}\n+\n #[allow(unused_lifetimes)]\n trait TypeOpInfo<'tcx> {\n     /// Returns an error to be reported if rerunning the type op fails to\n@@ -130,7 +149,7 @@ trait TypeOpInfo<'tcx> {\n \n     fn nice_error(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n+        mbcx: &mut MirBorrowckCtxt<'_, 'tcx>,\n         cause: ObligationCause<'tcx>,\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n@@ -175,7 +194,7 @@ trait TypeOpInfo<'tcx> {\n         debug!(?placeholder_region);\n \n         let span = cause.span;\n-        let nice_error = self.nice_error(tcx, cause, placeholder_region, error_region);\n+        let nice_error = self.nice_error(mbcx, cause, placeholder_region, error_region);\n \n         if let Some(nice_error) = nice_error {\n             mbcx.buffer_error(nice_error);\n@@ -208,16 +227,16 @@ impl<'tcx> TypeOpInfo<'tcx> for PredicateQuery<'tcx> {\n \n     fn nice_error(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n+        mbcx: &mut MirBorrowckCtxt<'_, 'tcx>,\n         cause: ObligationCause<'tcx>,\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        tcx.infer_ctxt().enter_with_canonical(\n+        mbcx.infcx.tcx.infer_ctxt().enter_with_canonical(\n             cause.span,\n             &self.canonical_query,\n             |ref infcx, key, _| {\n-                let mut fulfill_cx = <dyn TraitEngine<'_>>::new(tcx);\n+                let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n                 type_op_prove_predicate_with_cause(infcx, &mut *fulfill_cx, key, cause);\n                 try_extract_error_from_fulfill_cx(\n                     fulfill_cx,\n@@ -255,16 +274,16 @@ where\n \n     fn nice_error(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n+        mbcx: &mut MirBorrowckCtxt<'_, 'tcx>,\n         cause: ObligationCause<'tcx>,\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        tcx.infer_ctxt().enter_with_canonical(\n+        mbcx.infcx.tcx.infer_ctxt().enter_with_canonical(\n             cause.span,\n             &self.canonical_query,\n             |ref infcx, key, _| {\n-                let mut fulfill_cx = <dyn TraitEngine<'_>>::new(tcx);\n+                let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n \n                 let mut selcx = SelectionContext::new(infcx);\n \n@@ -316,16 +335,16 @@ impl<'tcx> TypeOpInfo<'tcx> for AscribeUserTypeQuery<'tcx> {\n \n     fn nice_error(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n+        mbcx: &mut MirBorrowckCtxt<'_, 'tcx>,\n         cause: ObligationCause<'tcx>,\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        tcx.infer_ctxt().enter_with_canonical(\n+        mbcx.infcx.tcx.infer_ctxt().enter_with_canonical(\n             cause.span,\n             &self.canonical_query,\n             |ref infcx, key, _| {\n-                let mut fulfill_cx = <dyn TraitEngine<'_>>::new(tcx);\n+                let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n                 type_op_ascribe_user_type_with_span(infcx, &mut *fulfill_cx, key, Some(cause.span))\n                     .ok()?;\n                 try_extract_error_from_fulfill_cx(\n@@ -339,43 +358,94 @@ impl<'tcx> TypeOpInfo<'tcx> for AscribeUserTypeQuery<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeOpInfo<'tcx> for crate::type_check::InstantiateOpaqueType<'tcx> {\n+    fn fallback_error(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        span: Span,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+        // FIXME: This error message isn't great, but it doesn't show up in the existing UI tests,\n+        // and is only the fallback when the nice error fails. Consider improving this some more.\n+        tcx.sess.struct_span_err(span, \"higher-ranked lifetime error for opaque type!\")\n+    }\n+\n+    fn base_universe(&self) -> ty::UniverseIndex {\n+        self.base_universe.unwrap()\n+    }\n+\n+    fn nice_error(\n+        &self,\n+        mbcx: &mut MirBorrowckCtxt<'_, 'tcx>,\n+        _cause: ObligationCause<'tcx>,\n+        placeholder_region: ty::Region<'tcx>,\n+        error_region: Option<ty::Region<'tcx>>,\n+    ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n+        try_extract_error_from_region_constraints(\n+            mbcx.infcx,\n+            placeholder_region,\n+            error_region,\n+            self.region_constraints.as_ref().unwrap(),\n+            // We're using the original `InferCtxt` that we\n+            // started MIR borrowchecking with, so the region\n+            // constraints have already been taken. Use the data from\n+            // our `mbcx` instead.\n+            |vid| mbcx.regioncx.var_infos[vid].origin,\n+            |vid| mbcx.regioncx.var_infos[vid].universe,\n+        )\n+    }\n+}\n+\n #[instrument(skip(fulfill_cx, infcx), level = \"debug\")]\n fn try_extract_error_from_fulfill_cx<'tcx>(\n     mut fulfill_cx: Box<dyn TraitEngine<'tcx> + 'tcx>,\n     infcx: &InferCtxt<'_, 'tcx>,\n     placeholder_region: ty::Region<'tcx>,\n     error_region: Option<ty::Region<'tcx>>,\n ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-    let tcx = infcx.tcx;\n-\n     // We generally shouldn't have errors here because the query was\n     // already run, but there's no point using `delay_span_bug`\n     // when we're going to emit an error here anyway.\n     let _errors = fulfill_cx.select_all_or_error(infcx);\n+    let region_constraints = infcx.with_region_constraints(|r| r.clone());\n+    try_extract_error_from_region_constraints(\n+        infcx,\n+        placeholder_region,\n+        error_region,\n+        &region_constraints,\n+        |vid| infcx.region_var_origin(vid),\n+        |vid| infcx.universe_of_region(infcx.tcx.mk_region(ty::ReVar(vid))),\n+    )\n+}\n \n-    let (sub_region, cause) = infcx.with_region_constraints(|region_constraints| {\n-        debug!(\"{:#?}\", region_constraints);\n+fn try_extract_error_from_region_constraints<'tcx>(\n+    infcx: &InferCtxt<'_, 'tcx>,\n+    placeholder_region: ty::Region<'tcx>,\n+    error_region: Option<ty::Region<'tcx>>,\n+    region_constraints: &RegionConstraintData<'tcx>,\n+    mut region_var_origin: impl FnMut(RegionVid) -> RegionVariableOrigin,\n+    mut universe_of_region: impl FnMut(RegionVid) -> UniverseIndex,\n+) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n+    let (sub_region, cause) =\n         region_constraints.constraints.iter().find_map(|(constraint, cause)| {\n             match *constraint {\n                 Constraint::RegSubReg(sub, sup) if sup == placeholder_region && sup != sub => {\n                     Some((sub, cause.clone()))\n                 }\n                 // FIXME: Should this check the universe of the var?\n                 Constraint::VarSubReg(vid, sup) if sup == placeholder_region => {\n-                    Some((tcx.mk_region(ty::ReVar(vid)), cause.clone()))\n+                    Some((infcx.tcx.mk_region(ty::ReVar(vid)), cause.clone()))\n                 }\n                 _ => None,\n             }\n-        })\n-    })?;\n+        })?;\n \n     debug!(?sub_region, \"cause = {:#?}\", cause);\n     let nice_error = match (error_region, *sub_region) {\n         (Some(error_region), ty::ReVar(vid)) => NiceRegionError::new(\n             infcx,\n             RegionResolutionError::SubSupConflict(\n                 vid,\n-                infcx.region_var_origin(vid),\n+                region_var_origin(vid),\n                 cause.clone(),\n                 error_region,\n                 cause.clone(),\n@@ -392,8 +462,8 @@ fn try_extract_error_from_fulfill_cx<'tcx>(\n             infcx,\n             RegionResolutionError::UpperBoundUniverseConflict(\n                 vid,\n-                infcx.region_var_origin(vid),\n-                infcx.universe_of_region(sub_region),\n+                region_var_origin(vid),\n+                universe_of_region(vid),\n                 cause.clone(),\n                 placeholder_region,\n             ),"}, {"sha": "58b246ec873ca27a329ac72be71f0a7aae7f937f", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -7,6 +7,7 @@\n #![feature(let_chains)]\n #![feature(let_else)]\n #![feature(min_specialization)]\n+#![feature(never_type)]\n #![feature(stmt_expr_attributes)]\n #![feature(trusted_step)]\n #![feature(try_blocks)]\n@@ -125,8 +126,9 @@ fn mir_borrowck<'tcx>(\n ) -> &'tcx BorrowCheckResult<'tcx> {\n     let (input_body, promoted) = tcx.mir_promoted(def);\n     debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def.did.to_def_id()));\n+    let hir_owner = tcx.hir().local_def_id_to_hir_id(def.did).owner;\n \n-    let opt_closure_req = tcx.infer_ctxt().with_opaque_type_inference(def.did).enter(|infcx| {\n+    let opt_closure_req = tcx.infer_ctxt().with_opaque_type_inference(hir_owner).enter(|infcx| {\n         let input_body: &Body<'_> = &input_body.borrow();\n         let promoted: &IndexVec<_, _> = &promoted.borrow();\n         do_mir_borrowck(&infcx, input_body, promoted, false).0\n@@ -141,7 +143,7 @@ fn mir_borrowck<'tcx>(\n /// If `return_body_with_facts` is true, then return the body with non-erased\n /// region ids on which the borrow checking was performed together with Polonius\n /// facts.\n-#[instrument(skip(infcx, input_body, input_promoted), level = \"debug\")]\n+#[instrument(skip(infcx, input_body, input_promoted), fields(id=?input_body.source.with_opt_param().as_local().unwrap()), level = \"debug\")]\n fn do_mir_borrowck<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     input_body: &Body<'tcx>,"}, {"sha": "9242c6aeb8b28c2f25488109856cd9b32c1cc161", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::mir::{\n     BasicBlock, Body, ClosureOutlivesSubject, ClosureRegionRequirements, LocalKind, Location,\n     Promoted,\n };\n-use rustc_middle::ty::{self, OpaqueTypeKey, Region, RegionVid, Ty};\n+use rustc_middle::ty::{self, OpaqueHiddenType, OpaqueTypeKey, Region, RegionVid};\n use rustc_span::symbol::sym;\n use std::env;\n use std::fmt::Debug;\n@@ -43,7 +43,7 @@ pub type PoloniusOutput = Output<RustcFacts>;\n /// closure requirements to propagate, and any generated errors.\n crate struct NllOutput<'tcx> {\n     pub regioncx: RegionInferenceContext<'tcx>,\n-    pub opaque_type_values: VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>>,\n+    pub opaque_type_values: VecMap<OpaqueTypeKey<'tcx>, OpaqueHiddenType<'tcx>>,\n     pub polonius_input: Option<Box<AllFacts>>,\n     pub polonius_output: Option<Rc<PoloniusOutput>>,\n     pub opt_closure_req: Option<ClosureRegionRequirements<'tcx>>,\n@@ -305,7 +305,7 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n         infcx.set_tainted_by_errors();\n     }\n \n-    let remapped_opaque_tys = regioncx.infer_opaque_types(&infcx, opaque_type_values, body.span);\n+    let remapped_opaque_tys = regioncx.infer_opaque_types(&infcx, opaque_type_values);\n \n     NllOutput {\n         regioncx,\n@@ -372,7 +372,7 @@ pub(super) fn dump_annotation<'a, 'tcx>(\n     body: &Body<'tcx>,\n     regioncx: &RegionInferenceContext<'tcx>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,\n-    opaque_type_values: &VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>>,\n+    opaque_type_values: &VecMap<OpaqueTypeKey<'tcx>, OpaqueHiddenType<'tcx>>,\n     errors: &mut crate::error::BorrowckErrors<'tcx>,\n ) {\n     let tcx = infcx.tcx;"}, {"sha": "1f81f7dda1334f85fcb95a313b71ba83ef4836ce", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -45,6 +45,7 @@ mod reverse_sccs;\n pub mod values;\n \n pub struct RegionInferenceContext<'tcx> {\n+    pub var_infos: VarInfos,\n     /// Contains the definition for every region variable. Region\n     /// variables are identified by their index (`RegionVid`). The\n     /// definition contains information about where the region came\n@@ -267,7 +268,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> Self {\n         // Create a RegionDefinition for each inference variable.\n         let definitions: IndexVec<_, _> = var_infos\n-            .into_iter()\n+            .iter()\n             .map(|info| RegionDefinition::new(info.universe, info.origin))\n             .collect();\n \n@@ -292,6 +293,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             Rc::new(member_constraints_in.into_mapped(|r| constraint_sccs.scc(r)));\n \n         let mut result = Self {\n+            var_infos,\n             definitions,\n             liveness_constraints,\n             constraints,"}, {"sha": "f454141dc522995afa50fd81e3bc3245ab8b242d", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 41, "deletions": 25, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,10 +1,9 @@\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir::OpaqueTyOrigin;\n-use rustc_infer::infer::opaque_types::OpaqueTypeDecl;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, OpaqueHiddenType, OpaqueTypeKey, TyCtxt, TypeFoldable};\n use rustc_span::Span;\n use rustc_trait_selection::opaque_types::InferCtxtExt;\n \n@@ -54,27 +53,41 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(crate) fn infer_opaque_types(\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n-        opaque_ty_decls: VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>,\n-        span: Span,\n-    ) -> VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>> {\n+        opaque_ty_decls: VecMap<OpaqueTypeKey<'tcx>, (OpaqueHiddenType<'tcx>, OpaqueTyOrigin)>,\n+    ) -> VecMap<OpaqueTypeKey<'tcx>, OpaqueHiddenType<'tcx>> {\n         opaque_ty_decls\n             .into_iter()\n-            .filter_map(|(opaque_type_key, decl)| {\n+            .map(|(opaque_type_key, (concrete_type, origin))| {\n                 let substs = opaque_type_key.substs;\n-                let concrete_type = decl.concrete_ty;\n                 debug!(?concrete_type, ?substs);\n \n                 let mut subst_regions = vec![self.universal_regions.fr_static];\n                 let universal_substs = infcx.tcx.fold_regions(substs, &mut false, |region, _| {\n-                    let vid = self.universal_regions.to_region_vid(region);\n-                    subst_regions.push(vid);\n-                    self.definitions[vid].external_name.unwrap_or_else(|| {\n-                        infcx\n-                            .tcx\n-                            .sess\n-                            .delay_span_bug(span, \"opaque type with non-universal region substs\");\n-                        infcx.tcx.lifetimes.re_static\n-                    })\n+                    if let ty::RePlaceholder(..) = region.kind() {\n+                        // Higher kinded regions don't need remapping, they don't refer to anything outside of this the substs.\n+                        return region;\n+                    }\n+                    let vid = self.to_region_vid(region);\n+                    trace!(?vid);\n+                    let scc = self.constraint_sccs.scc(vid);\n+                    trace!(?scc);\n+                    match self.scc_values.universal_regions_outlived_by(scc).find_map(|lb| {\n+                        self.eval_equal(vid, lb).then_some(self.definitions[lb].external_name?)\n+                    }) {\n+                        Some(region) => {\n+                            let vid = self.universal_regions.to_region_vid(region);\n+                            subst_regions.push(vid);\n+                            region\n+                        }\n+                        None => {\n+                            subst_regions.push(vid);\n+                            infcx.tcx.sess.delay_span_bug(\n+                                concrete_type.span,\n+                                \"opaque type with non-universal region substs\",\n+                            );\n+                            infcx.tcx.lifetimes.re_static\n+                        }\n+                    }\n                 });\n \n                 subst_regions.sort();\n@@ -97,15 +110,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 let remapped_type = infcx.infer_opaque_definition_from_instantiation(\n                     opaque_type_key,\n                     universal_concrete_type,\n-                    span,\n                 );\n-\n-                check_opaque_type_parameter_valid(\n+                let ty = if check_opaque_type_parameter_valid(\n                     infcx.tcx,\n                     opaque_type_key,\n-                    OpaqueTypeDecl { concrete_ty: remapped_type, ..decl },\n-                )\n-                .then_some((opaque_type_key, remapped_type))\n+                    origin,\n+                    concrete_type.span,\n+                ) {\n+                    remapped_type\n+                } else {\n+                    infcx.tcx.ty_error()\n+                };\n+                (opaque_type_key, OpaqueHiddenType { ty, span: concrete_type.span })\n             })\n             .collect()\n     }\n@@ -149,9 +165,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n fn check_opaque_type_parameter_valid(\n     tcx: TyCtxt<'_>,\n     opaque_type_key: OpaqueTypeKey<'_>,\n-    decl: OpaqueTypeDecl<'_>,\n+    origin: OpaqueTyOrigin,\n+    span: Span,\n ) -> bool {\n-    match decl.origin {\n+    match origin {\n         // No need to check return position impl trait (RPIT)\n         // because for type and const parameters they are correct\n         // by construction: we convert\n@@ -177,7 +194,6 @@ fn check_opaque_type_parameter_valid(\n         // Check these\n         OpaqueTyOrigin::TyAlias => {}\n     }\n-    let span = decl.definition_span;\n     let opaque_generics = tcx.generics_of(opaque_type_key.def_id);\n     let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n     for (i, arg) in opaque_type_key.substs.iter().enumerate() {"}, {"sha": "3856b7f4a4b8227e182bd3e2969a962085958ee0", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -33,12 +33,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     ) -> Fallible<R>\n     where\n         Op: type_op::TypeOp<'tcx, Output = R>,\n-        Canonical<'tcx, Op>: ToUniverseInfo<'tcx>,\n+        Op::ErrorInfo: ToUniverseInfo<'tcx>,\n     {\n         let old_universe = self.infcx.universe();\n \n-        let TypeOpOutput { output, constraints, canonicalized_query } =\n-            op.fully_perform(self.infcx)?;\n+        let TypeOpOutput { output, constraints, error_info } = op.fully_perform(self.infcx)?;\n \n         if let Some(data) = &constraints {\n             self.push_region_constraints(locations, category, data);\n@@ -47,8 +46,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         let universe = self.infcx.universe();\n \n         if old_universe != universe {\n-            let universe_info = match canonicalized_query {\n-                Some(canonicalized_query) => canonicalized_query.to_universe_info(old_universe),\n+            let universe_info = match error_info {\n+                Some(error_info) => error_info.to_universe_info(old_universe),\n                 None => UniverseInfo::other(),\n             };\n             for u in old_universe..universe {"}, {"sha": "0b9d0a0e9220b29c9f6779a146e89fc6f164d825", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -267,7 +267,7 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n                         TypeOpOutput {\n                             output: self.infcx.tcx.ty_error(),\n                             constraints: None,\n-                            canonicalized_query: None,\n+                            error_info: None,\n                         }\n                     });\n                 // Note: we need this in examples like"}, {"sha": "83c8ecba1f17aa78d86d2af0a8a8c76dbc69bf06", "filename": "compiler/rustc_borrowck/src/type_check/input_output.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -147,9 +147,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // Return types are a bit more complex. They may contain opaque `impl Trait` types.\n         let mir_output_ty = body.local_decls[RETURN_PLACE].ty;\n         let output_span = body.local_decls[RETURN_PLACE].source_info.span;\n-        if let Err(terr) = self.eq_opaque_type_and_type(\n-            mir_output_ty,\n+        if let Err(terr) = self.eq_types(\n             normalized_output_ty,\n+            mir_output_ty,\n             Locations::All(output_span),\n             ConstraintCategory::BoringNoLocation,\n         ) {\n@@ -169,9 +169,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             let user_provided_output_ty = user_provided_sig.output();\n             let user_provided_output_ty =\n                 self.normalize(user_provided_output_ty, Locations::All(output_span));\n-            if let Err(err) = self.eq_opaque_type_and_type(\n-                mir_output_ty,\n+            if let Err(err) = self.eq_types(\n                 user_provided_output_ty,\n+                mir_output_ty,\n                 Locations::All(output_span),\n                 ConstraintCategory::BoringNoLocation,\n             ) {"}, {"sha": "9d7dcc5379c5d41f07a44a1e0298a4af291271fb", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 77, "deletions": 198, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -5,6 +5,7 @@ use std::{fmt, iter, mem};\n \n use either::Either;\n \n+use hir::OpaqueTyOrigin;\n use rustc_data_structures::frozen::Frozen;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::vec_map::VecMap;\n@@ -15,8 +16,8 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n-use rustc_infer::infer::opaque_types::OpaqueTypeDecl;\n use rustc_infer::infer::outlives::env::RegionBoundPairs;\n+use rustc_infer::infer::region_constraints::RegionConstraintData;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{\n     InferCtxt, InferOk, LateBoundRegionConversionTime, NllRegionVariableOrigin,\n@@ -30,18 +31,20 @@ use rustc_middle::ty::cast::CastTy;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef, UserSubsts};\n use rustc_middle::ty::{\n-    self, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, OpaqueTypeKey, RegionVid,\n-    ToPredicate, Ty, TyCtxt, UserType, UserTypeAnnotationIndex,\n+    self, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, OpaqueHiddenType,\n+    OpaqueTypeKey, RegionVid, ToPredicate, Ty, TyCtxt, UserType, UserTypeAnnotationIndex,\n };\n use rustc_span::def_id::CRATE_DEF_ID;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::VariantIdx;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::type_op;\n+use rustc_trait_selection::traits::query::type_op::custom::scrape_region_constraints;\n use rustc_trait_selection::traits::query::type_op::custom::CustomTypeOp;\n+use rustc_trait_selection::traits::query::type_op::{TypeOp, TypeOpOutput};\n use rustc_trait_selection::traits::query::Fallible;\n-use rustc_trait_selection::traits::{self, ObligationCause, PredicateObligations};\n+use rustc_trait_selection::traits::{self, ObligationCause, PredicateObligation};\n \n use rustc_const_eval::transform::{\n     check_consts::ConstCx, promote_consts::is_const_fn_in_array_repeat_expression,\n@@ -75,7 +78,7 @@ macro_rules! span_mirbug {\n             $context.last_span,\n             &format!(\n                 \"broken MIR in {:?} ({:?}): {}\",\n-                $context.body.source.def_id(),\n+                $context.body().source.def_id(),\n                 $elem,\n                 format_args!($($message)*),\n             ),\n@@ -199,59 +202,44 @@ pub(crate) fn type_check<'mir, 'tcx>(\n             );\n \n             translate_outlives_facts(&mut cx);\n-            let opaque_type_values = mem::take(&mut infcx.inner.borrow_mut().opaque_types);\n+            let opaque_type_values =\n+                infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n \n             opaque_type_values\n                 .into_iter()\n-                .filter_map(|(opaque_type_key, mut decl)| {\n-                    decl.concrete_ty = infcx.resolve_vars_if_possible(decl.concrete_ty);\n+                .map(|(opaque_type_key, decl)| {\n+                    cx.fully_perform_op(\n+                        Locations::All(body.span),\n+                        ConstraintCategory::OpaqueType,\n+                        CustomTypeOp::new(\n+                            |infcx| {\n+                                infcx.register_member_constraints(\n+                                    param_env,\n+                                    opaque_type_key,\n+                                    decl.hidden_type.ty,\n+                                    decl.hidden_type.span,\n+                                );\n+                                Ok(InferOk { value: (), obligations: vec![] })\n+                            },\n+                            || \"opaque_type_map\".to_string(),\n+                        ),\n+                    )\n+                    .unwrap();\n+                    let mut hidden_type = infcx.resolve_vars_if_possible(decl.hidden_type);\n                     trace!(\n                         \"finalized opaque type {:?} to {:#?}\",\n                         opaque_type_key,\n-                        decl.concrete_ty.kind()\n+                        hidden_type.ty.kind()\n                     );\n-                    if decl.concrete_ty.has_infer_types_or_consts() {\n+                    if hidden_type.has_infer_types_or_consts() {\n                         infcx.tcx.sess.delay_span_bug(\n-                            body.span,\n-                            &format!(\"could not resolve {:#?}\", decl.concrete_ty.kind()),\n+                            decl.hidden_type.span,\n+                            &format!(\"could not resolve {:#?}\", hidden_type.ty.kind()),\n                         );\n-                        decl.concrete_ty = infcx.tcx.ty_error();\n+                        hidden_type.ty = infcx.tcx.ty_error();\n                     }\n-                    let concrete_is_opaque = if let ty::Opaque(def_id, _) = decl.concrete_ty.kind()\n-                    {\n-                        *def_id == opaque_type_key.def_id\n-                    } else {\n-                        false\n-                    };\n \n-                    if concrete_is_opaque {\n-                        // We're using an opaque `impl Trait` type without\n-                        // 'revealing' it. For example, code like this:\n-                        //\n-                        // type Foo = impl Debug;\n-                        // fn foo1() -> Foo { ... }\n-                        // fn foo2() -> Foo { foo1() }\n-                        //\n-                        // In `foo2`, we're not revealing the type of `Foo` - we're\n-                        // just treating it as the opaque type.\n-                        //\n-                        // When this occurs, we do *not* want to try to equate\n-                        // the concrete type with the underlying defining type\n-                        // of the opaque type - this will always fail, since\n-                        // the defining type of an opaque type is always\n-                        // some other type (e.g. not itself)\n-                        // Essentially, none of the normal obligations apply here -\n-                        // we're just passing around some unknown opaque type,\n-                        // without actually looking at the underlying type it\n-                        // gets 'revealed' into\n-                        debug!(\n-                            \"eq_opaque_type_and_type: non-defining use of {:?}\",\n-                            opaque_type_key.def_id,\n-                        );\n-                        None\n-                    } else {\n-                        Some((opaque_type_key, decl))\n-                    }\n+                    (opaque_type_key, (hidden_type, decl.origin))\n                 })\n                 .collect()\n         },\n@@ -283,7 +271,7 @@ fn type_check_internal<'a, 'tcx, R>(\n         borrowck_context,\n     );\n     let errors_reported = {\n-        let mut verifier = TypeVerifier::new(&mut checker, body, promoted);\n+        let mut verifier = TypeVerifier::new(&mut checker, promoted);\n         verifier.visit_body(&body);\n         verifier.errors_reported\n     };\n@@ -340,7 +328,6 @@ enum FieldAccessError {\n /// is a problem.\n struct TypeVerifier<'a, 'b, 'tcx> {\n     cx: &'a mut TypeChecker<'b, 'tcx>,\n-    body: &'b Body<'tcx>,\n     promoted: &'b IndexVec<Promoted, Body<'tcx>>,\n     last_span: Span,\n     errors_reported: bool,\n@@ -476,7 +463,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n \n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         self.super_rvalue(rvalue, location);\n-        let rval_ty = rvalue.ty(self.body, self.tcx());\n+        let rval_ty = rvalue.ty(self.body(), self.tcx());\n         self.sanitize_type(rvalue, rval_ty);\n     }\n \n@@ -535,10 +522,13 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n     fn new(\n         cx: &'a mut TypeChecker<'b, 'tcx>,\n-        body: &'b Body<'tcx>,\n         promoted: &'b IndexVec<Promoted, Body<'tcx>>,\n     ) -> Self {\n-        TypeVerifier { body, promoted, cx, last_span: body.span, errors_reported: false }\n+        TypeVerifier { promoted, last_span: cx.body.span, cx, errors_reported: false }\n+    }\n+\n+    fn body(&self) -> &Body<'tcx> {\n+        self.cx.body\n     }\n \n     fn tcx(&self) -> TyCtxt<'tcx> {\n@@ -563,7 +553,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n     ) -> PlaceTy<'tcx> {\n         debug!(\"sanitize_place: {:?}\", place);\n \n-        let mut place_ty = PlaceTy::from_ty(self.body.local_decls[place.local].ty);\n+        let mut place_ty = PlaceTy::from_ty(self.body().local_decls[place.local].ty);\n \n         for elem in place.projection.iter() {\n             if place_ty.variant_index.is_none() {\n@@ -608,7 +598,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         // checker on the promoted MIR, then transfer the constraints back to\n         // the main MIR, changing the locations to the provided location.\n \n-        let parent_body = mem::replace(&mut self.body, promoted_body);\n+        let parent_body = mem::replace(&mut self.cx.body, promoted_body);\n \n         // Use new sets of constraints and closure bounds so that we can\n         // modify their locations.\n@@ -644,7 +634,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n             self.cx.typeck_mir(promoted_body);\n         }\n \n-        self.body = parent_body;\n+        self.cx.body = parent_body;\n         // Merge the outlives constraints back in, at the given location.\n         swap_constraints(self);\n \n@@ -706,7 +696,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 }))\n             }\n             ProjectionElem::Index(i) => {\n-                let index_ty = Place::from(i).ty(self.body, tcx).ty;\n+                let index_ty = Place::from(i).ty(self.body(), tcx).ty;\n                 if index_ty != tcx.types.usize {\n                     PlaceTy::from_ty(span_mirbug_and_err!(self, i, \"index by non-usize {:?}\", i))\n                 } else {\n@@ -915,7 +905,7 @@ struct BorrowCheckContext<'a, 'tcx> {\n crate struct MirTypeckResults<'tcx> {\n     crate constraints: MirTypeckRegionConstraints<'tcx>,\n     crate universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n-    crate opaque_type_values: VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>,\n+    crate opaque_type_values: VecMap<OpaqueTypeKey<'tcx>, (OpaqueHiddenType<'tcx>, OpaqueTyOrigin)>,\n }\n \n /// A collection of region constraints that must be satisfied for the\n@@ -1065,17 +1055,19 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         checker\n     }\n \n+    fn body(&self) -> &Body<'tcx> {\n+        self.body\n+    }\n+\n     fn unsized_feature_enabled(&self) -> bool {\n         let features = self.tcx().features();\n         features.unsized_locals || features.unsized_fn_params\n     }\n \n     /// Equate the inferred type and the annotated type for user type annotations\n+    #[instrument(skip(self), level = \"debug\")]\n     fn check_user_type_annotations(&mut self) {\n-        debug!(\n-            \"check_user_type_annotations: user_type_annotations={:?}\",\n-            self.user_type_annotations\n-        );\n+        debug!(?self.user_type_annotations);\n         for user_annotation in self.user_type_annotations {\n             let CanonicalUserTypeAnnotation { span, ref user_ty, inferred_ty } = *user_annotation;\n             let inferred_ty = self.normalize(inferred_ty, Locations::All(span));\n@@ -1216,131 +1208,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         Ok(())\n     }\n \n-    /// Equates a type `anon_ty` that may contain opaque types whose\n-    /// values are to be inferred by the MIR.\n-    ///\n-    /// The type `revealed_ty` contains the same type as `anon_ty`, but with the\n-    /// hidden types for impl traits revealed.\n-    ///\n-    /// # Example\n-    ///\n-    /// Consider a piece of code like\n-    ///\n-    /// ```rust\n-    /// type Foo<U> = impl Debug;\n-    ///\n-    /// fn foo<T: Debug>(t: T) -> Box<Foo<T>> {\n-    ///      Box::new((t, 22_u32))\n-    /// }\n-    /// ```\n-    ///\n-    /// Here, the function signature would be something like\n-    /// `fn(T) -> Box<impl Debug>`. The MIR return slot would have\n-    /// the type with the opaque type revealed, so `Box<(T, u32)>`.\n-    ///\n-    /// In terms of our function parameters:\n-    ///\n-    /// * `anon_ty` would be `Box<Foo<T>>` where `Foo<T>` is an opaque type\n-    ///   scoped to this function (note that it is parameterized by the\n-    ///   generics of `foo`). Note that `anon_ty` is not just the opaque type,\n-    ///   but the entire return type (which may contain opaque types within it).\n-    /// * `revealed_ty` would be `Box<(T, u32)>`\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn eq_opaque_type_and_type(\n-        &mut self,\n-        revealed_ty: Ty<'tcx>,\n-        anon_ty: Ty<'tcx>,\n-        locations: Locations,\n-        category: ConstraintCategory,\n-    ) -> Fallible<()> {\n-        // Fast path for the common case.\n-        if !anon_ty.has_opaque_types() {\n-            if let Err(terr) = self.eq_types(anon_ty, revealed_ty, locations, category) {\n-                span_mirbug!(\n-                    self,\n-                    locations,\n-                    \"eq_opaque_type_and_type: `{:?}=={:?}` failed with `{:?}`\",\n-                    revealed_ty,\n-                    anon_ty,\n-                    terr\n-                );\n-            }\n-            return Ok(());\n-        }\n-\n-        let param_env = self.param_env;\n-        let body = self.body;\n-        let mir_def_id = body.source.def_id().expect_local();\n-\n-        debug!(?mir_def_id);\n-        self.fully_perform_op(\n-            locations,\n-            category,\n-            CustomTypeOp::new(\n-                |infcx| {\n-                    let mut obligations = ObligationAccumulator::default();\n-\n-                    let dummy_body_id = hir::CRATE_HIR_ID;\n-\n-                    // Replace the opaque types defined by this function with\n-                    // inference variables, creating a map. In our example above,\n-                    // this would transform the type `Box<Foo<T>>` (where `Foo` is an opaque type)\n-                    // to `Box<?T>`, returning an `opaque_type_map` mapping `{Foo<T> -> ?T}`.\n-                    // (Note that the key of the map is both the def-id of `Foo` along with\n-                    // any generic parameters.)\n-                    let output_ty = obligations.add(infcx.instantiate_opaque_types(\n-                        dummy_body_id,\n-                        param_env,\n-                        anon_ty,\n-                        locations.span(body),\n-                    ));\n-                    debug!(?output_ty, ?revealed_ty);\n-\n-                    // Make sure that the inferred types are well-formed. I'm\n-                    // not entirely sure this is needed (the HIR type check\n-                    // didn't do this) but it seems sensible to prevent opaque\n-                    // types hiding ill-formed types.\n-                    obligations.obligations.push(traits::Obligation::new(\n-                        ObligationCause::dummy(),\n-                        param_env,\n-                        ty::Binder::dummy(ty::PredicateKind::WellFormed(revealed_ty.into()))\n-                            .to_predicate(infcx.tcx),\n-                    ));\n-                    obligations.add(\n-                        infcx\n-                            .at(&ObligationCause::dummy(), param_env)\n-                            .eq(output_ty, revealed_ty)?,\n-                    );\n-\n-                    debug!(\"equated\");\n-\n-                    Ok(InferOk { value: (), obligations: obligations.into_vec() })\n-                },\n-                || \"input_output\".to_string(),\n-            ),\n-        )?;\n-\n-        // Finally, if we instantiated the anon types successfully, we\n-        // have to solve any bounds (e.g., `-> impl Iterator` needs to\n-        // prove that `T: Iterator` where `T` is the type we\n-        // instantiated it with).\n-        let opaque_type_map = self.infcx.inner.borrow().opaque_types.clone();\n-        for (opaque_type_key, opaque_decl) in opaque_type_map {\n-            self.fully_perform_op(\n-                locations,\n-                ConstraintCategory::OpaqueType,\n-                CustomTypeOp::new(\n-                    |infcx| {\n-                        infcx.constrain_opaque_type(opaque_type_key, &opaque_decl);\n-                        Ok(InferOk { value: (), obligations: vec![] })\n-                    },\n-                    || \"opaque_type_map\".to_string(),\n-                ),\n-            )?;\n-        }\n-        Ok(())\n-    }\n-\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n@@ -2772,19 +2639,31 @@ impl NormalizeLocation for Location {\n     }\n }\n \n-#[derive(Debug, Default)]\n-struct ObligationAccumulator<'tcx> {\n-    obligations: PredicateObligations<'tcx>,\n+/// Runs `infcx.instantiate_opaque_types`. Unlike other `TypeOp`s,\n+/// this is not canonicalized - it directly affects the main `InferCtxt`\n+/// that we use during MIR borrowchecking.\n+#[derive(Debug)]\n+pub(super) struct InstantiateOpaqueType<'tcx> {\n+    pub base_universe: Option<ty::UniverseIndex>,\n+    pub region_constraints: Option<RegionConstraintData<'tcx>>,\n+    pub obligations: Vec<PredicateObligation<'tcx>>,\n }\n \n-impl<'tcx> ObligationAccumulator<'tcx> {\n-    fn add<T>(&mut self, value: InferOk<'tcx, T>) -> T {\n-        let InferOk { value, obligations } = value;\n-        self.obligations.extend(obligations);\n-        value\n-    }\n-\n-    fn into_vec(self) -> PredicateObligations<'tcx> {\n-        self.obligations\n+impl<'tcx> TypeOp<'tcx> for InstantiateOpaqueType<'tcx> {\n+    type Output = ();\n+    /// We use this type itself to store the information used\n+    /// when reporting errors. Since this is not a query, we don't\n+    /// re-run anything during error reporting - we just use the information\n+    /// we saved to help extract an error from the already-existing region\n+    /// constraints in our `InferCtxt`\n+    type ErrorInfo = InstantiateOpaqueType<'tcx>;\n+\n+    fn fully_perform(mut self, infcx: &InferCtxt<'_, 'tcx>) -> Fallible<TypeOpOutput<'tcx, Self>> {\n+        let (mut output, region_constraints) = scrape_region_constraints(infcx, || {\n+            Ok(InferOk { value: (), obligations: self.obligations.clone() })\n+        })?;\n+        self.region_constraints = Some(region_constraints);\n+        output.error_info = Some(self);\n+        Ok(output)\n     }\n }"}, {"sha": "8a757636087dfb92e5535c3565c35f719c5a3a58", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,13 +1,16 @@\n use rustc_infer::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRelatingDelegate};\n use rustc_infer::infer::NllRegionVariableOrigin;\n+use rustc_infer::traits::ObligationCause;\n use rustc_middle::mir::ConstraintCategory;\n+use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::{self, Const, Ty};\n+use rustc_span::Span;\n use rustc_trait_selection::traits::query::Fallible;\n \n use crate::constraints::OutlivesConstraint;\n use crate::diagnostics::UniverseInfo;\n-use crate::type_check::{Locations, TypeChecker};\n+use crate::type_check::{InstantiateOpaqueType, Locations, TypeChecker};\n \n impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     /// Adds sufficient constraints to ensure that `a R b` where `R` depends on `v`:\n@@ -63,6 +66,10 @@ impl<'me, 'bccx, 'tcx> NllTypeRelatingDelegate<'me, 'bccx, 'tcx> {\n }\n \n impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx> {\n+    fn span(&self) -> Span {\n+        self.locations.span(self.type_checker.body)\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.type_checker.param_env\n     }\n@@ -117,6 +124,9 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n \n     // We don't have to worry about the equality of consts during borrow checking\n     // as consts always have a static lifetime.\n+    // FIXME(oli-obk): is this really true? We can at least have HKL and with\n+    // inline consts we may have further lifetimes that may be unsound to treat as\n+    // 'static.\n     fn const_equate(&mut self, _a: Const<'tcx>, _b: Const<'tcx>) {}\n \n     fn normalization() -> NormalizationStrategy {\n@@ -126,4 +136,34 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n     fn forbid_inference_vars() -> bool {\n         true\n     }\n+\n+    fn register_opaque_type(\n+        &mut self,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n+        a_is_expected: bool,\n+    ) -> Result<(), TypeError<'tcx>> {\n+        let param_env = self.param_env();\n+        let span = self.span();\n+        let def_id = self.type_checker.body.source.def_id().expect_local();\n+        let body_id = self.type_checker.tcx().hir().local_def_id_to_hir_id(def_id);\n+        let cause = ObligationCause::misc(span, body_id);\n+        self.type_checker\n+            .fully_perform_op(\n+                self.locations,\n+                self.category,\n+                InstantiateOpaqueType {\n+                    obligations: self\n+                        .type_checker\n+                        .infcx\n+                        .handle_opaque_type(a, b, a_is_expected, &cause, param_env)?\n+                        .obligations,\n+                    // These fields are filled in during exectuion of the operation\n+                    base_universe: None,\n+                    region_constraints: None,\n+                },\n+            )\n+            .unwrap();\n+        Ok(())\n+    }\n }"}, {"sha": "e9c64049817f5558e16d7a7510e57a0120a690aa", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -725,6 +725,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n         self.tcx.fold_regions(value, &mut false, |_region, _depth| self.next_nll_region_var(origin))\n     }\n \n+    #[instrument(level = \"debug\", skip(self, indices))]\n     fn replace_bound_regions_with_nll_infer_vars<T>(\n         &self,\n         origin: NllRegionVariableOrigin,\n@@ -735,22 +736,15 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        debug!(\n-            \"replace_bound_regions_with_nll_infer_vars(value={:?}, all_outlive_scope={:?})\",\n-            value, all_outlive_scope,\n-        );\n         let (value, _map) = self.tcx.replace_late_bound_regions(value, |br| {\n-            debug!(\"replace_bound_regions_with_nll_infer_vars: br={:?}\", br);\n+            debug!(?br);\n             let liberated_region = self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n                 scope: all_outlive_scope.to_def_id(),\n                 bound_region: br.kind,\n             }));\n             let region_vid = self.next_nll_region_var(origin);\n             indices.insert_late_bound_region(liberated_region, region_vid.to_region_vid());\n-            debug!(\n-                \"replace_bound_regions_with_nll_infer_vars: liberated_region={:?} => {:?}\",\n-                liberated_region, region_vid\n-            );\n+            debug!(?liberated_region, ?region_vid);\n             region_vid\n         });\n         value\n@@ -765,6 +759,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n     /// entries for them and store them in the indices map. This code iterates over the complete\n     /// set of late-bound regions and checks for any that we have not yet seen, adding them to the\n     /// inputs vector.\n+    #[instrument(skip(self, indices))]\n     fn replace_late_bound_regions_with_nll_infer_vars(\n         &self,\n         mir_def_id: LocalDefId,\n@@ -776,6 +771,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n             debug!(\"replace_late_bound_regions_with_nll_infer_vars: r={:?}\", r);\n             if !indices.indices.contains_key(&r) {\n                 let region_vid = self.next_nll_region_var(FR);\n+                debug!(?region_vid);\n                 indices.insert_late_bound_region(r, region_vid.to_region_vid());\n             }\n         });"}, {"sha": "8790baa010c122c00bf411557804e1c71f356780", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::cast::CastTy;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::{self, adjustment::PointerCast, Instance, InstanceDef, Ty, TyCtxt};\n-use rustc_middle::ty::{Binder, TraitPredicate, TraitRef};\n+use rustc_middle::ty::{Binder, TraitPredicate, TraitRef, TypeFoldable};\n use rustc_mir_dataflow::{self, Analysis};\n use rustc_span::{sym, Span, Symbol};\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n@@ -47,7 +47,10 @@ impl<'mir, 'tcx> Qualifs<'mir, 'tcx> {\n         location: Location,\n     ) -> bool {\n         let ty = ccx.body.local_decls[local].ty;\n-        if !NeedsDrop::in_any_value_of_ty(ccx, ty) {\n+        // Peeking into opaque types causes cycles if the current function declares said opaque\n+        // type. Thus we avoid short circuiting on the type and instead run the more expensive\n+        // analysis that looks at the actual usage within this function\n+        if !ty.has_opaque_types() && !NeedsDrop::in_any_value_of_ty(ccx, ty) {\n             return false;\n         }\n \n@@ -101,7 +104,10 @@ impl<'mir, 'tcx> Qualifs<'mir, 'tcx> {\n         location: Location,\n     ) -> bool {\n         let ty = ccx.body.local_decls[local].ty;\n-        if !HasMutInterior::in_any_value_of_ty(ccx, ty) {\n+        // Peeking into opaque types causes cycles if the current function declares said opaque\n+        // type. Thus we avoid short circuiting on the type and instead run the more expensive\n+        // analysis that looks at the actual usage within this function\n+        if !ty.has_opaque_types() && !HasMutInterior::in_any_value_of_ty(ccx, ty) {\n             return false;\n         }\n \n@@ -148,7 +154,12 @@ impl<'mir, 'tcx> Qualifs<'mir, 'tcx> {\n \n             // If we know that all values of the return type are structurally matchable, there's no\n             // need to run dataflow.\n-            _ if !CustomEq::in_any_value_of_ty(ccx, ccx.body.return_ty()) => false,\n+            // Opaque types do not participate in const generics or pattern matching, so we can safely count them out.\n+            _ if ccx.body.return_ty().has_opaque_types()\n+                || !CustomEq::in_any_value_of_ty(ccx, ccx.body.return_ty()) =>\n+            {\n+                false\n+            }\n \n             hir::ConstContext::Const | hir::ConstContext::Static(_) => {\n                 let mut cursor = FlowSensitiveAnalysis::new(CustomEq, ccx)"}, {"sha": "263959f3cb376ed3e41468edf9039872550bf88f", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -79,7 +79,6 @@ pub fn equal_up_to_regions<'tcx>(\n     }\n \n     // Normalize lifetimes away on both sides, then compare.\n-    let param_env = param_env.with_reveal_all_normalized(tcx);\n     let normalize = |ty: Ty<'tcx>| {\n         tcx.normalize_erasing_regions(\n             param_env,\n@@ -170,9 +169,12 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             // Equal types, all is good.\n             return true;\n         }\n+        // Normalization reveals opaque types, but we may be validating MIR while computing\n+        // said opaque types, causing cycles.\n+        if (src, dest).has_opaque_types() {\n+            return true;\n+        }\n         // Normalize projections and things like that.\n-        // FIXME: We need to reveal_all, as some optimizations change types in ways\n-        // that require unfolding opaque types.\n         let param_env = self.param_env.with_reveal_all_normalized(self.tcx);\n         let src = self.tcx.normalize_erasing_regions(param_env, src);\n         let dest = self.tcx.normalize_erasing_regions(param_env, dest);"}, {"sha": "2f4b3844430e38afaf4ac523d09de47a10f59317", "filename": "compiler/rustc_data_structures/src/vec_map.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -30,6 +30,11 @@ where\n         }\n     }\n \n+    /// Removes the entry from the map and returns the removed value\n+    pub fn remove(&mut self, k: &K) -> Option<V> {\n+        self.0.iter().position(|(k2, _)| k2 == k).map(|pos| self.0.remove(pos).1)\n+    }\n+\n     /// Gets a reference to the value in the entry.\n     pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n     where\n@@ -39,6 +44,15 @@ where\n         self.0.iter().find(|(key, _)| k == key.borrow()).map(|elem| &elem.1)\n     }\n \n+    /// Gets a mutable reference to the value in the entry.\n+    pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n+    where\n+        K: Borrow<Q>,\n+        Q: Eq,\n+    {\n+        self.0.iter_mut().find(|(key, _)| k == key.borrow()).map(|elem| &mut elem.1)\n+    }\n+\n     /// Returns the any value corresponding to the supplied predicate filter.\n     ///\n     /// The supplied predicate will be applied to each (key, value) pair and it will return a\n@@ -58,7 +72,7 @@ where\n         // This should return just one element, otherwise it's a bug\n         assert!(\n             filter.next().is_none(),\n-            \"Collection {:?} should have just one matching element\",\n+            \"Collection {:#?} should have just one matching element\",\n             self\n         );\n         Some(value)"}, {"sha": "71ee4f1e76d6d01fe5aa47e174ff8b1fc3cd5d6c", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -34,6 +34,12 @@ pub struct At<'a, 'tcx> {\n     pub infcx: &'a InferCtxt<'a, 'tcx>,\n     pub cause: &'a ObligationCause<'tcx>,\n     pub param_env: ty::ParamEnv<'tcx>,\n+    /// Whether we should define opaque types\n+    /// or just treat them opaquely.\n+    /// Currently only used to prevent predicate\n+    /// matching from matching anything against opaque\n+    /// types.\n+    pub define_opaque_types: bool,\n }\n \n pub struct Trace<'a, 'tcx> {\n@@ -49,7 +55,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         cause: &'a ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> At<'a, 'tcx> {\n-        At { infcx: self, cause, param_env }\n+        At { infcx: self, cause, param_env, define_opaque_types: true }\n     }\n \n     /// Forks the inference context, creating a new inference context with the same inference\n@@ -59,6 +65,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         Self {\n             tcx: self.tcx.clone(),\n             defining_use_anchor: self.defining_use_anchor.clone(),\n+            reveal_defining_opaque_types: self.reveal_defining_opaque_types.clone(),\n             in_progress_typeck_results: self.in_progress_typeck_results.clone(),\n             inner: self.inner.clone(),\n             skip_leak_check: self.skip_leak_check.clone(),\n@@ -86,6 +93,10 @@ pub trait ToTrace<'tcx>: Relate<'tcx> + Copy {\n }\n \n impl<'a, 'tcx> At<'a, 'tcx> {\n+    pub fn define_opaque_types(self, define_opaque_types: bool) -> Self {\n+        Self { define_opaque_types, ..self }\n+    }\n+\n     /// Hacky routine for equating two impl headers in coherence.\n     pub fn eq_impl_headers(\n         self,\n@@ -216,7 +227,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n             fields\n                 .sub(a_is_expected)\n                 .relate(a, b)\n@@ -233,7 +244,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n             fields\n                 .equate(a_is_expected)\n                 .relate(a, b)\n@@ -248,7 +259,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n             fields\n                 .lub(a_is_expected)\n                 .relate(a, b)\n@@ -263,7 +274,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n             fields\n                 .glb(a_is_expected)\n                 .relate(a, b)"}, {"sha": "750643acdda3b03009a25b2f7803b83b6fe5c85b", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 60, "deletions": 12, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -22,10 +22,12 @@ use rustc_data_structures::captures::Captures;\n use rustc_index::vec::Idx;\n use rustc_index::vec::IndexVec;\n use rustc_middle::arena::ArenaAllocatable;\n+use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n use rustc_middle::ty::{self, BoundVar, Const, ToPredicate, Ty, TyCtxt};\n+use rustc_span::Span;\n use std::fmt::Debug;\n use std::iter;\n \n@@ -89,6 +91,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             var_values: inference_vars,\n             region_constraints: QueryRegionConstraints::default(),\n             certainty: Certainty::Proven, // Ambiguities are OK!\n+            opaque_types: vec![],\n             value: answer,\n         })\n     }\n@@ -133,14 +136,27 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         let certainty =\n             if ambig_errors.is_empty() { Certainty::Proven } else { Certainty::Ambiguous };\n \n+        let opaque_types = self.take_opaque_types_for_query_response();\n+\n         Ok(QueryResponse {\n             var_values: inference_vars,\n             region_constraints,\n             certainty,\n             value: answer,\n+            opaque_types,\n         })\n     }\n \n+    fn take_opaque_types_for_query_response(&self) -> Vec<(Ty<'tcx>, Ty<'tcx>)> {\n+        self.inner\n+            .borrow_mut()\n+            .opaque_type_storage\n+            .take_opaque_types()\n+            .into_iter()\n+            .map(|(k, v)| (self.tcx.mk_opaque(k.def_id, k.substs), v.hidden_type.ty))\n+            .collect()\n+    }\n+\n     /// Given the (canonicalized) result to a canonical query,\n     /// instantiates the result so it can be used, plugging in the\n     /// values from the canonical query. (Note that the result may\n@@ -223,13 +239,12 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     where\n         R: Debug + TypeFoldable<'tcx>,\n     {\n-        let result_subst =\n-            self.query_response_substitution_guess(cause, original_values, query_response);\n+        let InferOk { value: result_subst, mut obligations } = self\n+            .query_response_substitution_guess(cause, param_env, original_values, query_response)?;\n \n         // Compute `QueryOutlivesConstraint` values that unify each of\n         // the original values `v_o` that was canonicalized into a\n         // variable...\n-        let mut obligations = vec![];\n \n         for (index, original_value) in original_values.var_values.iter().enumerate() {\n             // ...with the value `v_r` of that variable from the query.\n@@ -343,20 +358,25 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             original_values, query_response,\n         );\n \n-        let result_subst =\n-            self.query_response_substitution_guess(cause, original_values, query_response);\n+        let mut value = self.query_response_substitution_guess(\n+            cause,\n+            param_env,\n+            original_values,\n+            query_response,\n+        )?;\n \n-        let obligations = self\n-            .unify_query_response_substitution_guess(\n+        value.obligations.extend(\n+            self.unify_query_response_substitution_guess(\n                 cause,\n                 param_env,\n                 original_values,\n-                &result_subst,\n+                &value.value,\n                 query_response,\n             )?\n-            .into_obligations();\n+            .into_obligations(),\n+        );\n \n-        Ok(InferOk { value: result_subst, obligations })\n+        Ok(value)\n     }\n \n     /// Given the original values and the (canonicalized) result from\n@@ -371,9 +391,10 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     fn query_response_substitution_guess<R>(\n         &self,\n         cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n         original_values: &OriginalQueryValues<'tcx>,\n         query_response: &Canonical<'tcx, QueryResponse<'tcx, R>>,\n-    ) -> CanonicalVarValues<'tcx>\n+    ) -> InferResult<'tcx, CanonicalVarValues<'tcx>>\n     where\n         R: Debug + TypeFoldable<'tcx>,\n     {\n@@ -473,7 +494,16 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 .collect(),\n         };\n \n-        result_subst\n+        let mut obligations = vec![];\n+\n+        // Carry all newly resolved opaque types to the caller's scope\n+        for &(a, b) in &query_response.value.opaque_types {\n+            let a = substitute_value(self.tcx, &result_subst, a);\n+            let b = substitute_value(self.tcx, &result_subst, b);\n+            obligations.extend(self.handle_opaque_type(a, b, true, cause, param_env)?.obligations);\n+        }\n+\n+        Ok(InferOk { value: result_subst, obligations })\n     }\n \n     /// Given a \"guess\" at the values for the canonical variables in\n@@ -629,6 +659,10 @@ struct QueryTypeRelatingDelegate<'a, 'tcx> {\n }\n \n impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n+    fn span(&self) -> Span {\n+        self.cause.span\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n     }\n@@ -684,4 +718,18 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n     fn forbid_inference_vars() -> bool {\n         true\n     }\n+\n+    fn register_opaque_type(\n+        &mut self,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n+        a_is_expected: bool,\n+    ) -> Result<(), TypeError<'tcx>> {\n+        self.obligations.extend(\n+            self.infcx\n+                .handle_opaque_type(a, b, a_is_expected, &self.cause, self.param_env)?\n+                .obligations,\n+        );\n+        Ok(())\n+    }\n }"}, {"sha": "41995ca509ef6ce83a9a2e95600c089754c81ab9", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -51,6 +51,12 @@ pub struct CombineFields<'infcx, 'tcx> {\n     pub cause: Option<ty::relate::Cause>,\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub obligations: PredicateObligations<'tcx>,\n+    /// Whether we should define opaque types\n+    /// or just treat them opaquely.\n+    /// Currently only used to prevent predicate\n+    /// matching from matching anything against opaque\n+    /// types.\n+    pub define_opaque_types: bool,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -322,6 +328,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n     /// will first instantiate `b_vid` with a *generalized* version\n     /// of `a_ty`. Generalization introduces other inference\n     /// variables wherever subtyping could occur.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn instantiate(\n         &mut self,\n         a_ty: Ty<'tcx>,\n@@ -334,8 +341,6 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         // Get the actual variable that b_vid has been inferred to\n         debug_assert!(self.infcx.inner.borrow_mut().type_variables().probe(b_vid).is_unknown());\n \n-        debug!(\"instantiate(a_ty={:?} dir={:?} b_vid={:?})\", a_ty, dir, b_vid);\n-\n         // Generalize type of `a_ty` appropriately depending on the\n         // direction.  As an example, assume:\n         //\n@@ -348,10 +353,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         // variables. (Down below, we will relate `a_ty <: b_ty`,\n         // adding constraints like `'x: '?2` and `?1 <: ?3`.)\n         let Generalization { ty: b_ty, needs_wf } = self.generalize(a_ty, b_vid, dir)?;\n-        debug!(\n-            \"instantiate(a_ty={:?}, dir={:?}, b_vid={:?}, generalized b_ty={:?})\",\n-            a_ty, dir, b_vid, b_ty\n-        );\n+        debug!(?b_ty);\n         self.infcx.inner.borrow_mut().type_variables().instantiate(b_vid, b_ty);\n \n         if needs_wf {\n@@ -392,13 +394,13 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n     /// Preconditions:\n     ///\n     /// - `for_vid` is a \"root vid\"\n+    #[instrument(skip(self), level = \"trace\")]\n     fn generalize(\n         &self,\n         ty: Ty<'tcx>,\n         for_vid: ty::TyVid,\n         dir: RelationDir,\n     ) -> RelateResult<'tcx, Generalization<'tcx>> {\n-        debug!(\"generalize(ty={:?}, for_vid={:?}, dir={:?}\", ty, for_vid, dir);\n         // Determine the ambient variance within which `ty` appears.\n         // The surrounding equation is:\n         //\n@@ -412,7 +414,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             RelationDir::SupertypeOf => ty::Contravariant,\n         };\n \n-        debug!(\"generalize: ambient_variance = {:?}\", ambient_variance);\n+        trace!(?ambient_variance);\n \n         let for_universe = match self.infcx.inner.borrow_mut().type_variables().probe(for_vid) {\n             v @ TypeVariableValue::Known { .. } => {\n@@ -421,8 +423,8 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             TypeVariableValue::Unknown { universe } => universe,\n         };\n \n-        debug!(\"generalize: for_universe = {:?}\", for_universe);\n-        debug!(\"generalize: trace = {:?}\", self.trace);\n+        trace!(?for_universe);\n+        trace!(?self.trace);\n \n         let mut generalize = Generalizer {\n             infcx: self.infcx,\n@@ -439,12 +441,12 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         let ty = match generalize.relate(ty, ty) {\n             Ok(ty) => ty,\n             Err(e) => {\n-                debug!(\"generalize: failure {:?}\", e);\n+                debug!(?e, \"failure\");\n                 return Err(e);\n             }\n         };\n         let needs_wf = generalize.needs_wf;\n-        debug!(\"generalize: success {{ {:?}, {:?} }}\", ty, needs_wf);\n+        trace!(?ty, ?needs_wf, \"success\");\n         Ok(Generalization { ty, needs_wf })\n     }\n "}, {"sha": "65c0eba4b3d5c791aa254269c389c3c26460e5f4", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -66,18 +66,19 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n         self.relate(a, b)\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"{}.tys({:?}, {:?})\", self.tag(), a, b);\n         if a == b {\n             return Ok(a);\n         }\n \n+        trace!(a = ?a.kind(), b = ?b.kind());\n+\n         let infcx = self.fields.infcx;\n+\n         let a = infcx.inner.borrow_mut().type_variables().replace_if_possible(a);\n         let b = infcx.inner.borrow_mut().type_variables().replace_if_possible(b);\n \n-        debug!(\"{}.tys: replacements ({:?}, {:?})\", self.tag(), a, b);\n-\n         match (a.kind(), b.kind()) {\n             (&ty::Infer(TyVar(a_id)), &ty::Infer(TyVar(b_id))) => {\n                 infcx.inner.borrow_mut().type_variables().equate(a_id, b_id);\n@@ -91,6 +92,25 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n                 self.fields.instantiate(a, RelationDir::EqTo, b_id, self.a_is_expected)?;\n             }\n \n+            (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {\n+                self.fields.infcx.super_combine_tys(self, a, b)?;\n+            }\n+            (&ty::Opaque(did, ..), _) | (_, &ty::Opaque(did, ..))\n+                if self.fields.define_opaque_types && did.is_local() =>\n+            {\n+                self.fields.obligations.extend(\n+                    infcx\n+                        .handle_opaque_type(\n+                            a,\n+                            b,\n+                            self.a_is_expected(),\n+                            &self.fields.trace.cause,\n+                            self.param_env(),\n+                        )?\n+                        .obligations,\n+                );\n+            }\n+\n             _ => {\n                 self.fields.infcx.super_combine_tys(self, a, b)?;\n             }"}, {"sha": "0d38b94965afe2d61f401d3771b43ef5a5600195", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -6,7 +6,7 @@ use super::InferCtxt;\n use super::Subtype;\n \n use crate::infer::combine::ConstEquateRelation;\n-use crate::traits::ObligationCause;\n+use crate::traits::{ObligationCause, PredicateObligation};\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n@@ -113,12 +113,20 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Glb<'combine, 'infcx,\n         &self.fields.trace.cause\n     }\n \n+    fn add_obligations(&mut self, obligations: Vec<PredicateObligation<'tcx>>) {\n+        self.fields.obligations.extend(obligations)\n+    }\n+\n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n         let mut sub = self.fields.sub(self.a_is_expected);\n         sub.relate(v, a)?;\n         sub.relate(v, b)?;\n         Ok(())\n     }\n+\n+    fn define_opaque_types(&self) -> bool {\n+        self.fields.define_opaque_types\n+    }\n }\n \n impl<'tcx> ConstEquateRelation<'tcx> for Glb<'_, '_, 'tcx> {"}, {"sha": "b77245c2592f9abe8cdca374b0ccb1f693345b06", "filename": "compiler/rustc_infer/src/infer/lattice.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -20,7 +20,7 @@\n use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use super::InferCtxt;\n \n-use crate::traits::ObligationCause;\n+use crate::traits::{ObligationCause, PredicateObligation};\n use rustc_middle::ty::relate::{RelateResult, TypeRelation};\n use rustc_middle::ty::TyVar;\n use rustc_middle::ty::{self, Ty};\n@@ -35,6 +35,10 @@ pub trait LatticeDir<'f, 'tcx>: TypeRelation<'tcx> {\n \n     fn cause(&self) -> &ObligationCause<'tcx>;\n \n+    fn add_obligations(&mut self, obligations: Vec<PredicateObligation<'tcx>>);\n+\n+    fn define_opaque_types(&self) -> bool;\n+\n     // Relates the type `v` to `a` and `b` such that `v` represents\n     // the LUB/GLB of `a` and `b` as appropriate.\n     //\n@@ -45,6 +49,7 @@ pub trait LatticeDir<'f, 'tcx>: TypeRelation<'tcx> {\n }\n \n /// Relates two types using a given lattice.\n+#[instrument(skip(this), level = \"debug\")]\n pub fn super_lattice_tys<'a, 'tcx: 'a, L>(\n     this: &mut L,\n     a: Ty<'tcx>,\n@@ -53,15 +58,17 @@ pub fn super_lattice_tys<'a, 'tcx: 'a, L>(\n where\n     L: LatticeDir<'a, 'tcx>,\n {\n-    debug!(\"{}.lattice_tys({:?}, {:?})\", this.tag(), a, b);\n+    debug!(\"{}\", this.tag());\n \n     if a == b {\n         return Ok(a);\n     }\n \n     let infcx = this.infcx();\n+\n     let a = infcx.inner.borrow_mut().type_variables().replace_if_possible(a);\n     let b = infcx.inner.borrow_mut().type_variables().replace_if_possible(b);\n+\n     match (a.kind(), b.kind()) {\n         // If one side is known to be a variable and one is not,\n         // create a variable (`v`) to represent the LUB. Make sure to\n@@ -98,6 +105,20 @@ where\n             Ok(v)\n         }\n \n+        (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {\n+            infcx.super_combine_tys(this, a, b)\n+        }\n+        (&ty::Opaque(did, ..), _) | (_, &ty::Opaque(did, ..))\n+            if this.define_opaque_types() && did.is_local() =>\n+        {\n+            this.add_obligations(\n+                infcx\n+                    .handle_opaque_type(a, b, this.a_is_expected(), this.cause(), this.param_env())?\n+                    .obligations,\n+            );\n+            Ok(a)\n+        }\n+\n         _ => infcx.super_combine_tys(this, a, b),\n     }\n }"}, {"sha": "498c1e907c4e132650b7edb523f0bbeb56dfd672", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -6,7 +6,7 @@ use super::InferCtxt;\n use super::Subtype;\n \n use crate::infer::combine::ConstEquateRelation;\n-use crate::traits::ObligationCause;\n+use crate::traits::{ObligationCause, PredicateObligation};\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n@@ -119,10 +119,18 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Lub<'combine, 'infcx,\n         &self.fields.trace.cause\n     }\n \n+    fn add_obligations(&mut self, obligations: Vec<PredicateObligation<'tcx>>) {\n+        self.fields.obligations.extend(obligations)\n+    }\n+\n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n         let mut sub = self.fields.sub(self.a_is_expected);\n         sub.relate(a, v)?;\n         sub.relate(b, v)?;\n         Ok(())\n     }\n+\n+    fn define_opaque_types(&self) -> bool {\n+        self.fields.define_opaque_types\n+    }\n }"}, {"sha": "63ffb5bde38461d79fbe2b90c887dcd073322867", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 45, "deletions": 18, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -5,7 +5,7 @@ pub use self::RegionVariableOrigin::*;\n pub use self::SubregionOrigin::*;\n pub use self::ValuePairs::*;\n \n-use self::opaque_types::OpaqueTypeMap;\n+use self::opaque_types::OpaqueTypeStorage;\n pub(crate) use self::undo_log::{InferCtxtUndoLogs, Snapshot, UndoLog};\n \n use crate::traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n@@ -191,18 +191,8 @@ pub struct InferCtxtInner<'tcx> {\n \n     undo_log: InferCtxtUndoLogs<'tcx>,\n \n-    // Opaque types found in explicit return types and their\n-    // associated fresh inference variable. Writeback resolves these\n-    // variables to get the concrete type, which can be used to\n-    // 'de-opaque' OpaqueTypeDecl outside of type inference.\n-    pub opaque_types: OpaqueTypeMap<'tcx>,\n-\n-    /// A map from inference variables created from opaque\n-    /// type instantiations (`ty::Infer`) to the actual opaque\n-    /// type (`ty::Opaque`). Used during fallback to map unconstrained\n-    /// opaque type inference variables to their corresponding\n-    /// opaque type.\n-    pub opaque_types_vars: FxHashMap<Ty<'tcx>, Ty<'tcx>>,\n+    /// Caches for opaque type inference.\n+    pub opaque_type_storage: OpaqueTypeStorage<'tcx>,\n }\n \n impl<'tcx> InferCtxtInner<'tcx> {\n@@ -216,8 +206,7 @@ impl<'tcx> InferCtxtInner<'tcx> {\n             float_unification_storage: ut::UnificationTableStorage::new(),\n             region_constraint_storage: Some(RegionConstraintStorage::new()),\n             region_obligations: vec![],\n-            opaque_types: Default::default(),\n-            opaque_types_vars: Default::default(),\n+            opaque_type_storage: Default::default(),\n         }\n     }\n \n@@ -236,6 +225,11 @@ impl<'tcx> InferCtxtInner<'tcx> {\n         self.type_variable_storage.with_log(&mut self.undo_log)\n     }\n \n+    #[inline]\n+    pub fn opaque_types(&mut self) -> opaque_types::OpaqueTypeTable<'_, 'tcx> {\n+        self.opaque_type_storage.with_log(&mut self.undo_log)\n+    }\n+\n     #[inline]\n     fn int_unification_table(\n         &mut self,\n@@ -296,6 +290,10 @@ pub struct InferCtxt<'a, 'tcx> {\n     /// to the outside until the end up in an `InferCtxt` for typeck or borrowck.\n     pub defining_use_anchor: Option<LocalDefId>,\n \n+    /// Used by WF-checking to not have to figure out hidden types itself, but\n+    /// to just invoke type_of to get the already computed hidden type from typeck.\n+    pub reveal_defining_opaque_types: bool,\n+\n     /// During type-checking/inference of a body, `in_progress_typeck_results`\n     /// contains a reference to the typeck results being built up, which are\n     /// used for reading closure kinds/signatures as they are inferred,\n@@ -571,6 +569,7 @@ pub struct InferCtxtBuilder<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     fresh_typeck_results: Option<RefCell<ty::TypeckResults<'tcx>>>,\n     defining_use_anchor: Option<LocalDefId>,\n+    reveal_defining_opaque_types: bool,\n }\n \n pub trait TyCtxtInferExt<'tcx> {\n@@ -579,7 +578,12 @@ pub trait TyCtxtInferExt<'tcx> {\n \n impl<'tcx> TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n     fn infer_ctxt(self) -> InferCtxtBuilder<'tcx> {\n-        InferCtxtBuilder { tcx: self, defining_use_anchor: None, fresh_typeck_results: None }\n+        InferCtxtBuilder {\n+            tcx: self,\n+            defining_use_anchor: None,\n+            fresh_typeck_results: None,\n+            reveal_defining_opaque_types: false,\n+        }\n     }\n }\n \n@@ -603,6 +607,13 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n         self\n     }\n \n+    /// WF-checking doesn't need to recompute opaque types and can instead use\n+    /// the type_of query to get them from typeck.\n+    pub fn reveal_defining_opaque_types(mut self) -> Self {\n+        self.reveal_defining_opaque_types = true;\n+        self\n+    }\n+\n     /// Given a canonical value `C` as a starting point, create an\n     /// inference context that contains each of the bound values\n     /// within instantiated as a fresh variable. The `f` closure is\n@@ -627,11 +638,17 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     }\n \n     pub fn enter<R>(&mut self, f: impl for<'a> FnOnce(InferCtxt<'a, 'tcx>) -> R) -> R {\n-        let InferCtxtBuilder { tcx, defining_use_anchor, ref fresh_typeck_results } = *self;\n+        let InferCtxtBuilder {\n+            tcx,\n+            defining_use_anchor,\n+            reveal_defining_opaque_types,\n+            ref fresh_typeck_results,\n+        } = *self;\n         let in_progress_typeck_results = fresh_typeck_results.as_ref();\n         f(InferCtxt {\n             tcx,\n             defining_use_anchor,\n+            reveal_defining_opaque_types,\n             in_progress_typeck_results,\n             inner: RefCell::new(InferCtxtInner::new()),\n             lexical_region_resolutions: RefCell::new(None),\n@@ -766,13 +783,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &'a self,\n         trace: TypeTrace<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n+        define_opaque_types: bool,\n     ) -> CombineFields<'a, 'tcx> {\n         CombineFields {\n             infcx: self,\n             trace,\n             cause: None,\n             param_env,\n             obligations: PredicateObligations::new(),\n+            define_opaque_types,\n         }\n     }\n \n@@ -1088,12 +1107,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.tcx.mk_ty_var(self.next_ty_var_id(origin))\n     }\n \n+    pub fn next_ty_var_id_in_universe(\n+        &self,\n+        origin: TypeVariableOrigin,\n+        universe: ty::UniverseIndex,\n+    ) -> TyVid {\n+        self.inner.borrow_mut().type_variables().new_var(universe, origin)\n+    }\n+\n     pub fn next_ty_var_in_universe(\n         &self,\n         origin: TypeVariableOrigin,\n         universe: ty::UniverseIndex,\n     ) -> Ty<'tcx> {\n-        let vid = self.inner.borrow_mut().type_variables().new_var(universe, origin);\n+        let vid = self.next_ty_var_id_in_universe(origin, universe);\n         self.tcx.mk_ty_var(vid)\n     }\n "}, {"sha": "cc0114d7538e0e5df8e04c635a5558d1bfb91c7c", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -24,11 +24,13 @@\n use crate::infer::combine::ConstEquateRelation;\n use crate::infer::InferCtxt;\n use crate::infer::{ConstVarValue, ConstVariableValue};\n+use crate::infer::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::{TypeFoldable, TypeVisitor};\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::{self, InferConst, Ty, TyCtxt};\n+use rustc_span::Span;\n use std::fmt::Debug;\n use std::ops::ControlFlow;\n \n@@ -75,6 +77,7 @@ where\n \n pub trait TypeRelatingDelegate<'tcx> {\n     fn param_env(&self) -> ty::ParamEnv<'tcx>;\n+    fn span(&self) -> Span;\n \n     /// Push a constraint `sup: sub` -- this constraint must be\n     /// satisfied for the two types to be related. `sub` and `sup` may\n@@ -88,6 +91,12 @@ pub trait TypeRelatingDelegate<'tcx> {\n     );\n \n     fn const_equate(&mut self, a: ty::Const<'tcx>, b: ty::Const<'tcx>);\n+    fn register_opaque_type(\n+        &mut self,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n+        a_is_expected: bool,\n+    ) -> Result<(), TypeError<'tcx>>;\n \n     /// Creates a new universe index. Used when instantiating placeholders.\n     fn create_next_universe(&mut self) -> ty::UniverseIndex;\n@@ -277,7 +286,6 @@ where\n         projection_ty: ty::ProjectionTy<'tcx>,\n         value_ty: Ty<'tcx>,\n     ) -> Ty<'tcx> {\n-        use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n         use rustc_span::DUMMY_SP;\n \n         match *value_ty.kind() {\n@@ -286,6 +294,8 @@ where\n                     kind: TypeVariableOriginKind::MiscVariable,\n                     span: DUMMY_SP,\n                 });\n+                // FIXME(lazy-normalization): This will always ICE, because the recursive\n+                // call will end up in the _ arm below.\n                 self.relate_projection_ty(projection_ty, var);\n                 self.relate_projection_ty(other_projection_ty, var);\n                 var\n@@ -531,6 +541,8 @@ where\n \n     #[instrument(skip(self), level = \"debug\")]\n     fn tys(&mut self, a: Ty<'tcx>, mut b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        let infcx = self.infcx;\n+\n         let a = self.infcx.shallow_resolve(a);\n \n         if !D::forbid_inference_vars() {\n@@ -559,6 +571,35 @@ where\n \n             (&ty::Infer(ty::TyVar(vid)), _) => self.relate_ty_var((vid, b)),\n \n+            (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {\n+                self.infcx.super_combine_tys(self, a, b)\n+            }\n+            (&ty::Opaque(did, ..), _) | (_, &ty::Opaque(did, ..)) if did.is_local() => {\n+                let (a, b) = if self.a_is_expected() { (a, b) } else { (b, a) };\n+                let mut generalize = |ty, ty_is_expected| {\n+                    let var = infcx.next_ty_var_id_in_universe(\n+                        TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::MiscVariable,\n+                            span: self.delegate.span(),\n+                        },\n+                        ty::UniverseIndex::ROOT,\n+                    );\n+                    if ty_is_expected {\n+                        self.relate_ty_var((ty, var))\n+                    } else {\n+                        self.relate_ty_var((var, ty))\n+                    }\n+                };\n+                let (a, b) = match (a.kind(), b.kind()) {\n+                    (&ty::Opaque(..), _) => (a, generalize(b, false)?),\n+                    (_, &ty::Opaque(..)) => (generalize(a, true)?, b),\n+                    _ => unreachable!(),\n+                };\n+                self.delegate.register_opaque_type(a, b, true)?;\n+                trace!(a = ?a.kind(), b = ?b.kind(), \"opaque type instantiated\");\n+                Ok(a)\n+            }\n+\n             (&ty::Projection(projection_ty), _)\n                 if D::normalization() == NormalizationStrategy::Lazy =>\n             {"}, {"sha": "e8cd5988b96ec93269fc6724c179a0c6c40947c1", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 243, "deletions": 247, "changes": 490, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,102 +1,196 @@\n-use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{InferCtxt, InferOk};\n use crate::traits;\n+use hir::def_id::{DefId, LocalDefId};\n+use hir::{HirId, OpaqueTyOrigin};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir as hir;\n-use rustc_hir::def_id::LocalDefId;\n+use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::fold::BottomUpFolder;\n use rustc_middle::ty::subst::{GenericArgKind, Subst};\n-use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n+use rustc_middle::ty::{\n+    self, OpaqueHiddenType, OpaqueTypeKey, Ty, TyCtxt, TypeFoldable, TypeVisitor,\n+};\n use rustc_span::Span;\n \n use std::ops::ControlFlow;\n \n pub type OpaqueTypeMap<'tcx> = VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>;\n \n+mod table;\n+\n+pub use table::{OpaqueTypeStorage, OpaqueTypeTable};\n+\n+use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use super::InferResult;\n+\n /// Information about the opaque types whose values we\n /// are inferring in this function (these are the `impl Trait` that\n /// appear in the return type).\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Clone, Debug)]\n pub struct OpaqueTypeDecl<'tcx> {\n-    /// The opaque type (`ty::Opaque`) for this declaration.\n-    pub opaque_type: Ty<'tcx>,\n-\n-    /// The span of this particular definition of the opaque type. So\n-    /// for example:\n-    ///\n-    /// ```ignore (incomplete snippet)\n-    /// type Foo = impl Baz;\n-    /// fn bar() -> Foo {\n-    /// //          ^^^ This is the span we are looking for!\n-    /// }\n-    /// ```\n-    ///\n-    /// In cases where the fn returns `(impl Trait, impl Trait)` or\n-    /// other such combinations, the result is currently\n-    /// over-approximated, but better than nothing.\n-    pub definition_span: Span,\n-\n-    /// The type variable that represents the value of the opaque type\n-    /// that we require. In other words, after we compile this function,\n-    /// we will be created a constraint like:\n-    ///\n-    ///     Foo<'a, T> = ?C\n-    ///\n-    /// where `?C` is the value of this type variable. =) It may\n-    /// naturally refer to the type and lifetime parameters in scope\n-    /// in this function, though ultimately it should only reference\n-    /// those that are arguments to `Foo` in the constraint above. (In\n-    /// other words, `?C` should not include `'b`, even though it's a\n-    /// lifetime parameter on `foo`.)\n-    pub concrete_ty: Ty<'tcx>,\n+    /// The hidden types that have been inferred for this opaque type.\n+    /// There can be multiple, but they are all `lub`ed together at the end\n+    /// to obtain the canonical hidden type.\n+    pub hidden_type: OpaqueHiddenType<'tcx>,\n \n     /// The origin of the opaque type.\n     pub origin: hir::OpaqueTyOrigin,\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    /// Replaces all opaque types in `value` with fresh inference variables\n-    /// and creates appropriate obligations. For example, given the input:\n-    ///\n-    ///     impl Iterator<Item = impl Debug>\n-    ///\n-    /// this method would create two type variables, `?0` and `?1`. It would\n-    /// return the type `?0` but also the obligations:\n-    ///\n-    ///     ?0: Iterator<Item = ?1>\n-    ///     ?1: Debug\n-    ///\n-    /// Moreover, it returns an `OpaqueTypeMap` that would map `?0` to\n-    /// info about the `impl Iterator<..>` type and `?1` to info about\n-    /// the `impl Debug` type.\n-    ///\n-    /// # Parameters\n-    ///\n-    /// - `parent_def_id` -- the `DefId` of the function in which the opaque type\n-    ///   is defined\n-    /// - `body_id` -- the body-id with which the resulting obligations should\n-    ///   be associated\n-    /// - `param_env` -- the in-scope parameter environment to be used for\n-    ///   obligations\n-    /// - `value` -- the value within which we are instantiating opaque types\n-    /// - `value_span` -- the span where the value came from, used in error reporting\n-    pub fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n+    /// This is a backwards compatibility hack to prevent breaking changes from\n+    /// lazy TAIT around RPIT handling.\n+    pub fn replace_opaque_types_with_inference_vars<T: TypeFoldable<'tcx>>(\n         &self,\n-        body_id: hir::HirId,\n-        param_env: ty::ParamEnv<'tcx>,\n         value: T,\n-        value_span: Span,\n+        body_id: HirId,\n+        span: Span,\n+        param_env: ty::ParamEnv<'tcx>,\n     ) -> InferOk<'tcx, T> {\n-        debug!(\n-            \"instantiate_opaque_types(value={:?}, body_id={:?}, \\\n-             param_env={:?}, value_span={:?})\",\n-            value, body_id, param_env, value_span,\n-        );\n-        let mut instantiator =\n-            Instantiator { infcx: self, body_id, param_env, value_span, obligations: vec![] };\n-        let value = instantiator.instantiate_opaque_types_in_map(value);\n-        InferOk { value, obligations: instantiator.obligations }\n+        if !value.has_opaque_types() {\n+            return InferOk { value, obligations: vec![] };\n+        }\n+        let mut obligations = vec![];\n+        let value = value.fold_with(&mut ty::fold::BottomUpFolder {\n+            tcx: self.tcx,\n+            lt_op: |lt| lt,\n+            ct_op: |ct| ct,\n+            ty_op: |ty| match *ty.kind() {\n+                // Closures can't create hidden types for opaque types of their parent, as they\n+                // do not have all the outlives information available. Also `type_of` looks for\n+                // hidden types in the owner (so the closure's parent), so it would not find these\n+                // definitions.\n+                ty::Opaque(def_id, _substs)\n+                    if matches!(\n+                        self.opaque_type_origin(def_id, span),\n+                        Some(OpaqueTyOrigin::FnReturn(..))\n+                    ) =>\n+                {\n+                    let span = if span.is_dummy() { self.tcx.def_span(def_id) } else { span };\n+                    let cause = ObligationCause::misc(span, body_id);\n+                    let ty_var = self.next_ty_var(TypeVariableOrigin {\n+                        kind: TypeVariableOriginKind::TypeInference,\n+                        span: cause.span,\n+                    });\n+                    obligations.extend(\n+                        self.handle_opaque_type(ty, ty_var, true, &cause, param_env)\n+                            .unwrap()\n+                            .obligations,\n+                    );\n+                    ty_var\n+                }\n+                _ => ty,\n+            },\n+        });\n+        InferOk { value, obligations }\n+    }\n+\n+    pub fn handle_opaque_type(\n+        &self,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n+        a_is_expected: bool,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> InferResult<'tcx, ()> {\n+        if a.references_error() || b.references_error() {\n+            return Ok(InferOk { value: (), obligations: vec![] });\n+        }\n+        let (a, b) = if a_is_expected { (a, b) } else { (b, a) };\n+        let process = |a: Ty<'tcx>, b: Ty<'tcx>| match *a.kind() {\n+            ty::Opaque(def_id, substs) => {\n+                let origin = if self.defining_use_anchor.is_some() {\n+                    // Check that this is `impl Trait` type is\n+                    // declared by `parent_def_id` -- i.e., one whose\n+                    // value we are inferring.  At present, this is\n+                    // always true during the first phase of\n+                    // type-check, but not always true later on during\n+                    // NLL. Once we support named opaque types more fully,\n+                    // this same scenario will be able to arise during all phases.\n+                    //\n+                    // Here is an example using type alias `impl Trait`\n+                    // that indicates the distinction we are checking for:\n+                    //\n+                    // ```rust\n+                    // mod a {\n+                    //   pub type Foo = impl Iterator;\n+                    //   pub fn make_foo() -> Foo { .. }\n+                    // }\n+                    //\n+                    // mod b {\n+                    //   fn foo() -> a::Foo { a::make_foo() }\n+                    // }\n+                    // ```\n+                    //\n+                    // Here, the return type of `foo` references an\n+                    // `Opaque` indeed, but not one whose value is\n+                    // presently being inferred. You can get into a\n+                    // similar situation with closure return types\n+                    // today:\n+                    //\n+                    // ```rust\n+                    // fn foo() -> impl Iterator { .. }\n+                    // fn bar() {\n+                    //     let x = || foo(); // returns the Opaque assoc with `foo`\n+                    // }\n+                    // ```\n+                    self.opaque_type_origin(def_id, cause.span)?\n+                } else {\n+                    self.opaque_ty_origin_unchecked(def_id, cause.span)\n+                };\n+                if let ty::Opaque(did2, _) = *b.kind() {\n+                    // We could accept this, but there are various ways to handle this situation, and we don't\n+                    // want to make a decision on it right now. Likely this case is so super rare anyway, that\n+                    // no one encounters it in practice.\n+                    // It does occur however in `fn fut() -> impl Future<Output = i32> { async { 42 } }`,\n+                    // where it is of no concern, so we only check for TAITs.\n+                    if let Some(OpaqueTyOrigin::TyAlias) = self.opaque_type_origin(did2, cause.span)\n+                    {\n+                        self.tcx\n+                                .sess\n+                                .struct_span_err(\n+                                    cause.span,\n+                                    \"opaque type's hidden type cannot be another opaque type from the same scope\",\n+                                )\n+                                .span_label(cause.span, \"one of the two opaque types used here has to be outside its defining scope\")\n+                                .span_note(\n+                                    self.tcx.def_span(def_id),\n+                                    \"opaque type whose hidden type is being assigned\",\n+                                )\n+                                .span_note(\n+                                    self.tcx.def_span(did2),\n+                                    \"opaque type being used as hidden type\",\n+                                )\n+                                .emit();\n+                    }\n+                }\n+                Some(self.register_hidden_type(\n+                    OpaqueTypeKey { def_id, substs },\n+                    cause.clone(),\n+                    param_env,\n+                    b,\n+                    origin,\n+                ))\n+            }\n+            _ => None,\n+        };\n+        if let Some(res) = process(a, b) {\n+            res\n+        } else if let Some(res) = process(b, a) {\n+            res\n+        } else {\n+            // Rerun equality check, but this time error out due to\n+            // different types.\n+            match self.at(cause, param_env).define_opaque_types(false).eq(a, b) {\n+                Ok(_) => span_bug!(\n+                    cause.span,\n+                    \"opaque types are never equal to anything but themselves: {:#?}\",\n+                    (a.kind(), b.kind())\n+                ),\n+                Err(e) => Err(e),\n+            }\n+        }\n     }\n \n     /// Given the map `opaque_types` containing the opaque\n@@ -231,51 +325,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// but this is not necessary, because the opaque type we\n     /// create will be allowed to reference `T`. So we only generate a\n     /// constraint that `'0: 'a`.\n-    ///\n-    /// # The `free_region_relations` parameter\n-    ///\n-    /// The `free_region_relations` argument is used to find the\n-    /// \"minimum\" of the regions supplied to a given opaque type.\n-    /// It must be a relation that can answer whether `'a <= 'b`,\n-    /// where `'a` and `'b` are regions that appear in the \"substs\"\n-    /// for the opaque type references (the `<'a>` in `Foo1<'a>`).\n-    ///\n-    /// Note that we do not impose the constraints based on the\n-    /// generic regions from the `Foo1` definition (e.g., `'x`). This\n-    /// is because the constraints we are imposing here is basically\n-    /// the concern of the one generating the constraining type C1,\n-    /// which is the current function. It also means that we can\n-    /// take \"implied bounds\" into account in some cases:\n-    ///\n-    /// ```text\n-    /// trait SomeTrait<'a, 'b> { }\n-    /// fn foo<'a, 'b>(_: &'a &'b u32) -> impl SomeTrait<'a, 'b> { .. }\n-    /// ```\n-    ///\n-    /// Here, the fact that `'b: 'a` is known only because of the\n-    /// implied bounds from the `&'a &'b u32` parameter, and is not\n-    /// \"inherent\" to the opaque type definition.\n-    ///\n-    /// # Parameters\n-    ///\n-    /// - `opaque_types` -- the map produced by `instantiate_opaque_types`\n-    /// - `free_region_relations` -- something that can be used to relate\n-    ///   the free regions (`'a`) that appear in the impl trait.\n     #[instrument(level = \"debug\", skip(self))]\n-    pub fn constrain_opaque_type(\n+    pub fn register_member_constraints(\n         &self,\n+        param_env: ty::ParamEnv<'tcx>,\n         opaque_type_key: OpaqueTypeKey<'tcx>,\n-        opaque_defn: &OpaqueTypeDecl<'tcx>,\n+        concrete_ty: Ty<'tcx>,\n+        span: Span,\n     ) {\n         let def_id = opaque_type_key.def_id;\n \n         let tcx = self.tcx;\n \n-        let concrete_ty = self.resolve_vars_if_possible(opaque_defn.concrete_ty);\n+        let concrete_ty = self.resolve_vars_if_possible(concrete_ty);\n \n         debug!(?concrete_ty);\n \n-        let first_own_region = match opaque_defn.origin {\n+        let first_own_region = match self.opaque_ty_origin_unchecked(def_id, span) {\n             hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {\n                 // We lower\n                 //\n@@ -319,7 +385,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             op: |r| {\n                 self.member_constraint(\n                     opaque_type_key.def_id,\n-                    opaque_defn.definition_span,\n+                    span,\n                     concrete_ty,\n                     r,\n                     &choice_regions,\n@@ -328,15 +394,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         });\n     }\n \n-    fn opaque_type_origin(&self, def_id: LocalDefId) -> Option<hir::OpaqueTyOrigin> {\n-        let tcx = self.tcx;\n-        let opaque_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+    #[instrument(skip(self), level = \"trace\")]\n+    pub fn opaque_type_origin(&self, opaque_def_id: DefId, span: Span) -> Option<OpaqueTyOrigin> {\n+        let def_id = opaque_def_id.as_local()?;\n+        let opaque_hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n         let parent_def_id = self.defining_use_anchor?;\n-        let item_kind = &tcx.hir().expect_item(def_id).kind;\n+        let item_kind = &self.tcx.hir().expect_item(def_id).kind;\n+\n         let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, ..  }) = item_kind else {\n             span_bug!(\n-                tcx.def_span(def_id),\n-                \"weird opaque type: {:#?}\",\n+                span,\n+                \"weird opaque type: {:#?}, {:#?}\",\n+                opaque_def_id,\n                 item_kind\n             )\n         };\n@@ -347,11 +416,25 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             hir::OpaqueTyOrigin::FnReturn(parent) => parent == parent_def_id,\n             // Named `type Foo = impl Bar;`\n             hir::OpaqueTyOrigin::TyAlias => {\n-                may_define_opaque_type(tcx, parent_def_id, opaque_hir_id)\n+                may_define_opaque_type(self.tcx, parent_def_id, opaque_hir_id)\n             }\n         };\n+        trace!(?origin);\n         in_definition_scope.then_some(*origin)\n     }\n+\n+    #[instrument(skip(self), level = \"trace\")]\n+    fn opaque_ty_origin_unchecked(&self, opaque_def_id: DefId, span: Span) -> OpaqueTyOrigin {\n+        let def_id = opaque_def_id.as_local().unwrap();\n+        let origin = match self.tcx.hir().expect_item(def_id).kind {\n+            hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => origin,\n+            ref itemkind => {\n+                span_bug!(span, \"weird opaque type: {:?}, {:#?}\", opaque_def_id, itemkind)\n+            }\n+        };\n+        trace!(?origin);\n+        origin\n+    }\n }\n \n // Visitor that requires that (almost) all regions in the type visited outlive\n@@ -426,180 +509,93 @@ where\n     }\n }\n \n-struct Instantiator<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-    body_id: hir::HirId,\n-    param_env: ty::ParamEnv<'tcx>,\n-    value_span: Span,\n-    obligations: Vec<traits::PredicateObligation<'tcx>>,\n+pub enum UseKind {\n+    DefiningUse,\n+    OpaqueUse,\n }\n \n-impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n-    fn instantiate_opaque_types_in_map<T: TypeFoldable<'tcx>>(&mut self, value: T) -> T {\n-        let tcx = self.infcx.tcx;\n-        value.fold_with(&mut BottomUpFolder {\n-            tcx,\n-            ty_op: |ty| {\n-                if ty.references_error() {\n-                    return tcx.ty_error();\n-                } else if let ty::Opaque(def_id, substs) = ty.kind() {\n-                    // Check that this is `impl Trait` type is\n-                    // declared by `parent_def_id` -- i.e., one whose\n-                    // value we are inferring.  At present, this is\n-                    // always true during the first phase of\n-                    // type-check, but not always true later on during\n-                    // NLL. Once we support named opaque types more fully,\n-                    // this same scenario will be able to arise during all phases.\n-                    //\n-                    // Here is an example using type alias `impl Trait`\n-                    // that indicates the distinction we are checking for:\n-                    //\n-                    // ```rust\n-                    // mod a {\n-                    //   pub type Foo = impl Iterator;\n-                    //   pub fn make_foo() -> Foo { .. }\n-                    // }\n-                    //\n-                    // mod b {\n-                    //   fn foo() -> a::Foo { a::make_foo() }\n-                    // }\n-                    // ```\n-                    //\n-                    // Here, the return type of `foo` references an\n-                    // `Opaque` indeed, but not one whose value is\n-                    // presently being inferred. You can get into a\n-                    // similar situation with closure return types\n-                    // today:\n-                    //\n-                    // ```rust\n-                    // fn foo() -> impl Iterator { .. }\n-                    // fn bar() {\n-                    //     let x = || foo(); // returns the Opaque assoc with `foo`\n-                    // }\n-                    // ```\n-                    if let Some(def_id) = def_id.as_local() {\n-                        if let Some(origin) = self.infcx.opaque_type_origin(def_id) {\n-                            let opaque_type_key =\n-                                OpaqueTypeKey { def_id: def_id.to_def_id(), substs };\n-                            return self.fold_opaque_ty(ty, opaque_type_key, origin);\n-                        }\n-\n-                        debug!(\n-                            \"instantiate_opaque_types_in_map: \\\n-                             encountered opaque outside its definition scope \\\n-                             def_id={:?}\",\n-                            def_id,\n-                        );\n-                    }\n-                }\n-\n-                ty\n-            },\n-            lt_op: |lt| lt,\n-            ct_op: |ct| ct,\n-        })\n+impl UseKind {\n+    pub fn is_defining(self) -> bool {\n+        match self {\n+            UseKind::DefiningUse => true,\n+            UseKind::OpaqueUse => false,\n+        }\n     }\n+}\n \n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     #[instrument(skip(self), level = \"debug\")]\n-    fn fold_opaque_ty(\n-        &mut self,\n-        ty: Ty<'tcx>,\n+    pub fn register_hidden_type(\n+        &self,\n         opaque_type_key: OpaqueTypeKey<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        hidden_ty: Ty<'tcx>,\n         origin: hir::OpaqueTyOrigin,\n-    ) -> Ty<'tcx> {\n-        let infcx = self.infcx;\n-        let tcx = infcx.tcx;\n+    ) -> InferResult<'tcx, ()> {\n+        let tcx = self.tcx;\n         let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n \n-        // Use the same type variable if the exact same opaque type appears more\n-        // than once in the return type (e.g., if it's passed to a type alias).\n-        if let Some(opaque_defn) = infcx.inner.borrow().opaque_types.get(&opaque_type_key) {\n-            debug!(\"re-using cached concrete type {:?}\", opaque_defn.concrete_ty.kind());\n-            return opaque_defn.concrete_ty;\n-        }\n-\n-        let ty_var = infcx.next_ty_var(TypeVariableOrigin {\n-            kind: TypeVariableOriginKind::TypeInference,\n-            span: self.value_span,\n-        });\n-\n         // Ideally, we'd get the span where *this specific `ty` came\n         // from*, but right now we just use the span from the overall\n         // value being folded. In simple cases like `-> impl Foo`,\n         // these are the same span, but not in cases like `-> (impl\n         // Foo, impl Bar)`.\n-        let definition_span = self.value_span;\n-\n-        {\n-            let mut infcx = self.infcx.inner.borrow_mut();\n-            infcx.opaque_types.insert(\n-                OpaqueTypeKey { def_id, substs },\n-                OpaqueTypeDecl { opaque_type: ty, definition_span, concrete_ty: ty_var, origin },\n-            );\n-            infcx.opaque_types_vars.insert(ty_var, ty);\n-        }\n+        let span = cause.span;\n \n-        debug!(\"generated new type inference var {:?}\", ty_var.kind());\n+        let mut obligations = vec![];\n+        let prev = self.inner.borrow_mut().opaque_types().register(\n+            OpaqueTypeKey { def_id, substs },\n+            OpaqueHiddenType { ty: hidden_ty, span },\n+            origin,\n+        );\n+        if let Some(prev) = prev {\n+            obligations = self.at(&cause, param_env).eq(prev, hidden_ty)?.obligations;\n+        }\n \n         let item_bounds = tcx.explicit_item_bounds(def_id);\n \n-        self.obligations.reserve(item_bounds.len());\n         for (predicate, _) in item_bounds {\n             debug!(?predicate);\n             let predicate = predicate.subst(tcx, substs);\n-            debug!(?predicate);\n \n             let predicate = predicate.fold_with(&mut BottomUpFolder {\n                 tcx,\n                 ty_op: |ty| match *ty.kind() {\n-                    // Replace all other mentions of the same opaque type with the hidden type,\n-                    // as the bounds must hold on the hidden type after all.\n-                    ty::Opaque(def_id2, substs2) if def_id == def_id2 && substs == substs2 => {\n-                        ty_var\n-                    }\n-                    // Instantiate nested instances of `impl Trait`.\n-                    ty::Opaque(..) => self.instantiate_opaque_types_in_map(ty),\n-                    _ => ty,\n-                },\n-                lt_op: |lt| lt,\n-                ct_op: |ct| ct,\n-            });\n-\n-            // We can't normalize associated types from `rustc_infer`, but we can eagerly register inference variables for them.\n-            let predicate = predicate.fold_with(&mut BottomUpFolder {\n-                tcx,\n-                ty_op: |ty| match ty.kind() {\n+                    // We can't normalize associated types from `rustc_infer`,\n+                    // but we can eagerly register inference variables for them.\n                     ty::Projection(projection_ty) if !projection_ty.has_escaping_bound_vars() => {\n-                        infcx.infer_projection(\n-                            self.param_env,\n-                            *projection_ty,\n-                            traits::ObligationCause::misc(self.value_span, self.body_id),\n+                        self.infer_projection(\n+                            param_env,\n+                            projection_ty,\n+                            cause.clone(),\n                             0,\n-                            &mut self.obligations,\n+                            &mut obligations,\n                         )\n                     }\n+                    // Replace all other mentions of the same opaque type with the hidden type,\n+                    // as the bounds must hold on the hidden type after all.\n+                    ty::Opaque(def_id2, substs2) if def_id == def_id2 && substs == substs2 => {\n+                        hidden_ty\n+                    }\n                     _ => ty,\n                 },\n                 lt_op: |lt| lt,\n                 ct_op: |ct| ct,\n             });\n-            debug!(?predicate);\n \n             if let ty::PredicateKind::Projection(projection) = predicate.kind().skip_binder() {\n                 if projection.term.references_error() {\n-                    return tcx.ty_error();\n+                    // No point on adding these obligations since there's a type error involved.\n+                    return Ok(InferOk { value: (), obligations: vec![] });\n                 }\n+                trace!(\"{:#?}\", projection.term);\n             }\n-\n-            let cause =\n-                traits::ObligationCause::new(self.value_span, self.body_id, traits::OpaqueType);\n-\n             // Require that the predicate holds for the concrete type.\n             debug!(?predicate);\n-            self.obligations.push(traits::Obligation::new(cause, self.param_env, predicate));\n+            obligations.push(traits::Obligation::new(cause.clone(), param_env, predicate));\n         }\n-\n-        ty_var\n+        Ok(InferOk { value: (), obligations })\n     }\n }\n "}, {"sha": "fb12da0cc13f0aeb3661ff34d8c7781d92058d9f", "filename": "compiler/rustc_infer/src/infer/opaque_types/table.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,80 @@\n+use rustc_data_structures::undo_log::UndoLogs;\n+use rustc_hir::OpaqueTyOrigin;\n+use rustc_middle::ty::{self, OpaqueHiddenType, OpaqueTypeKey, Ty};\n+use rustc_span::DUMMY_SP;\n+\n+use crate::infer::{InferCtxtUndoLogs, UndoLog};\n+\n+use super::{OpaqueTypeDecl, OpaqueTypeMap};\n+\n+#[derive(Default, Debug, Clone)]\n+pub struct OpaqueTypeStorage<'tcx> {\n+    // Opaque types found in explicit return types and their\n+    // associated fresh inference variable. Writeback resolves these\n+    // variables to get the concrete type, which can be used to\n+    // 'de-opaque' OpaqueTypeDecl, after typeck is done with all functions.\n+    pub opaque_types: OpaqueTypeMap<'tcx>,\n+}\n+\n+impl<'tcx> OpaqueTypeStorage<'tcx> {\n+    #[instrument(level = \"debug\")]\n+    pub(crate) fn remove(&mut self, key: OpaqueTypeKey<'tcx>, idx: Option<OpaqueHiddenType<'tcx>>) {\n+        if let Some(idx) = idx {\n+            self.opaque_types.get_mut(&key).unwrap().hidden_type = idx;\n+        } else {\n+            match self.opaque_types.remove(&key) {\n+                None => bug!(\"reverted opaque type inference that was never registered: {:?}\", key),\n+                Some(_) => {}\n+            }\n+        }\n+    }\n+\n+    #[instrument(level = \"debug\")]\n+    pub fn take_opaque_types(&mut self) -> OpaqueTypeMap<'tcx> {\n+        std::mem::take(&mut self.opaque_types)\n+    }\n+\n+    #[inline]\n+    pub(crate) fn with_log<'a>(\n+        &'a mut self,\n+        undo_log: &'a mut InferCtxtUndoLogs<'tcx>,\n+    ) -> OpaqueTypeTable<'a, 'tcx> {\n+        OpaqueTypeTable { storage: self, undo_log }\n+    }\n+}\n+\n+impl<'tcx> Drop for OpaqueTypeStorage<'tcx> {\n+    fn drop(&mut self) {\n+        if !self.opaque_types.is_empty() {\n+            ty::tls::with(|tcx| {\n+                tcx.sess.delay_span_bug(DUMMY_SP, &format!(\"{:?}\", self.opaque_types))\n+            });\n+        }\n+    }\n+}\n+\n+pub struct OpaqueTypeTable<'a, 'tcx> {\n+    storage: &'a mut OpaqueTypeStorage<'tcx>,\n+\n+    undo_log: &'a mut InferCtxtUndoLogs<'tcx>,\n+}\n+\n+impl<'a, 'tcx> OpaqueTypeTable<'a, 'tcx> {\n+    #[instrument(skip(self), level = \"debug\")]\n+    pub(crate) fn register(\n+        &mut self,\n+        key: OpaqueTypeKey<'tcx>,\n+        hidden_type: OpaqueHiddenType<'tcx>,\n+        origin: OpaqueTyOrigin,\n+    ) -> Option<Ty<'tcx>> {\n+        if let Some(decl) = self.storage.opaque_types.get_mut(&key) {\n+            let prev = std::mem::replace(&mut decl.hidden_type, hidden_type);\n+            self.undo_log.push(UndoLog::OpaqueTypes(key, Some(prev)));\n+            return Some(prev.ty);\n+        }\n+        let decl = OpaqueTypeDecl { hidden_type, origin };\n+        self.storage.opaque_types.insert(key, decl);\n+        self.undo_log.push(UndoLog::OpaqueTypes(key, None));\n+        None\n+    }\n+}"}, {"sha": "45aa2bcba86f264e02698e48f1d4328895402141", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -153,6 +153,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// This function may have to perform normalizations, and hence it\n     /// returns an `InferOk` with subobligations that must be\n     /// processed.\n+    #[instrument(level = \"debug\", skip(self, region_bound_pairs_map))]\n     pub fn process_registered_region_obligations(\n         &self,\n         region_bound_pairs_map: &FxHashMap<hir::HirId, RegionBoundPairs<'tcx>>,\n@@ -164,8 +165,6 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             \"cannot process registered region obligations in a snapshot\"\n         );\n \n-        debug!(?param_env, \"process_registered_region_obligations()\");\n-\n         let my_region_obligations = self.take_registered_region_obligations();\n \n         for (body_id, RegionObligation { sup_type, sub_region, origin }) in my_region_obligations {"}, {"sha": "3600b54a27104c67b3be68b77fb3f8035271c020", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -2,6 +2,7 @@ use super::combine::{CombineFields, RelationDir};\n use super::SubregionOrigin;\n \n use crate::infer::combine::ConstEquateRelation;\n+use crate::infer::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::traits::Obligation;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n@@ -74,16 +75,16 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"{}.tys({:?}, {:?})\", self.tag(), a, b);\n-\n         if a == b {\n             return Ok(a);\n         }\n \n         let infcx = self.fields.infcx;\n         let a = infcx.inner.borrow_mut().type_variables().replace_if_possible(a);\n         let b = infcx.inner.borrow_mut().type_variables().replace_if_possible(b);\n+\n         match (a.kind(), b.kind()) {\n             (&ty::Infer(TyVar(_)), &ty::Infer(TyVar(_))) => {\n                 // Shouldn't have any LBR here, so we can safely put\n@@ -121,6 +122,38 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n                 Ok(self.tcx().ty_error())\n             }\n \n+            (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {\n+                self.fields.infcx.super_combine_tys(self, a, b)?;\n+                Ok(a)\n+            }\n+            (&ty::Opaque(did, ..), _) | (_, &ty::Opaque(did, ..))\n+                if self.fields.define_opaque_types && did.is_local() =>\n+            {\n+                let mut generalize = |ty, ty_is_expected| {\n+                    let var = infcx.next_ty_var_id_in_universe(\n+                        TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::MiscVariable,\n+                            span: self.fields.trace.cause.span,\n+                        },\n+                        ty::UniverseIndex::ROOT,\n+                    );\n+                    self.fields.instantiate(ty, RelationDir::SubtypeOf, var, ty_is_expected)?;\n+                    Ok(infcx.tcx.mk_ty_var(var))\n+                };\n+                let (a, b) = if self.a_is_expected { (a, b) } else { (b, a) };\n+                let (a, b) = match (a.kind(), b.kind()) {\n+                    (&ty::Opaque(..), _) => (a, generalize(b, true)?),\n+                    (_, &ty::Opaque(..)) => (generalize(a, false)?, b),\n+                    _ => unreachable!(),\n+                };\n+                self.fields.obligations.extend(\n+                    infcx\n+                        .handle_opaque_type(a, b, true, &self.fields.trace.cause, self.param_env())?\n+                        .obligations,\n+                );\n+                Ok(a)\n+            }\n+\n             _ => {\n                 self.fields.infcx.super_combine_tys(self, a, b)?;\n                 Ok(a)"}, {"sha": "1b696f21cbcf479364509311159e6912478123d5", "filename": "compiler/rustc_infer/src/infer/undo_log.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -4,7 +4,7 @@ use rustc_data_structures::snapshot_vec as sv;\n use rustc_data_structures::undo_log::{Rollback, UndoLogs};\n use rustc_data_structures::unify as ut;\n use rustc_middle::infer::unify_key::RegionVidKey;\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, OpaqueHiddenType, OpaqueTypeKey};\n \n use crate::{\n     infer::{region_constraints, type_variable, InferCtxtInner},\n@@ -19,6 +19,7 @@ pub struct Snapshot<'tcx> {\n /// Records the \"undo\" data for a single operation that affects some form of inference variable.\n #[derive(Clone)]\n pub(crate) enum UndoLog<'tcx> {\n+    OpaqueTypes(OpaqueTypeKey<'tcx>, Option<OpaqueHiddenType<'tcx>>),\n     TypeVariables(type_variable::UndoLog<'tcx>),\n     ConstUnificationTable(sv::UndoLog<ut::Delegate<ty::ConstVid<'tcx>>>),\n     IntUnificationTable(sv::UndoLog<ut::Delegate<ty::IntVid>>),\n@@ -65,6 +66,7 @@ impl_from! {\n impl<'tcx> Rollback<UndoLog<'tcx>> for InferCtxtInner<'tcx> {\n     fn reverse(&mut self, undo: UndoLog<'tcx>) {\n         match undo {\n+            UndoLog::OpaqueTypes(key, idx) => self.opaque_type_storage.remove(key, idx),\n             UndoLog::TypeVariables(undo) => self.type_variable_storage.reverse(undo),\n             UndoLog::ConstUnificationTable(undo) => self.const_unification_storage.reverse(undo),\n             UndoLog::IntUnificationTable(undo) => self.int_unification_storage.reverse(undo),"}, {"sha": "f3ea83a32b5864e9d7d413b4d50489f2be463049", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -178,6 +178,12 @@ pub struct QueryResponse<'tcx, R> {\n     pub var_values: CanonicalVarValues<'tcx>,\n     pub region_constraints: QueryRegionConstraints<'tcx>,\n     pub certainty: Certainty,\n+    /// List of opaque types which we tried to compare to another type.\n+    /// Inside the query we don't know yet whether the opaque type actually\n+    /// should get its hidden type inferred. So we bubble the opaque type\n+    /// and the type it was compared against upwards and let the query caller\n+    /// handle it.\n+    pub opaque_types: Vec<(Ty<'tcx>, Ty<'tcx>)>,\n     pub value: R,\n }\n "}, {"sha": "811b9da3740d7b4694f79156f81efc14d52e9d68", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,7 +1,7 @@\n //! Values computed by queries that use MIR.\n \n use crate::mir::{Body, Promoted};\n-use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::{self, OpaqueHiddenType, Ty, TyCtxt};\n use rustc_data_structures::stable_map::FxHashMap;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::ErrorGuaranteed;\n@@ -242,7 +242,7 @@ pub struct BorrowCheckResult<'tcx> {\n     /// All the opaque types that are restricted to concrete types\n     /// by this function. Unlike the value in `TypeckResults`, this has\n     /// unerased regions.\n-    pub concrete_opaque_types: VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>>,\n+    pub concrete_opaque_types: VecMap<OpaqueTypeKey<'tcx>, OpaqueHiddenType<'tcx>>,\n     pub closure_requirements: Option<ClosureRegionRequirements<'tcx>>,\n     pub used_mut_upvars: SmallVec<[Field; 8]>,\n     pub tainted_by_errors: Option<ErrorGuaranteed>,"}, {"sha": "3243ef28ff00504a6e0e9937adbe2b960badc024", "filename": "compiler/rustc_middle/src/ty/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -53,17 +53,17 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n         self.relate(a, b)\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn regions(\n         &mut self,\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n     ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        debug!(\"{}.regions({:?}, {:?})\", self.tag(), a, b);\n         Ok(a)\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"{}.tys({:?}, {:?})\", self.tag(), a, b);\n         if a == b {\n             return Ok(a);\n         }"}, {"sha": "ac9f04ee05575ccd7ad5fb4b8950ff22166a6c8d", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -33,6 +33,7 @@ use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{self, Lock, Lrc, WorkerLocal};\n+use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -485,9 +486,13 @@ pub struct TypeckResults<'tcx> {\n     /// this field will be set to `Some(ErrorGuaranteed)`.\n     pub tainted_by_errors: Option<ErrorGuaranteed>,\n \n-    /// All the opaque types that are restricted to concrete types\n-    /// by this function.\n-    pub concrete_opaque_types: FxHashSet<DefId>,\n+    /// All the opaque types that have hidden types set\n+    /// by this function. For return-position-impl-trait we also store the\n+    /// type here, so that mir-borrowck can figure out hidden types,\n+    /// even if they are only set in dead code (which doesn't show up in MIR).\n+    /// For type-alias-impl-trait, this map is only used to prevent query cycles,\n+    /// so the hidden types are all `None`.\n+    pub concrete_opaque_types: VecMap<DefId, Option<Ty<'tcx>>>,\n \n     /// Tracks the minimum captures required for a closure;\n     /// see `MinCaptureInformationMap` for more details."}, {"sha": "388109e6512dd29a82b2232017d7bec0e2afc177", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1243,15 +1243,11 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     type BreakTy = FoundFlags;\n \n     #[inline]\n-    #[instrument(level = \"trace\")]\n-    fn visit_ty(&mut self, t: Ty<'_>) -> ControlFlow<Self::BreakTy> {\n-        debug!(\n-            \"HasTypeFlagsVisitor: t={:?} t.flags={:?} self.flags={:?}\",\n-            t,\n-            t.flags(),\n-            self.flags\n-        );\n-        if t.flags().intersects(self.flags) {\n+    #[instrument(skip(self), level = \"trace\")]\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        let flags = t.flags();\n+        trace!(t.flags=?t.flags());\n+        if flags.intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n         } else {\n             ControlFlow::CONTINUE"}, {"sha": "44c190e459c3d82ead6cb179eee07397dea37941", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1057,12 +1057,55 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable, TyEncodable, TyDecodable, TypeFoldable)]\n+#[derive(\n+    Copy,\n+    Clone,\n+    Debug,\n+    PartialEq,\n+    Eq,\n+    HashStable,\n+    TyEncodable,\n+    TyDecodable,\n+    TypeFoldable,\n+    Lift\n+)]\n pub struct OpaqueTypeKey<'tcx> {\n     pub def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n }\n \n+#[derive(Copy, Clone, Debug, TypeFoldable, HashStable, TyEncodable, TyDecodable)]\n+pub struct OpaqueHiddenType<'tcx> {\n+    /// The span of this particular definition of the opaque type. So\n+    /// for example:\n+    ///\n+    /// ```ignore (incomplete snippet)\n+    /// type Foo = impl Baz;\n+    /// fn bar() -> Foo {\n+    /// //          ^^^ This is the span we are looking for!\n+    /// }\n+    /// ```\n+    ///\n+    /// In cases where the fn returns `(impl Trait, impl Trait)` or\n+    /// other such combinations, the result is currently\n+    /// over-approximated, but better than nothing.\n+    pub span: Span,\n+\n+    /// The type variable that represents the value of the opaque type\n+    /// that we require. In other words, after we compile this function,\n+    /// we will be created a constraint like:\n+    ///\n+    ///     Foo<'a, T> = ?C\n+    ///\n+    /// where `?C` is the value of this type variable. =) It may\n+    /// naturally refer to the type and lifetime parameters in scope\n+    /// in this function, though ultimately it should only reference\n+    /// those that are arguments to `Foo` in the constraint above. (In\n+    /// other words, `?C` should not include `'b`, even though it's a\n+    /// lifetime parameter on `foo`.)\n+    pub ty: Ty<'tcx>,\n+}\n+\n rustc_index::newtype_index! {\n     /// \"Universes\" are used during type- and trait-checking in the\n     /// presence of `for<..>` binders to control what sets of names are"}, {"sha": "fecc5d805fcace0670e0805c5767b54ffc07b291", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -647,20 +647,23 @@ pub trait PrettyPrinter<'tcx>:\n                     return Ok(self);\n                 }\n \n-                return with_no_queries!({\n-                    let def_key = self.tcx().def_key(def_id);\n-                    if let Some(name) = def_key.disambiguated_data.data.get_opt_name() {\n-                        p!(write(\"{}\", name));\n-                        // FIXME(eddyb) print this with `print_def_path`.\n-                        if !substs.is_empty() {\n-                            p!(\"::\");\n-                            p!(generic_delimiters(|cx| cx.comma_sep(substs.iter())));\n+                let parent = self.tcx().parent(def_id).expect(\"opaque types always have a parent\");\n+                match self.tcx().def_kind(parent) {\n+                    DefKind::TyAlias | DefKind::AssocTy => {\n+                        if let ty::Opaque(d, _) = *self.tcx().type_of(parent).kind() {\n+                            if d == def_id {\n+                                // If the type alias directly starts with the `impl` of the\n+                                // opaque type we're printing, then skip the `::{opaque#1}`.\n+                                p!(print_def_path(parent, substs));\n+                                return Ok(self);\n+                            }\n                         }\n+                        // Complex opaque type, e.g. `type Foo = (i32, impl Debug);`\n+                        p!(print_def_path(def_id, substs));\n                         return Ok(self);\n                     }\n-\n-                    self.pretty_print_opaque_impl_type(def_id, substs)\n-                });\n+                    _ => return self.pretty_print_opaque_impl_type(def_id, substs),\n+                }\n             }\n             ty::Str => p!(\"str\"),\n             ty::Generator(did, substs, movability) => {"}, {"sha": "335ddeb66db05913ec790bcdeaa87318825e3e95", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1925,6 +1925,13 @@ impl<'tcx> Ty<'tcx> {\n         }\n     }\n \n+    pub fn expect_opaque_type(self) -> ty::OpaqueTypeKey<'tcx> {\n+        match *self.kind() {\n+            Opaque(def_id, substs) => ty::OpaqueTypeKey { def_id, substs },\n+            _ => bug!(\"`expect_opaque_type` called on non-opaque type: {}\", self),\n+        }\n+    }\n+\n     pub fn simd_size_and_type(self, tcx: TyCtxt<'tcx>) -> (u64, Ty<'tcx>) {\n         match self.kind() {\n             Adt(def, substs) => {"}, {"sha": "679043bdc30f922a6662693af0594c5dc86fda9a", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,8 +1,8 @@\n use crate::build::matches::ArmHasGuard;\n use crate::build::ForGuard::OutsideGuard;\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n-use rustc_middle::mir::*;\n use rustc_middle::thir::*;\n+use rustc_middle::{mir::*, ty};\n use rustc_span::Span;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n@@ -190,7 +190,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // This return type is usually `()`, unless the block is diverging, in which case the\n             // return type is `!`. For the unit type, we need to actually return the unit, but in\n             // the case of `!`, no return value is required, as the block will never return.\n-            if destination_ty.is_unit() {\n+            // Opaque types of empty bodies also need this unit assignment, in order to infer that their\n+            // type is actually unit. Otherwise there will be no defining use found in the MIR.\n+            if destination_ty.is_unit() || matches!(destination_ty.kind(), ty::Opaque(..)) {\n                 // We only want to assign an implicit `()` as the return value of the block if the\n                 // block does not diverge. (Otherwise, we may try to assign a unit to a `!`-type.)\n                 this.cfg.push_assign_unit(block, source_info, destination, this.tcx);"}, {"sha": "7fd20b45e77cd7ff465595569081d08f8455b0a8", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -181,7 +181,6 @@ impl<K: DepKind> EncoderState<K> {\n         }\n     }\n \n-    #[instrument(level = \"debug\", skip(self, record_graph))]\n     fn encode_node(\n         &mut self,\n         node: &NodeInfo<K>,\n@@ -208,7 +207,6 @@ impl<K: DepKind> EncoderState<K> {\n             stat.edge_counter += edge_count as u64;\n         }\n \n-        debug!(?index, ?node);\n         let encoder = &mut self.encoder;\n         if self.result.is_ok() {\n             self.result = node.encode(encoder);"}, {"sha": "06287f00faddb00c717c816f8808bb750aa1bf49", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -5,15 +5,14 @@ use rustc_infer::infer::error_reporting::unexpected_hidden_region_diagnostic;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts};\n-use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt};\n+use rustc_middle::ty::{self, OpaqueHiddenType, OpaqueTypeKey, Ty, TyCtxt};\n use rustc_span::Span;\n \n pub trait InferCtxtExt<'tcx> {\n     fn infer_opaque_definition_from_instantiation(\n         &self,\n         opaque_type_key: OpaqueTypeKey<'tcx>,\n-        instantiated_ty: Ty<'tcx>,\n-        span: Span,\n+        instantiated_ty: OpaqueHiddenType<'tcx>,\n     ) -> Ty<'tcx>;\n }\n \n@@ -33,7 +32,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// purpose of this function is to do that translation.\n     ///\n     /// (*) C1 and C2 were introduced in the comments on\n-    /// `constrain_opaque_type`. Read that comment for more context.\n+    /// `register_member_constraints`. Read that comment for more context.\n     ///\n     /// # Parameters\n     ///\n@@ -45,9 +44,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn infer_opaque_definition_from_instantiation(\n         &self,\n         opaque_type_key: OpaqueTypeKey<'tcx>,\n-        instantiated_ty: Ty<'tcx>,\n-        span: Span,\n+        instantiated_ty: OpaqueHiddenType<'tcx>,\n     ) -> Ty<'tcx> {\n+        if self.is_tainted_by_errors() {\n+            return self.tcx.ty_error();\n+        }\n+\n         let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n \n         // Use substs to build up a reverse map from regions to their\n@@ -65,13 +67,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // Convert the type from the function into a type valid outside\n         // the function, by replacing invalid regions with 'static,\n         // after producing an error for each of them.\n-        let definition_ty = instantiated_ty.fold_with(&mut ReverseMapper::new(\n+        let definition_ty = instantiated_ty.ty.fold_with(&mut ReverseMapper::new(\n             self.tcx,\n-            self.is_tainted_by_errors(),\n             def_id,\n             map,\n-            instantiated_ty,\n-            span,\n+            instantiated_ty.ty,\n+            instantiated_ty.span,\n         ));\n         debug!(?definition_ty);\n \n@@ -82,10 +83,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n struct ReverseMapper<'tcx> {\n     tcx: TyCtxt<'tcx>,\n \n-    /// If errors have already been reported in this fn, we suppress\n-    /// our own errors because they are sometimes derivative.\n-    tainted_by_errors: bool,\n-\n     opaque_type_def_id: DefId,\n     map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n     map_missing_regions_to_empty: bool,\n@@ -100,15 +97,13 @@ struct ReverseMapper<'tcx> {\n impl<'tcx> ReverseMapper<'tcx> {\n     fn new(\n         tcx: TyCtxt<'tcx>,\n-        tainted_by_errors: bool,\n         opaque_type_def_id: DefId,\n         map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n         hidden_ty: Ty<'tcx>,\n         span: Span,\n     ) -> Self {\n         Self {\n             tcx,\n-            tainted_by_errors,\n             opaque_type_def_id,\n             map,\n             map_missing_regions_to_empty: false,\n@@ -167,9 +162,7 @@ impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n         match self.map.get(&r.into()).map(|k| k.unpack()) {\n             Some(GenericArgKind::Lifetime(r1)) => r1,\n             Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n-            None if self.map_missing_regions_to_empty || self.tainted_by_errors => {\n-                self.tcx.lifetimes.re_root_empty\n-            }\n+            None if self.map_missing_regions_to_empty => self.tcx.lifetimes.re_root_empty,\n             None if generics.parent.is_some() => {\n                 if let Some(hidden_ty) = self.hidden_ty.take() {\n                     unexpected_hidden_region_diagnostic("}, {"sha": "4b6784aee9782c0066287e8df29e08f52c199f3e", "filename": "compiler/rustc_trait_selection/src/traits/codegen.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -92,6 +92,12 @@ pub fn codegen_fulfill_obligation<'tcx>(\n         });\n         let impl_source = drain_fulfillment_cx_or_panic(&infcx, &mut fulfill_cx, impl_source);\n \n+        // There should be no opaque types during codegen, they all get revealed.\n+        let opaque_types = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+        if !opaque_types.is_empty() {\n+            bug!(\"{:#?}\", opaque_types);\n+        }\n+\n         debug!(\"Cache miss: {:?} => {:?}\", trait_ref, impl_source);\n         Ok(&*tcx.arena.alloc(impl_source))\n     })"}, {"sha": "39da99ac252933860659f9f8a7b9a17153d30be0", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1294,6 +1294,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             ty::Generator(..) => \"generator\",\n             _ => \"function\",\n         };\n+        let span = self.tcx.sess.source_map().guess_head_span(span);\n         let mut err = struct_span_err!(\n             self.tcx.sess,\n             span,\n@@ -1673,6 +1674,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             ));\n \n             let original_span = err.span.primary_span().unwrap();\n+            let original_span = self.tcx.sess.source_map().guess_head_span(original_span);\n             let mut span = MultiSpan::from_span(original_span);\n \n             let message = outer_generator"}, {"sha": "d4ec677a0b1c55602601c8edf29222e865e29562", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -214,10 +214,21 @@ fn project_and_unify_type<'cx, 'tcx>(\n         Err(InProgress) => return Ok(Err(InProgress)),\n     };\n     debug!(?normalized, ?obligations, \"project_and_unify_type result\");\n-    match infcx\n-        .at(&obligation.cause, obligation.param_env)\n-        .eq(normalized, obligation.predicate.term)\n-    {\n+    let actual = obligation.predicate.term;\n+    // HACK: lazy TAIT would regress src/test/ui/impl-trait/nested-return-type2.rs, so we add\n+    // a back-compat hack hat converts the RPITs into inference vars, just like they were before\n+    // lazy TAIT.\n+    // This does not affect TAITs in general, as tested in the nested-return-type-tait* tests.\n+    let InferOk { value: actual, obligations: new } =\n+        selcx.infcx().replace_opaque_types_with_inference_vars(\n+            actual,\n+            obligation.cause.body_id,\n+            obligation.cause.span,\n+            obligation.param_env,\n+        );\n+    obligations.extend(new);\n+\n+    match infcx.at(&obligation.cause, obligation.param_env).eq(normalized, actual) {\n         Ok(InferOk { obligations: inferred_obligations, value: () }) => {\n             obligations.extend(inferred_obligations);\n             Ok(Ok(Some(obligations)))"}, {"sha": "605c9ace5ed06644c22ea0d0e5774a9aa74f0e3c", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/custom.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -3,7 +3,8 @@ use crate::infer::{InferCtxt, InferOk};\n use crate::traits::engine::TraitEngineExt as _;\n use crate::traits::query::type_op::TypeOpOutput;\n use crate::traits::query::Fallible;\n-use crate::traits::{ObligationCause, TraitEngine};\n+use crate::traits::TraitEngine;\n+use rustc_infer::infer::region_constraints::RegionConstraintData;\n use rustc_infer::traits::TraitEngineExt as _;\n use rustc_span::source_map::DUMMY_SP;\n \n@@ -31,6 +32,9 @@ where\n     G: Fn() -> String,\n {\n     type Output = R;\n+    /// We can't do any custom error reporting for `CustomTypeOp`, so\n+    /// we can use `!` to enforce that the implementation never provides it.\n+    type ErrorInfo = !;\n \n     /// Processes the operation and all resulting obligations,\n     /// returning the final result along with any region constraints\n@@ -40,7 +44,7 @@ where\n             info!(\"fully_perform({:?})\", self);\n         }\n \n-        scrape_region_constraints(infcx, || (self.closure)(infcx))\n+        Ok(scrape_region_constraints(infcx, || (self.closure)(infcx))?.0)\n     }\n }\n \n@@ -55,12 +59,11 @@ where\n \n /// Executes `op` and then scrapes out all the \"old style\" region\n /// constraints that result, creating query-region-constraints.\n-fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n+pub fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n     infcx: &InferCtxt<'_, 'tcx>,\n     op: impl FnOnce() -> Fallible<InferOk<'tcx, R>>,\n-) -> Fallible<TypeOpOutput<'tcx, Op>> {\n+) -> Fallible<(TypeOpOutput<'tcx, Op>, RegionConstraintData<'tcx>)> {\n     let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-    let dummy_body_id = ObligationCause::dummy().body_id;\n \n     // During NLL, we expect that nobody will register region\n     // obligations **except** as part of a custom type op (and, at the\n@@ -75,7 +78,6 @@ fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n     );\n \n     let InferOk { value, obligations } = infcx.commit_if_ok(|_| op())?;\n-    debug_assert!(obligations.iter().all(|o| o.cause.body_id == dummy_body_id));\n     fulfill_cx.register_predicate_obligations(infcx, obligations);\n     let errors = fulfill_cx.select_all_or_error(infcx);\n     if !errors.is_empty() {\n@@ -99,12 +101,18 @@ fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n     );\n \n     if region_constraints.is_empty() {\n-        Ok(TypeOpOutput { output: value, constraints: None, canonicalized_query: None })\n+        Ok((\n+            TypeOpOutput { output: value, constraints: None, error_info: None },\n+            region_constraint_data,\n+        ))\n     } else {\n-        Ok(TypeOpOutput {\n-            output: value,\n-            constraints: Some(Rc::new(region_constraints)),\n-            canonicalized_query: None,\n-        })\n+        Ok((\n+            TypeOpOutput {\n+                output: value,\n+                constraints: Some(Rc::new(region_constraints)),\n+                error_info: None,\n+            },\n+            region_constraint_data,\n+        ))\n     }\n }"}, {"sha": "1e72dd693396a8cfcf5d11a864268bd25f510de2", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -28,6 +28,7 @@ pub use rustc_middle::traits::query::type_op::*;\n /// cannot be completed).\n pub trait TypeOp<'tcx>: Sized + fmt::Debug {\n     type Output;\n+    type ErrorInfo;\n \n     /// Processes the operation and all resulting obligations,\n     /// returning the final result along with any region constraints\n@@ -41,9 +42,8 @@ pub struct TypeOpOutput<'tcx, Op: TypeOp<'tcx>> {\n     pub output: Op::Output,\n     /// Any region constraints from performing the type op.\n     pub constraints: Option<Rc<QueryRegionConstraints<'tcx>>>,\n-    /// The canonicalized form of the query.\n-    /// This for error reporting to be able to rerun the query.\n-    pub canonicalized_query: Option<Canonical<'tcx, Op>>,\n+    /// Used for error reporting to be able to rerun the query\n+    pub error_info: Option<Op::ErrorInfo>,\n }\n \n /// \"Query type ops\" are type ops that are implemented using a\n@@ -119,10 +119,11 @@ where\n     Q: QueryTypeOp<'tcx>,\n {\n     type Output = Q::QueryResponse;\n+    type ErrorInfo = Canonical<'tcx, ParamEnvAnd<'tcx, Q>>;\n \n     fn fully_perform(self, infcx: &InferCtxt<'_, 'tcx>) -> Fallible<TypeOpOutput<'tcx, Self>> {\n         let mut region_constraints = QueryRegionConstraints::default();\n-        let (output, canonicalized_query, mut obligations, _) =\n+        let (output, error_info, mut obligations, _) =\n             Q::fully_perform_into(self, infcx, &mut region_constraints)?;\n \n         // Typically, instantiating NLL query results does not\n@@ -160,6 +161,6 @@ where\n         let region_constraints =\n             if region_constraints.is_empty() { None } else { Some(Rc::new(region_constraints)) };\n \n-        Ok(TypeOpOutput { output, constraints: region_constraints, canonicalized_query })\n+        Ok(TypeOpOutput { output, constraints: region_constraints, error_info })\n     }\n }"}, {"sha": "cf472813e9e3217c873ab060c0b7091bf58f2ae5", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -256,6 +256,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n \n         if obligation.predicate.skip_binder().self_ty().is_ty_var() {\n+            debug!(ty = ?obligation.predicate.skip_binder().self_ty(), \"ambiguous inference var or opaque type\");\n             // Self is a type variable (e.g., `_: AsRef<str>`).\n             //\n             // This is somewhat problematic, as the current scheme can't really"}, {"sha": "42f17721f9b545c7f8dfd321f28238f06062a9ba", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -33,6 +33,7 @@ use rustc_middle::dep_graph::{DepKind, DepNodeIndex};\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::fast_reject::{self, TreatParams};\n+use rustc_middle::ty::fold::BottomUpFolder;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArgKind, Subst, SubstsRef};\n@@ -1313,6 +1314,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self, param_env, cache_fresh_trait_pred, dep_node), level = \"debug\")]\n     fn insert_candidate_cache(\n         &mut self,\n         mut param_env: ty::ParamEnv<'tcx>,\n@@ -1353,17 +1355,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// a projection, look at the bounds of `T::Bar`, see if we can find a\n     /// `Baz` bound. We return indexes into the list returned by\n     /// `tcx.item_bounds` for any applicable bounds.\n+    #[instrument(level = \"debug\", skip(self))]\n     fn match_projection_obligation_against_definition_bounds(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n     ) -> smallvec::SmallVec<[usize; 2]> {\n         let poly_trait_predicate = self.infcx().resolve_vars_if_possible(obligation.predicate);\n         let placeholder_trait_predicate =\n             self.infcx().replace_bound_vars_with_placeholders(poly_trait_predicate);\n-        debug!(\n-            ?placeholder_trait_predicate,\n-            \"match_projection_obligation_against_definition_bounds\"\n-        );\n+        debug!(?placeholder_trait_predicate);\n \n         let tcx = self.infcx.tcx;\n         let (def_id, substs) = match *placeholder_trait_predicate.trait_ref.self_ty().kind() {\n@@ -1414,7 +1414,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             })\n             .collect();\n \n-        debug!(?matching_bounds, \"match_projection_obligation_against_definition_bounds\");\n+        debug!(?matching_bounds);\n         matching_bounds\n     }\n \n@@ -1444,6 +1444,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         });\n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n+            .define_opaque_types(false)\n             .sup(ty::Binder::dummy(placeholder_trait_ref), trait_bound)\n             .map(|InferOk { obligations: _, value: () }| {\n                 // This method is called within a probe, so we can't have\n@@ -1506,6 +1507,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let is_match = self\n             .infcx\n             .at(&obligation.cause, obligation.param_env)\n+            .define_opaque_types(false)\n             .sup(obligation.predicate, infer_projection)\n             .map_or(false, |InferOk { obligations, value: () }| {\n                 self.evaluate_predicates_recursively(\n@@ -2081,11 +2083,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match self.match_impl(impl_def_id, obligation) {\n             Ok(substs) => substs,\n             Err(()) => {\n-                bug!(\n-                    \"Impl {:?} was matchable against {:?} but now is not\",\n-                    impl_def_id,\n-                    obligation\n+                self.infcx.tcx.sess.delay_span_bug(\n+                    obligation.cause.span,\n+                    &format!(\n+                        \"Impl {:?} was matchable against {:?} but now is not\",\n+                        impl_def_id, obligation\n+                    ),\n                 );\n+                let value = self.infcx.fresh_substs_for_item(obligation.cause.span, impl_def_id);\n+                let err = self.tcx().ty_error();\n+                let value = value.fold_with(&mut BottomUpFolder {\n+                    tcx: self.tcx(),\n+                    ty_op: |_| err,\n+                    lt_op: |l| l,\n+                    ct_op: |c| c,\n+                });\n+                Normalized { value, obligations: vec![] }\n             }\n         }\n     }\n@@ -2137,6 +2150,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let InferOk { obligations, .. } = self\n             .infcx\n             .at(&cause, obligation.param_env)\n+            .define_opaque_types(false)\n             .eq(placeholder_obligation_trait_ref, impl_trait_ref)\n             .map_err(|e| debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e))?;\n         nested_obligations.extend(obligations);\n@@ -2220,6 +2234,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> Result<Vec<PredicateObligation<'tcx>>, ()> {\n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n+            // We don't want predicates for opaque types to just match all other types,\n+            // if there is an obligation on the opaque type, then that obligation must be met\n+            // opaquely. Otherwise we'd match any obligation to the opaque type and then error\n+            // out later.\n+            .define_opaque_types(false)\n             .sup(obligation.predicate.to_poly_trait_ref(), poly_trait_ref)\n             .map(|InferOk { obligations, .. }| obligations)\n             .map_err(|_| ())"}, {"sha": "4e19479da87fbce387fc997a0dd0f83723e68f49", "filename": "compiler/rustc_traits/src/chalk/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -134,6 +134,7 @@ crate fn evaluate_goal<'tcx>(\n                 var_values: CanonicalVarValues { var_values },\n                 region_constraints: QueryRegionConstraints::default(),\n                 certainty: Certainty::Proven,\n+                opaque_types: vec![],\n                 value: (),\n             },\n         };\n@@ -162,6 +163,7 @@ crate fn evaluate_goal<'tcx>(\n                                     .make_identity(tcx),\n                                 region_constraints: QueryRegionConstraints::default(),\n                                 certainty: Certainty::Ambiguous,\n+                                opaque_types: vec![],\n                                 value: (),\n                             },\n                         };"}, {"sha": "b015e40b6836fea3991eaaaf524f7da3ffd2e6c2", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -61,6 +61,14 @@ bitflags! {\n                                           | TypeFlags::HAS_CT_INFER.bits\n                                           | TypeFlags::HAS_TY_PLACEHOLDER.bits\n                                           | TypeFlags::HAS_CT_PLACEHOLDER.bits\n+                                          // The `evaluate_obligation` query does not return further\n+                                          // obligations. If it evaluates an obligation with an opaque\n+                                          // type, that opaque type may get compared to another type,\n+                                          // constraining it. We would lose this information.\n+                                          // FIXME: differentiate between crate-local opaque types\n+                                          // and opaque types from other crates, as only opaque types\n+                                          // from the local crate can possibly be a local name\n+                                          | TypeFlags::HAS_TY_OPAQUE.bits\n                                           // We consider 'freshened' types and constants\n                                           // to depend on a particular fn.\n                                           // The freshening process throws away information,"}, {"sha": "79be8bde55ab153bd3faee3f44a47e583d6bcec5", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -4,7 +4,7 @@ use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir::{self as hir, ExprKind};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::traits::Obligation;\n-use rustc_middle::ty::{self, ToPredicate, Ty};\n+use rustc_middle::ty::{self, ToPredicate, Ty, TypeFoldable};\n use rustc_span::{MultiSpan, Span};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{\n@@ -98,8 +98,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let arm_ty = self.check_expr_with_expectation(&arm.body, expected);\n             all_arms_diverge &= self.diverges.get();\n \n-            let opt_suggest_box_span =\n-                self.opt_suggest_box_span(arm.body.span, arm_ty, orig_expected);\n+            let opt_suggest_box_span = self.opt_suggest_box_span(arm_ty, orig_expected);\n \n             let (arm_span, semi_span) =\n                 self.get_appropriate_arm_semicolon_removal_span(&arms, i, prior_arm_ty, arm_ty);\n@@ -504,20 +503,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // provide a structured suggestion in that case.\n     pub(crate) fn opt_suggest_box_span(\n         &self,\n-        span: Span,\n         outer_ty: Ty<'tcx>,\n         orig_expected: Expectation<'tcx>,\n     ) -> Option<Span> {\n-        match (orig_expected, self.ret_coercion_impl_trait.map(|ty| (self.body_id.owner, ty))) {\n-            (Expectation::ExpectHasType(expected), Some((_id, ty)))\n-                if self.in_tail_expr && self.can_coerce(outer_ty, expected) =>\n+        match orig_expected {\n+            Expectation::ExpectHasType(expected)\n+                if self.in_tail_expr\n+                    && self.ret_coercion.as_ref()?.borrow().merged_ty().has_opaque_types()\n+                    && self.can_coerce(outer_ty, expected) =>\n             {\n-                let impl_trait_ret_ty =\n-                    self.infcx.instantiate_opaque_types(self.body_id, self.param_env, ty, span);\n-                assert!(\n-                    impl_trait_ret_ty.obligations.is_empty(),\n-                    \"we should never get new obligations here\"\n-                );\n                 let obligations = self.fulfillment_cx.borrow().pending_obligations();\n                 let mut suggest_box = !obligations.is_empty();\n                 for o in obligations {"}, {"sha": "2a5cf03e9d0baaf4f042e096250a5a3d02095409", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -538,7 +538,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Expectation<'tcx>,\n         fn_sig: ty::FnSig<'tcx>,\n     ) -> Ty<'tcx> {\n-        // `fn_sig` is the *signature* of the cosure being called. We\n+        // `fn_sig` is the *signature* of the closure being called. We\n         // don't know the full details yet (`Fn` vs `FnMut` etc), but we\n         // do know the types expected for each argument and the return\n         // type."}, {"sha": "5362ca8d719781e66c065a0c3196f93bf90b7b01", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 23, "deletions": 38, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::layout::{LayoutError, MAX_SIMD_LANES};\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::util::{Discr, IntTypeExt};\n-use rustc_middle::ty::{self, OpaqueTypeKey, ParamEnv, Ty, TyCtxt};\n+use rustc_middle::ty::{self, ParamEnv, Ty, TyCtxt};\n use rustc_session::lint::builtin::{UNINHABITED_STATIC, UNSUPPORTED_CALLING_CONVENTIONS};\n use rustc_span::symbol::sym;\n use rustc_span::{self, MultiSpan, Span};\n@@ -83,8 +83,6 @@ pub(super) fn check_fn<'a, 'tcx>(\n     can_be_generator: Option<hir::Movability>,\n     return_type_pre_known: bool,\n ) -> (FnCtxt<'a, 'tcx>, Option<GeneratorTypes<'tcx>>) {\n-    let mut fn_sig = fn_sig;\n-\n     // Create the function context. This is either derived from scratch or,\n     // in the case of closures, based on the outer context.\n     let mut fcx = FnCtxt::new(inherited, param_env, body.value.hir_id);\n@@ -97,21 +95,15 @@ pub(super) fn check_fn<'a, 'tcx>(\n \n     let declared_ret_ty = fn_sig.output();\n \n-    let revealed_ret_ty =\n-        fcx.instantiate_opaque_types_from_value(declared_ret_ty, decl.output.span());\n-    debug!(\"check_fn: declared_ret_ty: {}, revealed_ret_ty: {}\", declared_ret_ty, revealed_ret_ty);\n-    fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(revealed_ret_ty)));\n+    let ret_ty =\n+        fcx.register_infer_ok_obligations(fcx.infcx.replace_opaque_types_with_inference_vars(\n+            declared_ret_ty,\n+            body.value.hir_id,\n+            DUMMY_SP,\n+            param_env,\n+        ));\n+    fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(ret_ty)));\n     fcx.ret_type_span = Some(decl.output.span());\n-    if let ty::Opaque(..) = declared_ret_ty.kind() {\n-        fcx.ret_coercion_impl_trait = Some(declared_ret_ty);\n-    }\n-    fn_sig = tcx.mk_fn_sig(\n-        fn_sig.inputs().iter().cloned(),\n-        revealed_ret_ty,\n-        fn_sig.c_variadic,\n-        fn_sig.unsafety,\n-        fn_sig.abi,\n-    );\n \n     let span = body.value.span;\n \n@@ -253,7 +245,7 @@ pub(super) fn check_fn<'a, 'tcx>(\n             fcx.next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::DynReturnFn, span });\n         debug!(\"actual_return_ty replaced with {:?}\", actual_return_ty);\n     }\n-    fcx.demand_suptype(span, revealed_ret_ty, actual_return_ty);\n+    fcx.demand_suptype(span, declared_ret_ty, actual_return_ty);\n \n     // Check that a function marked as `#[panic_handler]` has signature `fn(&PanicInfo) -> !`\n     if let Some(panic_impl_did) = tcx.lang_items().panic_impl() {\n@@ -656,6 +648,8 @@ fn check_opaque_meets_bounds<'tcx>(\n     span: Span,\n     origin: &hir::OpaqueTyOrigin,\n ) {\n+    let hidden_type = tcx.type_of(def_id).subst(tcx, substs);\n+\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let defining_use_anchor = match *origin {\n         hir::OpaqueTyOrigin::FnReturn(did) | hir::OpaqueTyOrigin::AsyncFn(did) => did,\n@@ -670,25 +664,13 @@ fn check_opaque_meets_bounds<'tcx>(\n \n         let misc_cause = traits::ObligationCause::misc(span, hir_id);\n \n-        let _ = inh.register_infer_ok_obligations(\n-            infcx.instantiate_opaque_types(hir_id, param_env, opaque_ty, span),\n-        );\n-\n-        let opaque_type_map = infcx.inner.borrow().opaque_types.clone();\n-        for (OpaqueTypeKey { def_id, substs }, opaque_defn) in opaque_type_map {\n-            let hidden_type = tcx.type_of(def_id).subst(tcx, substs);\n-            trace!(?hidden_type);\n-            match infcx.at(&misc_cause, param_env).eq(opaque_defn.concrete_ty, hidden_type) {\n-                Ok(infer_ok) => inh.register_infer_ok_obligations(infer_ok),\n-                Err(ty_err) => {\n-                    tcx.sess.delay_span_bug(\n-                        span,\n-                        &format!(\n-                            \"could not check bounds on revealed type `{}`:\\n{}\",\n-                            hidden_type, ty_err,\n-                        ),\n-                    );\n-                }\n+        match infcx.at(&misc_cause, param_env).eq(opaque_ty, hidden_type) {\n+            Ok(infer_ok) => inh.register_infer_ok_obligations(infer_ok),\n+            Err(ty_err) => {\n+                tcx.sess.delay_span_bug(\n+                    span,\n+                    &format!(\"could not unify `{}` with revealed type:\\n{}\", hidden_type, ty_err,),\n+                );\n             }\n         }\n \n@@ -701,7 +683,7 @@ fn check_opaque_meets_bounds<'tcx>(\n \n         match origin {\n             // Checked when type checking the function containing them.\n-            hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => return,\n+            hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {}\n             // Can have different predicates to their defining use\n             hir::OpaqueTyOrigin::TyAlias => {\n                 // Finally, resolve all regions. This catches wily misuses of\n@@ -710,6 +692,9 @@ fn check_opaque_meets_bounds<'tcx>(\n                 fcx.regionck_item(hir_id, span, FxHashSet::default());\n             }\n         }\n+\n+        // Clean up after ourselves\n+        let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n     });\n }\n "}, {"sha": "2f5f804c56f78dee26659656d3f26753f83fe5ce", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 55, "deletions": 23, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -3,6 +3,7 @@\n use super::{check_fn, Expectation, FnCtxt, GeneratorTypes};\n \n use crate::astconv::AstConv;\n+use crate::rustc_middle::ty::subst::Subst;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n@@ -13,6 +14,7 @@ use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::source_map::Span;\n+use rustc_span::DUMMY_SP;\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::ArgKind;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n@@ -172,6 +174,29 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected_ty: Ty<'tcx>,\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n         match *expected_ty.kind() {\n+            ty::Opaque(def_id, substs) => {\n+                let bounds = self.tcx.explicit_item_bounds(def_id);\n+                let sig = bounds.iter().find_map(|(pred, span)| match pred.kind().skip_binder() {\n+                    ty::PredicateKind::Projection(proj_predicate) => self\n+                        .deduce_sig_from_projection(\n+                            Some(*span),\n+                            pred.kind().rebind(proj_predicate.subst(self.tcx, substs)),\n+                        ),\n+                    _ => None,\n+                });\n+\n+                let kind = bounds\n+                    .iter()\n+                    .filter_map(|(pred, _)| match pred.kind().skip_binder() {\n+                        ty::PredicateKind::Trait(tp) => {\n+                            self.tcx.fn_trait_kind_from_lang_item(tp.def_id())\n+                        }\n+                        _ => None,\n+                    })\n+                    .fold(None, |best, cur| Some(best.map_or(cur, |best| cmp::min(best, cur))));\n+                trace!(?sig, ?kind);\n+                (sig, kind)\n+            }\n             ty::Dynamic(ref object_type, ..) => {\n                 let sig = object_type.projection_bounds().find_map(|pb| {\n                     let pb = pb.with_self_ty(self.tcx, self.tcx.types.trait_object_dummy_self);\n@@ -197,10 +222,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n         let expected_sig =\n             self.obligations_for_self_ty(expected_vid).find_map(|(_, obligation)| {\n-                debug!(\n-                    \"deduce_expectations_from_obligations: obligation.predicate={:?}\",\n-                    obligation.predicate\n-                );\n+                debug!(?obligation.predicate);\n \n                 let bound_predicate = obligation.predicate.kind();\n                 if let ty::PredicateKind::Projection(proj_predicate) =\n@@ -235,22 +257,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// The `cause_span` should be the span that caused us to\n     /// have this expected signature, or `None` if we can't readily\n     /// know that.\n+    #[instrument(level = \"debug\", skip(self, cause_span))]\n     fn deduce_sig_from_projection(\n         &self,\n         cause_span: Option<Span>,\n         projection: ty::PolyProjectionPredicate<'tcx>,\n     ) -> Option<ExpectedSig<'tcx>> {\n         let tcx = self.tcx;\n \n-        debug!(\"deduce_sig_from_projection({:?})\", projection);\n-\n         let trait_def_id = projection.trait_def_id(tcx);\n \n         let is_fn = tcx.fn_trait_kind_from_lang_item(trait_def_id).is_some();\n         let gen_trait = tcx.require_lang_item(LangItem::Generator, cause_span);\n         let is_gen = gen_trait == trait_def_id;\n         if !is_fn && !is_gen {\n-            debug!(\"deduce_sig_from_projection: not fn or generator\");\n+            debug!(\"not fn or generator\");\n             return None;\n         }\n \n@@ -259,15 +280,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // associated item and not yield.\n             let return_assoc_item = self.tcx.associated_item_def_ids(gen_trait)[1];\n             if return_assoc_item != projection.projection_def_id() {\n-                debug!(\"deduce_sig_from_projection: not return assoc item of generator\");\n+                debug!(\"not return assoc item of generator\");\n                 return None;\n             }\n         }\n \n         let input_tys = if is_fn {\n             let arg_param_ty = projection.skip_binder().projection_ty.substs.type_at(1);\n             let arg_param_ty = self.resolve_vars_if_possible(arg_param_ty);\n-            debug!(\"deduce_sig_from_projection: arg_param_ty={:?}\", arg_param_ty);\n+            debug!(?arg_param_ty);\n \n             match arg_param_ty.kind() {\n                 &ty::Tuple(tys) => tys,\n@@ -282,7 +303,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Since this is a return parameter type it is safe to unwrap.\n         let ret_param_ty = projection.skip_binder().term.ty().unwrap();\n         let ret_param_ty = self.resolve_vars_if_possible(ret_param_ty);\n-        debug!(\"deduce_sig_from_projection: ret_param_ty={:?}\", ret_param_ty);\n+        debug!(?ret_param_ty);\n \n         let sig = projection.rebind(self.tcx.mk_fn_sig(\n             input_tys.iter(),\n@@ -291,7 +312,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             hir::Unsafety::Normal,\n             Abi::Rust,\n         ));\n-        debug!(\"deduce_sig_from_projection: sig={:?}\", sig);\n+        debug!(?sig);\n \n         Some(ExpectedSig { cause_span, sig })\n     }\n@@ -401,9 +422,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // in this binder we are creating.\n         assert!(!expected_sig.sig.skip_binder().has_vars_bound_above(ty::INNERMOST));\n         let bound_sig = expected_sig.sig.map_bound(|sig| {\n+            let output = self.hide_parent_opaque_types(\n+                sig.output(),\n+                expected_sig.cause_span.unwrap_or(DUMMY_SP),\n+                body.id().hir_id,\n+            );\n             self.tcx.mk_fn_sig(\n                 sig.inputs().iter().cloned(),\n-                sig.output(),\n+                output,\n                 sig.c_variadic,\n                 hir::Unsafety::Normal,\n                 Abi::RustCall,\n@@ -590,6 +616,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 _ => astconv.ty_infer(None, decl.output.span()),\n             },\n         };\n+        let supplied_return =\n+            self.hide_parent_opaque_types(supplied_return, decl.output.span(), body.id().hir_id);\n \n         let result = ty::Binder::bind_with_vars(\n             self.tcx.mk_fn_sig(\n@@ -610,45 +638,49 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         result\n     }\n \n+    fn hide_parent_opaque_types(&self, ty: Ty<'tcx>, span: Span, body_id: hir::HirId) -> Ty<'tcx> {\n+        let InferOk { value, obligations } =\n+            self.replace_opaque_types_with_inference_vars(ty, body_id, span, self.param_env);\n+        self.register_predicates(obligations);\n+        value\n+    }\n+\n     /// Invoked when we are translating the generator that results\n     /// from desugaring an `async fn`. Returns the \"sugared\" return\n     /// type of the `async fn` -- that is, the return type that the\n     /// user specified. The \"desugared\" return type is an `impl\n     /// Future<Output = T>`, so we do this by searching through the\n     /// obligations to extract the `T`.\n+    #[instrument(skip(self), level = \"debug\")]\n     fn deduce_future_output_from_obligations(&self, expr_def_id: DefId) -> Option<Ty<'tcx>> {\n-        debug!(\"deduce_future_output_from_obligations(expr_def_id={:?})\", expr_def_id);\n-\n         let ret_coercion = self.ret_coercion.as_ref().unwrap_or_else(|| {\n             span_bug!(self.tcx.def_span(expr_def_id), \"async fn generator outside of a fn\")\n         });\n \n-        // In practice, the return type of the surrounding function is\n-        // always a (not yet resolved) inference variable, because it\n-        // is the hidden type for an `impl Trait` that we are going to\n-        // be inferring.\n         let ret_ty = ret_coercion.borrow().expected_ty();\n         let ret_ty = self.inh.infcx.shallow_resolve(ret_ty);\n-        let ret_vid = match *ret_ty.kind() {\n-            ty::Infer(ty::TyVar(ret_vid)) => ret_vid,\n+        let (def_id, substs) = match *ret_ty.kind() {\n+            ty::Opaque(def_id, substs) => (def_id, substs),\n             ty::Error(_) => return None,\n             _ => span_bug!(\n                 self.tcx.def_span(expr_def_id),\n                 \"async fn generator return type not an inference variable\"\n             ),\n         };\n \n+        let item_bounds = self.tcx.explicit_item_bounds(def_id);\n+\n         // Search for a pending obligation like\n         //\n         // `<R as Future>::Output = T`\n         //\n         // where R is the return type we are expecting. This type `T`\n         // will be our output.\n-        let output_ty = self.obligations_for_self_ty(ret_vid).find_map(|(_, obligation)| {\n-            let bound_predicate = obligation.predicate.kind();\n+        let output_ty = item_bounds.iter().find_map(|&(predicate, span)| {\n+            let bound_predicate = predicate.subst(self.tcx, substs).kind();\n             if let ty::PredicateKind::Projection(proj_predicate) = bound_predicate.skip_binder() {\n                 self.deduce_future_output_from_projection(\n-                    obligation.cause.span,\n+                    span,\n                     bound_predicate.rebind(proj_predicate),\n                 )\n             } else {"}, {"sha": "2f973a54f88a7b621ff734ba5257df1c64b4e62f", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1272,7 +1272,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n \n     /// Returns the current \"merged type\", representing our best-guess\n     /// at the LUB of the expressions we've seen so far (if any). This\n-    /// isn't *final* until you call `self.final()`, which will return\n+    /// isn't *final* until you call `self.complete()`, which will return\n     /// the merged type.\n     pub fn merged_ty(&self) -> Ty<'tcx> {\n         self.final_ty.unwrap_or(self.expected_ty)"}, {"sha": "81cebaef3aa9283f240a140b9d5e92e87ecb7d23", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -965,8 +965,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n             let else_diverges = self.diverges.get();\n \n-            let opt_suggest_box_span =\n-                self.opt_suggest_box_span(else_expr.span, else_ty, orig_expected);\n+            let opt_suggest_box_span = self.opt_suggest_box_span(else_ty, orig_expected);\n             let if_cause =\n                 self.if_cause(sp, then_expr, else_expr, then_ty, else_ty, opt_suggest_box_span);\n "}, {"sha": "85132317824076160bf8b538e3d2f0ab582625fc", "filename": "compiler/rustc_typeck/src/check/fallback.rs", "status": "modified", "additions": 1, "deletions": 64, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -24,7 +24,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             self.fulfillment_cx.borrow_mut().pending_obligations()\n         );\n \n-        // Check if we have any unsolved varibales. If not, no need for fallback.\n+        // Check if we have any unsolved variables. If not, no need for fallback.\n         let unsolved_variables = self.unsolved_variables();\n         if unsolved_variables.is_empty() {\n             return false;\n@@ -66,16 +66,6 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         // refer to opaque types.\n         self.select_obligations_where_possible(fallback_has_occurred, |_| {});\n \n-        // We now run fallback again, but this time we allow it to replace\n-        // unconstrained opaque type variables, in addition to performing\n-        // other kinds of fallback.\n-        for ty in &self.unsolved_variables() {\n-            fallback_has_occurred |= self.fallback_opaque_type_vars(*ty);\n-        }\n-\n-        // See if we can make any more progress.\n-        self.select_obligations_where_possible(fallback_has_occurred, |_| {});\n-\n         fallback_has_occurred\n     }\n \n@@ -136,59 +126,6 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         true\n     }\n \n-    /// Second round of fallback: Unconstrained type variables created\n-    /// from the instantiation of an opaque type fall back to the\n-    /// opaque type itself. This is a somewhat incomplete attempt to\n-    /// manage \"identity passthrough\" for `impl Trait` types.\n-    ///\n-    /// For example, in this code:\n-    ///\n-    ///```\n-    /// type MyType = impl Copy;\n-    /// fn defining_use() -> MyType { true }\n-    /// fn other_use() -> MyType { defining_use() }\n-    /// ```\n-    ///\n-    /// `defining_use` will constrain the instantiated inference\n-    /// variable to `bool`, while `other_use` will constrain\n-    /// the instantiated inference variable to `MyType`.\n-    ///\n-    /// When we process opaque types during writeback, we\n-    /// will handle cases like `other_use`, and not count\n-    /// them as defining usages\n-    ///\n-    /// However, we also need to handle cases like this:\n-    ///\n-    /// ```rust\n-    /// pub type Foo = impl Copy;\n-    /// fn produce() -> Option<Foo> {\n-    ///     None\n-    ///  }\n-    ///  ```\n-    ///\n-    /// In the above snippet, the inference variable created by\n-    /// instantiating `Option<Foo>` will be completely unconstrained.\n-    /// We treat this as a non-defining use by making the inference\n-    /// variable fall back to the opaque type itself.\n-    fn fallback_opaque_type_vars(&self, ty: Ty<'tcx>) -> bool {\n-        let span = self\n-            .infcx\n-            .type_var_origin(ty)\n-            .map(|origin| origin.span)\n-            .unwrap_or(rustc_span::DUMMY_SP);\n-        let oty = self.inner.borrow().opaque_types_vars.get(&ty).copied();\n-        if let Some(opaque_ty) = oty {\n-            debug!(\n-                \"fallback_opaque_type_vars(ty={:?}): falling back to opaque type {:?}\",\n-                ty, opaque_ty\n-            );\n-            self.demand_eqtype(span, ty, opaque_ty);\n-            true\n-        } else {\n-            return false;\n-        }\n-    }\n-\n     /// The \"diverging fallback\" system is rather complicated. This is\n     /// a result of our need to balance 'do the right thing' with\n     /// backwards compatibility."}, {"sha": "bb3bfbb7dd11a13d9ee84699daf15e3990f08c35", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -372,23 +372,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         (result, spans)\n     }\n \n-    /// Replaces the opaque types from the given value with type variables,\n-    /// and records the `OpaqueTypeMap` for later use during writeback. See\n-    /// `InferCtxt::instantiate_opaque_types` for more details.\n-    #[instrument(skip(self, value_span), level = \"debug\")]\n-    pub(in super::super) fn instantiate_opaque_types_from_value<T: TypeFoldable<'tcx>>(\n-        &self,\n-        value: T,\n-        value_span: Span,\n-    ) -> T {\n-        self.register_infer_ok_obligations(self.instantiate_opaque_types(\n-            self.body_id,\n-            self.param_env,\n-            value,\n-            value_span,\n-        ))\n-    }\n-\n     /// Convenience method which tracks extra diagnostic information for normalization\n     /// that occurs as a result of WF checking. The `hir_id` is the `HirId` of the hir item\n     /// whose type is being wf-checked - this is used to construct a more precise span if\n@@ -775,6 +758,34 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Vec<Ty<'tcx>> {\n         let formal_ret = self.resolve_vars_with_obligations(formal_ret);\n         let Some(ret_ty) = expected_ret.only_has_type(self) else { return Vec::new() };\n+\n+        // HACK(oli-obk): This is a hack to keep RPIT and TAIT in sync wrt their behaviour.\n+        // Without it, the inference\n+        // variable will get instantiated with the opaque type. The inference variable often\n+        // has various helpful obligations registered for it that help closures figure out their\n+        // signature. If we infer the inference var to the opaque type, the closure won't be able\n+        // to find those obligations anymore, and it can't necessarily find them from the opaque\n+        // type itself. We could be more powerful with inference if we *combined* the obligations\n+        // so that we got both the obligations from the opaque type and the ones from the inference\n+        // variable. That will accept more code than we do right now, so we need to carefully consider\n+        // the implications.\n+        // Note: this check is pessimistic, as the inference type could be matched with something other\n+        // than the opaque type, but then we need a new `TypeRelation` just for this specific case and\n+        // can't re-use `sup` below.\n+        // See src/test/ui/impl-trait/hidden-type-is-opaque.rs and\n+        // src/test/ui/impl-trait/hidden-type-is-opaque-2.rs for examples that hit this path.\n+        if formal_ret.has_infer_types() {\n+            for ty in ret_ty.walk() {\n+                if let ty::subst::GenericArgKind::Type(ty) = ty.unpack() {\n+                    if let ty::Opaque(def_id, _) = *ty.kind() {\n+                        if self.infcx.opaque_type_origin(def_id, DUMMY_SP).is_some() {\n+                            return Vec::new();\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n         let expect_args = self\n             .fudge_inference_if_ok(|| {\n                 // Attempt to apply a subtyping relationship between the formal"}, {"sha": "6c55f8212940e720929d6db406bc8c696884a11e", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -57,8 +57,6 @@ pub struct FnCtxt<'a, 'tcx> {\n     /// any).\n     pub(super) ret_coercion: Option<RefCell<DynamicCoerceMany<'tcx>>>,\n \n-    pub(super) ret_coercion_impl_trait: Option<Ty<'tcx>>,\n-\n     pub(super) ret_type_span: Option<Span>,\n \n     /// Used exclusively to reduce cost of advanced evaluation used for\n@@ -130,7 +128,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             param_env,\n             err_count_on_creation: inh.tcx.sess.err_count(),\n             ret_coercion: None,\n-            ret_coercion_impl_trait: None,\n             ret_type_span: None,\n             in_tail_expr: false,\n             ret_coercion_span: Cell::new(None),"}, {"sha": "b775f24f8efd85f506b0b10cb01e720d0716873e", "filename": "compiler/rustc_typeck/src/check/inherited.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -95,6 +95,13 @@ impl<'tcx> InheritedBuilder<'tcx> {\n         let def_id = self.def_id;\n         self.infcx.enter(|infcx| f(Inherited::new(infcx, def_id)))\n     }\n+\n+    /// WF-checking doesn't need to recompute opaque types and can instead use\n+    /// the type_of query to get them from typeck.\n+    pub fn reveal_defining_opaque_types(mut self) -> Self {\n+        self.infcx = self.infcx.reveal_defining_opaque_types();\n+        self\n+    }\n }\n \n impl<'a, 'tcx> Inherited<'a, 'tcx> {\n@@ -119,8 +126,8 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     pub(super) fn register_predicate(&self, obligation: traits::PredicateObligation<'tcx>) {\n-        debug!(\"register_predicate({:?})\", obligation);\n         if obligation.has_escaping_bound_vars() {\n             span_bug!(obligation.cause.span, \"escaping bound vars in predicate {:?}\", obligation);\n         }"}, {"sha": "abdce9f5866386fa647970fede74c4cd5cbadbc5", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1476,6 +1476,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             TraitCandidate(trait_ref) => self.probe(|_| {\n                 let _ = self\n                     .at(&ObligationCause::dummy(), self.param_env)\n+                    .define_opaque_types(false)\n                     .sup(candidate.xform_self_ty, self_ty);\n                 match self.select_trait_candidate(trait_ref) {\n                     Ok(Some(traits::ImplSource::UserDefined(ref impl_data))) => {\n@@ -1505,6 +1506,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             // First check that the self type can be related.\n             let sub_obligations = match self\n                 .at(&ObligationCause::dummy(), self.param_env)\n+                .define_opaque_types(false)\n                 .sup(probe.xform_self_ty, self_ty)\n             {\n                 Ok(InferOk { obligations, value: () }) => obligations,\n@@ -1655,6 +1657,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     );\n                     if self\n                         .at(&ObligationCause::dummy(), self.param_env)\n+                        .define_opaque_types(false)\n                         .sup(return_ty, xform_ret_ty)\n                         .is_err()\n                     {"}, {"sha": "b6111793678aa84349b98ca7573fb09b24390a1a", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -343,6 +343,7 @@ fn diagnostic_only_typeck<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &ty::T\n     typeck_with_fallback(tcx, def_id, fallback)\n }\n \n+#[instrument(skip(tcx, fallback))]\n fn typeck_with_fallback<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: LocalDefId,"}, {"sha": "70bc46c5123b6d21a3b1c813e5175ad9faed9a81", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -335,11 +335,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     // Returns a list of `Ty`s for each upvar.\n     fn final_upvar_tys(&self, closure_id: DefId) -> Vec<Ty<'tcx>> {\n-        // Presently an unboxed closure type cannot \"escape\" out of a\n-        // function, so we will only encounter ones that originated in the\n-        // local crate or were inlined into it along with some function.\n-        // This may change if abstract return types of some sort are\n-        // implemented.\n         self.typeck_results\n             .borrow()\n             .closure_min_captures_flattened(closure_id)"}, {"sha": "250576bff048f8e40a8d2d873ebd2ee7fc50204e", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -968,7 +968,7 @@ fn for_item<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'_>) -> CheckWfFcxBuilder<\n \n fn for_id(tcx: TyCtxt<'_>, def_id: LocalDefId, span: Span) -> CheckWfFcxBuilder<'_> {\n     CheckWfFcxBuilder {\n-        inherited: Inherited::build(tcx, def_id),\n+        inherited: Inherited::build(tcx, def_id).reveal_defining_opaque_types(),\n         id: hir::HirId::make_owner(def_id),\n         span,\n         param_env: tcx.param_env(def_id),"}, {"sha": "ecbd1e463491b9f960c3c0f97214ba63662707d4", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 33, "deletions": 58, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -18,9 +18,9 @@ use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::{self, ClosureSizeProfileData, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n-use rustc_trait_selection::opaque_types::InferCtxtExt;\n \n use std::mem;\n+use std::ops::ControlFlow;\n \n ///////////////////////////////////////////////////////////////////////////\n // Entry point\n@@ -65,7 +65,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         wbcx.visit_closures();\n         wbcx.visit_liberated_fn_sigs();\n         wbcx.visit_fru_field_types();\n-        wbcx.visit_opaque_types(body.value.span);\n+        wbcx.visit_opaque_types();\n         wbcx.visit_coercion_casts();\n         wbcx.visit_user_provided_tys();\n         wbcx.visit_user_provided_sigs();\n@@ -497,64 +497,39 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             fcx_typeck_results.generator_interior_types.clone();\n     }\n \n-    #[instrument(skip(self, span), level = \"debug\")]\n-    fn visit_opaque_types(&mut self, span: Span) {\n-        let opaque_types = self.fcx.infcx.inner.borrow().opaque_types.clone();\n-        for (opaque_type_key, opaque_defn) in opaque_types {\n-            let hir_id =\n-                self.tcx().hir().local_def_id_to_hir_id(opaque_type_key.def_id.expect_local());\n-            let instantiated_ty = self.resolve(opaque_defn.concrete_ty, &hir_id);\n-\n-            debug_assert!(!instantiated_ty.has_escaping_bound_vars());\n-\n-            let opaque_type_key = self.fcx.fully_resolve(opaque_type_key).unwrap();\n-\n-            // Prevent:\n-            // * `fn foo<T>() -> Foo<T>`\n-            // * `fn foo<T: Bound + Other>() -> Foo<T>`\n-            // from being defining.\n-\n-            // Also replace all generic params with the ones from the opaque type\n-            // definition so that\n-            // ```rust\n-            // type Foo<T> = impl Baz + 'static;\n-            // fn foo<U>() -> Foo<U> { .. }\n-            // ```\n-            // figures out the concrete type with `U`, but the stored type is with `T`.\n-\n-            // FIXME: why are we calling this here? This seems too early, and duplicated.\n-            let definition_ty = self.fcx.infer_opaque_definition_from_instantiation(\n-                opaque_type_key,\n-                instantiated_ty,\n-                span,\n-            );\n-\n-            let mut skip_add = false;\n-\n-            if let ty::Opaque(definition_ty_def_id, _substs) = *definition_ty.kind() {\n-                if opaque_defn.origin == hir::OpaqueTyOrigin::TyAlias {\n-                    if opaque_type_key.def_id == definition_ty_def_id {\n-                        debug!(\n-                            \"skipping adding concrete definition for opaque type {:?} {:?}\",\n-                            opaque_defn, opaque_type_key.def_id\n-                        );\n-                        skip_add = true;\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn visit_opaque_types(&mut self) {\n+        let opaque_types =\n+            self.fcx.infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+        for (opaque_type_key, decl) in opaque_types {\n+            let hidden_type = match decl.origin {\n+                hir::OpaqueTyOrigin::FnReturn(_) | hir::OpaqueTyOrigin::AsyncFn(_) => {\n+                    let ty = self.resolve(decl.hidden_type.ty, &decl.hidden_type.span);\n+                    struct RecursionChecker {\n+                        def_id: DefId,\n+                    }\n+                    impl<'tcx> ty::TypeVisitor<'tcx> for RecursionChecker {\n+                        type BreakTy = ();\n+                        fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+                            if let ty::Opaque(def_id, _) = *t.kind() {\n+                                if def_id == self.def_id {\n+                                    return ControlFlow::Break(());\n+                                }\n+                            }\n+                            t.super_visit_with(self)\n+                        }\n                     }\n+                    if ty\n+                        .visit_with(&mut RecursionChecker { def_id: opaque_type_key.def_id })\n+                        .is_break()\n+                    {\n+                        return;\n+                    }\n+                    Some(ty)\n                 }\n-            }\n-\n-            if opaque_type_key.substs.needs_infer() {\n-                span_bug!(span, \"{:#?} has inference variables\", opaque_type_key.substs)\n-            }\n-\n-            // We only want to add an entry into `concrete_opaque_types`\n-            // if we actually found a defining usage of this opaque type.\n-            // Otherwise, we do nothing - we'll either find a defining usage\n-            // in some other location, or we'll end up emitting an error due\n-            // to the lack of defining usage\n-            if !skip_add {\n-                self.typeck_results.concrete_opaque_types.insert(opaque_type_key.def_id);\n-            }\n+                hir::OpaqueTyOrigin::TyAlias => None,\n+            };\n+            self.typeck_results.concrete_opaque_types.insert(opaque_type_key.def_id, hidden_type);\n         }\n     }\n "}, {"sha": "95d1b6a15f51ab8b8f81826dac40bf424071e49d", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 53, "deletions": 39, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -8,7 +8,7 @@ use rustc_hir::{HirId, Node};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::IntTypeExt;\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeFolder};\n+use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt, TypeFoldable, TypeFolder};\n use rustc_span::symbol::Ident;\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -358,29 +358,24 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                         .concrete_opaque_types\n                         .get_value_matching(|(key, _)| key.def_id == def_id.to_def_id())\n                         .copied()\n+                        .map(|concrete| concrete.ty)\n                         .unwrap_or_else(|| {\n-                            tcx.sess.delay_span_bug(\n-                                DUMMY_SP,\n-                                &format!(\n-                                    \"owner {:?} has no opaque type for {:?} in its typeck results\",\n-                                    owner, def_id,\n-                                ),\n-                            );\n-                            if let Some(_) =\n-                                tcx.typeck(owner).tainted_by_errors\n-                            {\n+                            let table = tcx.typeck(owner);\n+                            if let Some(_) = table.tainted_by_errors {\n                                 // Some error in the\n                                 // owner fn prevented us from populating\n                                 // the `concrete_opaque_types` table.\n                                 tcx.ty_error()\n                             } else {\n-                                // We failed to resolve the opaque type or it\n-                                // resolves to itself. Return the non-revealed\n-                                // type, which should result in E0720.\n-                                tcx.mk_opaque(\n-                                    def_id.to_def_id(),\n-                                    InternalSubsts::identity_for_item(tcx, def_id.to_def_id()),\n-                                )\n+                                table.concrete_opaque_types.get(&def_id.to_def_id()).copied().unwrap_or_else(|| {\n+                                    // We failed to resolve the opaque type or it\n+                                    // resolves to itself. We interpret this as the\n+                                    // no values of the hidden type ever being constructed,\n+                                    // so we can just make the hidden type be `!`.\n+                                    // For backwards compatibility reasons, we fall back to\n+                                    // `()` until we the diverging default is changed.\n+                                    Some(tcx.mk_diverging_default())\n+                                }).expect(\"RPIT always have a hidden type from typeck\")\n                             }\n                         });\n                     debug!(\"concrete_ty = {:?}\", concrete_ty);\n@@ -562,7 +557,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n         /// with the first type that we find, and then later types are\n         /// checked against it (we also carry the span of that first\n         /// type).\n-        found: Option<(Span, Ty<'tcx>)>,\n+        found: Option<ty::OpaqueHiddenType<'tcx>>,\n     }\n \n     impl ConstraintLocator<'_> {\n@@ -575,41 +570,55 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n             }\n             // Calling `mir_borrowck` can lead to cycle errors through\n             // const-checking, avoid calling it if we don't have to.\n-            if !self.tcx.typeck(def_id).concrete_opaque_types.contains(&self.def_id) {\n+            // ```rust\n+            // type Foo = impl Fn() -> usize; // when computing type for this\n+            // const fn bar() -> Foo {\n+            //     || 0usize\n+            // }\n+            // const BAZR: Foo = bar(); // we would mir-borrowck this, causing cycles\n+            // // because we again need to reveal `Foo` so we can check whether the\n+            // // constant does not contain interior mutability.\n+            // ```\n+            let tables = self.tcx.typeck(def_id);\n+            if let Some(_) = tables.tainted_by_errors {\n+                self.found = Some(ty::OpaqueHiddenType { span: DUMMY_SP, ty: self.tcx.ty_error() });\n+                return;\n+            }\n+            if tables.concrete_opaque_types.get(&self.def_id).is_none() {\n                 debug!(\"no constraints in typeck results\");\n                 return;\n             }\n             // Use borrowck to get the type with unerased regions.\n             let concrete_opaque_types = &self.tcx.mir_borrowck(def_id).concrete_opaque_types;\n             debug!(?concrete_opaque_types);\n-            for (opaque_type_key, concrete_type) in concrete_opaque_types {\n+            for &(opaque_type_key, concrete_type) in concrete_opaque_types {\n                 if opaque_type_key.def_id != self.def_id {\n                     // Ignore constraints for other opaque types.\n                     continue;\n                 }\n \n                 debug!(?concrete_type, ?opaque_type_key.substs, \"found constraint\");\n \n-                // FIXME(oli-obk): trace the actual span from inference to improve errors.\n-                let span = self.tcx.def_span(def_id);\n-\n-                if let Some((prev_span, prev_ty)) = self.found {\n-                    if *concrete_type != prev_ty && !(*concrete_type, prev_ty).references_error() {\n-                        debug!(?span);\n+                if let Some(prev) = self.found {\n+                    if concrete_type.ty != prev.ty && !(concrete_type, prev).references_error() {\n                         // Found different concrete types for the opaque type.\n                         let mut err = self.tcx.sess.struct_span_err(\n-                            span,\n+                            concrete_type.span,\n                             \"concrete type differs from previous defining opaque type use\",\n                         );\n                         err.span_label(\n-                            span,\n-                            format!(\"expected `{}`, got `{}`\", prev_ty, concrete_type),\n+                            concrete_type.span,\n+                            format!(\"expected `{}`, got `{}`\", prev.ty, concrete_type.ty),\n                         );\n-                        err.span_note(prev_span, \"previous use here\");\n+                        if prev.span == concrete_type.span {\n+                            err.span_label(prev.span, \"this expression supplies two conflicting concrete types for the same opaque type\");\n+                        } else {\n+                            err.span_note(prev.span, \"previous use here\");\n+                        }\n                         err.emit();\n                     }\n                 } else {\n-                    self.found = Some((span, *concrete_type));\n+                    self.found = Some(concrete_type);\n                 }\n             }\n         }\n@@ -629,23 +638,23 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n             intravisit::walk_expr(self, ex);\n         }\n         fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n-            debug!(\"find_existential_constraints: visiting {:?}\", it);\n+            trace!(?it.def_id);\n             // The opaque type itself or its children are not within its reveal scope.\n             if it.def_id.to_def_id() != self.def_id {\n                 self.check(it.def_id);\n                 intravisit::walk_item(self, it);\n             }\n         }\n         fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n-            debug!(\"find_existential_constraints: visiting {:?}\", it);\n+            trace!(?it.def_id);\n             // The opaque type itself or its children are not within its reveal scope.\n             if it.def_id.to_def_id() != self.def_id {\n                 self.check(it.def_id);\n                 intravisit::walk_impl_item(self, it);\n             }\n         }\n         fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n-            debug!(\"find_existential_constraints: visiting {:?}\", it);\n+            trace!(?it.def_id);\n             self.check(it.def_id);\n             intravisit::walk_trait_item(self, it);\n         }\n@@ -655,12 +664,12 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n     let scope = tcx.hir().get_defining_scope(hir_id);\n     let mut locator = ConstraintLocator { def_id: def_id.to_def_id(), tcx, found: None };\n \n-    debug!(\"find_opaque_ty_constraints: scope={:?}\", scope);\n+    debug!(?scope);\n \n     if scope == hir::CRATE_HIR_ID {\n         tcx.hir().walk_toplevel_module(&mut locator);\n     } else {\n-        debug!(\"find_opaque_ty_constraints: scope={:?}\", tcx.hir().get(scope));\n+        trace!(\"scope={:#?}\", tcx.hir().get(scope));\n         match tcx.hir().get(scope) {\n             // We explicitly call `visit_*` methods, instead of using `intravisit::walk_*` methods\n             // This allows our visitor to process the defining item itself, causing\n@@ -684,10 +693,15 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n     }\n \n     match locator.found {\n-        Some((_, ty)) => ty,\n+        Some(hidden) => hidden.ty,\n         None => {\n             let span = tcx.def_span(def_id);\n-            tcx.sess.span_err(span, \"could not find defining uses\");\n+            let name = tcx.item_name(tcx.parent(def_id.to_def_id()).unwrap());\n+            let label = format!(\n+                \"`{}` must be used in combination with a concrete type within the same module\",\n+                name\n+            );\n+            tcx.sess.struct_span_err(span, \"unconstrained opaque type\").note(&label).emit();\n             tcx.ty_error()\n         }\n     }"}, {"sha": "d9467e8fd6bc13f86c3c043f5d1f8bfdec1627df", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -147,6 +147,12 @@ fn main() {\n         cmd.arg(\"-Z\").arg(\"force-unstable-if-unmarked\");\n     }\n \n+    if let Ok(flags) = env::var(\"MAGIC_EXTRA_RUSTFLAGS\") {\n+        for flag in flags.split(' ') {\n+            cmd.arg(flag);\n+        }\n+    }\n+\n     let is_test = args.iter().any(|a| a == \"--test\");\n     if verbose > 2 {\n         let rust_env_vars ="}, {"sha": "31564a0cbd5c64a059d7d412301b2e493a9382ba", "filename": "src/test/incremental/hashes/function_interfaces.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -305,7 +305,7 @@ pub fn return_impl_trait() -> i32        {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg = \"cfail2\", except = \"hir_owner, hir_owner_nodes, typeck, fn_sig\")]\n+#[rustc_clean(cfg = \"cfail2\", except = \"hir_owner, hir_owner_nodes, typeck, fn_sig, optimized_mir\")]\n #[rustc_clean(cfg = \"cfail3\")]\n #[rustc_clean(cfg = \"cfail5\", except = \"hir_owner, hir_owner_nodes, typeck, fn_sig, optimized_mir\")]\n #[rustc_clean(cfg = \"cfail6\")]"}, {"sha": "67b97c21805e684cf757c1f0ef7d6d3af2e5ec37", "filename": "src/test/ui/associated-type-bounds/assoc-type-eq-with-dyn-atb-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -30,7 +30,7 @@ impl Thing for AssocNoCopy {\n     type Out = Box<dyn Bar<Assoc: Copy>>;\n \n     fn func() -> Self::Out {\n-        //~^ ERROR the trait bound `String: Copy` is not satisfied\n         Box::new(AssocNoCopy)\n+        //~^ ERROR the trait bound `String: Copy` is not satisfied\n     }\n }"}, {"sha": "f1dcd34066dbc6bfda6d3db2cf565f5029f53ef2", "filename": "src/test/ui/associated-type-bounds/assoc-type-eq-with-dyn-atb-fail.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,8 +1,10 @@\n error[E0277]: the trait bound `String: Copy` is not satisfied\n-  --> $DIR/assoc-type-eq-with-dyn-atb-fail.rs:32:18\n+  --> $DIR/assoc-type-eq-with-dyn-atb-fail.rs:33:9\n    |\n-LL |     fn func() -> Self::Out {\n-   |                  ^^^^^^^^^ the trait `Copy` is not implemented for `String`\n+LL |         Box::new(AssocNoCopy)\n+   |         ^^^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `String`\n+   |\n+   = note: required for the cast to the object type `dyn Bar<Assoc = <AssocNoCopy as Thing>::Out::{opaque#0}>`\n \n error: aborting due to previous error\n "}, {"sha": "ef0443034ec43117eaa604d484381e19d61bad08", "filename": "src/test/ui/associated-types/impl-trait-return-missing-constraint.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fassociated-types%2Fimpl-trait-return-missing-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fassociated-types%2Fimpl-trait-return-missing-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fimpl-trait-return-missing-constraint.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -23,7 +23,8 @@ fn bar() -> impl Bar {\n }\n \n fn baz() -> impl Bar<Item = i32> {\n-//~^ ERROR type mismatch resolving `<impl Bar as Foo>::Item == i32`\n+    //~^ ERROR type mismatch resolving `<impl Bar as Foo>::Item == i32`\n+    //~| ERROR type mismatch resolving `<impl Bar as Foo>::Item == i32`\n     bar()\n }\n "}, {"sha": "b7c49570ca40c737ca316b979457bb7423b35444", "filename": "src/test/ui/associated-types/impl-trait-return-missing-constraint.stderr", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fassociated-types%2Fimpl-trait-return-missing-constraint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fassociated-types%2Fimpl-trait-return-missing-constraint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fimpl-trait-return-missing-constraint.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -2,18 +2,43 @@ error[E0271]: type mismatch resolving `<impl Bar as Foo>::Item == i32`\n   --> $DIR/impl-trait-return-missing-constraint.rs:25:13\n    |\n LL | fn bar() -> impl Bar {\n-   |             -------- the found opaque type\n+   |             -------- the expected opaque type\n ...\n LL | fn baz() -> impl Bar<Item = i32> {\n-   |             ^^^^^^^^^^^^^^^^^^^^ expected `i32`, found associated type\n+   |             ^^^^^^^^^^^^^^^^^^^^ expected associated type, found `i32`\n    |\n-   = note:         expected type `i32`\n-           found associated type `<impl Bar as Foo>::Item`\n+   = note: expected associated type `<impl Bar as Foo>::Item`\n+                         found type `i32`\n+   = help: consider constraining the associated type `<impl Bar as Foo>::Item` to `i32` or calling a method that returns `<impl Bar as Foo>::Item`\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n help: consider constraining the associated type `<impl Bar as Foo>::Item` to `i32`\n    |\n LL | fn bar() -> impl Bar<Item = i32> {\n    |                     ++++++++++++\n \n-error: aborting due to previous error\n+error[E0271]: type mismatch resolving `<impl Bar as Foo>::Item == i32`\n+  --> $DIR/impl-trait-return-missing-constraint.rs:25:34\n+   |\n+LL |   fn bar() -> impl Bar {\n+   |               -------- the expected opaque type\n+...\n+LL |   fn baz() -> impl Bar<Item = i32> {\n+   |  __________________________________^\n+LL | |\n+LL | |\n+LL | |     bar()\n+LL | | }\n+   | |_^ expected associated type, found `i32`\n+   |\n+   = note: expected associated type `<impl Bar as Foo>::Item`\n+                         found type `i32`\n+   = help: consider constraining the associated type `<impl Bar as Foo>::Item` to `i32` or calling a method that returns `<impl Bar as Foo>::Item`\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n+help: consider constraining the associated type `<impl Bar as Foo>::Item` to `i32`\n+   |\n+LL | fn bar() -> impl Bar<Item = i32> {\n+   |                     ++++++++++++\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0271`."}, {"sha": "f21c811512416a34728af743624f6563dfe7def1", "filename": "src/test/ui/async-await/async-borrowck-escaping-block-error.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-block-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-block-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-block-error.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -8,10 +8,10 @@ LL |     Box::new(async { x } )\n    |                    may outlive borrowed value `x`\n    |\n note: async block is returned here\n-  --> $DIR/async-borrowck-escaping-block-error.rs:4:20\n+  --> $DIR/async-borrowck-escaping-block-error.rs:6:5\n    |\n-LL | fn test_boxed() -> Box<impl std::future::Future<Output = u32>> {\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     Box::new(async { x } )\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n help: to force the async block to take ownership of `x` (and any other referenced variables), use the `move` keyword\n    |\n LL |     Box::new(async move { x } )"}, {"sha": "019c56eb2fa3efc2329396f1fc13f90e20722d25", "filename": "src/test/ui/async-await/issue-70818.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -2,7 +2,7 @@\n \n use std::future::Future;\n fn foo<T: Send, U>(ty: T, ty1: U) -> impl Future<Output = (T, U)> + Send {\n-//~^ Error future cannot be sent between threads safely\n+    //~^ Error future cannot be sent between threads safely\n     async { (ty, ty1) }\n }\n "}, {"sha": "cdb141c0e3ea2802c7efd1d6a3a368d832b5e64e", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-one.nll.stderr", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.nll.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -14,12 +14,16 @@ LL | | }\n    = help: consider adding the following bound: `'a: 'b`\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ret-impl-trait-one.rs:16:65\n+  --> $DIR/ret-impl-trait-one.rs:16:80\n    |\n-LL | async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> {\n-   |                                    --                           ^^^^^^^^^^^^^^\n-   |                                    |\n-   |                                    hidden type `(&'a u8, &'b u8)` captures the lifetime `'b` as defined here\n+LL |   async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> {\n+   |  ____________________________________--__________________________________________^\n+   | |                                    |\n+   | |                                    hidden type `(&'a u8, &'b u8)` captures the lifetime `'b` as defined here\n+LL | |\n+LL | |     (a, b)\n+LL | | }\n+   | |_^\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |"}, {"sha": "2eb3a07059f7bf97d52310280da2d46bf2bbf14b", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-one.stderr", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,19 +1,26 @@\n error[E0623]: lifetime mismatch\n-  --> $DIR/ret-impl-trait-one.rs:10:65\n+  --> $DIR/ret-impl-trait-one.rs:10:85\n    |\n-LL | async fn async_ret_impl_trait3<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> + 'b {\n-   |                                                      ------     ^^^^^^^^^^^^^^^^^^^\n-   |                                                      |          |\n-   |                                                      |          ...but data from `a` is returned here\n-   |                                                      this parameter and the return type are declared with different lifetimes...\n+LL |   async fn async_ret_impl_trait3<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> + 'b {\n+   |  ______________________________________________________------_____-------------------_^\n+   | |                                                      |\n+   | |                                                      this parameter and the return type are declared with different lifetimes...\n+LL | |\n+LL | |     (a, b)\n+LL | | }\n+   | |_^ ...but data from `a` is returned here\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ret-impl-trait-one.rs:16:65\n+  --> $DIR/ret-impl-trait-one.rs:16:80\n    |\n-LL | async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> {\n-   |                                    --                           ^^^^^^^^^^^^^^\n-   |                                    |\n-   |                                    hidden type `(&'a u8, &'b u8)` captures the lifetime `'b` as defined here\n+LL |   async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> {\n+   |  ____________________________________--__________________________________________^\n+   | |                                    |\n+   | |                                    hidden type `(&'a u8, &'b u8)` captures the lifetime `'b` as defined here\n+LL | |\n+LL | |     (a, b)\n+LL | | }\n+   | |_^\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |"}, {"sha": "cfb0ef1b33a2b69de5936a9cd44e51ce7b9c84f5", "filename": "src/test/ui/async-await/no-const-async.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -3,3 +3,4 @@\n \n pub const async fn x() {}\n //~^ ERROR functions cannot be both `const` and `async`\n+//~| ERROR cycle detected"}, {"sha": "fd76c282f9629c475253bc0197f6cd699999489b", "filename": "src/test/ui/async-await/no-const-async.stderr", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -7,5 +7,36 @@ LL | pub const async fn x() {}\n    |     |     `async` because of this\n    |     `const` because of this\n \n-error: aborting due to previous error\n+error[E0391]: cycle detected when computing type of `x::{opaque#0}`\n+  --> $DIR/no-const-async.rs:4:24\n+   |\n+LL | pub const async fn x() {}\n+   |                        ^\n+   |\n+note: ...which requires borrow-checking `x`...\n+  --> $DIR/no-const-async.rs:4:1\n+   |\n+LL | pub const async fn x() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing `x`...\n+  --> $DIR/no-const-async.rs:4:1\n+   |\n+LL | pub const async fn x() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires const checking `x`...\n+  --> $DIR/no-const-async.rs:4:1\n+   |\n+LL | pub const async fn x() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which requires computing whether `impl core::future::future::Future<Output = ()>` is freeze...\n+   = note: ...which requires evaluating trait selection obligation `impl core::future::future::Future<Output = ()>: core::marker::Freeze`...\n+   = note: ...which again requires computing type of `x::{opaque#0}`, completing the cycle\n+note: cycle used when checking item types in top-level module\n+  --> $DIR/no-const-async.rs:4:1\n+   |\n+LL | pub const async fn x() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0391`."}, {"sha": "edc4cb8ac5df37153345b5a8453538bb330da90a", "filename": "src/test/ui/async-await/recursive-async-impl-trait-type.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fasync-await%2Frecursive-async-impl-trait-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fasync-await%2Frecursive-async-impl-trait-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Frecursive-async-impl-trait-type.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -2,7 +2,8 @@\n // Test that impl trait does not allow creating recursive types that are\n // otherwise forbidden when using `async` and `await`.\n \n-async fn recursive_async_function() -> () { //~ ERROR\n+async fn recursive_async_function() -> () {\n+    //~^ ERROR recursion in an `async fn` requires boxing\n     recursive_async_function().await;\n }\n "}, {"sha": "796f82e779c2b901b8b2eacbac795cb47de33da4", "filename": "src/test/ui/async-await/suggest-missing-await.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -21,8 +21,8 @@ async fn dummy() {}\n async fn suggest_await_in_async_fn_return() {\n     dummy()\n     //~^ ERROR mismatched types [E0308]\n-    //~| HELP consider using a semicolon here\n     //~| HELP consider `await`ing on the `Future`\n+    //~| HELP consider using a semicolon here\n     //~| SUGGESTION .await\n }\n "}, {"sha": "78d78f57955a8f28dd0e202b4edb65e9fc7f2f2f", "filename": "src/test/ui/chalkify/bugs/async.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fchalkify%2Fbugs%2Fasync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fchalkify%2Fbugs%2Fasync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fbugs%2Fasync.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -29,10 +29,13 @@ LL |     T: Generator<ResumeTy, Yield = ()>,\n    |                            ^^^^^^^^^^ required by this bound in `from_generator`\n \n error[E0280]: the requirement `<impl Future as Future>::Output == u32` is not satisfied\n-  --> $DIR/async.rs:7:25\n+  --> $DIR/async.rs:7:29\n    |\n-LL | async fn foo(x: u32) -> u32 {\n-   |                         ^^^\n+LL |   async fn foo(x: u32) -> u32 {\n+   |  _____________________________^\n+LL | |     x\n+LL | | }\n+   | |_^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "46379a3815a4db9b32188fdefbdc813025176b08", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/borrowck/borrowck-4.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fborrowck%2Fborrowck-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fborrowck%2Fborrowck-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fborrowck%2Fborrowck-4.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -8,10 +8,10 @@ LL |        println!(\"{:?}\", p);\n    |                         - `p` is borrowed here\n    |\n note: closure is returned here\n-  --> $DIR/borrowck-4.rs:8:14\n+  --> $DIR/borrowck-4.rs:15:5\n    |\n-LL | fn foo () -> impl FnMut()->() {\n-   |              ^^^^^^^^^^^^^^^^\n+LL |     c\n+   |     ^\n help: to force the closure to take ownership of `p` (and any other referenced variables), use the `move` keyword\n    |\n LL |     let mut c = move || {"}, {"sha": "b8488d83998e87ebcf45716ca7d3f27e945e8eaa", "filename": "src/test/ui/conservative_impl_trait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fconservative_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fconservative_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconservative_impl_trait.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -2,6 +2,7 @@\n \n fn will_ice(something: &u32) -> impl Iterator<Item = &u32> {\n     //~^ ERROR `()` is not an iterator\n+    //~| ERROR `()` is not an iterator\n }\n \n fn main() {}"}, {"sha": "2348f2f52978f159c15e1eb22db188853aa65153", "filename": "src/test/ui/conservative_impl_trait.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fconservative_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fconservative_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconservative_impl_trait.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -6,6 +6,18 @@ LL | fn will_ice(something: &u32) -> impl Iterator<Item = &u32> {\n    |\n    = help: the trait `Iterator` is not implemented for `()`\n \n-error: aborting due to previous error\n+error[E0277]: `()` is not an iterator\n+  --> $DIR/conservative_impl_trait.rs:3:60\n+   |\n+LL |   fn will_ice(something: &u32) -> impl Iterator<Item = &u32> {\n+   |  ____________________________________________________________^\n+LL | |\n+LL | |\n+LL | | }\n+   | |_^ `()` is not an iterator\n+   |\n+   = help: the trait `Iterator` is not implemented for `()`\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "24031aa1e61f365537dd7cfbaadb45492436797e", "filename": "src/test/ui/const-generics/defaults/rp_impl_trait_fail.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -5,6 +5,7 @@ impl<const N: u32> Trait for Uwu<N> {}\n \n fn rawr() -> impl Trait {\n     //~^ error: the trait bound `Uwu<10_u32, 12_u32>: Trait` is not satisfied\n+    //~| error: the trait bound `Uwu<10_u32, 12_u32>: Trait` is not satisfied\n     Uwu::<10, 12>\n }\n \n@@ -16,11 +17,13 @@ impl Traitor<1, 2> for u64 {}\n \n fn uwu<const N: u8>() -> impl Traitor<N> {\n     //~^ error: the trait bound `u32: Traitor<N, N>` is not satisfied\n+    //~| error: the trait bound `u32: Traitor<N, N>` is not satisfied\n     1_u32\n }\n \n fn owo() -> impl Traitor {\n     //~^ error: the trait bound `u64: Traitor<1_u8, 1_u8>` is not satisfied\n+    //~| error: the trait bound `u64: Traitor<1_u8, 1_u8>` is not satisfied\n     1_u64\n }\n "}, {"sha": "81cfcb35606617d6b04c134bfbbedc95b262e5da", "filename": "src/test/ui/const-generics/defaults/rp_impl_trait_fail.stderr", "status": "modified", "additions": 47, "deletions": 3, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -7,8 +7,22 @@ LL | fn rawr() -> impl Trait {\n    = help: the following implementations were found:\n              <Uwu<N> as Trait>\n \n+error[E0277]: the trait bound `Uwu<10_u32, 12_u32>: Trait` is not satisfied\n+  --> $DIR/rp_impl_trait_fail.rs:6:25\n+   |\n+LL |   fn rawr() -> impl Trait {\n+   |  _________________________^\n+LL | |\n+LL | |\n+LL | |     Uwu::<10, 12>\n+LL | | }\n+   | |_^ the trait `Trait` is not implemented for `Uwu<10_u32, 12_u32>`\n+   |\n+   = help: the following implementations were found:\n+             <Uwu<N> as Trait>\n+\n error[E0277]: the trait bound `u32: Traitor<N, N>` is not satisfied\n-  --> $DIR/rp_impl_trait_fail.rs:17:26\n+  --> $DIR/rp_impl_trait_fail.rs:18:26\n    |\n LL | fn uwu<const N: u8>() -> impl Traitor<N> {\n    |                          ^^^^^^^^^^^^^^^ the trait `Traitor<N, N>` is not implemented for `u32`\n@@ -17,8 +31,23 @@ LL | fn uwu<const N: u8>() -> impl Traitor<N> {\n              <u32 as Traitor<N, 2_u8>>\n              <u64 as Traitor<1_u8, 2_u8>>\n \n+error[E0277]: the trait bound `u32: Traitor<N, N>` is not satisfied\n+  --> $DIR/rp_impl_trait_fail.rs:18:42\n+   |\n+LL |   fn uwu<const N: u8>() -> impl Traitor<N> {\n+   |  __________________________________________^\n+LL | |\n+LL | |\n+LL | |     1_u32\n+LL | | }\n+   | |_^ the trait `Traitor<N, N>` is not implemented for `u32`\n+   |\n+   = help: the following implementations were found:\n+             <u32 as Traitor<N, 2_u8>>\n+             <u64 as Traitor<1_u8, 2_u8>>\n+\n error[E0277]: the trait bound `u64: Traitor<1_u8, 1_u8>` is not satisfied\n-  --> $DIR/rp_impl_trait_fail.rs:22:13\n+  --> $DIR/rp_impl_trait_fail.rs:24:13\n    |\n LL | fn owo() -> impl Traitor {\n    |             ^^^^^^^^^^^^ the trait `Traitor<1_u8, 1_u8>` is not implemented for `u64`\n@@ -27,6 +56,21 @@ LL | fn owo() -> impl Traitor {\n              <u64 as Traitor<1_u8, 2_u8>>\n              <u32 as Traitor<N, 2_u8>>\n \n-error: aborting due to 3 previous errors\n+error[E0277]: the trait bound `u64: Traitor<1_u8, 1_u8>` is not satisfied\n+  --> $DIR/rp_impl_trait_fail.rs:24:26\n+   |\n+LL |   fn owo() -> impl Traitor {\n+   |  __________________________^\n+LL | |\n+LL | |\n+LL | |     1_u64\n+LL | | }\n+   | |_^ the trait `Traitor<1_u8, 1_u8>` is not implemented for `u64`\n+   |\n+   = help: the following implementations were found:\n+             <u64 as Traitor<1_u8, 2_u8>>\n+             <u32 as Traitor<N, 2_u8>>\n+\n+error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "405d6e2a9f5607bb01d6b8e3bbd0c0bbf4e350f0", "filename": "src/test/ui/entry-point/imported_main_const_fn_item_type_forbidden.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fentry-point%2Fimported_main_const_fn_item_type_forbidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fentry-point%2Fimported_main_const_fn_item_type_forbidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fentry-point%2Fimported_main_const_fn_item_type_forbidden.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -3,11 +3,9 @@\n #![allow(incomplete_features)]\n pub mod foo {\n     type MainFn = impl Fn();\n-    //~^ ERROR could not find defining uses\n \n     fn bar() {}\n     pub const BAR: MainFn = bar;\n-    //~^ ERROR mismatched types [E0308]\n }\n \n use foo::BAR as main; //~ ERROR `main` function not found in crate"}, {"sha": "fabb6ffb02f77a94756431202410cb10d1c09f2c", "filename": "src/test/ui/entry-point/imported_main_const_fn_item_type_forbidden.stderr", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fentry-point%2Fimported_main_const_fn_item_type_forbidden.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fentry-point%2Fimported_main_const_fn_item_type_forbidden.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fentry-point%2Fimported_main_const_fn_item_type_forbidden.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,30 +1,11 @@\n error[E0601]: `main` function not found in crate `imported_main_const_fn_item_type_forbidden`\n-  --> $DIR/imported_main_const_fn_item_type_forbidden.rs:13:22\n+  --> $DIR/imported_main_const_fn_item_type_forbidden.rs:11:22\n    |\n LL | use foo::BAR as main;\n    |     ---------------- ^ consider adding a `main` function to `$DIR/imported_main_const_fn_item_type_forbidden.rs`\n    |     |\n    |     non-function item at `crate::main` is found\n \n-error[E0308]: mismatched types\n-  --> $DIR/imported_main_const_fn_item_type_forbidden.rs:9:29\n-   |\n-LL |     type MainFn = impl Fn();\n-   |                   --------- the expected opaque type\n-...\n-LL |     pub const BAR: MainFn = bar;\n-   |                             ^^^ expected opaque type, found fn item\n-   |\n-   = note: expected opaque type `impl Fn()`\n-                  found fn item `fn() {bar}`\n-\n-error: could not find defining uses\n-  --> $DIR/imported_main_const_fn_item_type_forbidden.rs:5:19\n-   |\n-LL |     type MainFn = impl Fn();\n-   |                   ^^^^^^^^^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0308, E0601.\n-For more information about an error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0601`."}, {"sha": "6dfd7f6840f1b8807daef10c35f9dc063d8b9c84", "filename": "src/test/ui/feature-gates/feature-gate-type_alias_impl_trait.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,13 +1,13 @@\n // ignore-compare-mode-chalk\n+// check-pass\n #![feature(type_alias_impl_trait)]\n use std::fmt::Debug;\n \n type Foo = impl Debug;\n-//~^ ERROR could not find defining uses\n \n struct Bar(Foo);\n fn define() -> Bar {\n-    Bar(42) //~ ERROR mismatched types\n+    Bar(42)\n }\n \n type Foo2 = impl Debug;\n@@ -17,21 +17,18 @@ fn define2() {\n }\n \n type Foo3 = impl Debug;\n-//~^ ERROR could not find defining uses\n \n fn define3(x: Foo3) {\n-    let y: i32 = x; //~ ERROR mismatched types\n+    let y: i32 = x;\n }\n fn define3_1() {\n-    define3(42) //~ ERROR mismatched types\n+    define3(42)\n }\n \n type Foo4 = impl Debug;\n-//~^ ERROR could not find defining uses\n \n fn define4() {\n     let y: Foo4 = 42;\n-    //~^ ERROR mismatched types [E0308]\n }\n \n fn main() {}"}, {"sha": "da3ddb1c50979f852528bc26518b9b028dd54c88", "filename": "src/test/ui/feature-gates/feature-gate-type_alias_impl_trait.stderr", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/1446d17b8f4bd3ff8dbfb129a7674165e06f9f4c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1446d17b8f4bd3ff8dbfb129a7674165e06f9f4c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.stderr?ref=1446d17b8f4bd3ff8dbfb129a7674165e06f9f4c", "patch": "@@ -1,73 +0,0 @@\n-error[E0308]: mismatched types\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:10:9\n-   |\n-LL | type Foo = impl Debug;\n-   |            ---------- the expected opaque type\n-...\n-LL |     Bar(42)\n-   |         ^^ expected opaque type, found integer\n-   |\n-   = note: expected opaque type `impl Debug`\n-                     found type `{integer}`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:23:18\n-   |\n-LL | type Foo3 = impl Debug;\n-   |             ---------- the found opaque type\n-...\n-LL |     let y: i32 = x;\n-   |            ---   ^ expected `i32`, found opaque type\n-   |            |\n-   |            expected due to this\n-   |\n-   = note:     expected type `i32`\n-           found opaque type `impl Debug`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:26:13\n-   |\n-LL | type Foo3 = impl Debug;\n-   |             ---------- the expected opaque type\n-...\n-LL |     define3(42)\n-   |             ^^ expected opaque type, found integer\n-   |\n-   = note: expected opaque type `impl Debug`\n-                     found type `{integer}`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:33:19\n-   |\n-LL | type Foo4 = impl Debug;\n-   |             ---------- the expected opaque type\n-...\n-LL |     let y: Foo4 = 42;\n-   |            ----   ^^ expected opaque type, found integer\n-   |            |\n-   |            expected due to this\n-   |\n-   = note: expected opaque type `impl Debug`\n-                     found type `{integer}`\n-\n-error: could not find defining uses\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:5:12\n-   |\n-LL | type Foo = impl Debug;\n-   |            ^^^^^^^^^^\n-\n-error: could not find defining uses\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:19:13\n-   |\n-LL | type Foo3 = impl Debug;\n-   |             ^^^^^^^^^^\n-\n-error: could not find defining uses\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:29:13\n-   |\n-LL | type Foo4 = impl Debug;\n-   |             ^^^^^^^^^^\n-\n-error: aborting due to 7 previous errors\n-\n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "f27956e45950a04b6c919b207282a782a6175b25", "filename": "src/test/ui/generator/issue-88653.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fgenerator%2Fissue-88653.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fgenerator%2Fissue-88653.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-88653.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -6,10 +6,14 @@\n use std::ops::Generator;\n \n fn foo(bar: bool) -> impl Generator<(bool,)> {\n-//~^ ERROR: type mismatch in generator arguments [E0631]\n-//~| NOTE: expected signature of `fn((bool,)) -> _`\n+    //~^ ERROR: type mismatch in generator arguments [E0631]\n+    //~| ERROR: type mismatch in generator arguments [E0631]\n+    //~| NOTE: expected signature of `fn((bool,)) -> _`\n+    //~| NOTE: expected signature of `fn((bool,)) -> _`\n+    //~| NOTE: in this expansion of desugaring of `impl Trait`\n     |bar| {\n-    //~^ NOTE: found signature of `fn(bool) -> _`\n+        //~^ NOTE: found signature of `fn(bool) -> _`\n+        //~| NOTE: found signature of `fn(bool) -> _`\n         if bar {\n             yield bar;\n         }"}, {"sha": "25357411ce1897cadea4a9333f1438aef4f91509", "filename": "src/test/ui/generator/issue-88653.stderr", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fgenerator%2Fissue-88653.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fgenerator%2Fissue-88653.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-88653.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -7,6 +7,22 @@ LL | fn foo(bar: bool) -> impl Generator<(bool,)> {\n LL |     |bar| {\n    |     ----- found signature of `fn(bool) -> _`\n \n-error: aborting due to previous error\n+error[E0631]: type mismatch in generator arguments\n+  --> $DIR/issue-88653.rs:8:46\n+   |\n+LL |   fn foo(bar: bool) -> impl Generator<(bool,)> {\n+   |  ______________________________________________^\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     |bar| {\n+   | |     ----- found signature of `fn(bool) -> _`\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^ expected signature of `fn((bool,)) -> _`\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0631`."}, {"sha": "77b830783c32a03242b7351ab24fcb20a74d197b", "filename": "src/test/ui/generator/type-mismatch-signature-deduction.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -2,7 +2,9 @@\n \n use std::ops::Generator;\n \n-fn foo() -> impl Generator<Return = i32> { //~ ERROR type mismatch\n+fn foo() -> impl Generator<Return = i32> {\n+    //~^ ERROR type mismatch\n+    //~| ERROR type mismatch\n     || {\n         if false {\n             return Ok(6);"}, {"sha": "6369e7ec4c784fb3248b4e47e1524bfbebe5459f", "filename": "src/test/ui/generator/type-mismatch-signature-deduction.stderr", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,27 +1,43 @@\n error[E0308]: mismatched types\n-  --> $DIR/type-mismatch-signature-deduction.rs:13:9\n+  --> $DIR/type-mismatch-signature-deduction.rs:15:9\n    |\n LL |         5\n    |         ^ expected enum `Result`, found integer\n    |\n    = note: expected type `Result<{integer}, _>`\n               found type `{integer}`\n note: return type inferred to be `Result<{integer}, _>` here\n-  --> $DIR/type-mismatch-signature-deduction.rs:8:20\n+  --> $DIR/type-mismatch-signature-deduction.rs:10:20\n    |\n LL |             return Ok(6);\n    |                    ^^^^^\n \n-error[E0271]: type mismatch resolving `<[generator@$DIR/type-mismatch-signature-deduction.rs:6:5: 14:6] as Generator>::Return == i32`\n+error[E0271]: type mismatch resolving `<[generator@$DIR/type-mismatch-signature-deduction.rs:8:5: 16:6] as Generator>::Return == i32`\n   --> $DIR/type-mismatch-signature-deduction.rs:5:13\n    |\n LL | fn foo() -> impl Generator<Return = i32> {\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found enum `Result`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Result`, found `i32`\n    |\n-   = note: expected type `i32`\n-              found enum `Result<{integer}, _>`\n+   = note: expected enum `Result<{integer}, _>`\n+              found type `i32`\n \n-error: aborting due to 2 previous errors\n+error[E0271]: type mismatch resolving `<[generator@$DIR/type-mismatch-signature-deduction.rs:8:5: 16:6] as Generator>::Return == i32`\n+  --> $DIR/type-mismatch-signature-deduction.rs:5:42\n+   |\n+LL |   fn foo() -> impl Generator<Return = i32> {\n+   |  __________________________________________^\n+LL | |\n+LL | |\n+LL | |     || {\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^ expected enum `Result`, found `i32`\n+   |\n+   = note: expected enum `Result<{integer}, _>`\n+              found type `i32`\n+\n+error: aborting due to 3 previous errors\n \n Some errors have detailed explanations: E0271, E0308.\n For more information about an error, try `rustc --explain E0271`."}, {"sha": "fbf1c8f95feca2736e02e413e4f03bd86fdaa42e", "filename": "src/test/ui/generic-associated-types/bugs/issue-86218.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fissue-86218.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fissue-86218.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fissue-86218.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,4 +1,4 @@\n-error[E0477]: the type `impl Stream<Item = i32>` does not fulfill the required lifetime\n+error[E0477]: the type `<() as Yay<&'a ()>>::InnerStream<'s>` does not fulfill the required lifetime\n   --> $DIR/issue-86218.rs:23:28\n    |\n LL |     type InnerStream<'s> = impl Stream<Item = i32> + 's;\n@@ -10,6 +10,14 @@ note: type must outlive the lifetime `'s` as defined here as required by this bi\n LL |     type InnerStream<'s> = impl Stream<Item = i32> + 's;\n    |                      ^^\n \n-error: aborting due to previous error\n+error: unconstrained opaque type\n+  --> $DIR/issue-86218.rs:23:28\n+   |\n+LL |     type InnerStream<'s> = impl Stream<Item = i32> + 's;\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `InnerStream` must be used in combination with a concrete type within the same module\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0477`."}, {"sha": "5cbadfacc1b60bf846ca44d56ea5f6e87ac19161", "filename": "src/test/ui/generic-associated-types/bugs/issue-89008.stderr", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fissue-89008.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fissue-89008.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fissue-89008.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,21 +1,19 @@\n-error[E0271]: type mismatch resolving `<impl Future as Future>::Output == impl Stream<Item = Repr>`\n-  --> $DIR/issue-89008.rs:39:43\n+error[E0271]: type mismatch resolving `<Empty<_> as Stream>::Item == Repr`\n+  --> $DIR/issue-89008.rs:40:9\n    |\n-LL |     type LineStream<'a, Repr> = impl Stream<Item = Repr>;\n-   |                                 ------------------------ the expected opaque type\n-...\n LL |     fn line_stream<'a, Repr>(&'a self) -> Self::LineStreamFut<'a, Repr> {\n-   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected opaque type, found struct `Empty`\n+   |                        ---- this type parameter\n+LL |         async {empty()}\n+   |         ^^^^^^^^^^^^^^^ type mismatch resolving `<Empty<_> as Stream>::Item == Repr`\n    |\n-   = note: expected opaque type `impl Stream<Item = Repr>`\n-                   found struct `Empty<_>`\n-\n-error: could not find defining uses\n-  --> $DIR/issue-89008.rs:35:33\n+note: expected this to be `()`\n+  --> $DIR/issue-89008.rs:18:17\n    |\n-LL |     type LineStream<'a, Repr> = impl Stream<Item = Repr>;\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     type Item = ();\n+   |                 ^^\n+   = note:   expected unit type `()`\n+           found type parameter `Repr`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0271`."}, {"sha": "c65f3fb2aa0a114aa6edc8a3c8dfd3869e8070e7", "filename": "src/test/ui/generic-associated-types/issue-87258_a.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_a.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -16,7 +16,8 @@ pub trait Trait2 {\n \n impl<'c, S: Trait2> Trait2 for &'c mut S {\n     type FooFuture<'a> = impl Trait1;\n-    fn foo<'a>() -> Self::FooFuture<'a> { //~ ERROR\n+    //~^ ERROR unconstrained opaque type\n+    fn foo<'a>() -> Self::FooFuture<'a> {\n         Struct(unimplemented!())\n     }\n }"}, {"sha": "db3a5c819cbf3d7d317f533e3ac33a30fd84f130", "filename": "src/test/ui/generic-associated-types/issue-87258_a.stderr", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_a.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,11 +1,10 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/issue-87258_a.rs:19:21\n+error: unconstrained opaque type\n+  --> $DIR/issue-87258_a.rs:18:26\n    |\n-LL |     fn foo<'a>() -> Self::FooFuture<'a> {\n-   |                     ^^^^^^^^^^^^^^^^^^^\n+LL |     type FooFuture<'a> = impl Trait1;\n+   |                          ^^^^^^^^^^^\n    |\n-   = note: hidden type `Struct<'_>` captures lifetime '_#7r\n+   = note: `FooFuture` must be used in combination with a concrete type within the same module\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0700`."}, {"sha": "f59e0d7665942f7cc68fe1df2b93c62b9b422e05", "filename": "src/test/ui/generic-associated-types/issue-87258_b.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_b.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -15,10 +15,11 @@ pub trait Trait2 {\n }\n \n type Helper<'xenon, 'yttrium, KABOOM: Trait2> = impl Trait1;\n+//~^ ERROR unconstrained opaque type\n \n impl<'c, S: Trait2> Trait2 for &'c mut S {\n     type FooFuture<'a> = Helper<'c, 'a, S>;\n-    fn foo<'a>() -> Self::FooFuture<'a> { //~ ERROR\n+    fn foo<'a>() -> Self::FooFuture<'a> {\n         Struct(unimplemented!())\n     }\n }"}, {"sha": "9faccc96124bc9648c915ce51078e78bdb48587b", "filename": "src/test/ui/generic-associated-types/issue-87258_b.stderr", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_b.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,11 +1,10 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/issue-87258_b.rs:21:21\n+error: unconstrained opaque type\n+  --> $DIR/issue-87258_b.rs:17:49\n    |\n-LL |     fn foo<'a>() -> Self::FooFuture<'a> {\n-   |                     ^^^^^^^^^^^^^^^^^^^\n+LL | type Helper<'xenon, 'yttrium, KABOOM: Trait2> = impl Trait1;\n+   |                                                 ^^^^^^^^^^^\n    |\n-   = note: hidden type `Struct<'_>` captures lifetime '_#7r\n+   = note: `Helper` must be used in combination with a concrete type within the same module\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0700`."}, {"sha": "e0796dfecbbcc04fb4d8649ee37d436c13b88b92", "filename": "src/test/ui/generic-associated-types/issue-88595.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88595.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88595.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88595.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -17,7 +17,6 @@ struct C;\n \n impl<'a> A<'a> for C {\n     type B<'b> = impl Clone;\n-    //~^ ERROR: could not find defining uses\n \n     fn a(&'a self) -> Self::B<'a> {} //~ ERROR: non-defining opaque type use in defining scope\n }"}, {"sha": "79d3479af8c8fa1955259547939754e08d31f528", "filename": "src/test/ui/generic-associated-types/issue-88595.stderr", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88595.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88595.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88595.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,8 +1,8 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/issue-88595.rs:22:23\n+  --> $DIR/issue-88595.rs:21:35\n    |\n LL |     fn a(&'a self) -> Self::B<'a> {}\n-   |                       ^^^^^^^^^^^\n+   |                                   ^^\n    |\n note: lifetime used multiple times\n   --> $DIR/issue-88595.rs:18:6\n@@ -12,11 +12,5 @@ LL | impl<'a> A<'a> for C {\n LL |     type B<'b> = impl Clone;\n    |            ^^\n \n-error: could not find defining uses\n-  --> $DIR/issue-88595.rs:19:18\n-   |\n-LL |     type B<'b> = impl Clone;\n-   |                  ^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "7a9d64d339feb1531a526092d0f2b53616c862e1", "filename": "src/test/ui/impl-trait/async_scope_creep.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fasync_scope_creep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fasync_scope_creep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fasync_scope_creep.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,28 @@\n+#![feature(type_alias_impl_trait)]\n+// edition:2021\n+// check-pass\n+\n+struct Pending {}\n+\n+struct CantOpen {}\n+\n+trait AsyncRead {}\n+\n+impl AsyncRead for i32 {}\n+\n+type PendingReader<'a> = impl AsyncRead + 'a;\n+\n+type OpeningReadFuture<'a> =\n+    impl std::future::Future<Output = Result<PendingReader<'a>, CantOpen>>;\n+\n+impl Pending {\n+    async fn read(&mut self) -> Result<impl AsyncRead + '_, CantOpen> {\n+        Ok(42)\n+    }\n+\n+    fn read_fut(&mut self) -> OpeningReadFuture<'_> {\n+        self.read()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "d2452abab02549987b5352dfcd8624a60d307108", "filename": "src/test/ui/impl-trait/auto-trait-leak.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -11,6 +11,7 @@ fn main() {\n // return type, which can't depend on the obligation.\n fn cycle1() -> impl Clone {\n     //~^ ERROR cycle detected\n+    //~| ERROR cycle detected\n     send(cycle2().clone());\n \n     Rc::new(Cell::new(5))"}, {"sha": "14db864f1c28af51ad3dcbf60085e9860f920818", "filename": "src/test/ui/impl-trait/auto-trait-leak.stderr", "status": "modified", "additions": 97, "deletions": 15, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -30,47 +30,129 @@ note: ...which requires building MIR for `cycle1`...\n LL | fn cycle1() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires type-checking `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:14:5\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires computing type of `cycle2::{opaque#0}`...\n+  --> $DIR/auto-trait-leak.rs:20:16\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   |                ^^^^^^^^^^\n+note: ...which requires borrow-checking `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:20:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:20:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing MIR for `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:20:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires unsafety-checking `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:20:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires building MIR for `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:20:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires type-checking `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:20:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which again requires computing type of `cycle1::{opaque#0}`, completing the cycle\n+note: cycle used when checking item types in top-level module\n+  --> $DIR/auto-trait-leak.rs:1:1\n+   |\n+LL | / use std::cell::Cell;\n+LL | | use std::rc::Rc;\n+LL | |\n+LL | | fn send<T: Send>(_: T) {}\n+...  |\n+LL | |     Rc::new(String::from(\"foo\"))\n+LL | | }\n+   | |_^\n+\n+error[E0391]: cycle detected when computing type of `cycle1::{opaque#0}`\n+  --> $DIR/auto-trait-leak.rs:12:16\n    |\n-LL |     send(cycle2().clone());\n-   |     ^^^^\n-   = note: ...which requires evaluating trait selection obligation `impl core::clone::Clone: core::marker::Send`...\n+LL | fn cycle1() -> impl Clone {\n+   |                ^^^^^^^^^^\n+   |\n+note: ...which requires borrow-checking `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing MIR for `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires unsafety-checking `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires building MIR for `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires type-checking `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires computing type of `cycle2::{opaque#0}`...\n-  --> $DIR/auto-trait-leak.rs:19:16\n+  --> $DIR/auto-trait-leak.rs:20:16\n    |\n LL | fn cycle2() -> impl Clone {\n    |                ^^^^^^^^^^\n note: ...which requires borrow-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n+  --> $DIR/auto-trait-leak.rs:20:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires processing `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n+  --> $DIR/auto-trait-leak.rs:20:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires processing MIR for `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n+  --> $DIR/auto-trait-leak.rs:20:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires unsafety-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n+  --> $DIR/auto-trait-leak.rs:20:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires building MIR for `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n+  --> $DIR/auto-trait-leak.rs:20:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires type-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:20:5\n+  --> $DIR/auto-trait-leak.rs:20:1\n    |\n-LL |     send(cycle1().clone());\n-   |     ^^^^\n-   = note: ...which requires evaluating trait selection obligation `impl core::clone::Clone: core::marker::Send`...\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which again requires computing type of `cycle1::{opaque#0}`, completing the cycle\n note: cycle used when checking item types in top-level module\n   --> $DIR/auto-trait-leak.rs:1:1\n@@ -84,6 +166,6 @@ LL | |     Rc::new(String::from(\"foo\"))\n LL | | }\n    | |_^\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0391`."}, {"sha": "35994e4a5ba3f5b7556ef82e9cbb6c0def9e12e6", "filename": "src/test/ui/impl-trait/auto-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -19,7 +19,7 @@ impl<T: Send> AnotherTrait for T {}\n // (We treat opaque types as \"foreign types\" that could grow more impls\n // in the future.)\n impl AnotherTrait for D<OpaqueType> {\n-    //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `D<impl OpaqueTrait>`\n+    //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`\n }\n \n fn main() {}"}, {"sha": "81009413c9a268f550e356fe32381bf0e3526a88", "filename": "src/test/ui/impl-trait/auto-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,11 +1,11 @@\n-error[E0119]: conflicting implementations of trait `AnotherTrait` for type `D<impl OpaqueTrait>`\n+error[E0119]: conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`\n   --> $DIR/auto-trait.rs:21:1\n    |\n LL | impl<T: Send> AnotherTrait for T {}\n    | -------------------------------- first implementation here\n ...\n LL | impl AnotherTrait for D<OpaqueType> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `D<impl OpaqueTrait>`\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `D<OpaqueType>`\n \n error: aborting due to previous error\n "}, {"sha": "5e4f4995447e14f8912cf6d8bb86395f77126e3b", "filename": "src/test/ui/impl-trait/autoderef.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fautoderef.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,19 @@\n+// check-pass\n+\n+use std::path::Path;\n+use std::ffi::OsStr;\n+use std::ops::Deref;\n+\n+fn frob(path: &str) -> impl Deref<Target = Path> + '_ {\n+    OsStr::new(path).as_ref()\n+}\n+\n+fn open_parent<'path>(_path: &'path Path) {\n+    todo!()\n+}\n+\n+fn main() {\n+    let old_path = frob(\"hello\");\n+\n+    open_parent(&old_path);\n+}"}, {"sha": "9f962fa9bbaf51fc1a54f738dd4f076ac8e15834", "filename": "src/test/ui/impl-trait/bound-normalization-fail.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -24,6 +24,7 @@ mod impl_trait {\n     /// `T::Assoc` can't be normalized any further here.\n     fn foo_fail<T: Trait>() -> impl FooLike<Output = T::Assoc> {\n         //~^ ERROR: type mismatch\n+        //~| ERROR: type mismatch\n         Foo(())\n     }\n }\n@@ -39,8 +40,9 @@ mod lifetimes {\n \n     /// Missing bound constraining `Assoc`, `T::Assoc` can't be normalized further.\n     fn foo2_fail<'a, T: Trait<'a>>() -> impl FooLike<Output = T::Assoc> {\n-        //~^ ERROR: type mismatch\n-        //~^^ ERROR `impl Trait` return type cannot contain a projection or `Self` that references lifetimes from a parent scope\n+        //~^ ERROR `impl Trait` return type cannot contain a projection or `Self` that references lifetimes from a parent scope\n+        //~| ERROR: type mismatch\n+        //~| ERROR: type mismatch\n         Foo(())\n     }\n }"}, {"sha": "0344f416eb7ff6859445f995cef66631a39e6bce", "filename": "src/test/ui/impl-trait/bound-normalization-fail.stderr", "status": "modified", "additions": 56, "deletions": 9, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -4,43 +4,90 @@ error[E0271]: type mismatch resolving `<Foo<()> as FooLike>::Output == <T as imp\n LL |     fn foo_fail<T: Trait>() -> impl FooLike<Output = T::Assoc> {\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type mismatch resolving `<Foo<()> as FooLike>::Output == <T as impl_trait::Trait>::Assoc`\n    |\n-note: expected this to be `<T as impl_trait::Trait>::Assoc`\n+note: expected this to be `()`\n   --> $DIR/bound-normalization-fail.rs:14:19\n    |\n LL |     type Output = T;\n    |                   ^\n-   = note: expected associated type `<T as impl_trait::Trait>::Assoc`\n-                    found unit type `()`\n+   = note:    expected unit type `()`\n+           found associated type `<T as impl_trait::Trait>::Assoc`\n+help: consider constraining the associated type `<T as impl_trait::Trait>::Assoc` to `()`\n+   |\n+LL |     fn foo_fail<T: Trait<Assoc = ()>>() -> impl FooLike<Output = T::Assoc> {\n+   |                         ++++++++++++\n+\n+error[E0271]: type mismatch resolving `<Foo<()> as FooLike>::Output == <T as impl_trait::Trait>::Assoc`\n+  --> $DIR/bound-normalization-fail.rs:25:64\n+   |\n+LL |       fn foo_fail<T: Trait>() -> impl FooLike<Output = T::Assoc> {\n+   |  ________________________________________________________________^\n+LL | |\n+LL | |\n+LL | |         Foo(())\n+LL | |     }\n+   | |_____^ type mismatch resolving `<Foo<()> as FooLike>::Output == <T as impl_trait::Trait>::Assoc`\n+   |\n+note: expected this to be `()`\n+  --> $DIR/bound-normalization-fail.rs:14:19\n+   |\n+LL |     type Output = T;\n+   |                   ^\n+   = note:    expected unit type `()`\n+           found associated type `<T as impl_trait::Trait>::Assoc`\n help: consider constraining the associated type `<T as impl_trait::Trait>::Assoc` to `()`\n    |\n LL |     fn foo_fail<T: Trait<Assoc = ()>>() -> impl FooLike<Output = T::Assoc> {\n    |                         ++++++++++++\n \n error[E0760]: `impl Trait` return type cannot contain a projection or `Self` that references lifetimes from a parent scope\n-  --> $DIR/bound-normalization-fail.rs:41:41\n+  --> $DIR/bound-normalization-fail.rs:42:41\n    |\n LL |     fn foo2_fail<'a, T: Trait<'a>>() -> impl FooLike<Output = T::Assoc> {\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0271]: type mismatch resolving `<Foo<()> as FooLike>::Output == <T as lifetimes::Trait<'static>>::Assoc`\n-  --> $DIR/bound-normalization-fail.rs:41:41\n+  --> $DIR/bound-normalization-fail.rs:42:41\n    |\n LL |     fn foo2_fail<'a, T: Trait<'a>>() -> impl FooLike<Output = T::Assoc> {\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type mismatch resolving `<Foo<()> as FooLike>::Output == <T as lifetimes::Trait<'static>>::Assoc`\n    |\n-note: expected this to be `<T as lifetimes::Trait<'static>>::Assoc`\n+note: expected this to be `()`\n+  --> $DIR/bound-normalization-fail.rs:14:19\n+   |\n+LL |     type Output = T;\n+   |                   ^\n+   = note:    expected unit type `()`\n+           found associated type `<T as lifetimes::Trait<'static>>::Assoc`\n+help: consider constraining the associated type `<T as lifetimes::Trait<'static>>::Assoc` to `()`\n+   |\n+LL |     fn foo2_fail<'a, T: Trait<'a, Assoc = ()>>() -> impl FooLike<Output = T::Assoc> {\n+   |                                 ++++++++++++\n+\n+error[E0271]: type mismatch resolving `<Foo<()> as FooLike>::Output == <T as lifetimes::Trait<'static>>::Assoc`\n+  --> $DIR/bound-normalization-fail.rs:42:73\n+   |\n+LL |       fn foo2_fail<'a, T: Trait<'a>>() -> impl FooLike<Output = T::Assoc> {\n+   |  _________________________________________________________________________^\n+LL | |\n+LL | |\n+LL | |\n+LL | |         Foo(())\n+LL | |     }\n+   | |_____^ type mismatch resolving `<Foo<()> as FooLike>::Output == <T as lifetimes::Trait<'static>>::Assoc`\n+   |\n+note: expected this to be `()`\n   --> $DIR/bound-normalization-fail.rs:14:19\n    |\n LL |     type Output = T;\n    |                   ^\n-   = note: expected associated type `<T as lifetimes::Trait<'static>>::Assoc`\n-                    found unit type `()`\n+   = note:    expected unit type `()`\n+           found associated type `<T as lifetimes::Trait<'static>>::Assoc`\n help: consider constraining the associated type `<T as lifetimes::Trait<'static>>::Assoc` to `()`\n    |\n LL |     fn foo2_fail<'a, T: Trait<'a, Assoc = ()>>() -> impl FooLike<Output = T::Assoc> {\n    |                                 ++++++++++++\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 5 previous errors\n \n Some errors have detailed explanations: E0271, E0760.\n For more information about an error, try `rustc --explain E0271`."}, {"sha": "c27b5ca9f6689856be63574890ccd9e99352f72c", "filename": "src/test/ui/impl-trait/cross-return-site-inference.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fcross-return-site-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fcross-return-site-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fcross-return-site-inference.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,45 @@\n+// edition:2021\n+\n+fn foo(b: bool) -> impl std::fmt::Debug {\n+    if b {\n+        return vec![42]\n+    }\n+    [].into_iter().collect()\n+}\n+\n+fn bar(b: bool) -> impl std::fmt::Debug {\n+    if b {\n+        return [].into_iter().collect()\n+    }\n+    vec![42]\n+}\n+\n+fn bak(b: bool) -> impl std::fmt::Debug {\n+    if b {\n+        return std::iter::empty().collect()\n+    }\n+    vec![42]\n+}\n+\n+fn baa(b: bool) -> impl std::fmt::Debug {\n+    if b {\n+        return [42].into_iter().collect()\n+    }\n+    vec![]\n+}\n+\n+fn muh() -> Result<(), impl std::fmt::Debug> {\n+    Err(\"whoops\")?; //~ ERROR `?` couldn't convert the error to `impl Debug`\n+    Ok(())\n+}\n+\n+fn muh2() -> Result<(), impl std::fmt::Debug> {\n+    return Err(From::from(\"foo\")); //~ ERROR the trait bound `impl Debug: From<&str>` is not satisfied\n+    Ok(())\n+}\n+\n+fn muh3() -> Result<(), impl std::fmt::Debug> {\n+    Err(From::from(\"foo\")) //~ ERROR the trait bound `impl Debug: From<&str>` is not satisfied\n+}\n+\n+fn main() {}"}, {"sha": "06afb938c5fad59d37a0cc9ec9b8be69e7b2d6c8", "filename": "src/test/ui/impl-trait/cross-return-site-inference.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fcross-return-site-inference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fcross-return-site-inference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fcross-return-site-inference.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,26 @@\n+error[E0277]: `?` couldn't convert the error to `impl Debug`\n+  --> $DIR/cross-return-site-inference.rs:32:18\n+   |\n+LL | fn muh() -> Result<(), impl std::fmt::Debug> {\n+   |             -------------------------------- expected `impl Debug` because of this\n+LL |     Err(\"whoops\")?;\n+   |                  ^ the trait `From<&str>` is not implemented for `impl Debug`\n+   |\n+   = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait\n+   = note: required because of the requirements on the impl of `FromResidual<Result<Infallible, &str>>` for `Result<(), impl Debug>`\n+\n+error[E0277]: the trait bound `impl Debug: From<&str>` is not satisfied\n+  --> $DIR/cross-return-site-inference.rs:37:16\n+   |\n+LL |     return Err(From::from(\"foo\"));\n+   |                ^^^^^^^^^^ the trait `From<&str>` is not implemented for `impl Debug`\n+\n+error[E0277]: the trait bound `impl Debug: From<&str>` is not satisfied\n+  --> $DIR/cross-return-site-inference.rs:42:9\n+   |\n+LL |     Err(From::from(\"foo\"))\n+   |         ^^^^^^^^^^ the trait `From<&str>` is not implemented for `impl Debug`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "211f7972dbca890e17e5af268e44acce89defd36", "filename": "src/test/ui/impl-trait/divergence.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fdivergence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fdivergence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdivergence.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+\n+fn foo() -> impl MyTrait {\n+    panic!();\n+    MyStruct\n+}\n+\n+struct MyStruct;\n+trait MyTrait {}\n+\n+impl MyTrait for MyStruct {}\n+\n+fn main() {}"}, {"sha": "750687e2322284fc055ad262e08b0edd6254ed10", "filename": "src/test/ui/impl-trait/does-not-live-long-enough.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fdoes-not-live-long-enough.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fdoes-not-live-long-enough.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdoes-not-live-long-enough.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -7,10 +7,10 @@ LL |         self.data.iter().filter(|s| s.starts_with(prefix)).map(|s| s.as_ref\n    |                                 may outlive borrowed value `prefix`\n    |\n note: closure is returned here\n-  --> $DIR/does-not-live-long-enough.rs:5:55\n+  --> $DIR/does-not-live-long-enough.rs:6:9\n    |\n-LL |     fn started_with<'a>(&'a self, prefix: &'a str) -> impl Iterator<Item=&'a str> {\n-   |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         self.data.iter().filter(|s| s.starts_with(prefix)).map(|s| s.as_ref())\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: to force the closure to take ownership of `prefix` (and any other referenced variables), use the `move` keyword\n    |\n LL |         self.data.iter().filter(move |s| s.starts_with(prefix)).map(|s| s.as_ref())"}, {"sha": "804ccbcc6c0ab3ef35073d41826aa76dd16c9670", "filename": "src/test/ui/impl-trait/equality.stderr", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -12,19 +12,10 @@ error[E0308]: mismatched types\n   --> $DIR/equality.rs:15:5\n    |\n LL | fn two(x: bool) -> impl Foo {\n-   |                    -------- expected because this return type...\n-LL |     if x {\n-LL |         return 1_i32;\n-   |                ----- ...is found to be `i32` here\n-LL |     }\n+   |                    -------- expected `_` because of return type\n+...\n LL |     0_u32\n    |     ^^^^^ expected `i32`, found `u32`\n-   |\n-   = note: to return `impl Trait`, all returned values must be of the same type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = help: if the trait `Foo` were object safe, you could return a boxed trait object\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: you could instead create a new `enum` with a variant for each returned type\n \n error[E0277]: cannot add `impl Foo` to `u32`\n   --> $DIR/equality.rs:24:11"}, {"sha": "1e6eb5bb355888c04904570ec6cd6232dd1814db", "filename": "src/test/ui/impl-trait/fallback.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ffallback.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,9 @@\n+// check-pass\n+\n+fn take_edge_counters(\n+    x: &mut Option<Vec<i32>>,\n+) -> Option<impl Iterator<Item = i32>> {\n+    x.take().map_or(None, |m| Some(m.into_iter()))\n+}\n+\n+fn main() {}"}, {"sha": "ae07c89276861140342005edf0fa90f54650ad45", "filename": "src/test/ui/impl-trait/hidden-lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -26,8 +26,8 @@ impl<T> Swap for Rc<RefCell<T>> {\n // Here we are hiding `'b` making the caller believe that `&'a mut &'s T` and\n // `&'a mut &'l T` are the same type.\n fn hide_ref<'a, 'b, T: 'static>(x: &'a mut &'b T) -> impl Swap + 'a {\n-    //~^ ERROR hidden type\n     x\n+    //~^ ERROR hidden type\n }\n \n fn dangle_ref() -> &'static [i32; 3] {\n@@ -43,8 +43,8 @@ fn dangle_ref() -> &'static [i32; 3] {\n // This is different to the previous example because the concrete return type\n // only has a single lifetime.\n fn hide_rc_refcell<'a, 'b: 'a, T: 'static>(x: Rc<RefCell<&'b T>>) -> impl Swap + 'a {\n-    //~^ ERROR hidden type\n     x\n+    //~^ ERROR hidden type\n }\n \n fn dangle_rc_refcell() -> &'static [i32; 3] {"}, {"sha": "97652f5462ef02487b72a2c6dc7588a4eed0f37d", "filename": "src/test/ui/impl-trait/hidden-lifetimes.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,23 +1,23 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/hidden-lifetimes.rs:28:54\n+  --> $DIR/hidden-lifetimes.rs:29:5\n    |\n LL | fn hide_ref<'a, 'b, T: 'static>(x: &'a mut &'b T) -> impl Swap + 'a {\n-   |                 --                                   ^^^^^^^^^^^^^^\n-   |                 |\n-   |                 hidden type `&'a mut &'b T` captures the lifetime `'b` as defined here\n+   |                 -- hidden type `&'a mut &'b T` captures the lifetime `'b` as defined here\n+LL |     x\n+   |     ^\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |\n LL | fn hide_ref<'a, 'b, T: 'static>(x: &'a mut &'b T) -> impl Swap + 'a + 'b {\n    |                                                                     ++++\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/hidden-lifetimes.rs:45:70\n+  --> $DIR/hidden-lifetimes.rs:46:5\n    |\n LL | fn hide_rc_refcell<'a, 'b: 'a, T: 'static>(x: Rc<RefCell<&'b T>>) -> impl Swap + 'a {\n-   |                        --                                            ^^^^^^^^^^^^^^\n-   |                        |\n-   |                        hidden type `Rc<RefCell<&'b T>>` captures the lifetime `'b` as defined here\n+   |                        -- hidden type `Rc<RefCell<&'b T>>` captures the lifetime `'b` as defined here\n+LL |     x\n+   |     ^\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |"}, {"sha": "7876add5aa6cb8392149ba922a1d1e280dc341f5", "filename": "src/test/ui/impl-trait/hidden-type-is-opaque-2.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-type-is-opaque-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-type-is-opaque-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-type-is-opaque-2.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,45 @@\n+// This doesn't work, because we don't flow information from opaque types\n+// into function arguments via the function's generic parameters\n+// FIXME(oli-obk): make `expected_inputs_for_expected_output` support this\n+\n+#![feature(type_alias_impl_trait)]\n+\n+fn reify_as() -> Thunk<impl FnOnce(Continuation) -> Continuation> {\n+    Thunk::new(|mut cont| { //~ ERROR type annotations needed\n+        cont.reify_as();\n+        cont\n+    })\n+}\n+\n+type Tait = impl FnOnce(Continuation) -> Continuation;\n+\n+fn reify_as_tait() -> Thunk<Tait> {\n+    Thunk::new(|mut cont| { //~ ERROR type annotations needed\n+        cont.reify_as();\n+        cont\n+    })\n+}\n+\n+#[must_use]\n+struct Thunk<F>(F);\n+\n+impl<F> Thunk<F> {\n+    fn new(f: F) -> Self\n+    where\n+        F: ContFn,\n+    {\n+        Thunk(f)\n+    }\n+}\n+\n+trait ContFn {}\n+\n+impl<F: FnOnce(Continuation) -> Continuation> ContFn for F {}\n+\n+struct Continuation;\n+\n+impl Continuation {\n+    fn reify_as(&mut self) {}\n+}\n+\n+fn main() {}"}, {"sha": "dcf1982312f294616b2f3198646ef20595b45c68", "filename": "src/test/ui/impl-trait/hidden-type-is-opaque-2.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-type-is-opaque-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-type-is-opaque-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-type-is-opaque-2.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,19 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/hidden-type-is-opaque-2.rs:8:17\n+   |\n+LL |     Thunk::new(|mut cont| {\n+   |                 ^^^^^^^^ consider giving this closure parameter a type\n+   |\n+   = note: type must be known at this point\n+\n+error[E0282]: type annotations needed\n+  --> $DIR/hidden-type-is-opaque-2.rs:17:17\n+   |\n+LL |     Thunk::new(|mut cont| {\n+   |                 ^^^^^^^^ consider giving this closure parameter a type\n+   |\n+   = note: type must be known at this point\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "72b4028d854f8daa7b66728331d3a0aa3dedd558", "filename": "src/test/ui/impl-trait/hidden-type-is-opaque.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-type-is-opaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-type-is-opaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-type-is-opaque.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,42 @@\n+// check-pass\n+#![feature(type_alias_impl_trait)]\n+\n+fn reify_as() -> Thunk<impl ContFn> {\n+    Thunk::new(|mut cont| {\n+        cont.reify_as();\n+        cont\n+    })\n+}\n+\n+type Tait = impl ContFn;\n+\n+fn reify_as_tait() -> Thunk<Tait> {\n+    Thunk::new(|mut cont| {\n+        cont.reify_as();\n+        cont\n+    })\n+}\n+\n+#[must_use]\n+struct Thunk<F>(F);\n+\n+impl<F> Thunk<F> {\n+    fn new(f: F) -> Self\n+    where\n+        F: FnOnce(Continuation) -> Continuation,\n+    {\n+        Thunk(f)\n+    }\n+}\n+\n+trait ContFn {}\n+\n+impl<F: FnOnce(Continuation) -> Continuation> ContFn for F {}\n+\n+struct Continuation;\n+\n+impl Continuation {\n+    fn reify_as(&mut self) {}\n+}\n+\n+fn main() {}"}, {"sha": "a75b9b43b3e8bae8b0544bd387dab33c1348d104", "filename": "src/test/ui/impl-trait/issue-55872-1.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -10,11 +10,10 @@ impl<S: Default> Bar for S {\n     type E = impl Copy;\n \n     fn foo<T: Default>() -> Self::E {\n-        //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-        //~| ERROR impl has stricter requirements than trait\n-        //~| ERROR the trait bound `S: Copy` is not satisfied in `(S, T)` [E0277]\n-        //~| ERROR the trait bound `T: Copy` is not satisfied in `(S, T)` [E0277]\n+        //~^ ERROR impl has stricter requirements than trait\n         (S::default(), T::default())\n+        //~^ ERROR the trait bound `S: Copy` is not satisfied in `(S, T)` [E0277]\n+        //~| ERROR the trait bound `T: Copy` is not satisfied in `(S, T)` [E0277]\n     }\n }\n "}, {"sha": "efc57da746132600900295431238ac4498bf995d", "filename": "src/test/ui/impl-trait/issue-55872-1.stderr", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -8,10 +8,10 @@ LL |     fn foo<T: Default>() -> Self::E {\n    |               ^^^^^^^ impl has extra requirement `T: Default`\n \n error[E0277]: the trait bound `S: Copy` is not satisfied in `(S, T)`\n-  --> $DIR/issue-55872-1.rs:12:29\n+  --> $DIR/issue-55872-1.rs:14:9\n    |\n-LL |     fn foo<T: Default>() -> Self::E {\n-   |                             ^^^^^^^ within `(S, T)`, the trait `Copy` is not implemented for `S`\n+LL |         (S::default(), T::default())\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ within `(S, T)`, the trait `Copy` is not implemented for `S`\n    |\n    = note: required because it appears within the type `(S, T)`\n help: consider further restricting this bound\n@@ -20,31 +20,18 @@ LL | impl<S: Default + std::marker::Copy> Bar for S {\n    |                 +++++++++++++++++++\n \n error[E0277]: the trait bound `T: Copy` is not satisfied in `(S, T)`\n-  --> $DIR/issue-55872-1.rs:12:29\n+  --> $DIR/issue-55872-1.rs:14:9\n    |\n-LL |     fn foo<T: Default>() -> Self::E {\n-   |                             ^^^^^^^ within `(S, T)`, the trait `Copy` is not implemented for `T`\n+LL |         (S::default(), T::default())\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ within `(S, T)`, the trait `Copy` is not implemented for `T`\n    |\n    = note: required because it appears within the type `(S, T)`\n help: consider further restricting this bound\n    |\n LL |     fn foo<T: Default + std::marker::Copy>() -> Self::E {\n    |                       +++++++++++++++++++\n \n-error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/issue-55872-1.rs:12:37\n-   |\n-LL |       fn foo<T: Default>() -> Self::E {\n-   |  _____________________________________^\n-LL | |\n-LL | |\n-LL | |\n-LL | |\n-LL | |         (S::default(), T::default())\n-LL | |     }\n-   | |_____^\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n \n Some errors have detailed explanations: E0276, E0277.\n For more information about an error, try `rustc --explain E0276`."}, {"sha": "4443d3c4d0df18a82d6a215a1c8c8fd81ac2c0d0", "filename": "src/test/ui/impl-trait/issue-55872-2.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -3,17 +3,16 @@\n #![feature(type_alias_impl_trait)]\n \n pub trait Bar {\n-    type E: Copy;\n+    type E: Send;\n \n     fn foo<T>() -> Self::E;\n }\n \n impl<S> Bar for S {\n-    type E = impl std::marker::Copy;\n+    type E = impl std::marker::Send;\n     fn foo<T>() -> Self::E {\n-        //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-        //~| ERROR the trait bound `impl Future: Copy` is not satisfied\n         async {}\n+        //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n     }\n }\n "}, {"sha": "11b8485c8bbfe225ebee91f190b09676cf2a934d", "filename": "src/test/ui/impl-trait/issue-55872-2.stderr", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,20 +1,8 @@\n-error[E0277]: the trait bound `impl Future: Copy` is not satisfied\n-  --> $DIR/issue-55872-2.rs:13:20\n-   |\n-LL |     fn foo<T>() -> Self::E {\n-   |                    ^^^^^^^ the trait `Copy` is not implemented for `impl Future`\n-\n error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/issue-55872-2.rs:13:28\n+  --> $DIR/issue-55872-2.rs:14:9\n    |\n-LL |       fn foo<T>() -> Self::E {\n-   |  ____________________________^\n-LL | |\n-LL | |\n-LL | |         async {}\n-LL | |     }\n-   | |_____^\n+LL |         async {}\n+   |         ^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "bc2d0b1d757e21f89b4b3cc6b063fc15b2a38be2", "filename": "src/test/ui/impl-trait/issue-55872-3.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-3.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,20 @@\n+// edition:2018\n+// ignore-compare-mode-chalk\n+\n+#![feature(type_alias_impl_trait)]\n+\n+pub trait Bar {\n+    type E: Copy;\n+\n+    fn foo<T>() -> Self::E;\n+}\n+\n+impl<S> Bar for S {\n+    type E = impl std::marker::Copy;\n+    fn foo<T>() -> Self::E {\n+        async {}\n+        //~^ ERROR the trait bound `impl Future: Copy` is not satisfied [E0277]\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "69a5c8d613577c1814678aaeb7fc8af6210fcc15", "filename": "src/test/ui/impl-trait/issue-55872-3.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-3.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,9 @@\n+error[E0277]: the trait bound `impl Future: Copy` is not satisfied\n+  --> $DIR/issue-55872-3.rs:15:9\n+   |\n+LL |         async {}\n+   |         ^^^^^^^^ the trait `Copy` is not implemented for `impl Future`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "c4e6f6436085451ea1f8e7a5af1e8e9f44fd0a2a", "filename": "src/test/ui/impl-trait/issue-55872.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -10,8 +10,8 @@ impl<S> Bar for S {\n     type E = impl Copy;\n \n     fn foo<T>() -> Self::E {\n-        //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n         || ()\n+        //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n     }\n }\n "}, {"sha": "cb370fbe1c41d33724a96b113a7f736043ab6250", "filename": "src/test/ui/impl-trait/issue-55872.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,12 +1,8 @@\n error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/issue-55872.rs:12:28\n+  --> $DIR/issue-55872.rs:13:9\n    |\n-LL |       fn foo<T>() -> Self::E {\n-   |  ____________________________^\n-LL | |\n-LL | |         || ()\n-LL | |     }\n-   | |_____^\n+LL |         || ()\n+   |         ^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "cf2c8b7e415408faac524e65a15070252072d169", "filename": "src/test/ui/impl-trait/issue-72911.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-72911.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-72911.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-72911.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -5,7 +5,7 @@ pub struct Lint {}\n impl Lint {}\n \n pub fn gather_all() -> impl Iterator<Item = Lint> {\n-    //~^ ERROR: cannot resolve opaque type\n+    //~^ ERROR `()` is not an iterator\n     lint_files().flat_map(|f| gather_from_file(&f))\n }\n "}, {"sha": "4a990286d966d2c0ad009200b3ce9dbcc496dff8", "filename": "src/test/ui/impl-trait/issue-72911.stderr", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-72911.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-72911.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-72911.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -10,25 +10,15 @@ error[E0433]: failed to resolve: use of undeclared crate or module `foo`\n LL | fn lint_files() -> impl Iterator<Item = foo::MissingItem> {\n    |                                         ^^^ use of undeclared crate or module `foo`\n \n-error[E0720]: cannot resolve opaque type\n+error[E0277]: `()` is not an iterator\n   --> $DIR/issue-72911.rs:7:24\n    |\n LL | pub fn gather_all() -> impl Iterator<Item = Lint> {\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^ recursive opaque type\n-LL |\n-LL |     lint_files().flat_map(|f| gather_from_file(&f))\n-   |     -----------------------------------------------\n-   |     |\n-   |     returning here with type `FlatMap<impl Iterator<Item = [type error]>, [type error], [closure@$DIR/issue-72911.rs:9:27: 9:51]>`\n-   |     returning here with type `FlatMap<impl Iterator<Item = [type error]>, [type error], [closure@$DIR/issue-72911.rs:9:27: 9:51]>`\n-...\n-LL | fn gather_from_file(dir_entry: &foo::MissingItem) -> impl Iterator<Item = Lint> {\n-   |                                                      -------------------------- returning this opaque type `FlatMap<impl Iterator<Item = [type error]>, [type error], [closure@$DIR/issue-72911.rs:9:27: 9:51]>`\n-...\n-LL | fn lint_files() -> impl Iterator<Item = foo::MissingItem> {\n-   |                    -------------------------------------- returning this opaque type `FlatMap<impl Iterator<Item = [type error]>, [type error], [closure@$DIR/issue-72911.rs:9:27: 9:51]>`\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^ `()` is not an iterator\n+   |\n+   = help: the trait `Iterator` is not implemented for `()`\n \n error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0433, E0720.\n-For more information about an error, try `rustc --explain E0433`.\n+Some errors have detailed explanations: E0277, E0433.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "a79bb6474d8ba5f7df5830979265f7b0ce953db5", "filename": "src/test/ui/impl-trait/issue-86465.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-86465.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-86465.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-86465.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -3,8 +3,8 @@\n type X<'a, 'b> = impl std::fmt::Debug;\n \n fn f<'t, 'u>(a: &'t u32, b: &'u u32) -> (X<'t, 'u>, X<'u, 't>) {\n-    //~^ ERROR concrete type differs from previous defining opaque type use\n     (a, a)\n+    //~^ ERROR concrete type differs from previous defining opaque type use\n }\n \n fn main() {}"}, {"sha": "90d6904ed616468583b6eae338ad399dcb87c3ca", "filename": "src/test/ui/impl-trait/issue-86465.stderr", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-86465.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-86465.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-86465.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,14 +1,11 @@\n error: concrete type differs from previous defining opaque type use\n-  --> $DIR/issue-86465.rs:5:1\n+  --> $DIR/issue-86465.rs:6:5\n    |\n-LL | fn f<'t, 'u>(a: &'t u32, b: &'u u32) -> (X<'t, 'u>, X<'u, 't>) {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&'a u32`, got `&'b u32`\n-   |\n-note: previous use here\n-  --> $DIR/issue-86465.rs:5:1\n-   |\n-LL | fn f<'t, 'u>(a: &'t u32, b: &'u u32) -> (X<'t, 'u>, X<'u, 't>) {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     (a, a)\n+   |     ^^^^^^\n+   |     |\n+   |     expected `&'a u32`, got `&'b u32`\n+   |     this expression supplies two conflicting concrete types for the same opaque type\n \n error: aborting due to previous error\n "}, {"sha": "a70166e03a7b1219622f010572fccba4643beb85", "filename": "src/test/ui/impl-trait/issues/issue-54895.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-54895.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-54895.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-54895.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,23 @@\n+// check-pass\n+\n+trait Trait<'a> {\n+    type Out;\n+    fn call(&'a self) -> Self::Out;\n+}\n+\n+struct X(());\n+\n+impl<'a> Trait<'a> for X {\n+    type Out = ();\n+    fn call(&'a self) -> Self::Out {\n+        ()\n+    }\n+}\n+\n+fn f() -> impl for<'a> Trait<'a, Out = impl Sized + 'a> {\n+    X(())\n+}\n+\n+fn main() {\n+    let _ = f();\n+}"}, {"sha": "041bd0e3855ec29754b839a769f28696fe856e74", "filename": "src/test/ui/impl-trait/issues/issue-62742.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-62742.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-62742.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-62742.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,32 @@\n+use std::marker::PhantomData;\n+\n+fn _alias_check() {\n+    WrongImpl::foo(0i32);\n+    //~^ ERROR the trait bound `RawImpl<_>: Raw<_>` is not satisfied\n+    WrongImpl::<()>::foo(0i32);\n+    //~^ ERROR the trait bound `RawImpl<()>: Raw<()>` is not satisfied\n+    //~| ERROR trait bounds were not satisfied\n+    CorrectImpl::foo(0i32);\n+}\n+\n+pub trait Raw<T: ?Sized> {\n+    type Value;\n+}\n+\n+pub type WrongImpl<T> = SafeImpl<T, RawImpl<T>>;\n+\n+pub type CorrectImpl<T> = SafeImpl<[T], RawImpl<T>>;\n+\n+pub struct RawImpl<T>(PhantomData<T>);\n+\n+impl<T> Raw<[T]> for RawImpl<T> {\n+    type Value = T;\n+}\n+\n+pub struct SafeImpl<T: ?Sized, A: Raw<T>>(PhantomData<(A, T)>);\n+\n+impl<T: ?Sized, A: Raw<T>> SafeImpl<T, A> {\n+    pub fn foo(value: A::Value) {}\n+}\n+\n+fn main() {}"}, {"sha": "28068b7548ce59e4e04eb89e63a0db1df305f3e3", "filename": "src/test/ui/impl-trait/issues/issue-62742.stderr", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-62742.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-62742.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-62742.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,54 @@\n+error[E0277]: the trait bound `RawImpl<_>: Raw<_>` is not satisfied\n+  --> $DIR/issue-62742.rs:4:5\n+   |\n+LL |     WrongImpl::foo(0i32);\n+   |     ^^^^^^^^^ the trait `Raw<_>` is not implemented for `RawImpl<_>`\n+   |\n+   = help: the following implementations were found:\n+             <RawImpl<T> as Raw<[T]>>\n+note: required by a bound in `SafeImpl`\n+  --> $DIR/issue-62742.rs:26:35\n+   |\n+LL | pub struct SafeImpl<T: ?Sized, A: Raw<T>>(PhantomData<(A, T)>);\n+   |                                   ^^^^^^ required by this bound in `SafeImpl`\n+\n+error[E0599]: the function or associated item `foo` exists for struct `SafeImpl<(), RawImpl<()>>`, but its trait bounds were not satisfied\n+  --> $DIR/issue-62742.rs:6:22\n+   |\n+LL |     WrongImpl::<()>::foo(0i32);\n+   |                      ^^^ function or associated item cannot be called on `SafeImpl<(), RawImpl<()>>` due to unsatisfied trait bounds\n+...\n+LL | pub struct RawImpl<T>(PhantomData<T>);\n+   | -------------------------------------- doesn't satisfy `RawImpl<()>: Raw<()>`\n+...\n+LL | pub struct SafeImpl<T: ?Sized, A: Raw<T>>(PhantomData<(A, T)>);\n+   | --------------------------------------------------------------- function or associated item `foo` not found for this\n+   |\n+   = note: the following trait bounds were not satisfied:\n+           `RawImpl<()>: Raw<()>`\n+note: the following trait must be implemented\n+  --> $DIR/issue-62742.rs:12:1\n+   |\n+LL | / pub trait Raw<T: ?Sized> {\n+LL | |     type Value;\n+LL | | }\n+   | |_^\n+\n+error[E0277]: the trait bound `RawImpl<()>: Raw<()>` is not satisfied\n+  --> $DIR/issue-62742.rs:6:5\n+   |\n+LL |     WrongImpl::<()>::foo(0i32);\n+   |     ^^^^^^^^^^^^^^^ the trait `Raw<()>` is not implemented for `RawImpl<()>`\n+   |\n+   = help: the following implementations were found:\n+             <RawImpl<T> as Raw<[T]>>\n+note: required by a bound in `SafeImpl`\n+  --> $DIR/issue-62742.rs:26:35\n+   |\n+LL | pub struct SafeImpl<T: ?Sized, A: Raw<T>>(PhantomData<(A, T)>);\n+   |                                   ^^^^^^ required by this bound in `SafeImpl`\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0277, E0599.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "17fbe046e3ac939f5e2051ade599f925c32265e1", "filename": "src/test/ui/impl-trait/issues/issue-67830.nll.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-67830.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-67830.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-67830.nll.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,20 @@\n+error: implementation of `FnOnce` is not general enough\n+  --> $DIR/issue-67830.rs:23:5\n+   |\n+LL |     Wrap(|a| Some(a).into_iter())\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: closure with signature `fn(&'2 A) -> std::option::IntoIter<&A>` must implement `FnOnce<(&'1 A,)>`, for any lifetime `'1`...\n+   = note: ...but it actually implements `FnOnce<(&'2 A,)>`, for some specific lifetime `'2`\n+\n+error: implementation of `FnOnce` is not general enough\n+  --> $DIR/issue-67830.rs:23:5\n+   |\n+LL |     Wrap(|a| Some(a).into_iter())\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: closure with signature `fn(&'2 A) -> std::option::IntoIter<&A>` must implement `FnOnce<(&'1 A,)>`, for any lifetime `'1`...\n+   = note: ...but it actually implements `FnOnce<(&'2 A,)>`, for some specific lifetime `'2`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "a308d975b43959b828cb3f634331a7f4bcf8a7bf", "filename": "src/test/ui/impl-trait/issues/issue-67830.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-67830.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-67830.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-67830.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,26 @@\n+trait MyFn<Arg> {\n+    type Output;\n+    fn call(&self, arg: Arg) -> Self::Output;\n+}\n+\n+struct Wrap<F>(F);\n+\n+impl<A, B, F> MyFn<A> for Wrap<F>\n+where\n+    F: Fn(A) -> B\n+{\n+    type Output = B;\n+\n+    fn call(&self, arg: A) -> Self::Output {\n+        (self.0)(arg)\n+    }\n+}\n+\n+\n+struct A;\n+fn test() -> impl for<'a> MyFn<&'a A, Output=impl Iterator + 'a> {\n+    //~^ ERROR implementation of `FnOnce` is not general enough\n+    Wrap(|a| Some(a).into_iter())\n+}\n+\n+fn main() {}"}, {"sha": "74e2f99cd33f9b300f2aa960147e26b89f5e19b1", "filename": "src/test/ui/impl-trait/issues/issue-67830.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-67830.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-67830.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-67830.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,15 @@\n+error: implementation of `FnOnce` is not general enough\n+  --> $DIR/issue-67830.rs:21:66\n+   |\n+LL |   fn test() -> impl for<'a> MyFn<&'a A, Output=impl Iterator + 'a> {\n+   |  __________________________________________________________________^\n+LL | |\n+LL | |     Wrap(|a| Some(a).into_iter())\n+LL | | }\n+   | |_^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: closure with signature `fn(&'2 A) -> std::option::IntoIter<&A>` must implement `FnOnce<(&'1 A,)>`, for any lifetime `'1`...\n+   = note: ...but it actually implements `FnOnce<(&'2 A,)>`, for some specific lifetime `'2`\n+\n+error: aborting due to previous error\n+"}, {"sha": "1a86fa00ed1a0a3832e4d0e6f3f59eb7ffdc87d7", "filename": "src/test/ui/impl-trait/issues/issue-70877.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -4,7 +4,7 @@ type FooArg<'a> = &'a dyn ToString;\n type FooRet = impl std::fmt::Debug;\n \n type FooItem = Box<dyn Fn(FooArg) -> FooRet>;\n-type Foo = impl Iterator<Item = FooItem>; //~ ERROR: type mismatch\n+type Foo = impl Iterator<Item = FooItem>;\n \n #[repr(C)]\n struct Bar(u8);\n@@ -13,7 +13,7 @@ impl Iterator for Bar {\n     type Item = FooItem;\n \n     fn next(&mut self) -> Option<Self::Item> {\n-        Some(Box::new(quux))\n+        Some(Box::new(quux)) //~ ERROR mismatched types\n     }\n }\n \n@@ -28,7 +28,7 @@ fn ham() -> Foo {\n fn oof() -> impl std::fmt::Debug {\n     let mut bar = ham();\n     let func = bar.next().unwrap();\n-    return func(&\"oof\");\n+    return func(&\"oof\"); //~ ERROR opaque type's hidden type cannot be another opaque type\n }\n \n fn main() {"}, {"sha": "7cbd58bdabf2f7b9521cb5f6a85f4d6b8d1b8904", "filename": "src/test/ui/impl-trait/issues/issue-70877.stderr", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,20 +1,34 @@\n-error[E0271]: type mismatch resolving `<Bar as Iterator>::Item == Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> Option<String> + 'static)>`\n-  --> $DIR/issue-70877.rs:7:12\n+error[E0308]: mismatched types\n+  --> $DIR/issue-70877.rs:16:9\n    |\n LL | type FooRet = impl std::fmt::Debug;\n-   |               -------------------- the found opaque type\n+   |               -------------------- the expected opaque type\n ...\n-LL | type Foo = impl Iterator<Item = FooItem>;\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type mismatch resolving `<Bar as Iterator>::Item == Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> Option<String> + 'static)>`\n+LL |     fn next(&mut self) -> Option<Self::Item> {\n+   |                           ------------------ expected `Option<Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> FooRet + 'static)>>` because of return type\n+LL |         Some(Box::new(quux))\n+   |         ^^^^^^^^^^^^^^^^^^^^ expected trait object `dyn Fn`, found fn item\n    |\n-note: expected this to be `Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> Option<String> + 'static)>`\n-  --> $DIR/issue-70877.rs:13:17\n+   = note: expected enum `Option<Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> FooRet + 'static)>>`\n+              found enum `Option<Box<for<'r> fn(&'r (dyn ToString + 'r)) -> FooRet {quux}>>`\n+\n+error: opaque type's hidden type cannot be another opaque type from the same scope\n+  --> $DIR/issue-70877.rs:31:12\n+   |\n+LL |     return func(&\"oof\");\n+   |            ^^^^^^^^^^^^ one of the two opaque types used here has to be outside its defining scope\n+   |\n+note: opaque type whose hidden type is being assigned\n+  --> $DIR/issue-70877.rs:28:13\n    |\n-LL |     type Item = FooItem;\n-   |                 ^^^^^^^\n-   = note: expected struct `Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> Option<String> + 'static)>`\n-              found struct `Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> impl Debug + 'static)>`\n+LL | fn oof() -> impl std::fmt::Debug {\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+note: opaque type being used as hidden type\n+  --> $DIR/issue-70877.rs:4:15\n+   |\n+LL | type FooRet = impl std::fmt::Debug;\n+   |               ^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0271`.\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "654de0cd0253c4a77f51adf1a0fbba8f084630d4", "filename": "src/test/ui/impl-trait/issues/issue-74282.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-74282.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-74282.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-74282.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,11 @@\n+#![feature(type_alias_impl_trait)]\n+\n+type Closure = impl Fn() -> u64;\n+struct Anonymous(Closure);\n+\n+fn main() {\n+    let y = || -> Closure { || 3 };\n+    Anonymous(|| { //~ ERROR mismatched types\n+        3 //~^ ERROR mismatched types\n+    })\n+}"}, {"sha": "6e02a6b2b87b4c71d6abb2010b1ebf2a97a56a23", "filename": "src/test/ui/impl-trait/issues/issue-74282.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-74282.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-74282.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-74282.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,33 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-74282.rs:8:15\n+   |\n+LL |   type Closure = impl Fn() -> u64;\n+   |                  ---------------- the expected opaque type\n+...\n+LL |       Anonymous(|| {\n+   |  _______________^\n+LL | |         3\n+LL | |     })\n+   | |_____^ expected closure, found a different closure\n+   |\n+   = note: expected opaque type `Closure`\n+                  found closure `[closure@$DIR/issue-74282.rs:8:15: 10:6]`\n+   = note: no two closures, even if identical, have the same type\n+   = help: consider boxing your closure and/or using it as a trait object\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-74282.rs:8:5\n+   |\n+LL |   fn main() {\n+   |             - expected `()` because of default return type\n+LL |       let y = || -> Closure { || 3 };\n+LL | /     Anonymous(|| {\n+LL | |         3\n+LL | |     })\n+   | |      ^- help: consider using a semicolon here: `;`\n+   | |______|\n+   |        expected `()`, found struct `Anonymous`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "d29710b6f54ca50944292a821ad935e19876ad99", "filename": "src/test/ui/impl-trait/issues/issue-77987.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-77987.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-77987.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-77987.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,21 @@\n+#![feature(type_alias_impl_trait)]\n+\n+// check-pass\n+\n+trait Foo<T> {}\n+impl<T, U> Foo<T> for U {}\n+\n+type Scope = impl Foo<()>;\n+\n+#[allow(unused)]\n+fn infer_scope() -> Scope {\n+    ()\n+}\n+\n+#[allow(unused)]\n+fn ice() -> impl Foo<Scope>\n+{\n+    loop {}\n+}\n+\n+fn main() {}"}, {"sha": "5498793bc28daa57581b68b8fae861043be108e5", "filename": "src/test/ui/impl-trait/issues/issue-78722.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -7,10 +7,11 @@ type F = impl core::future::Future<Output = u8>;\n struct Bug {\n     V1: [(); {\n         fn concrete_use() -> F {\n-            async {}\n+            async {} //~ ERROR type mismatch\n         }\n         let f: F = async { 1 };\n-        //~^ ERROR mismatched types [E0308]\n+        //~^ ERROR `async` blocks are not allowed in constants\n+        //~| ERROR destructors cannot be evaluated at compile-time\n         1\n     }],\n }"}, {"sha": "624d85570c7de8bdf03be409dcd9d764b9a4cca9", "filename": "src/test/ui/impl-trait/issues/issue-78722.stderr", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,23 +1,28 @@\n-error[E0308]: mismatched types\n+error[E0658]: `async` blocks are not allowed in constants\n   --> $DIR/issue-78722.rs:12:20\n    |\n-LL | type F = impl core::future::Future<Output = u8>;\n-   |          -------------------------------------- the expected opaque type\n-...\n LL |         let f: F = async { 1 };\n-   |                -   ^^^^^^^^^^^ expected opaque type, found a different opaque type\n-   |                |\n-   |                expected due to this\n+   |                    ^^^^^^^^^^^\n    |\n-  ::: $SRC_DIR/core/src/future/mod.rs:LL:COL\n+   = note: see issue #85368 <https://github.com/rust-lang/rust/issues/85368> for more information\n+   = help: add `#![feature(const_async_blocks)]` to the crate attributes to enable\n+\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/issue-78722.rs:12:13\n    |\n-LL | pub const fn from_generator<T>(gen: T) -> impl Future<Output = T::Return>\n-   |                                           ------------------------------- the found opaque type\n+LL |         let f: F = async { 1 };\n+   |             ^ constants cannot evaluate destructors\n+...\n+LL |     }],\n+   |     - value is dropped here\n+\n+error[E0271]: type mismatch resolving `<impl Future as Future>::Output == u8`\n+  --> $DIR/issue-78722.rs:10:13\n    |\n-   = note: expected opaque type `impl Future<Output = u8>`\n-              found opaque type `impl Future`\n-   = note: distinct uses of `impl Trait` result in different opaque types\n+LL |             async {}\n+   |             ^^^^^^^^ expected `()`, found `u8`\n \n-error: aborting due to previous error\n+error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0308`.\n+Some errors have detailed explanations: E0271, E0493, E0658.\n+For more information about an error, try `rustc --explain E0271`."}, {"sha": "cc9167b340ad72aca6a9cc01be0e6b18e8c22569", "filename": "src/test/ui/impl-trait/issues/issue-82139.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-82139.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-82139.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-82139.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,19 @@\n+#![feature(type_alias_impl_trait)]\n+\n+trait Trait {\n+    type Associated;\n+    fn func() -> Self::Associated;\n+}\n+\n+trait Bound {}\n+pub struct Struct;\n+\n+impl Trait for Struct {\n+    type Associated = impl Bound;\n+\n+    fn func() -> Self::Associated {\n+        Some(42).map(|_| j) //~ ERROR cannot find value `j` in this scope\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "0adcd4a7a2f5cdc25313d35ba420d4665190c1e8", "filename": "src/test/ui/impl-trait/issues/issue-82139.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-82139.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-82139.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-82139.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,9 @@\n+error[E0425]: cannot find value `j` in this scope\n+  --> $DIR/issue-82139.rs:15:26\n+   |\n+LL |         Some(42).map(|_| j)\n+   |                          ^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "58aca77fdf19fa832b52a453d9dfa0317d02b45a", "filename": "src/test/ui/impl-trait/issues/issue-83919.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-83919.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-83919.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-83919.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,31 @@\n+#![feature(type_alias_impl_trait)]\n+\n+// edition:2021\n+\n+use std::future::Future;\n+\n+trait Foo {\n+    type T;\n+    type Fut2: Future<Output=Self::T>; // ICE got triggered with traits other than Future here\n+    type Fut: Future<Output=Self::Fut2>;\n+    fn get_fut(&self) -> Self::Fut;\n+}\n+\n+struct Implementor;\n+\n+impl Foo for Implementor {\n+    type T = u64;\n+    type Fut2 = impl Future<Output=u64>;\n+    type Fut = impl Future<Output=Self::Fut2>;\n+\n+    fn get_fut(&self) -> Self::Fut {\n+        async move {\n+            42 //~^ ERROR `{integer}` is not a future\n+            // 42 does not impl Future and rustc does actually point out the error,\n+            // but rustc used to panic.\n+            // Putting a valid Future here always worked fine.\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "ebd0130be8d065122b88e96633308418d53ff06b", "filename": "src/test/ui/impl-trait/issues/issue-83919.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-83919.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-83919.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-83919.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,17 @@\n+error[E0277]: `{integer}` is not a future\n+  --> $DIR/issue-83919.rs:22:9\n+   |\n+LL | /         async move {\n+LL | |             42\n+LL | |             // 42 does not impl Future and rustc does actually point out the error,\n+LL | |             // but rustc used to panic.\n+LL | |             // Putting a valid Future here always worked fine.\n+LL | |         }\n+   | |_________^ `{integer}` is not a future\n+   |\n+   = help: the trait `Future` is not implemented for `{integer}`\n+   = note: {integer} must be a future or must implement `IntoFuture` to be awaited\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "49a34ccfa3b4baa655bb3dcfcc504c3bc0526c37", "filename": "src/test/ui/impl-trait/issues/issue-84073.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-84073.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-84073.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-84073.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,33 @@\n+use std::marker::PhantomData;\n+\n+pub trait StatefulFuture<S> {}\n+pub struct Never<T>(PhantomData<T>);\n+impl<T> StatefulFuture<T> for Never<T> {}\n+\n+pub struct RaceBuilder<F, S> {\n+    future: F,\n+    _phantom: PhantomData<S>,\n+}\n+\n+impl<T, F> RaceBuilder<T, F>\n+where\n+    F: StatefulFuture<Option<T>>,\n+{\n+    pub fn when(self) {}\n+}\n+\n+pub struct Race<T, R> {\n+    race: R,\n+    _phantom: PhantomData<T>,\n+}\n+\n+impl<T, R> Race<T, R>\n+where\n+    R: Fn(RaceBuilder<T, Never<T>>),\n+{\n+    pub fn new(race: R) {}\n+}\n+\n+fn main() {\n+    Race::new(|race| race.when()); //~ ERROR type annotations needed\n+}"}, {"sha": "36047d23fedda6f182aec29649c3bcf9da3b3bc8", "filename": "src/test/ui/impl-trait/issues/issue-84073.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-84073.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-84073.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-84073.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,9 @@\n+error[E0282]: type annotations needed for `RaceBuilder<T, Never<T>>`\n+  --> $DIR/issue-84073.rs:32:16\n+   |\n+LL |     Race::new(|race| race.when());\n+   |                ^^^^ consider giving this closure parameter the explicit type `RaceBuilder<T, Never<T>>`, where the type parameter `T` is specified\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "0786e66ca8b06c6969184d2160f97a18bd5c1a3f", "filename": "src/test/ui/impl-trait/issues/issue-86201.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86201.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86201.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86201.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,10 +1,10 @@\n #![feature(unboxed_closures)]\n #![feature(type_alias_impl_trait)]\n \n+// check-pass\n+\n type FunType = impl Fn<()>;\n-//~^ ERROR could not find defining uses\n static STATIC_FN: FunType = some_fn;\n-//~^ ERROR mismatched types\n \n fn some_fn() {}\n "}, {"sha": "b1460096ded66d3119023e21099d1886ce602f53", "filename": "src/test/ui/impl-trait/issues/issue-86201.stderr", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1446d17b8f4bd3ff8dbfb129a7674165e06f9f4c/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86201.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1446d17b8f4bd3ff8dbfb129a7674165e06f9f4c/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86201.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86201.stderr?ref=1446d17b8f4bd3ff8dbfb129a7674165e06f9f4c", "patch": "@@ -1,21 +0,0 @@\n-error[E0308]: mismatched types\n-  --> $DIR/issue-86201.rs:6:29\n-   |\n-LL | type FunType = impl Fn<()>;\n-   |                ----------- the expected opaque type\n-LL |\n-LL | static STATIC_FN: FunType = some_fn;\n-   |                             ^^^^^^^ expected opaque type, found fn item\n-   |\n-   = note: expected opaque type `impl Fn<()>`\n-                  found fn item `fn() {some_fn}`\n-\n-error: could not find defining uses\n-  --> $DIR/issue-86201.rs:4:16\n-   |\n-LL | type FunType = impl Fn<()>;\n-   |                ^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "f4b0b3f33fcd3437691a9e72398f3f469e94df6d", "filename": "src/test/ui/impl-trait/issues/issue-86719.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86719.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86719.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86719.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,12 @@\n+#![feature(type_alias_impl_trait)]\n+\n+trait Bar {\n+    type E;\n+}\n+impl<S> Bar for S {\n+    type E = impl ; //~ ERROR at least one trait must be specified\n+    fn foo() -> Self::E { //~ ERROR `foo` is not a member\n+        |_| true //~ ERROR type annotations needed\n+    }\n+}\n+fn main() {}"}, {"sha": "e2abf71c110b906b4a5bd89972c53be6ada271eb", "filename": "src/test/ui/impl-trait/issues/issue-86719.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86719.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86719.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86719.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,24 @@\n+error: at least one trait must be specified\n+  --> $DIR/issue-86719.rs:7:14\n+   |\n+LL |     type E = impl ;\n+   |              ^^^^\n+\n+error[E0407]: method `foo` is not a member of trait `Bar`\n+  --> $DIR/issue-86719.rs:8:5\n+   |\n+LL | /     fn foo() -> Self::E {\n+LL | |         |_| true\n+LL | |     }\n+   | |_____^ not a member of trait `Bar`\n+\n+error[E0282]: type annotations needed\n+  --> $DIR/issue-86719.rs:9:10\n+   |\n+LL |         |_| true\n+   |          ^ consider giving this closure parameter a type\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0282, E0407.\n+For more information about an error, try `rustc --explain E0282`."}, {"sha": "e8cef42f208ca78ac1418d3940a9861929f839dd", "filename": "src/test/ui/impl-trait/issues/issue-86800.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86800.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86800.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86800.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,48 @@\n+#![feature(type_alias_impl_trait)]\n+\n+// edition:2021\n+\n+use std::future::Future;\n+\n+struct Connection {\n+}\n+\n+trait Transaction {\n+}\n+\n+struct TestTransaction<'conn> {\n+    conn: &'conn Connection\n+}\n+\n+impl<'conn> Transaction for TestTransaction<'conn> {\n+}\n+\n+struct Context {\n+}\n+\n+type TransactionResult<O> = Result<O, ()>;\n+\n+type TransactionFuture<'__, O> = impl '__ + Future<Output = TransactionResult<O>>;\n+//~^ ERROR unconstrained opaque type\n+\n+fn execute_transaction_fut<'f, F, O>(\n+    f: F,\n+) -> impl FnOnce(&mut dyn Transaction) -> TransactionFuture<O>\n+where\n+    F: FnOnce(&mut dyn Transaction) -> TransactionFuture<O> + 'f\n+{\n+    f\n+}\n+\n+impl Context {\n+    async fn do_transaction<O>(\n+        &self, f: impl FnOnce(&mut dyn Transaction) -> TransactionFuture<O>\n+    ) -> TransactionResult<O>\n+    {\n+        let mut conn = Connection {};\n+        let mut transaction = TestTransaction { conn: &mut conn };\n+        f(&mut transaction).await\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "787aecc5b84bf93a1d8d89e061daef8fb0252f19", "filename": "src/test/ui/impl-trait/issues/issue-86800.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86800.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86800.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86800.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,10 @@\n+error: unconstrained opaque type\n+  --> $DIR/issue-86800.rs:25:34\n+   |\n+LL | type TransactionFuture<'__, O> = impl '__ + Future<Output = TransactionResult<O>>;\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `TransactionFuture` must be used in combination with a concrete type within the same module\n+\n+error: aborting due to previous error\n+"}, {"sha": "f0f6d2bb61c71aa39068b3a964653a47e5c8d50b", "filename": "src/test/ui/impl-trait/issues/issue-87340.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-87340.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-87340.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-87340.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,14 @@\n+#![feature(type_alias_impl_trait)]\n+\n+trait X {\n+    type I;\n+    fn f() -> Self::I;\n+}\n+\n+impl<T> X for () {\n+//~^ ERROR `T` is not constrained by the impl trait, self type, or predicates\n+    type I = impl Sized;\n+    fn f() -> Self::I {}\n+}\n+\n+fn main() {}"}, {"sha": "2ab1e6a031248b6eaa2dc89be47724dc6779e84f", "filename": "src/test/ui/impl-trait/issues/issue-87340.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-87340.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-87340.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-87340.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,9 @@\n+error[E0207]: the type parameter `T` is not constrained by the impl trait, self type, or predicates\n+  --> $DIR/issue-87340.rs:8:6\n+   |\n+LL | impl<T> X for () {\n+   |      ^ unconstrained type parameter\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0207`."}, {"sha": "9cf8ff76c87f8301f0f8f140b89276b6ad898d88", "filename": "src/test/ui/impl-trait/issues/issue-88236-2.nll.stderr", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.nll.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,51 @@\n+error: implementation of `Hrtb` is not general enough\n+  --> $DIR/issue-88236-2.rs:17:5\n+   |\n+LL |     &()\n+   |     ^^^ implementation of `Hrtb` is not general enough\n+   |\n+   = note: `Hrtb<'0>` would have to be implemented for the type `&()`, for any lifetime `'0`...\n+   = note: ...but `Hrtb<'1>` is actually implemented for the type `&'1 ()`, for some specific lifetime `'1`\n+\n+error: implementation of `Hrtb` is not general enough\n+  --> $DIR/issue-88236-2.rs:17:5\n+   |\n+LL |     &()\n+   |     ^^^ implementation of `Hrtb` is not general enough\n+   |\n+   = note: `Hrtb<'0>` would have to be implemented for the type `&()`, for any lifetime `'0`...\n+   = note: ...but `Hrtb<'1>` is actually implemented for the type `&'1 ()`, for some specific lifetime `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/issue-88236-2.rs:20:5\n+   |\n+LL | fn make_bad_impl<'b>(x: &'b ()) -> impl for<'a> Hrtb<'a, Assoc = impl Send + 'a> {\n+   |                  -- lifetime `'b` defined here\n+LL |     x\n+   |     ^ returning this value requires that `'b` must outlive `'static`\n+   |\n+help: to allow this `impl Trait` to capture borrowed data with lifetime `'b`, add `'b` as a bound\n+   |\n+LL | fn make_bad_impl<'b>(x: &'b ()) -> impl for<'a> Hrtb<'a, Assoc = impl Send + 'a> + 'b {\n+   |                                                                                  ++++\n+\n+error: implementation of `Hrtb` is not general enough\n+  --> $DIR/issue-88236-2.rs:20:5\n+   |\n+LL |     x\n+   |     ^ implementation of `Hrtb` is not general enough\n+   |\n+   = note: `Hrtb<'0>` would have to be implemented for the type `&()`, for any lifetime `'0`...\n+   = note: ...but `Hrtb<'1>` is actually implemented for the type `&'1 ()`, for some specific lifetime `'1`\n+\n+error: implementation of `Hrtb` is not general enough\n+  --> $DIR/issue-88236-2.rs:20:5\n+   |\n+LL |     x\n+   |     ^ implementation of `Hrtb` is not general enough\n+   |\n+   = note: `Hrtb<'0>` would have to be implemented for the type `&()`, for any lifetime `'0`...\n+   = note: ...but `Hrtb<'1>` is actually implemented for the type `&'1 ()`, for some specific lifetime `'1`\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "af26a1f54c46d5e498a6786f4f05565acc754471", "filename": "src/test/ui/impl-trait/issues/issue-88236-2.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,23 @@\n+// this used to cause stack overflows\n+\n+trait Hrtb<'a> {\n+    type Assoc;\n+}\n+\n+impl<'a> Hrtb<'a> for () {\n+    type Assoc = ();\n+}\n+\n+impl<'a> Hrtb<'a> for &'a () {\n+    type Assoc = ();\n+}\n+\n+fn make_impl() -> impl for<'a> Hrtb<'a, Assoc = impl Send + 'a> {}\n+fn make_weird_impl<'b>(x: &'b ()) -> impl for<'a> Hrtb<'a, Assoc = impl Send + 'a> {\n+    &() //~^ ERROR implementation of `Hrtb` is not general enough\n+}\n+fn make_bad_impl<'b>(x: &'b ()) -> impl for<'a> Hrtb<'a, Assoc = impl Send + 'a> {\n+    x //~^ ERROR implementation of `Hrtb` is not general enough\n+}\n+\n+fn main() {}"}, {"sha": "45fadcab3f2e15ca61c5292446699bba9b793260", "filename": "src/test/ui/impl-trait/issues/issue-88236-2.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,23 @@\n+error: implementation of `Hrtb` is not general enough\n+  --> $DIR/issue-88236-2.rs:16:38\n+   |\n+LL | fn make_weird_impl<'b>(x: &'b ()) -> impl for<'a> Hrtb<'a, Assoc = impl Send + 'a> {\n+   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Hrtb` is not general enough\n+   |\n+   = note: `Hrtb<'0>` would have to be implemented for the type `&()`, for any lifetime `'0`...\n+   = note: ...but `Hrtb<'1>` is actually implemented for the type `&'1 ()`, for some specific lifetime `'1`\n+\n+error: implementation of `Hrtb` is not general enough\n+  --> $DIR/issue-88236-2.rs:19:82\n+   |\n+LL |   fn make_bad_impl<'b>(x: &'b ()) -> impl for<'a> Hrtb<'a, Assoc = impl Send + 'a> {\n+   |  __________________________________________________________________________________^\n+LL | |     x\n+LL | | }\n+   | |_^ implementation of `Hrtb` is not general enough\n+   |\n+   = note: `&()` must implement `Hrtb<'0>`, for any lifetime `'0`...\n+   = note: ...but `Hrtb<'_>` is actually implemented for the type `&()`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "2ea35270a7e3b5cc0e6784bc8bff5375d7e693d4", "filename": "src/test/ui/impl-trait/issues/issue-88236.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,19 @@\n+// check-pass\n+\n+// this used to cause stack overflows\n+\n+trait Hrtb<'a> {\n+    type Assoc;\n+}\n+\n+impl<'a> Hrtb<'a> for () {\n+    type Assoc = ();\n+}\n+\n+impl<'a> Hrtb<'a> for &'a () {\n+    type Assoc = ();\n+}\n+\n+fn make_impl() -> impl for<'a> Hrtb<'a, Assoc = impl Send + 'a> {}\n+\n+fn main() {}"}, {"sha": "d685a6f120109e603a2ba472d68076867ac941a6", "filename": "src/test/ui/impl-trait/issues/issue-89312.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-89312.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-89312.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-89312.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,24 @@\n+#![feature(type_alias_impl_trait)]\n+\n+// check-pass\n+\n+trait T { type Item; }\n+\n+type Alias<'a> = impl T<Item = &'a ()>;\n+\n+struct S;\n+impl<'a> T for &'a S {\n+    type Item = &'a ();\n+}\n+\n+fn filter_positive<'a>() -> Alias<'a> {\n+    &S\n+}\n+\n+fn with_positive(fun: impl Fn(Alias<'_>)) {\n+    fun(filter_positive());\n+}\n+\n+fn main() {\n+    with_positive(|_| ());\n+}"}, {"sha": "6924931cda5db2d00d3c94e410481fd0d2161150", "filename": "src/test/ui/impl-trait/issues/issue-93788.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-93788.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-93788.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-93788.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,27 @@\n+// check-pass\n+\n+struct D;\n+\n+trait Tr {\n+    type It;\n+    fn foo(self) -> Option<Self::It>;\n+}\n+\n+impl<'a> Tr for &'a D {\n+    type It = ();\n+    fn foo(self) -> Option<()> { None }\n+}\n+\n+fn run<F>(f: F)\n+    where for<'a> &'a D: Tr,\n+          F: Fn(<&D as Tr>::It),\n+{\n+    let d = &D;\n+    while let Some(i) = d.foo() {\n+        f(i);\n+    }\n+}\n+\n+fn main() {\n+    run(|_| {});\n+}"}, {"sha": "834f2dc6cb5b6dfde14de37e2e7cd83d73e9c85e", "filename": "src/test/ui/impl-trait/lifetimes2.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Flifetimes2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Flifetimes2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Flifetimes2.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+\n+pub fn keys<'a>(x: &'a Result<u32, u32>) -> impl std::fmt::Debug + 'a {\n+    match x {\n+        Ok(map) => Ok(map),\n+        Err(map) => Err(map),\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "f5aaf1185211b44d67e06cc6b7deffa351b64ea0", "filename": "src/test/ui/impl-trait/multiple-lifetimes/error-handling-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -8,7 +8,6 @@ impl<T: Copy> Copy for CopyIfEq<T, T> {}\n type E<'a, 'b> = impl Sized;\n \n fn foo<'a: 'b, 'b, 'c>(x: &'static i32, mut y: &'a i32) -> E<'b, 'c> {\n-    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n     let v = CopyIfEq::<*mut _, *mut _>(&mut { x }, &mut y);\n \n     // This assignment requires that `x` and `y` have the same type due to the\n@@ -21,6 +20,7 @@ fn foo<'a: 'b, 'b, 'c>(x: &'static i32, mut y: &'a i32) -> E<'b, 'c> {\n         let _: &'b i32 = *u.0;\n     }\n     u.0\n+    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n }\n \n fn main() {}"}, {"sha": "b837b64110365d47585e9d702a7d52c2f51d33ca", "filename": "src/test/ui/impl-trait/multiple-lifetimes/error-handling-2.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,10 +1,11 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/error-handling-2.rs:10:60\n+  --> $DIR/error-handling-2.rs:22:5\n    |\n LL | fn foo<'a: 'b, 'b, 'c>(x: &'static i32, mut y: &'a i32) -> E<'b, 'c> {\n-   |        --                                                  ^^^^^^^^^\n-   |        |\n-   |        hidden type `*mut &'a i32` captures the lifetime `'a` as defined here\n+   |        -- hidden type `*mut &'a i32` captures the lifetime `'a` as defined here\n+...\n+LL |     u.0\n+   |     ^^^\n \n error: aborting due to previous error\n "}, {"sha": "47e05bce0f8de747a9f1baa6c588917459f0bf8b", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unrelated.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -14,7 +14,6 @@ struct Ordinary<'a>(&'a u8);\n // by both `'a` and `'b`.\n \n fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n-//~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n where\n     'a: 'e,\n     'b: 'd,\n@@ -27,6 +26,7 @@ where\n     // 'a in ['d, 'e]\n     // ```\n     if condition() { a } else { b }\n+    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n }\n \n fn condition() -> bool {"}, {"sha": "15476c706a7f2eab942c6a0ef53faea811766d05", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unrelated.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,10 +1,11 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ordinary-bounds-unrelated.rs:16:74\n+  --> $DIR/ordinary-bounds-unrelated.rs:28:33\n    |\n LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n-   |                     --                                                   ^^^^^^^^^^^^^^^^^^\n-   |                     |\n-   |                     hidden type `Ordinary<'b>` captures the lifetime `'b` as defined here\n+   |                     -- hidden type `Ordinary<'b>` captures the lifetime `'b` as defined here\n+...\n+LL |     if condition() { a } else { b }\n+   |                                 ^\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |"}, {"sha": "321cb8c92a1774eb825e44c5d681cf48d24a5481", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unsuited.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -16,7 +16,6 @@ struct Ordinary<'a>(&'a u8);\n // consider the loans for both `'a` and `'b` alive.\n \n fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n-//~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n {\n     // We return a value:\n     //\n@@ -30,6 +29,7 @@ fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n     //\n     // We are forced to pick that '0 = 'e, because only 'e is outlived by *both* 'a and 'b.\n     if condition() { a } else { b }\n+    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n }\n \n fn condition() -> bool {"}, {"sha": "7315aa8e9d4787f617c65d33e42b24eee4614f08", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unsuited.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,10 +1,11 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ordinary-bounds-unsuited.rs:18:62\n+  --> $DIR/ordinary-bounds-unsuited.rs:31:33\n    |\n LL | fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n-   |                     --                                       ^^^^^^^^^^^^^^^^^^\n-   |                     |\n-   |                     hidden type `Ordinary<'b>` captures the lifetime `'b` as defined here\n+   |                     -- hidden type `Ordinary<'b>` captures the lifetime `'b` as defined here\n+...\n+LL |     if condition() { a } else { b }\n+   |                                 ^\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |"}, {"sha": "9589b69491e251c19138f26223031e35b32eb66c", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.nll.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,8 +1,8 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/must_outlive_least_region_or_bound.rs:3:23\n+  --> $DIR/must_outlive_least_region_or_bound.rs:3:35\n    |\n LL | fn elided(x: &i32) -> impl Copy { x }\n-   |              ----     ^^^^^^^^^\n+   |              ----                 ^\n    |              |\n    |              hidden type `&i32` captures the anonymous lifetime defined here\n    |\n@@ -12,10 +12,10 @@ LL | fn elided(x: &i32) -> impl Copy + '_ { x }\n    |                                 ++++\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/must_outlive_least_region_or_bound.rs:6:32\n+  --> $DIR/must_outlive_least_region_or_bound.rs:6:44\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n-   |             --                 ^^^^^^^^^\n+   |             --                             ^\n    |             |\n    |             hidden type `&'a i32` captures the lifetime `'a` as defined here\n    |\n@@ -67,23 +67,23 @@ LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    = help: consider replacing `'a` with `'static`\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/must_outlive_least_region_or_bound.rs:33:61\n+  --> $DIR/must_outlive_least_region_or_bound.rs:34:5\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n-   |                              --                             ^^^^^^^^^^^^^^^^\n-   |                              |\n-   |                              hidden type `[closure@$DIR/must_outlive_least_region_or_bound.rs:35:5: 35:31]` captures the lifetime `'b` as defined here\n+   |                              -- hidden type `[closure@$DIR/must_outlive_least_region_or_bound.rs:34:5: 34:31]` captures the lifetime `'b` as defined here\n+LL |     move |_| println!(\"{}\", y)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) + 'b {\n    |                                                                              ++++\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:38:51\n+  --> $DIR/must_outlive_least_region_or_bound.rs:41:5\n    |\n-LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n-   |                                                   ^^^^^^^^^^^^^^^^^^^^\n+LL |     x\n+   |     ^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'static`...\n "}, {"sha": "baa42da64468d51e991df9dff9b649f339e35e17", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -31,12 +31,13 @@ fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x } //~ ERRO\n // Tests that a closure type containing 'b cannot be returned from a type where\n // only 'a was expected.\n fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n-    //~^ ERROR: captures lifetime that does not appear in bounds\n     move |_| println!(\"{}\", y)\n+    //~^ ERROR: captures lifetime that does not appear in bounds\n }\n \n fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n     //~^ ERROR the parameter type `T` may not live long enough\n+    //~| ERROR the parameter type `T` may not live long enough\n     x\n }\n "}, {"sha": "1272adb35e98c3fb1e7d927a7166e29cdd6f15dc", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.stderr", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,8 +1,8 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/must_outlive_least_region_or_bound.rs:3:23\n+  --> $DIR/must_outlive_least_region_or_bound.rs:3:35\n    |\n LL | fn elided(x: &i32) -> impl Copy { x }\n-   |              ----     ^^^^^^^^^\n+   |              ----                 ^\n    |              |\n    |              hidden type `&i32` captures the anonymous lifetime defined here\n    |\n@@ -12,10 +12,10 @@ LL | fn elided(x: &i32) -> impl Copy + '_ { x }\n    |                                 ++++\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/must_outlive_least_region_or_bound.rs:6:32\n+  --> $DIR/must_outlive_least_region_or_bound.rs:6:44\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n-   |             --                 ^^^^^^^^^\n+   |             --                             ^\n    |             |\n    |             hidden type `&'a i32` captures the lifetime `'a` as defined here\n    |\n@@ -112,12 +112,12 @@ LL | fn with_bound<'a>(x: &'static i32) -> impl LifetimeTrait<'a> + 'static { x\n    |                      ~~~~~~~~~~~~\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/must_outlive_least_region_or_bound.rs:33:61\n+  --> $DIR/must_outlive_least_region_or_bound.rs:34:5\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n-   |                              --                             ^^^^^^^^^^^^^^^^\n-   |                              |\n-   |                              hidden type `[closure@$DIR/must_outlive_least_region_or_bound.rs:35:5: 35:31]` captures the lifetime `'b` as defined here\n+   |                              -- hidden type `[closure@$DIR/must_outlive_least_region_or_bound.rs:34:5: 34:31]` captures the lifetime `'b` as defined here\n+LL |     move |_| println!(\"{}\", y)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |\n@@ -132,6 +132,19 @@ LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n    |                                 |\n    |                                 help: consider adding an explicit lifetime bound...: `T: 'static +`\n \n+error[E0310]: the parameter type `T` may not live long enough\n+  --> $DIR/must_outlive_least_region_or_bound.rs:38:72\n+   |\n+LL |   fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n+   |  _________________________________--_____________________________________^\n+   | |                                 |\n+   | |                                 help: consider adding an explicit lifetime bound...: `T: 'static +`\n+LL | |\n+LL | |\n+LL | |     x\n+LL | | }\n+   | |_^ ...so that the type `T` will meet its required lifetime bounds\n+\n error[E0759]: `x` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/must_outlive_least_region_or_bound.rs:16:50\n    |\n@@ -218,7 +231,7 @@ help: alternatively, add an explicit `'static` bound to this reference\n LL | fn explicit4<'a>(x: &'static i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n    |                     ~~~~~~~~~~~~\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 14 previous errors\n \n Some errors have detailed explanations: E0310, E0621, E0700, E0759.\n For more information about an error, try `rustc --explain E0310`."}, {"sha": "70e24a3a9d029b946073b198b4d1cbf7583381a1", "filename": "src/test/ui/impl-trait/negative-reasoning.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -17,7 +17,7 @@ impl<T: std::fmt::Debug> AnotherTrait for T {}\n \n // This is in error, because we cannot assume that `OpaqueType: !Debug`\n impl AnotherTrait for D<OpaqueType> {\n-    //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `D<impl OpaqueTrait>`\n+    //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`\n }\n \n fn main() {}"}, {"sha": "6b8cc9e7374239c2c14036bf2ce6bfd6628323ad", "filename": "src/test/ui/impl-trait/negative-reasoning.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,13 +1,13 @@\n-error[E0119]: conflicting implementations of trait `AnotherTrait` for type `D<impl OpaqueTrait>`\n+error[E0119]: conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`\n   --> $DIR/negative-reasoning.rs:19:1\n    |\n LL | impl<T: std::fmt::Debug> AnotherTrait for T {}\n    | ------------------------------------------- first implementation here\n ...\n LL | impl AnotherTrait for D<OpaqueType> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `D<impl OpaqueTrait>`\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `D<OpaqueType>`\n    |\n-   = note: upstream crates may add a new impl of trait `std::fmt::Debug` for type `impl OpaqueTrait` in future versions\n+   = note: upstream crates may add a new impl of trait `std::fmt::Debug` for type `OpaqueType` in future versions\n \n error: aborting due to previous error\n "}, {"sha": "f2217f699fbbdc6a7951e092bb52bb6dcb137e70", "filename": "src/test/ui/impl-trait/nested-return-type2-tait.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,32 @@\n+#![feature(type_alias_impl_trait)]\n+\n+trait Duh {}\n+\n+impl Duh for i32 {}\n+\n+trait Trait {\n+    type Assoc: Duh;\n+}\n+\n+// the fact that `R` is the `::Output` projection on `F` causes\n+// an intermediate inference var to be generated which is then later\n+// compared against the actually found `Assoc` type.\n+impl<R: Duh, F: FnMut() -> R> Trait for F {\n+    type Assoc = R;\n+}\n+\n+type Sendable = impl Send;\n+\n+// The `Sendable` here is then later compared against the inference var\n+// created, causing the inference var to be set to `Sendable` instead of\n+// the hidden type. We already have obligations registered on the inference\n+// var to make it uphold the `: Duh` bound on `Trait::Assoc`. The opaque\n+// type does not implement `Duh`, even if its hidden type does. So we error out.\n+fn foo() -> impl Trait<Assoc = Sendable> {\n+    //~^ ERROR `Sendable: Duh` is not satisfied\n+    //~| ERROR `Sendable: Duh` is not satisfied\n+    || 42\n+}\n+\n+fn main() {\n+}"}, {"sha": "776c06b20dfc23a7c9810cf646a4a91aac3c2dc9", "filename": "src/test/ui/impl-trait/nested-return-type2-tait.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,32 @@\n+error[E0277]: the trait bound `Sendable: Duh` is not satisfied\n+  --> $DIR/nested-return-type2-tait.rs:25:13\n+   |\n+LL | fn foo() -> impl Trait<Assoc = Sendable> {\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Duh` is not implemented for `Sendable`\n+   |\n+note: required because of the requirements on the impl of `Trait` for `[closure@$DIR/nested-return-type2-tait.rs:28:5: 28:10]`\n+  --> $DIR/nested-return-type2-tait.rs:14:31\n+   |\n+LL | impl<R: Duh, F: FnMut() -> R> Trait for F {\n+   |                               ^^^^^     ^\n+\n+error[E0277]: the trait bound `Sendable: Duh` is not satisfied\n+  --> $DIR/nested-return-type2-tait.rs:25:42\n+   |\n+LL |   fn foo() -> impl Trait<Assoc = Sendable> {\n+   |  __________________________________________^\n+LL | |\n+LL | |\n+LL | |     || 42\n+LL | | }\n+   | |_^ the trait `Duh` is not implemented for `Sendable`\n+   |\n+note: required because of the requirements on the impl of `Trait` for `[closure@$DIR/nested-return-type2-tait.rs:28:5: 28:10]`\n+  --> $DIR/nested-return-type2-tait.rs:14:31\n+   |\n+LL | impl<R: Duh, F: FnMut() -> R> Trait for F {\n+   |                               ^^^^^     ^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "af8e066305471df0451cb61a6a75c501cc5dc8d0", "filename": "src/test/ui/impl-trait/nested-return-type2-tait2.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait2.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,32 @@\n+#![feature(type_alias_impl_trait)]\n+\n+trait Duh {}\n+\n+impl Duh for i32 {}\n+\n+trait Trait {\n+    type Assoc: Duh;\n+}\n+\n+// the fact that `R` is the `::Output` projection on `F` causes\n+// an intermediate inference var to be generated which is then later\n+// compared against the actually found `Assoc` type.\n+impl<R: Duh, F: FnMut() -> R> Trait for F {\n+    type Assoc = R;\n+}\n+\n+type Sendable = impl Send;\n+type Traitable = impl Trait<Assoc = Sendable>;\n+\n+// The `impl Send` here is then later compared against the inference var\n+// created, causing the inference var to be set to `impl Send` instead of\n+// the hidden type. We already have obligations registered on the inference\n+// var to make it uphold the `: Duh` bound on `Trait::Assoc`. The opaque\n+// type does not implement `Duh`, even if its hidden type does. So we error out.\n+fn foo() -> Traitable {\n+    || 42\n+    //~^ ERROR `Sendable: Duh` is not satisfied\n+}\n+\n+fn main() {\n+}"}, {"sha": "4993202e2532e5fa1782ebf62ecc263af54d992c", "filename": "src/test/ui/impl-trait/nested-return-type2-tait2.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait2.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `Sendable: Duh` is not satisfied\n+  --> $DIR/nested-return-type2-tait2.rs:27:5\n+   |\n+LL |     || 42\n+   |     ^^^^^ the trait `Duh` is not implemented for `Sendable`\n+   |\n+note: required because of the requirements on the impl of `Trait` for `[closure@$DIR/nested-return-type2-tait2.rs:27:5: 27:10]`\n+  --> $DIR/nested-return-type2-tait2.rs:14:31\n+   |\n+LL | impl<R: Duh, F: FnMut() -> R> Trait for F {\n+   |                               ^^^^^     ^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "74fd8a9dda0bfcb952e7631e9492abe0d02fa941", "filename": "src/test/ui/impl-trait/nested-return-type2-tait3.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait3.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,31 @@\n+#![feature(type_alias_impl_trait)]\n+\n+trait Duh {}\n+\n+impl Duh for i32 {}\n+\n+trait Trait {\n+    type Assoc: Duh;\n+}\n+\n+// the fact that `R` is the `::Output` projection on `F` causes\n+// an intermediate inference var to be generated which is then later\n+// compared against the actually found `Assoc` type.\n+impl<R: Duh, F: FnMut() -> R> Trait for F {\n+    type Assoc = R;\n+}\n+\n+type Traitable = impl Trait<Assoc = impl Send>;\n+\n+// The `impl Send` here is then later compared against the inference var\n+// created, causing the inference var to be set to `impl Send` instead of\n+// the hidden type. We already have obligations registered on the inference\n+// var to make it uphold the `: Duh` bound on `Trait::Assoc`. The opaque\n+// type does not implement `Duh`, even if its hidden type does. So we error out.\n+fn foo() -> Traitable {\n+    || 42\n+    //~^ ERROR `impl Send: Duh` is not satisfied\n+}\n+\n+fn main() {\n+}"}, {"sha": "efeaf059a3bb27b54a0cd15058fc4e11f867db62", "filename": "src/test/ui/impl-trait/nested-return-type2-tait3.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait3.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `impl Send: Duh` is not satisfied\n+  --> $DIR/nested-return-type2-tait3.rs:26:5\n+   |\n+LL |     || 42\n+   |     ^^^^^ the trait `Duh` is not implemented for `impl Send`\n+   |\n+note: required because of the requirements on the impl of `Trait` for `[closure@$DIR/nested-return-type2-tait3.rs:26:5: 26:10]`\n+  --> $DIR/nested-return-type2-tait3.rs:14:31\n+   |\n+LL | impl<R: Duh, F: FnMut() -> R> Trait for F {\n+   |                               ^^^^^     ^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "39928d543e15d79a2d0e74d1c5b7affdb5ae2bf0", "filename": "src/test/ui/impl-trait/nested-return-type2.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,30 @@\n+// check-pass\n+\n+trait Duh {}\n+\n+impl Duh for i32 {}\n+\n+trait Trait {\n+    type Assoc: Duh;\n+}\n+\n+// the fact that `R` is the `::Output` projection on `F` causes\n+// an intermediate inference var to be generated which is then later\n+// compared against the actually found `Assoc` type.\n+impl<R: Duh, F: FnMut() -> R> Trait for F {\n+    type Assoc = R;\n+}\n+\n+// The `impl Send` here is then later compared against the inference var\n+// created, causing the inference var to be set to `impl Send` instead of\n+// the hidden type. We already have obligations registered on the inference\n+// var to make it uphold the `: Duh` bound on `Trait::Assoc`. The opaque\n+// type does not implement `Duh`, even if its hidden type does.\n+// Lazy TAIT would error out, but we inserted a hack to make it work again,\n+// keeping backwards compatibility.\n+fn foo() -> impl Trait<Assoc = impl Send> {\n+    || 42\n+}\n+\n+fn main() {\n+}"}, {"sha": "3936f4dbbb426f385704f8eb8a3c7ede227d9a7b", "filename": "src/test/ui/impl-trait/nested-return-type3-tait.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3-tait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3-tait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3-tait.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,24 @@\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+trait Duh {}\n+\n+impl Duh for i32 {}\n+\n+trait Trait {\n+    type Assoc: Duh;\n+}\n+\n+impl<F: Duh> Trait for F {\n+    type Assoc = F;\n+}\n+\n+type Sendable = impl Send;\n+\n+fn foo() -> impl Trait<Assoc = Sendable> {\n+    42\n+}\n+\n+fn main() {\n+}"}, {"sha": "56778ed90dc7b46b7fef77a686e207363cff3bd2", "filename": "src/test/ui/impl-trait/nested-return-type3-tait2.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3-tait2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3-tait2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3-tait2.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,25 @@\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+trait Duh {}\n+\n+impl Duh for i32 {}\n+\n+trait Trait {\n+    type Assoc: Duh;\n+}\n+\n+impl<F: Duh> Trait for F {\n+    type Assoc = F;\n+}\n+\n+type Sendable = impl Send;\n+type Traitable = impl Trait<Assoc = Sendable>;\n+\n+fn foo() -> Traitable {\n+    42\n+}\n+\n+fn main() {\n+}"}, {"sha": "04c6c92b1a3c50e5408db510c60f11e288d035e7", "filename": "src/test/ui/impl-trait/nested-return-type3-tait3.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3-tait3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3-tait3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3-tait3.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,24 @@\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+trait Duh {}\n+\n+impl Duh for i32 {}\n+\n+trait Trait {\n+    type Assoc: Duh;\n+}\n+\n+impl<F: Duh> Trait for F {\n+    type Assoc = F;\n+}\n+\n+type Traitable = impl Trait<Assoc = impl Send>;\n+\n+fn foo() -> Traitable {\n+    42\n+}\n+\n+fn main() {\n+}"}, {"sha": "74b4dae22ebfd32a5ee845c1ec3d8834f4bc447e", "filename": "src/test/ui/impl-trait/nested-return-type3.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type3.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,20 @@\n+// check-pass\n+\n+trait Duh {}\n+\n+impl Duh for i32 {}\n+\n+trait Trait {\n+    type Assoc: Duh;\n+}\n+\n+impl<F: Duh> Trait for F {\n+    type Assoc = F;\n+}\n+\n+fn foo() -> impl Trait<Assoc = impl Send> {\n+    42\n+}\n+\n+fn main() {\n+}"}, {"sha": "85c6f8c462cbbfb60adb2c7a83a72783769961dc", "filename": "src/test/ui/impl-trait/nested_impl_trait.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested_impl_trait.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -4,6 +4,7 @@ fn fine(x: impl Into<u32>) -> impl Into<u32> { x }\n \n fn bad_in_ret_position(x: impl Into<u32>) -> impl Into<impl Debug> { x }\n //~^ ERROR nested `impl Trait` is not allowed\n+//~| ERROR the trait bound `impl Debug: From<impl Into<u32>>` is not satisfied\n \n fn bad_in_fn_syntax(x: fn() -> impl Into<impl Debug>) {}\n //~^ ERROR nested `impl Trait` is not allowed\n@@ -16,6 +17,7 @@ struct X;\n impl X {\n     fn bad(x: impl Into<u32>) -> impl Into<impl Debug> { x }\n     //~^ ERROR nested `impl Trait` is not allowed\n+    //~| ERROR the trait bound `impl Debug: From<impl Into<u32>>` is not satisfied\n }\n \n fn allowed_in_assoc_type() -> impl Iterator<Item=impl Fn()> {"}, {"sha": "26b48c7cdf7181615bb876899d3825ee3a016ce4", "filename": "src/test/ui/impl-trait/nested_impl_trait.stderr", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fnested_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested_impl_trait.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -8,7 +8,7 @@ LL | fn bad_in_ret_position(x: impl Into<u32>) -> impl Into<impl Debug> { x }\n    |                                              outer `impl Trait`\n \n error[E0666]: nested `impl Trait` is not allowed\n-  --> $DIR/nested_impl_trait.rs:8:42\n+  --> $DIR/nested_impl_trait.rs:9:42\n    |\n LL | fn bad_in_fn_syntax(x: fn() -> impl Into<impl Debug>) {}\n    |                                ----------^^^^^^^^^^-\n@@ -17,7 +17,7 @@ LL | fn bad_in_fn_syntax(x: fn() -> impl Into<impl Debug>) {}\n    |                                outer `impl Trait`\n \n error[E0666]: nested `impl Trait` is not allowed\n-  --> $DIR/nested_impl_trait.rs:12:37\n+  --> $DIR/nested_impl_trait.rs:13:37\n    |\n LL | fn bad_in_arg_position(_: impl Into<impl Debug>) { }\n    |                           ----------^^^^^^^^^^-\n@@ -26,7 +26,7 @@ LL | fn bad_in_arg_position(_: impl Into<impl Debug>) { }\n    |                           outer `impl Trait`\n \n error[E0666]: nested `impl Trait` is not allowed\n-  --> $DIR/nested_impl_trait.rs:17:44\n+  --> $DIR/nested_impl_trait.rs:18:44\n    |\n LL |     fn bad(x: impl Into<u32>) -> impl Into<impl Debug> { x }\n    |                                  ----------^^^^^^^^^^-\n@@ -35,18 +35,34 @@ LL |     fn bad(x: impl Into<u32>) -> impl Into<impl Debug> { x }\n    |                                  outer `impl Trait`\n \n error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in `fn` pointer return\n-  --> $DIR/nested_impl_trait.rs:8:32\n+  --> $DIR/nested_impl_trait.rs:9:32\n    |\n LL | fn bad_in_fn_syntax(x: fn() -> impl Into<impl Debug>) {}\n    |                                ^^^^^^^^^^^^^^^^^^^^^\n \n error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in `Fn` trait return\n-  --> $DIR/nested_impl_trait.rs:25:42\n+  --> $DIR/nested_impl_trait.rs:27:42\n    |\n LL | fn allowed_in_ret_type() -> impl Fn() -> impl Into<u32> {\n    |                                          ^^^^^^^^^^^^^^\n \n-error: aborting due to 6 previous errors\n+error[E0277]: the trait bound `impl Debug: From<impl Into<u32>>` is not satisfied\n+  --> $DIR/nested_impl_trait.rs:5:46\n+   |\n+LL | fn bad_in_ret_position(x: impl Into<u32>) -> impl Into<impl Debug> { x }\n+   |                                              ^^^^^^^^^^^^^^^^^^^^^ the trait `From<impl Into<u32>>` is not implemented for `impl Debug`\n+   |\n+   = note: required because of the requirements on the impl of `Into<impl Debug>` for `impl Into<u32>`\n+\n+error[E0277]: the trait bound `impl Debug: From<impl Into<u32>>` is not satisfied\n+  --> $DIR/nested_impl_trait.rs:18:34\n+   |\n+LL |     fn bad(x: impl Into<u32>) -> impl Into<impl Debug> { x }\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^ the trait `From<impl Into<u32>>` is not implemented for `impl Debug`\n+   |\n+   = note: required because of the requirements on the impl of `Into<impl Debug>` for `impl Into<u32>`\n+\n+error: aborting due to 8 previous errors\n \n-Some errors have detailed explanations: E0562, E0666.\n-For more information about an error, try `rustc --explain E0562`.\n+Some errors have detailed explanations: E0277, E0562, E0666.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "5ca01a593761cd54eb835bfb7d3df6f87d0810b6", "filename": "src/test/ui/impl-trait/object-unsafe-trait-in-return-position-impl-trait.stderr", "status": "modified", "additions": 4, "deletions": 31, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -2,46 +2,19 @@ error[E0308]: mismatched types\n   --> $DIR/object-unsafe-trait-in-return-position-impl-trait.rs:36:5\n    |\n LL | fn can() -> impl NotObjectSafe {\n-   |             ------------------ expected because this return type...\n-LL |     if true {\n-LL |         return A;\n-   |                - ...is found to be `A` here\n-LL |     }\n+   |             ------------------ expected `_` because of return type\n+...\n LL |     B\n    |     ^ expected struct `A`, found struct `B`\n-   |\n-   = note: to return `impl Trait`, all returned values must be of the same type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = help: if the trait `NotObjectSafe` were object safe, you could return a boxed trait object\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: you could instead create a new `enum` with a variant for each returned type\n \n error[E0308]: mismatched types\n   --> $DIR/object-unsafe-trait-in-return-position-impl-trait.rs:43:5\n    |\n LL | fn cat() -> impl ObjectSafe {\n-   |             --------------- expected because this return type...\n-LL |     if true {\n-LL |         return A;\n-   |                - ...is found to be `A` here\n-LL |     }\n+   |             --------------- expected `_` because of return type\n+...\n LL |     B\n    |     ^ expected struct `A`, found struct `B`\n-   |\n-   = note: to return `impl Trait`, all returned values must be of the same type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: you could instead create a new `enum` with a variant for each returned type\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn cat() -> Box<dyn ObjectSafe> {\n-   |             ~~~~~~~           +\n-help: if you change the return type to expect trait objects, box the returned expressions\n-   |\n-LL ~         return Box::new(A);\n-LL |     }\n-LL ~     Box::new(B)\n-   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0c595f441ba8e2d0d43cd2ddf47586ba49b72145", "filename": "src/test/ui/impl-trait/point-to-type-err-cause-on-impl-trait-return.stderr", "status": "modified", "additions": 10, "deletions": 149, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -2,82 +2,28 @@ error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:5:5\n    |\n LL | fn foo() -> impl std::fmt::Display {\n-   |             ---------------------- expected because this return type...\n-LL |     if false {\n-LL |         return 0i32;\n-   |                ---- ...is found to be `i32` here\n-LL |     }\n+   |             ---------------------- expected `_` because of return type\n+...\n LL |     1u32\n    |     ^^^^ expected `i32`, found `u32`\n-   |\n-   = note: to return `impl Trait`, all returned values must be of the same type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: you could instead create a new `enum` with a variant for each returned type\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn foo() -> Box<dyn std::fmt::Display> {\n-   |             ~~~~~~~                  +\n-help: if you change the return type to expect trait objects, box the returned expressions\n-   |\n-LL ~         return Box::new(0i32);\n-LL |     }\n-LL ~     Box::new(1u32)\n-   |\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:12:16\n    |\n LL | fn bar() -> impl std::fmt::Display {\n-   |             ---------------------- expected because this return type...\n-LL |     if false {\n-LL |         return 0i32;\n-   |                ---- ...is found to be `i32` here\n-LL |     } else {\n+   |             ---------------------- expected `_` because of return type\n+...\n LL |         return 1u32;\n    |                ^^^^ expected `i32`, found `u32`\n-   |\n-   = note: to return `impl Trait`, all returned values must be of the same type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: you could instead create a new `enum` with a variant for each returned type\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn bar() -> Box<dyn std::fmt::Display> {\n-   |             ~~~~~~~                  +\n-help: if you change the return type to expect trait objects, box the returned expressions\n-   |\n-LL ~         return Box::new(0i32);\n-LL |     } else {\n-LL ~         return Box::new(1u32);\n-   |\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:20:9\n    |\n LL | fn baz() -> impl std::fmt::Display {\n-   |             ---------------------- expected because this return type...\n-LL |     if false {\n-LL |         return 0i32;\n-   |                ---- ...is found to be `i32` here\n-LL |     } else {\n+   |             ---------------------- expected `_` because of return type\n+...\n LL |         1u32\n    |         ^^^^ expected `i32`, found `u32`\n-   |\n-   = note: to return `impl Trait`, all returned values must be of the same type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: you could instead create a new `enum` with a variant for each returned type\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn baz() -> Box<dyn std::fmt::Display> {\n-   |             ~~~~~~~                  +\n-help: if you change the return type to expect trait objects, box the returned expressions\n-   |\n-LL ~         return Box::new(0i32);\n-LL |     } else {\n-LL ~         Box::new(1u32)\n-   |\n \n error[E0308]: `if` and `else` have incompatible types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:28:9\n@@ -90,100 +36,36 @@ LL | |         1u32\n    | |         ^^^^ expected `i32`, found `u32`\n LL | |     }\n    | |_____- `if` and `else` have incompatible types\n-   |\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn qux() -> Box<dyn std::fmt::Display> {\n-   |             ~~~~~~~                  +\n-help: if you change the return type to expect trait objects, box the returned expressions\n-   |\n-LL ~         Box::new(0i32)\n-LL |     } else {\n-LL ~         Box::new(1u32)\n-   |\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:35:14\n    |\n LL | fn bat() -> impl std::fmt::Display {\n-   |             ---------------------- expected because this return type...\n-LL |     match 13 {\n-LL |         0 => return 0i32,\n-   |                     ---- ...is found to be `i32` here\n+   |             ---------------------- expected `_` because of return type\n+...\n LL |         _ => 1u32,\n    |              ^^^^ expected `i32`, found `u32`\n-   |\n-   = note: to return `impl Trait`, all returned values must be of the same type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: you could instead create a new `enum` with a variant for each returned type\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn bat() -> Box<dyn std::fmt::Display> {\n-   |             ~~~~~~~                  +\n-help: if you change the return type to expect trait objects, box the returned expressions\n-   |\n-LL ~         0 => return Box::new(0i32),\n-LL ~         _ => Box::new(1u32),\n-   |\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:40:5\n    |\n LL |   fn can() -> impl std::fmt::Display {\n-   |               ---------------------- expected because this return type...\n+   |               ---------------------- expected `_` because of return type\n LL | /     match 13 {\n LL | |         0 => return 0i32,\n-   | |                     ---- ...is found to be `i32` here\n LL | |         1 => 1u32,\n LL | |         _ => 2u32,\n LL | |     }\n    | |_____^ expected `i32`, found `u32`\n-   |\n-   = note: to return `impl Trait`, all returned values must be of the same type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: you could instead create a new `enum` with a variant for each returned type\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn can() -> Box<dyn std::fmt::Display> {\n-   |             ~~~~~~~                  +\n-help: if you change the return type to expect trait objects, box the returned expressions\n-   |\n-LL ~     Box::new(match 13 {\n-LL ~         0 => return Box::new(0i32),\n-LL |         1 => 1u32,\n-LL |         _ => 2u32,\n-LL ~     })\n-   |\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:53:13\n    |\n LL | fn cat() -> impl std::fmt::Display {\n-   |             ---------------------- expected because this return type...\n-...\n-LL |             return 0i32;\n-   |                    ---- ...is found to be `i32` here\n+   |             ---------------------- expected `_` because of return type\n ...\n LL |             1u32\n    |             ^^^^ expected `i32`, found `u32`\n-   |\n-   = note: to return `impl Trait`, all returned values must be of the same type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: you could instead create a new `enum` with a variant for each returned type\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn cat() -> Box<dyn std::fmt::Display> {\n-   |             ~~~~~~~                  +\n-help: if you change the return type to expect trait objects, box the returned expressions\n-   |\n-LL ~             return Box::new(0i32);\n-LL |         }\n-LL |         _ => {\n-LL ~             Box::new(1u32)\n-   |\n \n error[E0308]: `match` arms have incompatible types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:61:14\n@@ -196,16 +78,6 @@ LL | |         1 => 1u32,\n LL | |         _ => 2u32,\n LL | |     }\n    | |_____- `match` arms have incompatible types\n-   |\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn dog() -> Box<dyn std::fmt::Display> {\n-   |             ~~~~~~~                  +\n-help: if you change the return type to expect trait objects, box the returned expressions\n-   |\n-LL ~         0 => Box::new(0i32),\n-LL ~         1 => Box::new(1u32),\n-   |\n \n error[E0308]: `if` and `else` have incompatible types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:97:9\n@@ -218,17 +90,6 @@ LL | |         1u32\n    | |         ^^^^ expected `i32`, found `u32`\n LL | |     }\n    | |_____- `if` and `else` have incompatible types\n-   |\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn apt() -> Box<dyn std::fmt::Display> {\n-   |             ~~~~~~~                  +\n-help: if you change the return type to expect trait objects, box the returned expressions\n-   |\n-LL ~         Box::new(0i32)\n-LL |     } else {\n-LL ~         Box::new(1u32)\n-   |\n \n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:66:13"}, {"sha": "ade0dfa1bb3b3e347d0161aa271a8683586728b2", "filename": "src/test/ui/impl-trait/projection-mismatch-in-impl-where-clause.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fprojection-mismatch-in-impl-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fprojection-mismatch-in-impl-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fprojection-mismatch-in-impl-where-clause.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -4,7 +4,7 @@ error[E0271]: type mismatch resolving `<() as Super>::Assoc == ()`\n LL | fn test() -> impl Test {\n    |              ^^^^^^^^^ type mismatch resolving `<() as Super>::Assoc == ()`\n    |\n-note: expected this to be `()`\n+note: expected this to be `u8`\n   --> $DIR/projection-mismatch-in-impl-where-clause.rs:6:18\n    |\n LL |     type Assoc = u8;"}, {"sha": "b33802e2bc8dafd4517785d279ab5683c446ba29", "filename": "src/test/ui/impl-trait/projection.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fprojection.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,29 @@\n+// build-pass\n+// needs to be build-pass, because it is a regression test for a mir validation failure\n+// that only happens during codegen.\n+\n+struct D;\n+\n+trait Tr {\n+    type It;\n+    fn foo(self) -> Option<Self::It>;\n+}\n+\n+impl<'a> Tr for &'a D {\n+    type It = ();\n+    fn foo(self) -> Option<()> { None }\n+}\n+\n+fn run<F>(f: F)\n+    where for<'a> &'a D: Tr,\n+          F: Fn(<&D as Tr>::It),\n+{\n+    let d = &D;\n+    while let Some(i) = d.foo() {\n+        f(i);\n+    }\n+}\n+\n+fn main() {\n+    run(|_| {});\n+}"}, {"sha": "7bd5cff31bbdf578623e6833e354930a12a1ee87", "filename": "src/test/ui/impl-trait/question_mark.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fquestion_mark.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,30 @@\n+// check-pass\n+\n+use std::fmt::Debug;\n+\n+#[derive(Debug)]\n+pub struct Target;\n+\n+#[derive(Debug)]\n+pub struct Source;\n+impl From<Source> for Target {\n+    fn from(_: Source) -> Self {\n+        Self\n+    }\n+}\n+\n+fn maybe_source() -> Result<(), Source> {\n+    todo!()\n+}\n+\n+pub fn typaram() -> Result<(), impl Debug> {\n+    maybe_source()?;\n+    Ok::<_, Target>(())\n+}\n+\n+pub fn direct() -> Result<(), impl Debug> {\n+    maybe_source()?;\n+    Err(Target)\n+}\n+\n+fn main() {}"}, {"sha": "540a280f0a319d8303a3071b786b987edd2ea5a4", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-direct.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,9 +1,8 @@\n-// Test that an `impl Trait` type that expands to itself is an error.\n+// check-pass\n \n #![allow(unconditional_recursion)]\n \n fn test() -> impl Sized {\n-    //~^ ERROR E0720\n     test()\n }\n "}, {"sha": "5a3027ec751a91126268ddd7bc3eb8691c248246", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-direct.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1446d17b8f4bd3ff8dbfb129a7674165e06f9f4c/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1446d17b8f4bd3ff8dbfb129a7674165e06f9f4c/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.stderr?ref=1446d17b8f4bd3ff8dbfb129a7674165e06f9f4c", "patch": "@@ -1,12 +0,0 @@\n-error[E0720]: cannot resolve opaque type\n-  --> $DIR/recursive-impl-trait-type-direct.rs:5:14\n-   |\n-LL | fn test() -> impl Sized {\n-   |              ^^^^^^^^^^ recursive opaque type\n-LL |\n-LL |     test()\n-   |     ------ returning here with type `impl Sized`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0720`."}, {"sha": "ffc0cd9d10c34fc9e4bbbf05b38769b5f1b95e5b", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-indirect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -5,7 +5,7 @@\n #![allow(unconditional_recursion)]\n \n fn option(i: i32) -> impl Sized {\n-    //~^ ERROR\n+    //~^ ERROR cannot resolve opaque type\n     if i < 0 { None } else { Some((option(i - 1), i)) }\n }\n "}, {"sha": "6b200d7e3a89eeb6c615ba0b5dc6f71fc476d178", "filename": "src/test/ui/impl-trait/recursive-type-alias-impl-trait-declaration-too-subtle-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle-2.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,17 @@\n+#![feature(type_alias_impl_trait)]\n+\n+type Foo = impl PartialEq<(Foo, i32)>;\n+\n+struct Bar;\n+\n+impl PartialEq<(Foo, i32)> for Bar {\n+    fn eq(&self, _other: &(Foo, i32)) -> bool {\n+        true\n+    }\n+}\n+\n+fn foo() -> Foo {\n+    Bar //~ ERROR can't compare `Bar` with `(Bar, i32)`\n+}\n+\n+fn main() {}"}, {"sha": "5476bf9d27745d9373b1daf74885f5a4f37b626d", "filename": "src/test/ui/impl-trait/recursive-type-alias-impl-trait-declaration-too-subtle-2.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle-2.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,11 @@\n+error[E0277]: can't compare `Bar` with `(Bar, i32)`\n+  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle-2.rs:14:5\n+   |\n+LL |     Bar\n+   |     ^^^ no implementation for `Bar == (Bar, i32)`\n+   |\n+   = help: the trait `PartialEq<(Bar, i32)>` is not implemented for `Bar`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "6aa832cde71ee7c3ec6788b15d7b684045247e1a", "filename": "src/test/ui/impl-trait/recursive-type-alias-impl-trait-declaration-too-subtle.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,30 @@\n+#![feature(type_alias_impl_trait)]\n+\n+mod a {\n+    type Foo = impl PartialEq<(Foo, i32)>;\n+    //~^ ERROR unconstrained opaque type\n+\n+    struct Bar;\n+\n+    impl PartialEq<(Bar, i32)> for Bar {\n+        fn eq(&self, _other: &(Foo, i32)) -> bool {\n+            true\n+        }\n+    }\n+}\n+\n+mod b {\n+    type Foo = impl PartialEq<(Foo, i32)>;\n+    //~^ ERROR unconstrained opaque type\n+\n+    struct Bar;\n+\n+    impl PartialEq<(Foo, i32)> for Bar {\n+        fn eq(&self, _other: &(Bar, i32)) -> bool {\n+            //~^ ERROR impl has stricter requirements than trait\n+            true\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "19d5cdb9d0ac6f0f0363e1a20318c9e7a1a4b106", "filename": "src/test/ui/impl-trait/recursive-type-alias-impl-trait-declaration-too-subtle.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,25 @@\n+error: unconstrained opaque type\n+  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:4:16\n+   |\n+LL |     type Foo = impl PartialEq<(Foo, i32)>;\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `Foo` must be used in combination with a concrete type within the same module\n+\n+error: unconstrained opaque type\n+  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:17:16\n+   |\n+LL |     type Foo = impl PartialEq<(Foo, i32)>;\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `Foo` must be used in combination with a concrete type within the same module\n+\n+error[E0276]: impl has stricter requirements than trait\n+  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:23:9\n+   |\n+LL |         fn eq(&self, _other: &(Bar, i32)) -> bool {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `b::Bar: PartialEq<(b::Bar, i32)>`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0276`."}, {"sha": "ad0a003e87948ec9279fce45edcbee650754dedc", "filename": "src/test/ui/impl-trait/recursive-type-alias-impl-trait-declaration.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,19 @@\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+type Foo = impl PartialEq<(Foo, i32)>;\n+\n+struct Bar;\n+\n+impl PartialEq<(Bar, i32)> for Bar {\n+    fn eq(&self, _other: &(Bar, i32)) -> bool {\n+        true\n+    }\n+}\n+\n+fn foo() -> Foo {\n+    Bar\n+}\n+\n+fn main() {}"}, {"sha": "a04cb1702b6388a190e5a58b1993acb9a69f9c36", "filename": "src/test/ui/impl-trait/region-escape-via-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -12,10 +12,10 @@ trait Trait<'a> { }\n impl<'a, 'b> Trait<'b> for Cell<&'a u32> { }\n \n fn foo<'x, 'y>(x: Cell<&'x u32>) -> impl Trait<'y>\n-    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds [E0700]\n where 'x: 'y\n {\n     x\n+    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds [E0700]\n }\n \n fn main() { }"}, {"sha": "bc02f7694d7f68d0c8f11f106bc346f2b7839886", "filename": "src/test/ui/impl-trait/region-escape-via-bound.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,10 +1,11 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/region-escape-via-bound.rs:14:37\n+  --> $DIR/region-escape-via-bound.rs:17:5\n    |\n LL | fn foo<'x, 'y>(x: Cell<&'x u32>) -> impl Trait<'y>\n-   |        --                           ^^^^^^^^^^^^^^\n-   |        |\n-   |        hidden type `Cell<&'x u32>` captures the lifetime `'x` as defined here\n+   |        -- hidden type `Cell<&'x u32>` captures the lifetime `'x` as defined here\n+...\n+LL |     x\n+   |     ^\n    |\n help: to declare that the `impl Trait` captures `'x`, you can add an explicit `'x` lifetime bound\n    |"}, {"sha": "f940c1949d0b8345be0c2102b0702330e97bae2d", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -4,14 +4,14 @@ struct A {\n \n impl A {\n     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n+        self.x.iter().map(|a| a.0)\n         //~^ ERROR: captures lifetime that does not appear in bounds\n         //~| ERROR: captures lifetime that does not appear in bounds\n-        self.x.iter().map(|a| a.0)\n     }\n     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n+        self.x.iter().map(|a| a.0)\n         //~^ ERROR: captures lifetime that does not appear in bounds\n         //~| ERROR: captures lifetime that does not appear in bounds\n-        self.x.iter().map(|a| a.0)\n     }\n }\n "}, {"sha": "bc8e39f9c504cf7380ce0cdbe7325a1735a694d6", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,49 +1,49 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/static-return-lifetime-infered.rs:6:35\n+  --> $DIR/static-return-lifetime-infered.rs:7:9\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n-   |                         -----     ^^^^^^^^^^^^^^^^^^^^^^^\n-   |                         |\n-   |                         hidden type `Map<std::slice::Iter<'_, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:9:27: 9:34]>` captures the anonymous lifetime defined here\n+   |                         ----- hidden type `Map<std::slice::Iter<'_, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:7:27: 7:34]>` captures the anonymous lifetime defined here\n+LL |         self.x.iter().map(|a| a.0)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: to declare that the `impl Trait` captures `'_`, you can add an explicit `'_` lifetime bound\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + '_ {\n    |                                                           ++++\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/static-return-lifetime-infered.rs:6:35\n+  --> $DIR/static-return-lifetime-infered.rs:7:9\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n-   |                         -----     ^^^^^^^^^^^^^^^^^^^^^^^\n-   |                         |\n-   |                         hidden type `Map<std::slice::Iter<'_, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:9:27: 9:34]>` captures the anonymous lifetime defined here\n+   |                         ----- hidden type `Map<std::slice::Iter<'_, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:7:27: 7:34]>` captures the anonymous lifetime defined here\n+LL |         self.x.iter().map(|a| a.0)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: to declare that the `impl Trait` captures `'_`, you can add an explicit `'_` lifetime bound\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + '_ {\n    |                                                           ++++\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/static-return-lifetime-infered.rs:11:37\n+  --> $DIR/static-return-lifetime-infered.rs:12:9\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n-   |                    --               ^^^^^^^^^^^^^^^^^^^^^^^\n-   |                    |\n-   |                    hidden type `Map<std::slice::Iter<'a, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:14:27: 14:34]>` captures the lifetime `'a` as defined here\n+   |                    -- hidden type `Map<std::slice::Iter<'a, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:12:27: 12:34]>` captures the lifetime `'a` as defined here\n+LL |         self.x.iter().map(|a| a.0)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: to declare that the `impl Trait` captures `'a`, you can add an explicit `'a` lifetime bound\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> + 'a {\n    |                                                             ++++\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/static-return-lifetime-infered.rs:11:37\n+  --> $DIR/static-return-lifetime-infered.rs:12:9\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n-   |                    --               ^^^^^^^^^^^^^^^^^^^^^^^\n-   |                    |\n-   |                    hidden type `Map<std::slice::Iter<'a, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:14:27: 14:34]>` captures the lifetime `'a` as defined here\n+   |                    -- hidden type `Map<std::slice::Iter<'a, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:12:27: 12:34]>` captures the lifetime `'a` as defined here\n+LL |         self.x.iter().map(|a| a.0)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: to declare that the `impl Trait` captures `'a`, you can add an explicit `'a` lifetime bound\n    |"}, {"sha": "8dcbbfd6e6492622fea9c286fa5c1c963b9ae74d", "filename": "src/test/ui/impl-trait/trait_resolution.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Ftrait_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Ftrait_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftrait_resolution.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,30 @@\n+// check-pass\n+\n+use std::fmt::Debug;\n+\n+pub struct EventStream<S> {\n+    stream: S,\n+}\n+\n+impl<S: Debug> EventStream<S> {\n+    fn into_stream(self) -> impl Debug {\n+        unimplemented!()\n+    }\n+\n+    pub fn into_reader(self) -> impl Debug {\n+        ReaderStream::from(self.into_stream())\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct ReaderStream<S> {\n+    stream: S,\n+}\n+\n+impl<S> From<S> for ReaderStream<S> {\n+    fn from(stream: S) -> Self {\n+        ReaderStream { stream }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "6eb2a11b22c5f359e89099183bcdd64c9c54f301", "filename": "src/test/ui/impl-trait/two_tait_defining_each_other.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,19 @@\n+#![feature(type_alias_impl_trait)]\n+\n+type A = impl Foo;\n+type B = impl Foo;\n+\n+trait Foo {}\n+\n+fn muh(x: A) -> B {\n+    if false {\n+        return Bar; // B's hidden type is Bar\n+    }\n+    x // A's hidden type is `Bar`, because all the hidden types of `B` are compared with each other\n+    //~^ ERROR opaque type's hidden type cannot be another opaque type\n+}\n+\n+struct Bar;\n+impl Foo for Bar {}\n+\n+fn main() {}"}, {"sha": "1a42ac525a6a8f12f60f5a7b47f7ca4bf09d7714", "filename": "src/test/ui/impl-trait/two_tait_defining_each_other.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,19 @@\n+error: opaque type's hidden type cannot be another opaque type from the same scope\n+  --> $DIR/two_tait_defining_each_other.rs:12:5\n+   |\n+LL |     x // A's hidden type is `Bar`, because all the hidden types of `B` are compared with each other\n+   |     ^ one of the two opaque types used here has to be outside its defining scope\n+   |\n+note: opaque type whose hidden type is being assigned\n+  --> $DIR/two_tait_defining_each_other.rs:4:10\n+   |\n+LL | type B = impl Foo;\n+   |          ^^^^^^^^\n+note: opaque type being used as hidden type\n+  --> $DIR/two_tait_defining_each_other.rs:3:10\n+   |\n+LL | type A = impl Foo;\n+   |          ^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "05b09668016c47b8a836eeec7d06c84854f85c32", "filename": "src/test/ui/impl-trait/two_tait_defining_each_other2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other2.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,16 @@\n+#![feature(type_alias_impl_trait)]\n+\n+type A = impl Foo; //~ ERROR unconstrained opaque type\n+type B = impl Foo;\n+\n+trait Foo {}\n+\n+fn muh(x: A) -> B {\n+    x // B's hidden type is A (opaquely)\n+    //~^ ERROR opaque type's hidden type cannot be another opaque type\n+}\n+\n+struct Bar;\n+impl Foo for Bar {}\n+\n+fn main() {}"}, {"sha": "4d8f96de1626c500ad8648295ec2acf0944311be", "filename": "src/test/ui/impl-trait/two_tait_defining_each_other2.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other2.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,27 @@\n+error: unconstrained opaque type\n+  --> $DIR/two_tait_defining_each_other2.rs:3:10\n+   |\n+LL | type A = impl Foo;\n+   |          ^^^^^^^^\n+   |\n+   = note: `A` must be used in combination with a concrete type within the same module\n+\n+error: opaque type's hidden type cannot be another opaque type from the same scope\n+  --> $DIR/two_tait_defining_each_other2.rs:9:5\n+   |\n+LL |     x // B's hidden type is A (opaquely)\n+   |     ^ one of the two opaque types used here has to be outside its defining scope\n+   |\n+note: opaque type whose hidden type is being assigned\n+  --> $DIR/two_tait_defining_each_other2.rs:4:10\n+   |\n+LL | type B = impl Foo;\n+   |          ^^^^^^^^\n+note: opaque type being used as hidden type\n+  --> $DIR/two_tait_defining_each_other2.rs:3:10\n+   |\n+LL | type A = impl Foo;\n+   |          ^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "37f8ae1b84b55f50cd7ada951e389cd9b269d007", "filename": "src/test/ui/impl-trait/two_tait_defining_each_other3.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other3.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,19 @@\n+#![feature(type_alias_impl_trait)]\n+\n+type A = impl Foo;\n+type B = impl Foo;\n+\n+trait Foo {}\n+\n+fn muh(x: A) -> B {\n+    if false {\n+        return x;  // B's hidden type is A (opaquely)\n+        //~^ ERROR opaque type's hidden type cannot be another opaque type\n+    }\n+    Bar // A's hidden type is `Bar`, because all the return types are compared with each other\n+}\n+\n+struct Bar;\n+impl Foo for Bar {}\n+\n+fn main() {}"}, {"sha": "b06dc16d5e700c505e179dc37298a1881b473d2e", "filename": "src/test/ui/impl-trait/two_tait_defining_each_other3.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftwo_tait_defining_each_other3.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,19 @@\n+error: opaque type's hidden type cannot be another opaque type from the same scope\n+  --> $DIR/two_tait_defining_each_other3.rs:10:16\n+   |\n+LL |         return x;  // B's hidden type is A (opaquely)\n+   |                ^ one of the two opaque types used here has to be outside its defining scope\n+   |\n+note: opaque type whose hidden type is being assigned\n+  --> $DIR/two_tait_defining_each_other3.rs:4:10\n+   |\n+LL | type B = impl Foo;\n+   |          ^^^^^^^^\n+note: opaque type being used as hidden type\n+  --> $DIR/two_tait_defining_each_other3.rs:3:10\n+   |\n+LL | type A = impl Foo;\n+   |          ^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "b1175a5952e592a7a575da8413050c2e18f3d29f", "filename": "src/test/ui/impl-trait/type_parameters_captured.nll.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.nll.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,8 +1,8 @@\n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/type_parameters_captured.rs:7:20\n+  --> $DIR/type_parameters_captured.rs:10:5\n    |\n-LL | fn foo<T>(x: T) -> impl Any + 'static {\n-   |                    ^^^^^^^^^^^^^^^^^^\n+LL |     x\n+   |     ^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'static`...\n "}, {"sha": "bb9cab742a58f81bac9e25365b9a17b1e9058749", "filename": "src/test/ui/impl-trait/type_parameters_captured.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -6,6 +6,7 @@ impl<T> Any for T {}\n // Check that type parameters are captured and not considered 'static\n fn foo<T>(x: T) -> impl Any + 'static {\n     //~^ ERROR the parameter type `T` may not live long enough\n+    //~| ERROR the parameter type `T` may not live long enough\n     x\n }\n "}, {"sha": "c4ca34a6ed39b132148980921ab41588227d0df8", "filename": "src/test/ui/impl-trait/type_parameters_captured.stderr", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -6,6 +6,19 @@ LL | fn foo<T>(x: T) -> impl Any + 'static {\n    |        |\n    |        help: consider adding an explicit lifetime bound...: `T: 'static`\n \n-error: aborting due to previous error\n+error[E0310]: the parameter type `T` may not live long enough\n+  --> $DIR/type_parameters_captured.rs:7:39\n+   |\n+LL |   fn foo<T>(x: T) -> impl Any + 'static {\n+   |  ________-______________________________^\n+   | |        |\n+   | |        help: consider adding an explicit lifetime bound...: `T: 'static`\n+LL | |\n+LL | |\n+LL | |     x\n+LL | | }\n+   | |_^ ...so that the type `T` will meet its required lifetime bounds\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0310`."}, {"sha": "d5a87b5d468340b3673d52c926b971597a9cc834", "filename": "src/test/ui/impl-trait/where-allowed-2.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,8 +1,7 @@\n-//! Ideally, these tests would go in `where-allowed.rs`, but we bail out\n-//! too early to display them.\n use std::fmt::Debug;\n \n-// Disallowed\n-fn in_adt_in_return() -> Vec<impl Debug> { panic!() } //~ ERROR cannot resolve opaque type\n+// check-pass\n+\n+fn in_adt_in_return() -> Vec<impl Debug> { panic!() }\n \n fn main() {}"}, {"sha": "b8e06725cbcdd6493683dc2ca34fd4d775d5cc27", "filename": "src/test/ui/impl-trait/where-allowed-2.stderr", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1446d17b8f4bd3ff8dbfb129a7674165e06f9f4c/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1446d17b8f4bd3ff8dbfb129a7674165e06f9f4c/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.stderr?ref=1446d17b8f4bd3ff8dbfb129a7674165e06f9f4c", "patch": "@@ -1,13 +0,0 @@\n-error[E0720]: cannot resolve opaque type\n-  --> $DIR/where-allowed-2.rs:6:30\n-   |\n-LL | fn in_adt_in_return() -> Vec<impl Debug> { panic!() }\n-   |                              ^^^^^^^^^^    -------- this returned value is of `!` type\n-   |                              |\n-   |                              cannot resolve opaque type\n-   |\n-   = help: this error will resolve once the item's body returns a concrete type\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0720`."}, {"sha": "fde59f39b1cd9017e8ed309f4eb6d79bf3c6bea5", "filename": "src/test/ui/issues-71798.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fissues-71798.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fissues-71798.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues-71798.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,5 +1,7 @@\n fn test_ref(x: &u32) -> impl std::future::Future<Output = u32> + '_ {\n-    *x //~^ ERROR `u32` is not a future\n+    //~^ ERROR `u32` is not a future\n+    //~| ERROR `u32` is not a future\n+    *x\n }\n \n fn main() {"}, {"sha": "63669c0513d6491c3c943bbf549ba7d05f19bd5d", "filename": "src/test/ui/issues-71798.stderr", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fissues-71798.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fissues-71798.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues-71798.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,5 +1,5 @@\n error[E0425]: cannot find value `u` in this scope\n-  --> $DIR/issues-71798.rs:6:24\n+  --> $DIR/issues-71798.rs:8:24\n    |\n LL |     let _ = test_ref & u;\n    |                        ^ not found in this scope\n@@ -13,7 +13,21 @@ LL | fn test_ref(x: &u32) -> impl std::future::Future<Output = u32> + '_ {\n    = help: the trait `Future` is not implemented for `u32`\n    = note: u32 must be a future or must implement `IntoFuture` to be awaited\n \n-error: aborting due to 2 previous errors\n+error[E0277]: `u32` is not a future\n+  --> $DIR/issues-71798.rs:1:69\n+   |\n+LL |   fn test_ref(x: &u32) -> impl std::future::Future<Output = u32> + '_ {\n+   |  _____________________________________________________________________^\n+LL | |\n+LL | |\n+LL | |     *x\n+LL | | }\n+   | |_^ `u32` is not a future\n+   |\n+   = help: the trait `Future` is not implemented for `u32`\n+   = note: u32 must be a future or must implement `IntoFuture` to be awaited\n+\n+error: aborting due to 3 previous errors\n \n Some errors have detailed explanations: E0277, E0425.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "aa172f3f19b6b3288fce71f4da4880beb528011d", "filename": "src/test/ui/lazy-type-alias-impl-trait/branches.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,14 @@\n+#![feature(type_alias_impl_trait)]\n+\n+type Foo = impl std::fmt::Debug;\n+\n+fn foo(b: bool) -> Foo {\n+    if b {\n+        vec![42_i32]\n+    } else {\n+        std::iter::empty().collect()\n+        //~^ ERROR `Foo` cannot be built from an iterator over elements of type `_`\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "c3902f34706bd3bf01a7de6d56aaad36044ad043", "filename": "src/test/ui/lazy-type-alias-impl-trait/branches.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,16 @@\n+error[E0277]: a value of type `Foo` cannot be built from an iterator over elements of type `_`\n+  --> $DIR/branches.rs:9:28\n+   |\n+LL |         std::iter::empty().collect()\n+   |                            ^^^^^^^ value of type `Foo` cannot be built from `std::iter::Iterator<Item=_>`\n+   |\n+   = help: the trait `FromIterator<_>` is not implemented for `Foo`\n+note: required by a bound in `collect`\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `collect`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "af605e4d8062dbb7fc809962fee0a2cd5943018a", "filename": "src/test/ui/lazy-type-alias-impl-trait/branches2.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches2.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,28 @@\n+#![feature(type_alias_impl_trait)]\n+\n+// run-pass\n+\n+type Foo = impl std::iter::FromIterator<i32> + PartialEq<Vec<i32>> + std::fmt::Debug;\n+\n+fn foo(b: bool) -> Foo {\n+    if b {\n+        vec![42_i32]\n+    } else {\n+        std::iter::empty().collect()\n+    }\n+}\n+\n+fn bar(b: bool) -> impl PartialEq<Vec<i32>> + std::fmt::Debug {\n+    if b {\n+        vec![42_i32]\n+    } else {\n+        std::iter::empty().collect()\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(foo(true), vec![42]);\n+    assert_eq!(foo(false), vec![]);\n+    assert_eq!(bar(true), vec![42]);\n+    assert_eq!(bar(false), vec![]);\n+}"}, {"sha": "10f6bd74031ac7324b1b1d7271dda397255464d6", "filename": "src/test/ui/lazy-type-alias-impl-trait/freeze_cycle.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Ffreeze_cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Ffreeze_cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Ffreeze_cycle.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,46 @@\n+// check-pass\n+\n+#![feature(gen_future, generator_trait, negative_impls)]\n+\n+use std::ops::{Generator, GeneratorState};\n+use std::task::{Poll, Context};\n+use std::future::{Future};\n+use std::ptr::NonNull;\n+use std::pin::Pin;\n+\n+fn main() {}\n+\n+#[derive(Debug, Copy, Clone)]\n+pub struct ResumeTy(NonNull<Context<'static>>);\n+\n+unsafe impl Send for ResumeTy {}\n+\n+unsafe impl Sync for ResumeTy {}\n+\n+pub const fn from_generator<T>(gen: T) -> impl Future<Output = T::Return>\n+where\n+    T: Generator<ResumeTy, Yield = ()>,\n+{\n+    struct GenFuture<T: Generator<ResumeTy, Yield = ()>>(T);\n+\n+    // We rely on the fact that async/await futures are immovable in order to create\n+    // self-referential borrows in the underlying generator.\n+    impl<T: Generator<ResumeTy, Yield = ()>> !Unpin for GenFuture<T> {}\n+\n+    impl<T: Generator<ResumeTy, Yield = ()>> Future for GenFuture<T> {\n+        type Output = T::Return;\n+        fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n+            // SAFETY: Safe because we're !Unpin + !Drop, and this is just a field projection.\n+            let gen = unsafe { Pin::map_unchecked_mut(self, |s| &mut s.0) };\n+\n+            // Resume the generator, turning the `&mut Context` into a `NonNull` raw pointer. The\n+            // `.await` lowering will safely cast that back to a `&mut Context`.\n+            match gen.resume(ResumeTy(NonNull::from(cx).cast::<Context<'static>>())) {\n+                GeneratorState::Yielded(()) => Poll::Pending,\n+                GeneratorState::Complete(x) => Poll::Ready(x),\n+            }\n+        }\n+    }\n+\n+    GenFuture(gen)\n+}"}, {"sha": "d07d732c78570c74368044af764d6983cee5652c", "filename": "src/test/ui/lazy-type-alias-impl-trait/infer_cross_function.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Finfer_cross_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Finfer_cross_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Finfer_cross_function.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,27 @@\n+// check-pass\n+\n+fn main() {}\n+\n+trait Reader {}\n+\n+struct Unit<R>(R);\n+struct ResDwarf<R>(R);\n+\n+struct Context<R: Reader> {\n+    dwarf: ResDwarf<R>,\n+}\n+\n+struct Range;\n+\n+struct ResUnit<R>(R);\n+\n+impl<R: Reader + 'static> Context<R> {\n+    fn find_dwarf_unit(&self, probe: u64) -> Option<&Unit<R>> {\n+        let x = self.find_units(probe);\n+        None\n+    }\n+\n+    fn find_units(&self, probe: u64) -> impl Iterator<Item = &ResUnit<R>> {\n+        std::iter::empty()\n+    }\n+}"}, {"sha": "f75a88aa8f0645da33663b44e051b2a00a682f69", "filename": "src/test/ui/lazy-type-alias-impl-trait/lifetime_inference.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Flifetime_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Flifetime_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Flifetime_inference.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,7 @@\n+// check-pass\n+\n+fn main() {}\n+\n+fn nth<I: Iterator>(iter: &mut I, step: usize) -> impl FnMut() -> Option<I::Item> + '_ {\n+    move || iter.nth(step)\n+}"}, {"sha": "f8291112739c116d0550b51f13b281a5747c40b8", "filename": "src/test/ui/lazy-type-alias-impl-trait/nested.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fnested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fnested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fnested.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,23 @@\n+// check-pass\n+\n+fn main() {}\n+\n+struct RawTableInner<A> {\n+    alloc: A,\n+}\n+\n+impl<A> RawTableInner<A> {\n+    fn prepare_resize(\n+        self,\n+    ) -> ScopeGuard<Self, impl FnMut(&mut Self)> {\n+        ScopeGuard { dropfn: move |self_| {}, value: self,  }\n+    }\n+}\n+\n+pub struct ScopeGuard<T, F>\n+where\n+    F: FnMut(&mut T),\n+{\n+    dropfn: F,\n+    value: T,\n+}"}, {"sha": "8d03b5158d66278c4521a579b743d3574d0c2ade", "filename": "src/test/ui/lazy-type-alias-impl-trait/opaque_vs_opaque.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fopaque_vs_opaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fopaque_vs_opaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fopaque_vs_opaque.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+\n+fn main() {}\n+\n+fn filter_fold<T, Acc, PRED: FnMut(&T) -> bool, FOLD: FnMut(Acc, T) -> Acc>(\n+    mut predicate: PRED,\n+    mut fold: FOLD,\n+) -> impl FnMut(Acc, T) -> Acc {\n+    move |acc, item| if predicate(&item) { fold(acc, item) } else { acc }\n+}"}, {"sha": "cf7cd5d26ca2fb31fa553016add112ddec9b673a", "filename": "src/test/ui/lazy-type-alias-impl-trait/recursion.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,23 @@\n+#![feature(type_alias_impl_trait)]\n+\n+// check-pass\n+\n+type Foo = impl std::fmt::Debug;\n+\n+fn foo(b: bool) -> Foo {\n+    if b {\n+        return 42\n+    }\n+    let x: u32 = foo(false);\n+    99\n+}\n+\n+fn bar(b: bool) -> impl std::fmt::Debug {\n+    if b {\n+        return 42\n+    }\n+    let x: u32 = bar(false);\n+    99\n+}\n+\n+fn main() {}"}, {"sha": "1cc64ea17e79e71cea76cefb6aa216f23f195500", "filename": "src/test/ui/lazy-type-alias-impl-trait/recursion2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion2.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,21 @@\n+#![feature(type_alias_impl_trait)]\n+\n+type Foo = impl std::fmt::Debug;\n+\n+fn foo(b: bool) -> Foo {\n+    if b {\n+        return vec![];\n+    }\n+    let x: Vec<i32> = foo(false);\n+    std::iter::empty().collect() //~ ERROR `Foo` cannot be built from an iterator\n+}\n+\n+fn bar(b: bool) -> impl std::fmt::Debug {\n+    if b {\n+        return vec![]\n+    }\n+    let x: Vec<i32> = bar(false);\n+    std::iter::empty().collect()\n+}\n+\n+fn main() {}"}, {"sha": "1f6201a8300c6dacc29aedef98bb0c9f600c1f95", "filename": "src/test/ui/lazy-type-alias-impl-trait/recursion2.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion2.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,16 @@\n+error[E0277]: a value of type `Foo` cannot be built from an iterator over elements of type `_`\n+  --> $DIR/recursion2.rs:10:24\n+   |\n+LL |     std::iter::empty().collect()\n+   |                        ^^^^^^^ value of type `Foo` cannot be built from `std::iter::Iterator<Item=_>`\n+   |\n+   = help: the trait `FromIterator<_>` is not implemented for `Foo`\n+note: required by a bound in `collect`\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `collect`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "7f1cedae068f02770721c8c190a4564c07c1cdc5", "filename": "src/test/ui/lazy-type-alias-impl-trait/recursion3.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion3.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,21 @@\n+#![feature(type_alias_impl_trait)]\n+\n+type Foo = impl std::fmt::Debug;\n+\n+fn foo(b: bool) -> Foo {\n+    if b {\n+        return 42\n+    }\n+    let x: u32 = foo(false) + 42; //~ ERROR cannot add\n+    99\n+}\n+\n+fn bar(b: bool) -> impl std::fmt::Debug {\n+    if b {\n+        return 42\n+    }\n+    let x: u32 = bar(false) + 42; //~ ERROR cannot add\n+    99\n+}\n+\n+fn main() {}"}, {"sha": "e1d5cafedc808ecd313fd1c4a7442dcad9117ffd", "filename": "src/test/ui/lazy-type-alias-impl-trait/recursion3.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion3.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,19 @@\n+error[E0369]: cannot add `{integer}` to `Foo`\n+  --> $DIR/recursion3.rs:9:29\n+   |\n+LL |     let x: u32 = foo(false) + 42;\n+   |                  ---------- ^ -- {integer}\n+   |                  |\n+   |                  Foo\n+\n+error[E0369]: cannot add `{integer}` to `impl Debug`\n+  --> $DIR/recursion3.rs:17:29\n+   |\n+LL |     let x: u32 = bar(false) + 42;\n+   |                  ---------- ^ -- {integer}\n+   |                  |\n+   |                  impl Debug\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0369`."}, {"sha": "57dd7fb067c6d10fca63e1f16c46647ef58b5040", "filename": "src/test/ui/lazy-type-alias-impl-trait/recursion4.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion4.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,23 @@\n+#![feature(type_alias_impl_trait)]\n+\n+type Foo = impl std::fmt::Debug;\n+\n+fn foo(b: bool) -> Foo {\n+    if b {\n+        return vec![];\n+    }\n+    let mut x = foo(false);\n+    x = std::iter::empty().collect(); //~ ERROR `Foo` cannot be built from an iterator\n+    vec![]\n+}\n+\n+fn bar(b: bool) -> impl std::fmt::Debug {\n+    if b {\n+        return vec![];\n+    }\n+    let mut x = bar(false);\n+    x = std::iter::empty().collect(); //~ ERROR `impl Debug` cannot be built from an iterator\n+    vec![]\n+}\n+\n+fn main() {}"}, {"sha": "42a1f782d299d651e0e5a720a84ef4f1bfbbb8e9", "filename": "src/test/ui/lazy-type-alias-impl-trait/recursion4.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Frecursion4.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,29 @@\n+error[E0277]: a value of type `Foo` cannot be built from an iterator over elements of type `_`\n+  --> $DIR/recursion4.rs:10:28\n+   |\n+LL |     x = std::iter::empty().collect();\n+   |                            ^^^^^^^ value of type `Foo` cannot be built from `std::iter::Iterator<Item=_>`\n+   |\n+   = help: the trait `FromIterator<_>` is not implemented for `Foo`\n+note: required by a bound in `collect`\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `collect`\n+\n+error[E0277]: a value of type `impl Debug` cannot be built from an iterator over elements of type `_`\n+  --> $DIR/recursion4.rs:19:28\n+   |\n+LL |     x = std::iter::empty().collect();\n+   |                            ^^^^^^^ value of type `impl Debug` cannot be built from `std::iter::Iterator<Item=_>`\n+   |\n+   = help: the trait `FromIterator<_>` is not implemented for `impl Debug`\n+note: required by a bound in `collect`\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `collect`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "007101498238d7f12fc52fabec521565a7b97056", "filename": "src/test/ui/lazy-type-alias-impl-trait/unsized_sized_opaque.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Funsized_sized_opaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Funsized_sized_opaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Funsized_sized_opaque.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+\n+fn main() {}\n+\n+pub struct PairSlices<'a, 'b, T> {\n+    pub(crate) a0: &'a mut [T],\n+    pub(crate) a1: &'a mut [T],\n+    pub(crate) b0: &'b [T],\n+    pub(crate) b1: &'b [T],\n+}\n+\n+impl<'a, 'b, T> PairSlices<'a, 'b, T> {\n+    pub fn remainder(self) -> impl Iterator<Item = &'b [T]> {\n+        IntoIterator::into_iter([self.b0, self.b1])\n+    }\n+}"}, {"sha": "133679f30f8fb4435a1177c8a1346f311191dc2f", "filename": "src/test/ui/lifetimes/lifetime-elision-return-type-trait.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -6,7 +6,8 @@ trait Future {\n use std::error::Error;\n \n fn foo() -> impl Future<Item=(), Error=Box<dyn Error>> {\n-//~^ ERROR not satisfied\n+    //~^ ERROR not satisfied\n+    //~| ERROR not satisfied\n     Ok(())\n }\n "}, {"sha": "a3badd7b25add4ab77032aa9862000749917d917", "filename": "src/test/ui/lifetimes/lifetime-elision-return-type-trait.stderr", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -4,6 +4,17 @@ error[E0277]: the trait bound `Result<(), _>: Future` is not satisfied\n LL | fn foo() -> impl Future<Item=(), Error=Box<dyn Error>> {\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Future` is not implemented for `Result<(), _>`\n \n-error: aborting due to previous error\n+error[E0277]: the trait bound `Result<(), _>: Future` is not satisfied\n+  --> $DIR/lifetime-elision-return-type-trait.rs:8:56\n+   |\n+LL |   fn foo() -> impl Future<Item=(), Error=Box<dyn Error>> {\n+   |  ________________________________________________________^\n+LL | |\n+LL | |\n+LL | |     Ok(())\n+LL | | }\n+   | |_^ the trait `Future` is not implemented for `Result<(), _>`\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "13dab7ed954f85b5ec7a13da761a91ab95f42c84", "filename": "src/test/ui/lint/inline-trait-and-foreign-items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Finline-trait-and-foreign-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Finline-trait-and-foreign-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Finline-trait-and-foreign-items.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -23,7 +23,7 @@ impl Trait for () {\n     type T = Self;\n \n     #[inline] //~ ERROR attribute should be applied to function or closure\n-    type U = impl Trait; //~ ERROR could not find defining uses\n+    type U = impl Trait; //~ ERROR unconstrained opaque type\n }\n \n extern \"C\" {"}, {"sha": "fc7e89e4f4cce6dae3bf812d0c727aa7ef1c5746", "filename": "src/test/ui/lint/inline-trait-and-foreign-items.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Finline-trait-and-foreign-items.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Finline-trait-and-foreign-items.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Finline-trait-and-foreign-items.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -61,11 +61,13 @@ LL |     #[inline]\n LL |     type T;\n    |     ------- not a function or closure\n \n-error: could not find defining uses\n+error: unconstrained opaque type\n   --> $DIR/inline-trait-and-foreign-items.rs:26:14\n    |\n LL |     type U = impl Trait;\n    |              ^^^^^^^^^^\n+   |\n+   = note: `U` must be used in combination with a concrete type within the same module\n \n error: aborting due to 6 previous errors; 2 warnings emitted\n "}, {"sha": "691047c8a405b56551985c1b26f21aa99f6efbb1", "filename": "src/test/ui/lint/lint-ctypes-73249-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-2.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -23,7 +23,7 @@ pub struct A<T: Foo> {\n }\n \n extern \"C\" {\n-    pub fn lint_me() -> A<()>; //~ ERROR: uses type `impl Baz`\n+    pub fn lint_me() -> A<()>; //~ ERROR: uses type `Qux`\n }\n \n fn main() {}"}, {"sha": "7c85e9fa85c632cfc27d83171e2617dc5e6eaf41", "filename": "src/test/ui/lint/lint-ctypes-73249-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-2.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,4 +1,4 @@\n-error: `extern` block uses type `impl Baz`, which is not FFI-safe\n+error: `extern` block uses type `Qux`, which is not FFI-safe\n   --> $DIR/lint-ctypes-73249-2.rs:26:25\n    |\n LL |     pub fn lint_me() -> A<()>;"}, {"sha": "ef8ab7e03d2f07277c0105a158398ebc231d7a04", "filename": "src/test/ui/lint/lint-ctypes-73249-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-3.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -17,7 +17,7 @@ pub struct A {\n }\n \n extern \"C\" {\n-    pub fn lint_me() -> A; //~ ERROR: uses type `impl Baz`\n+    pub fn lint_me() -> A; //~ ERROR: uses type `Qux`\n }\n \n fn main() {}"}, {"sha": "83e2a233c43355aab8670baf6591a89c49ac7b44", "filename": "src/test/ui/lint/lint-ctypes-73249-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-3.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,4 +1,4 @@\n-error: `extern` block uses type `impl Baz`, which is not FFI-safe\n+error: `extern` block uses type `Qux`, which is not FFI-safe\n   --> $DIR/lint-ctypes-73249-3.rs:20:25\n    |\n LL |     pub fn lint_me() -> A;"}, {"sha": "083fb6c5fb16dcc447c250aa1ebebecc39ac1b8f", "filename": "src/test/ui/lint/lint-ctypes-73249-5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-5.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -17,7 +17,7 @@ pub struct A {\n }\n \n extern \"C\" {\n-    pub fn lint_me() -> A; //~ ERROR: uses type `impl Baz`\n+    pub fn lint_me() -> A; //~ ERROR: uses type `Qux`\n }\n \n fn main() {}"}, {"sha": "37781d78cf28c03513b830662d90e6b2ff5efbaa", "filename": "src/test/ui/lint/lint-ctypes-73249-5.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73249-5.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,4 +1,4 @@\n-error: `extern` block uses type `impl Baz`, which is not FFI-safe\n+error: `extern` block uses type `Qux`, which is not FFI-safe\n   --> $DIR/lint-ctypes-73249-5.rs:20:25\n    |\n LL |     pub fn lint_me() -> A;"}, {"sha": "145ba784f7c66955e5a3a8ee068c9e188388bd8a", "filename": "src/test/ui/lint/lint-ctypes-73251-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-1.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -20,7 +20,7 @@ fn assign() -> Qux {\n }\n \n extern \"C\" {\n-    pub fn lint_me() -> <u32 as Foo>::Assoc; //~ ERROR: uses type `impl Baz`\n+    pub fn lint_me() -> <u32 as Foo>::Assoc; //~ ERROR: uses type `Qux`\n }\n \n fn main() {}"}, {"sha": "76b19d37e21a6d9eaeb5fddf3ec26b2d72f161ae", "filename": "src/test/ui/lint/lint-ctypes-73251-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-1.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,4 +1,4 @@\n-error: `extern` block uses type `impl Baz`, which is not FFI-safe\n+error: `extern` block uses type `Qux`, which is not FFI-safe\n   --> $DIR/lint-ctypes-73251-1.rs:23:25\n    |\n LL |     pub fn lint_me() -> <u32 as Foo>::Assoc;"}, {"sha": "df71a94579624bd51dc28637579094a281210639", "filename": "src/test/ui/lint/lint-ctypes-73251-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-2.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -33,7 +33,7 @@ fn use_of_b() -> AliasB {\n }\n \n extern \"C\" {\n-    pub fn lint_me() -> <AliasB as TraitB>::Assoc; //~ ERROR: uses type `impl TraitA<Assoc = u32>`\n+    pub fn lint_me() -> <AliasB as TraitB>::Assoc; //~ ERROR: uses type `AliasA`\n }\n \n fn main() {}"}, {"sha": "64f0fb2d892a45d31448a07da8a1bf46be8ded0c", "filename": "src/test/ui/lint/lint-ctypes-73251-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-73251-2.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,4 +1,4 @@\n-error: `extern` block uses type `impl TraitA<Assoc = u32>`, which is not FFI-safe\n+error: `extern` block uses type `AliasA`, which is not FFI-safe\n   --> $DIR/lint-ctypes-73251-2.rs:36:25\n    |\n LL |     pub fn lint_me() -> <AliasB as TraitB>::Assoc;"}, {"sha": "b7cc38e99fc37bdddacf11c89dfb60a9c5bdee91", "filename": "src/test/ui/lint/opaque-ty-ffi-unsafe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Fopaque-ty-ffi-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Fopaque-ty-ffi-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fopaque-ty-ffi-unsafe.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -9,7 +9,7 @@ pub fn ret_closure() -> A {\n \n extern \"C\" {\n     pub fn a(_: A);\n-    //~^ ERROR `extern` block uses type `impl Fn()`, which is not FFI-safe [improper_ctypes]\n+    //~^ ERROR `extern` block uses type `A`, which is not FFI-safe [improper_ctypes]\n }\n \n fn main() {}"}, {"sha": "62d00fd6835eee19568dc430c5a4b0de43d9d3f1", "filename": "src/test/ui/lint/opaque-ty-ffi-unsafe.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Fopaque-ty-ffi-unsafe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Flint%2Fopaque-ty-ffi-unsafe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fopaque-ty-ffi-unsafe.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,4 +1,4 @@\n-error: `extern` block uses type `impl Fn()`, which is not FFI-safe\n+error: `extern` block uses type `A`, which is not FFI-safe\n   --> $DIR/opaque-ty-ffi-unsafe.rs:11:17\n    |\n LL |     pub fn a(_: A);"}, {"sha": "7d020841180012580290b044c221ea6b79b2df02", "filename": "src/test/ui/never_type/feature-gate-never_type_fallback.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -6,7 +6,8 @@ fn main() {}\n \n trait T {}\n \n-fn should_ret_unit() -> impl T {\n-    //~^ ERROR the trait bound `(): T` is not satisfied\n-    panic!()\n+fn should_ret_unit() {\n+    foo(panic!()) //~ ERROR\n }\n+\n+fn foo(_: impl T) {}"}, {"sha": "54abed383000dc8134137db45fa06923d8cfe74e", "filename": "src/test/ui/never_type/feature-gate-never_type_fallback.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,8 +1,14 @@\n error[E0277]: the trait bound `(): T` is not satisfied\n-  --> $DIR/feature-gate-never_type_fallback.rs:9:25\n+  --> $DIR/feature-gate-never_type_fallback.rs:10:5\n    |\n-LL | fn should_ret_unit() -> impl T {\n-   |                         ^^^^^^ the trait `T` is not implemented for `()`\n+LL |     foo(panic!())\n+   |     ^^^ the trait `T` is not implemented for `()`\n+   |\n+note: required by a bound in `foo`\n+  --> $DIR/feature-gate-never_type_fallback.rs:13:16\n+   |\n+LL | fn foo(_: impl T) {}\n+   |                ^ required by this bound in `foo`\n \n error: aborting due to previous error\n "}, {"sha": "cc9520c1b24c8818d8584b08c193f1764b997ae5", "filename": "src/test/ui/never_type/impl_trait_fallback.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+\n+fn main() {}\n+\n+trait T {}\n+impl T for () {}\n+\n+fn should_ret_unit() -> impl T {\n+    panic!()\n+}"}, {"sha": "f73d953bdbd0b6e10aaf2d268e53d2a802a315de", "filename": "src/test/ui/never_type/impl_trait_fallback2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback2.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,21 @@\n+#![feature(type_alias_impl_trait)]\n+\n+fn main() {}\n+\n+trait T {}\n+impl T for i32 {}\n+\n+fn should_ret_unit() -> impl T {\n+    //~^ ERROR `(): T` is not satisfied\n+    panic!()\n+}\n+\n+type Foo = impl T;\n+\n+fn a() -> Foo {\n+    panic!()\n+}\n+\n+fn b() -> Foo {\n+    42\n+}"}, {"sha": "2f50b9d245900f0bb1f6c90c68085b3f755b06e5", "filename": "src/test/ui/never_type/impl_trait_fallback2.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback2.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,9 @@\n+error[E0277]: the trait bound `(): T` is not satisfied\n+  --> $DIR/impl_trait_fallback2.rs:8:25\n+   |\n+LL | fn should_ret_unit() -> impl T {\n+   |                         ^^^^^^ the trait `T` is not implemented for `()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "26ce9b93105e6fc3ed4c3c8f2c6e576b4bae96aa", "filename": "src/test/ui/never_type/impl_trait_fallback3.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback3.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,15 @@\n+#![feature(type_alias_impl_trait)]\n+\n+fn main() {}\n+\n+trait T {\n+    type Assoc;\n+}\n+\n+type Foo = impl T;\n+//~^ ERROR unconstrained opaque type\n+\n+fn a() -> Foo {\n+    // This is not a defining use, it doesn't actually constrain the opaque type.\n+    panic!()\n+}"}, {"sha": "121019d5f69aefe3739137e5f63c63b78a6a8030", "filename": "src/test/ui/never_type/impl_trait_fallback3.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback3.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,10 @@\n+error: unconstrained opaque type\n+  --> $DIR/impl_trait_fallback3.rs:9:12\n+   |\n+LL | type Foo = impl T;\n+   |            ^^^^^^\n+   |\n+   = note: `Foo` must be used in combination with a concrete type within the same module\n+\n+error: aborting due to previous error\n+"}, {"sha": "fe62773fa02dbd2be3cb1f9d8e03a4faf45357cf", "filename": "src/test/ui/never_type/impl_trait_fallback4.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback4.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,24 @@\n+#![feature(type_alias_impl_trait)]\n+\n+trait T {\n+    type Assoc: Cake;\n+}\n+\n+trait Cake: std::fmt::Display {\n+    fn cake() -> Self;\n+}\n+\n+type Foo = impl T;\n+\n+fn foo() -> impl T {\n+    //~^ ERROR `(): T` is not satisfied\n+    panic!()\n+}\n+\n+fn a() -> Foo {\n+    foo()\n+}\n+\n+fn main() {\n+    println!(\"{}\", <Foo as T>::Assoc::cake());\n+}"}, {"sha": "f2e216e9044c00a50eac5adb4728813370bc3881", "filename": "src/test/ui/never_type/impl_trait_fallback4.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback4.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,9 @@\n+error[E0277]: the trait bound `(): T` is not satisfied\n+  --> $DIR/impl_trait_fallback4.rs:13:13\n+   |\n+LL | fn foo() -> impl T {\n+   |             ^^^^^^ the trait `T` is not implemented for `()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "2f4cbf8322bbd13f648cc30c708c8f1eae2f7683", "filename": "src/test/ui/nll/issue-52113.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnll%2Fissue-52113.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnll%2Fissue-52113.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52113.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -29,9 +29,9 @@ fn produce3<'a, 'b: 'a>(data: &'a mut Vec<&'a u32>, value: &'b u32) -> impl Bazi\n fn produce_err<'a, 'b: 'a>(data: &'b mut Vec<&'b u32>, value: &'a u32) -> impl Bazinga + 'b {\n     let x = move || {\n         let value: &'a u32 = value;\n-        data.push(value);\n+        data.push(value); //~ ERROR lifetime may not live long enough\n     };\n-    x //~ ERROR lifetime may not live long enough\n+    x\n }\n \n fn main() {}"}, {"sha": "42ff1866893e6d923e707653ad8db4c3b6e204e7", "filename": "src/test/ui/nll/issue-52113.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnll%2Fissue-52113.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnll%2Fissue-52113.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52113.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,13 +1,13 @@\n error: lifetime may not live long enough\n-  --> $DIR/issue-52113.rs:34:5\n+  --> $DIR/issue-52113.rs:32:9\n    |\n LL | fn produce_err<'a, 'b: 'a>(data: &'b mut Vec<&'b u32>, value: &'a u32) -> impl Bazinga + 'b {\n    |                --  -- lifetime `'b` defined here\n    |                |\n    |                lifetime `'a` defined here\n ...\n-LL |     x\n-   |     ^ function was supposed to return data with lifetime `'b` but it is returning data with lifetime `'a`\n+LL |         data.push(value);\n+   |         ^^^^^^^^^^^^^^^^ argument requires that `'a` must outlive `'b`\n    |\n    = help: consider adding the following bound: `'a: 'b`\n "}, {"sha": "97dc016068bed85abe50f1e81c3ff81c9ccaf4c2", "filename": "src/test/ui/nll/issue-73159-rpit-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -7,8 +7,8 @@ struct Foo<'a>(&'a [u8]);\n \n impl<'a> Foo<'a> {\n     fn make_it(&self) -> impl Iterator<Item = u8> {\n-        //~^ ERROR: captures lifetime that does not appear in bounds\n         self.0.iter().copied()\n+        //~^ ERROR: captures lifetime that does not appear in bounds\n     }\n }\n "}, {"sha": "a3e9c0b44c21078c76a54e23a4bbeb177dac259a", "filename": "src/test/ui/nll/issue-73159-rpit-static.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,10 +1,11 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/issue-73159-rpit-static.rs:9:26\n+  --> $DIR/issue-73159-rpit-static.rs:10:9\n    |\n LL | impl<'a> Foo<'a> {\n    |      -- hidden type `Copied<std::slice::Iter<'a, u8>>` captures the lifetime `'a` as defined here\n LL |     fn make_it(&self) -> impl Iterator<Item = u8> {\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         self.0.iter().copied()\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "0fbe6a63c0b685fbd51c369ed283f811ced84323", "filename": "src/test/ui/nll/relate_tys/opaque-hrtb.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fopaque-hrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fopaque-hrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fopaque-hrtb.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,16 @@\n+#![feature(nll)]\n+\n+trait MyTrait<T> {}\n+\n+struct Foo;\n+impl<T> MyTrait<T> for Foo {}\n+\n+fn bar<Input>() -> impl MyTrait<Input> {\n+    Foo\n+}\n+\n+fn foo() -> impl for<'a> MyTrait<&'a str> {\n+    bar() //~ ERROR implementation of `MyTrait` is not general enough\n+}\n+\n+fn main() {}"}, {"sha": "4c8b66f21abe015e408c163e51e3c3aa07350143", "filename": "src/test/ui/nll/relate_tys/opaque-hrtb.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fopaque-hrtb.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fopaque-hrtb.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fopaque-hrtb.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,11 @@\n+error: implementation of `MyTrait` is not general enough\n+  --> $DIR/opaque-hrtb.rs:13:5\n+   |\n+LL |     bar()\n+   |     ^^^^^ implementation of `MyTrait` is not general enough\n+   |\n+   = note: `impl MyTrait<&'2 str>` must implement `MyTrait<&'1 str>`, for any lifetime `'1`...\n+   = note: ...but it actually implements `MyTrait<&'2 str>`, for some specific lifetime `'2`\n+\n+error: aborting due to previous error\n+"}, {"sha": "c04185d08142481a928ae978c214943acaff011b", "filename": "src/test/ui/nll/ty-outlives/impl-trait-captures.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -8,8 +8,8 @@ trait Foo<'a> {\n impl<'a, T> Foo<'a> for T { }\n \n fn foo<'a, T>(x: &T) -> impl Foo<'a> {\n-//~^ ERROR captures lifetime that does not appear in bounds\n     x\n+    //~^ ERROR captures lifetime that does not appear in bounds\n }\n \n fn main() {}"}, {"sha": "42d9f057aaa08dcf8773d4765bf4546f6509383d", "filename": "src/test/ui/nll/ty-outlives/impl-trait-captures.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,10 +1,10 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/impl-trait-captures.rs:10:25\n+  --> $DIR/impl-trait-captures.rs:11:5\n    |\n LL | fn foo<'a, T>(x: &T) -> impl Foo<'a> {\n-   |                  --     ^^^^^^^^^^^^\n-   |                  |\n-   |                  hidden type `&ReFree(DefId(0:8 ~ impl_trait_captures[1afc]::foo), BrAnon(0)) T` captures the anonymous lifetime defined here\n+   |                  -- hidden type `&ReFree(DefId(0:8 ~ impl_trait_captures[1afc]::foo), BrAnon(0)) T` captures the anonymous lifetime defined here\n+LL |     x\n+   |     ^\n    |\n help: to declare that the `impl Trait` captures `ReFree(DefId(0:8 ~ impl_trait_captures[1afc]::foo), BrAnon(0))`, you can add an explicit `ReFree(DefId(0:8 ~ impl_trait_captures[1afc]::foo), BrAnon(0))` lifetime bound\n    |"}, {"sha": "3548ad03a7d3d9fc6a7578dc21bf59f646d6f251", "filename": "src/test/ui/nll/ty-outlives/impl-trait-outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -5,11 +5,11 @@\n use std::fmt::Debug;\n \n fn no_region<'a, T>(x: Box<T>) -> impl Debug + 'a\n-    //~^ ERROR the parameter type `T` may not live long enough [E0309]\n where\n     T: Debug,\n {\n     x\n+    //~^ ERROR the parameter type `T` may not live long enough [E0309]\n }\n \n fn correct_region<'a, T>(x: Box<T>) -> impl Debug + 'a\n@@ -20,11 +20,11 @@ where\n }\n \n fn wrong_region<'a, 'b, T>(x: Box<T>) -> impl Debug + 'a\n-    //~^ ERROR the parameter type `T` may not live long enough [E0309]\n where\n     T: 'b + Debug,\n {\n     x\n+    //~^ ERROR the parameter type `T` may not live long enough [E0309]\n }\n \n fn outlives_region<'a, 'b, T>(x: Box<T>) -> impl Debug + 'a"}, {"sha": "31ee540cce9f70ccf63bcd4f9baed4e8f5276ae7", "filename": "src/test/ui/nll/ty-outlives/impl-trait-outlives.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,16 +1,16 @@\n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/impl-trait-outlives.rs:7:35\n+  --> $DIR/impl-trait-outlives.rs:11:5\n    |\n-LL | fn no_region<'a, T>(x: Box<T>) -> impl Debug + 'a\n-   |                                   ^^^^^^^^^^^^^^^\n+LL |     x\n+   |     ^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'a`...\n \n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/impl-trait-outlives.rs:22:42\n+  --> $DIR/impl-trait-outlives.rs:26:5\n    |\n-LL | fn wrong_region<'a, 'b, T>(x: Box<T>) -> impl Debug + 'a\n-   |                                          ^^^^^^^^^^^^^^^\n+LL |     x\n+   |     ^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'a`...\n "}, {"sha": "c2954868f78e4b00504f07eacfa25a071e18df43", "filename": "src/test/ui/parser/fn-header-semantic-fail.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -9,8 +9,9 @@ fn main() {\n     unsafe fn ff2() {} // OK.\n     const fn ff3() {} // OK.\n     extern \"C\" fn ff4() {} // OK.\n-    const async unsafe extern \"C\" fn ff5() {} // OK.\n+    const async unsafe extern \"C\" fn ff5() {}\n     //~^ ERROR functions cannot be both `const` and `async`\n+    //~| ERROR cycle detected\n \n     trait X {\n         async fn ft1(); //~ ERROR functions in traits cannot be declared `async`\n@@ -26,15 +27,16 @@ fn main() {\n     struct Y;\n     impl X for Y {\n         async fn ft1() {} //~ ERROR functions in traits cannot be declared `async`\n-        //~^ ERROR method `ft1` has an incompatible type for trait\n+        //~^ ERROR impl has stricter requirements than trait\n         unsafe fn ft2() {} // OK.\n         const fn ft3() {} //~ ERROR functions in traits cannot be declared const\n         extern \"C\" fn ft4() {}\n         const async unsafe extern \"C\" fn ft5() {}\n         //~^ ERROR functions in traits cannot be declared `async`\n         //~| ERROR functions in traits cannot be declared const\n-        //~| ERROR method `ft5` has an incompatible type for trait\n         //~| ERROR functions cannot be both `const` and `async`\n+        //~| ERROR cycle detected\n+        //~| ERROR impl has stricter requirements than trait\n     }\n \n     impl Y {\n@@ -44,6 +46,7 @@ fn main() {\n         extern \"C\" fn fi4() {} // OK.\n         const async unsafe extern \"C\" fn fi5() {}\n         //~^ ERROR functions cannot be both `const` and `async`\n+        //~| ERROR cycle detected\n     }\n \n     extern \"C\" {"}, {"sha": "bd3b9181123bb7b0485a9b342c9045aa0ad5f98d", "filename": "src/test/ui/parser/fn-header-semantic-fail.stderr", "status": "modified", "additions": 136, "deletions": 46, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,14 +1,14 @@\n error: functions cannot be both `const` and `async`\n   --> $DIR/fn-header-semantic-fail.rs:12:5\n    |\n-LL |     const async unsafe extern \"C\" fn ff5() {} // OK.\n+LL |     const async unsafe extern \"C\" fn ff5() {}\n    |     ^^^^^-^^^^^------------------------------\n    |     |     |\n    |     |     `async` because of this\n    |     `const` because of this\n \n error[E0706]: functions in traits cannot be declared `async`\n-  --> $DIR/fn-header-semantic-fail.rs:16:9\n+  --> $DIR/fn-header-semantic-fail.rs:17:9\n    |\n LL |         async fn ft1();\n    |         -----^^^^^^^^^^\n@@ -19,19 +19,19 @@ LL |         async fn ft1();\n    = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n \n error[E0379]: functions in traits cannot be declared const\n-  --> $DIR/fn-header-semantic-fail.rs:18:9\n+  --> $DIR/fn-header-semantic-fail.rs:19:9\n    |\n LL |         const fn ft3();\n    |         ^^^^^ functions in traits cannot be const\n \n error[E0379]: functions in traits cannot be declared const\n-  --> $DIR/fn-header-semantic-fail.rs:20:9\n+  --> $DIR/fn-header-semantic-fail.rs:21:9\n    |\n LL |         const async unsafe extern \"C\" fn ft5();\n    |         ^^^^^ functions in traits cannot be const\n \n error[E0706]: functions in traits cannot be declared `async`\n-  --> $DIR/fn-header-semantic-fail.rs:20:9\n+  --> $DIR/fn-header-semantic-fail.rs:21:9\n    |\n LL |         const async unsafe extern \"C\" fn ft5();\n    |         ^^^^^^-----^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -42,7 +42,7 @@ LL |         const async unsafe extern \"C\" fn ft5();\n    = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n \n error: functions cannot be both `const` and `async`\n-  --> $DIR/fn-header-semantic-fail.rs:20:9\n+  --> $DIR/fn-header-semantic-fail.rs:21:9\n    |\n LL |         const async unsafe extern \"C\" fn ft5();\n    |         ^^^^^-^^^^^----------------------------\n@@ -51,7 +51,7 @@ LL |         const async unsafe extern \"C\" fn ft5();\n    |         `const` because of this\n \n error[E0706]: functions in traits cannot be declared `async`\n-  --> $DIR/fn-header-semantic-fail.rs:28:9\n+  --> $DIR/fn-header-semantic-fail.rs:29:9\n    |\n LL |         async fn ft1() {}\n    |         -----^^^^^^^^^^^^\n@@ -62,19 +62,19 @@ LL |         async fn ft1() {}\n    = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n \n error[E0379]: functions in traits cannot be declared const\n-  --> $DIR/fn-header-semantic-fail.rs:31:9\n+  --> $DIR/fn-header-semantic-fail.rs:32:9\n    |\n LL |         const fn ft3() {}\n    |         ^^^^^ functions in traits cannot be const\n \n error[E0379]: functions in traits cannot be declared const\n-  --> $DIR/fn-header-semantic-fail.rs:33:9\n+  --> $DIR/fn-header-semantic-fail.rs:34:9\n    |\n LL |         const async unsafe extern \"C\" fn ft5() {}\n    |         ^^^^^ functions in traits cannot be const\n \n error[E0706]: functions in traits cannot be declared `async`\n-  --> $DIR/fn-header-semantic-fail.rs:33:9\n+  --> $DIR/fn-header-semantic-fail.rs:34:9\n    |\n LL |         const async unsafe extern \"C\" fn ft5() {}\n    |         ^^^^^^-----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -85,7 +85,7 @@ LL |         const async unsafe extern \"C\" fn ft5() {}\n    = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n \n error: functions cannot be both `const` and `async`\n-  --> $DIR/fn-header-semantic-fail.rs:33:9\n+  --> $DIR/fn-header-semantic-fail.rs:34:9\n    |\n LL |         const async unsafe extern \"C\" fn ft5() {}\n    |         ^^^^^-^^^^^------------------------------\n@@ -94,7 +94,7 @@ LL |         const async unsafe extern \"C\" fn ft5() {}\n    |         `const` because of this\n \n error: functions cannot be both `const` and `async`\n-  --> $DIR/fn-header-semantic-fail.rs:45:9\n+  --> $DIR/fn-header-semantic-fail.rs:47:9\n    |\n LL |         const async unsafe extern \"C\" fn fi5() {}\n    |         ^^^^^-^^^^^------------------------------\n@@ -103,7 +103,7 @@ LL |         const async unsafe extern \"C\" fn fi5() {}\n    |         `const` because of this\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:50:18\n+  --> $DIR/fn-header-semantic-fail.rs:53:18\n    |\n LL |     extern \"C\" {\n    |     ---------- in this `extern` block\n@@ -116,7 +116,7 @@ LL |         fn fe1();\n    |         ~~\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:51:19\n+  --> $DIR/fn-header-semantic-fail.rs:54:19\n    |\n LL |     extern \"C\" {\n    |     ---------- in this `extern` block\n@@ -130,7 +130,7 @@ LL |         fn fe2();\n    |         ~~\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:52:18\n+  --> $DIR/fn-header-semantic-fail.rs:55:18\n    |\n LL |     extern \"C\" {\n    |     ---------- in this `extern` block\n@@ -144,7 +144,7 @@ LL |         fn fe3();\n    |         ~~\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:53:23\n+  --> $DIR/fn-header-semantic-fail.rs:56:23\n    |\n LL |     extern \"C\" {\n    |     ---------- in this `extern` block\n@@ -158,7 +158,7 @@ LL |         fn fe4();\n    |         ~~\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:54:42\n+  --> $DIR/fn-header-semantic-fail.rs:57:42\n    |\n LL |     extern \"C\" {\n    |     ---------- in this `extern` block\n@@ -172,51 +172,141 @@ LL |         fn fe5();\n    |         ~~\n \n error: functions cannot be both `const` and `async`\n-  --> $DIR/fn-header-semantic-fail.rs:54:9\n+  --> $DIR/fn-header-semantic-fail.rs:57:9\n    |\n LL |         const async unsafe extern \"C\" fn fe5();\n    |         ^^^^^-^^^^^----------------------------\n    |         |     |\n    |         |     `async` because of this\n    |         `const` because of this\n \n-error[E0053]: method `ft1` has an incompatible type for trait\n-  --> $DIR/fn-header-semantic-fail.rs:28:24\n+error[E0391]: cycle detected when computing type of `main::ff5::{opaque#0}`\n+  --> $DIR/fn-header-semantic-fail.rs:12:44\n    |\n-LL |         async fn ft1() {}\n-   |                        ^\n-   |                        |\n-   |                        checked the `Output` of this `async fn`, found opaque type\n-   |                        expected `()`, found opaque type\n+LL |     const async unsafe extern \"C\" fn ff5() {}\n+   |                                            ^\n+   |\n+note: ...which requires borrow-checking `main::ff5`...\n+  --> $DIR/fn-header-semantic-fail.rs:12:5\n+   |\n+LL |     const async unsafe extern \"C\" fn ff5() {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing `main::ff5`...\n+  --> $DIR/fn-header-semantic-fail.rs:12:5\n+   |\n+LL |     const async unsafe extern \"C\" fn ff5() {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires const checking `main::ff5`...\n+  --> $DIR/fn-header-semantic-fail.rs:12:5\n    |\n-   = note: while checking the return type of the `async fn`\n-note: type in trait\n-  --> $DIR/fn-header-semantic-fail.rs:16:23\n+LL |     const async unsafe extern \"C\" fn ff5() {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which requires computing whether `impl core::future::future::Future<Output = ()>` is freeze...\n+   = note: ...which requires evaluating trait selection obligation `impl core::future::future::Future<Output = ()>: core::marker::Freeze`...\n+   = note: ...which again requires computing type of `main::ff5::{opaque#0}`, completing the cycle\n+note: cycle used when checking item types in top-level module\n+  --> $DIR/fn-header-semantic-fail.rs:5:1\n+   |\n+LL | / #![feature(const_extern_fn)]\n+LL | |\n+LL | | fn main() {\n+LL | |     async fn ff1() {} // OK.\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+\n+error[E0276]: impl has stricter requirements than trait\n+  --> $DIR/fn-header-semantic-fail.rs:29:9\n    |\n LL |         async fn ft1();\n-   |                       ^\n-   = note: expected fn pointer `fn()`\n-              found fn pointer `fn() -> impl Future<Output = ()>`\n+   |         --------------- definition of `ft1` from trait\n+...\n+LL |         async fn ft1() {}\n+   |         ^^^^^^^^^^^^^^ impl has extra requirement `(): Future`\n+\n+error[E0276]: impl has stricter requirements than trait\n+  --> $DIR/fn-header-semantic-fail.rs:34:9\n+   |\n+LL |         const async unsafe extern \"C\" fn ft5();\n+   |         --------------------------------------- definition of `ft5` from trait\n+...\n+LL |         const async unsafe extern \"C\" fn ft5() {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `(): Future`\n \n-error[E0053]: method `ft5` has an incompatible type for trait\n-  --> $DIR/fn-header-semantic-fail.rs:33:48\n+error[E0391]: cycle detected when computing type of `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 40:6>::ft5::{opaque#0}`\n+  --> $DIR/fn-header-semantic-fail.rs:34:48\n    |\n LL |         const async unsafe extern \"C\" fn ft5() {}\n    |                                                ^\n-   |                                                |\n-   |                                                checked the `Output` of this `async fn`, found opaque type\n-   |                                                expected `()`, found opaque type\n    |\n-   = note: while checking the return type of the `async fn`\n-note: type in trait\n-  --> $DIR/fn-header-semantic-fail.rs:20:47\n+note: ...which requires borrow-checking `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 40:6>::ft5`...\n+  --> $DIR/fn-header-semantic-fail.rs:34:9\n    |\n-LL |         const async unsafe extern \"C\" fn ft5();\n-   |                                               ^\n-   = note: expected fn pointer `unsafe extern \"C\" fn()`\n-              found fn pointer `unsafe extern \"C\" fn() -> impl Future<Output = ()>`\n+LL |         const async unsafe extern \"C\" fn ft5() {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 40:6>::ft5`...\n+  --> $DIR/fn-header-semantic-fail.rs:34:9\n+   |\n+LL |         const async unsafe extern \"C\" fn ft5() {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires const checking `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 40:6>::ft5`...\n+  --> $DIR/fn-header-semantic-fail.rs:34:9\n+   |\n+LL |         const async unsafe extern \"C\" fn ft5() {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which requires computing whether `impl core::future::future::Future<Output = ()>` is freeze...\n+   = note: ...which requires evaluating trait selection obligation `impl core::future::future::Future<Output = ()>: core::marker::Freeze`...\n+   = note: ...which again requires computing type of `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 40:6>::ft5::{opaque#0}`, completing the cycle\n+note: cycle used when checking item types in top-level module\n+  --> $DIR/fn-header-semantic-fail.rs:5:1\n+   |\n+LL | / #![feature(const_extern_fn)]\n+LL | |\n+LL | | fn main() {\n+LL | |     async fn ff1() {} // OK.\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+\n+error[E0391]: cycle detected when computing type of `main::<impl at $DIR/fn-header-semantic-fail.rs:42:5: 50:6>::fi5::{opaque#0}`\n+  --> $DIR/fn-header-semantic-fail.rs:47:48\n+   |\n+LL |         const async unsafe extern \"C\" fn fi5() {}\n+   |                                                ^\n+   |\n+note: ...which requires borrow-checking `main::<impl at $DIR/fn-header-semantic-fail.rs:42:5: 50:6>::fi5`...\n+  --> $DIR/fn-header-semantic-fail.rs:47:9\n+   |\n+LL |         const async unsafe extern \"C\" fn fi5() {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing `main::<impl at $DIR/fn-header-semantic-fail.rs:42:5: 50:6>::fi5`...\n+  --> $DIR/fn-header-semantic-fail.rs:47:9\n+   |\n+LL |         const async unsafe extern \"C\" fn fi5() {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires const checking `main::<impl at $DIR/fn-header-semantic-fail.rs:42:5: 50:6>::fi5`...\n+  --> $DIR/fn-header-semantic-fail.rs:47:9\n+   |\n+LL |         const async unsafe extern \"C\" fn fi5() {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which requires computing whether `impl core::future::future::Future<Output = ()>` is freeze...\n+   = note: ...which requires evaluating trait selection obligation `impl core::future::future::Future<Output = ()>: core::marker::Freeze`...\n+   = note: ...which again requires computing type of `main::<impl at $DIR/fn-header-semantic-fail.rs:42:5: 50:6>::fi5::{opaque#0}`, completing the cycle\n+note: cycle used when checking item types in top-level module\n+  --> $DIR/fn-header-semantic-fail.rs:5:1\n+   |\n+LL | / #![feature(const_extern_fn)]\n+LL | |\n+LL | | fn main() {\n+LL | |     async fn ff1() {} // OK.\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n \n-error: aborting due to 20 previous errors\n+error: aborting due to 23 previous errors\n \n-Some errors have detailed explanations: E0053, E0379, E0706.\n-For more information about an error, try `rustc --explain E0053`.\n+Some errors have detailed explanations: E0276, E0379, E0391, E0706.\n+For more information about an error, try `rustc --explain E0276`."}, {"sha": "68ea4a026d7bf3622e0f9e3d6117e977c05a07ad", "filename": "src/test/ui/polymorphization/generators.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fpolymorphization%2Fgenerators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fpolymorphization%2Fgenerators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpolymorphization%2Fgenerators.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -32,7 +32,6 @@ where\n \n #[rustc_polymorphize_error]\n pub fn unused_type<T>() -> impl Generator<(), Yield = u32, Return = u32> + Unpin {\n-    //~^ ERROR item has unused generic parameters\n     || {\n         //~^ ERROR item has unused generic parameters\n         yield 1;\n@@ -58,7 +57,6 @@ pub fn used_type_in_return<R: Default>() -> impl Generator<(), Yield = u32, Retu\n \n #[rustc_polymorphize_error]\n pub fn unused_const<const T: u32>() -> impl Generator<(), Yield = u32, Return = u32> + Unpin {\n-    //~^ ERROR item has unused generic parameters\n     || {\n         //~^ ERROR item has unused generic parameters\n         yield 1;"}, {"sha": "1152bcb0734a63490ef7a65683f52b7de7afc8a0", "filename": "src/test/ui/polymorphization/generators.stderr", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fpolymorphization%2Fgenerators.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fpolymorphization%2Fgenerators.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpolymorphization%2Fgenerators.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -8,11 +8,10 @@ LL | #![feature(generic_const_exprs, generators, generator_trait, rustc_attrs)]\n    = note: see issue #76560 <https://github.com/rust-lang/rust/issues/76560> for more information\n \n error: item has unused generic parameters\n-  --> $DIR/generators.rs:36:5\n+  --> $DIR/generators.rs:35:5\n    |\n LL |   pub fn unused_type<T>() -> impl Generator<(), Yield = u32, Return = u32> + Unpin {\n    |                      - generic parameter `T` is unused\n-LL |\n LL | /     || {\n LL | |\n LL | |         yield 1;\n@@ -21,29 +20,16 @@ LL | |     }\n    | |_____^\n \n error: item has unused generic parameters\n-  --> $DIR/generators.rs:34:8\n-   |\n-LL | pub fn unused_type<T>() -> impl Generator<(), Yield = u32, Return = u32> + Unpin {\n-   |        ^^^^^^^^^^^ - generic parameter `T` is unused\n-\n-error: item has unused generic parameters\n-  --> $DIR/generators.rs:62:5\n+  --> $DIR/generators.rs:60:5\n    |\n LL |   pub fn unused_const<const T: u32>() -> impl Generator<(), Yield = u32, Return = u32> + Unpin {\n    |                             - generic parameter `T` is unused\n-LL |\n LL | /     || {\n LL | |\n LL | |         yield 1;\n LL | |         2\n LL | |     }\n    | |_____^\n \n-error: item has unused generic parameters\n-  --> $DIR/generators.rs:60:8\n-   |\n-LL | pub fn unused_const<const T: u32>() -> impl Generator<(), Yield = u32, Return = u32> + Unpin {\n-   |        ^^^^^^^^^^^^       - generic parameter `T` is unused\n-\n-error: aborting due to 4 previous errors; 1 warning emitted\n+error: aborting due to 2 previous errors; 1 warning emitted\n "}, {"sha": "6facc467f7a6fc56903cbacbea3e4975b6817a5b", "filename": "src/test/ui/resolve/issue-70736-async-fn-no-body-def-collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -14,7 +14,7 @@ trait B {\n impl B for A {\n     async fn associated(); //~ ERROR without body\n     //~^ ERROR cannot be declared `async`\n-    //~| ERROR incompatible type for trait\n+    //~| ERROR impl has stricter requirements than trait\n }\n \n fn main() {}"}, {"sha": "c144060a8597de7ffe617dd4f2bc4f463f125993", "filename": "src/test/ui/resolve/issue-70736-async-fn-no-body-def-collector.stderr", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -44,25 +44,16 @@ LL |     async fn associated();\n    = note: `async` trait functions are not currently supported\n    = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n \n-error[E0053]: method `associated` has an incompatible type for trait\n-  --> $DIR/issue-70736-async-fn-no-body-def-collector.rs:15:26\n+error[E0276]: impl has stricter requirements than trait\n+  --> $DIR/issue-70736-async-fn-no-body-def-collector.rs:15:5\n    |\n LL |     async fn associated();\n-   |                          ^\n-   |                          |\n-   |                          checked the `Output` of this `async fn`, found opaque type\n-   |                          expected `()`, found opaque type\n-   |\n-   = note: while checking the return type of the `async fn`\n-note: type in trait\n-  --> $DIR/issue-70736-async-fn-no-body-def-collector.rs:11:26\n-   |\n+   |     ---------------------- definition of `associated` from trait\n+...\n LL |     async fn associated();\n-   |                          ^\n-   = note: expected fn pointer `fn()`\n-              found fn pointer `fn() -> impl Future<Output = ()>`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `(): Future`\n \n error: aborting due to 6 previous errors\n \n-Some errors have detailed explanations: E0053, E0706.\n-For more information about an error, try `rustc --explain E0053`.\n+Some errors have detailed explanations: E0276, E0706.\n+For more information about an error, try `rustc --explain E0276`."}, {"sha": "30479580f11a3c0122291b0020d1738bf15406f4", "filename": "src/test/ui/save-analysis/issue-68621.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-68621.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-68621.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-68621.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -11,7 +11,7 @@ trait Service {\n struct Struct;\n \n impl Service for Struct {\n-    type Future = impl Trait; //~ ERROR: could not find defining uses\n+    type Future = impl Trait; //~ ERROR: unconstrained opaque type\n }\n \n fn main() {}"}, {"sha": "4a4bf9a6996bc489aade43388ffe581b7185de76", "filename": "src/test/ui/save-analysis/issue-68621.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-68621.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-68621.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsave-analysis%2Fissue-68621.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,8 +1,10 @@\n-error: could not find defining uses\n+error: unconstrained opaque type\n   --> $DIR/issue-68621.rs:14:19\n    |\n LL |     type Future = impl Trait;\n    |                   ^^^^^^^^^^\n+   |\n+   = note: `Future` must be used in combination with a concrete type within the same module\n \n error: aborting due to previous error\n "}, {"sha": "570a08cb58768ff9c1fc6ded908cade51d391b22", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,8 +1,8 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait-async.rs:8:37\n+  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait-async.rs:8:48\n    |\n LL |     async fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |                          -          ^^^^^^^^^^\n+   |                          -                     ^^^^^^^^\n    |                          |\n    |                          hidden type `Pin<&Foo>` captures the lifetime `'_` as defined here\n    |"}, {"sha": "abdc650c68e78d46b85949e92ba38e38c448123a", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,8 +1,8 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait.rs:6:31\n+  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait.rs:6:44\n    |\n LL |     fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |                    -----      ^^^^^^^^^^\n+   |                    -----                   ^^^^\n    |                    |\n    |                    hidden type `Pin<&Foo>` captures the anonymous lifetime defined here\n    |"}, {"sha": "cad7d76c6ab5fd5a156ae81626ed2f86911a8842", "filename": "src/test/ui/suggestions/impl-trait-return-trailing-semicolon.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-return-trailing-semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-return-trailing-semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-return-trailing-semicolon.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -2,6 +2,7 @@ trait Bar {}\n impl Bar for u8 {}\n fn foo() -> impl Bar {\n     5; //~^ ERROR the trait bound `(): Bar` is not satisfied\n+    //~| ERROR the trait bound `(): Bar` is not satisfied\n }\n \n fn main() {}"}, {"sha": "ba6967e78e16347c09a9d02f0ed4e44d1789208d", "filename": "src/test/ui/suggestions/impl-trait-return-trailing-semicolon.stderr", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-return-trailing-semicolon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-return-trailing-semicolon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-return-trailing-semicolon.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -6,6 +6,16 @@ LL | fn foo() -> impl Bar {\n LL |     5;\n    |      - consider removing this semicolon\n \n-error: aborting due to previous error\n+error[E0277]: the trait bound `(): Bar` is not satisfied\n+  --> $DIR/impl-trait-return-trailing-semicolon.rs:3:22\n+   |\n+LL |   fn foo() -> impl Bar {\n+   |  ______________________^\n+LL | |     5;\n+LL | |\n+LL | | }\n+   | |_^ the trait `Bar` is not implemented for `()`\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "7ca7380a7befdd7ed1d3928a81f0548a3de06365", "filename": "src/test/ui/suggestions/issue-81098.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fsuggestions%2Fissue-81098.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fsuggestions%2Fissue-81098.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-81098.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,12 +1,14 @@\n // Don't suggest removing a semicolon if the last statement isn't an expression with semicolon\n // (#81098)\n fn wat() -> impl core::fmt::Display { //~ ERROR: `()` doesn't implement `std::fmt::Display`\n+    //~^ ERROR: `()` doesn't implement `std::fmt::Display`\n     fn why() {}\n }\n \n // Do it if the last statement is an expression with semicolon\n // (#54771)\n fn ok() -> impl core::fmt::Display { //~ ERROR: `()` doesn't implement `std::fmt::Display`\n+    //~^ ERROR: `()` doesn't implement `std::fmt::Display`\n     1;\n }\n "}, {"sha": "d62526442e9af2ccd1ec177cacb48d64b4401219", "filename": "src/test/ui/suggestions/issue-81098.stderr", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fsuggestions%2Fissue-81098.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Fsuggestions%2Fissue-81098.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-81098.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -8,16 +8,43 @@ LL | fn wat() -> impl core::fmt::Display {\n    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n \n error[E0277]: `()` doesn't implement `std::fmt::Display`\n-  --> $DIR/issue-81098.rs:9:12\n+  --> $DIR/issue-81098.rs:3:37\n+   |\n+LL |   fn wat() -> impl core::fmt::Display {\n+   |  _____________________________________^\n+LL | |\n+LL | |     fn why() {}\n+LL | | }\n+   | |_^ `()` cannot be formatted with the default formatter\n+   |\n+   = help: the trait `std::fmt::Display` is not implemented for `()`\n+   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n+\n+error[E0277]: `()` doesn't implement `std::fmt::Display`\n+  --> $DIR/issue-81098.rs:10:12\n    |\n LL | fn ok() -> impl core::fmt::Display {\n    |            ^^^^^^^^^^^^^^^^^^^^^^^ `()` cannot be formatted with the default formatter\n+LL |\n LL |     1;\n    |      - consider removing this semicolon\n    |\n    = help: the trait `std::fmt::Display` is not implemented for `()`\n    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n \n-error: aborting due to 2 previous errors\n+error[E0277]: `()` doesn't implement `std::fmt::Display`\n+  --> $DIR/issue-81098.rs:10:36\n+   |\n+LL |   fn ok() -> impl core::fmt::Display {\n+   |  ____________________________________^\n+LL | |\n+LL | |     1;\n+LL | | }\n+   | |_^ `()` cannot be formatted with the default formatter\n+   |\n+   = help: the trait `std::fmt::Display` is not implemented for `()`\n+   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n+\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "04320e72076830aab187c2e7b7dbf43e08d73051", "filename": "src/test/ui/traits/alias/issue-83613.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -8,6 +8,6 @@ fn mk_opaque() -> OpaqueType {\n trait AnotherTrait {}\n impl<T: Send> AnotherTrait for T {}\n impl AnotherTrait for OpaqueType {}\n-//~^ ERROR conflicting implementations of trait `AnotherTrait` for type `impl OpaqueTrait`\n+//~^ ERROR conflicting implementations of trait `AnotherTrait` for type `OpaqueType`\n //~| ERROR cannot implement trait on type alias impl trait\n fn main() {}"}, {"sha": "4f19e6607c8d9f3256b34b61a969316754d8e956", "filename": "src/test/ui/traits/alias/issue-83613.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -10,13 +10,13 @@ note: type alias impl trait defined here\n LL | type OpaqueType = impl OpaqueTrait;\n    |                   ^^^^^^^^^^^^^^^^\n \n-error[E0119]: conflicting implementations of trait `AnotherTrait` for type `impl OpaqueTrait`\n+error[E0119]: conflicting implementations of trait `AnotherTrait` for type `OpaqueType`\n   --> $DIR/issue-83613.rs:10:1\n    |\n LL | impl<T: Send> AnotherTrait for T {}\n    | -------------------------------- first implementation here\n LL | impl AnotherTrait for OpaqueType {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `impl OpaqueTrait`\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `OpaqueType`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "28bc1da964dbcdfdaa6101d3973bcabfe736ce20", "filename": "src/test/ui/traits/pointee-tail-is-generic-errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftraits%2Fpointee-tail-is-generic-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftraits%2Fpointee-tail-is-generic-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fpointee-tail-is-generic-errors.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -14,7 +14,7 @@ fn a<T: ?Sized>() {\n     //~^ ERROR type mismatch resolving `<T as Pointee>::Metadata == ()`\n \n     is_thin::<Opaque>();\n-    //~^ ERROR type mismatch resolving `<impl Debug + ?Sized as Pointee>::Metadata == ()`\n+    //~^ ERROR type mismatch resolving `<Opaque as Pointee>::Metadata == ()`\n }\n \n fn is_thin<T: std::ptr::Pointee<Metadata = ()> + ?Sized>() {}"}, {"sha": "8456f84562ff2c1170b8b85011a6e87c9f790bac", "filename": "src/test/ui/traits/pointee-tail-is-generic-errors.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftraits%2Fpointee-tail-is-generic-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftraits%2Fpointee-tail-is-generic-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fpointee-tail-is-generic-errors.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -14,7 +14,7 @@ note: required by a bound in `is_thin`\n LL | fn is_thin<T: std::ptr::Pointee<Metadata = ()> + ?Sized>() {}\n    |                                 ^^^^^^^^^^^^^ required by this bound in `is_thin`\n \n-error[E0271]: type mismatch resolving `<impl Debug + ?Sized as Pointee>::Metadata == ()`\n+error[E0271]: type mismatch resolving `<Opaque as Pointee>::Metadata == ()`\n   --> $DIR/pointee-tail-is-generic-errors.rs:16:5\n    |\n LL | type Opaque = impl std::fmt::Debug + ?Sized;\n@@ -24,13 +24,13 @@ LL |     is_thin::<Opaque>();\n    |     ^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n    |\n    = note:    expected unit type `()`\n-           found associated type `<impl Debug + ?Sized as Pointee>::Metadata`\n+           found associated type `<Opaque as Pointee>::Metadata`\n note: required by a bound in `is_thin`\n   --> $DIR/pointee-tail-is-generic-errors.rs:20:33\n    |\n LL | fn is_thin<T: std::ptr::Pointee<Metadata = ()> + ?Sized>() {}\n    |                                 ^^^^^^^^^^^^^ required by this bound in `is_thin`\n-help: consider constraining the associated type `<impl Debug + ?Sized as Pointee>::Metadata` to `()`\n+help: consider constraining the associated type `<Opaque as Pointee>::Metadata` to `()`\n    |\n LL | type Opaque = impl std::fmt::Debug<Metadata = ()> + ?Sized;\n    |                                   +++++++++++++++"}, {"sha": "185207b9800bbc0c41b4f53d5d7e1fb106965e2c", "filename": "src/test/ui/type-alias-impl-trait/argument-types.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fargument-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fargument-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fargument-types.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,14 +1,12 @@\n #![feature(type_alias_impl_trait)]\n #![allow(dead_code)]\n-\n+// check-pass\n use std::fmt::Debug;\n \n type Foo = impl Debug;\n \n-// FIXME: This should compile, but it currently doesn't\n fn foo1(mut x: Foo) {\n     x = 22_u32;\n-    //~^ ERROR: mismatched types [E0308]\n }\n \n fn foo2(mut x: Foo) {"}, {"sha": "a87e44a048b250c09704b31158b51aacf0c8a60c", "filename": "src/test/ui/type-alias-impl-trait/argument-types.stderr", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1446d17b8f4bd3ff8dbfb129a7674165e06f9f4c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fargument-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1446d17b8f4bd3ff8dbfb129a7674165e06f9f4c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fargument-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fargument-types.stderr?ref=1446d17b8f4bd3ff8dbfb129a7674165e06f9f4c", "patch": "@@ -1,17 +0,0 @@\n-error[E0308]: mismatched types\n-  --> $DIR/argument-types.rs:10:9\n-   |\n-LL | type Foo = impl Debug;\n-   |            ---------- the expected opaque type\n-...\n-LL | fn foo1(mut x: Foo) {\n-   |                --- expected due to this parameter type\n-LL |     x = 22_u32;\n-   |         ^^^^^^ expected opaque type, found `u32`\n-   |\n-   = note: expected opaque type `impl Debug`\n-                     found type `u32`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "0664275b2ad0a359520c9df3d97743000f2b5f54", "filename": "src/test/ui/type-alias-impl-trait/auto-trait-leakage2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage2.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -2,15 +2,15 @@ error[E0277]: `Rc<u32>` cannot be sent between threads safely\n   --> $DIR/auto-trait-leakage2.rs:17:13\n    |\n LL |     type Foo = impl std::fmt::Debug;\n-   |                -------------------- within this `impl Debug`\n+   |                -------------------- within this `Foo`\n ...\n LL |     is_send(m::foo());\n    |     ------- ^^^^^^^^ `Rc<u32>` cannot be sent between threads safely\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = help: within `impl Debug`, the trait `Send` is not implemented for `Rc<u32>`\n-   = note: required because it appears within the type `impl Debug`\n+   = help: within `Foo`, the trait `Send` is not implemented for `Rc<u32>`\n+   = note: required because it appears within the type `Foo`\n note: required by a bound in `is_send`\n   --> $DIR/auto-trait-leakage2.rs:14:15\n    |"}, {"sha": "b456b1445e7845ebbe29bf76a8514dd2bd57d4a6", "filename": "src/test/ui/type-alias-impl-trait/auto-trait-leakage3.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage3.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -6,6 +6,7 @@\n mod m {\n     type Foo = impl std::fmt::Debug;\n     //~^ ERROR: cycle detected when computing type of `m::Foo::{opaque#0}` [E0391]\n+    //~| ERROR: cycle detected when computing type of `m::Foo::{opaque#0}` [E0391]\n \n     pub fn foo() -> Foo {\n         22_u32"}, {"sha": "4c44875b4a548eb85a4d3a51fbe115d571b87d78", "filename": "src/test/ui/type-alias-impl-trait/auto-trait-leakage3.stderr", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage3.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -5,18 +5,35 @@ LL |     type Foo = impl std::fmt::Debug;\n    |                ^^^^^^^^^^^^^^^^^^^^\n    |\n note: ...which requires type-checking `m::bar`...\n-  --> $DIR/auto-trait-leakage3.rs:15:9\n+  --> $DIR/auto-trait-leakage3.rs:15:5\n    |\n-LL |         is_send(foo());\n-   |         ^^^^^^^\n-   = note: ...which requires evaluating trait selection obligation `impl core::fmt::Debug: core::marker::Send`...\n+LL |     pub fn bar() {\n+   |     ^^^^^^^^^^^^\n    = note: ...which again requires computing type of `m::Foo::{opaque#0}`, completing the cycle\n note: cycle used when checking item types in module `m`\n   --> $DIR/auto-trait-leakage3.rs:6:1\n    |\n LL | mod m {\n    | ^^^^^\n \n-error: aborting due to previous error\n+error[E0391]: cycle detected when computing type of `m::Foo::{opaque#0}`\n+  --> $DIR/auto-trait-leakage3.rs:7:16\n+   |\n+LL |     type Foo = impl std::fmt::Debug;\n+   |                ^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: ...which requires type-checking `m::bar`...\n+  --> $DIR/auto-trait-leakage3.rs:15:5\n+   |\n+LL |     pub fn bar() {\n+   |     ^^^^^^^^^^^^\n+   = note: ...which again requires computing type of `m::Foo::{opaque#0}`, completing the cycle\n+note: cycle used when checking item types in module `m`\n+  --> $DIR/auto-trait-leakage3.rs:6:1\n+   |\n+LL | mod m {\n+   | ^^^^^\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0391`."}, {"sha": "4d2890b5de583c48bc63a8e6d727e4d3516f03f1", "filename": "src/test/ui/type-alias-impl-trait/bound_reduction2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -7,13 +7,12 @@ trait TraitWithAssoc {\n }\n \n type Foo<V> = impl Trait<V>;\n-//~^ ERROR could not find defining uses\n \n trait Trait<U> {}\n \n impl<W> Trait<W> for () {}\n \n fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n-    //~^ ERROR non-defining opaque type use in defining scope\n     ()\n+    //~^ ERROR non-defining opaque type use\n }"}, {"sha": "c405b1f6af2057428a78bf0dc88993d954d99ad7", "filename": "src/test/ui/type-alias-impl-trait/bound_reduction2.stderr", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,20 +1,14 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/bound_reduction2.rs:16:46\n+  --> $DIR/bound_reduction2.rs:16:5\n    |\n-LL | fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n-   |                                              ^^^^^^^^^^^^^\n+LL |     ()\n+   |     ^^\n    |\n note: used non-generic type `<T as TraitWithAssoc>::Assoc` for generic parameter\n   --> $DIR/bound_reduction2.rs:9:10\n    |\n LL | type Foo<V> = impl Trait<V>;\n    |          ^\n \n-error: could not find defining uses\n-  --> $DIR/bound_reduction2.rs:9:15\n-   |\n-LL | type Foo<V> = impl Trait<V>;\n-   |               ^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "83d22161e4e75617fb3845576e8b6843d0eb966a", "filename": "src/test/ui/type-alias-impl-trait/bounds-are-checked.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -4,11 +4,11 @@\n #![feature(type_alias_impl_trait)]\n \n type X<'a> = impl Into<&'static str> + From<&'a str>;\n-//~^ ERROR mismatched types\n \n fn f<'a: 'static>(t: &'a str) -> X<'a> {\n     //~^ WARNING unnecessary lifetime parameter\n     t\n+    //~^ ERROR non-defining opaque type use\n }\n \n fn extend_lt<'a>(o: &'a str) -> &'static str {"}, {"sha": "d87ef2ec79c1a26bd14f122938098e1605769ab1", "filename": "src/test/ui/type-alias-impl-trait/bounds-are-checked.stderr", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -1,26 +1,19 @@\n warning: unnecessary lifetime parameter `'a`\n-  --> $DIR/bounds-are-checked.rs:9:6\n+  --> $DIR/bounds-are-checked.rs:8:6\n    |\n LL | fn f<'a: 'static>(t: &'a str) -> X<'a> {\n    |      ^^^^^^^^^^^\n    |\n    = help: you can use the `'static` lifetime directly, in place of `'a`\n \n-error[E0308]: mismatched types\n-  --> $DIR/bounds-are-checked.rs:6:14\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/bounds-are-checked.rs:10:5\n    |\n LL | type X<'a> = impl Into<&'static str> + From<&'a str>;\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ lifetime mismatch\n-   |\n-   = note: expected trait `From<&'a str>`\n-              found trait `From<&'static str>`\n-note: the lifetime `'a` as defined here...\n-  --> $DIR/bounds-are-checked.rs:6:8\n-   |\n-LL | type X<'a> = impl Into<&'static str> + From<&'a str>;\n-   |        ^^\n-   = note: ...does not necessarily outlive the static lifetime\n+   |        -- cannot use static lifetime; use a bound lifetime instead or remove the lifetime parameter from the opaque type\n+...\n+LL |     t\n+   |     ^\n \n error: aborting due to previous error; 1 warning emitted\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "a1a9401acc2c4e962a53de625e27810d445b986a", "filename": "src/test/ui/type-alias-impl-trait/closures_in_branches.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fclosures_in_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fclosures_in_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fclosures_in_branches.rs?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,31 @@\n+#![feature(type_alias_impl_trait)]\n+\n+type Foo = impl std::ops::FnOnce(String) -> usize;\n+\n+fn foo(b: bool) -> Foo {\n+    if b {\n+        |x| x.len()\n+    } else {\n+        panic!()\n+    }\n+}\n+\n+\n+type Foo1 = impl std::ops::FnOnce(String) -> usize;\n+fn foo1(b: bool) -> Foo1 {\n+    |x| x.len()\n+}\n+\n+fn bar(b: bool) -> impl std::ops::FnOnce(String) -> usize {\n+    if b {\n+        |x| x.len() //~ ERROR type annotations needed\n+    } else {\n+        panic!()\n+    }\n+}\n+\n+fn bar1(b: bool) -> impl std::ops::FnOnce(String) -> usize {\n+    |x| x.len()\n+}\n+\n+fn main() {}"}, {"sha": "cfa4a4b9d20ba669e9bb6757d93af36f156579a5", "filename": "src/test/ui/type-alias-impl-trait/closures_in_branches.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fclosures_in_branches.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fclosures_in_branches.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fclosures_in_branches.stderr?ref=f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e", "patch": "@@ -0,0 +1,11 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/closures_in_branches.rs:21:10\n+   |\n+LL |         |x| x.len()\n+   |          ^ consider giving this closure parameter a type\n+   |\n+   = note: type must be known at this point\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}]}