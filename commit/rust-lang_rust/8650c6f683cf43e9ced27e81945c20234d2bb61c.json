{"sha": "8650c6f683cf43e9ced27e81945c20234d2bb61c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2NTBjNmY2ODNjZjQzZTljZWQyN2U4MTk0NWMyMDIzNGQyYmI2MWM=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-12-18T03:31:04Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-12-18T04:00:36Z"}, "message": "Switch from serialization to std::serialize. (snapshot)", "tree": {"sha": "bd2e18afb29e2d998bf2a4e55f47c43867026901", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd2e18afb29e2d998bf2a4e55f47c43867026901"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8650c6f683cf43e9ced27e81945c20234d2bb61c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8650c6f683cf43e9ced27e81945c20234d2bb61c", "html_url": "https://github.com/rust-lang/rust/commit/8650c6f683cf43e9ced27e81945c20234d2bb61c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8650c6f683cf43e9ced27e81945c20234d2bb61c/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec9305802ba1bde2d0de34278395379de69f3468", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec9305802ba1bde2d0de34278395379de69f3468", "html_url": "https://github.com/rust-lang/rust/commit/ec9305802ba1bde2d0de34278395379de69f3468"}], "stats": {"total": 853, "additions": 422, "deletions": 431}, "files": [{"sha": "e61714c0dd2771faaece07469d344e0ba359753d", "filename": "src/librustc/README.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibrustc%2FREADME.txt", "raw_url": "https://github.com/rust-lang/rust/raw/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibrustc%2FREADME.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FREADME.txt?ref=8650c6f683cf43e9ced27e81945c20234d2bb61c", "patch": "@@ -23,7 +23,7 @@ front/    - front-end: attributes, conditional compilation\n middle/   - middle-end: name resolution, typechecking, LLVM code\n                   generation\n back/     - back-end: linking and ABI\n-metadata/ - serializer and deserializer for data required by\n+metadata/ - encoder and decoder for data required by\n                     separate compilation\n driver/   - command-line processing, main() entrypoint\n util/     - ubiquitous types and helper functions"}, {"sha": "d21cf71ac45f07f348fb416217a6f56dbadf5565", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=8650c6f683cf43e9ced27e81945c20234d2bb61c", "patch": "@@ -25,7 +25,7 @@ use reader = std::ebml::reader;\n use std::ebml;\n use std::map::HashMap;\n use std::map;\n-use std::serialization::deserialize;\n+use std::serialize::decode;\n use syntax::ast_map;\n use syntax::attr;\n use syntax::diagnostic::span_handler;\n@@ -284,7 +284,7 @@ fn item_ty_param_bounds(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd)\n \n fn item_ty_region_param(item: ebml::Doc) -> Option<ty::region_variance> {\n     reader::maybe_get_doc(item, tag_region_param).map(|doc| {\n-        deserialize(&reader::Deserializer(*doc))\n+        decode(&reader::Decoder(*doc))\n     })\n }\n "}, {"sha": "ab6992c1283bc3f1bbc5b6b3842a016a1cbe02f5", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=8650c6f683cf43e9ced27e81945c20234d2bb61c", "patch": "@@ -50,7 +50,7 @@ export encode_def_id;\n type abbrev_map = map::HashMap<ty::t, tyencode::ty_abbrev>;\n \n type encode_inlined_item = fn@(ecx: @encode_ctxt,\n-                               ebml_w: writer::Serializer,\n+                               ebml_w: writer::Encoder,\n                                path: ast_map::path,\n                                ii: ast::inlined_item);\n \n@@ -96,31 +96,31 @@ fn reachable(ecx: @encode_ctxt, id: node_id) -> bool {\n     ecx.reachable.contains_key(id)\n }\n \n-fn encode_name(ecx: @encode_ctxt, ebml_w: writer::Serializer, name: ident) {\n+fn encode_name(ecx: @encode_ctxt, ebml_w: writer::Encoder, name: ident) {\n     ebml_w.wr_tagged_str(tag_paths_data_name, ecx.tcx.sess.str_of(name));\n }\n \n-fn encode_impl_type_basename(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n+fn encode_impl_type_basename(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                              name: ident) {\n     ebml_w.wr_tagged_str(tag_item_impl_type_basename,\n                          ecx.tcx.sess.str_of(name));\n }\n \n-fn encode_def_id(ebml_w: writer::Serializer, id: def_id) {\n+fn encode_def_id(ebml_w: writer::Encoder, id: def_id) {\n     ebml_w.wr_tagged_str(tag_def_id, def_to_str(id));\n }\n \n-fn encode_region_param(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n+fn encode_region_param(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                        it: @ast::item) {\n     let opt_rp = ecx.tcx.region_paramd_items.find(it.id);\n     for opt_rp.each |rp| {\n         do ebml_w.wr_tag(tag_region_param) {\n-            (*rp).serialize(&ebml_w);\n+            (*rp).encode(&ebml_w);\n         }\n     }\n }\n \n-fn encode_mutability(ebml_w: writer::Serializer, mt: struct_mutability) {\n+fn encode_mutability(ebml_w: writer::Encoder, mt: struct_mutability) {\n     do ebml_w.wr_tag(tag_struct_mut) {\n         let val = match mt {\n           struct_immutable => 'a',\n@@ -132,7 +132,7 @@ fn encode_mutability(ebml_w: writer::Serializer, mt: struct_mutability) {\n \n type entry<T> = {val: T, pos: uint};\n \n-fn add_to_index(ecx: @encode_ctxt, ebml_w: writer::Serializer, path: &[ident],\n+fn add_to_index(ecx: @encode_ctxt, ebml_w: writer::Encoder, path: &[ident],\n                 index: &mut ~[entry<~str>], name: ident) {\n     let mut full_path = ~[];\n     full_path.push_all(path);\n@@ -143,7 +143,7 @@ fn add_to_index(ecx: @encode_ctxt, ebml_w: writer::Serializer, path: &[ident],\n          pos: ebml_w.writer.tell()});\n }\n \n-fn encode_trait_ref(ebml_w: writer::Serializer, ecx: @encode_ctxt,\n+fn encode_trait_ref(ebml_w: writer::Encoder, ecx: @encode_ctxt,\n                     t: @trait_ref) {\n     ebml_w.start_tag(tag_impl_trait);\n     encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, t.ref_id));\n@@ -152,15 +152,15 @@ fn encode_trait_ref(ebml_w: writer::Serializer, ecx: @encode_ctxt,\n \n \n // Item info table encoding\n-fn encode_family(ebml_w: writer::Serializer, c: char) {\n+fn encode_family(ebml_w: writer::Encoder, c: char) {\n     ebml_w.start_tag(tag_items_data_item_family);\n     ebml_w.writer.write(&[c as u8]);\n     ebml_w.end_tag();\n }\n \n fn def_to_str(did: def_id) -> ~str { fmt!(\"%d:%d\", did.crate, did.node) }\n \n-fn encode_ty_type_param_bounds(ebml_w: writer::Serializer, ecx: @encode_ctxt,\n+fn encode_ty_type_param_bounds(ebml_w: writer::Encoder, ecx: @encode_ctxt,\n                                params: @~[ty::param_bounds]) {\n     let ty_str_ctxt = @{diag: ecx.diag,\n                         ds: def_to_str,\n@@ -174,21 +174,21 @@ fn encode_ty_type_param_bounds(ebml_w: writer::Serializer, ecx: @encode_ctxt,\n     }\n }\n \n-fn encode_type_param_bounds(ebml_w: writer::Serializer, ecx: @encode_ctxt,\n+fn encode_type_param_bounds(ebml_w: writer::Encoder, ecx: @encode_ctxt,\n                             params: ~[ty_param]) {\n     let ty_param_bounds =\n         @params.map(|param| ecx.tcx.ty_param_bounds.get(param.id));\n     encode_ty_type_param_bounds(ebml_w, ecx, ty_param_bounds);\n }\n \n \n-fn encode_variant_id(ebml_w: writer::Serializer, vid: def_id) {\n+fn encode_variant_id(ebml_w: writer::Encoder, vid: def_id) {\n     ebml_w.start_tag(tag_items_data_item_variant);\n     ebml_w.writer.write(str::to_bytes(def_to_str(vid)));\n     ebml_w.end_tag();\n }\n \n-fn write_type(ecx: @encode_ctxt, ebml_w: writer::Serializer, typ: ty::t) {\n+fn write_type(ecx: @encode_ctxt, ebml_w: writer::Encoder, typ: ty::t) {\n     let ty_str_ctxt =\n         @{diag: ecx.diag,\n           ds: def_to_str,\n@@ -198,7 +198,7 @@ fn write_type(ecx: @encode_ctxt, ebml_w: writer::Serializer, typ: ty::t) {\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n \n-fn write_vstore(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n+fn write_vstore(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                 vstore: ty::vstore) {\n     let ty_str_ctxt =\n         @{diag: ecx.diag,\n@@ -209,13 +209,13 @@ fn write_vstore(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n     tyencode::enc_vstore(ebml_w.writer, ty_str_ctxt, vstore);\n }\n \n-fn encode_type(ecx: @encode_ctxt, ebml_w: writer::Serializer, typ: ty::t) {\n+fn encode_type(ecx: @encode_ctxt, ebml_w: writer::Encoder, typ: ty::t) {\n     ebml_w.start_tag(tag_items_data_item_type);\n     write_type(ecx, ebml_w, typ);\n     ebml_w.end_tag();\n }\n \n-fn encode_symbol(ecx: @encode_ctxt, ebml_w: writer::Serializer, id: node_id) {\n+fn encode_symbol(ecx: @encode_ctxt, ebml_w: writer::Encoder, id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     let sym = match ecx.item_symbols.find(id) {\n       Some(ref x) => (*x),\n@@ -228,27 +228,27 @@ fn encode_symbol(ecx: @encode_ctxt, ebml_w: writer::Serializer, id: node_id) {\n     ebml_w.end_tag();\n }\n \n-fn encode_discriminant(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n+fn encode_discriminant(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                        id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     ebml_w.writer.write(str::to_bytes(ecx.discrim_symbols.get(id)));\n     ebml_w.end_tag();\n }\n \n-fn encode_disr_val(_ecx: @encode_ctxt, ebml_w: writer::Serializer,\n+fn encode_disr_val(_ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                    disr_val: int) {\n     ebml_w.start_tag(tag_disr_val);\n     ebml_w.writer.write(str::to_bytes(int::to_str(disr_val,10u)));\n     ebml_w.end_tag();\n }\n \n-fn encode_parent_item(ebml_w: writer::Serializer, id: def_id) {\n+fn encode_parent_item(ebml_w: writer::Encoder, id: def_id) {\n     ebml_w.start_tag(tag_items_data_parent_item);\n     ebml_w.writer.write(str::to_bytes(def_to_str(id)));\n     ebml_w.end_tag();\n }\n \n-fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n+fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                             id: node_id, variants: ~[variant],\n                             path: ast_map::path, index: @mut ~[entry<int>],\n                             ty_params: ~[ty_param]) {\n@@ -285,9 +285,9 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n     }\n }\n \n-fn encode_path(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n+fn encode_path(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                path: ast_map::path, name: ast_map::path_elt) {\n-    fn encode_path_elt(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n+    fn encode_path_elt(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                        elt: ast_map::path_elt) {\n         let (tag, name) = match elt {\n           ast_map::path_mod(name) => (tag_path_elt_mod, name),\n@@ -306,7 +306,7 @@ fn encode_path(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n     }\n }\n \n-fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n+fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                        md: _mod, id: node_id, path: ast_map::path,\n                        name: ident) {\n     ebml_w.start_tag(tag_items_data_item);\n@@ -365,15 +365,15 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n     ebml_w.end_tag();\n }\n \n-fn encode_visibility(ebml_w: writer::Serializer, visibility: visibility) {\n+fn encode_visibility(ebml_w: writer::Encoder, visibility: visibility) {\n     encode_family(ebml_w, match visibility {\n         public => 'g',\n         private => 'j',\n         inherited => 'N'\n     });\n }\n \n-fn encode_self_type(ebml_w: writer::Serializer, self_type: ast::self_ty_) {\n+fn encode_self_type(ebml_w: writer::Encoder, self_type: ast::self_ty_) {\n     ebml_w.start_tag(tag_item_trait_method_self_ty);\n \n     // Encode the base self type.\n@@ -405,14 +405,14 @@ fn encode_self_type(ebml_w: writer::Serializer, self_type: ast::self_ty_) {\n     ebml_w.end_tag();\n }\n \n-fn encode_method_sort(ebml_w: writer::Serializer, sort: char) {\n+fn encode_method_sort(ebml_w: writer::Encoder, sort: char) {\n     ebml_w.start_tag(tag_item_trait_method_sort);\n     ebml_w.writer.write(&[ sort as u8 ]);\n     ebml_w.end_tag();\n }\n \n /* Returns an index of items in this class */\n-fn encode_info_for_struct(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n+fn encode_info_for_struct(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                          path: ast_map::path,\n                          fields: ~[@struct_field],\n                          global_index: @mut~[entry<int>]) -> ~[entry<int>] {\n@@ -447,7 +447,7 @@ fn encode_info_for_struct(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n }\n \n // This is for encoding info for ctors and dtors\n-fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n+fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                         id: node_id, ident: ident, path: ast_map::path,\n                         item: Option<inlined_item>, tps: ~[ty_param]) {\n         ebml_w.start_tag(tag_items_data_item);\n@@ -472,7 +472,7 @@ fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n         ebml_w.end_tag();\n }\n \n-fn encode_info_for_method(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n+fn encode_info_for_method(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                           impl_path: ast_map::path, should_inline: bool,\n                           parent_id: node_id,\n                           m: @method, all_tps: ~[ty_param]) {\n@@ -527,7 +527,7 @@ fn should_inline(attrs: ~[attribute]) -> bool {\n }\n \n \n-fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n+fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                         item: @item, index: @mut ~[entry<int>],\n                         path: ast_map::path) {\n \n@@ -540,7 +540,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n         };\n     if !must_write && !reachable(ecx, item.id) { return; }\n \n-    fn add_to_index_(item: @item, ebml_w: writer::Serializer,\n+    fn add_to_index_(item: @item, ebml_w: writer::Encoder,\n                      index: @mut ~[entry<int>]) {\n         index.push({val: item.id, pos: ebml_w.writer.tell()});\n     }\n@@ -807,7 +807,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n     }\n }\n \n-fn encode_info_for_foreign_item(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n+fn encode_info_for_foreign_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                                 nitem: @foreign_item,\n                                 index: @mut ~[entry<int>],\n                                 path: ast_map::path, abi: foreign_abi) {\n@@ -840,7 +840,7 @@ fn encode_info_for_foreign_item(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n     ebml_w.end_tag();\n }\n \n-fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n+fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                          crate: @crate) -> ~[entry<int>] {\n     let index = @mut ~[];\n     ebml_w.start_tag(tag_items_data);\n@@ -895,7 +895,7 @@ fn create_index<T: Copy Hash IterBytes>(index: ~[entry<T>]) ->\n     return buckets_frozen;\n }\n \n-fn encode_index<T>(ebml_w: writer::Serializer, buckets: ~[@~[entry<T>]],\n+fn encode_index<T>(ebml_w: writer::Encoder, buckets: ~[@~[entry<T>]],\n                    write_fn: fn(io::Writer, T)) {\n     let writer = ebml_w.writer;\n     ebml_w.start_tag(tag_index);\n@@ -930,7 +930,7 @@ fn write_int(writer: io::Writer, &&n: int) {\n     writer.write_be_u32(n as u32);\n }\n \n-fn encode_meta_item(ebml_w: writer::Serializer, mi: meta_item) {\n+fn encode_meta_item(ebml_w: writer::Encoder, mi: meta_item) {\n     match mi.node {\n       meta_word(ref name) => {\n         ebml_w.start_tag(tag_meta_item_word);\n@@ -967,7 +967,7 @@ fn encode_meta_item(ebml_w: writer::Serializer, mi: meta_item) {\n     }\n }\n \n-fn encode_attributes(ebml_w: writer::Serializer, attrs: ~[attribute]) {\n+fn encode_attributes(ebml_w: writer::Encoder, attrs: ~[attribute]) {\n     ebml_w.start_tag(tag_attributes);\n     for attrs.each |attr| {\n         ebml_w.start_tag(tag_attribute);\n@@ -1028,7 +1028,7 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> ~[attribute] {\n     return attrs;\n }\n \n-fn encode_crate_deps(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n+fn encode_crate_deps(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                      cstore: cstore::CStore) {\n \n     fn get_ordered_deps(ecx: @encode_ctxt, cstore: cstore::CStore)\n@@ -1074,7 +1074,7 @@ fn encode_crate_deps(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n     ebml_w.end_tag();\n }\n \n-fn encode_crate_dep(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n+fn encode_crate_dep(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                     dep: decoder::crate_dep) {\n     ebml_w.start_tag(tag_crate_dep);\n     ebml_w.start_tag(tag_crate_dep_name);\n@@ -1089,7 +1089,7 @@ fn encode_crate_dep(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n     ebml_w.end_tag();\n }\n \n-fn encode_hash(ebml_w: writer::Serializer, hash: ~str) {\n+fn encode_hash(ebml_w: writer::Encoder, hash: ~str) {\n     ebml_w.start_tag(tag_crate_hash);\n     ebml_w.writer.write(str::to_bytes(hash));\n     ebml_w.end_tag();\n@@ -1127,7 +1127,7 @@ fn encode_metadata(parms: encode_parms, crate: @crate) -> ~[u8] {\n         type_abbrevs: ty::new_ty_hash()\n      });\n \n-    let ebml_w = writer::Serializer(wr as io::Writer);\n+    let ebml_w = writer::Encoder(wr as io::Writer);\n \n     encode_hash(ebml_w, ecx.link_meta.extras_hash);\n "}, {"sha": "7456c67a588f689475cb5a2293f057a82799b356", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 62, "deletions": 63, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=8650c6f683cf43e9ced27e81945c20234d2bb61c", "patch": "@@ -24,12 +24,11 @@ use util::ppaux::ty_to_str;\n \n use reader = std::ebml::reader;\n use std::ebml::reader::get_doc;\n-use std::ebml::writer::Serializer;\n+use std::ebml::writer::Encoder;\n use std::ebml;\n use std::map::HashMap;\n-use std::serialization::{DeserializerHelpers, deserialize};\n-use std::serialization::{Serializable, SerializerHelpers};\n-use std::serialization;\n+use std::serialize;\n+use std::serialize::{Encodable, EncoderHelpers, DecoderHelpers, decode};\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util;\n@@ -84,7 +83,7 @@ trait tr_intern {\n // Top-level methods.\n \n fn encode_inlined_item(ecx: @e::encode_ctxt,\n-                       ebml_w: writer::Serializer,\n+                       ebml_w: writer::Encoder,\n                        path: ast_map::path,\n                        ii: ast::inlined_item,\n                        maps: maps) {\n@@ -95,7 +94,7 @@ fn encode_inlined_item(ecx: @e::encode_ctxt,\n \n     let id_range = ast_util::compute_id_range_for_inlined_item(ii);\n     do ebml_w.wr_tag(c::tag_ast as uint) {\n-        id_range.serialize(&ebml_w);\n+        id_range.encode(&ebml_w);\n         encode_ast(ebml_w, simplify_ast(ii));\n         encode_side_tables_for_ii(ecx, maps, ebml_w, ii);\n     }\n@@ -117,8 +116,8 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n       Some(ast_doc) => {\n         debug!(\"> Decoding inlined fn: %s::?\",\n                ast_map::path_to_str(path, tcx.sess.parse_sess.interner));\n-        let ast_dsr = &reader::Deserializer(ast_doc);\n-        let from_id_range = deserialize(ast_dsr);\n+        let ast_dsr = &reader::Decoder(ast_doc);\n+        let from_id_range = decode(ast_dsr);\n         let to_id_range = reserve_id_range(dcx.tcx.sess, from_id_range);\n         let xcx = extended_decode_ctxt_(@{dcx: dcx,\n                                           from_id_range: from_id_range,\n@@ -194,24 +193,24 @@ impl span: tr {\n     }\n }\n \n-trait def_id_serializer_helpers {\n+trait def_id_encoder_helpers {\n     fn emit_def_id(did: ast::def_id);\n }\n \n-impl<S: serialization::Serializer> S: def_id_serializer_helpers {\n+impl<S: serialize::Encoder> S: def_id_encoder_helpers {\n     fn emit_def_id(did: ast::def_id) {\n-        did.serialize(&self)\n+        did.encode(&self)\n     }\n }\n \n-trait def_id_deserializer_helpers {\n+trait def_id_decoder_helpers {\n     fn read_def_id(xcx: extended_decode_ctxt) -> ast::def_id;\n }\n \n-impl<D: serialization::Deserializer> D: def_id_deserializer_helpers {\n+impl<D: serialize::Decoder> D: def_id_decoder_helpers {\n \n     fn read_def_id(xcx: extended_decode_ctxt) -> ast::def_id {\n-        let did: ast::def_id = deserialize(&self);\n+        let did: ast::def_id = decode(&self);\n         did.tr(xcx)\n     }\n }\n@@ -231,9 +230,9 @@ impl<D: serialization::Deserializer> D: def_id_deserializer_helpers {\n // We also have to adjust the spans: for now we just insert a dummy span,\n // but eventually we should add entries to the local codemap as required.\n \n-fn encode_ast(ebml_w: writer::Serializer, item: ast::inlined_item) {\n+fn encode_ast(ebml_w: writer::Encoder, item: ast::inlined_item) {\n     do ebml_w.wr_tag(c::tag_tree as uint) {\n-        item.serialize(&ebml_w)\n+        item.encode(&ebml_w)\n     }\n }\n \n@@ -287,8 +286,8 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n \n fn decode_ast(par_doc: ebml::Doc) -> ast::inlined_item {\n     let chi_doc = par_doc[c::tag_tree as uint];\n-    let d = &reader::Deserializer(chi_doc);\n-    deserialize(d)\n+    let d = &reader::Decoder(chi_doc);\n+    decode(d)\n }\n \n fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n@@ -327,13 +326,13 @@ fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n // ______________________________________________________________________\n // Encoding and decoding of ast::def\n \n-fn encode_def(ebml_w: writer::Serializer, def: ast::def) {\n-    def.serialize(&ebml_w)\n+fn encode_def(ebml_w: writer::Encoder, def: ast::def) {\n+    def.encode(&ebml_w)\n }\n \n fn decode_def(xcx: extended_decode_ctxt, doc: ebml::Doc) -> ast::def {\n-    let dsr = &reader::Deserializer(doc);\n-    let def: ast::def = deserialize(dsr);\n+    let dsr = &reader::Decoder(doc);\n+    let def: ast::def = decode(dsr);\n     def.tr(xcx)\n }\n \n@@ -421,17 +420,17 @@ impl ty::bound_region: tr {\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n \n-fn encode_freevar_entry(ebml_w: writer::Serializer, fv: @freevar_entry) {\n-    (*fv).serialize(&ebml_w)\n+fn encode_freevar_entry(ebml_w: writer::Encoder, fv: @freevar_entry) {\n+    (*fv).encode(&ebml_w)\n }\n \n-trait ebml_deserializer_helper {\n+trait ebml_decoder_helper {\n     fn read_freevar_entry(xcx: extended_decode_ctxt) -> freevar_entry;\n }\n \n-impl reader::Deserializer: ebml_deserializer_helper {\n+impl reader::Decoder: ebml_decoder_helper {\n     fn read_freevar_entry(xcx: extended_decode_ctxt) -> freevar_entry {\n-        let fv: freevar_entry = deserialize(&self);\n+        let fv: freevar_entry = decode(&self);\n         fv.tr(xcx)\n     }\n }\n@@ -449,23 +448,23 @@ trait read_method_map_entry_helper {\n     fn read_method_map_entry(xcx: extended_decode_ctxt) -> method_map_entry;\n }\n \n-fn serialize_method_map_entry(ecx: @e::encode_ctxt,\n-                              ebml_w: writer::Serializer,\n+fn encode_method_map_entry(ecx: @e::encode_ctxt,\n+                              ebml_w: writer::Encoder,\n                               mme: method_map_entry) {\n     do ebml_w.emit_rec {\n         do ebml_w.emit_field(~\"self_arg\", 0u) {\n             ebml_w.emit_arg(ecx, mme.self_arg);\n         }\n         do ebml_w.emit_field(~\"explicit_self\", 2u) {\n-            mme.explicit_self.serialize(&ebml_w);\n+            mme.explicit_self.encode(&ebml_w);\n         }\n         do ebml_w.emit_field(~\"origin\", 1u) {\n-            mme.origin.serialize(&ebml_w);\n+            mme.origin.encode(&ebml_w);\n         }\n     }\n }\n \n-impl reader::Deserializer: read_method_map_entry_helper {\n+impl reader::Decoder: read_method_map_entry_helper {\n     fn read_method_map_entry(xcx: extended_decode_ctxt) -> method_map_entry {\n         do self.read_rec {\n             {self_arg:\n@@ -474,12 +473,12 @@ impl reader::Deserializer: read_method_map_entry_helper {\n                  }),\n              explicit_self:\n                  self.read_field(~\"explicit_self\", 2u, || {\n-                    let self_type: ast::self_ty_ = deserialize(&self);\n+                    let self_type: ast::self_ty_ = decode(&self);\n                     self_type\n                  }),\n              origin:\n                  self.read_field(~\"origin\", 1u, || {\n-                     let method_origin: method_origin = deserialize(&self);\n+                     let method_origin: method_origin = decode(&self);\n                      method_origin.tr(xcx)\n                  })}\n         }\n@@ -509,19 +508,19 @@ impl method_origin: tr {\n // Encoding and decoding vtable_res\n \n fn encode_vtable_res(ecx: @e::encode_ctxt,\n-                     ebml_w: writer::Serializer,\n+                     ebml_w: writer::Encoder,\n                      dr: typeck::vtable_res) {\n-    // can't autogenerate this code because automatic serialization of\n+    // can't autogenerate this code because automatic code of\n     // ty::t doesn't work, and there is no way (atm) to have\n-    // hand-written serialization routines combine with auto-generated\n+    // hand-written encoding routines combine with auto-generated\n     // ones.  perhaps we should fix this.\n     do ebml_w.emit_from_vec(*dr) |vtable_origin| {\n         encode_vtable_origin(ecx, ebml_w, *vtable_origin)\n     }\n }\n \n fn encode_vtable_origin(ecx: @e::encode_ctxt,\n-                      ebml_w: writer::Serializer,\n+                      ebml_w: writer::Encoder,\n                       vtable_origin: typeck::vtable_origin) {\n     do ebml_w.emit_enum(~\"vtable_origin\") {\n         match vtable_origin {\n@@ -563,12 +562,12 @@ fn encode_vtable_origin(ecx: @e::encode_ctxt,\n \n }\n \n-trait vtable_deserialization_helpers {\n+trait vtable_decoder_helpers {\n     fn read_vtable_res(xcx: extended_decode_ctxt) -> typeck::vtable_res;\n     fn read_vtable_origin(xcx: extended_decode_ctxt) -> typeck::vtable_origin;\n }\n \n-impl reader::Deserializer: vtable_deserialization_helpers {\n+impl reader::Decoder: vtable_decoder_helpers {\n     fn read_vtable_res(xcx: extended_decode_ctxt) -> typeck::vtable_res {\n         @self.read_to_vec(|| self.read_vtable_origin(xcx) )\n     }\n@@ -645,7 +644,7 @@ trait ebml_writer_helpers {\n     fn emit_tpbt(ecx: @e::encode_ctxt, tpbt: ty::ty_param_bounds_and_ty);\n }\n \n-impl writer::Serializer: ebml_writer_helpers {\n+impl writer::Encoder: ebml_writer_helpers {\n     fn emit_ty(ecx: @e::encode_ctxt, ty: ty::t) {\n         do self.emit_opaque {\n             e::write_type(ecx, self, ty)\n@@ -684,7 +683,7 @@ impl writer::Serializer: ebml_writer_helpers {\n                 }\n             }\n             do self.emit_field(~\"region_param\", 1u) {\n-                tpbt.region_param.serialize(&self);\n+                tpbt.region_param.encode(&self);\n             }\n             do self.emit_field(~\"ty\", 2u) {\n                 self.emit_ty(ecx, tpbt.ty);\n@@ -698,7 +697,7 @@ trait write_tag_and_id {\n     fn id(id: ast::node_id);\n }\n \n-impl writer::Serializer: write_tag_and_id {\n+impl writer::Encoder: write_tag_and_id {\n     fn tag(tag_id: c::astencode_tag, f: fn()) {\n         do self.wr_tag(tag_id as uint) { f() }\n     }\n@@ -710,7 +709,7 @@ impl writer::Serializer: write_tag_and_id {\n \n fn encode_side_tables_for_ii(ecx: @e::encode_ctxt,\n                              maps: maps,\n-                             ebml_w: writer::Serializer,\n+                             ebml_w: writer::Encoder,\n                              ii: ast::inlined_item) {\n     do ebml_w.wr_tag(c::tag_table as uint) {\n         ast_util::visit_ids_for_inlined_item(\n@@ -726,7 +725,7 @@ fn encode_side_tables_for_ii(ecx: @e::encode_ctxt,\n \n fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n                              maps: maps,\n-                             ebml_w: writer::Serializer,\n+                             ebml_w: writer::Encoder,\n                              id: ast::node_id) {\n     let tcx = ecx.tcx;\n \n@@ -736,7 +735,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         do ebml_w.tag(c::tag_table_def) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n-                (*def).serialize(&ebml_w)\n+                (*def).encode(&ebml_w)\n             }\n         }\n     }\n@@ -813,7 +812,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n                 do ebml_w.emit_from_vec((*m).get()) |id| {\n-                    id.serialize(&ebml_w);\n+                    id.encode(&ebml_w);\n                 }\n             }\n         }\n@@ -823,7 +822,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         do ebml_w.tag(c::tag_table_method_map) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n-                serialize_method_map_entry(ecx, ebml_w, *mme)\n+                encode_method_map_entry(ecx, ebml_w, *mme)\n             }\n         }\n     }\n@@ -841,7 +840,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         do ebml_w.tag(c::tag_table_adjustments) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n-                (**adj).serialize(&ebml_w)\n+                (**adj).encode(&ebml_w)\n             }\n         }\n     }\n@@ -856,7 +855,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         do ebml_w.tag(c::tag_table_value_mode) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n-                (*vm).serialize(&ebml_w)\n+                (*vm).encode(&ebml_w)\n             }\n         }\n     }\n@@ -874,7 +873,7 @@ impl ebml::Doc: doc_decoder_helpers {\n     }\n }\n \n-trait ebml_deserializer_decoder_helpers {\n+trait ebml_decoder_decoder_helpers {\n     fn read_arg(xcx: extended_decode_ctxt) -> ty::arg;\n     fn read_ty(xcx: extended_decode_ctxt) -> ty::t;\n     fn read_tys(xcx: extended_decode_ctxt) -> ~[ty::t];\n@@ -883,7 +882,7 @@ trait ebml_deserializer_decoder_helpers {\n                                 -> ty::ty_param_bounds_and_ty;\n }\n \n-impl reader::Deserializer: ebml_deserializer_decoder_helpers {\n+impl reader::Decoder: ebml_decoder_decoder_helpers {\n \n     fn read_arg(xcx: extended_decode_ctxt) -> ty::arg {\n         do self.read_opaque |doc| {\n@@ -927,7 +926,7 @@ impl reader::Deserializer: ebml_deserializer_decoder_helpers {\n                     @self.read_to_vec(|| self.read_bounds(xcx) )\n                 }),\n                 region_param: self.read_field(~\"region_param\", 1u, || {\n-                    deserialize(&self)\n+                    decode(&self)\n                 }),\n                 ty: self.read_field(~\"ty\", 2u, || {\n                     self.read_ty(xcx)\n@@ -955,7 +954,7 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n             dcx.tcx.legacy_boxed_traits.insert(id, ());\n         } else {\n             let val_doc = entry_doc[c::tag_table_val as uint];\n-            let val_dsr = &reader::Deserializer(val_doc);\n+            let val_dsr = &reader::Decoder(val_doc);\n             if tag == (c::tag_table_def as uint) {\n                 let def = decode_def(xcx, val_doc);\n                 dcx.tcx.def_map.insert(id, def);\n@@ -991,11 +990,11 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n                 dcx.maps.vtable_map.insert(id,\n                                            val_dsr.read_vtable_res(xcx));\n             } else if tag == (c::tag_table_adjustments as uint) {\n-                let adj: @ty::AutoAdjustment = @deserialize(val_dsr);\n+                let adj: @ty::AutoAdjustment = @decode(val_dsr);\n                 adj.tr(xcx);\n                 dcx.tcx.adjustments.insert(id, adj);\n             } else if tag == (c::tag_table_value_mode as uint) {\n-                let vm: ty::ValueMode = deserialize(val_dsr);\n+                let vm: ty::ValueMode = decode(val_dsr);\n                 dcx.tcx.value_modes.insert(id, vm);\n             } else {\n                 xcx.dcx.tcx.sess.bug(\n@@ -1011,17 +1010,17 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n // Testing of astencode_gen\n \n #[cfg(test)]\n-fn encode_item_ast(ebml_w: writer::Serializer, item: @ast::item) {\n+fn encode_item_ast(ebml_w: writer::Encoder, item: @ast::item) {\n     do ebml_w.wr_tag(c::tag_tree as uint) {\n-        (*item).serialize(&ebml_w)\n+        (*item).encode(&ebml_w)\n     }\n }\n \n #[cfg(test)]\n fn decode_item_ast(par_doc: ebml::Doc) -> @ast::item {\n     let chi_doc = par_doc[c::tag_tree as uint];\n-    let d = &reader::Deserializer(chi_doc);\n-    @deserialize(d)\n+    let d = &reader::Decoder(chi_doc);\n+    @decode(d)\n }\n \n #[cfg(test)]\n@@ -1060,17 +1059,17 @@ fn mk_ctxt() -> fake_ext_ctxt {\n fn roundtrip(in_item: Option<@ast::item>) {\n     let in_item = in_item.get();\n     let bytes = do io::with_bytes_writer |wr| {\n-        let ebml_w = writer::Serializer(wr);\n+        let ebml_w = writer::Encoder(wr);\n         encode_item_ast(ebml_w, in_item);\n     };\n     let ebml_doc = reader::Doc(@bytes);\n     let out_item = decode_item_ast(ebml_doc);\n \n     let exp_str = do io::with_str_writer |w| {\n-        in_item.serialize(&std::prettyprint::Serializer(w))\n+        in_item.encode(&std::prettyprint::Encoder(w))\n     };\n     let out_str = do io::with_str_writer |w| {\n-        out_item.serialize(&std::prettyprint::Serializer(w))\n+        out_item.encode(&std::prettyprint::Encoder(w))\n     };\n \n     debug!(\"expected string: %s\", exp_str);"}, {"sha": "38ec7dd5eb07113c5fac9495d14a861e6982842e", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=8650c6f683cf43e9ced27e81945c20234d2bb61c", "patch": "@@ -26,8 +26,8 @@ export has_freevars;\n \n // A vector of defs representing the free variables referred to in a function.\n // (The def_upvar will already have been stripped).\n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type freevar_entry = {\n     def: ast::def, //< The variable being accessed free.\n     span: span     //< First span where it is accessed (there can be multiple)"}, {"sha": "dc2632156466c7dc5b7670e382709a309cabe5a6", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=8650c6f683cf43e9ced27e81945c20234d2bb61c", "patch": "@@ -106,7 +106,7 @@ export ty_estr, mk_estr, type_is_str;\n export ty_evec, mk_evec, type_is_vec;\n export ty_unboxed_vec, mk_unboxed_vec, mk_mut_unboxed_vec;\n export vstore, vstore_fixed, vstore_uniq, vstore_box, vstore_slice;\n-export serialize_vstore, deserialize_vstore;\n+export encode_vstore, decode_vstore;\n export ty_nil, mk_nil, type_is_nil;\n export ty_trait, mk_trait;\n export ty_param, mk_param, ty_params_to_tys;\n@@ -238,8 +238,8 @@ type method = {ident: ast::ident,\n \n type mt = {ty: t, mutbl: ast::mutability};\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum vstore {\n     vstore_fixed(uint),\n     vstore_uniq,\n@@ -255,8 +255,8 @@ type field_ty = {\n };\n \n /// How an lvalue is to be used.\n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n pub enum ValueMode {\n     ReadValue,  // Non-destructively read the value; do not copy or move.\n     CopyValue,  // Copy the value.\n@@ -307,8 +307,8 @@ enum ast_ty_to_ty_cache_entry {\n \n type opt_region_variance = Option<region_variance>;\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum region_variance { rv_covariant, rv_invariant, rv_contravariant }\n \n impl region_variance : cmp::Eq {\n@@ -325,23 +325,23 @@ impl region_variance : cmp::Eq {\n     pure fn ne(&self, other: &region_variance) -> bool { !(*self).eq(other) }\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n pub type AutoAdjustment = {\n     autoderefs: uint,\n     autoref: Option<AutoRef>\n };\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n pub type AutoRef = {\n     kind: AutoRefKind,\n     region: Region,\n     mutbl: ast::mutability\n };\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum AutoRefKind {\n     /// Convert from T to &T\n     AutoPtr,\n@@ -544,8 +544,8 @@ impl param_ty : to_bytes::IterBytes {\n \n \n /// Representation of regions:\n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum Region {\n     /// Bound regions are found (primarily) in function types.  They indicate\n     /// region parameters that have yet to be replaced with actual regions\n@@ -573,8 +573,8 @@ enum Region {\n     re_infer(InferRegion)\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum bound_region {\n     /// The self region for structs, impls (&T in a type defn or &self/T)\n     br_self,\n@@ -712,8 +712,8 @@ enum TyVid = uint;\n enum IntVid = uint;\n enum FloatVid = uint;\n enum FnVid = uint;\n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum RegionVid = uint;\n \n enum InferTy {\n@@ -732,8 +732,8 @@ impl InferTy : to_bytes::IterBytes {\n     }\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum InferRegion {\n     ReVar(RegionVid),\n     ReSkolemized(uint, bound_region)"}, {"sha": "684ee4fa45422d822b133184f0986ba730934313", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=8650c6f683cf43e9ced27e81945c20234d2bb61c", "patch": "@@ -111,8 +111,8 @@ pub mod collect;\n #[legacy_exports]\n pub mod coherence;\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n pub enum method_origin {\n     // fully statically resolved method\n     method_static(ast::def_id),\n@@ -129,8 +129,8 @@ pub enum method_origin {\n \n // details for a method invoked with a receiver whose type is a type parameter\n // with a bounded trait.\n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type method_param = {\n     // the trait containing the method to be invoked\n     trait_id: ast::def_id,"}, {"sha": "0e1b6852e7e0b93fc467ad3b81dcd02c4bf5f901", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=8650c6f683cf43e9ced27e81945c20234d2bb61c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #[forbid(deprecated_mode)];\n-use serialization;\n+use serialize;\n \n // Simple Extensible Binary Markup Language (ebml) reader and writer on a\n // cursor model. See the specification here:\n@@ -38,7 +38,7 @@ struct TaggedDoc {\n     doc: Doc,\n }\n \n-enum EbmlSerializerTag {\n+enum EbmlEncoderTag {\n     EsUint, EsU64, EsU32, EsU16, EsU8,\n     EsInt, EsI64, EsI32, EsI16, EsI8,\n     EsBool,\n@@ -189,16 +189,16 @@ pub mod reader {\n     pub fn doc_as_i64(d: Doc) -> i64 { doc_as_u64(d) as i64 }\n \n \n-    pub struct Deserializer {\n+    pub struct Decoder {\n         priv mut parent: Doc,\n         priv mut pos: uint,\n     }\n \n-    pub fn Deserializer(d: Doc) -> Deserializer {\n-        Deserializer { mut parent: d, mut pos: d.start }\n+    pub fn Decoder(d: Doc) -> Decoder {\n+        Decoder { mut parent: d, mut pos: d.start }\n     }\n \n-    priv impl Deserializer {\n+    priv impl Decoder {\n         fn _check_label(lbl: &str) {\n             if self.pos < self.parent.end {\n                 let TaggedDoc { tag: r_tag, doc: r_doc } =\n@@ -214,7 +214,7 @@ pub mod reader {\n             }\n         }\n \n-        fn next_doc(exp_tag: EbmlSerializerTag) -> Doc {\n+        fn next_doc(exp_tag: EbmlEncoderTag) -> Doc {\n             debug!(\". next_doc(exp_tag=%?)\", exp_tag);\n             if self.pos >= self.parent.end {\n                 fail ~\"no more documents in current node!\";\n@@ -247,22 +247,22 @@ pub mod reader {\n             move r\n         }\n \n-        fn _next_uint(exp_tag: EbmlSerializerTag) -> uint {\n+        fn _next_uint(exp_tag: EbmlEncoderTag) -> uint {\n             let r = doc_as_u32(self.next_doc(exp_tag));\n             debug!(\"_next_uint exp_tag=%? result=%?\", exp_tag, r);\n             r as uint\n         }\n     }\n \n-    impl Deserializer {\n+    impl Decoder {\n         fn read_opaque<R>(&self, op: fn(Doc) -> R) -> R {\n             do self.push_doc(self.next_doc(EsOpaque)) {\n                 op(copy self.parent)\n             }\n         }\n     }\n \n-    impl Deserializer: serialization::Deserializer {\n+    impl Decoder: serialize::Decoder {\n         fn read_nil(&self) -> () { () }\n \n         fn read_u64(&self) -> u64 { doc_as_u64(self.next_doc(EsU64)) }\n@@ -387,7 +387,7 @@ pub mod reader {\n pub mod writer {\n \n     // ebml writing\n-    pub struct Serializer {\n+    pub struct Encoder {\n         writer: io::Writer,\n         priv mut size_positions: ~[uint],\n     }\n@@ -412,13 +412,13 @@ pub mod writer {\n         fail fmt!(\"vint to write too big: %?\", n);\n     }\n \n-    pub fn Serializer(w: io::Writer) -> Serializer {\n+    pub fn Encoder(w: io::Writer) -> Encoder {\n         let size_positions: ~[uint] = ~[];\n-        Serializer { writer: w, mut size_positions: size_positions }\n+        Encoder { writer: w, mut size_positions: size_positions }\n     }\n \n     // FIXME (#2741): Provide a function to write the standard ebml header.\n-    impl Serializer {\n+    impl Encoder {\n         fn start_tag(tag_id: uint) {\n             debug!(\"Start tag %u\", tag_id);\n \n@@ -516,37 +516,37 @@ pub mod writer {\n     // FIXME (#2743): optionally perform \"relaxations\" on end_tag to more\n     // efficiently encode sizes; this is a fixed point iteration\n \n-    // Set to true to generate more debugging in EBML serialization.\n+    // Set to true to generate more debugging in EBML code.\n     // Totally lame approach.\n     const debug: bool = false;\n \n-    priv impl Serializer {\n+    priv impl Encoder {\n         // used internally to emit things like the vector length and so on\n-        fn _emit_tagged_uint(t: EbmlSerializerTag, v: uint) {\n+        fn _emit_tagged_uint(t: EbmlEncoderTag, v: uint) {\n             assert v <= 0xFFFF_FFFF_u;\n             self.wr_tagged_u32(t as uint, v as u32);\n         }\n \n         fn _emit_label(label: &str) {\n             // There are various strings that we have access to, such as\n             // the name of a record field, which do not actually appear in\n-            // the serialized EBML (normally).  This is just for\n+            // the encoded EBML (normally).  This is just for\n             // efficiency.  When debugging, though, we can emit such\n-            // labels and then they will be checked by deserializer to\n+            // labels and then they will be checked by decoder to\n             // try and check failures more quickly.\n             if debug { self.wr_tagged_str(EsLabel as uint, label) }\n         }\n     }\n \n-    impl Serializer {\n+    impl Encoder {\n         fn emit_opaque(&self, f: fn()) {\n             do self.wr_tag(EsOpaque as uint) {\n                 f()\n             }\n         }\n     }\n \n-    impl Serializer: serialization::Serializer {\n+    impl Encoder: serialize::Encoder {\n         fn emit_nil(&self) {}\n \n         fn emit_uint(&self, v: uint) {\n@@ -652,12 +652,12 @@ mod tests {\n         fn test_v(v: Option<int>) {\n             debug!(\"v == %?\", v);\n             let bytes = do io::with_bytes_writer |wr| {\n-                let ebml_w = writer::Serializer(wr);\n-                v.serialize(&ebml_w)\n+                let ebml_w = writer::Encoder(wr);\n+                v.encode(&ebml_w)\n             };\n             let ebml_doc = reader::Doc(@bytes);\n-            let deser = reader::Deserializer(ebml_doc);\n-            let v1 = serialization::deserialize(&deser);\n+            let deser = reader::Decoder(ebml_doc);\n+            let v1 = serialize::decode(&deser);\n             debug!(\"v1 == %?\", v1);\n             assert v == v1;\n         }"}, {"sha": "770d621d51fc752bea7f2006144bfe15445c8c87", "filename": "src/libstd/json.rs", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=8650c6f683cf43e9ced27e81945c20234d2bb61c", "patch": "@@ -65,15 +65,15 @@ fn spaces(n: uint) -> ~str {\n     return ss;\n }\n \n-pub struct Serializer {\n+pub struct Encoder {\n     priv wr: io::Writer,\n }\n \n-pub fn Serializer(wr: io::Writer) -> Serializer {\n-    Serializer { wr: wr }\n+pub fn Encoder(wr: io::Writer) -> Encoder {\n+    Encoder { wr: wr }\n }\n \n-pub impl Serializer: serialization::Serializer {\n+pub impl Encoder: serialize::Encoder {\n     fn emit_nil(&self) { self.wr.write_str(\"null\") }\n \n     fn emit_uint(&self, v: uint) { self.emit_float(v as float); }\n@@ -168,16 +168,16 @@ pub impl Serializer: serialization::Serializer {\n     }\n }\n \n-pub struct PrettySerializer {\n+pub struct PrettyEncoder {\n     priv wr: io::Writer,\n     priv mut indent: uint,\n }\n \n-pub fn PrettySerializer(wr: io::Writer) -> PrettySerializer {\n-    PrettySerializer { wr: wr, indent: 0 }\n+pub fn PrettyEncoder(wr: io::Writer) -> PrettyEncoder {\n+    PrettyEncoder { wr: wr, indent: 0 }\n }\n \n-pub impl PrettySerializer: serialization::Serializer {\n+pub impl PrettyEncoder: serialize::Encoder {\n     fn emit_nil(&self) { self.wr.write_str(\"null\") }\n \n     fn emit_uint(&self, v: uint) { self.emit_float(v as float); }\n@@ -283,21 +283,19 @@ pub impl PrettySerializer: serialization::Serializer {\n     }\n }\n \n-pub impl<\n-    S: serialization::Serializer\n-> Json: serialization::Serializable<S> {\n-    fn serialize(&self, s: &S) {\n+pub impl<S: serialize::Encoder> Json: serialize::Encodable<S> {\n+    fn encode(&self, s: &S) {\n         match *self {\n-            Number(v) => v.serialize(s),\n-            String(ref v) => v.serialize(s),\n-            Boolean(v) => v.serialize(s),\n-            List(ref v) => v.serialize(s),\n+            Number(v) => v.encode(s),\n+            String(ref v) => v.encode(s),\n+            Boolean(v) => v.encode(s),\n+            List(ref v) => v.encode(s),\n             Object(ref v) => {\n                 do s.emit_rec || {\n                     let mut idx = 0;\n                     for v.each |key, value| {\n                         do s.emit_field(*key, idx) {\n-                            value.serialize(s);\n+                            value.encode(s);\n                         }\n                         idx += 1;\n                     }\n@@ -308,23 +306,23 @@ pub impl<\n     }\n }\n \n-/// Serializes a json value into a io::writer\n+/// Encodes a json value into a io::writer\n pub fn to_writer(wr: io::Writer, json: &Json) {\n-    json.serialize(&Serializer(wr))\n+    json.encode(&Encoder(wr))\n }\n \n-/// Serializes a json value into a string\n+/// Encodes a json value into a string\n pub pure fn to_str(json: &Json) -> ~str unsafe {\n     // ugh, should be safe\n     io::with_str_writer(|wr| to_writer(wr, json))\n }\n \n-/// Serializes a json value into a io::writer\n+/// Encodes a json value into a io::writer\n pub fn to_pretty_writer(wr: io::Writer, json: &Json) {\n-    json.serialize(&PrettySerializer(wr))\n+    json.encode(&PrettyEncoder(wr))\n }\n \n-/// Serializes a json value into a string\n+/// Encodes a json value into a string\n pub fn to_pretty_str(json: &Json) -> ~str {\n     io::with_str_writer(|wr| to_pretty_writer(wr, json))\n }\n@@ -336,7 +334,7 @@ pub struct Parser {\n     priv mut col: uint,\n }\n \n-/// Deserializes a json value from an io::reader\n+/// Decode a json value from an io::reader\n pub fn Parser(rdr: io::Reader) -> Parser {\n     Parser {\n         rdr: rdr,\n@@ -695,28 +693,28 @@ priv impl Parser {\n     }\n }\n \n-/// Deserializes a json value from an io::reader\n+/// Decodes a json value from an io::reader\n pub fn from_reader(rdr: io::Reader) -> Result<Json, Error> {\n     Parser(rdr).parse()\n }\n \n-/// Deserializes a json value from a string\n+/// Decodes a json value from a string\n pub fn from_str(s: &str) -> Result<Json, Error> {\n     do io::with_str_reader(s) |rdr| {\n         from_reader(rdr)\n     }\n }\n \n-pub struct Deserializer {\n+pub struct Decoder {\n     priv json: Json,\n     priv mut stack: ~[&Json],\n }\n \n-pub fn Deserializer(json: Json) -> Deserializer {\n-    Deserializer { json: move json, stack: ~[] }\n+pub fn Decoder(json: Json) -> Decoder {\n+    Decoder { json: move json, stack: ~[] }\n }\n \n-priv impl Deserializer {\n+priv impl Decoder {\n     fn peek(&self) -> &self/Json {\n         if self.stack.len() == 0 { self.stack.push(&self.json); }\n         vec::last(self.stack)\n@@ -728,7 +726,7 @@ priv impl Deserializer {\n     }\n }\n \n-pub impl Deserializer: serialization::Deserializer {\n+pub impl Decoder: serialize::Decoder {\n     fn read_nil(&self) -> () {\n         debug!(\"read_nil\");\n         match *self.pop() {"}, {"sha": "ef26a8cb19035f86f35d8b772f31eecccc6e79ba", "filename": "src/libstd/prettyprint.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibstd%2Fprettyprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibstd%2Fprettyprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprettyprint.rs?ref=8650c6f683cf43e9ced27e81945c20234d2bb61c", "patch": "@@ -12,17 +12,17 @@\n \n use io::Writer;\n use io::WriterUtil;\n-use serialization;\n+use serialize;\n \n-pub struct Serializer {\n+pub struct Encoder {\n     wr: io::Writer,\n }\n \n-pub fn Serializer(wr: io::Writer) -> Serializer {\n-    Serializer { wr: wr }\n+pub fn Encoder(wr: io::Writer) -> Encoder {\n+    Encoder { wr: wr }\n }\n \n-pub impl Serializer: serialization::Serializer {\n+pub impl Encoder: serialize::Encoder {\n     fn emit_nil(&self) {\n         self.wr.write_str(~\"()\")\n     }"}, {"sha": "918781cffb5d5470a9ab2246195d66ab6301fcd1", "filename": "src/libstd/std.rc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=8650c6f683cf43e9ced27e81945c20234d2bb61c", "patch": "@@ -107,14 +107,16 @@ mod unicode;\n \n pub mod test;\n pub mod serialize;\n+#[cfg(stage0)]\n pub mod serialization;\n \n // A curious inner-module that's not exported that contains the binding\n-// 'std' so that macro-expanded references to std::code and such\n+// 'std' so that macro-expanded references to std::serialize and such\n // can be resolved within libcore.\n #[doc(hidden)] // FIXME #3538\n mod std {\n     pub use serialize;\n+    #[cfg(stage0)]\n     pub use serialization;\n }\n "}, {"sha": "e45fc8e0107a921e30a0a14aaaaef0abb68a80d7", "filename": "src/libstd/time.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=8650c6f683cf43e9ced27e81945c20234d2bb61c", "patch": "@@ -31,8 +31,8 @@ extern mod rustrt {\n }\n \n /// A record specifying a time value in seconds and nanoseconds.\n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n pub struct Timespec { sec: i64, nsec: i32 }\n \n impl Timespec {\n@@ -83,8 +83,8 @@ pub fn tzset() {\n     rustrt::rust_tzset();\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n pub struct Tm {\n     tm_sec: i32, // seconds after the minute ~[0-60]\n     tm_min: i32, // minutes after the hour ~[0-59]"}, {"sha": "1a997d4b7095da1d693b658bb947da596a155775", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=8650c6f683cf43e9ced27e81945c20234d2bb61c", "patch": "@@ -15,8 +15,7 @@ use either::{Right,Left,Either};\n \n use json;\n use sha1;\n-use serialization::{Serializer,Serializable,\n-                    Deserializer,Deserializable};\n+use serialize::{Encoder, Encodable, Decoder, Decodable, decode};\n \n /**\n *\n@@ -162,13 +161,13 @@ struct Work<T:Owned> {\n     res: Option<Either<T,PortOne<(Exec,T)>>>\n }\n \n-fn digest<T:Serializable<json::Serializer>\n-            Deserializable<json::Deserializer>>(t: &T) -> ~str {\n+fn digest<T:Encodable<json::Encoder>\n+            Decodable<json::Decoder>>(t: &T) -> ~str {\n     let sha = sha1::sha1();\n     let s = do io::with_str_writer |wr| {\n         // XXX: sha1 should be a writer itself, shouldn't\n         // go via strings.\n-        t.serialize(&json::Serializer(wr));\n+        t.encode(&json::Encoder(wr));\n     };\n     sha.input_str(s);\n     sha.result_str()\n@@ -189,8 +188,8 @@ impl Context {\n     }\n \n     fn prep<T:Owned\n-              Serializable<json::Serializer>\n-              Deserializable<json::Deserializer>>(\n+              Encodable<json::Encoder>\n+              Decodable<json::Decoder>>(\n                   @self,\n                   fn_name:&str,\n                   blk: fn((@mut Prep))->Work<T>) -> Work<T> {\n@@ -237,8 +236,8 @@ impl Prep {\n     }\n \n     fn exec<T:Owned\n-              Serializable<json::Serializer>\n-              Deserializable<json::Deserializer>>(\n+              Encodable<json::Encoder>\n+              Decodable<json::Decoder>>(\n                   @mut self, blk: ~fn(&Exec) -> T) -> Work<T> {\n \n         let cached = self.ctxt.db.prepare(self.fn_name,\n@@ -260,8 +259,7 @@ impl Prep {\n \n                     let v : T = do io::with_str_reader(res) |rdr| {\n                         let j = result::unwrap(json::from_reader(rdr));\n-                        Deserializable::deserialize(\n-                            &json::Deserializer(move j))\n+                        Decodable::decode(&json::Decoder(move j))\n                     };\n                     return Work::new(self, move Left(move v));\n                 }\n@@ -284,8 +282,8 @@ impl Prep {\n }\n \n impl<T:Owned\n-       Serializable<json::Serializer>\n-       Deserializable<json::Deserializer>>\n+       Encodable<json::Encoder>\n+       Decodable<json::Decoder>>\n     Work<T> {\n     static fn new(p: @mut Prep, e: Either<T,PortOne<(Exec,T)>>) -> Work<T> {\n         move Work { prep: p, res: Some(move e) }\n@@ -294,8 +292,8 @@ impl<T:Owned\n \n // FIXME (#3724): movable self. This should be in impl Work.\n fn unwrap<T:Owned\n-            Serializable<json::Serializer>\n-            Deserializable<json::Deserializer>>(w: Work<T>) -> T {\n+            Encodable<json::Encoder>\n+            Decodable<json::Decoder>>(w: Work<T>) -> T {\n \n     let mut ww = move w;\n     let mut s = None;\n@@ -312,7 +310,7 @@ fn unwrap<T:Owned\n             };\n \n             let s = do io::with_str_writer |wr| {\n-                v.serialize(&json::Serializer(wr));\n+                v.encode(&json::Encoder(wr));\n             };\n \n             ww.prep.ctxt.db.cache(ww.prep.fn_name,"}, {"sha": "da49340e24adf0fb5c63e9db7185b31e23cbbb4a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 171, "deletions": 174, "changes": 345, "blob_url": "https://github.com/rust-lang/rust/blob/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8650c6f683cf43e9ced27e81945c20234d2bb61c", "patch": "@@ -10,15 +10,12 @@\n \n // The Rust abstract syntax tree.\n \n-use std::serialization::{Serializable,\n-                         Deserializable,\n-                         Serializer,\n-                         Deserializer};\n+use std::serialize::{Encodable, Decodable, Encoder, Decoder};\n use codemap::{span, FileName};\n use parse::token;\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type spanned<T> = {node: T, span: span};\n \n \n@@ -33,25 +30,25 @@ macro_rules! interner_key (\n // implemented.\n struct ident { repr: uint }\n \n-impl<S: Serializer> ident: Serializable<S> {\n-    fn serialize(&self, s: &S) {\n+impl<S: Encoder> ident: Encodable<S> {\n+    fn encode(&self, s: &S) {\n         let intr = match unsafe {\n             task::local_data::local_data_get(interner_key!())\n         } {\n-            None => fail ~\"serialization: TLS interner not set up\",\n+            None => fail ~\"encode: TLS interner not set up\",\n             Some(intr) => intr\n         };\n \n         s.emit_owned_str(*(*intr).get(*self));\n     }\n }\n \n-impl<D: Deserializer> ident: Deserializable<D> {\n-    static fn deserialize(d: &D) -> ident {\n+impl<D: Decoder> ident: Decodable<D> {\n+    static fn decode(d: &D) -> ident {\n         let intr = match unsafe {\n             task::local_data::local_data_get(interner_key!())\n         } {\n-            None => fail ~\"deserialization: TLS interner not set up\",\n+            None => fail ~\"decode: TLS interner not set up\",\n             Some(intr) => intr\n         };\n \n@@ -73,8 +70,8 @@ impl ident: to_bytes::IterBytes {\n // Functions may or may not have names.\n type fn_ident = Option<ident>;\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type path = {span: span,\n              global: bool,\n              idents: ~[ident],\n@@ -85,8 +82,8 @@ type crate_num = int;\n \n type node_id = int;\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type def_id = {crate: crate_num, node: node_id};\n \n impl def_id : cmp::Eq {\n@@ -99,20 +96,20 @@ impl def_id : cmp::Eq {\n const local_crate: crate_num = 0;\n const crate_node_id: node_id = 0;\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n // The AST represents all type param bounds as types.\n // typeck::collect::compute_bounds matches these against\n // the \"special\" built-in traits (see middle::lang_items) and\n // detects Copy, Send, Owned, and Const.\n enum ty_param_bound = @Ty;\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type ty_param = {ident: ident, id: node_id, bounds: @~[ty_param_bound]};\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum def {\n     def_fn(def_id, purity),\n     def_static_method(/* method */ def_id,\n@@ -284,8 +281,8 @@ type crate_ =\n \n type meta_item = spanned<meta_item_>;\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum meta_item_ {\n     meta_word(~str),\n     meta_list(~str, ~[@meta_item]),\n@@ -294,24 +291,24 @@ enum meta_item_ {\n \n type blk = spanned<blk_>;\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type blk_ = {view_items: ~[@view_item],\n              stmts: ~[@stmt],\n              expr: Option<@expr>,\n              id: node_id,\n              rules: blk_check_mode};\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type pat = {id: node_id, node: pat_, span: span};\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type field_pat = {ident: ident, pat: @pat};\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum binding_mode {\n     bind_by_value,\n     bind_by_move,\n@@ -367,8 +364,8 @@ impl binding_mode : cmp::Eq {\n     pure fn ne(&self, other: &binding_mode) -> bool { !(*self).eq(other) }\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum pat_ {\n     pat_wild,\n     // A pat_ident may either be a new bound variable,\n@@ -392,8 +389,8 @@ enum pat_ {\n     pat_vec(~[@pat], Option<@pat>)\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum mutability { m_mutbl, m_imm, m_const, }\n \n impl mutability : to_bytes::IterBytes {\n@@ -409,8 +406,8 @@ impl mutability : cmp::Eq {\n     pure fn ne(&self, other: &mutability) -> bool { !(*self).eq(other) }\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n pub enum Proto {\n     ProtoBare,     // bare functions (deprecated)\n     ProtoUniq,     // ~fn\n@@ -431,8 +428,8 @@ impl Proto : to_bytes::IterBytes {\n     }\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum vstore {\n     // FIXME (#3469): Change uint to @expr (actually only constant exprs)\n     vstore_fixed(Option<uint>),   // [1,2,3,4]\n@@ -441,8 +438,8 @@ enum vstore {\n     vstore_slice(@region)         // &[1,2,3,4](foo)?\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum expr_vstore {\n     // FIXME (#3469): Change uint to @expr (actually only constant exprs)\n     expr_vstore_fixed(Option<uint>),   // [1,2,3,4]\n@@ -460,8 +457,8 @@ pure fn is_blockish(p: ast::Proto) -> bool {\n     }\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum binop {\n     add,\n     subtract,\n@@ -490,8 +487,8 @@ impl binop : cmp::Eq {\n     pure fn ne(&self, other: &binop) -> bool { !(*self).eq(other) }\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum unop {\n     box(mutability),\n     uniq(mutability),\n@@ -542,8 +539,8 @@ impl unop : cmp::Eq {\n \n // Generally, after typeck you can get the inferred value\n // using ty::resolved_T(...).\n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum inferable<T> {\n     expl(T),\n     infer(node_id)\n@@ -582,8 +579,8 @@ impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n }\n \n // \"resolved\" mode: the real modes.\n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum rmode { by_ref, by_val, by_move, by_copy }\n \n impl rmode : to_bytes::IterBytes {\n@@ -605,8 +602,8 @@ type mode = inferable<rmode>;\n \n type stmt = spanned<stmt_>;\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum stmt_ {\n     stmt_decl(@decl, node_id),\n \n@@ -622,31 +619,31 @@ enum stmt_ {\n \n // FIXME (pending discussion of #1697, #2178...): local should really be\n // a refinement on pat.\n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type local_ =  {is_mutbl: bool, ty: @Ty, pat: @pat,\n                 init: Option<@expr>, id: node_id};\n \n type local = spanned<local_>;\n \n type decl = spanned<decl_>;\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum decl_ { decl_local(~[@local]), decl_item(@item), }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type arm = {pats: ~[@pat], guard: Option<@expr>, body: blk};\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type field_ = {mutbl: mutability, ident: ident, expr: @expr};\n \n type field = spanned<field_>;\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum blk_check_mode { default_blk, unsafe_blk, }\n \n impl blk_check_mode : cmp::Eq {\n@@ -661,18 +658,18 @@ impl blk_check_mode : cmp::Eq {\n     pure fn ne(&self, other: &blk_check_mode) -> bool { !(*self).eq(other) }\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type expr = {id: node_id, callee_id: node_id, node: expr_, span: span};\n // Extra node ID is only used for index, assign_op, unary, binary, method call\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum log_level { error, debug, log_other }\n // 0 = error, 1 = debug, 2 = log_other\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum expr_ {\n     expr_vstore(@expr, expr_vstore),\n     expr_vec(~[@expr], mutability),\n@@ -731,8 +728,8 @@ enum expr_ {\n     expr_paren(@expr)\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type capture_item_ = {\n     id: int,\n     is_move: bool,\n@@ -760,8 +757,8 @@ type capture_clause = @~[capture_item];\n // else knows what to do with them, so you'll probably get a syntax\n // error.\n //\n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n #[doc=\"For macro invocations; parsing is delegated to the macro\"]\n enum token_tree {\n     tt_tok(span, token::Token),\n@@ -825,8 +822,8 @@ enum token_tree {\n //\n type matcher = spanned<matcher_>;\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum matcher_ {\n     // match one token\n     match_tok(token::Token),\n@@ -839,16 +836,16 @@ enum matcher_ {\n \n type mac = spanned<mac_>;\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum mac_ {\n     mac_invoc_tt(@path,~[token_tree]),   // new macro-invocation\n }\n \n type lit = spanned<lit_>;\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum lit_ {\n     lit_str(@~str),\n     lit_int(i64, int_ty),\n@@ -892,24 +889,24 @@ impl ast::lit_: cmp::Eq {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type mt = {ty: @Ty, mutbl: mutability};\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type ty_field_ = {ident: ident, mt: mt};\n \n type ty_field = spanned<ty_field_>;\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type ty_method = {ident: ident, attrs: ~[attribute], purity: purity,\n                   decl: fn_decl, tps: ~[ty_param], self_ty: self_ty,\n                   id: node_id, span: span};\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n // A trait method is either required (meaning it doesn't have an\n // implementation, just a signature) or provided (meaning it has a default\n // implementation).\n@@ -918,8 +915,8 @@ enum trait_method {\n     provided(@method),\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum int_ty { ty_i, ty_char, ty_i8, ty_i16, ty_i32, ty_i64, }\n \n impl int_ty : to_bytes::IterBytes {\n@@ -948,8 +945,8 @@ impl int_ty : cmp::Eq {\n     pure fn ne(&self, other: &int_ty) -> bool { !(*self).eq(other) }\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n \n impl uint_ty : to_bytes::IterBytes {\n@@ -976,8 +973,8 @@ impl uint_ty : cmp::Eq {\n     pure fn ne(&self, other: &uint_ty) -> bool { !(*self).eq(other) }\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum float_ty { ty_f, ty_f32, ty_f64, }\n \n impl float_ty : to_bytes::IterBytes {\n@@ -996,13 +993,13 @@ impl float_ty : cmp::Eq {\n     pure fn ne(&self, other: &float_ty) -> bool { !(*self).eq(other) }\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type Ty = {id: node_id, node: ty_, span: span};\n \n // Not represented directly in the AST, referred to by name through a ty_path.\n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum prim_ty {\n     ty_int(int_ty),\n     ty_uint(uint_ty),\n@@ -1049,21 +1046,21 @@ impl prim_ty : cmp::Eq {\n     pure fn ne(&self, other: &prim_ty) -> bool { !(*self).eq(other) }\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type region = {id: node_id, node: region_};\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum region_ {\n     re_anon,\n     re_static,\n     re_self,\n     re_named(ident)\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum Onceness {\n     Once,\n     Many\n@@ -1081,8 +1078,8 @@ impl Onceness : cmp::Eq {\n     }\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n struct TyFn {\n     proto: Proto,\n     region: Option<@region>,\n@@ -1092,8 +1089,8 @@ struct TyFn {\n     decl: fn_decl\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum ty_ {\n     ty_nil,\n     ty_bot, /* bottom type */\n@@ -1132,19 +1129,19 @@ impl Ty : to_bytes::IterBytes {\n }\n \n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type arg = {mode: mode, ty: @Ty, pat: @pat, id: node_id};\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type fn_decl =\n     {inputs: ~[arg],\n      output: @Ty,\n      cf: ret_style};\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum purity {\n     pure_fn, // declared with \"pure fn\"\n     unsafe_fn, // declared with \"unsafe fn\"\n@@ -1165,8 +1162,8 @@ impl purity : cmp::Eq {\n     pure fn ne(&self, other: &purity) -> bool { !(*self).eq(other) }\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum ret_style {\n     noreturn, // functions with return type _|_ that always\n               // raise an error or exit (i.e. never return to the caller)\n@@ -1191,8 +1188,8 @@ impl ret_style : cmp::Eq {\n     pure fn ne(&self, other: &ret_style) -> bool { !(*self).eq(other) }\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum self_ty_ {\n     sty_static,                         // no self: static method\n     sty_by_ref,                         // old by-reference self: ``\n@@ -1248,29 +1245,29 @@ impl self_ty_ : cmp::Eq {\n \n type self_ty = spanned<self_ty_>;\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type method = {ident: ident, attrs: ~[attribute],\n                tps: ~[ty_param], self_ty: self_ty,\n                purity: purity, decl: fn_decl, body: blk,\n                id: node_id, span: span, self_id: node_id,\n                vis: visibility};\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type _mod = {view_items: ~[@view_item], items: ~[@item]};\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum foreign_abi {\n     foreign_abi_rust_intrinsic,\n     foreign_abi_cdecl,\n     foreign_abi_stdcall,\n }\n \n // Foreign mods can be named or anonymous\n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum foreign_mod_sort { named, anonymous }\n \n impl foreign_mod_sort : cmp::Eq {\n@@ -1294,49 +1291,49 @@ impl foreign_abi : cmp::Eq {\n     pure fn ne(&self, other: &foreign_abi) -> bool { !(*self).eq(other) }\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type foreign_mod =\n     {sort: foreign_mod_sort,\n      abi: ident,\n      view_items: ~[@view_item],\n      items: ~[@foreign_item]};\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type variant_arg = {ty: @Ty, id: node_id};\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum variant_kind {\n     tuple_variant_kind(~[variant_arg]),\n     struct_variant_kind(@struct_def),\n     enum_variant_kind(enum_def)\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type enum_def_ = { variants: ~[variant], common: Option<@struct_def> };\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum enum_def = enum_def_;\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type variant_ = {name: ident, attrs: ~[attribute], kind: variant_kind,\n                  id: node_id, disr_expr: Option<@expr>, vis: visibility};\n \n type variant = spanned<variant_>;\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type path_list_ident_ = {name: ident, id: node_id};\n \n type path_list_ident = spanned<path_list_ident_>;\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum namespace { module_ns, type_value_ns }\n \n impl namespace : cmp::Eq {\n@@ -1348,8 +1345,8 @@ impl namespace : cmp::Eq {\n \n type view_path = spanned<view_path_>;\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum view_path_ {\n \n     // quux = foo::bar::baz\n@@ -1366,13 +1363,13 @@ enum view_path_ {\n     view_path_list(@path, ~[path_list_ident], node_id)\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type view_item = {node: view_item_, attrs: ~[attribute],\n                   vis: visibility, span: span};\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum view_item_ {\n     view_item_use(ident, ~[@meta_item], node_id),\n     view_item_import(~[@view_path]),\n@@ -1385,8 +1382,8 @@ type attribute = spanned<attribute_>;\n // Distinguishes between attributes that decorate items and attributes that\n // are contained as statements within items. These two cases need to be\n // distinguished for pretty-printing.\n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum attr_style { attr_outer, attr_inner, }\n \n impl attr_style : cmp::Eq {\n@@ -1397,8 +1394,8 @@ impl attr_style : cmp::Eq {\n }\n \n // doc-comments are promoted to attributes that have is_sugared_doc = true\n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type attribute_ = {style: attr_style, value: meta_item, is_sugared_doc: bool};\n \n /*\n@@ -1408,12 +1405,12 @@ type attribute_ = {style: attr_style, value: meta_item, is_sugared_doc: bool};\n   If this impl is an item_impl, the impl_id is redundant (it could be the\n   same as the impl's node id).\n  */\n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type trait_ref = {path: @path, ref_id: node_id};\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum visibility { public, private, inherited }\n \n impl visibility : cmp::Eq {\n@@ -1430,8 +1427,8 @@ impl visibility : cmp::Eq {\n     pure fn ne(&self, other: &visibility) -> bool { !(*self).eq(other) }\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type struct_field_ = {\n     kind: struct_field_kind,\n     id: node_id,\n@@ -1440,8 +1437,8 @@ type struct_field_ = {\n \n type struct_field = spanned<struct_field_>;\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum struct_field_kind {\n     named_field(ident, struct_mutability, visibility),\n     unnamed_field   // element of a tuple-like struct\n@@ -1474,8 +1471,8 @@ impl struct_field_kind : cmp::Eq {\n     }\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type struct_def = {\n     fields: ~[@struct_field], /* fields */\n     /* (not including ctor or dtor) */\n@@ -1490,14 +1487,14 @@ type struct_def = {\n   FIXME (#3300): Should allow items to be anonymous. Right now\n   we just use dummy names for anon items.\n  */\n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type item = {ident: ident, attrs: ~[attribute],\n              id: node_id, node: item_,\n              vis: visibility, span: span};\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum item_ {\n     item_const(@Ty, @expr),\n     item_fn(fn_decl, purity, ~[ty_param], blk),\n@@ -1514,8 +1511,8 @@ enum item_ {\n     item_mac(mac),\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum struct_mutability { struct_mutable, struct_immutable }\n \n impl struct_mutability : to_bytes::IterBytes {\n@@ -1540,15 +1537,15 @@ impl struct_mutability : cmp::Eq {\n \n type struct_dtor = spanned<struct_dtor_>;\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type struct_dtor_ = {id: node_id,\n                     attrs: ~[attribute],\n                     self_id: node_id,\n                     body: blk};\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type foreign_item =\n     {ident: ident,\n      attrs: ~[attribute],\n@@ -1557,8 +1554,8 @@ type foreign_item =\n      span: span,\n      vis: visibility};\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum foreign_item_ {\n     foreign_item_fn(fn_decl, purity, ~[ty_param]),\n     foreign_item_const(@Ty)\n@@ -1567,8 +1564,8 @@ enum foreign_item_ {\n // The data we save and restore about an inlined item or method.  This is not\n // part of the AST that we parse from a file, but it becomes part of the tree\n // that we trans.\n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum inlined_item {\n     ii_item(@item),\n     ii_method(def_id /* impl id */, @method),"}, {"sha": "521114bf2973aba8303ea09f81110fd445d09d57", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=8650c6f683cf43e9ced27e81945c20234d2bb61c", "patch": "@@ -417,8 +417,8 @@ fn dtor_dec() -> fn_decl {\n // ______________________________________________________________________\n // Enumerating the IDs which appear in an AST\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type id_range = {min: node_id, max: node_id};\n \n fn empty(range: id_range) -> bool {"}, {"sha": "974455972f15e1d4957255c7e6743f4437908fbc", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=8650c6f683cf43e9ced27e81945c20234d2bb61c", "patch": "@@ -22,10 +22,7 @@ source code snippets, etc.\n */\n \n use dvec::DVec;\n-use std::serialization::{Serializable,\n-                         Deserializable,\n-                         Serializer,\n-                         Deserializer};\n+use std::serialize::{Encodable, Decodable, Encoder, Decoder};\n \n trait Pos {\n     static pure fn from_uint(n: uint) -> self;\n@@ -131,13 +128,13 @@ impl span : cmp::Eq {\n     pure fn ne(&self, other: &span) -> bool { !(*self).eq(other) }\n }\n \n-impl<S: Serializer> span: Serializable<S> {\n-    /* Note #1972 -- spans are serialized but not deserialized */\n-    fn serialize(&self, _s: &S) { }\n+impl<S: Encoder> span: Encodable<S> {\n+    /* Note #1972 -- spans are encoded but not decoded */\n+    fn encode(&self, _s: &S) { }\n }\n \n-impl<D: Deserializer> span: Deserializable<D> {\n-    static fn deserialize(_d: &D) -> span {\n+impl<D: Decoder> span: Decodable<D> {\n+    static fn decode(_d: &D) -> span {\n         ast_util::dummy_sp()\n     }\n }"}, {"sha": "a65f5f33512ea83ab83f14ec70f82d7c08b96ae9", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=8650c6f683cf43e9ced27e81945c20234d2bb61c", "patch": "@@ -77,7 +77,7 @@ fn expand_expr(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n }\n \n // This is a secondary mechanism for invoking syntax extensions on items:\n-// \"decorator\" attributes, such as #[auto_serialize]. These are invoked by an\n+// \"decorator\" attributes, such as #[auto_encode]. These are invoked by an\n // attribute prefixing an item, and are interpreted by feeding the item\n // through the named attribute _as a syntax extension_ and splicing in the\n // resulting item vec into place in favour of the decorator. Note that"}, {"sha": "04e6e187dbb2248cdb0ab54082c8b1638c63b391", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=8650c6f683cf43e9ced27e81945c20234d2bb61c", "patch": "@@ -12,8 +12,8 @@ use util::interner;\n use util::interner::Interner;\n use std::map::HashMap;\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum binop {\n     PLUS,\n     MINUS,\n@@ -27,8 +27,8 @@ enum binop {\n     SHR,\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum Token {\n     /* Expression-operator symbols. */\n     EQ,\n@@ -85,8 +85,8 @@ enum Token {\n     EOF,\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n /// For interpolation during macro expansion.\n enum nonterminal {\n     nt_item(@ast::item),\n@@ -351,7 +351,7 @@ impl ident_interner {\n }\n \n /* Key for thread-local data for sneaking interner information to the\n- * serializer/deserializer. It sounds like a hack because it is one.\n+ * encoder/decoder. It sounds like a hack because it is one.\n  * Bonus ultra-hack: functions as keys don't work across crates,\n  * so we have to use a unique number. See taskgroup_key! in task.rs\n  * for another case of this. */"}, {"sha": "faa46530e9d1aa3b38248e6224eb0516b97a5d36", "filename": "src/test/run-pass/auto-encode.rs", "status": "renamed", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8650c6f683cf43e9ced27e81945c20234d2bb61c/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=8650c6f683cf43e9ced27e81945c20234d2bb61c", "patch": "@@ -22,37 +22,37 @@ use std::ebml;\n use EBReader = std::ebml::reader;\n use EBWriter = std::ebml::writer;\n use io::Writer;\n-use std::serialization::{Serializable, Deserializable, deserialize};\n+use std::serialize::{Encodable, Decodable, decode};\n use std::prettyprint;\n use std::time;\n \n-fn test_prettyprint<A: Serializable<prettyprint::Serializer>>(\n+fn test_prettyprint<A: Encodable<prettyprint::Encoder>>(\n     a: &A,\n     expected: &~str\n ) {\n     let s = do io::with_str_writer |w| {\n-        a.serialize(&prettyprint::Serializer(w))\n+        a.encode(&prettyprint::Encoder(w))\n     };\n     debug!(\"s == %?\", s);\n     assert s == *expected;\n }\n \n fn test_ebml<A:\n     Eq\n-    Serializable<EBWriter::Serializer>\n-    Deserializable<EBReader::Deserializer>\n+    Encodable<EBWriter::Encoder>\n+    Decodable<EBReader::Decoder>\n >(a1: &A) {\n     let bytes = do io::with_bytes_writer |wr| {\n-        let ebml_w = &EBWriter::Serializer(wr);\n-        a1.serialize(ebml_w)\n+        let ebml_w = &EBWriter::Encoder(wr);\n+        a1.encode(ebml_w)\n     };\n     let d = EBReader::Doc(@move bytes);\n-    let a2: A = deserialize(&EBReader::Deserializer(d));\n+    let a2: A = decode(&EBReader::Decoder(d));\n     assert *a1 == a2;\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum Expr {\n     Val(uint),\n     Plus(@Expr, @Expr),\n@@ -126,8 +126,8 @@ impl CLike : cmp::Eq {\n     pure fn ne(&self, other: &CLike) -> bool { !(*self).eq(other) }\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type Spanned<T> = {lo: uint, hi: uint, node: T};\n \n impl<T:cmp::Eq> Spanned<T> : cmp::Eq {\n@@ -139,27 +139,27 @@ impl<T:cmp::Eq> Spanned<T> : cmp::Eq {\n     pure fn ne(&self, other: &Spanned<T>) -> bool { !(*self).eq(other) }\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n type SomeRec = {v: ~[uint]};\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum AnEnum = SomeRec;\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n struct Point {x: uint, y: uint}\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum Quark<T> {\n     Top(T),\n     Bottom(T)\n }\n \n-#[auto_serialize]\n-#[auto_deserialize]\n+#[auto_encode]\n+#[auto_decode]\n enum CLike { A, B, C }\n \n fn main() {", "previous_filename": "src/test/run-pass/auto_serialize.rs"}]}