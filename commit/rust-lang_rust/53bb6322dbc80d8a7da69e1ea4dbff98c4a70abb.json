{"sha": "53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "node_id": "C_kwDOAAsO6NoAKDUzYmI2MzIyZGJjODBkOGE3ZGE2OWUxZWE0ZGJmZjk4YzRhNzBhYmI", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2023-01-31T22:38:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-31T22:38:52Z"}, "message": "Rollup merge of #107467 - WaffleLapkin:uneq, r=oli-obk\n\nImprove enum checks\n\nSome light refactoring.", "tree": {"sha": "cdfff407398d47f6a151da0c7dcf965c7c6f031c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdfff407398d47f6a151da0c7dcf965c7c6f031c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj2Zh8CRBK7hj4Ov3rIwAAA8MIACWcfo6w0lkru+ka1AYzlMXr\nV1GUU6kFWT1OFtbKzQarhImXX87r783Gqt02R7V4ku9roJAO+pry51lg9Wa9DoWr\nilCCoH656Al3+NeBNptE2l0K9fvQ2a1X0kN7xT96i4rhtRZzDzf4QDqeBANUOR2g\ndpVvphAruTuaDG2kvUuBG20SeUXEuH18iVD6yOAcskwX5fa6mNrQJPgWk1NNYxjy\nEPmrLL+YHi/yDw5wSn+zpPQyFByfI/1MG3FAAm7dLgaJ1SgWSjsuOF9xvzmvKs4q\nlZQpl+tnz3iT5QOy+bFm3loFKPFjJCMHjif0Ax2PMxatGaNX/GhVy5gbywiDOtU=\n=rygi\n-----END PGP SIGNATURE-----\n", "payload": "tree cdfff407398d47f6a151da0c7dcf965c7c6f031c\nparent c6a104f3e4266cb9f369b7edbc58520ca43f911e\nparent 340414ed7bbcdd28a6a5baa0e3229c07029387b4\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1675204732 +0100\ncommitter GitHub <noreply@github.com> 1675204732 +0100\n\nRollup merge of #107467 - WaffleLapkin:uneq, r=oli-obk\n\nImprove enum checks\n\nSome light refactoring.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "html_url": "https://github.com/rust-lang/rust/commit/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6a104f3e4266cb9f369b7edbc58520ca43f911e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6a104f3e4266cb9f369b7edbc58520ca43f911e", "html_url": "https://github.com/rust-lang/rust/commit/c6a104f3e4266cb9f369b7edbc58520ca43f911e"}, {"sha": "340414ed7bbcdd28a6a5baa0e3229c07029387b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/340414ed7bbcdd28a6a5baa0e3229c07029387b4", "html_url": "https://github.com/rust-lang/rust/commit/340414ed7bbcdd28a6a5baa0e3229c07029387b4"}], "stats": {"total": 534, "additions": 276, "deletions": 258}, "files": [{"sha": "eece99a3eef0358c29f2792a6762955e1e9a03c6", "filename": "compiler/rustc_ast/src/util/comments.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -58,23 +58,24 @@ pub fn beautify_doc_string(data: Symbol, kind: CommentKind) -> Symbol {\n         // In case we have doc comments like `/**` or `/*!`, we want to remove stars if they are\n         // present. However, we first need to strip the empty lines so they don't get in the middle\n         // when we try to compute the \"horizontal trim\".\n-        let lines = if kind == CommentKind::Block {\n-            // Whatever happens, we skip the first line.\n-            let mut i = lines\n-                .get(0)\n-                .map(|l| if l.trim_start().starts_with('*') { 0 } else { 1 })\n-                .unwrap_or(0);\n-            let mut j = lines.len();\n-\n-            while i < j && lines[i].trim().is_empty() {\n-                i += 1;\n-            }\n-            while j > i && lines[j - 1].trim().is_empty() {\n-                j -= 1;\n+        let lines = match kind {\n+            CommentKind::Block => {\n+                // Whatever happens, we skip the first line.\n+                let mut i = lines\n+                    .get(0)\n+                    .map(|l| if l.trim_start().starts_with('*') { 0 } else { 1 })\n+                    .unwrap_or(0);\n+                let mut j = lines.len();\n+\n+                while i < j && lines[i].trim().is_empty() {\n+                    i += 1;\n+                }\n+                while j > i && lines[j - 1].trim().is_empty() {\n+                    j -= 1;\n+                }\n+                &lines[i..j]\n             }\n-            &lines[i..j]\n-        } else {\n-            lines\n+            CommentKind::Line => lines,\n         };\n \n         for line in lines {"}, {"sha": "40f518b33cfb66dbcf4b485a2d32ab3a71b2aa1a", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -344,7 +344,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     } else {\n                         err.span_help(source_info.span, \"try removing `&mut` here\");\n                     }\n-                } else if decl.mutability == Mutability::Not {\n+                } else if decl.mutability.is_not() {\n                     if matches!(\n                         decl.local_info,\n                         Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::ImplicitSelf("}, {"sha": "2605a1491fb35427609d13dd00475820eb2fdfc1", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -2028,7 +2028,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             }\n                         };\n \n-                        if ty_to_mut == Mutability::Mut && ty_mut == Mutability::Not {\n+                        if ty_to_mut.is_mut() && ty_mut.is_not() {\n                             span_mirbug!(\n                                 self,\n                                 rvalue,"}, {"sha": "d865d5bc974e069f27714768bb9812ad999134cf", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -622,10 +622,9 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         let alloc = alloc.inner();\n         if is_write {\n             // Write access. These are never allowed, but we give a targeted error message.\n-            if alloc.mutability == Mutability::Not {\n-                Err(err_ub!(WriteToReadOnly(alloc_id)).into())\n-            } else {\n-                Err(ConstEvalErrKind::ModifiedGlobal.into())\n+            match alloc.mutability {\n+                Mutability::Not => Err(err_ub!(WriteToReadOnly(alloc_id)).into()),\n+                Mutability::Mut => Err(ConstEvalErrKind::ModifiedGlobal.into()),\n             }\n         } else {\n             // Read access. These are usually allowed, with some exceptions."}, {"sha": "a87ce0053e8a038932d7f71b711ce741094de771", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -304,7 +304,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .into());\n         };\n \n-        if alloc.mutability == Mutability::Not {\n+        if alloc.mutability.is_not() {\n             throw_ub_format!(\"deallocating immutable allocation {alloc_id:?}\");\n         }\n         if alloc_kind != kind {\n@@ -631,7 +631,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n \n         let (_kind, alloc) = self.memory.alloc_map.get_mut(id).unwrap();\n-        if alloc.mutability == Mutability::Not {\n+        if alloc.mutability.is_not() {\n             throw_ub!(WriteToReadOnly(id))\n         }\n         Ok((alloc, &mut self.machine))"}, {"sha": "72f456138ef56c63e38652be3bf18a4d105b53f5", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -754,7 +754,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 // FIXME(JakobDegen) The validator should check that `self.mir_phase <\n                 // DropsLowered`. However, this causes ICEs with generation of drop shims, which\n                 // seem to fail to set their `MirPhase` correctly.\n-                if *kind == RetagKind::Raw || *kind == RetagKind::TwoPhase {\n+                if matches!(kind, RetagKind::Raw | RetagKind::TwoPhase) {\n                     self.fail(location, format!(\"explicit `{:?}` is forbidden\", kind));\n                 }\n             }"}, {"sha": "faeaa548619708f5c2c0621f27ac25073b68b715", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -2113,30 +2113,38 @@ impl EmitterWriter {\n                         }\n                     }\n                     for sugg in suggestions {\n-                        if sugg.style == SuggestionStyle::CompletelyHidden {\n-                            // do not display this suggestion, it is meant only for tools\n-                        } else if sugg.style == SuggestionStyle::HideCodeAlways {\n-                            if let Err(e) = self.emit_message_default(\n-                                &MultiSpan::new(),\n-                                &[(sugg.msg.to_owned(), Style::HeaderMsg)],\n-                                args,\n-                                &None,\n-                                &Level::Help,\n-                                max_line_num_len,\n-                                true,\n-                                None,\n-                            ) {\n-                                panic!(\"failed to emit error: {}\", e);\n+                        match sugg.style {\n+                            SuggestionStyle::CompletelyHidden => {\n+                                // do not display this suggestion, it is meant only for tools\n                             }\n-                        } else if let Err(e) = self.emit_suggestion_default(\n-                            span,\n-                            sugg,\n-                            args,\n-                            &Level::Help,\n-                            max_line_num_len,\n-                        ) {\n-                            panic!(\"failed to emit error: {}\", e);\n-                        };\n+                            SuggestionStyle::HideCodeAlways => {\n+                                if let Err(e) = self.emit_message_default(\n+                                    &MultiSpan::new(),\n+                                    &[(sugg.msg.to_owned(), Style::HeaderMsg)],\n+                                    args,\n+                                    &None,\n+                                    &Level::Help,\n+                                    max_line_num_len,\n+                                    true,\n+                                    None,\n+                                ) {\n+                                    panic!(\"failed to emit error: {}\", e);\n+                                }\n+                            }\n+                            SuggestionStyle::HideCodeInline\n+                            | SuggestionStyle::ShowCode\n+                            | SuggestionStyle::ShowAlways => {\n+                                if let Err(e) = self.emit_suggestion_default(\n+                                    span,\n+                                    sugg,\n+                                    args,\n+                                    &Level::Help,\n+                                    max_line_num_len,\n+                                ) {\n+                                    panic!(\"failed to emit error: {}\", e);\n+                                }\n+                            }\n+                        }\n                     }\n                 }\n             }"}, {"sha": "9aa14e1f214851668893591b480f058ec987153f", "filename": "compiler/rustc_errors/src/styled_buffer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_errors%2Fsrc%2Fstyled_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_errors%2Fsrc%2Fstyled_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fstyled_buffer.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -142,7 +142,7 @@ impl StyledBuffer {\n     pub fn set_style(&mut self, line: usize, col: usize, style: Style, overwrite: bool) {\n         if let Some(ref mut line) = self.lines.get_mut(line) {\n             if let Some(StyledChar { style: s, .. }) = line.get_mut(col) {\n-                if overwrite || *s == Style::NoStyle || *s == Style::Quotation {\n+                if overwrite || matches!(s, Style::NoStyle | Style::Quotation) {\n                     *s = style;\n                 }\n             }"}, {"sha": "283e68a68b5df5b135e303639cd598672dc29fe8", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -503,7 +503,7 @@ impl TtParser {\n                         mp.push_match(metavar_idx, seq_depth, MatchedSeq(vec![]));\n                     }\n \n-                    if op == KleeneOp::ZeroOrMore || op == KleeneOp::ZeroOrOne {\n+                    if matches!(op, KleeneOp::ZeroOrMore | KleeneOp::ZeroOrOne) {\n                         // Try zero matches of this sequence, by skipping over it.\n                         self.cur_mps.push(MatcherPos {\n                             idx: idx_first_after,"}, {"sha": "5e8f727df69dade8cc2016d81e5cfc1cac2c75f4", "filename": "compiler/rustc_hir_analysis/src/astconv/generics.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -385,10 +385,9 @@ pub fn check_generic_arg_count_for_call(\n ) -> GenericArgCountResult {\n     let empty_args = hir::GenericArgs::none();\n     let gen_args = seg.args.unwrap_or(&empty_args);\n-    let gen_pos = if is_method_call == IsMethodCall::Yes {\n-        GenericArgPosition::MethodCall\n-    } else {\n-        GenericArgPosition::Value\n+    let gen_pos = match is_method_call {\n+        IsMethodCall::Yes => GenericArgPosition::MethodCall,\n+        IsMethodCall::No => GenericArgPosition::Value,\n     };\n     let has_self = generics.parent.is_none() && generics.has_self;\n "}, {"sha": "47eace961be55393eee2b53b0c6e5539aebb97c4", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 55, "deletions": 48, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -606,59 +606,66 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n             };\n             check_abi(tcx, it.hir_id(), it.span, abi);\n \n-            if abi == Abi::RustIntrinsic {\n-                for item in items {\n-                    let item = tcx.hir().foreign_item(item.id);\n-                    intrinsic::check_intrinsic_type(tcx, item);\n-                }\n-            } else if abi == Abi::PlatformIntrinsic {\n-                for item in items {\n-                    let item = tcx.hir().foreign_item(item.id);\n-                    intrinsic::check_platform_intrinsic_type(tcx, item);\n+            match abi {\n+                Abi::RustIntrinsic => {\n+                    for item in items {\n+                        let item = tcx.hir().foreign_item(item.id);\n+                        intrinsic::check_intrinsic_type(tcx, item);\n+                    }\n                 }\n-            } else {\n-                for item in items {\n-                    let def_id = item.id.owner_id.def_id;\n-                    let generics = tcx.generics_of(def_id);\n-                    let own_counts = generics.own_counts();\n-                    if generics.params.len() - own_counts.lifetimes != 0 {\n-                        let (kinds, kinds_pl, egs) = match (own_counts.types, own_counts.consts) {\n-                            (_, 0) => (\"type\", \"types\", Some(\"u32\")),\n-                            // We don't specify an example value, because we can't generate\n-                            // a valid value for any type.\n-                            (0, _) => (\"const\", \"consts\", None),\n-                            _ => (\"type or const\", \"types or consts\", None),\n-                        };\n-                        struct_span_err!(\n-                            tcx.sess,\n-                            item.span,\n-                            E0044,\n-                            \"foreign items may not have {kinds} parameters\",\n-                        )\n-                        .span_label(item.span, &format!(\"can't have {kinds} parameters\"))\n-                        .help(\n-                            // FIXME: once we start storing spans for type arguments, turn this\n-                            // into a suggestion.\n-                            &format!(\n-                                \"replace the {} parameters with concrete {}{}\",\n-                                kinds,\n-                                kinds_pl,\n-                                egs.map(|egs| format!(\" like `{}`\", egs)).unwrap_or_default(),\n-                            ),\n-                        )\n-                        .emit();\n+\n+                Abi::PlatformIntrinsic => {\n+                    for item in items {\n+                        let item = tcx.hir().foreign_item(item.id);\n+                        intrinsic::check_platform_intrinsic_type(tcx, item);\n                     }\n+                }\n \n-                    let item = tcx.hir().foreign_item(item.id);\n-                    match &item.kind {\n-                        hir::ForeignItemKind::Fn(fn_decl, _, _) => {\n-                            require_c_abi_if_c_variadic(tcx, fn_decl, abi, item.span);\n+                _ => {\n+                    for item in items {\n+                        let def_id = item.id.owner_id.def_id;\n+                        let generics = tcx.generics_of(def_id);\n+                        let own_counts = generics.own_counts();\n+                        if generics.params.len() - own_counts.lifetimes != 0 {\n+                            let (kinds, kinds_pl, egs) = match (own_counts.types, own_counts.consts)\n+                            {\n+                                (_, 0) => (\"type\", \"types\", Some(\"u32\")),\n+                                // We don't specify an example value, because we can't generate\n+                                // a valid value for any type.\n+                                (0, _) => (\"const\", \"consts\", None),\n+                                _ => (\"type or const\", \"types or consts\", None),\n+                            };\n+                            struct_span_err!(\n+                                tcx.sess,\n+                                item.span,\n+                                E0044,\n+                                \"foreign items may not have {kinds} parameters\",\n+                            )\n+                            .span_label(item.span, &format!(\"can't have {kinds} parameters\"))\n+                            .help(\n+                                // FIXME: once we start storing spans for type arguments, turn this\n+                                // into a suggestion.\n+                                &format!(\n+                                    \"replace the {} parameters with concrete {}{}\",\n+                                    kinds,\n+                                    kinds_pl,\n+                                    egs.map(|egs| format!(\" like `{}`\", egs)).unwrap_or_default(),\n+                                ),\n+                            )\n+                            .emit();\n                         }\n-                        hir::ForeignItemKind::Static(..) => {\n-                            check_static_inhabited(tcx, def_id);\n-                            check_static_linkage(tcx, def_id);\n+\n+                        let item = tcx.hir().foreign_item(item.id);\n+                        match &item.kind {\n+                            hir::ForeignItemKind::Fn(fn_decl, _, _) => {\n+                                require_c_abi_if_c_variadic(tcx, fn_decl, abi, item.span);\n+                            }\n+                            hir::ForeignItemKind::Static(..) => {\n+                                check_static_inhabited(tcx, def_id);\n+                                check_static_linkage(tcx, def_id);\n+                            }\n+                            _ => {}\n                         }\n-                        _ => {}\n                     }\n                 }\n             }"}, {"sha": "7dcf9d8299f142d85315a9be60dc996bc6f32e05", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -9,9 +9,7 @@ use rustc_ast_pretty::pp::{self, Breaks};\n use rustc_ast_pretty::pprust::{Comments, PrintState};\n use rustc_hir as hir;\n use rustc_hir::LifetimeParamKind;\n-use rustc_hir::{\n-    BindingAnnotation, ByRef, GenericArg, GenericParam, GenericParamKind, Mutability, Node, Term,\n-};\n+use rustc_hir::{BindingAnnotation, ByRef, GenericArg, GenericParam, GenericParamKind, Node, Term};\n use rustc_hir::{GenericBound, PatKind, RangeEnd, TraitBoundModifier};\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, Ident, IdentPrinter, Symbol};\n@@ -1746,7 +1744,7 @@ impl<'a> State<'a> {\n                 if by_ref == ByRef::Yes {\n                     self.word_nbsp(\"ref\");\n                 }\n-                if mutbl == Mutability::Mut {\n+                if mutbl.is_mut() {\n                     self.word_nbsp(\"mut\");\n                 }\n                 self.print_ident(ident);"}, {"sha": "0b30bf957a3d3dba303edeb2da613d44411c84e6", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -1354,13 +1354,12 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             return Some(Err(MethodError::Ambiguity(sources)));\n         }\n \n-        applicable_candidates.pop().map(|(probe, status)| {\n-            if status == ProbeResult::Match {\n+        applicable_candidates.pop().map(|(probe, status)| match status {\n+            ProbeResult::Match => {\n                 Ok(probe\n                     .to_unadjusted_pick(self_ty, unstable_candidates.cloned().unwrap_or_default()))\n-            } else {\n-                Err(MethodError::BadReturnType)\n             }\n+            ProbeResult::NoMatch | ProbeResult::BadReturnType => Err(MethodError::BadReturnType),\n         })\n     }\n }"}, {"sha": "5d85cfe330acdd6075954690acc2a30c6fe7de21", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -580,27 +580,28 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &hir::ImplItem<'_>) {\n-        // If the method is an impl for a trait, don't doc.\n         let context = method_context(cx, impl_item.owner_id.def_id);\n-        if context == MethodLateContext::TraitImpl {\n-            return;\n-        }\n \n-        // If the method is an impl for an item with docs_hidden, don't doc.\n-        if context == MethodLateContext::PlainImpl {\n-            let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id());\n-            let impl_ty = cx.tcx.type_of(parent);\n-            let outerdef = match impl_ty.kind() {\n-                ty::Adt(def, _) => Some(def.did()),\n-                ty::Foreign(def_id) => Some(*def_id),\n-                _ => None,\n-            };\n-            let is_hidden = match outerdef {\n-                Some(id) => cx.tcx.is_doc_hidden(id),\n-                None => false,\n-            };\n-            if is_hidden {\n-                return;\n+        match context {\n+            // If the method is an impl for a trait, don't doc.\n+            MethodLateContext::TraitImpl => return,\n+            MethodLateContext::TraitAutoImpl => {}\n+            // If the method is an impl for an item with docs_hidden, don't doc.\n+            MethodLateContext::PlainImpl => {\n+                let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id());\n+                let impl_ty = cx.tcx.type_of(parent);\n+                let outerdef = match impl_ty.kind() {\n+                    ty::Adt(def, _) => Some(def.did()),\n+                    ty::Foreign(def_id) => Some(*def_id),\n+                    _ => None,\n+                };\n+                let is_hidden = match outerdef {\n+                    Some(id) => cx.tcx.is_doc_hidden(id),\n+                    None => false,\n+                };\n+                if is_hidden {\n+                    return;\n+                }\n             }\n         }\n "}, {"sha": "39ef4276faf10360b96efa1eda9a5f504cee1b6b", "filename": "compiler/rustc_metadata/src/dependency_format.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -113,37 +113,37 @@ fn calculate_type(tcx: TyCtxt<'_>, ty: CrateType) -> DependencyList {\n         CrateType::Staticlib => Linkage::Static,\n     };\n \n-    if preferred_linkage == Linkage::NotLinked {\n+    match preferred_linkage {\n         // If the crate is not linked, there are no link-time dependencies.\n-        return Vec::new();\n-    }\n-\n-    if preferred_linkage == Linkage::Static {\n-        // Attempt static linkage first. For dylibs and executables, we may be\n-        // able to retry below with dynamic linkage.\n-        if let Some(v) = attempt_static(tcx) {\n-            return v;\n-        }\n+        Linkage::NotLinked => return Vec::new(),\n+        Linkage::Static => {\n+            // Attempt static linkage first. For dylibs and executables, we may be\n+            // able to retry below with dynamic linkage.\n+            if let Some(v) = attempt_static(tcx) {\n+                return v;\n+            }\n \n-        // Staticlibs and static executables must have all static dependencies.\n-        // If any are not found, generate some nice pretty errors.\n-        if ty == CrateType::Staticlib\n-            || (ty == CrateType::Executable\n-                && sess.crt_static(Some(ty))\n-                && !sess.target.crt_static_allows_dylibs)\n-        {\n-            for &cnum in tcx.crates(()).iter() {\n-                if tcx.dep_kind(cnum).macros_only() {\n-                    continue;\n+            // Staticlibs and static executables must have all static dependencies.\n+            // If any are not found, generate some nice pretty errors.\n+            if ty == CrateType::Staticlib\n+                || (ty == CrateType::Executable\n+                    && sess.crt_static(Some(ty))\n+                    && !sess.target.crt_static_allows_dylibs)\n+            {\n+                for &cnum in tcx.crates(()).iter() {\n+                    if tcx.dep_kind(cnum).macros_only() {\n+                        continue;\n+                    }\n+                    let src = tcx.used_crate_source(cnum);\n+                    if src.rlib.is_some() {\n+                        continue;\n+                    }\n+                    sess.emit_err(RlibRequired { crate_name: tcx.crate_name(cnum) });\n                 }\n-                let src = tcx.used_crate_source(cnum);\n-                if src.rlib.is_some() {\n-                    continue;\n-                }\n-                sess.emit_err(RlibRequired { crate_name: tcx.crate_name(cnum) });\n+                return Vec::new();\n             }\n-            return Vec::new();\n         }\n+        Linkage::Dynamic | Linkage::IncludedFromDylib => {}\n     }\n \n     let mut formats = FxHashMap::default();\n@@ -283,12 +283,9 @@ fn attempt_static(tcx: TyCtxt<'_>) -> Option<DependencyList> {\n     let mut ret = tcx\n         .crates(())\n         .iter()\n-        .map(|&cnum| {\n-            if tcx.dep_kind(cnum) == CrateDepKind::Explicit {\n-                Linkage::Static\n-            } else {\n-                Linkage::NotLinked\n-            }\n+        .map(|&cnum| match tcx.dep_kind(cnum) {\n+            CrateDepKind::Explicit => Linkage::Static,\n+            CrateDepKind::MacrosOnly | CrateDepKind::Implicit => Linkage::NotLinked,\n         })\n         .collect::<Vec<_>>();\n "}, {"sha": "a5910100786ec71904c01b8348e026f7f556b8e9", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -107,7 +107,7 @@ impl<'tcx> Collector<'tcx> {\n             return;\n         };\n \n-        if abi == Abi::Rust || abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n+        if matches!(abi, Abi::Rust | Abi::RustIntrinsic | Abi::PlatformIntrinsic) {\n             return;\n         }\n "}, {"sha": "db24dae11304f6ec0d84ccba748f05e6e730ddc0", "filename": "compiler/rustc_middle/src/mir/coverage.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -135,7 +135,10 @@ impl Debug for CoverageKind {\n                 \"Expression({:?}) = {} {} {}\",\n                 id.index(),\n                 lhs.index(),\n-                if *op == Op::Add { \"+\" } else { \"-\" },\n+                match op {\n+                    Op::Add => \"+\",\n+                    Op::Subtract => \"-\",\n+                },\n                 rhs.index(),\n             ),\n             Unreachable => write!(fmt, \"Unreachable\"),"}, {"sha": "cf6d46e1e2c8acfd07b8263ab43329c6196a1833", "filename": "compiler/rustc_middle/src/mir/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraphviz.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -110,7 +110,7 @@ fn write_graph_label<'tcx, W: std::fmt::Write>(\n         let decl = &body.local_decls[local];\n \n         write!(w, \"let \")?;\n-        if decl.mutability == Mutability::Mut {\n+        if decl.mutability.is_mut() {\n             write!(w, \"mut \")?;\n         }\n "}, {"sha": "05a9ec5e6d04a5bca66b64c4795984223ebcd2d7", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -416,11 +416,7 @@ impl<'tcx> Body<'tcx> {\n         (self.arg_count + 1..self.local_decls.len()).filter_map(move |index| {\n             let local = Local::new(index);\n             let decl = &self.local_decls[local];\n-            if decl.is_user_variable() && decl.mutability == Mutability::Mut {\n-                Some(local)\n-            } else {\n-                None\n-            }\n+            (decl.is_user_variable() && decl.mutability.is_mut()).then(|| local)\n         })\n     }\n "}, {"sha": "16daf63b82d9f2f68e88acd85c54ce6f2f3d8422", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -580,7 +580,7 @@ fn write_scope_tree(\n             continue;\n         }\n \n-        let mut_str = if local_decl.mutability == Mutability::Mut { \"mut \" } else { \"\" };\n+        let mut_str = local_decl.mutability.prefix_str();\n \n         let mut indented_decl =\n             format!(\"{0:1$}let {2}{3:?}: {4:?}\", INDENT, indent, mut_str, local, local_decl.ty);"}, {"sha": "3d3cf75559e303089ccbaa320f9dff9a7e3fe964", "filename": "compiler/rustc_mir_build/src/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -44,7 +44,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let expr_ty = expr.ty;\n         let temp = {\n             let mut local_decl = LocalDecl::new(expr_ty, expr_span);\n-            if mutability == Mutability::Not {\n+            if mutability.is_not() {\n                 local_decl = local_decl.immutable();\n             }\n "}, {"sha": "feb054392bc2d4e8e044961ca30c0e7ea78b2657", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -5,7 +5,6 @@ use std::cell::Cell;\n \n use either::Right;\n \n-use rustc_ast::Mutability;\n use rustc_const_eval::const_eval::CheckAlignment;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::DefKind;\n@@ -289,7 +288,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         }\n         // If the static allocation is mutable, then we can't const prop it as its content\n         // might be different at runtime.\n-        if alloc.inner().mutability == Mutability::Mut {\n+        if alloc.inner().mutability.is_mut() {\n             throw_machine_stop_str!(\"can't access mutable globals in ConstProp\");\n         }\n \n@@ -528,7 +527,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let r = self.use_ecx(|this| this.ecx.read_immediate(&this.ecx.eval_operand(right, None)?));\n         let l = self.use_ecx(|this| this.ecx.read_immediate(&this.ecx.eval_operand(left, None)?));\n         // Check for exceeding shifts *even if* we cannot evaluate the LHS.\n-        if op == BinOp::Shr || op == BinOp::Shl {\n+        if matches!(op, BinOp::Shr | BinOp::Shl) {\n             let r = r.clone()?;\n             // We need the type of the LHS. We cannot use `place_layout` as that is the type\n             // of the result, which for checked binops is not the same!"}, {"sha": "c4b10218c237b2fa0cd19df96a75b3bbbb8f4b50", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -368,7 +368,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             this.ecx.read_immediate(&this.ecx.eval_operand(left, None)?)\n         });\n         // Check for exceeding shifts *even if* we cannot evaluate the LHS.\n-        if op == BinOp::Shr || op == BinOp::Shl {\n+        if matches!(op, BinOp::Shr | BinOp::Shl) {\n             let r = r.clone()?;\n             // We need the type of the LHS. We cannot use `place_layout` as that is the type\n             // of the result, which for checked binops is not the same!"}, {"sha": "22ea8710e6a96204efe13ead400e7442b9311a5e", "filename": "compiler/rustc_mir_transform/src/coverage/debug.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -323,7 +323,10 @@ impl DebugCounters {\n                         String::new()\n                     },\n                     self.format_operand(lhs),\n-                    if op == Op::Add { \"+\" } else { \"-\" },\n+                    match op {\n+                        Op::Add => \"+\",\n+                        Op::Subtract => \"-\",\n+                    },\n                     self.format_operand(rhs),\n                 );\n             }"}, {"sha": "e9ca6f7c93c446b569f72aa608087182c874b734", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -427,7 +427,7 @@ impl<'tcx> CloneShimBuilder<'tcx> {\n     fn make_place(&mut self, mutability: Mutability, ty: Ty<'tcx>) -> Place<'tcx> {\n         let span = self.span;\n         let mut local = LocalDecl::new(ty, span);\n-        if mutability == Mutability::Not {\n+        if mutability.is_not() {\n             local = local.immutable();\n         }\n         Place::from(self.local_decls.push(local))"}, {"sha": "58c7a398f14252e3e2ac7cd4bcf79c16b9049ab6", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -93,11 +93,12 @@ impl<'a> Parser<'a> {\n             // or `auto trait` items. We aim to parse an arbitrary path `a::b` but not something\n             // that starts like a path (1 token), but it fact not a path.\n             // Also, we avoid stealing syntax from `parse_item_`.\n-            if force_collect == ForceCollect::Yes {\n-                self.collect_tokens_no_attrs(|this| this.parse_stmt_path_start(lo, attrs))\n-            } else {\n-                self.parse_stmt_path_start(lo, attrs)\n-            }?\n+            match force_collect {\n+                ForceCollect::Yes => {\n+                    self.collect_tokens_no_attrs(|this| this.parse_stmt_path_start(lo, attrs))?\n+                }\n+                ForceCollect::No => self.parse_stmt_path_start(lo, attrs)?,\n+            }\n         } else if let Some(item) = self.parse_item_common(\n             attrs.clone(),\n             false,\n@@ -113,13 +114,12 @@ impl<'a> Parser<'a> {\n             self.mk_stmt(lo, StmtKind::Empty)\n         } else if self.token != token::CloseDelim(Delimiter::Brace) {\n             // Remainder are line-expr stmts.\n-            let e = if force_collect == ForceCollect::Yes {\n-                self.collect_tokens_no_attrs(|this| {\n+            let e = match force_collect {\n+                ForceCollect::Yes => self.collect_tokens_no_attrs(|this| {\n                     this.parse_expr_res(Restrictions::STMT_EXPR, Some(attrs))\n-                })\n-            } else {\n-                self.parse_expr_res(Restrictions::STMT_EXPR, Some(attrs))\n-            }?;\n+                })?,\n+                ForceCollect::No => self.parse_expr_res(Restrictions::STMT_EXPR, Some(attrs))?,\n+            };\n             if matches!(e.kind, ExprKind::Assign(..)) && self.eat_keyword(kw::Else) {\n                 let bl = self.parse_block()?;\n                 // Destructuring assignment ... else."}, {"sha": "8b4f0ab8feb848a0008a9a212aae65bbc0f332ec", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -323,13 +323,14 @@ impl<'a> Parser<'a> {\n         } else if self.can_begin_bound() {\n             self.parse_bare_trait_object(lo, allow_plus)?\n         } else if self.eat(&token::DotDotDot) {\n-            if allow_c_variadic == AllowCVariadic::Yes {\n-                TyKind::CVarArgs\n-            } else {\n-                // FIXME(Centril): Should we just allow `...` syntactically\n-                // anywhere in a type and use semantic restrictions instead?\n-                self.error_illegal_c_varadic_ty(lo);\n-                TyKind::Err\n+            match allow_c_variadic {\n+                AllowCVariadic::Yes => TyKind::CVarArgs,\n+                AllowCVariadic::No => {\n+                    // FIXME(Centril): Should we just allow `...` syntactically\n+                    // anywhere in a type and use semantic restrictions instead?\n+                    self.error_illegal_c_varadic_ty(lo);\n+                    TyKind::Err\n+                }\n             }\n         } else {\n             let msg = format!(\"expected type, found {}\", super::token_descr(&self.token));\n@@ -343,10 +344,9 @@ impl<'a> Parser<'a> {\n         let mut ty = self.mk_ty(span, kind);\n \n         // Try to recover from use of `+` with incorrect priority.\n-        if allow_plus == AllowPlus::Yes {\n-            self.maybe_recover_from_bad_type_plus(&ty)?;\n-        } else {\n-            self.maybe_report_ambiguous_plus(impl_dyn_multi, &ty);\n+        match allow_plus {\n+            AllowPlus::Yes => self.maybe_recover_from_bad_type_plus(&ty)?,\n+            AllowPlus::No => self.maybe_report_ambiguous_plus(impl_dyn_multi, &ty),\n         }\n         if RecoverQuestionMark::Yes == recover_question_mark {\n             ty = self.maybe_recover_from_question_mark(ty);"}, {"sha": "d67d52da497468b5d2f484aa896fd94d6ef21167", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -864,33 +864,39 @@ impl CheckAttrVisitor<'_> {\n         target: Target,\n         specified_inline: &mut Option<(bool, Span)>,\n     ) -> bool {\n-        if target == Target::Use || target == Target::ExternCrate {\n-            let do_inline = meta.name_or_empty() == sym::inline;\n-            if let Some((prev_inline, prev_span)) = *specified_inline {\n-                if do_inline != prev_inline {\n-                    let mut spans = MultiSpan::from_spans(vec![prev_span, meta.span()]);\n-                    spans.push_span_label(prev_span, fluent::passes_doc_inline_conflict_first);\n-                    spans.push_span_label(meta.span(), fluent::passes_doc_inline_conflict_second);\n-                    self.tcx.sess.emit_err(errors::DocKeywordConflict { spans });\n-                    return false;\n+        match target {\n+            Target::Use | Target::ExternCrate => {\n+                let do_inline = meta.name_or_empty() == sym::inline;\n+                if let Some((prev_inline, prev_span)) = *specified_inline {\n+                    if do_inline != prev_inline {\n+                        let mut spans = MultiSpan::from_spans(vec![prev_span, meta.span()]);\n+                        spans.push_span_label(prev_span, fluent::passes_doc_inline_conflict_first);\n+                        spans.push_span_label(\n+                            meta.span(),\n+                            fluent::passes_doc_inline_conflict_second,\n+                        );\n+                        self.tcx.sess.emit_err(errors::DocKeywordConflict { spans });\n+                        return false;\n+                    }\n+                    true\n+                } else {\n+                    *specified_inline = Some((do_inline, meta.span()));\n+                    true\n                 }\n-                true\n-            } else {\n-                *specified_inline = Some((do_inline, meta.span()));\n-                true\n             }\n-        } else {\n-            self.tcx.emit_spanned_lint(\n-                INVALID_DOC_ATTRIBUTES,\n-                hir_id,\n-                meta.span(),\n-                errors::DocInlineOnlyUse {\n-                    attr_span: meta.span(),\n-                    item_span: (attr.style == AttrStyle::Outer)\n-                        .then(|| self.tcx.hir().span(hir_id)),\n-                },\n-            );\n-            false\n+            _ => {\n+                self.tcx.emit_spanned_lint(\n+                    INVALID_DOC_ATTRIBUTES,\n+                    hir_id,\n+                    meta.span(),\n+                    errors::DocInlineOnlyUse {\n+                        attr_span: meta.span(),\n+                        item_span: (attr.style == AttrStyle::Outer)\n+                            .then(|| self.tcx.hir().span(hir_id)),\n+                    },\n+                );\n+                false\n+            }\n         }\n     }\n \n@@ -1137,7 +1143,7 @@ impl CheckAttrVisitor<'_> {\n                                     errors::DocTestUnknownInclude {\n                                         path,\n                                         value: value.to_string(),\n-                                        inner: if attr.style == AttrStyle::Inner { \"!\" } else { \"\" },\n+                                        inner: match attr.style { AttrStyle::Inner=>  \"!\" , AttrStyle::Outer => \"\" },\n                                         sugg: (attr.meta().unwrap().span, applicability),\n                                     }\n                                 );"}, {"sha": "47911aef25d4fe1f240e1dc432d688e96338490e", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -125,7 +125,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n         if let Some((depr, span)) = &depr {\n             is_deprecated = true;\n \n-            if kind == AnnotationKind::Prohibited || kind == AnnotationKind::DeprecationProhibited {\n+            if matches!(kind, AnnotationKind::Prohibited | AnnotationKind::DeprecationProhibited) {\n                 let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n                 self.tcx.emit_spanned_lint(\n                     USELESS_DEPRECATED,"}, {"sha": "84421dc1f62253354794e3b8079c190213e7d66b", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -298,14 +298,15 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                             self.r.record_partial_res(id, PartialRes::new(res));\n                         }\n                         if module.is_normal() {\n-                            if res == Res::Err {\n-                                Ok(ty::Visibility::Public)\n-                            } else {\n-                                let vis = ty::Visibility::Restricted(res.def_id());\n-                                if self.r.is_accessible_from(vis, parent_scope.module) {\n-                                    Ok(vis.expect_local())\n-                                } else {\n-                                    Err(VisResolutionError::AncestorOnly(path.span))\n+                            match res {\n+                                Res::Err => Ok(ty::Visibility::Public),\n+                                _ => {\n+                                    let vis = ty::Visibility::Restricted(res.def_id());\n+                                    if self.r.is_accessible_from(vis, parent_scope.module) {\n+                                        Ok(vis.expect_local())\n+                                    } else {\n+                                        Err(VisResolutionError::AncestorOnly(path.span))\n+                                    }\n                                 }\n                             }\n                         } else {"}, {"sha": "7375df451e89cb247b3ddeae05989c260105519f", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -1552,12 +1552,12 @@ impl<'a> Resolver<'a> {\n             if b.is_extern_crate() && ident.span.rust_2018() {\n                 help_msgs.push(format!(\"use `::{ident}` to refer to this {thing} unambiguously\"))\n             }\n-            if misc == AmbiguityErrorMisc::SuggestCrate {\n-                help_msgs\n-                    .push(format!(\"use `crate::{ident}` to refer to this {thing} unambiguously\"))\n-            } else if misc == AmbiguityErrorMisc::SuggestSelf {\n-                help_msgs\n-                    .push(format!(\"use `self::{ident}` to refer to this {thing} unambiguously\"))\n+            match misc {\n+                AmbiguityErrorMisc::SuggestCrate => help_msgs\n+                    .push(format!(\"use `crate::{ident}` to refer to this {thing} unambiguously\")),\n+                AmbiguityErrorMisc::SuggestSelf => help_msgs\n+                    .push(format!(\"use `self::{ident}` to refer to this {thing} unambiguously\")),\n+                AmbiguityErrorMisc::FromPrelude | AmbiguityErrorMisc::None => {}\n             }\n \n             err.span_note(b.span, &note_msg);"}, {"sha": "a50a8178de38bb3af51f44380575ee81c39b3887", "filename": "compiler/rustc_save_analysis/src/sig.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -29,7 +29,6 @@ use crate::{id_from_def_id, SaveContext};\n \n use rls_data::{SigElement, Signature};\n \n-use rustc_ast::Mutability;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir_pretty::id_to_string;\n@@ -769,9 +768,8 @@ impl<'hir> Sig for hir::ForeignItem<'hir> {\n             }\n             hir::ForeignItemKind::Static(ref ty, m) => {\n                 let mut text = \"static \".to_owned();\n-                if m == Mutability::Mut {\n-                    text.push_str(\"mut \");\n-                }\n+                text.push_str(m.prefix_str());\n+\n                 let name = self.ident.to_string();\n                 let defs = vec![SigElement {\n                     id: id_from_def_id(self.owner_id.to_def_id()),"}, {"sha": "f6d0b9713f0d0ca1d03da77d4e798516beee410e", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=53bb6322dbc80d8a7da69e1ea4dbff98c4a70abb", "patch": "@@ -1230,20 +1230,23 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     }\n \n                     ty::PredicateKind::WellFormed(ty) => {\n-                        if self.tcx.sess.opts.unstable_opts.trait_solver == TraitSolver::Classic {\n-                            // WF predicates cannot themselves make\n-                            // errors. They can only block due to\n-                            // ambiguity; otherwise, they always\n-                            // degenerate into other obligations\n-                            // (which may fail).\n-                            span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n-                        } else {\n-                            // FIXME: we'll need a better message which takes into account\n-                            // which bounds actually failed to hold.\n-                            self.tcx.sess.struct_span_err(\n-                                span,\n-                                &format!(\"the type `{}` is not well-formed\", ty),\n-                            )\n+                        match self.tcx.sess.opts.unstable_opts.trait_solver {\n+                            TraitSolver::Classic => {\n+                                // WF predicates cannot themselves make\n+                                // errors. They can only block due to\n+                                // ambiguity; otherwise, they always\n+                                // degenerate into other obligations\n+                                // (which may fail).\n+                                span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n+                            }\n+                            TraitSolver::Chalk | TraitSolver::Next => {\n+                                // FIXME: we'll need a better message which takes into account\n+                                // which bounds actually failed to hold.\n+                                self.tcx.sess.struct_span_err(\n+                                    span,\n+                                    &format!(\"the type `{}` is not well-formed\", ty),\n+                                )\n+                            }\n                         }\n                     }\n "}]}