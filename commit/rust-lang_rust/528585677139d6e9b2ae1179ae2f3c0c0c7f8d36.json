{"sha": "528585677139d6e9b2ae1179ae2f3c0c0c7f8d36", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyODU4NTY3NzEzOWQ2ZTliMmFlMTE3OWFlMmYzYzBjMGM3ZjhkMzY=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-04-19T17:41:57Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-04-19T17:42:06Z"}, "message": "Match on Symbol instead of &str in intrinsics handling", "tree": {"sha": "ea891c0deaed6f77dcd684d02c7927ebde92c5fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea891c0deaed6f77dcd684d02c7927ebde92c5fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/528585677139d6e9b2ae1179ae2f3c0c0c7f8d36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/528585677139d6e9b2ae1179ae2f3c0c0c7f8d36", "html_url": "https://github.com/rust-lang/rust/commit/528585677139d6e9b2ae1179ae2f3c0c0c7f8d36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/528585677139d6e9b2ae1179ae2f3c0c0c7f8d36/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf85572f59f5b70d73869c3902964c5ca47668df", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf85572f59f5b70d73869c3902964c5ca47668df", "html_url": "https://github.com/rust-lang/rust/commit/bf85572f59f5b70d73869c3902964c5ca47668df"}], "stats": {"total": 139, "additions": 69, "deletions": 70}, "files": [{"sha": "ba4ed2162cd5d1397c38fa210e1c36445a0226a3", "filename": "src/intrinsics/llvm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/528585677139d6e9b2ae1179ae2f3c0c0c7f8d36/src%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528585677139d6e9b2ae1179ae2f3c0c0c7f8d36/src%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fllvm.rs?ref=528585677139d6e9b2ae1179ae2f3c0c0c7f8d36", "patch": "@@ -22,7 +22,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n         };\n \n         // Used by `_mm_movemask_epi8` and `_mm256_movemask_epi8`\n-        llvm.x86.sse2.pmovmskb.128 | llvm.x86.avx2.pmovmskb | llvm.x86.sse2.movmsk.pd, (c a) {\n+        \"llvm.x86.sse2.pmovmskb.128\" | \"llvm.x86.avx2.pmovmskb\" | \"llvm.x86.sse2.movmsk.pd\", (c a) {\n             let (lane_count, lane_ty) = a.layout().ty.simd_size_and_type(fx.tcx);\n             let lane_ty = fx.clif_type(lane_ty).unwrap();\n             assert!(lane_count <= 32);\n@@ -51,7 +51,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n             let res = CValue::by_val(res, fx.layout_of(fx.tcx.types.i32));\n             ret.write_cvalue(fx, res);\n         };\n-        llvm.x86.sse2.cmp.ps | llvm.x86.sse2.cmp.pd, (c x, c y, o kind) {\n+        \"llvm.x86.sse2.cmp.ps\" | \"llvm.x86.sse2.cmp.pd\", (c x, c y, o kind) {\n             let kind_const = crate::constant::mir_operand_get_const_val(fx, kind).expect(\"llvm.x86.sse2.cmp.* kind not const\");\n             let flt_cc = match kind_const.try_to_bits(Size::from_bytes(1)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", kind_const)) {\n                 0 => FloatCC::Equal,\n@@ -81,7 +81,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n                 bool_to_zero_or_max_uint(fx, res_lane_layout, res_lane)\n             });\n         };\n-        llvm.x86.sse2.psrli.d, (c a, o imm8) {\n+        \"llvm.x86.sse2.psrli.d\", (c a, o imm8) {\n             let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8).expect(\"llvm.x86.sse2.psrli.d imm8 not const\");\n             simd_for_each_lane(fx, a, ret, |fx, _lane_layout, res_lane_layout, lane| {\n                 let res_lane = match imm8.try_to_bits(Size::from_bytes(4)).unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8)) {\n@@ -91,7 +91,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n                 CValue::by_val(res_lane, res_lane_layout)\n             });\n         };\n-        llvm.x86.sse2.pslli.d, (c a, o imm8) {\n+        \"llvm.x86.sse2.pslli.d\", (c a, o imm8) {\n             let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8).expect(\"llvm.x86.sse2.psrli.d imm8 not const\");\n             simd_for_each_lane(fx, a, ret, |fx, _lane_layout, res_lane_layout, lane| {\n                 let res_lane = match imm8.try_to_bits(Size::from_bytes(4)).unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8)) {\n@@ -101,7 +101,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n                 CValue::by_val(res_lane, res_lane_layout)\n             });\n         };\n-        llvm.x86.sse2.storeu.dq, (v mem_addr, c a) {\n+        \"llvm.x86.sse2.storeu.dq\", (v mem_addr, c a) {\n             // FIXME correctly handle the unalignment\n             let dest = CPlace::for_ptr(Pointer::new(mem_addr), a.layout());\n             dest.write_cvalue(fx, a);"}, {"sha": "435737f3a513b511c1788db6cc663994fd6b7886", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/528585677139d6e9b2ae1179ae2f3c0c0c7f8d36/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528585677139d6e9b2ae1179ae2f3c0c0c7f8d36/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=528585677139d6e9b2ae1179ae2f3c0c0c7f8d36", "patch": "@@ -8,23 +8,25 @@ mod simd;\n pub(crate) use cpuid::codegen_cpuid_call;\n pub(crate) use llvm::codegen_llvm_intrinsic_call;\n \n+use rustc_span::symbol::{sym, kw};\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n+\n use crate::prelude::*;\n use cranelift_codegen::ir::AtomicRmwOp;\n-use rustc_middle::ty::print::with_no_trimmed_paths;\n \n macro intrinsic_pat {\n     (_) => {\n         _\n     },\n     ($name:ident) => {\n-        stringify!($name)\n+        sym::$name\n+    },\n+    (kw.$name:ident) => {\n+        kw::$name\n     },\n     ($name:literal) => {\n-        stringify!($name)\n+        $name\n     },\n-    ($x:ident . $($xs:tt).*) => {\n-        concat!(stringify!($x), \".\", intrinsic_pat!($($xs).*))\n-    }\n }\n \n macro intrinsic_arg {\n@@ -87,7 +89,7 @@ macro call_intrinsic_match {\n     )*) => {\n         match $intrinsic {\n             $(\n-                stringify!($name) => {\n+                sym::$name => {\n                     assert!($substs.is_noop());\n                     if let [$(ref $arg),*] = *$args {\n                         let ($($arg,)*) = (\n@@ -400,18 +402,17 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n     let def_id = instance.def_id();\n     let substs = instance.substs;\n \n-    let intrinsic = fx.tcx.item_name(def_id).as_str();\n-    let intrinsic = &intrinsic[..];\n+    let intrinsic = fx.tcx.item_name(def_id);\n \n     let ret = match destination {\n         Some((place, _)) => place,\n         None => {\n             // Insert non returning intrinsics here\n             match intrinsic {\n-                \"abort\" => {\n+                sym::abort => {\n                     trap_abort(fx, \"Called intrinsic::abort.\");\n                 }\n-                \"transmute\" => {\n+                sym::transmute => {\n                     crate::base::codegen_panic(fx, \"Transmuting to uninhabited type.\", span);\n                 }\n                 _ => unimplemented!(\"unsupported instrinsic {}\", intrinsic),\n@@ -420,7 +421,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         }\n     };\n \n-    if intrinsic.starts_with(\"simd_\") {\n+    if intrinsic.as_str().starts_with(\"simd_\") {\n         self::simd::codegen_simd_intrinsic_call(fx, instance, args, ret, span);\n         let ret_block = fx.get_block(destination.expect(\"SIMD intrinsics don't diverge\").1);\n         fx.bcx.ins().jump(ret_block, &[]);\n@@ -470,8 +471,6 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         sinf64(flt) -> f64 => sin,\n         cosf32(flt) -> f32 => cosf,\n         cosf64(flt) -> f64 => cos,\n-        tanf32(flt) -> f32 => tanf,\n-        tanf64(flt) -> f64 => tan,\n     }\n \n     intrinsic_match! {\n@@ -496,7 +495,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 count\n             };\n \n-            if intrinsic.contains(\"nonoverlapping\") {\n+            if intrinsic == sym::copy_nonoverlapping {\n                 // FIXME emit_small_memcpy\n                 fx.bcx.call_memcpy(fx.module.target_config(), dst, src, byte_amount);\n             } else {\n@@ -515,7 +514,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             };\n \n             // FIXME make the copy actually volatile when using emit_small_mem{cpy,move}\n-            if intrinsic.contains(\"nonoverlapping\") {\n+            if intrinsic == sym::volatile_copy_nonoverlapping_memory {\n                 // FIXME emit_small_memcpy\n                 fx.bcx.call_memcpy(fx.module.target_config(), dst, src, byte_amount);\n             } else {\n@@ -552,27 +551,28 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, CValue::by_val(align, usize_layout));\n         };\n \n-        _ if intrinsic.starts_with(\"unchecked_\") || intrinsic == \"exact_div\", (c x, c y) {\n+        unchecked_add | unchecked_sub | unchecked_div | exact_div | unchecked_rem\n+        | unchecked_shl | unchecked_shr, (c x, c y) {\n             // FIXME trap on overflow\n             let bin_op = match intrinsic {\n-                \"unchecked_add\" => BinOp::Add,\n-                \"unchecked_sub\" => BinOp::Sub,\n-                \"unchecked_div\" | \"exact_div\" => BinOp::Div,\n-                \"unchecked_rem\" => BinOp::Rem,\n-                \"unchecked_shl\" => BinOp::Shl,\n-                \"unchecked_shr\" => BinOp::Shr,\n-                _ => unreachable!(\"intrinsic {}\", intrinsic),\n+                sym::unchecked_add => BinOp::Add,\n+                sym::unchecked_sub => BinOp::Sub,\n+                sym::unchecked_div | sym::exact_div => BinOp::Div,\n+                sym::unchecked_rem => BinOp::Rem,\n+                sym::unchecked_shl => BinOp::Shl,\n+                sym::unchecked_shr => BinOp::Shr,\n+                _ => unreachable!(),\n             };\n             let res = crate::num::codegen_int_binop(fx, bin_op, x, y);\n             ret.write_cvalue(fx, res);\n         };\n-        _ if intrinsic.ends_with(\"_with_overflow\"), (c x, c y) {\n+        add_with_overflow | sub_with_overflow | mul_with_overflow, (c x, c y) {\n             assert_eq!(x.layout().ty, y.layout().ty);\n             let bin_op = match intrinsic {\n-                \"add_with_overflow\" => BinOp::Add,\n-                \"sub_with_overflow\" => BinOp::Sub,\n-                \"mul_with_overflow\" => BinOp::Mul,\n-                _ => unreachable!(\"intrinsic {}\", intrinsic),\n+                sym::add_with_overflow => BinOp::Add,\n+                sym::sub_with_overflow => BinOp::Sub,\n+                sym::mul_with_overflow => BinOp::Mul,\n+                _ => unreachable!(),\n             };\n \n             let res = crate::num::codegen_checked_int_binop(\n@@ -583,12 +583,12 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             );\n             ret.write_cvalue(fx, res);\n         };\n-        _ if intrinsic.starts_with(\"saturating_\"), <T> (c lhs, c rhs) {\n+        saturating_add | saturating_sub, <T> (c lhs, c rhs) {\n             assert_eq!(lhs.layout().ty, rhs.layout().ty);\n             let bin_op = match intrinsic {\n-                \"saturating_add\" => BinOp::Add,\n-                \"saturating_sub\" => BinOp::Sub,\n-                _ => unreachable!(\"intrinsic {}\", intrinsic),\n+                sym::saturating_add => BinOp::Add,\n+                sym::saturating_sub => BinOp::Sub,\n+                _ => unreachable!(),\n             };\n \n             let signed = type_sign(T);\n@@ -609,15 +609,15 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let (min, max) = type_min_max_value(&mut fx.bcx, clif_ty, signed);\n \n             let val = match (intrinsic, signed) {\n-                (\"saturating_add\", false) => fx.bcx.ins().select(has_overflow, max, val),\n-                (\"saturating_sub\", false) => fx.bcx.ins().select(has_overflow, min, val),\n-                (\"saturating_add\", true) => {\n+                (sym::saturating_add, false) => fx.bcx.ins().select(has_overflow, max, val),\n+                (sym::saturating_sub, false) => fx.bcx.ins().select(has_overflow, min, val),\n+                (sym::saturating_add, true) => {\n                     let rhs = rhs.load_scalar(fx);\n                     let rhs_ge_zero = fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThanOrEqual, rhs, 0);\n                     let sat_val = fx.bcx.ins().select(rhs_ge_zero, max, min);\n                     fx.bcx.ins().select(has_overflow, sat_val, val)\n                 }\n-                (\"saturating_sub\", true) => {\n+                (sym::saturating_sub, true) => {\n                     let rhs = rhs.load_scalar(fx);\n                     let rhs_ge_zero = fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThanOrEqual, rhs, 0);\n                     let sat_val = fx.bcx.ins().select(rhs_ge_zero, min, max);\n@@ -816,7 +816,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 return;\n             }\n \n-            if intrinsic == \"assert_zero_valid\" && !layout.might_permit_raw_init(fx, /*zero:*/ true).unwrap() {\n+            if intrinsic == sym::assert_zero_valid && !layout.might_permit_raw_init(fx, /*zero:*/ true).unwrap() {\n                 with_no_trimmed_paths(|| crate::base::codegen_panic(\n                     fx,\n                     &format!(\"attempted to zero-initialize type `{}`, which is invalid\", T),\n@@ -825,7 +825,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 return;\n             }\n \n-            if intrinsic == \"assert_uninit_valid\" && !layout.might_permit_raw_init(fx, /*zero:*/ false).unwrap() {\n+            if intrinsic == sym::assert_uninit_valid && !layout.might_permit_raw_init(fx, /*zero:*/ false).unwrap() {\n                 with_no_trimmed_paths(|| crate::base::codegen_panic(\n                     fx,\n                     &format!(\"attempted to leave type `{}` uninitialized, which is invalid\", T),\n@@ -886,14 +886,14 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, caller_location);\n         };\n \n-        _ if intrinsic.starts_with(\"atomic_fence\"), () {\n+        _ if intrinsic.as_str().starts_with(\"atomic_fence\"), () {\n             fx.bcx.ins().fence();\n         };\n-        _ if intrinsic.starts_with(\"atomic_singlethreadfence\"), () {\n+        _ if intrinsic.as_str().starts_with(\"atomic_singlethreadfence\"), () {\n             // FIXME use a compiler fence once Cranelift supports it\n             fx.bcx.ins().fence();\n         };\n-        _ if intrinsic.starts_with(\"atomic_load\"), <T> (v ptr) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_load\"), <T> (v ptr) {\n             validate_atomic_type!(fx, intrinsic, span, T);\n             let ty = fx.clif_type(T).unwrap();\n \n@@ -902,14 +902,14 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let val = CValue::by_val(val, fx.layout_of(T));\n             ret.write_cvalue(fx, val);\n         };\n-        _ if intrinsic.starts_with(\"atomic_store\"), (v ptr, c val) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_store\"), (v ptr, c val) {\n             validate_atomic_type!(fx, intrinsic, span, val.layout().ty);\n \n             let val = val.load_scalar(fx);\n \n             fx.bcx.ins().atomic_store(MemFlags::trusted(), val, ptr);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xchg\"), (v ptr, c new) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_xchg\"), (v ptr, c new) {\n             let layout = new.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -921,7 +921,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_cxchg\"), (v ptr, c test_old, c new) { // both atomic_cxchg_* and atomic_cxchgweak_*\n+        _ if intrinsic.as_str().starts_with(\"atomic_cxchg\"), (v ptr, c test_old, c new) { // both atomic_cxchg_* and atomic_cxchgweak_*\n             let layout = new.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n \n@@ -935,7 +935,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, ret_val)\n         };\n \n-        _ if intrinsic.starts_with(\"atomic_xadd\"), (v ptr, c amount) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_xadd\"), (v ptr, c amount) {\n             let layout = amount.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -947,7 +947,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xsub\"), (v ptr, c amount) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_xsub\"), (v ptr, c amount) {\n             let layout = amount.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -959,7 +959,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_and\"), (v ptr, c src) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_and\"), (v ptr, c src) {\n             let layout = src.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -971,7 +971,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_or\"), (v ptr, c src) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_or\"), (v ptr, c src) {\n             let layout = src.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -983,7 +983,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xor\"), (v ptr, c src) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_xor\"), (v ptr, c src) {\n             let layout = src.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -997,7 +997,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n \n         // FIXME https://github.com/bytecodealliance/wasmtime/issues/2647\n-        _ if intrinsic.starts_with(\"atomic_nand\"), (v ptr, c src) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_nand\"), (v ptr, c src) {\n             let layout = src.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -1009,7 +1009,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_max\"), (v ptr, c src) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_max\"), (v ptr, c src) {\n             let layout = src.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -1021,7 +1021,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_umax\"), (v ptr, c src) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_umax\"), (v ptr, c src) {\n             let layout = src.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -1033,7 +1033,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_min\"), (v ptr, c src) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_min\"), (v ptr, c src) {\n             let layout = src.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -1045,7 +1045,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_umin\"), (v ptr, c src) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_umin\"), (v ptr, c src) {\n             let layout = src.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -1079,7 +1079,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, val);\n         };\n \n-        try, (v f, v data, v _catch_fn) {\n+        kw.Try, (v f, v data, v _catch_fn) {\n             // FIXME once unwinding is supported, change this to actually catch panics\n             let f_sig = fx.bcx.func.import_signature(Signature {\n                 call_conv: CallConv::triple_default(fx.triple()),\n@@ -1096,11 +1096,11 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n \n         fadd_fast | fsub_fast | fmul_fast | fdiv_fast | frem_fast, (c x, c y) {\n             let res = crate::num::codegen_float_binop(fx, match intrinsic {\n-                \"fadd_fast\" => BinOp::Add,\n-                \"fsub_fast\" => BinOp::Sub,\n-                \"fmul_fast\" => BinOp::Mul,\n-                \"fdiv_fast\" => BinOp::Div,\n-                \"frem_fast\" => BinOp::Rem,\n+                sym::fadd_fast => BinOp::Add,\n+                sym::fsub_fast => BinOp::Sub,\n+                sym::fmul_fast => BinOp::Mul,\n+                sym::fdiv_fast => BinOp::Div,\n+                sym::frem_fast => BinOp::Rem,\n                 _ => unreachable!(),\n             }, x, y);\n             ret.write_cvalue(fx, res);"}, {"sha": "e71925a0f545872d138e11e179012df010f66f81", "filename": "src/intrinsics/simd.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/528585677139d6e9b2ae1179ae2f3c0c0c7f8d36/src%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528585677139d6e9b2ae1179ae2f3c0c0c7f8d36/src%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fsimd.rs?ref=528585677139d6e9b2ae1179ae2f3c0c0c7f8d36", "patch": "@@ -13,8 +13,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n     let def_id = instance.def_id();\n     let substs = instance.substs;\n \n-    let intrinsic = fx.tcx.item_name(def_id).as_str();\n-    let intrinsic = &intrinsic[..];\n+    let intrinsic = fx.tcx.item_name(def_id);\n \n     intrinsic_match! {\n         fx, intrinsic, substs, args,\n@@ -65,10 +64,10 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n         };\n \n         // simd_shuffle32<T, U>(x: T, y: T, idx: [u32; 32]) -> U\n-        _ if intrinsic.starts_with(\"simd_shuffle\"), (c x, c y, o idx) {\n+        _ if intrinsic.as_str().starts_with(\"simd_shuffle\"), (c x, c y, o idx) {\n             validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n \n-            let n: u16 = intrinsic[\"simd_shuffle\".len()..].parse().unwrap();\n+            let n: u16 = intrinsic.as_str()[\"simd_shuffle\".len()..].parse().unwrap();\n \n             assert_eq!(x.layout(), y.layout());\n             let layout = x.layout();"}]}