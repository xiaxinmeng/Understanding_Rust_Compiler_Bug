{"sha": "e364f0eb5a51a96932ecd01dd2319eff4bdae2d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzNjRmMGViNWE1MWE5NjkzMmVjZDAxZGQyMzE5ZWZmNGJkYWUyZDE=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-07-14T00:10:44Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-08-17T21:41:37Z"}, "message": "feature gate `cfg(target_feature)`.\n\nThis is theoretically a breaking change, but GitHub search turns up no\nuses of it, and most non-built-in cfg's are passed via cargo features,\nwhich look like `feature = \"...\"`, and hence can't overlap.", "tree": {"sha": "d57d4f8c970a18f7877151c4e449485c920b49e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d57d4f8c970a18f7877151c4e449485c920b49e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e364f0eb5a51a96932ecd01dd2319eff4bdae2d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e364f0eb5a51a96932ecd01dd2319eff4bdae2d1", "html_url": "https://github.com/rust-lang/rust/commit/e364f0eb5a51a96932ecd01dd2319eff4bdae2d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e364f0eb5a51a96932ecd01dd2319eff4bdae2d1/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c66554cab3518a9f5c36eafd622ca4c8a3fda631", "url": "https://api.github.com/repos/rust-lang/rust/commits/c66554cab3518a9f5c36eafd622ca4c8a3fda631", "html_url": "https://github.com/rust-lang/rust/commit/c66554cab3518a9f5c36eafd622ca4c8a3fda631"}], "stats": {"total": 178, "additions": 150, "deletions": 28}, "files": [{"sha": "346e7a7bf9886284802d5f8ee34ae8411ea4a830", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e364f0eb5a51a96932ecd01dd2319eff4bdae2d1/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e364f0eb5a51a96932ecd01dd2319eff4bdae2d1/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=e364f0eb5a51a96932ecd01dd2319eff4bdae2d1", "patch": "@@ -406,8 +406,10 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     //\n     // baz! should not use this definition unless foo is enabled.\n \n-    krate = time(time_passes, \"configuration 1\", move ||\n-                 syntax::config::strip_unconfigured_items(sess.diagnostic(), krate));\n+    let mut feature_gated_cfgs = vec![];\n+    krate = time(time_passes, \"configuration 1\", ||\n+                 syntax::config::strip_unconfigured_items(sess.diagnostic(), krate,\n+                                                          &mut feature_gated_cfgs));\n \n     *sess.crate_types.borrow_mut() =\n         collect_crate_types(sess, &krate.attrs);\n@@ -511,6 +513,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n                                           cfg,\n                                           macros,\n                                           syntax_exts,\n+                                          &mut feature_gated_cfgs,\n                                           krate);\n         if cfg!(windows) {\n             env::set_var(\"PATH\", &_old_path);\n@@ -536,7 +539,17 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n \n     // strip again, in case expansion added anything with a #[cfg].\n     krate = time(time_passes, \"configuration 2\", ||\n-                 syntax::config::strip_unconfigured_items(sess.diagnostic(), krate));\n+                 syntax::config::strip_unconfigured_items(sess.diagnostic(), krate,\n+                                                          &mut feature_gated_cfgs));\n+\n+    time(time_passes, \"gated configuration checking\", || {\n+        let features = sess.features.borrow();\n+        feature_gated_cfgs.sort();\n+        feature_gated_cfgs.dedup();\n+        for cfg in &feature_gated_cfgs {\n+            cfg.check_and_emit(sess.diagnostic(), &features);\n+        }\n+    });\n \n     krate = time(time_passes, \"maybe building test harness\", ||\n                  syntax::test::modify_for_testing(&sess.parse_sess,"}, {"sha": "7540c2ff831e932976a2e0feca58e781fd25a542", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e364f0eb5a51a96932ecd01dd2319eff4bdae2d1/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e364f0eb5a51a96932ecd01dd2319eff4bdae2d1/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=e364f0eb5a51a96932ecd01dd2319eff4bdae2d1", "patch": "@@ -19,6 +19,7 @@ use ast::{AttrId, Attribute, Attribute_, MetaItem, MetaWord, MetaNameValue, Meta\n use codemap::{Span, Spanned, spanned, dummy_spanned};\n use codemap::BytePos;\n use diagnostic::SpanHandler;\n+use feature_gate::GatedCfg;\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use parse::token::{InternedString, intern_and_get_ident};\n use parse::token;\n@@ -357,24 +358,28 @@ pub fn requests_inline(attrs: &[Attribute]) -> bool {\n }\n \n /// Tests if a cfg-pattern matches the cfg set\n-pub fn cfg_matches(diagnostic: &SpanHandler, cfgs: &[P<MetaItem>], cfg: &ast::MetaItem) -> bool {\n+pub fn cfg_matches(diagnostic: &SpanHandler, cfgs: &[P<MetaItem>], cfg: &ast::MetaItem,\n+                   feature_gated_cfgs: &mut Vec<GatedCfg>) -> bool {\n     match cfg.node {\n         ast::MetaList(ref pred, ref mis) if &pred[..] == \"any\" =>\n-            mis.iter().any(|mi| cfg_matches(diagnostic, cfgs, &**mi)),\n+            mis.iter().any(|mi| cfg_matches(diagnostic, cfgs, &**mi, feature_gated_cfgs)),\n         ast::MetaList(ref pred, ref mis) if &pred[..] == \"all\" =>\n-            mis.iter().all(|mi| cfg_matches(diagnostic, cfgs, &**mi)),\n+            mis.iter().all(|mi| cfg_matches(diagnostic, cfgs, &**mi, feature_gated_cfgs)),\n         ast::MetaList(ref pred, ref mis) if &pred[..] == \"not\" => {\n             if mis.len() != 1 {\n                 diagnostic.span_err(cfg.span, \"expected 1 cfg-pattern\");\n                 return false;\n             }\n-            !cfg_matches(diagnostic, cfgs, &*mis[0])\n+            !cfg_matches(diagnostic, cfgs, &*mis[0], feature_gated_cfgs)\n         }\n         ast::MetaList(ref pred, _) => {\n             diagnostic.span_err(cfg.span, &format!(\"invalid predicate `{}`\", pred));\n             false\n         },\n-        ast::MetaWord(_) | ast::MetaNameValue(..) => contains(cfgs, cfg),\n+        ast::MetaWord(_) | ast::MetaNameValue(..) => {\n+            feature_gated_cfgs.extend(GatedCfg::gate(cfg));\n+            contains(cfgs, cfg)\n+        }\n     }\n }\n "}, {"sha": "faf0b51c8de0eda798c088a140ed32b2c880ac73", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e364f0eb5a51a96932ecd01dd2319eff4bdae2d1/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e364f0eb5a51a96932ecd01dd2319eff4bdae2d1/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=e364f0eb5a51a96932ecd01dd2319eff4bdae2d1", "patch": "@@ -10,6 +10,7 @@\n \n use attr::AttrMetaMethods;\n use diagnostic::SpanHandler;\n+use feature_gate::GatedCfg;\n use fold::Folder;\n use {ast, fold, attr};\n use codemap::{Spanned, respan};\n@@ -25,10 +26,13 @@ struct Context<F> where F: FnMut(&[ast::Attribute]) -> bool {\n \n // Support conditional compilation by transforming the AST, stripping out\n // any items that do not belong in the current configuration\n-pub fn strip_unconfigured_items(diagnostic: &SpanHandler, krate: ast::Crate) -> ast::Crate {\n-    let krate = process_cfg_attr(diagnostic, krate);\n+pub fn strip_unconfigured_items(diagnostic: &SpanHandler, krate: ast::Crate,\n+                                feature_gated_cfgs: &mut Vec<GatedCfg>)\n+                                -> ast::Crate\n+{\n+    let krate = process_cfg_attr(diagnostic, krate, feature_gated_cfgs);\n     let config = krate.config.clone();\n-    strip_items(krate, |attrs| in_cfg(diagnostic, &config, attrs))\n+    strip_items(krate, |attrs| in_cfg(diagnostic, &config, attrs, feature_gated_cfgs))\n }\n \n impl<F> fold::Folder for Context<F> where F: FnMut(&[ast::Attribute]) -> bool {\n@@ -248,7 +252,8 @@ fn foreign_item_in_cfg<F>(cx: &mut Context<F>, item: &ast::ForeignItem) -> bool\n \n // Determine if an item should be translated in the current crate\n // configuration based on the item's attributes\n-fn in_cfg(diagnostic: &SpanHandler, cfg: &[P<ast::MetaItem>], attrs: &[ast::Attribute]) -> bool {\n+fn in_cfg(diagnostic: &SpanHandler, cfg: &[P<ast::MetaItem>], attrs: &[ast::Attribute],\n+          feature_gated_cfgs: &mut Vec<GatedCfg>) -> bool {\n     attrs.iter().all(|attr| {\n         let mis = match attr.node.value.node {\n             ast::MetaList(_, ref mis) if attr.check_name(\"cfg\") => mis,\n@@ -260,25 +265,29 @@ fn in_cfg(diagnostic: &SpanHandler, cfg: &[P<ast::MetaItem>], attrs: &[ast::Attr\n             return true;\n         }\n \n-        attr::cfg_matches(diagnostic, cfg, &*mis[0])\n+        attr::cfg_matches(diagnostic, cfg, &*mis[0],\n+                          feature_gated_cfgs)\n     })\n }\n \n-struct CfgAttrFolder<'a> {\n+struct CfgAttrFolder<'a, 'b> {\n     diag: &'a SpanHandler,\n     config: ast::CrateConfig,\n+    feature_gated_cfgs: &'b mut Vec<GatedCfg>\n }\n \n // Process `#[cfg_attr]`.\n-fn process_cfg_attr(diagnostic: &SpanHandler, krate: ast::Crate) -> ast::Crate {\n+fn process_cfg_attr(diagnostic: &SpanHandler, krate: ast::Crate,\n+                    feature_gated_cfgs: &mut Vec<GatedCfg>) -> ast::Crate {\n     let mut fld = CfgAttrFolder {\n         diag: diagnostic,\n         config: krate.config.clone(),\n+        feature_gated_cfgs: feature_gated_cfgs,\n     };\n     fld.fold_crate(krate)\n }\n \n-impl<'a> fold::Folder for CfgAttrFolder<'a> {\n+impl<'a,'b> fold::Folder for CfgAttrFolder<'a,'b> {\n     fn fold_attribute(&mut self, attr: ast::Attribute) -> Option<ast::Attribute> {\n         if !attr.check_name(\"cfg_attr\") {\n             return fold::noop_fold_attribute(attr, self);\n@@ -299,7 +308,8 @@ impl<'a> fold::Folder for CfgAttrFolder<'a> {\n             }\n         };\n \n-        if attr::cfg_matches(self.diag, &self.config[..], &cfg) {\n+        if attr::cfg_matches(self.diag, &self.config[..], &cfg,\n+                             self.feature_gated_cfgs) {\n             Some(respan(mi.span, ast::Attribute_ {\n                 id: attr::mk_attr_id(),\n                 style: attr.node.style,"}, {"sha": "ef11a2bd66e804bd5e80a915b0785a78c6c2af42", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e364f0eb5a51a96932ecd01dd2319eff4bdae2d1/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e364f0eb5a51a96932ecd01dd2319eff4bdae2d1/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=e364f0eb5a51a96932ecd01dd2319eff4bdae2d1", "patch": "@@ -17,6 +17,7 @@ use codemap::{CodeMap, Span, ExpnId, ExpnInfo, NO_EXPANSION, CompilerExpansion};\n use ext;\n use ext::expand;\n use ext::tt::macro_rules;\n+use feature_gate::GatedCfg;\n use parse;\n use parse::parser;\n use parse::token;\n@@ -632,6 +633,7 @@ pub struct ExtCtxt<'a> {\n     pub backtrace: ExpnId,\n     pub ecfg: expand::ExpansionConfig<'a>,\n     pub crate_root: Option<&'static str>,\n+    pub feature_gated_cfgs: &'a mut Vec<GatedCfg>,\n \n     pub mod_path: Vec<ast::Ident> ,\n     pub exported_macros: Vec<ast::MacroDef>,\n@@ -642,7 +644,8 @@ pub struct ExtCtxt<'a> {\n \n impl<'a> ExtCtxt<'a> {\n     pub fn new(parse_sess: &'a parse::ParseSess, cfg: ast::CrateConfig,\n-               ecfg: expand::ExpansionConfig<'a>) -> ExtCtxt<'a> {\n+               ecfg: expand::ExpansionConfig<'a>,\n+               feature_gated_cfgs: &'a mut Vec<GatedCfg>) -> ExtCtxt<'a> {\n         let env = initial_syntax_expander_table(&ecfg);\n         ExtCtxt {\n             parse_sess: parse_sess,\n@@ -651,6 +654,7 @@ impl<'a> ExtCtxt<'a> {\n             mod_path: Vec::new(),\n             ecfg: ecfg,\n             crate_root: None,\n+            feature_gated_cfgs: feature_gated_cfgs,\n             exported_macros: Vec::new(),\n             syntax_env: env,\n             recursion_count: 0,"}, {"sha": "aa654e30530afc1e8b01ecdb229cffc708660fc2", "filename": "src/libsyntax/ext/cfg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e364f0eb5a51a96932ecd01dd2319eff4bdae2d1/src%2Flibsyntax%2Fext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e364f0eb5a51a96932ecd01dd2319eff4bdae2d1/src%2Flibsyntax%2Fext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg.rs?ref=e364f0eb5a51a96932ecd01dd2319eff4bdae2d1", "patch": "@@ -34,6 +34,7 @@ pub fn expand_cfg<'cx>(cx: &mut ExtCtxt,\n         return DummyResult::expr(sp);\n     }\n \n-    let matches_cfg = attr::cfg_matches(&cx.parse_sess.span_diagnostic, &cx.cfg, &*cfg);\n+    let matches_cfg = attr::cfg_matches(&cx.parse_sess.span_diagnostic, &cx.cfg, &*cfg,\n+                                        cx.feature_gated_cfgs);\n     MacEager::expr(cx.expr_bool(sp, matches_cfg))\n }"}, {"sha": "4f89b3494d403954c1a6e2f768b8f555ca6a0d03", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e364f0eb5a51a96932ecd01dd2319eff4bdae2d1/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e364f0eb5a51a96932ecd01dd2319eff4bdae2d1/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e364f0eb5a51a96932ecd01dd2319eff4bdae2d1", "patch": "@@ -21,7 +21,7 @@ use attr::AttrMetaMethods;\n use codemap;\n use codemap::{Span, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute, CompilerExpansion};\n use ext::base::*;\n-use feature_gate::{self, Features};\n+use feature_gate::{self, Features, GatedCfg};\n use fold;\n use fold::*;\n use parse;\n@@ -1687,8 +1687,10 @@ pub fn expand_crate<'feat>(parse_sess: &parse::ParseSess,\n                            // these are the macros being imported to this crate:\n                            imported_macros: Vec<ast::MacroDef>,\n                            user_exts: Vec<NamedSyntaxExtension>,\n+                           feature_gated_cfgs: &mut Vec<GatedCfg>,\n                            c: Crate) -> Crate {\n-    let mut cx = ExtCtxt::new(parse_sess, c.config.clone(), cfg);\n+    let mut cx = ExtCtxt::new(parse_sess, c.config.clone(), cfg,\n+                              feature_gated_cfgs);\n     if std_inject::no_core(&c) {\n         cx.crate_root = None;\n     } else if std_inject::no_std(&c) {\n@@ -1878,7 +1880,7 @@ mod tests {\n             src,\n             Vec::new(), &sess);\n         // should fail:\n-        expand_crate(&sess,test_ecfg(),vec!(),vec!(),crate_ast);\n+        expand_crate(&sess,test_ecfg(),vec!(),vec!(), &mut vec![], crate_ast);\n     }\n \n     // make sure that macros can't escape modules\n@@ -1891,7 +1893,7 @@ mod tests {\n             \"<test>\".to_string(),\n             src,\n             Vec::new(), &sess);\n-        expand_crate(&sess,test_ecfg(),vec!(),vec!(),crate_ast);\n+        expand_crate(&sess,test_ecfg(),vec!(),vec!(), &mut vec![], crate_ast);\n     }\n \n     // macro_use modules should allow macros to escape\n@@ -1903,14 +1905,14 @@ mod tests {\n             \"<test>\".to_string(),\n             src,\n             Vec::new(), &sess);\n-        expand_crate(&sess, test_ecfg(), vec!(), vec!(), crate_ast);\n+        expand_crate(&sess, test_ecfg(), vec!(), vec!(), &mut vec![], crate_ast);\n     }\n \n     fn expand_crate_str(crate_str: String) -> ast::Crate {\n         let ps = parse::ParseSess::new();\n         let crate_ast = panictry!(string_to_parser(&ps, crate_str).parse_crate_mod());\n         // the cfg argument actually does matter, here...\n-        expand_crate(&ps,test_ecfg(),vec!(),vec!(),crate_ast)\n+        expand_crate(&ps,test_ecfg(),vec!(),vec!(), &mut vec![], crate_ast)\n     }\n \n     // find the pat_ident paths in a crate"}, {"sha": "9a1c97a4d29f567ad737481264d1309af37dabf9", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e364f0eb5a51a96932ecd01dd2319eff4bdae2d1/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e364f0eb5a51a96932ecd01dd2319eff4bdae2d1/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=e364f0eb5a51a96932ecd01dd2319eff4bdae2d1", "patch": "@@ -37,6 +37,7 @@ use visit::Visitor;\n use parse::token::{self, InternedString};\n \n use std::ascii::AsciiExt;\n+use std::cmp;\n \n // If you change this list without updating src/doc/reference.md, @cmr will be sad\n // Don't ever remove anything from this list; set them to 'Removed'.\n@@ -180,6 +181,9 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Status)] = &[\n \n     // allow `repr(simd)`, and importing the various simd intrinsics\n     (\"simd_basics\", \"1.3.0\", Active),\n+\n+    // Allows cfg(target_feature = \"...\").\n+    (\"cfg_target_feature\", \"1.3.0\", Active),\n ];\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n@@ -327,6 +331,59 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType)] = &[\n     (\"recursion_limit\", CrateLevel),\n ];\n \n+macro_rules! cfg_fn {\n+    (|$x: ident| $e: expr) => {{\n+        fn f($x: &Features) -> bool {\n+            $e\n+        }\n+        f as fn(&Features) -> bool\n+    }}\n+}\n+// cfg(...)'s that are feature gated\n+const GATED_CFGS: &'static [(&'static str, &'static str, fn(&Features) -> bool)] = &[\n+    // (name in cfg, feature, function to check if the feature is enabled)\n+    (\"target_feature\", \"cfg_target_feature\", cfg_fn!(|x| x.cfg_target_feature)),\n+];\n+\n+#[derive(Debug, Eq, PartialEq)]\n+pub struct GatedCfg {\n+    span: Span,\n+    index: usize,\n+}\n+impl Ord for GatedCfg {\n+    fn cmp(&self, other: &GatedCfg) -> cmp::Ordering {\n+        (self.span.lo.0, self.span.hi.0, self.index)\n+            .cmp(&(other.span.lo.0, other.span.hi.0, other.index))\n+    }\n+}\n+impl PartialOrd for GatedCfg {\n+    fn partial_cmp(&self, other: &GatedCfg) -> Option<cmp::Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl GatedCfg {\n+    pub fn gate(cfg: &ast::MetaItem) -> Option<GatedCfg> {\n+        let name = cfg.name();\n+        GATED_CFGS.iter()\n+                  .position(|info| info.0 == name)\n+                  .map(|idx| {\n+                      GatedCfg {\n+                          span: cfg.span,\n+                          index: idx\n+                      }\n+                  })\n+    }\n+    pub fn check_and_emit(&self, diagnostic: &SpanHandler, features: &Features) {\n+        let (cfg, feature, has_feature) = GATED_CFGS[self.index];\n+        if !has_feature(features) {\n+            let explain = format!(\"`cfg({})` is experimental and subject to change\", cfg);\n+            emit_feature_err(diagnostic, feature, self.span, &explain);\n+        }\n+    }\n+}\n+\n+\n #[derive(PartialEq, Copy, Clone, Debug)]\n pub enum AttributeType {\n     /// Normal, builtin attribute that is consumed\n@@ -373,6 +430,7 @@ pub struct Features {\n     pub static_recursion: bool,\n     pub default_type_parameter_fallback: bool,\n     pub type_macros: bool,\n+    pub cfg_target_feature: bool,\n }\n \n impl Features {\n@@ -401,6 +459,7 @@ impl Features {\n             static_recursion: false,\n             default_type_parameter_fallback: false,\n             type_macros: false,\n+            cfg_target_feature: false,\n         }\n     }\n }\n@@ -920,6 +979,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler,\n         static_recursion: cx.has_feature(\"static_recursion\"),\n         default_type_parameter_fallback: cx.has_feature(\"default_type_parameter_fallback\"),\n         type_macros: cx.has_feature(\"type_macros\"),\n+        cfg_target_feature: cx.has_feature(\"cfg_target_feature\"),\n     }\n }\n "}, {"sha": "26fb287ce35d1bbfc0f878952d756f0568cd7012", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e364f0eb5a51a96932ecd01dd2319eff4bdae2d1/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e364f0eb5a51a96932ecd01dd2319eff4bdae2d1/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=e364f0eb5a51a96932ecd01dd2319eff4bdae2d1", "patch": "@@ -246,11 +246,13 @@ fn generate_test_harness(sess: &ParseSess,\n                          krate: ast::Crate,\n                          cfg: &ast::CrateConfig,\n                          sd: &diagnostic::SpanHandler) -> ast::Crate {\n+    let mut feature_gated_cfgs = vec![];\n     let mut cx: TestCtxt = TestCtxt {\n         sess: sess,\n         span_diagnostic: sd,\n         ext_cx: ExtCtxt::new(sess, cfg.clone(),\n-                             ExpansionConfig::default(\"test\".to_string())),\n+                             ExpansionConfig::default(\"test\".to_string()),\n+                             &mut feature_gated_cfgs),\n         path: Vec::new(),\n         testfns: Vec::new(),\n         reexport_test_harness_main: reexport_test_harness_main,"}, {"sha": "7832e1c7c51520e7978b491b2bad1426d52f65c2", "filename": "src/test/compile-fail/feature-gate-cfg-target-feature.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e364f0eb5a51a96932ecd01dd2319eff4bdae2d1/src%2Ftest%2Fcompile-fail%2Ffeature-gate-cfg-target-feature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e364f0eb5a51a96932ecd01dd2319eff4bdae2d1/src%2Ftest%2Fcompile-fail%2Ffeature-gate-cfg-target-feature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-cfg-target-feature.rs?ref=e364f0eb5a51a96932ecd01dd2319eff4bdae2d1", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[cfg(target_feature = \"x\")] //~ ERROR `cfg(target_feature)` is experimental\n+#[cfg_attr(target_feature = \"x\", x)] //~ ERROR `cfg(target_feature)` is experimental\n+struct Foo(u64, u64);\n+\n+#[cfg(not(any(all(target_feature = \"x\"))))] //~ ERROR `cfg(target_feature)` is experimental\n+fn foo() {}\n+\n+fn main() {\n+    cfg!(target_feature = \"x\");\n+    //~^ ERROR `cfg(target_feature)` is experimental and subject to change\n+}"}, {"sha": "eac38037b4bc1a12e6d0077da7806e474a2c9760", "filename": "src/test/run-fail-fulldeps/qquote.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e364f0eb5a51a96932ecd01dd2319eff4bdae2d1/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e364f0eb5a51a96932ecd01dd2319eff4bdae2d1/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs?ref=e364f0eb5a51a96932ecd01dd2319eff4bdae2d1", "patch": "@@ -23,9 +23,11 @@ use syntax::print::pprust;\n \n fn main() {\n     let ps = syntax::parse::ParseSess::new();\n+    let mut feature_gated_cfgs = vec![];\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n         &ps, vec![],\n-        syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()));\n+        syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n+        &mut feature_gated_cfgs);\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {"}, {"sha": "e272a5fe4f6cd091ddcb66c1e9e06a3fd5b858d4", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e364f0eb5a51a96932ecd01dd2319eff4bdae2d1/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e364f0eb5a51a96932ecd01dd2319eff4bdae2d1/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=e364f0eb5a51a96932ecd01dd2319eff4bdae2d1", "patch": "@@ -19,9 +19,11 @@ use syntax::print::pprust::*;\n \n fn main() {\n     let ps = syntax::parse::ParseSess::new();\n+    let mut feature_gated_cfgs = vec![];\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n         &ps, vec![],\n-        syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()));\n+        syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n+        &mut feature_gated_cfgs);\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {"}]}