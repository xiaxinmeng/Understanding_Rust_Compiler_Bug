{"sha": "4d1ef03c9ed28b6855c3f73535e21dc9cd6f6c5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkMWVmMDNjOWVkMjhiNjg1NWMzZjczNTM1ZTIxZGM5Y2Q2ZjZjNWQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-09-06T14:06:39Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-09-19T20:14:17Z"}, "message": "cleanup promotion const_kind checks\n\nin particular allow a few more promotions for consistency when they were already allowed in other contexts", "tree": {"sha": "b2b439737ab3b547fa5e6a4eba6e474fa10995d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2b439737ab3b547fa5e6a4eba6e474fa10995d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d1ef03c9ed28b6855c3f73535e21dc9cd6f6c5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d1ef03c9ed28b6855c3f73535e21dc9cd6f6c5d", "html_url": "https://github.com/rust-lang/rust/commit/4d1ef03c9ed28b6855c3f73535e21dc9cd6f6c5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d1ef03c9ed28b6855c3f73535e21dc9cd6f6c5d/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59fb88d061544a035f3043b47594b34789204cee", "url": "https://api.github.com/repos/rust-lang/rust/commits/59fb88d061544a035f3043b47594b34789204cee", "html_url": "https://github.com/rust-lang/rust/commit/59fb88d061544a035f3043b47594b34789204cee"}], "stats": {"total": 128, "additions": 83, "deletions": 45}, "files": [{"sha": "a4a6a7b03aba4821ba8293bc0675023b9f16d638", "filename": "compiler/rustc_mir/src/transform/promote_consts.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4d1ef03c9ed28b6855c3f73535e21dc9cd6f6c5d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1ef03c9ed28b6855c3f73535e21dc9cd6f6c5d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=4d1ef03c9ed28b6855c3f73535e21dc9cd6f6c5d", "patch": "@@ -297,6 +297,17 @@ impl std::ops::Deref for Validator<'a, 'tcx> {\n struct Unpromotable;\n \n impl<'tcx> Validator<'_, 'tcx> {\n+    //! Determines if this code could be executed at runtime and thus is subject to codegen.\n+    //! That means even unused constants need to be evaluated.\n+    //!\n+    //! `const_kind` should not be used in this file other than through this method!\n+    fn maybe_runtime(&self) -> bool {\n+        match self.const_kind {\n+            None | Some(hir::ConstContext::ConstFn) => true,\n+            Some(hir::ConstContext::Static(_) | hir::ConstContext::Const) => false,\n+        }\n+    }\n+\n     fn validate_candidate(&self, candidate: Candidate) -> Result<(), Unpromotable> {\n         match candidate {\n             Candidate::Ref(loc) => {\n@@ -365,10 +376,8 @@ impl<'tcx> Validator<'_, 'tcx> {\n                             // mutably without consequences. However, only &mut []\n                             // is allowed right now, and only in functions.\n                             if let ty::Array(_, len) = ty.kind() {\n-                                // FIXME(eddyb) the `self.is_non_const_fn` condition\n-                                // seems unnecessary, given that this is merely a ZST.\n                                 match len.try_eval_usize(self.tcx, self.param_env) {\n-                                    Some(0) if self.const_kind.is_none() => {}\n+                                    Some(0) => {}\n                                     _ => return Err(Unpromotable),\n                                 }\n                             } else {\n@@ -495,9 +504,10 @@ impl<'tcx> Validator<'_, 'tcx> {\n         match place {\n             PlaceRef { local, projection: [] } => self.validate_local(local),\n             PlaceRef { local, projection: [proj_base @ .., elem] } => {\n+                // Validate topmost projection, then recurse.\n                 match *elem {\n                     ProjectionElem::Deref => {\n-                        let mut not_promotable = true;\n+                        let mut promotable = false;\n                         // This is a special treatment for cases like *&STATIC where STATIC is a\n                         // global static variable.\n                         // This pattern is generated only when global static variables are directly\n@@ -512,6 +522,9 @@ impl<'tcx> Validator<'_, 'tcx> {\n                             }) = def_stmt\n                             {\n                                 if let Some(did) = c.check_static_ptr(self.tcx) {\n+                                    // Evaluating a promoted may not read statics except if it got\n+                                    // promoted from a static (this is a CTFE check). So we\n+                                    // can only promoted static accesses inside statics.\n                                     if let Some(hir::ConstContext::Static(..)) = self.const_kind {\n                                         // The `is_empty` predicate is introduced to exclude the case\n                                         // where the projection operations are [ .field, * ].\n@@ -524,13 +537,13 @@ impl<'tcx> Validator<'_, 'tcx> {\n                                         if proj_base.is_empty()\n                                             && !self.tcx.is_thread_local_static(did)\n                                         {\n-                                            not_promotable = false;\n+                                            promotable = true;\n                                         }\n                                     }\n                                 }\n                             }\n                         }\n-                        if not_promotable {\n+                        if !promotable {\n                             return Err(Unpromotable);\n                         }\n                     }\n@@ -545,7 +558,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     }\n \n                     ProjectionElem::Field(..) => {\n-                        if self.const_kind.is_none() {\n+                        if self.maybe_runtime() {\n                             let base_ty =\n                                 Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n                             if let Some(def) = base_ty.ty_adt_def() {\n@@ -571,13 +584,6 @@ impl<'tcx> Validator<'_, 'tcx> {\n             // `validate_rvalue` upon access.\n             Operand::Constant(c) => {\n                 if let Some(def_id) = c.check_static_ptr(self.tcx) {\n-                    // Only allow statics (not consts) to refer to other statics.\n-                    // FIXME(eddyb) does this matter at all for promotion?\n-                    let is_static = matches!(self.const_kind, Some(hir::ConstContext::Static(_)));\n-                    if !is_static {\n-                        return Err(Unpromotable);\n-                    }\n-\n                     let is_thread_local = self.tcx.is_thread_local_static(def_id);\n                     if is_thread_local {\n                         return Err(Unpromotable);\n@@ -591,20 +597,20 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n     fn validate_rvalue(&self, rvalue: &Rvalue<'tcx>) -> Result<(), Unpromotable> {\n         match *rvalue {\n-            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if self.const_kind.is_none() => {\n+            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if self.maybe_runtime() => {\n                 let operand_ty = operand.ty(self.body, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n                 match (cast_in, cast_out) {\n                     (CastTy::Ptr(_) | CastTy::FnPtr, CastTy::Int(_)) => {\n-                        // in normal functions, mark such casts as not promotable\n+                        // ptr-to-int casts are not promotable\n                         return Err(Unpromotable);\n                     }\n                     _ => {}\n                 }\n             }\n \n-            Rvalue::BinaryOp(op, ref lhs, _) if self.const_kind.is_none() => {\n+            Rvalue::BinaryOp(op, ref lhs, _) if self.maybe_runtime() => {\n                 if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind() {\n                     assert!(\n                         op == BinOp::Eq\n@@ -623,6 +629,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n             Rvalue::NullaryOp(NullOp::Box, _) => return Err(Unpromotable),\n \n+            // FIXME(RalfJung): the rest is *implicitly considered promotable*... that seems dangerous.\n             _ => {}\n         }\n \n@@ -644,8 +651,8 @@ impl<'tcx> Validator<'_, 'tcx> {\n             }\n \n             Rvalue::AddressOf(_, place) => {\n-                // Raw reborrows can come from reference to pointer coercions,\n-                // so are allowed.\n+                // We accept `&raw *`, i.e., raw reborrows -- creating a raw pointer is\n+                // no problem, only using it is.\n                 if let [proj_base @ .., ProjectionElem::Deref] = place.projection.as_ref() {\n                     let base_ty = Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind() {\n@@ -666,10 +673,8 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     // mutably without consequences. However, only &mut []\n                     // is allowed right now, and only in functions.\n                     if let ty::Array(_, len) = ty.kind() {\n-                        // FIXME(eddyb): We only return `Unpromotable` for `&mut []` inside a\n-                        // const context which seems unnecessary given that this is merely a ZST.\n                         match len.try_eval_usize(self.tcx, self.param_env) {\n-                            Some(0) if self.const_kind.is_none() => {}\n+                            Some(0) => {}\n                             _ => return Err(Unpromotable),\n                         }\n                     } else {\n@@ -734,14 +739,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n     ) -> Result<(), Unpromotable> {\n         let fn_ty = callee.ty(self.body, self.tcx);\n \n-        // `const` and `static` use the explicit rules for promotion regardless of the `Candidate`,\n-        // meaning calls to `const fn` can be promoted.\n-        let context_uses_explicit_promotion_rules = matches!(\n-            self.const_kind,\n-            Some(hir::ConstContext::Static(_) | hir::ConstContext::Const)\n-        );\n-\n-        if !self.explicit && !context_uses_explicit_promotion_rules {\n+        if !self.explicit && self.maybe_runtime() {\n             if let ty::FnDef(def_id, _) = *fn_ty.kind() {\n                 // Never promote runtime `const fn` calls of\n                 // functions without `#[rustc_promotable]`."}, {"sha": "fb57c8bb93458d535413e86fd016733665bd306b", "filename": "src/test/ui/consts/promote-no-mut.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59fb88d061544a035f3043b47594b34789204cee/src%2Ftest%2Fui%2Fconsts%2Fpromote-no-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fb88d061544a035f3043b47594b34789204cee/src%2Ftest%2Fui%2Fconsts%2Fpromote-no-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fpromote-no-mut.rs?ref=59fb88d061544a035f3043b47594b34789204cee", "patch": "@@ -1,10 +0,0 @@\n-// ignore-tidy-linelength\n-// We do not promote mutable references.\n-static mut TEST1: Option<&mut [i32]> = Some(&mut [1, 2, 3]); //~ ERROR temporary value dropped while borrowed\n-\n-static mut TEST2: &'static mut [i32] = {\n-    let x = &mut [1,2,3]; //~ ERROR temporary value dropped while borrowed\n-    x\n-};\n-\n-fn main() {}"}, {"sha": "8daac7583773451b9ae8d2340cefc4fea249a4f7", "filename": "src/test/ui/consts/promote-not.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4d1ef03c9ed28b6855c3f73535e21dc9cd6f6c5d/src%2Ftest%2Fui%2Fconsts%2Fpromote-not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1ef03c9ed28b6855c3f73535e21dc9cd6f6c5d/src%2Ftest%2Fui%2Fconsts%2Fpromote-not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fpromote-not.rs?ref=4d1ef03c9ed28b6855c3f73535e21dc9cd6f6c5d", "patch": "@@ -0,0 +1,30 @@\n+// ignore-tidy-linelength\n+// Test various things that we do not want to promote.\n+#![allow(unconditional_panic, const_err)]\n+#![feature(const_fn, const_fn_union)]\n+\n+// We do not promote mutable references.\n+static mut TEST1: Option<&mut [i32]> = Some(&mut [1, 2, 3]); //~ ERROR temporary value dropped while borrowed\n+\n+static mut TEST2: &'static mut [i32] = {\n+    let x = &mut [1,2,3]; //~ ERROR temporary value dropped while borrowed\n+    x\n+};\n+\n+// We do not promote fn calls in `fn`, including `const fn`.\n+pub const fn promote_cal(b: bool) -> i32 {\n+    const fn foo() { [()][42] }\n+\n+    if b {\n+        let _x: &'static () = &foo(); //~ ERROR temporary value dropped while borrowed\n+    }\n+    13\n+}\n+\n+// We do not promote union field accesses in `fn.\n+union U { x: i32, y: i32 }\n+pub const fn promote_union() {\n+    let _x: &'static i32 = &unsafe { U { x: 0 }.x }; //~ ERROR temporary value dropped while borrowed\n+}\n+\n+fn main() {}"}, {"sha": "efe921b601104a60b17d2167b1e7b37b8f70dfbd", "filename": "src/test/ui/consts/promote-not.stderr", "status": "renamed", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4d1ef03c9ed28b6855c3f73535e21dc9cd6f6c5d/src%2Ftest%2Fui%2Fconsts%2Fpromote-not.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d1ef03c9ed28b6855c3f73535e21dc9cd6f6c5d/src%2Ftest%2Fui%2Fconsts%2Fpromote-not.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fpromote-not.stderr?ref=4d1ef03c9ed28b6855c3f73535e21dc9cd6f6c5d", "patch": "@@ -1,5 +1,5 @@\n error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/promote-no-mut.rs:3:50\n+  --> $DIR/promote-not.rs:7:50\n    |\n LL | static mut TEST1: Option<&mut [i32]> = Some(&mut [1, 2, 3]);\n    |                                        ----------^^^^^^^^^-\n@@ -9,7 +9,7 @@ LL | static mut TEST1: Option<&mut [i32]> = Some(&mut [1, 2, 3]);\n    |                                        using this value as a static requires that borrow lasts for `'static`\n \n error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/promote-no-mut.rs:6:18\n+  --> $DIR/promote-not.rs:10:18\n    |\n LL |     let x = &mut [1,2,3];\n    |                  ^^^^^^^ creates a temporary which is freed while still in use\n@@ -18,6 +18,26 @@ LL |     x\n LL | };\n    | - temporary value is freed at the end of this statement\n \n-error: aborting due to 2 previous errors\n+error[E0716]: temporary value dropped while borrowed\n+  --> $DIR/promote-not.rs:19:32\n+   |\n+LL |         let _x: &'static () = &foo();\n+   |                 -----------    ^^^^^ creates a temporary which is freed while still in use\n+   |                 |\n+   |                 type annotation requires that borrow lasts for `'static`\n+LL |     }\n+   |     - temporary value is freed at the end of this statement\n+\n+error[E0716]: temporary value dropped while borrowed\n+  --> $DIR/promote-not.rs:27:29\n+   |\n+LL |     let _x: &'static i32 = &unsafe { U { x: 0 }.x };\n+   |             ------------    ^^^^^^^^^^^^^^^^^^^^^^^ creates a temporary which is freed while still in use\n+   |             |\n+   |             type annotation requires that borrow lasts for `'static`\n+LL | }\n+   | - temporary value is freed at the end of this statement\n+\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0716`.", "previous_filename": "src/test/ui/consts/promote-no-mut.stderr"}, {"sha": "5f84030a9e96b4d0f68afaca43b23b5bd353dca2", "filename": "src/test/ui/consts/promotion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d1ef03c9ed28b6855c3f73535e21dc9cd6f6c5d/src%2Ftest%2Fui%2Fconsts%2Fpromotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1ef03c9ed28b6855c3f73535e21dc9cd6f6c5d/src%2Ftest%2Fui%2Fconsts%2Fpromotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fpromotion.rs?ref=4d1ef03c9ed28b6855c3f73535e21dc9cd6f6c5d", "patch": "@@ -1,4 +1,4 @@\n-// run-pass\n+// check-pass\n \n // compile-flags: -O\n "}, {"sha": "b9eff469177e6e62acc0a2c98cfc7c270b850c42", "filename": "src/test/ui/statics/static-promotion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d1ef03c9ed28b6855c3f73535e21dc9cd6f6c5d/src%2Ftest%2Fui%2Fstatics%2Fstatic-promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1ef03c9ed28b6855c3f73535e21dc9cd6f6c5d/src%2Ftest%2Fui%2Fstatics%2Fstatic-promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatics%2Fstatic-promotion.rs?ref=4d1ef03c9ed28b6855c3f73535e21dc9cd6f6c5d", "patch": "@@ -1,4 +1,4 @@\n-// check-pass\n+// run-pass\n \n // Use of global static variables in literal values should be allowed for\n // promotion."}]}