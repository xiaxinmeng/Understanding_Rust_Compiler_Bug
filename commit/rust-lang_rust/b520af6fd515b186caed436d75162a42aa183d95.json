{"sha": "b520af6fd515b186caed436d75162a42aa183d95", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1MjBhZjZmZDUxNWIxODZjYWVkNDM2ZDc1MTYyYTQyYWExODNkOTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-03T18:36:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-03T18:36:59Z"}, "message": "Auto merge of #65646 - Amanieu:foreign-exceptions, r=nikomatsakis\n\nAllow foreign exceptions to unwind through Rust code and Rust panics to unwind through FFI\n\nThis PR fixes interactions between Rust panics and foreign (mainly C++) exceptions.\n\nC++ exceptions (and other FFI exceptions) can now safely unwind through Rust code:\n- The FFI function causing the unwind must be marked with `#[unwind(allowed)]`. If this is not the case then LLVM may optimize landing pads away with the assumption that they are unreachable.\n- Drop code will be executed as the exception unwinds through the stack, as with a Rust panic.\n- `catch_unwind` will *not* catch the exception, instead the exception will silently continue unwinding past it.\n\nRust panics can now safely unwind through C++ code:\n- C++ destructors will be called as the stack unwinds.\n- The Rust panic can only be caught with `catch (...)`, after which it can be either rethrown or discarded.\n- C++ cannot name the type of the Rust exception object used for unwinding, which means that it can't be caught explicitly or have its contents inspected.\n\nTests have been added to ensure all of the above works correctly.\n\nSome notes about non-C++ exceptions:\n- `pthread_cancel` and `pthread_exit` use unwinding on glibc. This has the same behavior as a C++ exception: destructors are run but it cannot be caught by `catch_unwind`.\n- `longjmp` on Windows is implemented using unwinding. Destructors are run on MSVC, but not on MinGW. In both cases the unwind cannot be caught by `catch_unwind`.\n- As with C++ exceptions, you need to mark the relevant FFI functions with `#[unwind(allowed)]`, otherwise LLVM will optimize out the destructors since they seem unreachable.\n\nI haven't updated any of the documentation, so officially unwinding through FFI is still UB. However this is a step towards making it well-defined.\n\nFixes #65441\n\ncc @gnzlbg\nr? @alexcrichton", "tree": {"sha": "6d7b585e1cfdde034a31707c546323a07a9837e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d7b585e1cfdde034a31707c546323a07a9837e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b520af6fd515b186caed436d75162a42aa183d95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b520af6fd515b186caed436d75162a42aa183d95", "html_url": "https://github.com/rust-lang/rust/commit/b520af6fd515b186caed436d75162a42aa183d95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b520af6fd515b186caed436d75162a42aa183d95/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b43a6822597061dc18cbdde1769d9815e718d7bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/b43a6822597061dc18cbdde1769d9815e718d7bb", "html_url": "https://github.com/rust-lang/rust/commit/b43a6822597061dc18cbdde1769d9815e718d7bb"}, {"sha": "f223e0d6274a8626b9d9428582384955e7f24b15", "url": "https://api.github.com/repos/rust-lang/rust/commits/f223e0d6274a8626b9d9428582384955e7f24b15", "html_url": "https://github.com/rust-lang/rust/commit/f223e0d6274a8626b9d9428582384955e7f24b15"}], "stats": {"total": 908, "additions": 480, "deletions": 428}, "files": [{"sha": "d4ad65e84b7b4935a8a88b919eab8ad20f50f09d", "filename": "src/doc/unstable-book/src/language-features/lang-items.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b520af6fd515b186caed436d75162a42aa183d95/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/b520af6fd515b186caed436d75162a42aa183d95/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md?ref=b520af6fd515b186caed436d75162a42aa183d95", "patch": "@@ -249,11 +249,11 @@ the source code.\n - Runtime\n   - `start`: `libstd/rt.rs`\n   - `eh_personality`: `libpanic_unwind/emcc.rs` (EMCC)\n-  - `eh_personality`: `libpanic_unwind/seh64_gnu.rs` (SEH64 GNU)\n+  - `eh_personality`: `libpanic_unwind/gcc.rs` (GNU)\n   - `eh_personality`: `libpanic_unwind/seh.rs` (SEH)\n-  - `eh_unwind_resume`: `libpanic_unwind/seh64_gnu.rs` (SEH64 GNU)\n   - `eh_unwind_resume`: `libpanic_unwind/gcc.rs` (GCC)\n-  - `msvc_try_filter`: `libpanic_unwind/seh.rs` (SEH)\n+  - `eh_catch_typeinfo`: `libpanic_unwind/seh.rs` (SEH)\n+  - `eh_catch_typeinfo`: `libpanic_unwind/emcc.rs` (EMCC)\n   - `panic`: `libcore/panicking.rs`\n   - `panic_bounds_check`: `libcore/panicking.rs`\n   - `panic_impl`: `libcore/panicking.rs`"}, {"sha": "1e9e7e4b8359ce393f72d5e7ac32e61708e4d93c", "filename": "src/libpanic_unwind/dwarf/eh.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b520af6fd515b186caed436d75162a42aa183d95/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b520af6fd515b186caed436d75162a42aa183d95/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs?ref=b520af6fd515b186caed436d75162a42aa183d95", "patch": "@@ -51,7 +51,7 @@ pub enum EHAction {\n \n pub const USING_SJLJ_EXCEPTIONS: bool = cfg!(all(target_os = \"ios\", target_arch = \"arm\"));\n \n-pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext<'_>)\n+pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext<'_>, foreign_exception: bool)\n     -> Result<EHAction, ()>\n {\n     if lsda.is_null() {\n@@ -96,7 +96,7 @@ pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext<'_>)\n                     return Ok(EHAction::None)\n                 } else {\n                     let lpad = lpad_base + cs_lpad;\n-                    return Ok(interpret_cs_action(cs_action, lpad))\n+                    return Ok(interpret_cs_action(cs_action, lpad, foreign_exception))\n                 }\n             }\n         }\n@@ -121,16 +121,23 @@ pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext<'_>)\n                 // Can never have null landing pad for sjlj -- that would have\n                 // been indicated by a -1 call site index.\n                 let lpad = (cs_lpad + 1) as usize;\n-                return Ok(interpret_cs_action(cs_action, lpad))\n+                return Ok(interpret_cs_action(cs_action, lpad, foreign_exception))\n             }\n         }\n     }\n }\n \n-fn interpret_cs_action(cs_action: u64, lpad: usize) -> EHAction {\n+fn interpret_cs_action(cs_action: u64, lpad: usize, foreign_exception: bool) -> EHAction {\n     if cs_action == 0 {\n+        // If cs_action is 0 then this is a cleanup (Drop::drop). We run these\n+        // for both Rust panics and foriegn exceptions.\n         EHAction::Cleanup(lpad)\n+    } else if foreign_exception {\n+        // catch_unwind should not catch foreign exceptions, only Rust panics.\n+        // Instead just continue unwinding.\n+        EHAction::None\n     } else {\n+        // Stop unwinding Rust panics at catch_unwind.\n         EHAction::Catch(lpad)\n     }\n }"}, {"sha": "3d0d5a4151eed925b1716bf0e8a9a22b86f559a1", "filename": "src/libpanic_unwind/emcc.rs", "status": "modified", "additions": 42, "deletions": 10, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b520af6fd515b186caed436d75162a42aa183d95/src%2Flibpanic_unwind%2Femcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b520af6fd515b186caed436d75162a42aa183d95/src%2Flibpanic_unwind%2Femcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Femcc.rs?ref=b520af6fd515b186caed436d75162a42aa183d95", "patch": "@@ -15,14 +15,48 @@ use alloc::boxed::Box;\n use libc::{self, c_int};\n use unwind as uw;\n \n+// This matches the layout of std::type_info in C++\n+#[repr(C)]\n+struct TypeInfo {\n+    vtable: *const usize,\n+    name: *const u8,\n+}\n+unsafe impl Sync for TypeInfo {}\n+\n+extern \"C\" {\n+    // The leading `\\x01` byte here is actually a magical signal to LLVM to\n+    // *not* apply any other mangling like prefixing with a `_` character.\n+    //\n+    // This symbol is the vtable used by C++'s `std::type_info`. Objects of type\n+    // `std::type_info`, type descriptors, have a pointer to this table. Type\n+    // descriptors are referenced by the C++ EH structures defined above and\n+    // that we construct below.\n+    //\n+    // Note that the real size is larger than 3 usize, but we only need our\n+    // vtable to point to the third element.\n+    #[link_name = \"\\x01_ZTVN10__cxxabiv117__class_type_infoE\"]\n+    static CLASS_TYPE_INFO_VTABLE: [usize; 3];\n+}\n+\n+// std::type_info for a rust_panic class\n+#[lang = \"eh_catch_typeinfo\"]\n+static EXCEPTION_TYPE_INFO: TypeInfo = TypeInfo {\n+    // Normally we would use .as_ptr().add(2) but this doesn't work in a const context.\n+    vtable: unsafe { &CLASS_TYPE_INFO_VTABLE[2] },\n+    // This intentionally doesn't use the normal name mangling scheme because\n+    // we don't want C++ to be able to produce or catch Rust panics.\n+    name: b\"rust_panic\\0\".as_ptr(),\n+};\n+\n pub fn payload() -> *mut u8 {\n     ptr::null_mut()\n }\n \n pub unsafe fn cleanup(ptr: *mut u8) -> Box<dyn Any + Send> {\n     assert!(!ptr.is_null());\n-    let ex = ptr::read(ptr as *mut _);\n-    __cxa_free_exception(ptr as *mut _);\n+    let adjusted_ptr = __cxa_begin_catch(ptr as *mut libc::c_void);\n+    let ex = ptr::read(adjusted_ptr as *mut _);\n+    __cxa_end_catch();\n     ex\n }\n \n@@ -32,11 +66,8 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     if exception == ptr::null_mut() {\n         return uw::_URC_FATAL_PHASE1_ERROR as u32;\n     }\n-    let exception = exception as *mut Box<dyn Any + Send>;\n-    ptr::write(exception, data);\n-    __cxa_throw(exception as *mut _, ptr::null_mut(), ptr::null_mut());\n-\n-    unreachable!()\n+    ptr::write(exception as *mut _, data);\n+    __cxa_throw(exception as *mut _, &EXCEPTION_TYPE_INFO, ptr::null_mut());\n }\n \n #[lang = \"eh_personality\"]\n@@ -52,10 +83,11 @@ unsafe extern \"C\" fn rust_eh_personality(version: c_int,\n \n extern \"C\" {\n     fn __cxa_allocate_exception(thrown_size: libc::size_t) -> *mut libc::c_void;\n-    fn __cxa_free_exception(thrown_exception: *mut libc::c_void);\n+    fn __cxa_begin_catch(thrown_exception: *mut libc::c_void) -> *mut libc::c_void;\n+    fn __cxa_end_catch();\n     fn __cxa_throw(thrown_exception: *mut libc::c_void,\n-                   tinfo: *mut libc::c_void,\n-                   dest: *mut libc::c_void);\n+                   tinfo: *const TypeInfo,\n+                   dest: *mut libc::c_void) -> !;\n     fn __gxx_personality_v0(version: c_int,\n                             actions: uw::_Unwind_Action,\n                             exception_class: uw::_Unwind_Exception_Class,"}, {"sha": "4f572fe21b30baeb36ded4232fba107fdc38465e", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 160, "deletions": 117, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/b520af6fd515b186caed436d75162a42aa183d95/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b520af6fd515b186caed436d75162a42aa183d95/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=b520af6fd515b186caed436d75162a42aa183d95", "patch": "@@ -133,133 +133,176 @@ const UNWIND_DATA_REG: (i32, i32) = (0, 1); // R0, R1\n // https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/libsupc++/eh_personality.cc\n // https://github.com/gcc-mirror/gcc/blob/trunk/libgcc/unwind-c.c\n \n-// The personality routine for most of our targets, except ARM, which has a slightly different ABI\n-// (however, iOS goes here as it uses SjLj unwinding).  Also, the 64-bit Windows implementation\n-// lives in seh64_gnu.rs\n-#[cfg(all(any(target_os = \"ios\", target_os = \"netbsd\", not(target_arch = \"arm\"))))]\n-#[lang = \"eh_personality\"]\n-#[no_mangle]\n-#[allow(unused)]\n-unsafe extern \"C\" fn rust_eh_personality(version: c_int,\n-                                         actions: uw::_Unwind_Action,\n-                                         exception_class: uw::_Unwind_Exception_Class,\n-                                         exception_object: *mut uw::_Unwind_Exception,\n-                                         context: *mut uw::_Unwind_Context)\n-                                         -> uw::_Unwind_Reason_Code {\n-    if version != 1 {\n-        return uw::_URC_FATAL_PHASE1_ERROR;\n-    }\n-    let eh_action = match find_eh_action(context) {\n-        Ok(action) => action,\n-        Err(_) => return uw::_URC_FATAL_PHASE1_ERROR,\n-    };\n-    if actions as i32 & uw::_UA_SEARCH_PHASE as i32 != 0 {\n-        match eh_action {\n-            EHAction::None |\n-            EHAction::Cleanup(_) => uw::_URC_CONTINUE_UNWIND,\n-            EHAction::Catch(_) => uw::_URC_HANDLER_FOUND,\n-            EHAction::Terminate => uw::_URC_FATAL_PHASE1_ERROR,\n-        }\n-    } else {\n-        match eh_action {\n-            EHAction::None => uw::_URC_CONTINUE_UNWIND,\n-            EHAction::Cleanup(lpad) |\n-            EHAction::Catch(lpad) => {\n-                uw::_Unwind_SetGR(context, UNWIND_DATA_REG.0, exception_object as uintptr_t);\n-                uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n-                uw::_Unwind_SetIP(context, lpad);\n-                uw::_URC_INSTALL_CONTEXT\n-            }\n-            EHAction::Terminate => uw::_URC_FATAL_PHASE2_ERROR,\n-        }\n-    }\n-}\n+cfg_if::cfg_if! {\n+    if #[cfg(all(target_arch = \"arm\", not(target_os = \"ios\"), not(target_os = \"netbsd\")))] {\n+        // ARM EHABI personality routine.\n+        // http://infocenter.arm.com/help/topic/com.arm.doc.ihi0038b/IHI0038B_ehabi.pdf\n+        //\n+        // iOS uses the default routine instead since it uses SjLj unwinding.\n+        #[lang = \"eh_personality\"]\n+        #[no_mangle]\n+        unsafe extern \"C\" fn rust_eh_personality(state: uw::_Unwind_State,\n+                                                 exception_object: *mut uw::_Unwind_Exception,\n+                                                 context: *mut uw::_Unwind_Context)\n+                                                 -> uw::_Unwind_Reason_Code {\n+            let state = state as c_int;\n+            let action = state & uw::_US_ACTION_MASK as c_int;\n+            let search_phase = if action == uw::_US_VIRTUAL_UNWIND_FRAME as c_int {\n+                // Backtraces on ARM will call the personality routine with\n+                // state == _US_VIRTUAL_UNWIND_FRAME | _US_FORCE_UNWIND. In those cases\n+                // we want to continue unwinding the stack, otherwise all our backtraces\n+                // would end at __rust_try\n+                if state & uw::_US_FORCE_UNWIND as c_int != 0 {\n+                    return continue_unwind(exception_object, context);\n+                }\n+                true\n+            } else if action == uw::_US_UNWIND_FRAME_STARTING as c_int {\n+                false\n+            } else if action == uw::_US_UNWIND_FRAME_RESUME as c_int {\n+                return continue_unwind(exception_object, context);\n+            } else {\n+                return uw::_URC_FAILURE;\n+            };\n \n-// ARM EHABI personality routine.\n-// http://infocenter.arm.com/help/topic/com.arm.doc.ihi0038b/IHI0038B_ehabi.pdf\n-#[cfg(all(target_arch = \"arm\", not(target_os = \"ios\"), not(target_os = \"netbsd\")))]\n-#[lang = \"eh_personality\"]\n-#[no_mangle]\n-unsafe extern \"C\" fn rust_eh_personality(state: uw::_Unwind_State,\n-                                         exception_object: *mut uw::_Unwind_Exception,\n-                                         context: *mut uw::_Unwind_Context)\n-                                         -> uw::_Unwind_Reason_Code {\n-    let state = state as c_int;\n-    let action = state & uw::_US_ACTION_MASK as c_int;\n-    let search_phase = if action == uw::_US_VIRTUAL_UNWIND_FRAME as c_int {\n-        // Backtraces on ARM will call the personality routine with\n-        // state == _US_VIRTUAL_UNWIND_FRAME | _US_FORCE_UNWIND. In those cases\n-        // we want to continue unwinding the stack, otherwise all our backtraces\n-        // would end at __rust_try\n-        if state & uw::_US_FORCE_UNWIND as c_int != 0 {\n-            return continue_unwind(exception_object, context);\n-        }\n-        true\n-    } else if action == uw::_US_UNWIND_FRAME_STARTING as c_int {\n-        false\n-    } else if action == uw::_US_UNWIND_FRAME_RESUME as c_int {\n-        return continue_unwind(exception_object, context);\n-    } else {\n-        return uw::_URC_FAILURE;\n-    };\n+            // The DWARF unwinder assumes that _Unwind_Context holds things like the function\n+            // and LSDA pointers, however ARM EHABI places them into the exception object.\n+            // To preserve signatures of functions like _Unwind_GetLanguageSpecificData(), which\n+            // take only the context pointer, GCC personality routines stash a pointer to\n+            // exception_object in the context, using location reserved for ARM's\n+            // \"scratch register\" (r12).\n+            uw::_Unwind_SetGR(context,\n+                              uw::UNWIND_POINTER_REG,\n+                              exception_object as uw::_Unwind_Ptr);\n+            // ...A more principled approach would be to provide the full definition of ARM's\n+            // _Unwind_Context in our libunwind bindings and fetch the required data from there\n+            // directly, bypassing DWARF compatibility functions.\n \n-    // The DWARF unwinder assumes that _Unwind_Context holds things like the function\n-    // and LSDA pointers, however ARM EHABI places them into the exception object.\n-    // To preserve signatures of functions like _Unwind_GetLanguageSpecificData(), which\n-    // take only the context pointer, GCC personality routines stash a pointer to exception_object\n-    // in the context, using location reserved for ARM's \"scratch register\" (r12).\n-    uw::_Unwind_SetGR(context,\n-                      uw::UNWIND_POINTER_REG,\n-                      exception_object as uw::_Unwind_Ptr);\n-    // ...A more principled approach would be to provide the full definition of ARM's\n-    // _Unwind_Context in our libunwind bindings and fetch the required data from there directly,\n-    // bypassing DWARF compatibility functions.\n+            let exception_class = (*exception_object).exception_class;\n+            let foreign_exception = exception_class != rust_exception_class();\n+            let eh_action = match find_eh_action(context, foreign_exception) {\n+                Ok(action) => action,\n+                Err(_) => return uw::_URC_FAILURE,\n+            };\n+            if search_phase {\n+                match eh_action {\n+                    EHAction::None |\n+                    EHAction::Cleanup(_) => return continue_unwind(exception_object, context),\n+                    EHAction::Catch(_) => return uw::_URC_HANDLER_FOUND,\n+                    EHAction::Terminate => return uw::_URC_FAILURE,\n+                }\n+            } else {\n+                match eh_action {\n+                    EHAction::None => return continue_unwind(exception_object, context),\n+                    EHAction::Cleanup(lpad) |\n+                    EHAction::Catch(lpad) => {\n+                        uw::_Unwind_SetGR(context, UNWIND_DATA_REG.0,\n+                                          exception_object as uintptr_t);\n+                        uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n+                        uw::_Unwind_SetIP(context, lpad);\n+                        return uw::_URC_INSTALL_CONTEXT;\n+                    }\n+                    EHAction::Terminate => return uw::_URC_FAILURE,\n+                }\n+            }\n \n-    let eh_action = match find_eh_action(context) {\n-        Ok(action) => action,\n-        Err(_) => return uw::_URC_FAILURE,\n-    };\n-    if search_phase {\n-        match eh_action {\n-            EHAction::None |\n-            EHAction::Cleanup(_) => return continue_unwind(exception_object, context),\n-            EHAction::Catch(_) => return uw::_URC_HANDLER_FOUND,\n-            EHAction::Terminate => return uw::_URC_FAILURE,\n+            // On ARM EHABI the personality routine is responsible for actually\n+            // unwinding a single stack frame before returning (ARM EHABI Sec. 6.1).\n+            unsafe fn continue_unwind(exception_object: *mut uw::_Unwind_Exception,\n+                                      context: *mut uw::_Unwind_Context)\n+                                      -> uw::_Unwind_Reason_Code {\n+                if __gnu_unwind_frame(exception_object, context) == uw::_URC_NO_REASON {\n+                    uw::_URC_CONTINUE_UNWIND\n+                } else {\n+                    uw::_URC_FAILURE\n+                }\n+            }\n+            // defined in libgcc\n+            extern \"C\" {\n+                fn __gnu_unwind_frame(exception_object: *mut uw::_Unwind_Exception,\n+                                      context: *mut uw::_Unwind_Context)\n+                                      -> uw::_Unwind_Reason_Code;\n+            }\n         }\n     } else {\n-        match eh_action {\n-            EHAction::None => return continue_unwind(exception_object, context),\n-            EHAction::Cleanup(lpad) |\n-            EHAction::Catch(lpad) => {\n-                uw::_Unwind_SetGR(context, UNWIND_DATA_REG.0, exception_object as uintptr_t);\n-                uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n-                uw::_Unwind_SetIP(context, lpad);\n-                return uw::_URC_INSTALL_CONTEXT;\n+        // Default personality routine, which is used directly on most targets\n+        // and indirectly on Windows x86_64 via SEH.\n+        unsafe extern \"C\" fn rust_eh_personality_impl(version: c_int,\n+                                                      actions: uw::_Unwind_Action,\n+                                                      exception_class: uw::_Unwind_Exception_Class,\n+                                                      exception_object: *mut uw::_Unwind_Exception,\n+                                                      context: *mut uw::_Unwind_Context)\n+                                                      -> uw::_Unwind_Reason_Code {\n+            if version != 1 {\n+                return uw::_URC_FATAL_PHASE1_ERROR;\n+            }\n+            let foreign_exception = exception_class != rust_exception_class();\n+            let eh_action = match find_eh_action(context, foreign_exception) {\n+                Ok(action) => action,\n+                Err(_) => return uw::_URC_FATAL_PHASE1_ERROR,\n+            };\n+            if actions as i32 & uw::_UA_SEARCH_PHASE as i32 != 0 {\n+                match eh_action {\n+                    EHAction::None |\n+                    EHAction::Cleanup(_) => uw::_URC_CONTINUE_UNWIND,\n+                    EHAction::Catch(_) => uw::_URC_HANDLER_FOUND,\n+                    EHAction::Terminate => uw::_URC_FATAL_PHASE1_ERROR,\n+                }\n+            } else {\n+                match eh_action {\n+                    EHAction::None => uw::_URC_CONTINUE_UNWIND,\n+                    EHAction::Cleanup(lpad) |\n+                    EHAction::Catch(lpad) => {\n+                        uw::_Unwind_SetGR(context, UNWIND_DATA_REG.0,\n+                            exception_object as uintptr_t);\n+                        uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n+                        uw::_Unwind_SetIP(context, lpad);\n+                        uw::_URC_INSTALL_CONTEXT\n+                    }\n+                    EHAction::Terminate => uw::_URC_FATAL_PHASE2_ERROR,\n+                }\n             }\n-            EHAction::Terminate => return uw::_URC_FAILURE,\n         }\n-    }\n \n-    // On ARM EHABI the personality routine is responsible for actually\n-    // unwinding a single stack frame before returning (ARM EHABI Sec. 6.1).\n-    unsafe fn continue_unwind(exception_object: *mut uw::_Unwind_Exception,\n-                              context: *mut uw::_Unwind_Context)\n-                              -> uw::_Unwind_Reason_Code {\n-        if __gnu_unwind_frame(exception_object, context) == uw::_URC_NO_REASON {\n-            uw::_URC_CONTINUE_UNWIND\n-        } else {\n-            uw::_URC_FAILURE\n+        cfg_if::cfg_if! {\n+            if #[cfg(all(windows, target_arch = \"x86_64\", target_env = \"gnu\"))] {\n+                // On x86_64 MinGW targets, the unwinding mechanism is SEH however the unwind\n+                // handler data (aka LSDA) uses GCC-compatible encoding.\n+                #[lang = \"eh_personality\"]\n+                #[no_mangle]\n+                #[allow(nonstandard_style)]\n+                unsafe extern \"C\" fn rust_eh_personality(exceptionRecord: *mut uw::EXCEPTION_RECORD,\n+                        establisherFrame: uw::LPVOID,\n+                        contextRecord: *mut uw::CONTEXT,\n+                        dispatcherContext: *mut uw::DISPATCHER_CONTEXT)\n+                        -> uw::EXCEPTION_DISPOSITION {\n+                    uw::_GCC_specific_handler(exceptionRecord,\n+                                             establisherFrame,\n+                                             contextRecord,\n+                                             dispatcherContext,\n+                                             rust_eh_personality_impl)\n+                }\n+            } else {\n+                // The personality routine for most of our targets.\n+                #[lang = \"eh_personality\"]\n+                #[no_mangle]\n+                unsafe extern \"C\" fn rust_eh_personality(version: c_int,\n+                        actions: uw::_Unwind_Action,\n+                        exception_class: uw::_Unwind_Exception_Class,\n+                        exception_object: *mut uw::_Unwind_Exception,\n+                        context: *mut uw::_Unwind_Context)\n+                        -> uw::_Unwind_Reason_Code {\n+                    rust_eh_personality_impl(version,\n+                                             actions,\n+                                             exception_class,\n+                                             exception_object,\n+                                             context)\n+                }\n+            }\n         }\n     }\n-    // defined in libgcc\n-    extern \"C\" {\n-        fn __gnu_unwind_frame(exception_object: *mut uw::_Unwind_Exception,\n-                              context: *mut uw::_Unwind_Context)\n-                              -> uw::_Unwind_Reason_Code;\n-    }\n }\n \n-unsafe fn find_eh_action(context: *mut uw::_Unwind_Context)\n+unsafe fn find_eh_action(context: *mut uw::_Unwind_Context, foreign_exception: bool)\n     -> Result<EHAction, ()>\n {\n     let lsda = uw::_Unwind_GetLanguageSpecificData(context) as *const u8;\n@@ -273,11 +316,11 @@ unsafe fn find_eh_action(context: *mut uw::_Unwind_Context)\n         get_text_start: &|| uw::_Unwind_GetTextRelBase(context),\n         get_data_start: &|| uw::_Unwind_GetDataRelBase(context),\n     };\n-    eh::find_eh_action(lsda, &eh_context)\n+    eh::find_eh_action(lsda, &eh_context, foreign_exception)\n }\n \n // See docs in the `unwind` module.\n-#[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\"))]\n+#[cfg(all(target_os=\"windows\", any(target_arch = \"x86\", target_arch = \"x86_64\"), target_env=\"gnu\"))]\n #[lang = \"eh_unwind_resume\"]\n #[unwind(allowed)]\n unsafe extern \"C\" fn rust_eh_unwind_resume(panic_ctx: *mut u8) -> ! {"}, {"sha": "d2a0ef7b1dde1cce1e738918638c68266305e0cd", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b520af6fd515b186caed436d75162a42aa183d95/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b520af6fd515b186caed436d75162a42aa183d95/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=b520af6fd515b186caed436d75162a42aa183d95", "patch": "@@ -5,9 +5,8 @@\n //! essentially gets categorized into three buckets currently:\n //!\n //! 1. MSVC targets use SEH in the `seh.rs` file.\n-//! 2. The 64-bit MinGW target half-uses SEH and half-use gcc-like information\n-//!    in the `seh64_gnu.rs` module.\n-//! 3. All other targets use libunwind/libgcc in the `gcc/mod.rs` module.\n+//! 2. Emscripten uses C++ exceptions in the `emcc.rs` file.\n+//! 3. All other targets use libunwind/libgcc in the `gcc.rs` file.\n //!\n //! More documentation about each implementation can be found in the respective\n //! module.\n@@ -52,9 +51,6 @@ cfg_if::cfg_if! {\n     } else if #[cfg(target_env = \"msvc\")] {\n         #[path = \"seh.rs\"]\n         mod imp;\n-    } else if #[cfg(all(windows, target_arch = \"x86_64\", target_env = \"gnu\"))] {\n-        #[path = \"seh64_gnu.rs\"]\n-        mod imp;\n     } else {\n         // Rust runtime's startup objects depend on these symbols, so make them public.\n         #[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\"))]\n@@ -65,7 +61,6 @@ cfg_if::cfg_if! {\n }\n \n mod dwarf;\n-mod windows;\n \n // Entry point for catching an exception, implemented using the `try` intrinsic\n // in the compiler."}, {"sha": "621813a2fee9550bccf5e8124ac7d5c9f04514c4", "filename": "src/libpanic_unwind/seh.rs", "status": "modified", "additions": 49, "deletions": 51, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/b520af6fd515b186caed436d75162a42aa183d95/src%2Flibpanic_unwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b520af6fd515b186caed436d75162a42aa183d95/src%2Flibpanic_unwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh.rs?ref=b520af6fd515b186caed436d75162a42aa183d95", "patch": "@@ -51,9 +51,7 @@ use alloc::boxed::Box;\n use core::any::Any;\n use core::mem;\n use core::raw;\n-\n-use crate::windows as c;\n-use libc::{c_int, c_uint};\n+use libc::{c_int, c_uint, c_void};\n \n // First up, a whole bunch of type definitions. There's a few platform-specific\n // oddities here, and a lot that's just blatantly copied from LLVM. The purpose\n@@ -76,18 +74,19 @@ use libc::{c_int, c_uint};\n // sort of operation. For example, if you compile this C++ code on MSVC and emit\n // the LLVM IR:\n //\n-//      #include <stdin.h>\n+//      #include <stdint.h>\n+//\n+//      struct rust_panic {\n+//          uint64_t x[2];\n+//      }\n //\n //      void foo() {\n-//          uint64_t a[2] = {0, 1};\n+//          rust_panic a = {0, 1};\n //          throw a;\n //      }\n //\n // That's essentially what we're trying to emulate. Most of the constant values\n-// below were just copied from LLVM, I'm at least not 100% sure what's going on\n-// everywhere. For example the `.PA_K\\0` and `.PEA_K\\0` strings below (stuck in\n-// the names of a few of these) I'm not actually sure what they do, but it seems\n-// to mirror what LLVM does!\n+// below were just copied from LLVM,\n //\n // In any case, these structures are all constructed in a similar manner, and\n // it's just somewhat verbose for us.\n@@ -98,10 +97,9 @@ use libc::{c_int, c_uint};\n #[macro_use]\n mod imp {\n     pub type ptr_t = *mut u8;\n-    pub const OFFSET: i32 = 4;\n \n+    #[cfg(bootstrap)]\n     pub const NAME1: [u8; 7] = [b'.', b'P', b'A', b'_', b'K', 0, 0];\n-    pub const NAME2: [u8; 7] = [b'.', b'P', b'A', b'X', 0, 0, 0];\n \n     macro_rules! ptr {\n         (0) => (core::ptr::null_mut());\n@@ -113,10 +111,9 @@ mod imp {\n #[macro_use]\n mod imp {\n     pub type ptr_t = u32;\n-    pub const OFFSET: i32 = 8;\n \n+    #[cfg(bootstrap)]\n     pub const NAME1: [u8; 7] = [b'.', b'P', b'E', b'A', b'_', b'K', 0];\n-    pub const NAME2: [u8; 7] = [b'.', b'P', b'E', b'A', b'X', 0, 0];\n \n     extern \"C\" {\n         pub static __ImageBase: u8;\n@@ -141,7 +138,7 @@ pub struct _ThrowInfo {\n #[repr(C)]\n pub struct _CatchableTypeArray {\n     pub nCatchableTypes: c_int,\n-    pub arrayOfCatchableTypes: [imp::ptr_t; 2],\n+    pub arrayOfCatchableTypes: [imp::ptr_t; 1],\n }\n \n #[repr(C)]\n@@ -164,9 +161,19 @@ pub struct _PMD {\n pub struct _TypeDescriptor {\n     pub pVFTable: *const u8,\n     pub spare: *mut u8,\n+    #[cfg(bootstrap)]\n     pub name: [u8; 7],\n+    #[cfg(not(bootstrap))]\n+    pub name: [u8; 11],\n }\n \n+// Note that we intentionally ignore name mangling rules here: we don't want C++\n+// to be able to catch Rust panics by simply declaring a `struct rust_panic`.\n+#[cfg(bootstrap)]\n+use imp::NAME1 as TYPE_NAME;\n+#[cfg(not(bootstrap))]\n+const TYPE_NAME: [u8; 11] = *b\"rust_panic\\0\";\n+\n static mut THROW_INFO: _ThrowInfo = _ThrowInfo {\n     attributes: 0,\n     pnfnUnwind: ptr!(0),\n@@ -175,31 +182,22 @@ static mut THROW_INFO: _ThrowInfo = _ThrowInfo {\n };\n \n static mut CATCHABLE_TYPE_ARRAY: _CatchableTypeArray = _CatchableTypeArray {\n-    nCatchableTypes: 2,\n-    arrayOfCatchableTypes: [ptr!(0), ptr!(0)],\n+    nCatchableTypes: 1,\n+    arrayOfCatchableTypes: [ptr!(0)],\n };\n \n-static mut CATCHABLE_TYPE1: _CatchableType = _CatchableType {\n-    properties: 1,\n+static mut CATCHABLE_TYPE: _CatchableType = _CatchableType {\n+    properties: 0,\n     pType: ptr!(0),\n     thisDisplacement: _PMD {\n         mdisp: 0,\n         pdisp: -1,\n         vdisp: 0,\n     },\n-    sizeOrOffset: imp::OFFSET,\n-    copy_function: ptr!(0),\n-};\n-\n-static mut CATCHABLE_TYPE2: _CatchableType = _CatchableType {\n-    properties: 1,\n-    pType: ptr!(0),\n-    thisDisplacement: _PMD {\n-        mdisp: 0,\n-        pdisp: -1,\n-        vdisp: 0,\n-    },\n-    sizeOrOffset: imp::OFFSET,\n+    #[cfg(bootstrap)]\n+    sizeOrOffset: mem::size_of::<*mut u64>() as c_int,\n+    #[cfg(not(bootstrap))]\n+    sizeOrOffset: mem::size_of::<[u64; 2]>() as c_int,\n     copy_function: ptr!(0),\n };\n \n@@ -215,22 +213,17 @@ extern \"C\" {\n     static TYPE_INFO_VTABLE: *const u8;\n }\n \n-// We use #[lang = \"msvc_try_filter\"] here as this is the type descriptor which\n+// We use #[lang = \"eh_catch_typeinfo\"] here as this is the type descriptor which\n // we'll use in LLVM's `catchpad` instruction which ends up also being passed as\n // an argument to the C++ personality function.\n //\n // Again, I'm not entirely sure what this is describing, it just seems to work.\n-#[cfg_attr(not(test), lang = \"msvc_try_filter\")]\n-static mut TYPE_DESCRIPTOR1: _TypeDescriptor = _TypeDescriptor {\n+#[cfg_attr(bootstrap, lang = \"msvc_try_filter\")]\n+#[cfg_attr(not(any(test, bootstrap)), lang = \"eh_catch_typeinfo\")]\n+static mut TYPE_DESCRIPTOR: _TypeDescriptor = _TypeDescriptor {\n     pVFTable: unsafe { &TYPE_INFO_VTABLE } as *const _ as *const _,\n     spare: core::ptr::null_mut(),\n-    name: imp::NAME1,\n-};\n-\n-static mut TYPE_DESCRIPTOR2: _TypeDescriptor = _TypeDescriptor {\n-    pVFTable: unsafe { &TYPE_INFO_VTABLE } as *const _ as *const _,\n-    spare: core::ptr::null_mut(),\n-    name: imp::NAME2,\n+    name: TYPE_NAME,\n };\n \n pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n@@ -246,6 +239,11 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     let ptrs = mem::transmute::<_, raw::TraitObject>(data);\n     let mut ptrs = [ptrs.data as u64, ptrs.vtable as u64];\n     let mut ptrs_ptr = ptrs.as_mut_ptr();\n+    let throw_ptr = if cfg!(bootstrap) {\n+        &mut ptrs_ptr as *mut _ as *mut _\n+    } else {\n+        ptrs_ptr as *mut _\n+    };\n \n     // This... may seems surprising, and justifiably so. On 32-bit MSVC the\n     // pointers between these structure are just that, pointers. On 64-bit MSVC,\n@@ -270,17 +268,17 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     atomic_store(&mut THROW_INFO.pCatchableTypeArray as *mut _ as *mut u32,\n                  ptr!(&CATCHABLE_TYPE_ARRAY as *const _) as u32);\n     atomic_store(&mut CATCHABLE_TYPE_ARRAY.arrayOfCatchableTypes[0] as *mut _ as *mut u32,\n-                 ptr!(&CATCHABLE_TYPE1 as *const _) as u32);\n-    atomic_store(&mut CATCHABLE_TYPE_ARRAY.arrayOfCatchableTypes[1] as *mut _ as *mut u32,\n-                 ptr!(&CATCHABLE_TYPE2 as *const _) as u32);\n-    atomic_store(&mut CATCHABLE_TYPE1.pType as *mut _ as *mut u32,\n-                 ptr!(&TYPE_DESCRIPTOR1 as *const _) as u32);\n-    atomic_store(&mut CATCHABLE_TYPE2.pType as *mut _ as *mut u32,\n-                 ptr!(&TYPE_DESCRIPTOR2 as *const _) as u32);\n+                 ptr!(&CATCHABLE_TYPE as *const _) as u32);\n+    atomic_store(&mut CATCHABLE_TYPE.pType as *mut _ as *mut u32,\n+                 ptr!(&TYPE_DESCRIPTOR as *const _) as u32);\n+\n+    extern \"system\" {\n+        #[unwind(allowed)]\n+        pub fn _CxxThrowException(pExceptionObject: *mut c_void, pThrowInfo: *mut u8) -> !;\n+    }\n \n-    c::_CxxThrowException(&mut ptrs_ptr as *mut _ as *mut _,\n-                          &mut THROW_INFO as *mut _ as *mut _);\n-    u32::max_value()\n+    _CxxThrowException(throw_ptr,\n+                       &mut THROW_INFO as *mut _ as *mut _);\n }\n \n pub fn payload() -> [u64; 2] {"}, {"sha": "16b699a44379979f7eda4031937e072e7b8d4d8c", "filename": "src/libpanic_unwind/seh64_gnu.rs", "status": "removed", "additions": 0, "deletions": 127, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/b43a6822597061dc18cbdde1769d9815e718d7bb/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b43a6822597061dc18cbdde1769d9815e718d7bb/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh64_gnu.rs?ref=b43a6822597061dc18cbdde1769d9815e718d7bb", "patch": "@@ -1,127 +0,0 @@\n-//! Unwinding implementation of top of native Win64 SEH,\n-//! however the unwind handler data (aka LSDA) uses GCC-compatible encoding.\n-\n-#![allow(nonstandard_style)]\n-#![allow(private_no_mangle_fns)]\n-\n-use alloc::boxed::Box;\n-\n-use core::any::Any;\n-use core::intrinsics;\n-use core::ptr;\n-use crate::dwarf::eh::{EHContext, EHAction, find_eh_action};\n-use crate::windows as c;\n-\n-// Define our exception codes:\n-// according to http://msdn.microsoft.com/en-us/library/het71c37(v=VS.80).aspx,\n-//    [31:30] = 3 (error), 2 (warning), 1 (info), 0 (success)\n-//    [29]    = 1 (user-defined)\n-//    [28]    = 0 (reserved)\n-// we define bits:\n-//    [24:27] = type\n-//    [0:23]  = magic\n-const ETYPE: c::DWORD = 0b1110_u32 << 28;\n-const MAGIC: c::DWORD = 0x525354; // \"RST\"\n-\n-const RUST_PANIC: c::DWORD = ETYPE | (1 << 24) | MAGIC;\n-\n-#[repr(C)]\n-struct PanicData {\n-    data: Box<dyn Any + Send>,\n-}\n-\n-pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n-    let panic_ctx = Box::new(PanicData { data });\n-    let params = [Box::into_raw(panic_ctx) as c::ULONG_PTR];\n-    c::RaiseException(RUST_PANIC,\n-                      c::EXCEPTION_NONCONTINUABLE,\n-                      params.len() as c::DWORD,\n-                      &params as *const c::ULONG_PTR);\n-    u32::max_value()\n-}\n-\n-pub fn payload() -> *mut u8 {\n-    ptr::null_mut()\n-}\n-\n-pub unsafe fn cleanup(ptr: *mut u8) -> Box<dyn Any + Send> {\n-    let panic_ctx = Box::from_raw(ptr as *mut PanicData);\n-    panic_ctx.data\n-}\n-\n-// SEH doesn't support resuming unwinds after calling a landing pad like\n-// libunwind does. For this reason, MSVC compiler outlines landing pads into\n-// separate functions that can be called directly from the personality function\n-// but are nevertheless able to find and modify stack frame of the \"parent\"\n-// function.\n-//\n-// Since this cannot be done with libdwarf-style landing pads,\n-// rust_eh_personality instead catches RUST_PANICs, runs the landing pad, then\n-// reraises the exception.\n-//\n-// Note that it makes certain assumptions about the exception:\n-//\n-// 1. That RUST_PANIC is non-continuable, so no lower stack frame may choose to\n-//    resume execution.\n-// 2. That the first parameter of the exception is a pointer to an extra data\n-//    area (PanicData).\n-// Since these assumptions do not generally hold true for foreign exceptions\n-// (system faults, C++ exceptions, etc), we make no attempt to invoke our\n-// landing pads (and, thus, destructors!) for anything other than RUST_PANICs.\n-// This is considered acceptable, because the behavior of throwing exceptions\n-// through a C ABI boundary is undefined.\n-\n-#[lang = \"eh_personality\"]\n-#[cfg(not(test))]\n-unsafe extern \"C\" fn rust_eh_personality(exceptionRecord: *mut c::EXCEPTION_RECORD,\n-                                         establisherFrame: c::LPVOID,\n-                                         contextRecord: *mut c::CONTEXT,\n-                                         dispatcherContext: *mut c::DISPATCHER_CONTEXT)\n-                                         -> c::EXCEPTION_DISPOSITION {\n-    let er = &*exceptionRecord;\n-    let dc = &*dispatcherContext;\n-\n-    if er.ExceptionFlags & c::EXCEPTION_UNWIND == 0 {\n-        // we are in the dispatch phase\n-        if er.ExceptionCode == RUST_PANIC {\n-            if let Some(lpad) = find_landing_pad(dc) {\n-                c::RtlUnwindEx(establisherFrame,\n-                               lpad as c::LPVOID,\n-                               exceptionRecord,\n-                               er.ExceptionInformation[0] as c::LPVOID, // pointer to PanicData\n-                               contextRecord,\n-                               dc.HistoryTable);\n-            }\n-        }\n-    }\n-    c::ExceptionContinueSearch\n-}\n-\n-#[lang = \"eh_unwind_resume\"]\n-#[unwind(allowed)]\n-unsafe extern \"C\" fn rust_eh_unwind_resume(panic_ctx: c::LPVOID) -> ! {\n-    let params = [panic_ctx as c::ULONG_PTR];\n-    c::RaiseException(RUST_PANIC,\n-                      c::EXCEPTION_NONCONTINUABLE,\n-                      params.len() as c::DWORD,\n-                      &params as *const c::ULONG_PTR);\n-    intrinsics::abort();\n-}\n-\n-unsafe fn find_landing_pad(dc: &c::DISPATCHER_CONTEXT) -> Option<usize> {\n-    let eh_ctx = EHContext {\n-        // The return address points 1 byte past the call instruction,\n-        // which could be in the next IP range in LSDA range table.\n-        ip: dc.ControlPc as usize - 1,\n-        func_start: dc.ImageBase as usize + (*dc.FunctionEntry).BeginAddress as usize,\n-        get_text_start: &|| dc.ImageBase as usize,\n-        get_data_start: &|| unimplemented!(),\n-    };\n-    match find_eh_action(dc.HandlerData, &eh_ctx) {\n-        Err(_) |\n-        Ok(EHAction::None) => None,\n-        Ok(EHAction::Cleanup(lpad)) |\n-        Ok(EHAction::Catch(lpad)) => Some(lpad),\n-        Ok(EHAction::Terminate) => intrinsics::abort(),\n-    }\n-}"}, {"sha": "3257a9d25a51ab9f325fa7af08c9abafaf38df18", "filename": "src/libpanic_unwind/windows.rs", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/b43a6822597061dc18cbdde1769d9815e718d7bb/src%2Flibpanic_unwind%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b43a6822597061dc18cbdde1769d9815e718d7bb/src%2Flibpanic_unwind%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fwindows.rs?ref=b43a6822597061dc18cbdde1769d9815e718d7bb", "patch": "@@ -1,86 +0,0 @@\n-#![allow(nonstandard_style)]\n-#![allow(dead_code)]\n-#![cfg(windows)]\n-\n-use libc::{c_long, c_ulong, c_void};\n-\n-pub type DWORD = c_ulong;\n-pub type LONG = c_long;\n-pub type ULONG_PTR = usize;\n-pub type LPVOID = *mut c_void;\n-\n-pub const EXCEPTION_MAXIMUM_PARAMETERS: usize = 15;\n-pub const EXCEPTION_NONCONTINUABLE: DWORD = 0x1;   // Noncontinuable exception\n-pub const EXCEPTION_UNWINDING: DWORD = 0x2;        // Unwind is in progress\n-pub const EXCEPTION_EXIT_UNWIND: DWORD = 0x4;      // Exit unwind is in progress\n-pub const EXCEPTION_TARGET_UNWIND: DWORD = 0x20;   // Target unwind in progress\n-pub const EXCEPTION_COLLIDED_UNWIND: DWORD = 0x40; // Collided exception handler call\n-pub const EXCEPTION_UNWIND: DWORD = EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND |\n-                                    EXCEPTION_TARGET_UNWIND |\n-                                    EXCEPTION_COLLIDED_UNWIND;\n-\n-#[repr(C)]\n-pub struct EXCEPTION_RECORD {\n-    pub ExceptionCode: DWORD,\n-    pub ExceptionFlags: DWORD,\n-    pub ExceptionRecord: *mut EXCEPTION_RECORD,\n-    pub ExceptionAddress: LPVOID,\n-    pub NumberParameters: DWORD,\n-    pub ExceptionInformation: [LPVOID; EXCEPTION_MAXIMUM_PARAMETERS],\n-}\n-\n-#[repr(C)]\n-pub struct EXCEPTION_POINTERS {\n-    pub ExceptionRecord: *mut EXCEPTION_RECORD,\n-    pub ContextRecord: *mut CONTEXT,\n-}\n-\n-pub enum UNWIND_HISTORY_TABLE {}\n-\n-#[repr(C)]\n-pub struct RUNTIME_FUNCTION {\n-    pub BeginAddress: DWORD,\n-    pub EndAddress: DWORD,\n-    pub UnwindData: DWORD,\n-}\n-\n-pub enum CONTEXT {}\n-\n-#[repr(C)]\n-pub struct DISPATCHER_CONTEXT {\n-    pub ControlPc: LPVOID,\n-    pub ImageBase: LPVOID,\n-    pub FunctionEntry: *const RUNTIME_FUNCTION,\n-    pub EstablisherFrame: LPVOID,\n-    pub TargetIp: LPVOID,\n-    pub ContextRecord: *const CONTEXT,\n-    pub LanguageHandler: LPVOID,\n-    pub HandlerData: *const u8,\n-    pub HistoryTable: *const UNWIND_HISTORY_TABLE,\n-}\n-\n-#[repr(C)]\n-pub enum EXCEPTION_DISPOSITION {\n-    ExceptionContinueExecution,\n-    ExceptionContinueSearch,\n-    ExceptionNestedException,\n-    ExceptionCollidedUnwind,\n-}\n-pub use self::EXCEPTION_DISPOSITION::*;\n-\n-extern \"system\" {\n-    #[unwind(allowed)]\n-    pub fn RaiseException(dwExceptionCode: DWORD,\n-                          dwExceptionFlags: DWORD,\n-                          nNumberOfArguments: DWORD,\n-                          lpArguments: *const ULONG_PTR);\n-    #[unwind(allowed)]\n-    pub fn RtlUnwindEx(TargetFrame: LPVOID,\n-                       TargetIp: LPVOID,\n-                       ExceptionRecord: *const EXCEPTION_RECORD,\n-                       ReturnValue: LPVOID,\n-                       OriginalContext: *const CONTEXT,\n-                       HistoryTable: *const UNWIND_HISTORY_TABLE);\n-    #[unwind(allowed)]\n-    pub fn _CxxThrowException(pExceptionObject: *mut c_void, pThrowInfo: *mut u8);\n-}"}, {"sha": "41f02a876f5977cf13d44d5b684362a8952cb544", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b520af6fd515b186caed436d75162a42aa183d95/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b520af6fd515b186caed436d75162a42aa183d95/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=b520af6fd515b186caed436d75162a42aa183d95", "patch": "@@ -385,7 +385,7 @@ language_item_table! {\n \n     EhPersonalityLangItem,       \"eh_personality\",     eh_personality,          Target::Fn;\n     EhUnwindResumeLangItem,      \"eh_unwind_resume\",   eh_unwind_resume,        Target::Fn;\n-    MSVCTryFilterLangItem,       \"msvc_try_filter\",    msvc_try_filter,         Target::Static;\n+    EhCatchTypeinfoLangItem,     \"eh_catch_typeinfo\",  eh_catch_typeinfo,       Target::Static;\n \n     OwnedBoxLangItem,            \"owned_box\",          owned_box,               Target::Struct;\n "}, {"sha": "02424956b9aa50474652c8e763d0a346c9232e53", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b520af6fd515b186caed436d75162a42aa183d95/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b520af6fd515b186caed436d75162a42aa183d95/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=b520af6fd515b186caed436d75162a42aa183d95", "patch": "@@ -849,7 +849,7 @@ fn codegen_msvc_try(\n         // We're generating an IR snippet that looks like:\n         //\n         //   declare i32 @rust_try(%func, %data, %ptr) {\n-        //      %slot = alloca i64*\n+        //      %slot = alloca [2 x i64]\n         //      invoke %func(%data) to label %normal unwind label %catchswitch\n         //\n         //   normal:\n@@ -873,44 +873,41 @@ fn codegen_msvc_try(\n         //\n         //      #include <stdint.h>\n         //\n+        //      struct rust_panic {\n+        //          uint64_t x[2];\n+        //      }\n+        //\n         //      int bar(void (*foo)(void), uint64_t *ret) {\n         //          try {\n         //              foo();\n         //              return 0;\n-        //          } catch(uint64_t a[2]) {\n-        //              ret[0] = a[0];\n-        //              ret[1] = a[1];\n+        //          } catch(rust_panic a) {\n+        //              ret[0] = a.x[0];\n+        //              ret[1] = a.x[1];\n         //              return 1;\n         //          }\n         //      }\n         //\n         // More information can be found in libstd's seh.rs implementation.\n-        let i64p = bx.type_ptr_to(bx.type_i64());\n-        let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n-        let slot = bx.alloca(i64p, ptr_align);\n+        let i64_2 = bx.type_array(bx.type_i64(), 2);\n+        let i64_align = bx.tcx().data_layout.i64_align.abi;\n+        let slot = bx.alloca(i64_2, i64_align);\n         bx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(), None);\n \n         normal.ret(bx.const_i32(0));\n \n         let cs = catchswitch.catch_switch(None, None, 1);\n         catchswitch.add_handler(cs, catchpad.llbb());\n \n-        let tydesc = match bx.tcx().lang_items().msvc_try_filter() {\n+        let tydesc = match bx.tcx().lang_items().eh_catch_typeinfo() {\n             Some(did) => bx.get_static(did),\n-            None => bug!(\"msvc_try_filter not defined\"),\n+            None => bug!(\"eh_catch_typeinfo not defined, but needed for SEH unwinding\"),\n         };\n         let funclet = catchpad.catch_pad(cs, &[tydesc, bx.const_i32(0), slot]);\n-        let addr = catchpad.load(slot, ptr_align);\n \n-        let i64_align = bx.tcx().data_layout.i64_align.abi;\n-        let arg1 = catchpad.load(addr, i64_align);\n-        let val1 = bx.const_i32(1);\n-        let gep1 = catchpad.inbounds_gep(addr, &[val1]);\n-        let arg2 = catchpad.load(gep1, i64_align);\n-        let local_ptr = catchpad.bitcast(local_ptr, i64p);\n-        let gep2 = catchpad.inbounds_gep(local_ptr, &[val1]);\n-        catchpad.store(arg1, local_ptr, i64_align);\n-        catchpad.store(arg2, gep2, i64_align);\n+        let payload = catchpad.load(slot, i64_align);\n+        let local_ptr = catchpad.bitcast(local_ptr, bx.type_ptr_to(i64_2));\n+        catchpad.store(payload, local_ptr, i64_align);\n         catchpad.catch_ret(&funclet, caught.llbb());\n \n         caught.ret(bx.const_i32(1));\n@@ -978,7 +975,14 @@ fn codegen_gnu_try(\n         // rust_try ignores the selector.\n         let lpad_ty = bx.type_struct(&[bx.type_i8p(), bx.type_i32()], false);\n         let vals = catch.landing_pad(lpad_ty, bx.eh_personality(), 1);\n-        catch.add_clause(vals, bx.const_null(bx.type_i8p()));\n+        let tydesc = match bx.tcx().lang_items().eh_catch_typeinfo() {\n+            Some(tydesc) => {\n+                let tydesc = bx.get_static(tydesc);\n+                bx.bitcast(tydesc, bx.type_i8p())\n+            }\n+            None => bx.const_null(bx.type_i8p()),\n+        };\n+        catch.add_clause(vals, tydesc);\n         let ptr = catch.extract_value(vals, 0);\n         let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n         let bitcast = catch.bitcast(local_ptr, bx.type_ptr_to(bx.type_i8p()));"}, {"sha": "0b39503c0d03453b08da3bf2a5f0420b6433747b", "filename": "src/libunwind/libunwind.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b520af6fd515b186caed436d75162a42aa183d95/src%2Flibunwind%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b520af6fd515b186caed436d75162a42aa183d95/src%2Flibunwind%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Flibunwind.rs?ref=b520af6fd515b186caed436d75162a42aa183d95", "patch": "@@ -244,3 +244,30 @@ if #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))] {\n     }\n }\n } // cfg_if!\n+\n+cfg_if::cfg_if! {\n+if #[cfg(all(windows, target_arch = \"x86_64\", target_env = \"gnu\"))] {\n+    // We declare these as opaque types. This is fine since you just need to\n+    // pass them to _GCC_specific_handler and forget about them.\n+    pub enum EXCEPTION_RECORD {}\n+    pub type LPVOID = *mut c_void;\n+    pub enum CONTEXT {}\n+    pub enum DISPATCHER_CONTEXT {}\n+    pub type EXCEPTION_DISPOSITION = c_int;\n+    type PersonalityFn = unsafe extern \"C\" fn(version: c_int,\n+                                              actions: _Unwind_Action,\n+                                              exception_class: _Unwind_Exception_Class,\n+                                              exception_object: *mut _Unwind_Exception,\n+                                              context: *mut _Unwind_Context)\n+                                              -> _Unwind_Reason_Code;\n+\n+    extern \"C\" {\n+        pub fn _GCC_specific_handler(exceptionRecord: *mut EXCEPTION_RECORD,\n+                                establisherFrame: LPVOID,\n+                                contextRecord: *mut CONTEXT,\n+                                dispatcherContext: *mut DISPATCHER_CONTEXT,\n+                                personality: PersonalityFn)\n+                                -> EXCEPTION_DISPOSITION;\n+    }\n+}\n+} // cfg_if!"}, {"sha": "7eba52f3c24e87914d446f97d63542d74bc30668", "filename": "src/test/run-make-fulldeps/foreign-exceptions/Makefile", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b520af6fd515b186caed436d75162a42aa183d95/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/b520af6fd515b186caed436d75162a42aa183d95/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2FMakefile?ref=b520af6fd515b186caed436d75162a42aa183d95", "patch": "@@ -0,0 +1,10 @@\n+-include ../tools.mk\n+\n+all: foo\n+\t$(call RUN,foo)\n+\n+foo: foo.rs $(call NATIVE_STATICLIB,foo)\n+\t$(RUSTC) $< -lfoo $(EXTRARSCXXFLAGS)\n+\n+$(TMPDIR)/libfoo.o: foo.cpp\n+\t$(call COMPILE_OBJ_CXX,$@,$<)"}, {"sha": "b0fd65f88e7de9588ca35a263ecd4d5810fb2b8d", "filename": "src/test/run-make-fulldeps/foreign-exceptions/foo.cpp", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b520af6fd515b186caed436d75162a42aa183d95/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2Ffoo.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b520af6fd515b186caed436d75162a42aa183d95/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2Ffoo.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2Ffoo.cpp?ref=b520af6fd515b186caed436d75162a42aa183d95", "patch": "@@ -0,0 +1,60 @@\n+#include <assert.h>\n+#include <stddef.h>\n+#include <stdio.h>\n+\n+void println(const char* s) {\n+    puts(s);\n+    fflush(stdout);\n+}\n+\n+struct exception {};\n+struct rust_panic {};\n+\n+struct drop_check {\n+    bool* ok;\n+    ~drop_check() {\n+        println(\"~drop_check\");\n+\n+        if (ok)\n+            *ok = true;\n+    }\n+};\n+\n+extern \"C\" {\n+    void rust_catch_callback(void (*cb)(), bool* rust_ok);\n+\n+    static void callback() {\n+        println(\"throwing C++ exception\");\n+        throw exception();\n+    }\n+\n+    void throw_cxx_exception() {\n+        bool rust_ok = false;\n+        try {\n+            rust_catch_callback(callback, &rust_ok);\n+            assert(false && \"unreachable\");\n+        } catch (exception e) {\n+            println(\"caught C++ exception\");\n+            assert(rust_ok);\n+            return;\n+        }\n+        assert(false && \"did not catch thrown C++ exception\");\n+    }\n+\n+    void cxx_catch_callback(void (*cb)(), bool* cxx_ok) {\n+        drop_check x;\n+        x.ok = NULL;\n+        try {\n+            cb();\n+        } catch (rust_panic e) {\n+            assert(false && \"shouldn't be able to catch a rust panic\");\n+        } catch (...) {\n+            println(\"caught foreign exception in catch (...)\");\n+            // Foreign exceptions are caught by catch (...). We only set the ok\n+            // flag if we successfully caught the panic. The destructor of\n+            // drop_check will then set the flag to true if it is executed.\n+            x.ok = cxx_ok;\n+            throw;\n+        }\n+    }\n+}"}, {"sha": "399c78f8d2d021cb7cdb80bc82400361666f7b6d", "filename": "src/test/run-make-fulldeps/foreign-exceptions/foo.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b520af6fd515b186caed436d75162a42aa183d95/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b520af6fd515b186caed436d75162a42aa183d95/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2Ffoo.rs?ref=b520af6fd515b186caed436d75162a42aa183d95", "patch": "@@ -0,0 +1,66 @@\n+// Tests that C++ exceptions can unwind through Rust code, run destructors and\n+// are ignored by catch_unwind. Also tests that Rust panics can unwind through\n+// C++ code.\n+\n+// For linking libstdc++ on MinGW\n+#![cfg_attr(all(windows, target_env = \"gnu\"), feature(static_nobundle))]\n+\n+#![feature(unwind_attributes)]\n+\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n+\n+struct DropCheck<'a>(&'a mut bool);\n+impl<'a> Drop for DropCheck<'a> {\n+    fn drop(&mut self) {\n+        println!(\"DropCheck::drop\");\n+        *self.0 = true;\n+    }\n+}\n+\n+extern \"C\" {\n+    fn throw_cxx_exception();\n+\n+    #[unwind(allowed)]\n+    fn cxx_catch_callback(cb: extern \"C\" fn(), ok: *mut bool);\n+}\n+\n+#[no_mangle]\n+#[unwind(allowed)]\n+extern \"C\" fn rust_catch_callback(cb: extern \"C\" fn(), rust_ok: &mut bool) {\n+    let _caught_unwind = catch_unwind(AssertUnwindSafe(|| {\n+        let _drop = DropCheck(rust_ok);\n+        cb();\n+        unreachable!(\"should have unwound instead of returned\");\n+    }));\n+    unreachable!(\"catch_unwind should not have caught foreign exception\");\n+}\n+\n+fn throw_rust_panic() {\n+    #[unwind(allowed)]\n+    extern \"C\" fn callback() {\n+        println!(\"throwing rust panic\");\n+        panic!(1234i32);\n+    }\n+\n+    let mut dropped = false;\n+    let mut cxx_ok = false;\n+    let caught_unwind = catch_unwind(AssertUnwindSafe(|| {\n+        let _drop = DropCheck(&mut dropped);\n+        unsafe {\n+            cxx_catch_callback(callback, &mut cxx_ok);\n+        }\n+        unreachable!(\"should have unwound instead of returned\");\n+    }));\n+    println!(\"caught rust panic\");\n+    assert!(dropped);\n+    assert!(caught_unwind.is_err());\n+    let panic_obj = caught_unwind.unwrap_err();\n+    let panic_int = *panic_obj.downcast_ref::<i32>().unwrap();\n+    assert_eq!(panic_int, 1234);\n+    assert!(cxx_ok);\n+}\n+\n+fn main() {\n+    unsafe { throw_cxx_exception() };\n+    throw_rust_panic();\n+}"}, {"sha": "4f93d97636e6004df6f86731d5937e2e7ed0dbfb", "filename": "src/test/run-make-fulldeps/issue-36710/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b520af6fd515b186caed436d75162a42aa183d95/src%2Ftest%2Frun-make-fulldeps%2Fissue-36710%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/b520af6fd515b186caed436d75162a42aa183d95/src%2Ftest%2Frun-make-fulldeps%2Fissue-36710%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-36710%2FMakefile?ref=b520af6fd515b186caed436d75162a42aa183d95", "patch": "@@ -6,7 +6,7 @@ all: foo\n \t$(call RUN,foo)\n \n foo: foo.rs $(call NATIVE_STATICLIB,foo)\n-\t$(RUSTC) $< -lfoo $(EXTRACXXFLAGS)\n+\t$(RUSTC) $< -lfoo $(EXTRARSCXXFLAGS)\n \n $(TMPDIR)/libfoo.o: foo.cpp\n \t$(call COMPILE_OBJ_CXX,$@,$<)"}, {"sha": "061f07c32434016b3686361998f8331171904e19", "filename": "src/test/run-make-fulldeps/issue-36710/foo.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b520af6fd515b186caed436d75162a42aa183d95/src%2Ftest%2Frun-make-fulldeps%2Fissue-36710%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b520af6fd515b186caed436d75162a42aa183d95/src%2Ftest%2Frun-make-fulldeps%2Fissue-36710%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-36710%2Ffoo.rs?ref=b520af6fd515b186caed436d75162a42aa183d95", "patch": "@@ -1,5 +1,8 @@\n // Tests that linking to C++ code with global destructors works.\n \n+// For linking libstdc++ on MinGW\n+#![cfg_attr(all(windows, target_env = \"gnu\"), feature(static_nobundle))]\n+\n extern { fn get() -> u32; }\n \n fn main() {"}, {"sha": "20a5e8e64225dcbec2b5c5544ff21d37e50d3bf5", "filename": "src/test/run-make-fulldeps/tools.mk", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b520af6fd515b186caed436d75162a42aa183d95/src%2Ftest%2Frun-make-fulldeps%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b520af6fd515b186caed436d75162a42aa183d95/src%2Ftest%2Frun-make-fulldeps%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Ftools.mk?ref=b520af6fd515b186caed436d75162a42aa183d95", "patch": "@@ -60,7 +60,7 @@ endif\n \n ifdef IS_MSVC\n COMPILE_OBJ = $(CC) -c -Fo:`cygpath -w $(1)` $(2)\n-COMPILE_OBJ_CXX = $(CXX) -c -Fo:`cygpath -w $(1)` $(2)\n+COMPILE_OBJ_CXX = $(CXX) -EHs -c -Fo:`cygpath -w $(1)` $(2)\n NATIVE_STATICLIB_FILE = $(1).lib\n NATIVE_STATICLIB = $(TMPDIR)/$(call NATIVE_STATICLIB_FILE,$(1))\n OUT_EXE=-Fe:`cygpath -w $(TMPDIR)/$(call BIN,$(1))` \\\n@@ -80,10 +80,29 @@ ifdef IS_MSVC\n \tEXTRACFLAGS := ws2_32.lib userenv.lib advapi32.lib\n else\n \tEXTRACFLAGS := -lws2_32 -luserenv\n+\tEXTRACXXFLAGS := -lstdc++\n+\t# So this is a bit hacky: we can't use the DLL version of libstdc++ because\n+\t# it pulls in the DLL version of libgcc, which means that we end up with 2\n+\t# instances of the DW2 unwinding implementation. This is a problem on\n+\t# i686-pc-windows-gnu because each module (DLL/EXE) needs to register its\n+\t# unwind information with the unwinding implementation, and libstdc++'s\n+\t# __cxa_throw won't see the unwinding info we registered with our statically\n+\t# linked libgcc.\n+\t#\n+\t# Now, simply statically linking libstdc++ would fix this problem, except\n+\t# that it is compiled with the expectation that pthreads is dynamically\n+\t# linked as a DLL and will fail to link with a statically linked libpthread.\n+\t#\n+\t# So we end up with the following hack: we link use static-nobundle to only\n+\t# link the parts of libstdc++ that we actually use, which doesn't include\n+\t# the dependency on the pthreads DLL.\n+\tEXTRARSCXXFLAGS := -l static-nobundle=stdc++\n endif\n else\n ifeq ($(UNAME),Darwin)\n \tEXTRACFLAGS := -lresolv\n+\tEXTRACXXFLAGS := -lc++\n+\tEXTRARSCXXFLAGS := -lc++\n else\n ifeq ($(UNAME),FreeBSD)\n \tEXTRACFLAGS := -lm -lpthread -lgcc_s\n@@ -97,6 +116,7 @@ ifeq ($(UNAME),OpenBSD)\n else\n \tEXTRACFLAGS := -lm -lrt -ldl -lpthread\n \tEXTRACXXFLAGS := -lstdc++\n+\tEXTRARSCXXFLAGS := -lstdc++\n endif\n endif\n endif"}]}