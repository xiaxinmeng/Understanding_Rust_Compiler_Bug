{"sha": "c0d61795defc83fd696971880d60f438a1837f0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwZDYxNzk1ZGVmYzgzZmQ2OTY5NzE4ODBkNjBmNDM4YTE4MzdmMGQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-01T21:28:30Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-05T02:41:23Z"}, "message": "wip: refactor repr of regions\n\n- we now distinguish bound/free parameters (see region-param\n  test case for why this is necessary)\n- we also track bounds on region variables\n- also, restructure fold_ty() to have multiple variants without\n  duplication instead of one overloaded folder.  This also allows\n  for using block functions.", "tree": {"sha": "f2ff10d7778cf262568269c3609d884232210583", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2ff10d7778cf262568269c3609d884232210583"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0d61795defc83fd696971880d60f438a1837f0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0d61795defc83fd696971880d60f438a1837f0d", "html_url": "https://github.com/rust-lang/rust/commit/c0d61795defc83fd696971880d60f438a1837f0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0d61795defc83fd696971880d60f438a1837f0d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d961f054c509db98a57011c1bb7aa1b14492f12f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d961f054c509db98a57011c1bb7aa1b14492f12f", "html_url": "https://github.com/rust-lang/rust/commit/d961f054c509db98a57011c1bb7aa1b14492f12f"}], "stats": {"total": 2285, "additions": 1338, "deletions": 947}, "files": [{"sha": "b527b5d1f431e09906a3722fa5a22b13d6570804", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0d61795defc83fd696971880d60f438a1837f0d/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0d61795defc83fd696971880d60f438a1837f0d/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=c0d61795defc83fd696971880d60f438a1837f0d", "patch": "@@ -265,7 +265,9 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         st.pos = st.pos + 1u;\n         ret ty::mk_res(st.tcx, def, inner, params);\n       }\n-      'X' { ret ty::mk_var(st.tcx, parse_int(st)); }\n+      'X' {\n+        ret ty::mk_var(st.tcx, ty::ty_vid(parse_int(st) as uint));\n+      }\n       'Y' { ret ty::mk_type(st.tcx); }\n       'C' {\n         let ck = alt check next(st) {"}, {"sha": "c5f23f37b865c6365b4d3d17471253a19c60f0b3", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 43, "deletions": 16, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c0d61795defc83fd696971880d60f438a1837f0d/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0d61795defc83fd696971880d60f438a1837f0d/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=c0d61795defc83fd696971880d60f438a1837f0d", "patch": "@@ -5,6 +5,7 @@ import std::map::hashmap;\n import syntax::ast::*;\n import driver::session::session;\n import middle::ty;\n+import middle::ty::vid;\n import syntax::print::pprust::*;\n import middle::trans::reachable;\n \n@@ -99,23 +100,46 @@ fn enc_mt(w: io::writer, cx: @ctxt, mt: ty::mt) {\n     }\n     enc_ty(w, cx, mt.ty);\n }\n+fn enc_bound_region(w: io::writer, br: ty::bound_region) {\n+    alt br {\n+      ty::br_self { w.write_char('s') }\n+      ty::br_anon { w.write_char('a') }\n+      ty::br_param(id, s) {\n+        w.write_char('[');\n+        w.write_uint(id);\n+        w.write_char('|');\n+        w.write_str(s);\n+        w.write_char(']')\n+      }\n+    }\n+}\n fn enc_region(w: io::writer, r: ty::region) {\n     alt r {\n-        ty::re_block(nid) {\n-            w.write_char('b'); w.write_int(nid); w.write_char('|');\n-        }\n-        ty::re_self {\n-            w.write_char('s');\n-        }\n-        ty::re_inferred {\n-            w.write_char('i');\n-        }\n-        ty::re_param(id) {\n-            w.write_char('p'); w.write_uint(id); w.write_char('|');\n-        }\n-        ty::re_var(id) {\n-            w.write_char('v'); w.write_uint(id); w.write_char('|');\n-        }\n+      ty::re_bound(br) {\n+        w.write_char('b');\n+        enc_bound_region(w, br);\n+      }\n+      ty::re_free(id, br) {\n+        w.write_char('f');\n+        w.write_char('[');\n+        w.write_int(id);\n+        w.write_char('|');\n+        enc_bound_region(w, br);\n+        w.write_char(']');\n+      }\n+      ty::re_scope(nid) {\n+        w.write_char('s');\n+        w.write_int(nid);\n+        w.write_char('|');\n+      }\n+      ty::re_default {\n+        w.write_char('i');\n+      }\n+      ty::re_var(id) {\n+        w.write_char('v');\n+        w.write_uint(id.to_uint());\n+        w.write_char('|');\n+      }\n     }\n }\n fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n@@ -199,7 +223,10 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         for t: ty::t in tps { enc_ty(w, cx, t); }\n         w.write_char(']');\n       }\n-      ty::ty_var(id) { w.write_char('X'); w.write_str(int::str(id)); }\n+      ty::ty_var(id) {\n+        w.write_char('X');\n+        w.write_uint(id.to_uint());\n+      }\n       ty::ty_param(id, did) {\n         w.write_char('p');\n         w.write_str(cx.ds(did));"}, {"sha": "035da0d477b666469540107524febf8d53e358da", "filename": "src/rustc/middle/infer.rs", "status": "modified", "additions": 397, "deletions": 232, "changes": 629, "blob_url": "https://github.com/rust-lang/rust/blob/c0d61795defc83fd696971880d60f438a1837f0d/src%2Frustc%2Fmiddle%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0d61795defc83fd696971880d60f438a1837f0d/src%2Frustc%2Fmiddle%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Finfer.rs?ref=c0d61795defc83fd696971880d60f438a1837f0d", "patch": "@@ -2,11 +2,13 @@ import std::smallintmap;\n import std::smallintmap::smallintmap;\n import std::smallintmap::map;\n import middle::ty;\n+import middle::ty::{ty_vid, region_vid, vid};\n import syntax::ast;\n import syntax::ast::{ret_style};\n import util::ppaux::{ty_to_str, mt_to_str};\n import result::{result, extensions, ok, err, map, map2, iter2};\n import ty::type_is_bot;\n+import driver::session::session;\n \n export infer_ctxt;\n export new_infer_ctxt;\n@@ -16,29 +18,46 @@ export resolve_type_structure;\n export fixup_vars;\n export resolve_var;\n export compare_tys;\n+export fixup_err, fixup_err_to_str;\n \n type bound<T:copy> = option<T>;\n \n type bounds<T:copy> = {lb: bound<T>, ub: bound<T>};\n \n-enum var_value<T:copy> {\n-    redirect(uint),\n+enum var_value<V:copy, T:copy> {\n+    redirect(V),\n     bounded(bounds<T>)\n }\n \n-type vals_and_bindings<T:copy> = {\n-    vals: smallintmap<var_value<T>>,\n-    mut bindings: [(uint, var_value<T>)]\n+type vals_and_bindings<V:copy, T:copy> = {\n+    vals: smallintmap<var_value<V, T>>,\n+    mut bindings: [(V, var_value<V, T>)]\n };\n \n enum infer_ctxt = @{\n     tcx: ty::ctxt,\n-    vb: vals_and_bindings<ty::t>,\n-    rb: vals_and_bindings<ty::region>,\n+    vb: vals_and_bindings<ty::ty_vid, ty::t>,\n+    rb: vals_and_bindings<ty::region_vid, ty::region>,\n };\n \n+enum fixup_err {\n+    unresolved_ty(ty_vid),\n+    cyclic_ty(ty_vid),\n+    unresolved_region(region_vid),\n+    cyclic_region(region_vid)\n+}\n+\n+fn fixup_err_to_str(f: fixup_err) -> str {\n+    alt f {\n+      unresolved_ty(_) { \"unconstrained type\" }\n+      cyclic_ty(_) { \"cyclic type of infinite size\" }\n+      unresolved_region(_) { \"unconstrained region\" }\n+      cyclic_region(_) { \"cyclic region\" }\n+    }\n+}\n+\n type ures = result::result<(), ty::type_err>;\n-type fres<T> = result::result<T,int>;\n+type fres<T> = result::result<T, fixup_err>;\n \n fn new_infer_ctxt(tcx: ty::ctxt) -> infer_ctxt {\n     infer_ctxt(@{tcx: tcx,\n@@ -74,12 +93,12 @@ fn resolve_type_structure(cx: infer_ctxt, a: ty::t) -> fres<ty::t> {\n     cx.resolve_ty(a)\n }\n \n-fn resolve_var(cx: infer_ctxt, vid: int) -> fres<ty::t> {\n-    cx.fixup_vars(ty::mk_var(cx.tcx, vid))\n+fn resolve_var(cx: infer_ctxt, vid: ty_vid) -> fres<ty::t> {\n+    cx.fixup_ty(ty::mk_var(cx.tcx, vid))\n }\n \n fn fixup_vars(cx: infer_ctxt, a: ty::t) -> fres<ty::t> {\n-    cx.fixup_vars(a)\n+    cx.fixup_ty(a)\n }\n \n impl methods for ures {\n@@ -120,23 +139,57 @@ impl<V:copy to_str> of to_str for bound<V> {\n     }\n }\n \n-impl<V:copy to_str> of to_str for bounds<V> {\n+impl<T:copy to_str> of to_str for bounds<T> {\n     fn to_str(cx: infer_ctxt) -> str {\n         #fmt[\"{%s <: %s}\",\n              self.lb.to_str(cx),\n              self.ub.to_str(cx)]\n     }\n }\n \n-impl<V:copy to_str> of to_str for var_value<V> {\n+impl<V:copy vid, T:copy to_str> of to_str for var_value<V,T> {\n     fn to_str(cx: infer_ctxt) -> str {\n         alt self {\n-          redirect(id) { #fmt(\"redirect(%u)\", id) }\n+          redirect(vid) { #fmt(\"redirect(%s)\", vid.to_str()) }\n           bounded(bnds) { #fmt(\"bounded(%s)\", bnds.to_str(cx)) }\n         }\n     }\n }\n \n+iface st {\n+    fn st(infcx: infer_ctxt, b: self) -> ures;\n+    fn lub(infcx: infer_ctxt, b: self) -> cres<self>;\n+    fn glb(infcx: infer_ctxt, b: self) -> cres<self>;\n+}\n+\n+impl of st for ty::t {\n+    fn st(infcx: infer_ctxt, b: ty::t) -> ures {\n+        infcx.tys(self, b)\n+    }\n+\n+    fn lub(infcx: infer_ctxt, b: ty::t) -> cres<ty::t> {\n+        lub(infcx).c_tys(self, b)\n+    }\n+\n+    fn glb(infcx: infer_ctxt, b: ty::t) -> cres<ty::t> {\n+        glb(infcx).c_tys(self, b)\n+    }\n+}\n+\n+impl of st for ty::region {\n+    fn st(infcx: infer_ctxt, b: ty::region) -> ures {\n+        infcx.regions(self, b)\n+    }\n+\n+    fn lub(infcx: infer_ctxt, b: ty::region) -> cres<ty::region> {\n+        lub(infcx).c_regions(self, b)\n+    }\n+\n+    fn glb(infcx: infer_ctxt, b: ty::region) -> cres<ty::region> {\n+        glb(infcx).c_regions(self, b)\n+    }\n+}\n+\n // Most of these methods, like tys() and so forth, take two parameters\n // a and b and they are tasked with \"ensuring that a is a subtype of\n // b\".  They return success or failure.  They make changes in-place to\n@@ -157,31 +210,20 @@ impl unify_methods for infer_ctxt {\n         err(e)\n     }\n \n-    fn set<T:copy to_str>(\n-        vb: vals_and_bindings<T>, vid: uint,\n-        +new_v: var_value<T>) {\n+    fn set<V:copy vid, T:copy to_str>(\n+        vb: vals_and_bindings<V, T>, vid: V,\n+        +new_v: var_value<V, T>) {\n \n-        let old_v = vb.vals.get(vid);\n+        let old_v = vb.vals.get(vid.to_uint());\n         vec::push(vb.bindings, (vid, old_v));\n-        vb.vals.insert(vid, new_v);\n+        vb.vals.insert(vid.to_uint(), new_v);\n \n-        #debug[\"Updating variable <%u> from %s to %s\",\n-               vid, old_v.to_str(self), new_v.to_str(self)];\n+        #debug[\"Updating variable %s from %s to %s\",\n+               vid.to_str(), old_v.to_str(self), new_v.to_str(self)];\n     }\n \n-    fn set_ty(vid: uint, +new_v: var_value<ty::t>) {\n-        let old_v = self.vb.vals.get(vid);\n+    fn set_ty(vid: ty_vid, +new_v: var_value<ty_vid, ty::t>) {\n         self.set(self.vb, vid, new_v);\n-\n-        #debug[\"Updating variable <T%u> from %s to %s\",\n-               vid, old_v.to_str(self), new_v.to_str(self)];\n-    }\n-\n-    fn rollback_to<T:copy>(vb: vals_and_bindings<T>, len: uint) {\n-        while vb.bindings.len() != len {\n-            let (vid, old_v) = vec::pop(vb.bindings);\n-            vb.vals.insert(vid, old_v);\n-        }\n     }\n \n     fn commit<T:copy,E:copy>(f: fn() -> result<T,E>) -> result<T,E> {\n@@ -203,10 +245,12 @@ impl unify_methods for infer_ctxt {\n \n     fn try<T:copy,E:copy>(f: fn() -> result<T,E>) -> result<T,E> {\n \n-        fn rollback_to<T:copy>(vb: vals_and_bindings<T>, len: uint) {\n+        fn rollback_to<V:copy vid, T:copy>(\n+            vb: vals_and_bindings<V, T>, len: uint) {\n+\n             while vb.bindings.len() != len {\n                 let (vid, old_v) = vec::pop(vb.bindings);\n-                vb.vals.insert(vid, old_v);\n+                vb.vals.insert(vid.to_uint(), old_v);\n             }\n         }\n \n@@ -225,19 +269,20 @@ impl unify_methods for infer_ctxt {\n         ret r;\n     }\n \n-    fn get<T:copy>(vb: vals_and_bindings<T>, vid: uint)\n-        -> {root: uint, bounds:bounds<T>} {\n+    fn get<V:copy vid, T:copy>(\n+        vb: vals_and_bindings<V, T>, vid: V)\n+        -> {root: V, bounds:bounds<T>} {\n \n-        alt vb.vals.find(vid) {\n+        alt vb.vals.find(vid.to_uint()) {\n           none {\n             let bnds = {lb: none, ub: none};\n-            vb.vals.insert(vid, bounded(bnds));\n+            vb.vals.insert(vid.to_uint(), bounded(bnds));\n             {root: vid, bounds: bnds}\n           }\n           some(redirect(vid)) {\n             let {root, bounds} = self.get(vb, vid);\n             if root != vid {\n-                vb.vals.insert(vid, redirect(root));\n+                vb.vals.insert(vid.to_uint(), redirect(root));\n             }\n             {root: root, bounds: bounds}\n           }\n@@ -247,11 +292,15 @@ impl unify_methods for infer_ctxt {\n         }\n     }\n \n-    fn get_var(vid: uint) -> {root: uint, bounds:bounds<ty::t>} {\n+    fn get_var(vid: ty_vid)\n+        -> {root: ty_vid, bounds:bounds<ty::t>} {\n+\n         ret self.get(self.vb, vid);\n     }\n \n-    fn get_region(rid: uint) -> {root: uint, bounds:bounds<ty::region>} {\n+    fn get_region(rid: region_vid)\n+        -> {root: region_vid, bounds:bounds<ty::region>} {\n+\n         ret self.get(self.rb, rid);\n     }\n \n@@ -304,8 +353,9 @@ impl unify_methods for infer_ctxt {\n     //    a.lb <: c.lb\n     //    b.lb <: c.lb\n     // If this cannot be achieved, the result is failure.\n-    fn set_ty_var_to_merged_bounds(\n-        v_id: uint, a: bounds<ty::t>, b: bounds<ty::t>) -> ures {\n+    fn set_var_to_merged_bounds<V:copy vid, T:copy to_str st>(\n+        vb: vals_and_bindings<V, T>,\n+        v_id: V, a: bounds<T>, b: bounds<T>) -> ures {\n \n         // Think of the two diamonds, we want to find the\n         // intersection.  There are basically four possibilities (you\n@@ -322,8 +372,8 @@ impl unify_methods for infer_ctxt {\n         //       A     \\ / A\n         //              B\n \n-        #debug[\"merge(<T%u>,%s,%s)\",\n-               v_id,\n+        #debug[\"merge(%s,%s,%s)\",\n+               v_id.to_str(),\n                a.to_str(self),\n                b.to_str(self)];\n \n@@ -335,41 +385,41 @@ impl unify_methods for infer_ctxt {\n         // when necessary.\n         self.bnds(a.lb, b.ub).then {||\n         self.bnds(b.lb, a.ub).then {||\n-        self.merge_bnds(\n-            a, b,\n-            {|a_ty, b_ty| lub(self).c_tys(a_ty, b_ty) },\n-            {|a_ty, b_ty| glb(self).c_tys(a_ty, b_ty) }).chain {|bnds|\n-\n-            #debug[\"merge(<T%u>): bnds=%s\",\n-                   v_id,\n+        self.merge_bnd(a.ub, b.ub, {|x, y| x.glb(self, y)}).chain {|ub|\n+        self.merge_bnd(a.lb, b.lb, {|x, y| x.lub(self, y)}).chain {|lb|\n+            let bnds = {lb: lb, ub: ub};\n+            #debug[\"merge(%s): bnds=%s\",\n+                   v_id.to_str(),\n                    bnds.to_str(self)];\n \n             // the new bounds must themselves\n             // be relatable:\n             self.bnds(bnds.lb, bnds.ub).then {||\n-            self.set_ty(v_id, bounded(bnds));\n+            self.set(vb, v_id, bounded(bnds));\n             self.uok()\n             }\n-        }}}\n+        }}}}\n     }\n \n-    // TODO: Generalize to regions.\n-    fn vars(a_id: uint, b_id: uint) -> ures {\n+    fn vars<V:copy vid, T:copy to_str st>(\n+        vb: vals_and_bindings<V, T>,\n+        a_id: V, b_id: V) -> ures {\n+\n         // Need to make sub_id a subtype of sup_id.\n-        let {root: a_id, bounds: a_bounds} = self.get(self.vb, a_id);\n-        let {root: b_id, bounds: b_bounds} = self.get(self.vb, b_id);\n+        let {root: a_id, bounds: a_bounds} = self.get(vb, a_id);\n+        let {root: b_id, bounds: b_bounds} = self.get(vb, b_id);\n \n-        #debug[\"vars(<T%u>=%s <: <T%u>=%s)\",\n-               a_id, a_bounds.to_str(self),\n-               b_id, b_bounds.to_str(self)];\n+        #debug[\"vars(%s=%s <: %s=%s)\",\n+               a_id.to_str(), a_bounds.to_str(self),\n+               b_id.to_str(), b_bounds.to_str(self)];\n \n         if a_id == b_id { ret self.uok(); }\n \n         // If both A's UB and B's LB have already been bound to types,\n         // see if we can make those types subtypes.\n         alt (a_bounds.ub, b_bounds.lb) {\n           (some(a_ub), some(b_lb)) {\n-            let r = self.try {|| self.tys(a_ub, b_lb) };\n+            let r = self.try {|| a_ub.st(self, b_lb) };\n             alt r {\n               ok(()) { ret result::ok(()); }\n               err(_) { /*fallthrough */ }\n@@ -380,38 +430,81 @@ impl unify_methods for infer_ctxt {\n \n         // For max perf, we should consider the rank here.  But for now,\n         // we always make b redirect to a.\n-        self.set_ty(b_id, redirect(a_id));\n+        self.set(vb, b_id, redirect(a_id));\n \n         // Otherwise, we need to merge A and B so as to guarantee that\n         // A remains a subtype of B.  Actually, there are other options,\n         // but that's the route we choose to take.\n-        self.set_ty_var_to_merged_bounds(a_id, a_bounds, b_bounds).then {||\n+        self.set_var_to_merged_bounds(vb, a_id, a_bounds, b_bounds).then {||\n             self.uok()\n         }\n     }\n \n-    fn varty(a_id: uint, b: ty::t) -> ures {\n-        let {root: a_id, bounds: a_bounds} = self.get(self.vb, a_id);\n-        #debug[\"varty(<T%u>=%s <: %s)\",\n-               a_id, a_bounds.to_str(self),\n+    fn vart<V: copy vid, T: copy to_str st>(\n+        vb: vals_and_bindings<V, T>,\n+        a_id: V, b: T) -> ures {\n+\n+        let {root: a_id, bounds: a_bounds} = self.get(vb, a_id);\n+        #debug[\"vart(%s=%s <: %s)\",\n+               a_id.to_str(), a_bounds.to_str(self),\n                b.to_str(self)];\n         let b_bounds = {lb: none, ub: some(b)};\n-        self.set_ty_var_to_merged_bounds(a_id, a_bounds, b_bounds)\n+        self.set_var_to_merged_bounds(vb, a_id, a_bounds, b_bounds)\n     }\n \n-    fn tyvar(a: ty::t, b_id: uint) -> ures {\n+    fn tvar<V: copy vid, T: copy to_str st>(\n+        vb: vals_and_bindings<V, T>,\n+        a: T, b_id: V) -> ures {\n+\n         let a_bounds = {lb: some(a), ub: none};\n-        let {root: b_id, bounds: b_bounds} = self.get(self.vb, b_id);\n-        #debug[\"tyvar(%s <: <T%u>=%s)\",\n+        let {root: b_id, bounds: b_bounds} = self.get(vb, b_id);\n+        #debug[\"tvar(%s <: %s=%s)\",\n                a.to_str(self),\n-               b_id, b_bounds.to_str(self)];\n-        self.set_ty_var_to_merged_bounds(b_id, a_bounds, b_bounds)\n+               b_id.to_str(), b_bounds.to_str(self)];\n+        self.set_var_to_merged_bounds(vb, b_id, a_bounds, b_bounds)\n     }\n \n     fn regions(a: ty::region, b: ty::region) -> ures {\n-        alt combine_or_unify_regions(self.tcx, a, b, false) {\n-            ok(_)   { self.uok()   }\n-            err(e)  { self.uerr(e) }\n+        alt (a, b) { // XXX\n+          (ty::re_var(a_id), ty::re_var(b_id)) {\n+            self.vars(self.rb, a_id, b_id)\n+          }\n+          (ty::re_var(a_id), _) {\n+            self.vart(self.rb, a_id, b)\n+          }\n+          (_, ty::re_var(b_id)) {\n+            self.tvar(self.rb, a, b_id)\n+          }\n+\n+          (ty::re_free(a_id, _), ty::re_scope(b_id)) |\n+          (ty::re_scope(a_id), ty::re_free(b_id, _)) |\n+          (ty::re_scope(a_id), ty::re_scope(b_id)) {\n+            let rm = self.tcx.region_map;\n+            alt region::nearest_common_ancestor(rm, a_id, b_id) {\n+              some(r_id) if r_id == a_id { self.uok() }\n+              _ { err(ty::terr_regions_differ(false, b, a)) }\n+            }\n+          }\n+\n+          // For these types, we cannot define any additional relationship:\n+          (ty::re_free(_, _), ty::re_free(_, _)) |\n+          (ty::re_bound(_), ty::re_bound(_)) |\n+          (ty::re_bound(_), ty::re_free(_, _)) |\n+          (ty::re_bound(_), ty::re_scope(_)) |\n+          (ty::re_free(_, _), ty::re_bound(_)) |\n+          (ty::re_scope(_), ty::re_bound(_)) {\n+            if a == b {\n+                self.uok()\n+            } else {\n+                err(ty::terr_regions_differ(false, b, a))\n+            }\n+          }\n+\n+          (ty::re_default, _) |\n+          (_, ty::re_default) {\n+            // actually a compiler bug, I think.\n+            err(ty::terr_regions_differ(false, b, a))\n+          }\n         }\n     }\n \n@@ -557,11 +650,10 @@ impl unify_methods for infer_ctxt {\n         ret self.uok();\n     }\n \n-    // TODO: Generalize this.\n-    fn bnds(a: bound<ty::t>, b: bound<ty::t>) -> ures {\n-        #debug(\"bnds(%s <: %s)\",\n-               a.to_str(self),\n-               b.to_str(self));\n+    fn bnds<T:copy to_str st>(\n+        a: bound<T>, b: bound<T>) -> ures {\n+\n+        #debug(\"bnds(%s <: %s)\", a.to_str(self), b.to_str(self));\n \n         alt (a, b) {\n           (none, none) |\n@@ -570,7 +662,7 @@ impl unify_methods for infer_ctxt {\n             self.uok()\n           }\n           (some(t_a), some(t_b)) {\n-            self.tys(t_a, t_b)\n+            t_a.st(self, t_b)\n           }\n         }\n     }\n@@ -605,13 +697,13 @@ impl unify_methods for infer_ctxt {\n           (ty::ty_bot, _) { self.uok() }\n \n           (ty::ty_var(a_id), ty::ty_var(b_id)) {\n-            self.vars(a_id as uint, b_id as uint)\n+            self.vars(self.vb, a_id, b_id)\n           }\n           (ty::ty_var(a_id), _) {\n-            self.varty(a_id as uint, b)\n+            self.vart(self.vb, a_id, b)\n           }\n           (_, ty::ty_var(b_id)) {\n-            self.tyvar(a, b_id as uint)\n+            self.tvar(self.vb, a, b_id)\n           }\n \n           (ty::ty_nil, _) |\n@@ -700,19 +792,19 @@ impl resolve_methods for infer_ctxt {\n         ok(t)\n     }\n \n-    fn rerr<T>(v: int) -> fres<T> {\n+    fn rerr<T>(v: fixup_err) -> fres<T> {\n         #debug[\"Resolve error: %?\", v];\n         err(v)\n     }\n \n-    fn resolve_var<T:copy to_str>(\n-        vb: vals_and_bindings<T>, bot_guard: fn(T)->bool,\n-        vid: int, unbound: fn() -> fres<T>) -> fres<T> {\n+    fn resolve_var<V: copy vid, T:copy to_str>(\n+        vb: vals_and_bindings<V, T>, bot_guard: fn(T)->bool,\n+        vid: V, unbound: fn() -> fres<T>) -> fres<T> {\n \n-        let {root:_, bounds} = self.get(vb, vid as uint);\n+        let {root:_, bounds} = self.get(vb, vid);\n \n-        #debug[\"resolve_var(%d) bounds=%s\",\n-               vid, bounds.to_str(self)];\n+        #debug[\"resolve_var(%s) bounds=%s\",\n+               vid.to_str(), bounds.to_str(self)];\n \n         // Nonobvious: prefer the most specific type\n         // (i.e., the lower bound) to the more general\n@@ -728,27 +820,27 @@ impl resolve_methods for infer_ctxt {\n         }\n     }\n \n-    fn resolve_ty_var(vid: int) -> fres<ty::t> {\n+    fn resolve_ty_var(vid: ty_vid) -> fres<ty::t> {\n         ret self.resolve_var(\n             self.vb,\n             {|t| type_is_bot(t) },\n             vid,\n             {|| ok(ty::mk_bot(self.tcx)) });\n     }\n \n-    fn resolve_region_var(rid: int) -> fres<ty::region> {\n+    fn resolve_region_var(rid: region_vid) -> fres<ty::region> {\n         ret self.resolve_var(\n             self.rb,\n             {|_t| false },\n             rid,\n-            {|| err(rid) });\n+            {|| err(unresolved_region(rid)) });\n     }\n \n     fn resolve_ty(typ: ty::t) -> fres<ty::t> {\n         alt ty::get(typ).struct {\n           ty::ty_var(vid) { self.resolve_ty_var(vid) }\n           ty::ty_rptr(ty::re_var(rid), base_ty) {\n-            alt self.resolve_region_var(rid as int) {\n+            alt self.resolve_region_var(rid) {\n               err(terr)  { err(terr) }\n               ok(region) {\n                 self.rok(ty::mk_rptr(self.tcx, region, base_ty))\n@@ -759,95 +851,76 @@ impl resolve_methods for infer_ctxt {\n         }\n     }\n \n-    fn subst_vars(unresolved: @mut option<int>,\n-                  vars_seen: std::list::list<int>,\n-                  vid: int) -> ty::t {\n-        // Should really return a fixup_result instead of a t, but fold_ty\n-        // doesn't allow returning anything but a t.\n-        alt self.resolve_ty_var(vid) {\n-          err(vid) {\n-            *unresolved = some(vid);\n-            ret ty::mk_var(self.tcx, vid);\n+    fn fixup_region(r: ty::region,\n+                    &r_seen: [region_vid],\n+                    err: @mut option<fixup_err>) -> ty::region {\n+        alt r {\n+          ty::re_var(rid) if vec::contains(r_seen, rid) {\n+            *err = some(cyclic_region(rid)); r\n           }\n-          ok(rt) {\n-            let mut give_up = false;\n-            std::list::iter(vars_seen) {|v|\n-                if v == vid {\n-                    *unresolved = some(-1); // hack: communicate inf ty\n-                    give_up = true;\n-                }\n-            }\n \n-            // Return the type unchanged, so we can error out\n-            // downstream\n-            if give_up { ret rt; }\n-            ret ty::fold_ty(self.tcx,\n-                            ty::fm_var(\n-                                self.subst_vars(\n-                                    unresolved,\n-                                    std::list::cons(vid, @vars_seen),\n-                                    _)),\n-                            rt);\n+          ty::re_var(rid) {\n+            alt self.resolve_region_var(rid) {\n+              result::ok(r1) {\n+                vec::push(r_seen, rid);\n+                let r2 = self.fixup_region(r1, r_seen, err);\n+                vec::pop(r_seen);\n+                ret r2;\n+              }\n+              result::err(e) { *err = some(e); r }\n+            }\n           }\n+\n+          _ { r }\n         }\n     }\n \n-    fn fixup_vars(typ: ty::t) -> fres<ty::t> {\n-        let unresolved = @mut none::<int>;\n-        let rty =\n-            ty::fold_ty(self.tcx,\n-                        ty::fm_var(\n-                            self.subst_vars(\n-                                unresolved,\n-                                std::list::nil,\n-                                _)),\n-                        typ);\n+    fn fixup_ty1(ty: ty::t,\n+                 &ty_seen: [ty_vid],\n+                 &r_seen: [region_vid],\n+                 err: @mut option<fixup_err>) -> ty::t {\n+        let tb = ty::get(ty);\n+        if !tb.has_vars { ret ty; }\n+        alt tb.struct {\n+          ty::ty_var(vid) if vec::contains(ty_seen, vid) {\n+            *err = some(cyclic_ty(vid)); ty\n+          }\n \n-        let ur = *unresolved;\n-        alt ur {\n-          none { ret self.rok(rty); }\n-          some(var_id) { ret self.rerr(var_id); }\n-        }\n-    }\n+          ty::ty_var(vid) {\n+            alt self.resolve_ty_var(vid) {\n+              result::err(e) { *err = some(e); ty }\n+              result::ok(ty1) {\n+                vec::push(ty_seen, vid);\n+                let ty2 = self.fixup_ty1(ty1, ty_seen, r_seen, err);\n+                vec::pop(ty_seen);\n+                ret ty2;\n+              }\n+            }\n+          }\n \n-    fn subst_regions(unresolved: @mut option<int>,\n-                     regions_seen: std::list::list<int>,\n-                     rid: int) -> ty::region {\n-        // Should really return a fixup_result instead of a t, but fold_ty\n-        // doesn't allow returning anything but a t.\n-        alt self.resolve_region_var(rid) {\n-          err(rid) {\n-            *unresolved = some(rid);\n-            ret ty::re_var(rid as uint);\n+          ty::ty_rptr(r, {ty: base_ty, mutbl: m}) {\n+            let base_ty1 = self.fixup_ty1(base_ty, ty_seen, r_seen, err);\n+            let r1 = self.fixup_region(r, r_seen, err);\n+            ret ty::mk_rptr(self.tcx, r1, {ty: base_ty1, mutbl: m});\n           }\n-          ok(rr) {\n-            let mut give_up = false;\n-            std::list::iter(regions_seen) {|r|\n-                if r == rid {\n-                    *unresolved = some(-1); // hack: communicate inf region\n-                    give_up = true;\n-                }\n+\n+          sty {\n+            ty::fold_sty_to_ty(self.tcx, sty) {|t|\n+                self.fixup_ty1(t, ty_seen, r_seen, err)\n             }\n-            ret rr;\n           }\n         }\n     }\n \n-    fn fixup_regions(typ: ty::t) -> fres<ty::t> {\n-        let unresolved = @mut none::<int>;\n-        let rty = ty::fold_ty(self.tcx, ty::fm_rptr({ |region, _under_rptr|\n-            alt region {\n-              ty::re_var(rid) {\n-                self.subst_regions(unresolved, std::list::nil, rid as int)\n-              }\n-              _ { region }\n-            }\n-        }, false), typ);\n-\n-        let ur = *unresolved;\n-        alt ur {\n+    fn fixup_ty(typ: ty::t) -> fres<ty::t> {\n+        #debug[\"fixup_ty(%s)\", ty_to_str(self.tcx, typ)];\n+        let mut ty_seen = [];\n+        let mut r_seen = [];\n+        let unresolved = @mut none;\n+        let rty = self.fixup_ty1(typ, ty_seen, r_seen, unresolved);\n+        alt *unresolved {\n           none { ret self.rok(rty); }\n-          some(var_id) { ret self.rerr(var_id); }\n+          some(e) { ret self.rerr(e); }\n         }\n     }\n }\n@@ -868,6 +941,10 @@ impl resolve_methods for infer_ctxt {\n // instance as the first parameter.  This would be better implemented\n // using traits.\n //\n+// The `c_X()` top-level items work for *both LUB and GLB*: any\n+// operation which varies between LUB and GLB will be dynamically\n+// dispatched using a `self.c_Y()` operation.\n+//\n // In principle, the subtyping relation computed above could be built\n // on the combine framework---this would result in less code but would\n // be less efficient.  There is a significant performance gain from\n@@ -884,42 +961,55 @@ iface combine {\n     fn bnd<V:copy>(b: bounds<V>) -> option<V>;\n     fn with_bnd<V:copy>(b: bounds<V>, v: V) -> bounds<V>;\n     fn c_bot(b: ty::t) -> cres<ty::t>;\n-    fn c_regions(a: ty::region, b: ty::region) -> cres<ty::region>;\n     fn c_mts(a: ty::mt, b: ty::mt) -> cres<ty::mt>;\n     fn c_contratys(t1: ty::t, t2: ty::t) -> cres<ty::t>;\n     fn c_tys(t1: ty::t, t2: ty::t) -> cres<ty::t>;\n     fn c_protos(p1: ast::proto, p2: ast::proto) -> cres<ast::proto>;\n     fn c_ret_styles(r1: ret_style, r2: ret_style) -> cres<ret_style>;\n+\n+    // Combining regions (along with some specific cases that are\n+    // different for LUB/GLB):\n+    fn c_regions(\n+        a: ty::region, b: ty::region) -> cres<ty::region>;\n+    fn c_regions_scope_scope(\n+        a: ty::region, a_id: ast::node_id,\n+        b: ty::region, b_id: ast::node_id) -> cres<ty::region>;\n+    fn c_regions_free_scope(\n+        a: ty::region, a_id: ast::node_id, a_br: ty::bound_region,\n+        b: ty::region, b_id: ast::node_id) -> cres<ty::region>;\n }\n \n enum lub = infer_ctxt;\n enum glb = infer_ctxt;\n \n-fn c_ty_vars<C:combine>(self: C, a_id: uint, b_id: uint) -> cres<ty::t> {\n+fn c_vars<V:copy vid, C:combine, T:copy to_str st>(\n+    self: C, vb: vals_and_bindings<V, T>,\n+    a_t: T, a_vid: V, b_vid: V,\n+    c_ts: fn(T, T) -> cres<T>) -> cres<T> {\n+\n+    // The comments in this function are written for LUB and types,\n+    // but they apply equally well to GLB and regions if you inverse\n+    // upper/lower/sub/super/etc.\n+\n     // Need to find a type that is a supertype of both a and b:\n-    let {root: a_id, bounds: a_bounds} = self.infcx().get_var(a_id);\n-    let {root: b_id, bounds: b_bounds} = self.infcx().get_var(b_id);\n+    let {root: a_vid, bounds: a_bounds} = self.infcx().get(vb, a_vid);\n+    let {root: b_vid, bounds: b_bounds} = self.infcx().get(vb, b_vid);\n \n-    #debug[\"%s.c_ty_vars(<T%u>=%s <: <T%u>=%s)\",\n+    #debug[\"%s.c_vars(%s=%s <: %s=%s)\",\n            self.tag(),\n-           a_id, a_bounds.to_str(self.infcx()),\n-           b_id, b_bounds.to_str(self.infcx())];\n-\n-    let tcx = self.infcx().tcx;\n+           a_vid.to_str(), a_bounds.to_str(self.infcx()),\n+           b_vid.to_str(), b_bounds.to_str(self.infcx())];\n \n-    if a_id == b_id {\n-        ret ok(ty::mk_var(tcx, a_id as int));\n+    if a_vid == b_vid {\n+        ret ok(a_t);\n     }\n \n-    // The comments in this function are written for LUB, but they\n-    // apply equally well to GLB if you inverse upper/lower/sub/super/etc.\n-\n     // If both A and B have an UB type, then we can just compute the\n     // LUB of those types:\n     let a_bnd = self.bnd(a_bounds), b_bnd = self.bnd(b_bounds);\n     alt (a_bnd, b_bnd) {\n       (some(a_ty), some(b_ty)) {\n-        alt self.infcx().try {|| self.c_tys(a_ty, b_ty) } {\n+        alt self.infcx().try {|| c_ts(a_ty, b_ty) } {\n             ok(t) { ret ok(t); }\n             err(_) { /*fallthrough */ }\n         }\n@@ -929,33 +1019,37 @@ fn c_ty_vars<C:combine>(self: C, a_id: uint, b_id: uint) -> cres<ty::t> {\n \n     // Otherwise, we need to merge A and B into one variable.  We can\n     // then use either variable as an upper bound:\n-    self.infcx().vars(a_id, b_id).then {||\n-        ok(ty::mk_var(tcx, a_id as int))\n+    self.infcx().vars(vb, a_vid, b_vid).then {||\n+        ok(a_t)\n     }\n }\n \n-fn c_ty_var_ty<C:combine>(self: C, a_id: uint, b: ty::t) -> cres<ty::t> {\n-    let {root: a_id, bounds: a_bounds} = self.infcx().get_var(a_id);\n+fn c_var_t<V:copy vid, C:combine, T:copy to_str st>(\n+    self: C, vb: vals_and_bindings<V, T>,\n+    a_vid: V, b: T,\n+    c_ts: fn(T, T) -> cres<T>) -> cres<T> {\n+\n+    let {root: a_id, bounds: a_bounds} = self.infcx().get(vb, a_vid);\n \n     // The comments in this function are written for LUB, but they\n     // apply equally well to GLB if you inverse upper/lower/sub/super/etc.\n \n-    #debug[\"%s.c_ty_var_ty(<T%u>=%s <: %s)\",\n+    #debug[\"%s.c_var_ty(%s=%s <: %s)\",\n            self.tag(),\n-           a_id, a_bounds.to_str(self.infcx()),\n+           a_id.to_str(), a_bounds.to_str(self.infcx()),\n            b.to_str(self.infcx())];\n \n     alt self.bnd(a_bounds) {\n-      some(a_ty) {\n+      some(a_bnd) {\n         // If a has an upper bound, return it.\n-        ret self.c_tys(a_ty, b);\n+        ret c_ts(a_bnd, b);\n       }\n       none {\n         // If a does not have an upper bound, make b the upper bound of a\n         // and then return b.\n         let a_bounds = self.with_bnd(a_bounds, b);\n         self.infcx().bnds(a_bounds.lb, a_bounds.ub).then {||\n-            self.infcx().set_ty(a_id, bounded(a_bounds));\n+            self.infcx().set(vb, a_id, bounded(a_bounds));\n             ok(b)\n         }\n       }\n@@ -1070,15 +1164,21 @@ fn c_tys<C:combine>(\n       (_, ty::ty_bot) { self.c_bot(b) }\n \n       (ty::ty_var(a_id), ty::ty_var(b_id)) {\n-        c_ty_vars(self, a_id as uint, b_id as uint)\n+        c_vars(self, self.infcx().vb,\n+               a, a_id, b_id,\n+               {|x, y| self.c_tys(x, y) })\n       }\n \n       // Note that the LUB/GLB operations are commutative:\n-      (ty::ty_var(a_id), _) {\n-        c_ty_var_ty(self, a_id as uint, b)\n+      (ty::ty_var(v_id), _) {\n+        c_var_t(self, self.infcx().vb,\n+                v_id, b,\n+                {|x, y| self.c_tys(x, y) })\n       }\n-      (_, ty::ty_var(b_id)) {\n-        c_ty_var_ty(self, b_id as uint, a)\n+      (_, ty::ty_var(v_id)) {\n+        c_var_t(self, self.infcx().vb,\n+                v_id, a,\n+                {|x, y| self.c_tys(x, y) })\n       }\n \n       (ty::ty_nil, _) |\n@@ -1192,43 +1292,61 @@ fn c_tys<C:combine>(\n     }\n }\n \n-fn combine_or_unify_regions(tcx: ty::ctxt,\n-                            a: ty::region,\n-                            b: ty::region,\n-                            contravariant_combine: bool) -> cres<ty::region> {\n+fn c_regions<C:combine>(\n+    self: C, a: ty::region, b: ty::region) -> cres<ty::region> {\n+\n+    #debug[\"%s.c_regions(%?, %?)\",\n+           self.tag(),\n+           a.to_str(self.infcx()),\n+           b.to_str(self.infcx())];\n+\n     alt (a, b) {\n-      (ty::re_var(_), _) | (_, ty::re_var(_)) {\n-        ok(a)   // FIXME: We need region variables!\n+      (ty::re_var(a_id), ty::re_var(b_id)) {\n+        c_vars(self, self.infcx().rb,\n+               a, a_id, b_id,\n+               {|x, y| self.c_regions(x, y) })\n+      }\n+\n+      (ty::re_var(v_id), r) |\n+      (r, ty::re_var(v_id)) {\n+        c_var_t(self, self.infcx().rb,\n+                v_id, r,\n+                {|x, y| self.c_regions(x, y) })\n       }\n-      (ty::re_inferred, _) | (_, ty::re_inferred) {\n-        fail \"tried to combine or unify inferred regions\"\n+\n+      (f @ ty::re_free(f_id, f_br), s @ ty::re_scope(s_id)) |\n+      (s @ ty::re_scope(s_id), f @ ty::re_free(f_id, f_br)) {\n+        self.c_regions_free_scope(f, f_id, f_br, s, s_id)\n+      }\n+\n+      (ty::re_scope(a_id), ty::re_scope(b_id)) {\n+        self.c_regions_scope_scope(a, a_id, b, b_id)\n       }\n-      (ty::re_param(_), ty::re_param(_)) |\n-      (ty::re_self, ty::re_self) {\n+\n+      // For these types, we cannot define any additional relationship:\n+      (ty::re_free(_, _), ty::re_free(_, _)) |\n+      (ty::re_bound(_), ty::re_bound(_)) |\n+      (ty::re_bound(_), ty::re_free(_, _)) |\n+      (ty::re_bound(_), ty::re_scope(_)) |\n+      (ty::re_free(_, _), ty::re_bound(_)) |\n+      (ty::re_scope(_), ty::re_bound(_)) {\n         if a == b {\n+            #debug[\"... yes, %s == %s.\",\n+                   a.to_str(self.infcx()),\n+                   b.to_str(self.infcx())];\n             ok(a)\n         } else {\n-            err(ty::terr_regions_differ(false, a, b))\n+            #debug[\"... no, %s != %s.\",\n+                   a.to_str(self.infcx()),\n+                   b.to_str(self.infcx())];\n+            err(ty::terr_regions_differ(false, b, a))\n         }\n       }\n-      (ty::re_param(_), ty::re_block(_)) |\n-      (ty::re_self, ty::re_block(_)) {\n-        ok(a)\n-      }\n-      (ty::re_block(_), ty::re_param(_)) |\n-      (ty::re_block(_), ty::re_self) {\n-        err(ty::terr_regions_differ(false, a, b))\n-      }\n-      (ty::re_block(block_a), ty::re_block(block_b)) {\n-        // The region corresponding to an outer block is a subtype of the\n-        // region corresponding to an inner block.\n-        let rm = tcx.region_map;\n-        let nca_opt = region::nearest_common_ancestor(rm, block_a, block_b);\n-        alt nca_opt {\n-            some(nca) if nca == block_b { ok(a) }\n-            some(nca) if contravariant_combine { ok(ty::re_block(nca)) }\n-            _ { err(ty::terr_regions_differ(false, a, b)) }\n-        }\n+\n+      (ty::re_default, _) |\n+      (_, ty::re_default) {\n+        // actually a compiler bug, I think.\n+        err(ty::terr_regions_differ(false, b, a))\n       }\n     }\n }\n@@ -1319,7 +1437,29 @@ impl of combine for lub {\n     }\n \n     fn c_regions(a: ty::region, b: ty::region) -> cres<ty::region> {\n-        ret combine_or_unify_regions(self.tcx, a, b, true);\n+        ret c_regions(self, a, b);\n+    }\n+\n+    fn c_regions_free_scope(\n+        a: ty::region, _a_id: ast::node_id, _a_br: ty::bound_region,\n+        _b: ty::region, _b_id: ast::node_id) -> cres<ty::region> {\n+\n+        // for LUB, the scope is within the function and the free\n+        // region is always a parameter to the method.\n+        ret ok(a); // NDM--not so for nested functions\n+    }\n+\n+    fn c_regions_scope_scope(a: ty::region, a_id: ast::node_id,\n+                             b: ty::region, b_id: ast::node_id)\n+        -> cres<ty::region> {\n+\n+        // The region corresponding to an outer block is a subtype of the\n+        // region corresponding to an inner block.\n+        let rm = self.infcx().tcx.region_map;\n+        alt region::nearest_common_ancestor(rm, a_id, b_id) {\n+          some(r_id) { ok(ty::re_scope(r_id)) }\n+          _ { err(ty::terr_regions_differ(false, b, a)) }\n+        }\n     }\n }\n \n@@ -1427,6 +1567,31 @@ impl of combine for glb {\n     }\n \n     fn c_regions(a: ty::region, b: ty::region) -> cres<ty::region> {\n-        ret combine_or_unify_regions(self.tcx, a, b, false);\n+        ret c_regions(self, a, b);\n+    }\n+\n+    fn c_regions_free_scope(\n+        _a: ty::region, _a_id: ast::node_id, _a_br: ty::bound_region,\n+        b: ty::region, _b_id: ast::node_id) -> cres<ty::region> {\n+\n+        // for GLB, the scope is within the function and the free\n+        // region is always a parameter to the method.  So the GLB\n+        // must be the scope.\n+        ret ok(b); // NDM--not so for nested functions\n+    }\n+\n+    fn c_regions_scope_scope(a: ty::region, a_id: ast::node_id,\n+                             b: ty::region, b_id: ast::node_id)\n+        -> cres<ty::region> {\n+\n+        // We want to generate a region that is contained by both of\n+        // these: so, if one of these scopes is a subscope of the\n+        // other, return it.  Otherwise fail.\n+        let rm = self.infcx().tcx.region_map;\n+        alt region::nearest_common_ancestor(rm, a_id, b_id) {\n+          some(r_id) if a_id == r_id { ok(b) }\n+          some(r_id) if b_id == r_id { ok(a) }\n+          _ { err(ty::terr_regions_differ(false, b, a)) }\n+        }\n     }\n }"}, {"sha": "1e002e9c1d07a0cca5a59b94f80ffa7eae9b14c9", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 317, "deletions": 103, "changes": 420, "blob_url": "https://github.com/rust-lang/rust/blob/c0d61795defc83fd696971880d60f438a1837f0d/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0d61795defc83fd696971880d60f438a1837f0d/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=c0d61795defc83fd696971880d60f438a1837f0d", "patch": "@@ -1,11 +1,141 @@\n /*\n- * Region resolution. This pass runs before typechecking and resolves region\n- * names to the appropriate block.\n- */\n+\n+Region resolution. This pass runs before typechecking and resolves region\n+names to the appropriate block.\n+\n+This seems to be as good a place as any to explain in detail how\n+region naming, representation, and type check works.\n+\n+### Naming and so forth\n+\n+We really want regions to be very lightweight to use. Therefore,\n+unlike other named things, the scopes for regions are not explicitly\n+declared: instead, they are implicitly defined.  Functions declare new\n+scopes: if the function is not a bare function, then as always it\n+inherits the names in scope from the outer scope.  Within a function\n+declaration, new names implicitly declare new region variables.  Outside\n+of function declarations, new names are illegal.  To make this more\n+concrete, here is an example:\n+\n+    fn foo(s: &a.S, t: &b.T) {\n+        let s1: &a.S = s; // a refers to the same a as in the decl\n+        let t1: &c.T = t; // illegal: cannot introduce new name here\n+    }\n+\n+The code in this file is what actually handles resolving these names.\n+It creates a couple of maps that map from the AST node representing a\n+region ptr type to the resolved form of its region parameter.  If new\n+names are introduced where they shouldn't be, then an error is\n+reported.\n+\n+If regions are not given an explicit name, then the behavior depends\n+a bit on the context.  Within a function declaration, all unnamed regions\n+are mapped to a single, anonymous parameter.  That is, a function like:\n+\n+    fn foo(s: &S) -> &S { s }\n+\n+is equivalent to a declaration like:\n+\n+    fn foo(s: &a.S) -> &a.S { s }\n+\n+Within a function body or other non-binding context, an unnamed region\n+reference is mapped to a fresh region variable whose value can be\n+inferred as normal.\n+\n+The resolved form of regions is `ty::region`.  Before I can explain\n+why this type is setup the way it is, I have to digress a little bit\n+into some ill-explained type theory.\n+\n+### Universal Quantification\n+\n+Regions are more complex than type parameters because, unlike type\n+parameters, they can be universally quantified within a type.  To put\n+it another way, you cannot (at least at the time of this writing) have\n+a variable `x` of type `fn<T>(T) -> T`.  You can have an *item* of\n+type `fn<T>(T) - T`, but whenever it is referenced within a method,\n+that type parameter `T` is replaced with a concrete type *variable*\n+`$T`.  To make this more concrete, imagine this code:\n+\n+    fn identity<T>(x: T) -> T { x }\n+    let f = identity; // f has type fn($T) -> $T\n+    f(3u); // $T is bound to uint\n+    f(3);  // Type error\n+\n+You can see here that a type error will result because the type of `f`\n+(as opposed to the type of `identity`) is not universally quantified\n+over `$T`.  That's fancy math speak for saying that the type variable\n+`$T` refers to a specific type that may not yet be known, unlike the\n+type parameter `T` which refers to some type which will never be\n+known.\n+\n+Anyway, regions work differently.  If you have an item of type\n+`fn(&a.T) -> &a.T` and you reference it, its type remains the same:\n+only when the function *is called* is `&a` instantiated with a\n+concrete region variable.  This means you could call it twice and give\n+different values for `&a` each time.\n+\n+This more general form is possible for regions because they do not\n+impact code generation.  We do not need to monomorphize functions\n+differently just because they contain region pointers.  In fact, we\n+don't really do *anything* differently.\n+\n+### Representing regions; or, why do I care about all that?\n+\n+The point of this discussion is that the representation of regions\n+must distinguish between a *bound* reference to a region and a *free*\n+reference.  A bound reference is one which will be replaced with a\n+fresh type variable when the function is called, like the type\n+parameter `T` in `identity`.  They can only appear within function\n+types.  A free reference is a region that may not yet be concretely\n+known, like the variable `$T`.\n+\n+To see why we must distinguish them carefully, consider this program:\n+\n+    fn item1(s: &a.S) {\n+        let choose = fn@(s1: &a.S) -> &a.S {\n+            if some_cond { s } else { s1 }\n+        };\n+    }\n+\n+Here, the variable `s1: &a.S` that appears within the `fn@` is a free\n+reference to `a`.  That is, when you call `choose()`, you don't\n+replace `&a` with a fresh region variable, but rather you expect `s1`\n+to be in the same region as the parameter `s`.\n+\n+But in this program, this is not the case at all:\n+\n+    fn item2() {\n+        let identity = fn@(s1: &a.S) -> &a.S { s1 };\n+    }\n+\n+To distinguish between these two cases, `ty::region` contains two\n+variants: `re_bound` and `re_free`.  In `item1()`, the outer reference\n+to `&a` would be `re_bound(rid_param(\"a\", 0u))`, and the inner reference\n+would be `re_free(rid_param(\"a\", 0u))`.  In `item2()`, the inner reference\n+would be `re_bound(rid_param(\"a\", 0u))`.\n+\n+#### Impliciations for typeck\n+\n+In typeck, whenever we call a function, we must go over and replace\n+all references to `re_bound()` regions within its parameters with\n+fresh type variables (we do not, however, replace bound regions within\n+nested function types, as those nested functions have not yet been\n+called).\n+\n+Also, when we typecheck the *body* of an item, we must replace all\n+`re_bound` references with `re_free` references.  This means that the\n+region in the type of the argument `s` in `item1()` *within `item1()`*\n+is not `re_bound(re_param(\"a\", 0u))` but rather `re_free(re_param(\"a\",\n+0u))`.  This is because, for any particular *invocation of `item1()`*,\n+`&a` will be bound to some specific region, and hence it is no longer\n+bound.\n+\n+*/\n \n import driver::session::session;\n import middle::ty;\n import syntax::{ast, visit};\n+import syntax::codemap::span;\n import util::common::new_def_hash;\n \n import std::list;\n@@ -23,10 +153,9 @@ enum parent {\n }\n \n /* Records the parameter ID of a region name. */\n-type binding = {\n-    name: str,\n-    id: uint\n-};\n+type binding = {node_id: ast::node_id,\n+                name: str,\n+                br: ty::bound_region};\n \n type region_map = {\n     /* Mapping from a block/function expression to its parent. */\n@@ -44,11 +173,105 @@ type region_map = {\n     rvalue_to_block: hashmap<ast::node_id,ast::node_id>\n };\n \n+type region_scope = @{\n+    node_id: ast::node_id,\n+    kind: region_scope_kind\n+};\n+\n+enum region_scope_kind {\n+    rsk_root,\n+    rsk_body(region_scope),\n+    rsk_self(region_scope),\n+    rsk_binding(region_scope, @mut [binding])\n+}\n+\n+fn root_scope(node_id: ast::node_id) -> region_scope {\n+    @{node_id: node_id, kind: rsk_root}\n+}\n+\n+impl methods for region_scope {\n+    fn body_subscope(node_id: ast::node_id) -> region_scope {\n+        @{node_id: node_id, kind: rsk_body(self)}\n+    }\n+\n+    fn binding_subscope(node_id: ast::node_id) -> region_scope {\n+        @{node_id: node_id, kind: rsk_binding(self, @mut [])}\n+    }\n+\n+    fn self_subscope(node_id: ast::node_id) -> region_scope {\n+        @{node_id: node_id, kind: rsk_self(self)}\n+    }\n+\n+    fn find(nm: str) -> option<binding> {\n+        alt self.kind {\n+          rsk_root { none }\n+          rsk_body(parent) { parent.find(nm) }\n+          rsk_self(parent) { parent.find(nm) }\n+          rsk_binding(parent, bs) {\n+            alt (*bs).find({|b| b.name == nm }) {\n+              none { parent.find(nm) }\n+              some(b) { some(b) }\n+            }\n+          }\n+        }\n+    }\n+\n+    // fn resolve_anon() -> option<ty::region> {\n+    //     alt self.kind {\n+    //       rsk_root { none }\n+    //       rsk_body(_) { none }\n+    //       rsk_self(_) { none }\n+    //       rsk_binding(_, _) { ty::re_bound(ty::br_anon) }\n+    //     }\n+    // }\n+\n+    fn resolve_self_helper(bound: bool) -> option<ty::region> {\n+        alt self.kind {\n+          rsk_root { none }\n+          rsk_self(_) if bound { some(ty::re_bound(ty::br_self)) }\n+          rsk_self(_) { some(ty::re_free(self.node_id, ty::br_self)) }\n+          rsk_binding(p, _) { p.resolve_self_helper(bound) }\n+          rsk_body(p) { p.resolve_self_helper(false) }\n+        }\n+    }\n+\n+    fn resolve_self() -> option<ty::region> {\n+        self.resolve_self_helper(true)\n+    }\n+\n+    fn resolve_ident(nm: str) -> option<ty::region> {\n+        alt self.find(nm) {\n+          some(b) if b.node_id == self.node_id {\n+            some(ty::re_bound(b.br))\n+          }\n+\n+          some(b) {\n+            some(ty::re_free(b.node_id, b.br))\n+          }\n+\n+          none {\n+            alt self.kind {\n+              rsk_self(_) | rsk_root | rsk_body(_) { none }\n+              rsk_binding(_, bs) {\n+                let idx = (*bs).len();\n+                let br = ty::br_param(idx, nm);\n+                vec::push(*bs, {node_id: self.node_id,\n+                                name: nm,\n+                                br: br});\n+                some(ty::re_bound(br))\n+              }\n+            }\n+          }\n+        }\n+    }\n+}\n+\n type ctxt = {\n     sess: session,\n     def_map: resolve::def_map,\n     region_map: @region_map,\n-    mut bindings: @list<binding>,\n+\n+    scope: region_scope,\n \n     /*\n      * A list of local IDs that will be parented to the next block we\n@@ -63,9 +286,6 @@ type ctxt = {\n     /* True if we're within the pattern part of an alt, false otherwise. */\n     in_alt: bool,\n \n-    /* True if we're within a typeclass implementation, false otherwise. */\n-    in_typeclass: bool,\n-\n     /* The next parameter ID. */\n     mut next_param_id: uint\n };\n@@ -108,16 +328,28 @@ fn nearest_common_ancestor(region_map: @region_map, scope_a: ast::node_id,\n     let b_ancestors = ancestors_of(region_map, scope_b);\n     let mut a_index = vec::len(a_ancestors) - 1u;\n     let mut b_index = vec::len(b_ancestors) - 1u;\n-    while a_ancestors[a_index] == b_ancestors[b_index] {\n+\n+    // Here, [ab]_ancestors is a vector going from narrow to broad.\n+    // The end of each vector will be the item where the scope is\n+    // defined; if there are any common ancestors, then the tails of\n+    // the vector will be the same.  So basically we want to walk\n+    // backwards from the tail of each vector and find the first point\n+    // where they diverge.  If one vector is a suffix of the other,\n+    // then the corresponding scope is a superscope of the other.\n+\n+    loop {\n+        if a_ancestors[a_index] != b_ancestors[b_index] {\n+            if a_index == a_ancestors.len() {\n+                ret none;\n+            } else {\n+                ret some(a_ancestors[a_index + 1u]);\n+            }\n+        }\n+        if a_index == 0u { ret some(scope_a); }\n+        if b_index == 0u { ret some(scope_b); }\n         a_index -= 1u;\n         b_index -= 1u;\n     }\n-\n-    if a_index == vec::len(a_ancestors) {\n-        ret none;\n-    }\n-\n-    ret some(a_ancestors[a_index + 1u]);\n }\n \n fn get_inferred_region(cx: ctxt, sp: syntax::codemap::span) -> ty::region {\n@@ -127,14 +359,51 @@ fn get_inferred_region(cx: ctxt, sp: syntax::codemap::span) -> ty::region {\n     // TODO: What do we do if we're in an alt?\n \n     ret alt cx.parent {\n-        pa_fn_item(_) | pa_nested_fn(_) {\n-            let id = cx.next_param_id;\n-            cx.next_param_id += 1u;\n-            ty::re_param(id)\n+      pa_fn_item(_) | pa_nested_fn(_) { ty::re_bound(ty::br_anon) }\n+      pa_block(block_id) { ty::re_scope(block_id) }\n+      pa_item(_) { ty::re_bound(ty::br_anon) }\n+      pa_crate { cx.sess.span_bug(sp, \"inferred region at crate level?!\"); }\n+    }\n+}\n+\n+fn resolve_region_binding(cx: ctxt, span: span, region: ast::region) {\n+\n+    let id = region.id;\n+    let rm = cx.region_map;\n+    alt region.node {\n+      ast::re_inferred {\n+        // option::may(cx.scope.resolve_anon()) {|r|\n+        //     rm.ast_type_to_region.insert(id, r);\n+        // }\n+      }\n+\n+      ast::re_named(ident) {\n+        alt cx.scope.resolve_ident(ident) {\n+          some(r) {\n+            rm.ast_type_to_region.insert(id, r);\n+          }\n+\n+          none {\n+            cx.sess.span_err(\n+                span,\n+                #fmt[\"the region `%s` is not declared\", ident]);\n+          }\n+        }\n+      }\n+\n+      ast::re_self {\n+        alt cx.scope.resolve_self() {\n+          some(r) {\n+            rm.ast_type_to_region.insert(id, r);\n+          }\n+\n+          none {\n+            cx.sess.span_err(\n+                span,\n+                \"the `self` region is not allowed here\");\n+          }\n         }\n-        pa_block(block_id) { ty::re_block(block_id) }\n-        pa_item(_) { ty::re_param(0u) }\n-        pa_crate { cx.sess.span_bug(sp, \"inferred region at crate level?!\"); }\n+      }\n     }\n }\n \n@@ -143,65 +412,10 @@ fn resolve_ty(ty: @ast::ty, cx: ctxt, visitor: visit::vt<ctxt>) {\n     cx.region_map.ast_type_to_inferred_region.insert(ty.id, inferred_region);\n \n     alt ty.node {\n-        ast::ty_rptr({id: region_id, node: node}, _) {\n-            alt node {\n-                ast::re_inferred { /* no-op */ }\n-                ast::re_self {\n-                    if cx.in_typeclass {\n-                        let r = ty::re_self;\n-                        let rm = cx.region_map;\n-                        rm.ast_type_to_region.insert(region_id, r);\n-                    } else {\n-                        cx.sess.span_err(ty.span,\n-                                         \"the `self` region is not allowed \\\n-                                          here\");\n-                    }\n-                }\n-                ast::re_named(ident) {\n-                    // If at item scope, introduce or reuse a binding. If at\n-                    // block scope, require that the binding be introduced.\n-                    let bindings = cx.bindings;\n-                    let mut region;\n-                    alt list::find(*bindings, {|b| ident == b.name}) {\n-                        some(binding) { region = ty::re_param(binding.id); }\n-                        none {\n-                            let id = cx.next_param_id;\n-                            let binding = {name: ident, id: id};\n-                            cx.next_param_id += 1u;\n-\n-                            cx.bindings = @list::cons(binding, cx.bindings);\n-                            region = ty::re_param(id);\n-\n-                            alt cx.parent {\n-                                pa_fn_item(fn_id) | pa_nested_fn(fn_id) {\n-                                    /* ok */\n-                                }\n-                                pa_item(_) {\n-                                    cx.sess.span_err(ty.span,\n-                                                     \"named region not \" +\n-                                                     \"allowed in this \" +\n-                                                     \"context\");\n-                                }\n-                                pa_block(_) {\n-                                    cx.sess.span_err(ty.span,\n-                                                     \"unknown region `\" +\n-                                                     ident + \"`\");\n-                                }\n-                                pa_crate {\n-                                    cx.sess.span_bug(ty.span, \"named \" +\n-                                                     \"region at crate \" +\n-                                                     \"level?!\");\n-                                }\n-                            }\n-                        }\n-                    }\n-\n-                    let ast_type_to_region = cx.region_map.ast_type_to_region;\n-                    ast_type_to_region.insert(region_id, region);\n-                }\n-            }\n-        }\n-        _ { /* nothing to do */ }\n+      ast::ty_rptr(r, _) {\n+        resolve_region_binding(cx, ty.span, r);\n+      }\n+      _ { /* nothing to do */ }\n     }\n \n     visit::visit_ty(ty, cx, visitor);\n@@ -230,6 +444,7 @@ fn resolve_block(blk: ast::blk, cx: ctxt, visitor: visit::vt<ctxt>) {\n \n     // Descend.\n     let new_cx: ctxt = {parent: pa_block(blk.node.id),\n+                        scope: cx.scope.body_subscope(blk.node.id),\n                         mut queued_locals: [],\n                         in_alt: false with cx};\n     visit::visit_block(blk, new_cx, visitor);\n@@ -282,6 +497,7 @@ fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n         ast::expr_fn(_, _, _, _) | ast::expr_fn_block(_, _) {\n             record_parent(cx, expr.id);\n             let new_cx = {parent: pa_nested_fn(expr.id),\n+                          scope: cx.scope.binding_subscope(expr.id),\n                           in_alt: false with cx};\n             visit::visit_expr(expr, new_cx, visitor);\n         }\n@@ -312,27 +528,26 @@ fn resolve_local(local: @ast::local, cx: ctxt, visitor: visit::vt<ctxt>) {\n \n fn resolve_item(item: @ast::item, cx: ctxt, visitor: visit::vt<ctxt>) {\n     // Items create a new outer block scope as far as we're concerned.\n-    let mut parent;\n-    let mut in_typeclass;\n-    alt item.node {\n-        ast::item_fn(_, _, _) | ast::item_enum(_, _) {\n-            parent = pa_fn_item(item.id);\n-            in_typeclass = false;\n-        }\n-        ast::item_impl(_, _, _, _) {\n-            parent = pa_item(item.id);\n-            in_typeclass = true;\n-        }\n-        _ {\n-            parent = pa_item(item.id);\n-            in_typeclass = false;\n+    let {parent, scope} = {\n+        alt item.node {\n+          ast::item_fn(_, _, _) | ast::item_enum(_, _) {\n+            {parent: pa_fn_item(item.id),\n+             scope: cx.scope.binding_subscope(item.id)}\n+          }\n+          ast::item_impl(_, _, _, _) | ast::item_class(_, _, _) {\n+            {parent: pa_item(item.id),\n+             scope: cx.scope.self_subscope(item.id)}\n+          }\n+          _ {\n+            {parent: pa_item(item.id),\n+             scope: root_scope(item.id)}\n+          }\n         }\n     };\n \n-    let new_cx: ctxt = {bindings: @list::nil,\n-                        parent: parent,\n+    let new_cx: ctxt = {parent: parent,\n+                        scope: scope,\n                         in_alt: false,\n-                        in_typeclass: in_typeclass,\n                         mut next_param_id: 0u\n                         with cx};\n \n@@ -349,11 +564,10 @@ fn resolve_crate(sess: session, def_map: resolve::def_map, crate: @ast::crate)\n                                   ast_type_to_inferred_region:\n                                     map::int_hash(),\n                                   rvalue_to_block: map::int_hash()},\n-                    mut bindings: @list::nil,\n+                    scope: root_scope(0),\n                     mut queued_locals: [],\n                     parent: pa_crate,\n                     in_alt: false,\n-                    in_typeclass: false,\n                     mut next_param_id: 0u};\n     let visitor = visit::mk_vt(@{\n         visit_block: resolve_block,"}, {"sha": "611f010ae1060e5d61bfbf9e28a6a872e7e9c160", "filename": "src/rustc/middle/regionck.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c0d61795defc83fd696971880d60f438a1837f0d/src%2Frustc%2Fmiddle%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0d61795defc83fd696971880d60f438a1837f0d/src%2Frustc%2Fmiddle%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregionck.rs?ref=c0d61795defc83fd696971880d60f438a1837f0d", "patch": "@@ -26,38 +26,38 @@ fn check_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n     if ty::type_has_rptrs(t) {\n         ty::walk_ty(t) { |t|\n             alt ty::get(t).struct {\n-                ty::ty_rptr(region, _) {\n-                    alt region {\n-                        ty::re_self | ty::re_inferred | ty::re_param(_) {\n-                            /* ok */\n-                        }\n-                        ty::re_block(rbi) {\n-                            let referent_block_id = rbi;\n-                            let enclosing_block_id = alt cx.enclosing_block {\n-                                none {\n-                                    cx.tcx.sess.span_bug(expr.span,\n-                                                         \"block region \" +\n-                                                         \"type outside a \" +\n-                                                         \"block?!\");\n-                                }\n-                                some(eb) { eb }\n-                            };\n+              ty::ty_rptr(region, _) {\n+                alt region {\n+                  ty::re_bound(_) | ty::re_free(_, _) {\n+                    /* ok */\n+                  }\n+                  ty::re_scope(rbi) {\n+                    let referent_block_id = rbi;\n+                    let enclosing_block_id = alt cx.enclosing_block {\n+                      none {\n+                        cx.tcx.sess.span_bug(expr.span,\n+                                             \"block region \" +\n+                                             \"type outside a \" +\n+                                             \"block?!\");\n+                      }\n+                      some(eb) { eb }\n+                    };\n \n-                            if !region::scope_contains(cx.tcx.region_map,\n-                                                       referent_block_id,\n-                                                       enclosing_block_id) {\n+                    if !region::scope_contains(cx.tcx.region_map,\n+                                               referent_block_id,\n+                                               enclosing_block_id) {\n \n-                                cx.tcx.sess.span_err(expr.span, \"reference \" +\n-                                                     \"escapes its block\");\n-                            }\n-                        }\n-                        ty::re_var(_) {\n-                            cx.tcx.sess.span_bug(expr.span,\n-                                                 \"unresolved region\");\n-                        }\n+                        cx.tcx.sess.span_err(expr.span, \"reference \" +\n+                                             \"escapes its block\");\n                     }\n+                  }\n+                  ty::re_default | ty::re_var(_) {\n+                    cx.tcx.sess.span_bug(expr.span,\n+                                         \"unresolved region\");\n+                  }\n                 }\n-                _ { /* no-op */ }\n+              }\n+              _ { /* no-op */ }\n             }\n         }\n     }"}, {"sha": "49efb8a00cc29f861ad8fab92475bc502829dff7", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0d61795defc83fd696971880d60f438a1837f0d/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0d61795defc83fd696971880d60f438a1837f0d/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=c0d61795defc83fd696971880d60f438a1837f0d", "patch": "@@ -641,7 +641,7 @@ fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n           _ { typ }\n         }\n     }\n-    ty::fold_ty(tcx, ty::fm_general(bind simplifier(tcx, _)), typ)\n+    ty::fold_ty(tcx, typ) {|t| simplifier(tcx, t) }\n }\n \n // Given a tag type `ty`, returns the offset of the payload."}, {"sha": "89c34064f6d19c508851315348e022fcc50d0b35", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 174, "deletions": 272, "changes": 446, "blob_url": "https://github.com/rust-lang/rust/blob/c0d61795defc83fd696971880d60f438a1837f0d/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0d61795defc83fd696971880d60f438a1837f0d/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=c0d61795defc83fd696971880d60f438a1837f0d", "patch": "@@ -15,6 +15,8 @@ import util::ppaux::ty_to_str;\n import util::ppaux::ty_constr_to_str;\n import syntax::print::pprust::*;\n \n+export ty_vid, region_vid, vid;\n+export br_hashmap;\n export is_instantiable;\n export node_id_to_type;\n export node_id_to_type_params;\n@@ -33,12 +35,11 @@ export expr_ty;\n export expr_ty_params_and_ty;\n export expr_is_lval;\n export field_ty;\n-export fold_ty;\n+export fold_ty, fold_sty_to_ty, fold_region, fold_ty_var;\n export field;\n export field_idx;\n export get_field;\n export get_fields;\n-export fm_var, fm_general, fm_rptr;\n export get_element_type;\n export is_binopable;\n export is_pred_ty;\n@@ -93,7 +94,7 @@ export ty_uint, mk_uint, mk_mach_uint;\n export ty_uniq, mk_uniq, mk_imm_uniq, type_is_unique_box;\n export ty_var, mk_var;\n export ty_self, mk_self;\n-export region, re_block, re_param, re_var;\n+export region, bound_region;\n export get, type_has_params, type_has_vars, type_has_rptrs, type_id;\n export ty_var_id;\n export ty_to_def_id;\n@@ -127,7 +128,6 @@ export resolved_mode;\n export arg_mode;\n export unify_mode;\n export set_default_mode;\n-export unify;\n export variant_info;\n export walk_ty, maybe_walk_ty;\n export occurs_check;\n@@ -261,20 +261,25 @@ type fn_ty = {proto: ast::proto,\n               ret_style: ret_style,\n               constraints: [@constr]};\n \n+// See discussion at head of region.rs\n enum region {\n-    // The region of a block.\n-    re_block(node_id),\n-    // The self region. Only valid inside classes and typeclass\n-    // implementations.\n-    re_self,\n-    // The inferred region, which also corresponds to &self in typedefs.\n-    re_inferred,\n+    re_bound(bound_region),\n+    re_free(node_id, bound_region),\n+    re_scope(node_id),\n+    re_var(region_vid),\n+    re_default\n+}\n+\n+enum bound_region {\n+    // The `self` region for a given class/impl/iface.  The defining item may\n+    // appear in another crate.\n+    br_self,\n \n-    // A region parameter.\n-    re_param(uint),\n+    // The anonymous region parameter for a given function.\n+    br_anon,\n \n-    // A region variable.\n-    re_var(uint)\n+    // A named region parameter.\n+    br_param(uint, str)\n }\n \n // NB: If you change this, you'll probably want to change the corresponding\n@@ -300,7 +305,7 @@ enum sty {\n     ty_res(def_id, t, [t]),\n     ty_tup([t]),\n \n-    ty_var(int), // type variable during typechecking\n+    ty_var(ty_vid), // type variable during typechecking\n     ty_param(uint, def_id), // type parameter\n     ty_self([t]), // interface method self type\n \n@@ -344,6 +349,24 @@ enum param_bound {\n     bound_iface(t),\n }\n \n+enum ty_vid = uint;\n+enum region_vid = uint;\n+\n+iface vid {\n+    fn to_uint() -> uint;\n+    fn to_str() -> str;\n+}\n+\n+impl of vid for ty_vid {\n+    fn to_uint() -> uint { *self }\n+    fn to_str() -> str { #fmt[\"<V%u>\", self.to_uint()] }\n+}\n+\n+impl of vid for region_vid {\n+    fn to_uint() -> uint { *self }\n+    fn to_str() -> str { #fmt[\"<R%u>\", self.to_uint()] }\n+}\n+\n fn param_bounds_to_kind(bounds: param_bounds) -> kind {\n     let mut kind = kind_noncopyable;\n     for bound in *bounds {\n@@ -443,7 +466,11 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n       ty_box(m) | ty_uniq(m) | ty_vec(m) | ty_ptr(m) {\n         derive_flags(has_params, has_vars, has_rptrs, m.ty);\n       }\n-      ty_rptr(_, m) {\n+      ty_rptr(r, m) {\n+        alt r {\n+          ty::re_var(_) { has_vars = true; }\n+          _ { }\n+        }\n         has_rptrs = true;\n         derive_flags(has_params, has_vars, has_rptrs, m.ty);\n       }\n@@ -555,7 +582,7 @@ fn mk_res(cx: ctxt, did: ast::def_id, inner: t, tps: [t]) -> t {\n     mk_t(cx, ty_res(did, inner, tps))\n }\n \n-fn mk_var(cx: ctxt, v: int) -> t { mk_t(cx, ty_var(v)) }\n+fn mk_var(cx: ctxt, v: ty_vid) -> t { mk_t(cx, ty_var(v)) }\n \n fn mk_self(cx: ctxt, tps: [t]) -> t { mk_t(cx, ty_self(tps)) }\n \n@@ -622,146 +649,124 @@ fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n     }\n }\n \n-enum fold_mode {\n-    fm_var(fn@(int) -> t),\n-    fm_param(fn@(uint, def_id) -> t),\n-    fm_rptr(fn@(region, bool /* under & */) -> region,\n-            bool /* descend into outermost fn */),\n-    fm_general(fn@(t) -> t),\n+fn fold_sty_to_ty(tcx: ty::ctxt, sty: sty, foldop: fn(t) -> t) -> t {\n+    mk_t(tcx, fold_sty(sty, foldop))\n+}\n+\n+fn fold_sty(sty: sty, fldop: fn(t) -> t) -> sty {\n+    alt sty {\n+      ty_box(tm) {\n+        ty_box({ty: fldop(tm.ty), mutbl: tm.mutbl})\n+      }\n+      ty_uniq(tm) {\n+        ty_uniq({ty: fldop(tm.ty), mutbl: tm.mutbl})\n+      }\n+      ty_ptr(tm) {\n+        ty_ptr({ty: fldop(tm.ty), mutbl: tm.mutbl})\n+      }\n+      ty_vec(tm) {\n+        ty_vec({ty: fldop(tm.ty), mutbl: tm.mutbl})\n+      }\n+      ty_enum(tid, subtys) {\n+        ty_enum(tid, vec::map(subtys) {|t| fldop(t) })\n+      }\n+      ty_iface(did, subtys) {\n+        ty_iface(did, vec::map(subtys) {|t| fldop(t) })\n+      }\n+      ty_self(subtys) {\n+        ty_self(vec::map(subtys) {|t| fldop(t) })\n+      }\n+      ty_rec(fields) {\n+        let new_fields = vec::map(fields) {|fl|\n+            let new_ty = fldop(fl.mt.ty);\n+            let new_mt = {ty: new_ty, mutbl: fl.mt.mutbl};\n+            {ident: fl.ident, mt: new_mt}\n+        };\n+        ty_rec(new_fields)\n+      }\n+      ty_tup(ts) {\n+        let new_ts = vec::map(ts) {|tt| fldop(tt) };\n+        ty_tup(new_ts)\n+      }\n+      ty_fn(f) {\n+        let new_args = vec::map(f.inputs) {|a|\n+            let new_ty = fldop(a.ty);\n+            {mode: a.mode, ty: new_ty}\n+        };\n+        let new_output = fldop(f.output);\n+        ty_fn({inputs: new_args, output: new_output with f})\n+      }\n+      ty_res(did, subty, tps) {\n+        let new_tps = vec::map(tps) {|ty| fldop(ty) };\n+        ty_res(did, fldop(subty), new_tps)\n+      }\n+      ty_rptr(r, tm) {\n+        ty_rptr(r, {ty: fldop(tm.ty), mutbl: tm.mutbl})\n+      }\n+      ty_constr(subty, cs) {\n+        ty_constr(fldop(subty), cs)\n+      }\n+      ty_class(did, tps) {\n+        let new_tps = vec::map(tps) {|ty| fldop(ty) };\n+        ty_class(did, new_tps)\n+      }\n+      ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n+      ty_str | ty_type | ty_opaque_closure_ptr(_) |\n+      ty_opaque_box | ty_var(_) | ty_param(_, _) {\n+        sty\n+      }\n+    }\n }\n \n-fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n-    fn do_fold(cx: ctxt, fld: fold_mode, ty_0: t, under_rptr: bool) -> t {\n-        let mut ty = ty_0;\n+// Folds types from the bottom up.\n+fn fold_ty(cx: ctxt, t0: t, fldop: fn(t) -> t) -> t {\n+    let sty = fold_sty(get(t0).struct) {|t| fold_ty(cx, t, fldop) };\n+    fldop(mk_t(cx, sty))\n+}\n \n-        let tb = get(ty);\n-        alt fld {\n-          fm_var(_) { if !tb.has_vars { ret ty; } }\n-          fm_param(_) { if !tb.has_params { ret ty; } }\n-          fm_rptr(_,_) { if !tb.has_rptrs { ret ty; } }\n-          fm_general(_) {/* no fast path */ }\n-        }\n+fn fold_ty_var(cx: ctxt, t0: t, fldop: fn(ty_vid) -> t) -> t {\n+    let tb = get(t0);\n+    if !tb.has_vars { ret t0; }\n+    alt tb.struct {\n+      ty_var(id) { fldop(id) }\n+      sty { fold_sty_to_ty(cx, sty) {|t| fold_ty_var(cx, t, fldop) } }\n+    }\n+}\n \n+fn fold_region(cx: ctxt, t0: t, fldop: fn(region, bool) -> region) -> t {\n+    fn do_fold(cx: ctxt, t0: t, under_r: bool,\n+               fldop: fn(region, bool) -> region) -> t {\n+        let tb = get(t0);\n+        if !tb.has_rptrs { ret t0; }\n         alt tb.struct {\n-          ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-          ty_str | ty_type | ty_opaque_closure_ptr(_) |\n-          ty_opaque_box {}\n-          ty_box(tm) {\n-            ty = mk_box(cx, {ty: do_fold(cx, fld, tm.ty, under_rptr),\n-                             mutbl: tm.mutbl});\n-          }\n-          ty_uniq(tm) {\n-            ty = mk_uniq(cx, {ty: do_fold(cx, fld, tm.ty, under_rptr),\n-                              mutbl: tm.mutbl});\n-          }\n-          ty_ptr(tm) {\n-            ty = mk_ptr(cx, {ty: do_fold(cx, fld, tm.ty, under_rptr),\n-                             mutbl: tm.mutbl});\n-          }\n-          ty_vec(tm) {\n-            ty = mk_vec(cx, {ty: do_fold(cx, fld, tm.ty, under_rptr),\n-                             mutbl: tm.mutbl});\n+          ty_rptr(r, {ty: t1, mutbl: m}) {\n+            let m_r = fldop(r, under_r);\n+            let m_t1 = do_fold(cx, t1, true, fldop);\n+            ty::mk_rptr(cx, m_r, {ty: m_t1, mutbl: m})\n           }\n-          ty_enum(tid, subtys) {\n-            ty = mk_enum(cx, tid,\n-                         vec::map(subtys, {|t|\n-                            do_fold(cx, fld, t, under_rptr)\n-                         }));\n+          ty_fn(_) {\n+            // do not recurse into functions, which introduce fresh bindings\n+            t0\n           }\n-          ty_iface(did, subtys) {\n-            ty = mk_iface(cx, did,\n-                          vec::map(subtys, {|t|\n-                              do_fold(cx, fld, t, under_rptr)\n-                          }));\n-          }\n-          ty_self(subtys) {\n-            ty = mk_self(cx, vec::map(subtys, {|t|\n-                                do_fold(cx, fld, t, under_rptr)\n-                             }));\n-          }\n-          ty_rec(fields) {\n-            let mut new_fields: [field] = [];\n-            for fl: field in fields {\n-                let new_ty = do_fold(cx, fld, fl.mt.ty, under_rptr);\n-                let new_mt = {ty: new_ty, mutbl: fl.mt.mutbl};\n-                new_fields += [{ident: fl.ident, mt: new_mt}];\n-            }\n-            ty = mk_rec(cx, new_fields);\n-          }\n-          ty_tup(ts) {\n-            let mut new_ts = [];\n-            for tt in ts { new_ts += [do_fold(cx, fld, tt, under_rptr)]; }\n-            ty = mk_tup(cx, new_ts);\n-          }\n-          ty_fn(f) {\n-            let mut new_fld;\n-            alt fld {\n-              fm_rptr(_, false) {\n-                // Don't recurse into functions, because regions are\n-                // universally quantified, well, universally, at function\n-                // boundaries.\n-                ret ty;\n-              }\n-              fm_rptr(f, true) {\n-                new_fld = fm_rptr(f, false);\n-              }\n-              _ { new_fld = fld; }\n-            }\n-\n-            let mut new_args: [arg] = [];\n-            for a: arg in f.inputs {\n-                let new_ty = do_fold(cx, new_fld, a.ty, under_rptr);\n-                new_args += [{mode: a.mode, ty: new_ty}];\n+          sty {\n+            fold_sty_to_ty(cx, sty) {|t|\n+                do_fold(cx, t, under_r, fldop)\n             }\n-            let new_output = do_fold(cx, new_fld, f.output, under_rptr);\n-            ty = mk_fn(cx, {inputs: new_args, output: new_output with f});\n-          }\n-          ty_res(did, subty, tps) {\n-            let mut new_tps = [];\n-            for tp: t in tps {\n-                new_tps += [do_fold(cx, fld, tp, under_rptr)];\n-            }\n-            ty = mk_res(cx, did, do_fold(cx, fld, subty, under_rptr),\n-                        new_tps);\n-          }\n-          ty_var(id) {\n-            alt fld { fm_var(folder) { ty = folder(id); } _ {/* no-op */ } }\n           }\n-          ty_param(id, did) {\n-            alt fld { fm_param(folder) { ty = folder(id, did); } _ {} }\n-          }\n-          ty_rptr(r, tm) {\n-            let region = alt fld {\n-                fm_rptr(folder, _) { folder(r, under_rptr) }\n-                _ { r }\n-            };\n-            ty = mk_rptr(cx, region,\n-                         {ty: do_fold(cx, fld, tm.ty, true),\n-                          mutbl: tm.mutbl});\n-          }\n-          ty_constr(subty, cs) {\n-              ty = mk_constr(cx, do_fold(cx, fld, subty, under_rptr), cs);\n-          }\n-          ty_class(did, ts) {\n-              ty = mk_class(cx, did, vec::map(ts, {|t|\n-                              do_fold(cx, fld, t, under_rptr)}));\n-          }\n-          _ {\n-              cx.sess.bug(\"unsupported sort of type in fold_ty\");\n-          }\n-        }\n-        alt tb.o_def_id {\n-          some(did) { ty = mk_t_with_id(cx, get(ty).struct, some(did)); }\n-          _ {}\n-        }\n-\n-        // If this is a general type fold, then we need to run it now.\n-        alt fld { fm_general(folder) { ret folder(ty); } _ { ret ty; } }\n+      }\n     }\n \n-    ret do_fold(cx, fld, ty_0, false);\n+    do_fold(cx, t0, false, fldop)\n }\n \n+fn substitute_type_params(cx: ctxt, substs: [ty::t], typ: t) -> t {\n+    let tb = get(typ);\n+    alt tb.struct {\n+      ty_param(idx, _) { substs[idx] }\n+      _ if !tb.has_params { typ }\n+      s { mk_t(cx, fold_sty(s) {|t| substitute_type_params(cx, substs, t)}) }\n+    }\n+}\n \n // Type utilities\n \n@@ -1392,7 +1397,7 @@ fn type_param(ty: t) -> option<uint> {\n \n // Returns a vec of all the type variables\n // occurring in t. It may contain duplicates.\n-fn vars_in_type(ty: t) -> [int] {\n+fn vars_in_type(ty: t) -> [ty_vid] {\n     let mut rslt = [];\n     walk_ty(ty) {|ty|\n         alt get(ty).struct { ty_var(v) { rslt += [v]; } _ { } }\n@@ -1421,6 +1426,19 @@ fn type_autoderef(cx: ctxt, t: t) -> t {\n     ret t1;\n }\n \n+fn hash_bound_region(br: bound_region) -> uint {\n+    alt br { // no idea if this is any good\n+      br_self { 0u }\n+      br_anon { 1u }\n+      br_param(id, _) { id }\n+    }\n+}\n+\n+fn br_hashmap<V:copy>() -> hashmap<bound_region, V> {\n+    map::hashmap(hash_bound_region,\n+                 {|&&a: bound_region, &&b: bound_region| a == b })\n+}\n+\n // Type hashing.\n fn hash_type_structure(st: sty) -> uint {\n     fn hash_uint(id: uint, n: uint) -> uint { (id << 2u) + n }\n@@ -1448,12 +1466,13 @@ fn hash_type_structure(st: sty) -> uint {\n         h\n     }\n     fn hash_region(r: region) -> uint {\n-        alt r {\n-          re_block(_)   { 0u }\n-          re_self       { 1u }\n-          re_inferred   { 2u }\n-          re_param(_)   { 3u }\n-          re_var(_)     { 4u }\n+        alt r { // no idea if this is any good\n+          re_bound(br) { (hash_bound_region(br)) << 2u | 0u }\n+          re_free(id, br) { ((id as uint) << 4u) |\n+                               (hash_bound_region(br)) << 2u | 1u }\n+          re_scope(id)  { ((id as uint) << 2u) | 2u }\n+          re_var(id)    { (id.to_uint() << 2u) | 3u }\n+          re_default    { 4u }\n         }\n     }\n     alt st {\n@@ -1492,7 +1511,7 @@ fn hash_type_structure(st: sty) -> uint {\n         for a in f.inputs { h = hash_subty(h, a.ty); }\n         hash_subty(h, f.output)\n       }\n-      ty_var(v) { hash_uint(30u, v as uint) }\n+      ty_var(v) { hash_uint(30u, v.to_uint()) }\n       ty_param(pid, did) { hash_def(hash_uint(31u, pid), did) }\n       ty_self(ts) {\n         let mut h = 28u;\n@@ -1638,7 +1657,7 @@ fn is_pred_ty(fty: t) -> bool {\n     is_fn_ty(fty) && type_is_bool(ty_fn_ret(fty))\n }\n \n-fn ty_var_id(typ: t) -> int {\n+fn ty_var_id(typ: t) -> ty_vid {\n     alt get(typ).struct {\n       ty_var(vid) { ret vid; }\n       _ { #error(\"ty_var_id called on non-var ty\"); fail; }\n@@ -1727,7 +1746,7 @@ fn sort_methods(meths: [method]) -> [method] {\n     ret std::sort::merge_sort(bind method_lteq(_, _), meths);\n }\n \n-fn occurs_check(tcx: ctxt, sp: span, vid: int, rt: t) {\n+fn occurs_check(tcx: ctxt, sp: span, vid: ty_vid, rt: t) {\n     // Fast path\n     if !type_has_vars(rt) { ret; }\n \n@@ -1816,115 +1835,6 @@ fn set_default_mode(cx: ctxt, m: ast::mode, m_def: ast::rmode) {\n     }\n }\n \n-// Type unification via Robinson's algorithm (Robinson 1965). Implemented as\n-// described in Hoder and Voronkov:\n-//\n-//     http://www.cs.man.ac.uk/~hoderk/ubench/unification_full.pdf\n-mod unify {\n-    import result::{result, ok, err, chain, map, map2};\n-\n-    export mk_region_bindings;\n-    export region_bindings;\n-    export precise, in_region_bindings;\n-\n-    type ures<T> = result<T,type_err>;\n-\n-    type region_bindings =\n-        {sets: ufind::ufind, regions: smallintmap::smallintmap<region>};\n-\n-    enum unify_style {\n-        precise,\n-        in_region_bindings(@region_bindings)\n-    }\n-    type uctxt = {st: unify_style, tcx: ctxt};\n-\n-    fn mk_region_bindings() -> @region_bindings {\n-        ret @{sets: ufind::make(), regions: smallintmap::mk::<region>()};\n-    }\n-\n-    // Unifies two region sets.\n-    //\n-    // FIXME: This is a straight copy of the code above. We should use\n-    //        polymorphism to make this better.\n-    fn union_region_sets<T:copy>(\n-        cx: @uctxt, set_a: uint, set_b: uint,\n-        nxt: fn() -> ures<T>) -> ures<T> {\n-\n-        let rb = alt cx.st {\n-            in_region_bindings(rb) { rb }\n-            precise {\n-                cx.tcx.sess.bug(\"attempted to unify two region sets without \\\n-                                 a set of region bindings present\");\n-            }\n-        };\n-        ufind::grow(rb.sets, uint::max(set_a, set_b) + 1u);\n-        let root_a = ufind::find(rb.sets, set_a);\n-        let root_b = ufind::find(rb.sets, set_b);\n-\n-        let replace_region = (\n-            fn@(rb: @region_bindings, r: region) {\n-                ufind::union(rb.sets, set_a, set_b);\n-                let root_c: uint = ufind::find(rb.sets, set_a);\n-                smallintmap::insert(rb.regions, root_c, r);\n-            }\n-        );\n-\n-        alt smallintmap::find(rb.regions, root_a) {\n-          none {\n-            alt smallintmap::find(rb.regions, root_b) {\n-              none { ufind::union(rb.sets, set_a, set_b); ret nxt(); }\n-              some(r_b) { replace_region(rb, r_b); ret nxt(); }\n-            }\n-          }\n-          some(r_a) {\n-            alt smallintmap::find(rb.regions, root_b) {\n-              none { replace_region(rb, r_a); ret nxt(); }\n-              some(r_b) {\n-                ret unify_regions(cx, r_a, r_b) {|r_c|\n-                    replace_region(rb, r_c);\n-                    nxt()\n-                };\n-              }\n-            }\n-          }\n-        }\n-    }\n-\n-    fn record_region_binding<T:copy>(\n-        cx: @uctxt, key: uint,\n-        r: region,\n-        nxt: fn(region) -> ures<T>) -> ures<T> {\n-\n-        let rb = alt cx.st {\n-            in_region_bindings(rb) { rb }\n-            precise { fail; }\n-        };\n-\n-        ufind::grow(rb.sets, key + 1u);\n-        let root = ufind::find(rb.sets, key);\n-        let mut result_region = r;\n-        alt smallintmap::find(rb.regions, root) {\n-          some(old_region) {\n-            alt unify_regions(cx, old_region, r, {|v| ok(v)}) {\n-              ok(unified_region) { result_region = unified_region; }\n-              err(e) { ret err(e); }\n-            }\n-          }\n-          none {/* fall through */ }\n-        }\n-        smallintmap::insert(rb.regions, root, result_region);\n-\n-        // FIXME: This should be re_var instead.\n-        ret nxt(re_param(key));\n-    }\n-\n-    fn unify_regions<T:copy>(\n-            _cx: @uctxt, _e_region: region, _a_region: region,\n-            _nxt: fn(region) -> ures<T>) -> ures<T> {\n-        fail;   // unused\n-    }\n-}\n-\n fn type_err_to_str(cx: ctxt, err: type_err) -> str {\n     alt err {\n       terr_mismatch { ret \"types differ\"; }\n@@ -1995,14 +1905,6 @@ fn type_err_to_str(cx: ctxt, err: type_err) -> str {\n     }\n }\n \n-// Replaces type parameters in the given type using the given list of\n-// substitions.\n-fn substitute_type_params(cx: ctxt, substs: [ty::t], typ: t) -> t {\n-    if !type_has_params(typ) { ret typ; }\n-    // Precondition? idx < vec::len(substs)\n-    fold_ty(cx, fm_param({|idx, _id| substs[idx]}), typ)\n-}\n-\n fn def_has_ty_params(def: ast::def) -> bool {\n     alt def {\n       ast::def_fn(_, _) | ast::def_variant(_, _) | ast::def_class(_)"}, {"sha": "9fcef5055867e61f0174abdb5a63b6b689d217e1", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 337, "deletions": 285, "changes": 622, "blob_url": "https://github.com/rust-lang/rust/blob/c0d61795defc83fd696971880d60f438a1837f0d/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0d61795defc83fd696971880d60f438a1837f0d/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=c0d61795defc83fd696971880d60f438a1837f0d", "patch": "@@ -11,6 +11,7 @@ import pat_util::*;\n import middle::ty;\n import middle::ty::{arg, field, node_type_table, mk_nil,\n                     ty_param_bounds_and_ty, lookup_public_fields};\n+import middle::ty::{ty_vid, region_vid, vid};\n import util::ppaux::ty_to_str;\n import std::smallintmap;\n import std::smallintmap::map;\n@@ -49,13 +50,7 @@ type vtable_map = hashmap<ast::node_id, vtable_res>;\n \n type ty_table = hashmap<ast::def_id, ty::t>;\n \n-// Used for typechecking the methods of an impl\n-// first field is the self type, second is the ID for the \"self\" object\n-// that's currently in scope\n-enum self_info { self_impl(ty::t, ast::node_id) }\n-\n-type crate_ctxt = {mut self_infos: [self_info],\n-                   impl_map: resolve::impl_map,\n+type crate_ctxt = {impl_map: resolve::impl_map,\n                    method_map: method_map,\n                    vtable_map: vtable_map,\n                    // Not at all sure it's right to put these here\n@@ -73,15 +68,16 @@ type fn_ctxt =\n     // var_bindings, locals and next_var_id are shared\n     // with any nested functions that capture the environment\n     // (and with any functions whose environment is being captured).\n-    {ret_ty: ty::t,\n+    {self_ty: option<ty::t>,\n+     ret_ty: ty::t,\n      // Used by loop bodies that return from the outer function\n      indirect_ret_ty: option<ty::t>,\n      purity: ast::purity,\n      proto: ast::proto,\n      infcx: infer::infer_ctxt,\n-     locals: hashmap<ast::node_id, int>,\n-     next_var_id: @mut int,\n-     next_region_var_id: @mut int,\n+     locals: hashmap<ast::node_id, ty_vid>,\n+     next_var_id: @mut uint,\n+     next_region_var_id: @mut uint,\n \n      // While type checking a function, the intermediate types for the\n      // expressions, blocks, and so forth contained within the function are\n@@ -114,21 +110,14 @@ type fn_ctxt =\n // Determines whether the given node ID is a use of the def of\n // the self ID for the current method, if there is one\n fn self_ref(fcx: @fn_ctxt, id: ast::node_id) -> bool {\n-    let node_def = alt fcx.ccx.tcx.def_map.find(id) {\n-            none { ret false; }\n-            some(d) { d } };\n-    alt get_self_info(fcx.ccx) {\n-       some(self_impl(_, slf_def)) {\n-           alt node_def {\n-                   ast::def_self(slf_actual) { slf_def == slf_actual }\n-                   _ { false }\n-           }\n-       }\n-       none { false }\n+    // check what def `id` was resolved to (if anything)\n+    alt fcx.ccx.tcx.def_map.find(id) {\n+      some(ast::def_self(_)) { true }\n+      _ { false }\n     }\n }\n \n-fn lookup_local(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> int {\n+fn lookup_local(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> ty_vid {\n     alt fcx.locals.find(id) {\n       some(x) { x }\n       _ {\n@@ -163,12 +152,12 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n         ret {bounds: @[], ty: typ};\n       }\n       ast::def_self(_) {\n-        alt get_self_info(fcx.ccx) {\n-          some(self_impl(impl_t,_)) {\n-            ret {bounds: @[], ty: impl_t};\n+        alt fcx.self_ty {\n+          some(self_ty) {\n+            ret {bounds: @[], ty: self_ty};\n           }\n           none {\n-              fcx.ccx.tcx.sess.span_bug(sp, \"def_self with no self_info\");\n+              fcx.ccx.tcx.sess.span_bug(sp, \"def_self with no self_ty\");\n           }\n         }\n       }\n@@ -369,14 +358,16 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n             ty::mk_ptr(tcx, ast_mt_to_mt(tcx, mode, mt))\n           }\n           ast::ty_rptr(region, mt) {\n-            let region = alt region.node {\n-                ast::re_inferred { ty::re_inferred }\n-                ast::re_self { ty::re_self }\n-                ast::re_named(_) {\n-                    tcx.region_map.ast_type_to_region.get(region.id)\n-                }\n+            let r = alt region.node {\n+              ast::re_inferred {\n+                // this must be replaced later by a fixup_regions() pass\n+                ty::re_default\n+              }\n+              ast::re_self | ast::re_named(_) {\n+                tcx.region_map.ast_type_to_region.get(region.id)\n+              }\n             };\n-            ty::mk_rptr(tcx, region, ast_mt_to_mt(tcx, mode, mt))\n+            ty::mk_rptr(tcx, r, ast_mt_to_mt(tcx, mode, mt))\n           }\n           ast::ty_tup(fields) {\n             let flds = vec::map(fields, bind do_ast_ty_to_ty(tcx, mode, _));\n@@ -554,32 +545,75 @@ fn ty_of_native_item(tcx: ty::ctxt, mode: mode, it: @ast::native_item)\n \n type next_region_param_id = { mut id: uint };\n \n-fn fixup_regions(tcx: ty::ctxt, next_region_param_id: next_region_param_id,\n-                 ty: ty::t) -> ty::t {\n-    let cur_region_param = @mut next_region_param_id.id;\n-    ret ty::fold_ty(tcx, ty::fm_rptr({|region, under_rptr|\n-        alt region {\n-            ty::re_inferred {\n-                if !under_rptr {\n-                    *cur_region_param = next_region_param_id.id;\n-                    next_region_param_id.id += 1u;\n-                }\n-                ty::re_param(*cur_region_param)\n+// fn replace_inferred(tcx: ty::ctxt, ty: ty::t,\n+//                     rop: fn() -> ty::region) -> ty::t {\n+//     let tb = ty::get(ty);\n+//     if !tb.has_rptrs { ret ty; }\n+//     alt tb.struct {\n+//       // Replace re_inferred that are nested underneath\n+//       // a top-level region ptr with the region ptr itself.\n+//       ty::ty_rptr(ty::re_inferred, ty1) {\n+//         let r = rop();\n+//         ty::mk_rptr(r, replace_inferred(tcx, ty1) {|| r })\n+//       }\n+//       ty::ty_rptr(r, ty1) {\n+//         ty::mk_rptr(r, replace_inferred(tcx, ty1) {|| r })\n+//       }\n+//\n+//       // Do not replace inferred ptrs that appear within fn(...) types, as\n+//       // those are bound by the function.\n+//       ty::ty_fn(f) {\n+//         ty\n+//       }\n+//\n+//       // Otherwise just map.\n+//       sty {\n+//         ty::fold_sty_to_ty(tcx, sty) {|t|\n+//           replace_inferred(tcx, with_r, t) }\n+//       }\n+//     }\n+// }\n+\n+fn replace_default_region(tcx: ty::ctxt,\n+                          with_region: ty::region,\n+                          ty: ty::t) -> ty::t {\n+    let mut last_region = with_region;\n+    ret ty::fold_region(tcx, ty) {|region, under_rptr|\n+        if !under_rptr {\n+            last_region = alt region {\n+              ty::re_default { with_region }\n+              _ { region }\n             }\n-            _ { region }\n         }\n-    }, false), ty);\n+        last_region\n+   };\n+}\n+\n+fn default_region_to_bound_anon(tcx: ty::ctxt, ty: ty::t) -> ty::t {\n+    replace_default_region(tcx, ty::re_bound(ty::br_anon), ty)\n+}\n+\n+fn default_region_to_bound_self(tcx: ty::ctxt, ty: ty::t) -> ty::t {\n+    replace_default_region(tcx, ty::re_bound(ty::br_self), ty)\n }\n \n fn fixup_regions_to_block(tcx: ty::ctxt, ty: ty::t, ast_ty: @ast::ty)\n         -> ty::t {\n     let region = tcx.region_map.ast_type_to_inferred_region.get(ast_ty.id);\n-    ret ty::fold_ty(tcx, ty::fm_rptr({|this_region, _under_rptr|\n-        alt this_region {\n-            ty::re_inferred { region }\n-            _ { this_region }\n+    replace_default_region(tcx, region, ty)\n+}\n+\n+fn replace_bound_regions_with_free_regions(\n+    tcx: ty::ctxt,\n+    id: ast::node_id,\n+    ty: ty::t) -> ty::t {\n+\n+    ty::fold_region(tcx, ty) {|region, _under_rptr|\n+        alt region {\n+          ty::re_bound(br) { ty::re_free(id, br) }\n+          _ { region }\n         }\n-    }, false), ty);\n+    }\n }\n \n fn ty_of_arg(tcx: ty::ctxt, mode: mode, a: ast::arg) -> ty::arg {\n@@ -614,38 +648,16 @@ fn ty_of_fn_decl(tcx: ty::ctxt,\n                  mode: mode,\n                  proto: ast::proto,\n                  decl: ast::fn_decl) -> ty::fn_ty {\n-    let mut has_regions: bool = false;\n-    let mut max_region_param: @mut uint = @mut 0u;\n-\n-    let mut input_tys = vec::map(decl.inputs) {|a|\n+    let input_tys = vec::map(decl.inputs) {|a|\n         let arg_ty = ty_of_arg(tcx, mode, a);\n-\n-        if ty::type_has_rptrs(arg_ty.ty) {\n-            has_regions = true;\n-            let _ = ty::fold_ty(tcx, ty::fm_rptr({|r, _under_rptr|\n-                alt r {\n-                    ty::re_param(n) {\n-                        *max_region_param = uint::max(n, *max_region_param);\n-                    }\n-                    _ { /* no-op */ }\n-                };\n-                r\n-            }, false), arg_ty.ty);\n-        }\n-\n-        arg_ty\n+        {ty: default_region_to_bound_anon(tcx, arg_ty.ty)\n+         with arg_ty}\n     };\n \n-    let mut output_ty = ast_ty_to_ty(tcx, mode, decl.output);\n-\n-    if has_regions {\n-        let next_region_param_id = { mut id: *max_region_param };\n-        input_tys = vec::map(input_tys, {|input_ty|\n-            {ty: fixup_regions(tcx, next_region_param_id, input_ty.ty)\n-             with input_ty}\n-        });\n-        output_ty = fixup_regions(tcx, next_region_param_id, output_ty);\n-    }\n+    let output_ty = {\n+        let t = ast_ty_to_ty(tcx, mode, decl.output);\n+        default_region_to_bound_anon(tcx, t)\n+    };\n \n     let out_constrs = vec::map(decl.constraints) {|constr|\n         ty::ast_constr_to_constr(tcx, constr)\n@@ -745,6 +757,7 @@ fn ast_ty_to_ty_crate_infer(ccx: @crate_ctxt, &&ast_ty: @ast::ty) ->\n \n // Functions that write types into the node type table\n fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t) {\n+    #debug[\"write_ty_to_tcx(%d, %s)\", node_id, ty_to_str(tcx, ty)];\n     smallintmap::insert(*tcx.node_types, node_id as uint, ty);\n }\n fn write_substs_to_tcx(tcx: ty::ctxt, node_id: ast::node_id,\n@@ -763,6 +776,9 @@ fn write_ty_substs_to_tcx(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t,\n impl methods for @fn_ctxt {\n     fn tcx() -> ty::ctxt { self.ccx.tcx }\n     fn tag() -> str { #fmt[\"%x\", ptr::addr_of(*self) as uint] }\n+    fn ty_to_str(t: ty::t) -> str {\n+        ty_to_str(self.ccx.tcx, resolve_type_vars_if_possible(self, t))\n+    }\n     fn write_ty(node_id: ast::node_id, ty: ty::t) {\n         #debug[\"write_ty(%d, %s) in fcx %s\",\n                node_id, ty_to_str(self.tcx(), ty), self.tag()];\n@@ -888,7 +904,7 @@ enum self_subst { self_param(ty::t, @fn_ctxt, span), self_full(ty::t, uint) }\n fn fixup_self_in_method_ty(cx: ty::ctxt, mty: ty::t, m_substs: [ty::t],\n                            self: self_subst) -> ty::t {\n     if ty::type_has_vars(mty) {\n-        ty::fold_ty(cx, ty::fm_general(fn@(t: ty::t) -> ty::t {\n+        ty::fold_ty(cx, mty) {|t|\n             alt ty::get(t).struct {\n               ty::ty_self(tps) {\n                 if vec::len(tps) > 0u {\n@@ -931,20 +947,32 @@ fn fixup_self_in_method_ty(cx: ty::ctxt, mty: ty::t, m_substs: [ty::t],\n               }\n               _ { t }\n             }\n-        }), mty)\n+        }\n     } else { mty }\n }\n \n-// Mangles an iface method ty to instantiate its `self` region.\n-fn fixup_self_region_in_method_ty(fcx: @fn_ctxt, mty: ty::t,\n-                                  self_expr: @ast::expr) -> ty::t {\n-    let self_region = region_of(fcx, self_expr);\n-    ty::fold_ty(fcx.ccx.tcx, ty::fm_rptr({|r, _under_rptr|\n+// Replaces all occurrences of the `self` region with `with_region`.  Note\n+// that we descend into `fn()` types here, because `fn()` does not bind the\n+// `self` region.\n+fn replace_self_region(tcx: ty::ctxt, with_region: ty::region,\n+                       ty: ty::t) -> ty::t {\n+\n+   ty::fold_region(tcx, ty) {|r, _under_rptr|\n+       alt r {\n+           ty::re_bound(re_self) { with_region }\n+           _ { r }\n+       }\n+   }\n+}\n+\n+fn instantiate_bound_regions(tcx: ty::ctxt, region: ty::region, &&ty: ty::t)\n+        -> ty::t {\n+    ty::fold_region(tcx, ty) {|r, _under_rptr|\n         alt r {\n-            ty::re_self { self_region }\n-            _ { r }\n+          ty::re_bound(_) { region }\n+          _ { r }\n         }\n-    }, false), mty)\n+    }\n }\n \n // Item collection - a pair of bootstrap passes:\n@@ -972,12 +1000,13 @@ mod collect {\n                 // should be called to resolve named types.\n                 let mut args: [arg] = [];\n                 for va: ast::variant_arg in variant.node.args {\n-                    let mut arg_ty = ast_ty_to_ty(tcx, m_collect, va.ty);\n-                    if ty::type_has_rptrs(arg_ty) {\n-                        let next_region_param_id = { mut id: 0u };\n-                        arg_ty = fixup_regions(tcx, next_region_param_id,\n-                                               arg_ty);\n-                    }\n+                    let arg_ty = {\n+                        // NDM We need BOUNDS here.  It should be that this\n+                        // yields a type like \"foo &anon\".  Basically every\n+                        // nominal type is going to require a region bound.\n+                        let arg_ty = ast_ty_to_ty(tcx, m_collect, va.ty);\n+                        default_region_to_bound_anon(tcx, arg_ty)\n+                    };\n \n                     args += [{mode: ast::expl(ast::by_copy), ty: arg_ty}];\n                 }\n@@ -1312,7 +1341,7 @@ mod demand {\n        ty_param_substs_and_ty {\n \n         let mut ty_param_substs: [mut ty::t] = [mut];\n-        let mut ty_param_subst_var_ids: [int] = [];\n+        let mut ty_param_subst_var_ids: [ty_vid] = [];\n         for ty_param_subst: ty::t in ty_param_substs_0 {\n             // Generate a type variable and unify it with the type parameter\n             // substitution. We will then pull out these type variables.\n@@ -1323,10 +1352,10 @@ mod demand {\n         }\n \n         fn mk_result(fcx: @fn_ctxt, result_ty: ty::t,\n-                     ty_param_subst_var_ids: [int]) ->\n+                     ty_param_subst_var_ids: [ty_vid]) ->\n            ty_param_substs_and_ty {\n             let mut result_ty_param_substs: [ty::t] = [];\n-            for var_id: int in ty_param_subst_var_ids {\n+            for var_id in ty_param_subst_var_ids {\n                 let tp_subst = ty::mk_var(fcx.ccx.tcx, var_id);\n                 result_ty_param_substs += [tp_subst];\n             }\n@@ -1339,17 +1368,15 @@ mod demand {\n             ret mk_result(fcx, expected, ty_param_subst_var_ids);\n           }\n           result::err(err) {\n-            let e_err = resolve_type_vars_if_possible(fcx, expected);\n-            let a_err = resolve_type_vars_if_possible(fcx, actual);\n             fcx.ccx.tcx.sess.span_err(sp,\n                                       \"mismatched types: expected `\" +\n-                                          ty_to_str(fcx.ccx.tcx, e_err) +\n-                                          \"` but found `\" +\n-                                          ty_to_str(fcx.ccx.tcx, a_err) +\n-                                          \"` (\" +\n-                                          ty::type_err_to_str(fcx.ccx.tcx,\n-                                                              err) +\n-                                          \")\");\n+                                      fcx.ty_to_str(expected) +\n+                                      \"` but found `\" +\n+                                      fcx.ty_to_str(actual) +\n+                                      \"` (\" +\n+                                      ty::type_err_to_str(\n+                                          fcx.ccx.tcx, err) +\n+                                      \")\");\n             ret mk_result(fcx, expected, ty_param_subst_var_ids);\n           }\n         }\n@@ -1403,16 +1430,13 @@ mod writeback {\n         if !ty::type_has_vars(typ) { ret some(typ); }\n         alt infer::fixup_vars(fcx.infcx, typ) {\n           result::ok(new_type) { ret some(new_type); }\n-          result::err(-1) {\n-            fcx.ccx.tcx.sess.span_err(\n-                sp,\n-                \"can not instantiate infinite type\");\n-            ret none;\n-          }\n-          result::err(vid) {\n+          result::err(e) {\n             if !fcx.ccx.tcx.sess.has_errors() {\n-                fcx.ccx.tcx.sess.span_err(sp, \"cannot determine a type \\\n-                                               for this expression\");\n+                fcx.ccx.tcx.sess.span_err(\n+                    sp,\n+                    #fmt[\"cannot determine a type \\\n+                          for this expression: %s\",\n+                         infer::fixup_err_to_str(e)])\n             }\n             ret none;\n           }\n@@ -1421,13 +1445,16 @@ mod writeback {\n     fn resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span, id: ast::node_id)\n         -> option<ty::t> {\n         let fcx = wbcx.fcx, tcx = fcx.ccx.tcx;\n-        alt resolve_type_vars_in_type(fcx, sp, fcx.node_ty(id)) {\n+        let n_ty = fcx.node_ty(id);\n+        alt resolve_type_vars_in_type(fcx, sp, n_ty) {\n           none {\n             wbcx.success = false;\n             ret none;\n           }\n \n           some(t) {\n+            #debug[\"resolve_type_vars_for_node(id=%d, n_ty=%s, t=%s)\",\n+                   id, ty_to_str(tcx, n_ty), ty_to_str(tcx, t)];\n             write_ty_to_tcx(tcx, id, t);\n             alt fcx.opt_node_ty_substs(id) {\n               some(substs) {\n@@ -1514,9 +1541,9 @@ mod writeback {\n         resolve_type_vars_for_node(wbcx, p.span, p.id);\n         #debug[\"Type for pattern binding %s (id %d) resolved to %s\",\n                pat_to_str(p), p.id,\n-               ty_to_str(wbcx.fcx.ccx.tcx,\n-                         ty::node_id_to_type(wbcx.fcx.ccx.tcx,\n-                                             p.id))];\n+               wbcx.fcx.ty_to_str(\n+                   ty::node_id_to_type(wbcx.fcx.ccx.tcx,\n+                                       p.id))];\n         visit::visit_pat(p, wbcx, v);\n     }\n     fn visit_local(l: @ast::local, wbcx: wb_ctxt, v: wb_vt) {\n@@ -1526,19 +1553,15 @@ mod writeback {\n           result::ok(lty) {\n             #debug[\"Type for local %s (id %d) resolved to %s\",\n                    pat_to_str(l.node.pat), l.node.id,\n-                   ty_to_str(wbcx.fcx.ccx.tcx, lty)];\n+                   wbcx.fcx.ty_to_str(lty)];\n             write_ty_to_tcx(wbcx.fcx.ccx.tcx, l.node.id, lty);\n           }\n-          result::err(-1) {\n+          result::err(e) {\n             wbcx.fcx.ccx.tcx.sess.span_err(\n                 l.span,\n-                \"this local variable has a type of infinite size\");\n-            wbcx.success = false;\n-          }\n-          result::err(_) {\n-            wbcx.fcx.ccx.tcx.sess.span_err(l.span,\n-                                           \"cannot determine a type \\\n-                                                for this local variable\");\n+                #fmt[\"cannot determine a type \\\n+                      for this local variable: %s\",\n+                     infer::fixup_err_to_str(e)]);\n             wbcx.success = false;\n           }\n         }\n@@ -1629,8 +1652,8 @@ fn check_intrinsic_type(tcx: ty::ctxt, it: @ast::native_item) {\n // for them before typechecking the function.\n type gather_result =\n     {infcx: infer::infer_ctxt,\n-     locals: hashmap<ast::node_id, int>,\n-     next_var_id: @mut int};\n+     locals: hashmap<ast::node_id, ty_vid>,\n+     next_var_id: @mut uint};\n \n // Used only as a helper for check_fn.\n fn gather_locals(ccx: @crate_ctxt,\n@@ -1641,8 +1664,8 @@ fn gather_locals(ccx: @crate_ctxt,\n     let {infcx, locals, nvi} = alt old_fcx {\n       none {\n         {infcx: infer::new_infer_ctxt(ccx.tcx),\n-         locals: int_hash::<int>(),\n-         nvi: @mut 0}\n+         locals: int_hash(),\n+         nvi: @mut 0u}\n       }\n       some(fcx) {\n         {infcx: fcx.infcx,\n@@ -1652,10 +1675,12 @@ fn gather_locals(ccx: @crate_ctxt,\n     };\n     let tcx = ccx.tcx;\n \n-    let next_var_id = fn@() -> int { let rv = *nvi; *nvi += 1; ret rv; };\n+    let next_var_id = fn@() -> uint {\n+        let rv = *nvi; *nvi += 1u; ret rv;\n+    };\n \n     let assign = fn@(nid: ast::node_id, ty_opt: option<ty::t>) {\n-        let var_id = next_var_id();\n+        let var_id = ty_vid(next_var_id());\n         locals.insert(nid, var_id);\n         alt ty_opt {\n           none {/* nothing to do */ }\n@@ -1668,8 +1693,8 @@ fn gather_locals(ccx: @crate_ctxt,\n     // Add formal parameters.\n     vec::iter2(arg_tys, decl.inputs) {|arg_ty, input|\n         assign(input.id, some(arg_ty));\n-        #debug[\"Argument %s is assigned to <T%d>\",\n-               input.ident, locals.get(input.id)];\n+        #debug[\"Argument %s is assigned to %s\",\n+               input.ident, locals.get(input.id).to_str()];\n     }\n \n     // Add explicitly-declared locals.\n@@ -1684,8 +1709,9 @@ fn gather_locals(ccx: @crate_ctxt,\n         }\n \n         assign(local.node.id, local_ty_opt);\n-        #debug[\"Local variable %s is assigned to <T%d>\",\n-               pat_to_str(local.node.pat), locals.get(local.node.id)];\n+        #debug[\"Local variable %s is assigned to %s\",\n+               pat_to_str(local.node.pat),\n+               locals.get(local.node.id).to_str()];\n         visit::visit_local(local, e, v);\n     };\n \n@@ -1695,8 +1721,9 @@ fn gather_locals(ccx: @crate_ctxt,\n           ast::pat_ident(path, _)\n           if !pat_util::pat_is_variant(ccx.tcx.def_map, p) {\n             assign(p.id, none);\n-            #debug[\"Pattern binding %s is assigned to <T%d>\",\n-                   path.node.idents[0], locals.get(p.id)];\n+            #debug[\"Pattern binding %s is assigned to %s\",\n+                   path.node.idents[0],\n+                   locals.get(p.id).to_str()];\n           }\n           _ {}\n         }\n@@ -1754,7 +1781,7 @@ fn count_region_params(ty: ty::t) -> uint {\n     let count = @mut 0u;\n     ty::walk_ty(ty) {|ty|\n         alt ty::get(ty).struct {\n-            ty::ty_rptr(ty::re_param(param_id), _) {\n+            ty::ty_rptr(ty::re_bound(ty::br_param(param_id, _)), _) {\n                 if param_id > *count {\n                     *count = param_id;\n                 }\n@@ -1765,49 +1792,57 @@ fn count_region_params(ty: ty::t) -> uint {\n     ret *count;\n }\n \n-// Replaces self, caller, or inferred regions in the given type with the given\n-// region.\n-fn instantiate_self_regions(tcx: ty::ctxt, region: ty::region, &&ty: ty::t)\n-        -> ty::t {\n-    if ty::type_has_rptrs(ty) {\n-        ty::fold_ty(tcx, ty::fm_rptr({|r, _under_rptr|\n-            alt r {\n-                ty::re_inferred | ty::re_self | ty::re_param(_) { region }\n-                _ { r }\n-            }\n-        }, false), ty)\n-    } else {\n-        ty\n-    }\n-}\n-\n-type region_env = smallintmap::smallintmap<int>;\n+type region_env = hashmap<ty::bound_region, region_vid>;\n \n fn region_env() -> @region_env {\n-    ret @smallintmap::mk::<int>();\n+    ret @ty::br_hashmap();\n }\n \n // Replaces all region parameters in the given type with region variables.\n-// This is used when typechecking function calls, bind expressions, and method\n-// calls.\n-fn universally_quantify_regions(fcx: @fn_ctxt, ty: ty::t) -> ty::t {\n+// Does not descend into fn types.  This is used when deciding whether an impl\n+// applies at a given call site.  See also universally_quantify_before_call().\n+fn universally_quantify_regions(fcx: @fn_ctxt, renv: @region_env,\n+                                ty: ty::t) -> ty::t {\n+    ty::fold_region(fcx.ccx.tcx, ty) {|r, _under_rptr|\n+        alt r {\n+          ty::re_bound(br) {\n+            alt (*renv).find(br) {\n+              some(var_id) { ty::re_var(var_id) }\n+              none {\n+                let var_id = next_region_var_id(fcx);\n+                (*renv).insert(br, var_id);\n+                ty::re_var(var_id)\n+              }\n+            }\n+          }\n+          _ { r }\n+        }\n+    }\n+}\n+\n+// Expects a function type.  Replaces all region parameters in the arguments\n+// and return type with fresh region variables. This is used when typechecking\n+// function calls, bind expressions, and method calls.\n+fn universally_quantify_before_call(\n+    fcx: @fn_ctxt, renv: @region_env, ty: ty::t) -> ty::t {\n     if ty::type_has_rptrs(ty) {\n-        let renv = region_env();\n-        ty::fold_ty(fcx.ccx.tcx, ty::fm_rptr({|r, _under_rptr|\n-            alt r {\n-                ty::re_param(param_id) {\n-                    alt smallintmap::find(*renv, param_id) {\n-                        some(var_id) { ty::re_var(var_id as uint) }\n-                        none {\n-                            let var_id = next_region_var_id(fcx);\n-                            smallintmap::insert(*renv, param_id, var_id);\n-                            ty::re_var(var_id as uint)\n-                        }\n-                    }\n-                }\n-                _ { r }\n+        // This is subtle: we expect `ty` to be a function type, but\n+        // fold_region() will not descend into function types.  As it happens\n+        // we only want to descend 1 level, so we just bypass fold_region for\n+        // the outer type and apply it to all of the types contained with\n+        // `ty`.\n+        alt ty::get(ty).struct {\n+          sty @ ty::ty_fn(_) {\n+            ty::fold_sty_to_ty(fcx.ccx.tcx, sty) {|t|\n+                universally_quantify_regions(fcx, renv, t)\n             }\n-        }, true), ty)\n+          }\n+          _ {\n+            // if not a function type, we're gonna' report an error\n+            // at some point, since the user is trying to call this thing\n+            ty\n+          }\n+        }\n     } else {\n         ty\n     }\n@@ -1832,10 +1867,10 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n         // Get the number of arguments in this enum variant.\n         let arg_types = variant_arg_types(pcx.fcx.ccx, pat.span,\n                                           v_def_ids.var, expected_tps);\n-        let arg_types = vec::map(arg_types,\n-                             bind instantiate_self_regions(pcx.fcx.ccx.tcx,\n-                                                           pcx.pat_region,\n-                                                           _));\n+        let arg_types = vec::map(arg_types) {|t|\n+            // NDM---is this reasonable?\n+            instantiate_bound_regions(pcx.fcx.ccx.tcx, pcx.pat_region, t)\n+        };\n         let subpats_len = subpats.len(), arg_len = arg_types.len();\n         if arg_len > 0u {\n             // N-ary variant.\n@@ -1932,7 +1967,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             tcx.sess.span_fatal\n                 (pat.span,\n                 #fmt[\"mismatched types: expected `%s` but found record\",\n-                                ty_to_str(tcx, expected)]);\n+                     fcx.ty_to_str(expected)]);\n           }\n         };\n         let f_count = vec::len(fields);\n@@ -1969,7 +2004,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             tcx.sess.span_fatal\n                 (pat.span,\n                  #fmt[\"mismatched types: expected `%s`, found tuple\",\n-                        ty_to_str(tcx, expected)]);\n+                      fcx.ty_to_str(expected)]);\n           }\n         };\n         let e_count = vec::len(elts);\n@@ -1994,10 +2029,11 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             fcx.write_ty(pat.id, expected);\n           }\n           _ {\n-            tcx.sess.span_fatal(pat.span,\n-                                        \"mismatched types: expected `\" +\n-                                            ty_to_str(tcx, expected) +\n-                                            \"` found box\");\n+            tcx.sess.span_fatal(\n+                pat.span,\n+                \"mismatched types: expected `\" +\n+                pcx.fcx.ty_to_str(expected) +\n+                \"` found box\");\n           }\n         }\n       }\n@@ -2008,10 +2044,11 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             fcx.write_ty(pat.id, expected);\n           }\n           _ {\n-            tcx.sess.span_fatal(pat.span,\n-                                        \"mismatched types: expected `\" +\n-                                            ty_to_str(tcx, expected) +\n-                                            \"` found uniq\");\n+            tcx.sess.span_fatal(\n+                pat.span,\n+                \"mismatched types: expected `\" +\n+                pcx.fcx.ty_to_str(expected) +\n+                \"` found uniq\");\n           }\n         }\n       }\n@@ -2146,7 +2183,8 @@ fn lookup_method(fcx: @fn_ctxt, expr: @ast::expr, node_id: ast::node_id,\n         }\n         if ty::type_has_rptrs(ty::ty_fn_ret(fty)) {\n             let fty = fcx.node_ty(node_id);\n-            let fty = fixup_self_region_in_method_ty(fcx, fty, expr);\n+            let self_region = region_of(fcx, expr);\n+            let fty = replace_self_region(fcx.ccx.tcx, self_region, fty);\n             fcx.write_ty(node_id, fty);\n         }\n         some(origin)\n@@ -2213,9 +2251,7 @@ fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n     let tcx = fcx.ccx.tcx;\n \n     #debug[\"lookup_method_inner: expr=%s name=%s ty=%s\",\n-           expr_to_str(expr),\n-           name,\n-           ty_to_str(fcx.ccx.tcx, ty)];\n+           expr_to_str(expr), name, fcx.ty_to_str(ty)];\n \n     // First, see whether this is an interface-bounded parameter\n     alt ty::get(ty).struct {\n@@ -2297,14 +2333,17 @@ fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n                     };\n \n                     // Here \"self\" refers to the callee side...\n-                    let next_rid = count_region_params(self_ty);\n-                    self_ty = instantiate_self_regions(fcx.ccx.tcx,\n-                                                       ty::re_param(next_rid),\n-                                                       self_ty);\n-                    self_ty = universally_quantify_regions(fcx, self_ty);\n+                    //let next_rid = count_region_params(self_ty);\n+                    //self_ty = instantiate_bound_regions(\n+                    //    fcx.ccx.tcx,\n+                    //    ty::re_bound(ty::br_param(next_rid)),\n+                    //    self_ty);\n+                    self_ty = universally_quantify_regions(\n+                        fcx, region_env(), self_ty);\n \n                     // ... and \"ty\" refers to the caller side.\n-                    let ty = universally_quantify_regions(fcx, ty);\n+                    let ty = universally_quantify_regions(\n+                        fcx, region_env(), ty);\n \n                     alt unify::unify(fcx, self_ty, ty) {\n                       result::ok(_) {\n@@ -2365,7 +2404,7 @@ fn region_of(fcx: @fn_ctxt, expr: @ast::expr) -> ty::region {\n                 ast::def_upvar(local_id, _, _) {\n                     let local_blocks = fcx.ccx.tcx.region_map.local_blocks;\n                     let local_block_id = local_blocks.get(local_id);\n-                    ret ty::re_block(local_block_id);\n+                    ret ty::re_scope(local_block_id);\n                 }\n                 _ {\n                     fcx.ccx.tcx.sess.span_unimpl(expr.span,\n@@ -2394,7 +2433,7 @@ fn region_of(fcx: @fn_ctxt, expr: @ast::expr) -> ty::region {\n         }\n         _ {\n             let blk_id = fcx.ccx.tcx.region_map.rvalue_to_block.get(expr.id);\n-            ret ty::re_block(blk_id);\n+            ret ty::re_scope(blk_id);\n         }\n     }\n }\n@@ -2412,8 +2451,7 @@ fn check_expr_fn_with_unifier(fcx: @fn_ctxt,\n                         ty_of_fn_decl(tcx, m_check_tyvar(fcx), proto, decl));\n \n     #debug(\"check_expr_fn_with_unifier %s fty=%s\",\n-           expr_to_str(expr),\n-           ty_to_str(tcx, fty));\n+           expr_to_str(expr), fcx.ty_to_str(fty));\n \n     fcx.write_ty(expr.id, fty);\n \n@@ -2426,23 +2464,26 @@ fn check_expr_fn_with_unifier(fcx: @fn_ctxt,\n     let ret_ty = ty::ty_fn_ret(fty);\n     let arg_tys = vec::map(ty::ty_fn_args(fty)) {|a| a.ty };\n \n-    check_fn(fcx.ccx, proto, decl, body,\n-             ret_ty, arg_tys, is_loop_body, some(fcx));\n+    check_fn(fcx.ccx, proto, decl, body, expr.id,\n+             ret_ty, arg_tys, is_loop_body, some(fcx),\n+             fcx.self_ty);\n }\n \n fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                            expected: ty::t) -> bool {\n \n-    #debug(\"typechecking expr %s\",\n-           syntax::print::pprust::expr_to_str(expr));\n+    #debug(\"typechecking expr %d (%s)\",\n+           expr.id, syntax::print::pprust::expr_to_str(expr));\n \n     // A generic function to factor out common logic from call and bind\n     // expressions.\n     fn check_call_or_bind(\n         fcx: @fn_ctxt, sp: span, fty: ty::t,\n         args: [option<@ast::expr>]) -> {fty: ty::t, bot: bool} {\n \n-        let fty = universally_quantify_regions(fcx, fty);\n+        let fty = universally_quantify_before_call(fcx, region_env(), fty);\n+        #debug[\"check_call_or_bind: after universal quant., fty=%s\",\n+               fcx.ty_to_str(fty)];\n         let sty = structure_of(fcx, sp, fty);\n         // Grab the argument types\n         let mut arg_tys = alt sty {\n@@ -2451,7 +2492,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             fcx.ccx.tcx.sess.span_fatal(sp, \"mismatched types: \\\n                                              expected function or native \\\n                                              function but found \"\n-                                        + ty_to_str(fcx.ccx.tcx, fty))\n+                                        + fcx.ty_to_str(fty))\n           }\n         };\n \n@@ -2527,7 +2568,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n \n     // A generic function for checking call expressions\n     fn check_call(fcx: @fn_ctxt, sp: span, f: @ast::expr, args: [@ast::expr])\n-            -> bool {\n+        -> {fty: ty::t, bot: bool} {\n         let mut args_opt_0: [option<@ast::expr>] = [];\n         for arg: @ast::expr in args {\n             args_opt_0 += [some::<@ast::expr>(arg)];\n@@ -2536,30 +2577,29 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         let bot = check_expr(fcx, f);\n \n         // Call the generic checker.\n-        ret {\n-            let fn_ty = fcx.expr_ty(f);\n-            check_call_or_bind(fcx, sp, fn_ty, args_opt_0).bot | bot\n-        };\n+        let fn_ty = fcx.expr_ty(f);\n+        let {fty, bot: bot1} = check_call_or_bind(fcx, sp, fn_ty, args_opt_0);\n+        ret {fty: fty, bot: bot | bot1};\n     }\n \n     // A generic function for doing all of the checking for call expressions\n     fn check_call_full(fcx: @fn_ctxt, sp: span, id: ast::node_id,\n                        f: @ast::expr, args: [@ast::expr]) -> bool {\n-        let mut bot = check_call(fcx, sp, f, args);\n+        let {fty, bot} = check_call(fcx, sp, f, args);\n+\n         /* need to restrict oper to being an explicit expr_path if we're\n         inside a pure function */\n         require_pure_call(fcx.ccx, fcx.purity, f, sp);\n \n         // Pull the return type out of the type of the function.\n-        let fty = fcx.expr_ty(f);\n-        let mut rt_1 = alt structure_of(fcx, sp, fty) {\n+        let {rt, bot} = alt structure_of(fcx, sp, fty) {\n           ty::ty_fn(f) {\n-            bot |= f.ret_style == ast::noreturn;\n-            f.output\n+            {rt: f.output,\n+             bot: bot | (f.ret_style == ast::noreturn)}\n           }\n           _ { fcx.ccx.tcx.sess.span_fatal(sp, \"calling non-function\"); }\n         };\n-        fcx.write_ty(id, rt_1);\n+        fcx.write_ty(id, rt);\n         ret bot;\n     }\n \n@@ -2709,7 +2749,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         tcx.sess.span_err(\n             ex.span, \"binary operation \" + ast_util::binop_to_str(op) +\n             \" cannot be applied to type `\" +\n-            ty_to_str(tcx, lhs_resolved_t) +\n+            fcx.ty_to_str(lhs_resolved_t) +\n             \"`\");\n         (lhs_resolved_t, false)\n     }\n@@ -2720,7 +2760,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n           _ {\n             fcx.ccx.tcx.sess.span_err(\n                 ex.span, #fmt[\"cannot apply unary operator `%s` to type `%s`\",\n-                              op_str, ty_to_str(fcx.ccx.tcx, rhs_t)]);\n+                              op_str, fcx.ty_to_str(rhs_t)]);\n             rhs_t\n           }\n         }\n@@ -2957,9 +2997,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             let pcx = {\n                 fcx: fcx,\n                 map: pat_util::pat_id_map(tcx.def_map, arm.pats[0]),\n-                alt_region: ty::re_block(parent_block),\n-                block_region: ty::re_block(arm.body.node.id),\n-                pat_region: ty::re_block(parent_block)\n+                alt_region: ty::re_scope(parent_block),\n+                block_region: ty::re_scope(arm.body.node.id),\n+                pat_region: ty::re_scope(parent_block)\n             };\n \n             for p: @ast::pat in arm.pats {\n@@ -3037,17 +3077,17 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         // Call the generic checker.\n         bot = check_expr(fcx, f);\n \n-        let ccob_bot = {\n+        let {fty, bot: ccob_bot} = {\n             let fn_ty = fcx.expr_ty(f);\n-            check_call_or_bind(fcx, expr.span, fn_ty, args).bot\n+            check_call_or_bind(fcx, expr.span, fn_ty, args)\n         };\n         bot |= ccob_bot;\n \n         // TODO: Perform substitutions on the return type.\n \n         // Pull the argument and return types out.\n         let mut proto, arg_tys, rt, cf, constrs;\n-        alt structure_of(fcx, expr.span, fcx.expr_ty(f)) {\n+        alt structure_of(fcx, expr.span, fty) {\n           // FIXME:\n           // probably need to munge the constrs to drop constraints\n           // for any bound args\n@@ -3352,28 +3392,28 @@ fn require_integral(fcx: @fn_ctxt, sp: span, t: ty::t) {\n     if !type_is_integral(fcx, sp, t) {\n         fcx.ccx.tcx.sess.span_err(sp, \"mismatched types: expected \\\n                                        `integer` but found `\"\n-                                  + ty_to_str(fcx.ccx.tcx, t) + \"`\");\n+                                  + fcx.ty_to_str(t) + \"`\");\n     }\n }\n \n-fn next_ty_var_id(fcx: @fn_ctxt) -> int {\n+fn next_ty_var_id(fcx: @fn_ctxt) -> ty_vid {\n     let id = *fcx.next_var_id;\n-    *fcx.next_var_id += 1;\n-    ret id;\n+    *fcx.next_var_id += 1u;\n+    ret ty_vid(id);\n }\n \n fn next_ty_var(fcx: @fn_ctxt) -> ty::t {\n     ret ty::mk_var(fcx.ccx.tcx, next_ty_var_id(fcx));\n }\n \n-fn next_region_var_id(fcx: @fn_ctxt) -> int {\n+fn next_region_var_id(fcx: @fn_ctxt) -> region_vid {\n     let id = *fcx.next_region_var_id;\n-    *fcx.next_region_var_id += 1;\n-    ret id;\n+    *fcx.next_region_var_id += 1u;\n+    ret region_vid(id);\n }\n \n fn next_region_var(fcx: @fn_ctxt) -> ty::region {\n-    ret ty::re_var(next_region_var_id(fcx) as uint);\n+    ret ty::re_var(next_region_var_id(fcx));\n }\n \n fn bind_params(fcx: @fn_ctxt, tp: ty::t, count: uint)\n@@ -3382,10 +3422,6 @@ fn bind_params(fcx: @fn_ctxt, tp: ty::t, count: uint)\n     {vars: vars, ty: ty::substitute_type_params(fcx.ccx.tcx, vars, tp)}\n }\n \n-fn get_self_info(ccx: @crate_ctxt) -> option<self_info> {\n-    ret vec::last_opt(ccx.self_infos);\n-}\n-\n fn check_decl_initializer(fcx: @fn_ctxt, nid: ast::node_id,\n                           init: ast::initializer) -> bool {\n     let lty = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, init.expr.span, nid));\n@@ -3405,7 +3441,7 @@ fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n     }\n \n     let block_id = fcx.ccx.tcx.region_map.rvalue_to_block.get(local.node.id);\n-    let region = ty::re_block(block_id);\n+    let region = ty::re_scope(block_id);\n     let pcx = {\n         fcx: fcx,\n         map: pat_util::pat_id_map(fcx.ccx.tcx.def_map, local.node.pat),\n@@ -3498,14 +3534,15 @@ fn check_const(ccx: @crate_ctxt, _sp: span, e: @ast::expr, id: ast::node_id) {\n     // and statement context for checking the initializer expression.\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n     let fcx: @fn_ctxt =\n-        @{ret_ty: rty,\n+        @{self_ty: none,\n+          ret_ty: rty,\n           indirect_ret_ty: none,\n           purity: ast::pure_fn,\n           proto: ast::proto_box,\n           infcx: infer::new_infer_ctxt(ccx.tcx),\n-          locals: int_hash::<int>(),\n-          next_var_id: @mut 0,\n-          next_region_var_id: @mut 0,\n+          locals: int_hash(),\n+          next_var_id: @mut 0u,\n+          next_region_var_id: @mut 0u,\n           node_types: smallintmap::mk(),\n           node_type_substs: map::int_hash(),\n           ccx: ccx};\n@@ -3534,14 +3571,15 @@ fn check_enum_variants(ccx: @crate_ctxt, sp: span, vs: [ast::variant],\n     // and statement context for checking the initializer expression.\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n     let fcx: @fn_ctxt =\n-        @{ret_ty: rty,\n+        @{self_ty: none,\n+          ret_ty: rty,\n           indirect_ret_ty: none,\n           purity: ast::pure_fn,\n           proto: ast::proto_box,\n           infcx: infer::new_infer_ctxt(ccx.tcx),\n-          locals: int_hash::<int>(),\n-          next_var_id: @mut 0,\n-          next_region_var_id: @mut 0,\n+          locals: int_hash(),\n+          next_var_id: @mut 0u,\n+          next_region_var_id: @mut 0u,\n           node_types: smallintmap::mk(),\n           node_type_substs: map::int_hash(),\n           ccx: ccx};\n@@ -3709,22 +3747,41 @@ fn check_constraints(fcx: @fn_ctxt, cs: [@ast::constr], args: [ast::arg]) {\n fn check_bare_fn(ccx: @crate_ctxt,\n                  decl: ast::fn_decl,\n                  body: ast::blk,\n-                 id: ast::node_id) {\n+                 id: ast::node_id,\n+                 self_ty: option<ty::t>) {\n     let fty = ty::node_id_to_type(ccx.tcx, id);\n     let ret_ty = ty::ty_fn_ret(fty);\n     let arg_tys = vec::map(ty::ty_fn_args(fty)) {|a| a.ty };\n-    check_fn(ccx, ast::proto_bare, decl, body,\n-             ret_ty, arg_tys, false, none);\n+    check_fn(ccx, ast::proto_bare, decl, body, id,\n+             ret_ty, arg_tys, false, none, self_ty);\n }\n \n fn check_fn(ccx: @crate_ctxt,\n             proto: ast::proto,\n             decl: ast::fn_decl,\n             body: ast::blk,\n+            fid: ast::node_id,\n             ret_ty: ty::t,\n             arg_tys: [ty::t],\n             indirect_ret: bool,\n-            old_fcx: option<@fn_ctxt>) {\n+            old_fcx: option<@fn_ctxt>,\n+            self_ty: option<ty::t>) {\n+\n+    // See big comment in region.rs.\n+    let arg_tys = arg_tys.map {|arg_ty|\n+        replace_bound_regions_with_free_regions(ccx.tcx, fid, arg_ty)\n+    };\n+    let ret_ty =\n+        replace_bound_regions_with_free_regions(ccx.tcx, fid, ret_ty);\n+    let self_ty = option::map(self_ty) {|st|\n+        replace_bound_regions_with_free_regions(ccx.tcx, fid, st)\n+    };\n+\n+    #debug[\"check_fn(arg_tys=%?, ret_ty=%?, self_ty=%?)\",\n+           arg_tys.map {|a| ty_to_str(ccx.tcx, a) },\n+           ty_to_str(ccx.tcx, ret_ty),\n+           option::map(self_ty) {|st| ty_to_str(ccx.tcx, st) }];\n+\n     // If old_fcx is some(...), this is a block fn { |x| ... }.\n     // In that case, the purity is inherited from the context.\n     let {purity, node_types, node_type_substs} = alt old_fcx {\n@@ -3750,14 +3807,15 @@ fn check_fn(ccx: @crate_ctxt,\n         }\n     } else { none };\n     let fcx: @fn_ctxt =\n-        @{ret_ty: ret_ty,\n+        @{self_ty: self_ty,\n+          ret_ty: ret_ty,\n           indirect_ret_ty: indirect_ret_ty,\n           purity: purity,\n           proto: proto,\n           infcx: gather_result.infcx,\n           locals: gather_result.locals,\n           next_var_id: gather_result.next_var_id,\n-          next_region_var_id: @mut 0,\n+          next_region_var_id: @mut 0u,\n           node_types: node_types,\n           node_type_substs: node_type_substs,\n           ccx: ccx};\n@@ -3791,8 +3849,8 @@ fn check_fn(ccx: @crate_ctxt,\n     }\n }\n \n-fn check_method(ccx: @crate_ctxt, method: @ast::method) {\n-    check_bare_fn(ccx, method.decl, method.body, method.id);\n+fn check_method(ccx: @crate_ctxt, method: @ast::method, self_ty: ty::t) {\n+    check_bare_fn(ccx, method.decl, method.body, method.id, some(self_ty));\n }\n \n fn class_types(ccx: @crate_ctxt, members: [@ast::class_member]) -> class_map {\n@@ -3816,9 +3874,7 @@ fn check_class_member(ccx: @crate_ctxt, class_t: ty::t,\n     alt cm.node {\n       ast::instance_var(_,t,_,_,_) { }\n       ast::class_method(m) {\n-          ccx.self_infos += [self_impl(class_t, m.self_id)];\n-          check_method(ccx, m);\n-          vec::pop(ccx.self_infos);\n+          check_method(ccx, m, class_t);\n       }\n     }\n }\n@@ -3828,20 +3884,18 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n       ast::item_const(_, e) { check_const(ccx, it.span, e, it.id); }\n       ast::item_enum(vs, _) { check_enum_variants(ccx, it.span, vs, it.id); }\n       ast::item_fn(decl, tps, body) {\n-        check_bare_fn(ccx, decl, body, it.id);\n+        check_bare_fn(ccx, decl, body, it.id, none);\n       }\n       ast::item_res(decl, tps, body, dtor_id, _) {\n         check_instantiable(ccx.tcx, it.span, it.id);\n-        check_bare_fn(ccx, decl, body, dtor_id);\n+        check_bare_fn(ccx, decl, body, dtor_id, none);\n       }\n       ast::item_impl(tps, _, ty, ms) {\n-        let mut self_ty = ast_ty_to_ty(ccx.tcx, m_check, ty);\n-        let self_region = ty::re_self;\n-        self_ty = instantiate_self_regions(ccx.tcx, self_region, self_ty);\n+        let self_ty = ast_ty_to_ty(ccx.tcx, m_check, ty);\n+        let self_region = ty::re_free(it.id, ty::br_self);\n+        let self_ty = replace_self_region(ccx.tcx, self_region, self_ty);\n         for m in ms {\n-             ccx.self_infos += [self_impl(self_ty, m.id)];\n-             check_method(ccx, m);\n-             vec::pop(ccx.self_infos);\n+            check_method(ccx, m, self_ty);\n         }\n       }\n       ast::item_class(tps, members, ctor) {\n@@ -3852,11 +3906,11 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n           // FIXME\n           let class_ccx = @{enclosing_class_id:cid,\n                             enclosing_class:members_info with *ccx};\n-          class_ccx.self_infos += [self_impl(class_t, ctor.node.self_id)];\n           // typecheck the ctor\n           check_bare_fn(class_ccx, ctor.node.dec,\n-                        ctor.node.body, ctor.node.id);\n-          vec::pop(class_ccx.self_infos);\n+                        ctor.node.body, ctor.node.id,\n+                        some(class_t));\n+\n           // typecheck the members\n           for m in members { check_class_member(class_ccx, class_t, m); }\n       }\n@@ -4057,13 +4111,12 @@ mod vtable {\n         let tcx = fcx.ccx.tcx;\n         alt infer::fixup_vars(fcx.infcx, ty) {\n           result::ok(new_type) { new_type }\n-          result::err(-1) {\n-            tcx.sess.span_fatal(sp, \"bounded type parameter with \\\n-                                     cyclic type\");\n-          }\n-          result::err(vid) {\n-            tcx.sess.span_fatal(sp, \"could not determine a type for a \\\n-                                     bounded type parameter\");\n+          result::err(e) {\n+            tcx.sess.span_fatal(\n+                sp,\n+                #fmt[\"cannot determine a type \\\n+                      for this bounded type parameter: %s\",\n+                     infer::fixup_err_to_str(e)])\n           }\n         }\n     }\n@@ -4153,8 +4206,7 @@ fn check_crate(tcx: ty::ctxt, impl_map: resolve::impl_map,\n                crate: @ast::crate) -> (method_map, vtable_map) {\n     collect::collect_item_types(tcx, crate);\n \n-    let ccx = @{mut self_infos: [],\n-                impl_map: impl_map,\n+    let ccx = @{impl_map: impl_map,\n                 method_map: std::map::int_hash(),\n                 vtable_map: std::map::int_hash(),\n                 enclosing_class_id: none,"}, {"sha": "2cb0fef1a90476aab47cf201952d529b10c0b29a", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c0d61795defc83fd696971880d60f438a1837f0d/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0d61795defc83fd696971880d60f438a1837f0d/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=c0d61795defc83fd696971880d60f438a1837f0d", "patch": "@@ -10,21 +10,32 @@ import syntax::{ast, ast_util};\n import middle::ast_map;\n import driver::session::session;\n \n+fn bound_region_to_str(_cx: ctxt, br: bound_region) -> str {\n+    alt br {\n+      br_anon          { \"&\" }\n+      br_param(_, str) { #fmt[\"&%s.\", str] }\n+      br_self          { \"&self.\" }\n+    }\n+}\n+\n fn region_to_str(cx: ctxt, region: region) -> str {\n     alt region {\n-      re_block(node_id) {\n+      re_scope(node_id) {\n         alt cx.items.get(node_id) {\n             ast_map::node_block(blk) {\n-                #fmt(\"<block at %s>\", codemap::span_to_str(blk.span,\n+                #fmt(\"&<block at %s>.\", codemap::span_to_str(blk.span,\n                                                            cx.sess.codemap))\n             }\n             _ { cx.sess.bug(\"re_block refers to non-block\") }\n         }\n       }\n-      re_self       { \"self\" }\n-      re_inferred   { \"\" }\n-      re_param(id)  { #fmt(\"<P%u>\", id) }    // TODO: do better than this\n-      re_var(id)    { #fmt(\"<R%u>\", id) }    // TODO: do better than this\n+\n+      re_bound(br) { bound_region_to_str(cx, br) }\n+      re_free(id, br) { #fmt[\"{%d} %s\", id, bound_region_to_str(cx, br)] }\n+\n+      // These two should not be seen by end-users (very often, anyhow):\n+      re_var(id)    { #fmt(\"&%s.\", id.to_str()) }\n+      re_default    { \"&(default).\" }\n     }\n }\n \n@@ -122,7 +133,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n       ty_box(tm) { \"@\" + mt_to_str(cx, tm) }\n       ty_uniq(tm) { \"~\" + mt_to_str(cx, tm) }\n       ty_ptr(tm) { \"*\" + mt_to_str(cx, tm) }\n-      ty_rptr(r, tm) { \"&\" + region_to_str(cx, r) + \".\" + mt_to_str(cx, tm) }\n+      ty_rptr(r, tm) { region_to_str(cx, r) + mt_to_str(cx, tm) }\n       ty_vec(tm) { \"[\" + mt_to_str(cx, tm) + \"]\" }\n       ty_type { \"type\" }\n       ty_rec(elems) {\n@@ -139,7 +150,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n         fn_to_str(cx, f.proto, none, f.inputs, f.output, f.ret_style,\n                   f.constraints)\n       }\n-      ty_var(v) { \"<T\" + int::str(v) + \">\" }\n+      ty_var(v) { v.to_str() }\n       ty_param(id, _) {\n         \"'\" + str::from_bytes([('a' as u8) + (id as u8)])\n       }"}, {"sha": "a802967bc7a048b65395a97fca87b4b9a2268ae5", "filename": "src/test/compile-fail/occurs-check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0d61795defc83fd696971880d60f438a1837f0d/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0d61795defc83fd696971880d60f438a1837f0d/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs?ref=c0d61795defc83fd696971880d60f438a1837f0d", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n-    let f; //! ERROR this local variable has a type of infinite size\n+    let f; //! ERROR cyclic type of infinite size\n     f = @f;\n }"}, {"sha": "9e483f063a2e3b020b5cc693afe066b3697973e7", "filename": "src/test/run-pass/region-param.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c0d61795defc83fd696971880d60f438a1837f0d/src%2Ftest%2Frun-pass%2Fregion-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0d61795defc83fd696971880d60f438a1837f0d/src%2Ftest%2Frun-pass%2Fregion-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregion-param.rs?ref=c0d61795defc83fd696971880d60f438a1837f0d", "patch": "@@ -0,0 +1,15 @@\n+fn region_identity(x: &r.uint) -> &r.uint { x }\n+\n+fn apply<T>(t: T, f: fn(T) -> T) -> T { f(t) }\n+\n+fn parameterized(x: &uint) -> uint {\n+    let z = apply(x) {|y|\n+        region_identity(y)\n+    };\n+    *z\n+}\n+\n+fn main() {\n+    let x = 3u;\n+    assert parameterized(&x) == 3u;\n+}\n\\ No newline at end of file"}, {"sha": "a587c19f38f719a185e6dad6bda996b55940a983", "filename": "src/test/run-pass/regions-self-impls.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0d61795defc83fd696971880d60f438a1837f0d/src%2Ftest%2Frun-pass%2Fregions-self-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0d61795defc83fd696971880d60f438a1837f0d/src%2Ftest%2Frun-pass%2Fregions-self-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-self-impls.rs?ref=c0d61795defc83fd696971880d60f438a1837f0d", "patch": "@@ -1,3 +1,6 @@\n+// xfail-test\n+// ^ handling of self is currently broken\n+\n type clam = { chowder: &int };\n \n impl clam for clam {"}]}