{"sha": "bce77980a2611da10b42dbd8a672c8cd17f79a94", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjZTc3OTgwYTI2MTFkYTEwYjQyZGJkOGE2NzJjOGNkMTdmNzlhOTQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-03T10:07:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-03T10:07:08Z"}, "message": "Rollup merge of #66967 - Nadrieril:remove-or-pat-hack, r=varkor\n\nRemove hack for top-level or-patterns in match checking\n\nFollow-up to #66612.\n\nOr-patterns are now truly first-class in match checking. As a side-effect, redundant subpatterns are linted as such, making the `unreachable_patterns` lint a bit more general.\n\ncc #54883\n\nr? @varkor", "tree": {"sha": "fdffdffca719ca07e6d715007df2d7675853c490", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdffdffca719ca07e6d715007df2d7675853c490"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bce77980a2611da10b42dbd8a672c8cd17f79a94", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd5jPMCRBK7hj4Ov3rIwAAdHIIAJvpQGCGsJd9bF84YEF08ZGP\nSvfFMpVh4fAk9bP5ZteY/mdkl9nRwCafQ+4ZtOMwnO0H9I5ZcUQzDnA6TrRdgazF\nfJg7udx2AmqKnD5S1Zdd47IFsDMrQm0QDpxPFzbUcvajTRC2OUTyc9lm4JcBTxY6\nKOgbNEEYUavm6r/5XwXAruU/dpaG4g9eOmT2WyZkeSgDp5whCAtF69mUfV4ed3Ba\nFArcn9SeQzUkRqXvnb7vDn0UwuhWjUdevJeAiEm2BOVJ1VplsGfbwA/8DzvCBWaz\n3HSFlvBWJZQLHEwm0zRu9M5dorQv9Bj+Dh+v6d/TQwJDG+c2UNyWjKkY9v8CHRw=\n=7ZX+\n-----END PGP SIGNATURE-----\n", "payload": "tree fdffdffca719ca07e6d715007df2d7675853c490\nparent 1303bf2f3cc7f8a60c9b09895e8b0c0fc8f54f75\nparent 1c1bec2f6dbed0910b2e0ca19cffb92d95be4ee5\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1575367628 +0100\ncommitter GitHub <noreply@github.com> 1575367628 +0100\n\nRollup merge of #66967 - Nadrieril:remove-or-pat-hack, r=varkor\n\nRemove hack for top-level or-patterns in match checking\n\nFollow-up to #66612.\n\nOr-patterns are now truly first-class in match checking. As a side-effect, redundant subpatterns are linted as such, making the `unreachable_patterns` lint a bit more general.\n\ncc #54883\n\nr? @varkor\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bce77980a2611da10b42dbd8a672c8cd17f79a94", "html_url": "https://github.com/rust-lang/rust/commit/bce77980a2611da10b42dbd8a672c8cd17f79a94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bce77980a2611da10b42dbd8a672c8cd17f79a94/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1303bf2f3cc7f8a60c9b09895e8b0c0fc8f54f75", "url": "https://api.github.com/repos/rust-lang/rust/commits/1303bf2f3cc7f8a60c9b09895e8b0c0fc8f54f75", "html_url": "https://github.com/rust-lang/rust/commit/1303bf2f3cc7f8a60c9b09895e8b0c0fc8f54f75"}, {"sha": "1c1bec2f6dbed0910b2e0ca19cffb92d95be4ee5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c1bec2f6dbed0910b2e0ca19cffb92d95be4ee5", "html_url": "https://github.com/rust-lang/rust/commit/1c1bec2f6dbed0910b2e0ca19cffb92d95be4ee5"}], "stats": {"total": 532, "additions": 355, "deletions": 177}, "files": [{"sha": "37a9381271a8cd6bcee2459257ed8fcc53252ad3", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 56, "deletions": 49, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/bce77980a2611da10b42dbd8a672c8cd17f79a94/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce77980a2611da10b42dbd8a672c8cd17f79a94/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=bce77980a2611da10b42dbd8a672c8cd17f79a94", "patch": "@@ -425,16 +425,12 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n     }\n \n     /// This computes `S(constructor, self)`. See top of the file for explanations.\n-    fn specialize_constructor<'a, 'q>(\n+    fn specialize_constructor(\n         &self,\n-        cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+        cx: &mut MatchCheckCtxt<'p, 'tcx>,\n         constructor: &Constructor<'tcx>,\n-        ctor_wild_subpatterns: &[&'q Pat<'tcx>],\n-    ) -> Option<PatStack<'q, 'tcx>>\n-    where\n-        'a: 'q,\n-        'p: 'q,\n-    {\n+        ctor_wild_subpatterns: &'p [Pat<'tcx>],\n+    ) -> Option<PatStack<'p, 'tcx>> {\n         let new_heads = specialize_one_pattern(cx, self.head(), constructor, ctor_wild_subpatterns);\n         new_heads.map(|mut new_head| {\n             new_head.0.extend_from_slice(&self.0[1..]);\n@@ -459,6 +455,7 @@ impl<'p, 'tcx> FromIterator<&'p Pat<'tcx>> for PatStack<'p, 'tcx> {\n }\n \n /// A 2D matrix.\n+#[derive(Clone)]\n pub struct Matrix<'p, 'tcx>(Vec<PatStack<'p, 'tcx>>);\n \n impl<'p, 'tcx> Matrix<'p, 'tcx> {\n@@ -486,16 +483,12 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     }\n \n     /// This computes `S(constructor, self)`. See top of the file for explanations.\n-    fn specialize_constructor<'a, 'q>(\n+    fn specialize_constructor(\n         &self,\n-        cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+        cx: &mut MatchCheckCtxt<'p, 'tcx>,\n         constructor: &Constructor<'tcx>,\n-        ctor_wild_subpatterns: &[&'q Pat<'tcx>],\n-    ) -> Matrix<'q, 'tcx>\n-    where\n-        'a: 'q,\n-        'p: 'q,\n-    {\n+        ctor_wild_subpatterns: &'p [Pat<'tcx>],\n+    ) -> Matrix<'p, 'tcx> {\n         self.0\n             .iter()\n             .filter_map(|r| r.specialize_constructor(cx, constructor, ctor_wild_subpatterns))\n@@ -1033,17 +1026,19 @@ impl<'tcx> Constructor<'tcx> {\n }\n \n #[derive(Clone, Debug)]\n-pub enum Usefulness<'tcx> {\n-    Useful,\n+pub enum Usefulness<'tcx, 'p> {\n+    /// Carries a list of unreachable subpatterns. Used only in the presence of or-patterns.\n+    Useful(Vec<&'p Pat<'tcx>>),\n+    /// Carries a list of witnesses of non-exhaustiveness.\n     UsefulWithWitness(Vec<Witness<'tcx>>),\n     NotUseful,\n }\n \n-impl<'tcx> Usefulness<'tcx> {\n+impl<'tcx, 'p> Usefulness<'tcx, 'p> {\n     fn new_useful(preference: WitnessPreference) -> Self {\n         match preference {\n             ConstructWitness => UsefulWithWitness(vec![Witness(vec![])]),\n-            LeaveOutWitness => Useful,\n+            LeaveOutWitness => Useful(vec![]),\n         }\n     }\n \n@@ -1604,13 +1599,13 @@ impl<'tcx> fmt::Debug for MissingConstructors<'tcx> {\n /// relation to preceding patterns, it is not reachable) and exhaustiveness\n /// checking (if a wildcard pattern is useful in relation to a matrix, the\n /// matrix isn't exhaustive).\n-pub fn is_useful<'p, 'a, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+pub fn is_useful<'p, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n     matrix: &Matrix<'p, 'tcx>,\n-    v: &PatStack<'_, 'tcx>,\n+    v: &PatStack<'p, 'tcx>,\n     witness_preference: WitnessPreference,\n     hir_id: HirId,\n-) -> Usefulness<'tcx> {\n+) -> Usefulness<'tcx, 'p> {\n     let &Matrix(ref rows) = matrix;\n     debug!(\"is_useful({:#?}, {:#?})\", matrix, v);\n \n@@ -1631,11 +1626,26 @@ pub fn is_useful<'p, 'a, 'tcx>(\n \n     // If the first pattern is an or-pattern, expand it.\n     if let Some(vs) = v.expand_or_pat() {\n-        return vs\n-            .into_iter()\n-            .map(|v| is_useful(cx, matrix, &v, witness_preference, hir_id))\n-            .find(|result| result.is_useful())\n-            .unwrap_or(NotUseful);\n+        // We need to push the already-seen patterns into the matrix in order to detect redundant\n+        // branches like `Some(_) | Some(0)`. We also keep track of the unreachable subpatterns.\n+        let mut matrix = matrix.clone();\n+        let mut unreachable_pats = Vec::new();\n+        let mut any_is_useful = false;\n+        for v in vs {\n+            let res = is_useful(cx, &matrix, &v, witness_preference, hir_id);\n+            match res {\n+                Useful(pats) => {\n+                    any_is_useful = true;\n+                    unreachable_pats.extend(pats);\n+                }\n+                NotUseful => unreachable_pats.push(v.head()),\n+                UsefulWithWitness(_) => {\n+                    bug!(\"Encountered or-pat in `v` during exhaustiveness checking\")\n+                }\n+            }\n+            matrix.push(v);\n+        }\n+        return if any_is_useful { Useful(unreachable_pats) } else { NotUseful };\n     }\n \n     let (ty, span) = matrix\n@@ -1768,21 +1778,21 @@ pub fn is_useful<'p, 'a, 'tcx>(\n \n /// A shorthand for the `U(S(c, P), S(c, q))` operation from the paper. I.e., `is_useful` applied\n /// to the specialised version of both the pattern matrix `P` and the new pattern `q`.\n-fn is_useful_specialized<'p, 'a, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+fn is_useful_specialized<'p, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n     matrix: &Matrix<'p, 'tcx>,\n-    v: &PatStack<'_, 'tcx>,\n+    v: &PatStack<'p, 'tcx>,\n     ctor: Constructor<'tcx>,\n     lty: Ty<'tcx>,\n     witness_preference: WitnessPreference,\n     hir_id: HirId,\n-) -> Usefulness<'tcx> {\n+) -> Usefulness<'tcx, 'p> {\n     debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, lty);\n \n-    let ctor_wild_subpatterns_owned: Vec<_> = ctor.wildcard_subpatterns(cx, lty);\n-    let ctor_wild_subpatterns: Vec<_> = ctor_wild_subpatterns_owned.iter().collect();\n-    let matrix = matrix.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns);\n-    v.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns)\n+    let ctor_wild_subpatterns =\n+        cx.pattern_arena.alloc_from_iter(ctor.wildcard_subpatterns(cx, lty));\n+    let matrix = matrix.specialize_constructor(cx, &ctor, ctor_wild_subpatterns);\n+    v.specialize_constructor(cx, &ctor, ctor_wild_subpatterns)\n         .map(|v| is_useful(cx, &matrix, &v, witness_preference, hir_id))\n         .map(|u| u.apply_constructor(cx, &ctor, lty))\n         .unwrap_or(NotUseful)\n@@ -2250,13 +2260,13 @@ fn constructor_covered_by_range<'tcx>(\n     if intersects { Some(()) } else { None }\n }\n \n-fn patterns_for_variant<'p, 'a: 'p, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+fn patterns_for_variant<'p, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n     subpatterns: &'p [FieldPat<'tcx>],\n-    ctor_wild_subpatterns: &[&'p Pat<'tcx>],\n+    ctor_wild_subpatterns: &'p [Pat<'tcx>],\n     is_non_exhaustive: bool,\n ) -> PatStack<'p, 'tcx> {\n-    let mut result = SmallVec::from_slice(ctor_wild_subpatterns);\n+    let mut result: SmallVec<_> = ctor_wild_subpatterns.iter().collect();\n \n     for subpat in subpatterns {\n         if !is_non_exhaustive || !cx.is_uninhabited(subpat.pattern.ty) {\n@@ -2280,11 +2290,11 @@ fn patterns_for_variant<'p, 'a: 'p, 'tcx>(\n /// different patterns.\n /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n /// fields filled with wild patterns.\n-fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    pat: &'q Pat<'tcx>,\n+fn specialize_one_pattern<'p, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n+    pat: &'p Pat<'tcx>,\n     constructor: &Constructor<'tcx>,\n-    ctor_wild_subpatterns: &[&'p Pat<'tcx>],\n+    ctor_wild_subpatterns: &'p [Pat<'tcx>],\n ) -> Option<PatStack<'p, 'tcx>> {\n     if let NonExhaustive = constructor {\n         // Only a wildcard pattern can match the special extra constructor\n@@ -2294,9 +2304,7 @@ fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n     let result = match *pat.kind {\n         PatKind::AscribeUserType { .. } => bug!(), // Handled by `expand_pattern`\n \n-        PatKind::Binding { .. } | PatKind::Wild => {\n-            Some(PatStack::from_slice(ctor_wild_subpatterns))\n-        }\n+        PatKind::Binding { .. } | PatKind::Wild => Some(ctor_wild_subpatterns.iter().collect()),\n \n         PatKind::Variant { adt_def, variant_index, ref subpatterns, .. } => {\n             let ref variant = adt_def.variants[variant_index];\n@@ -2406,7 +2414,6 @@ fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n                                 .chain(\n                                     ctor_wild_subpatterns\n                                         .iter()\n-                                        .map(|p| *p)\n                                         .skip(prefix.len())\n                                         .take(slice_count)\n                                         .chain(suffix.iter()),"}, {"sha": "737af3e1358f4593924610c8f8b7f50b6f64b67e", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 102, "deletions": 118, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/bce77980a2611da10b42dbd8a672c8cd17f79a94/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce77980a2611da10b42dbd8a672c8cd17f79a94/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=bce77980a2611da10b42dbd8a672c8cd17f79a94", "patch": "@@ -139,39 +139,22 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n             let mut have_errors = false;\n \n-            let inlined_arms: Vec<(Vec<_>, _)> = arms\n+            let inlined_arms: Vec<_> = arms\n                 .iter()\n                 .map(|arm| {\n-                    (\n-                        // HACK(or_patterns; Centril | dlrobertson): Remove this and\n-                        // correctly handle exhaustiveness checking for nested or-patterns.\n-                        match &arm.pat.kind {\n-                            hir::PatKind::Or(pats) => pats,\n-                            _ => std::slice::from_ref(&arm.pat),\n-                        }\n-                        .iter()\n-                        .map(|pat| {\n-                            let mut patcx = PatCtxt::new(\n-                                self.tcx,\n-                                self.param_env.and(self.identity_substs),\n-                                self.tables,\n-                            );\n-                            patcx.include_lint_checks();\n-                            let pattern = cx\n-                                .pattern_arena\n-                                .alloc(expand_pattern(cx, patcx.lower_pattern(&pat)))\n-                                as &_;\n-                            if !patcx.errors.is_empty() {\n-                                patcx.report_inlining_errors(pat.span);\n-                                have_errors = true;\n-                            }\n-                            (pattern, &**pat)\n-                        })\n-                        .collect(),\n-                        arm.guard.as_ref().map(|g| match g {\n-                            hir::Guard::If(ref e) => &**e,\n-                        }),\n-                    )\n+                    let mut patcx = PatCtxt::new(\n+                        self.tcx,\n+                        self.param_env.and(self.identity_substs),\n+                        self.tables,\n+                    );\n+                    patcx.include_lint_checks();\n+                    let pattern: &_ =\n+                        cx.pattern_arena.alloc(expand_pattern(cx, patcx.lower_pattern(&arm.pat)));\n+                    if !patcx.errors.is_empty() {\n+                        patcx.report_inlining_errors(arm.pat.span);\n+                        have_errors = true;\n+                    }\n+                    (pattern, &*arm.pat, arm.guard.is_some())\n                 })\n                 .collect();\n \n@@ -181,7 +164,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n             }\n \n             // Fourth, check for unreachable arms.\n-            check_arms(cx, &inlined_arms, source);\n+            let matrix = check_arms(cx, &inlined_arms, source);\n \n             // Then, if the match has no arms, check whether the scrutinee\n             // is uninhabited.\n@@ -248,12 +231,6 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n                 return;\n             }\n \n-            let matrix: Matrix<'_, '_> = inlined_arms\n-                .iter()\n-                .filter(|&&(_, guard)| guard.is_none())\n-                .flat_map(|arm| &arm.0)\n-                .map(|pat| PatStack::from_pattern(pat.0))\n-                .collect();\n             let scrut_ty = self.tables.node_type(scrut.hir_id);\n             check_exhaustive(cx, scrut_ty, scrut.span, &matrix, scrut.hir_id);\n         })\n@@ -267,8 +244,8 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n             patcx.include_lint_checks();\n             let pattern = patcx.lower_pattern(pat);\n             let pattern_ty = pattern.ty;\n-            let pattern = expand_pattern(cx, pattern);\n-            let pats: Matrix<'_, '_> = vec![PatStack::from_pattern(&pattern)].into_iter().collect();\n+            let pattern = cx.pattern_arena.alloc(expand_pattern(cx, pattern));\n+            let pats: Matrix<'_, '_> = vec![PatStack::from_pattern(pattern)].into_iter().collect();\n \n             let witnesses = match check_not_useful(cx, pattern_ty, &pats, pat.hir_id) {\n                 Ok(_) => return,\n@@ -403,113 +380,120 @@ fn pat_is_catchall(pat: &Pat) -> bool {\n }\n \n // Check for unreachable patterns\n-fn check_arms<'tcx>(\n-    cx: &mut MatchCheckCtxt<'_, 'tcx>,\n-    arms: &[(Vec<(&super::Pat<'tcx>, &hir::Pat)>, Option<&hir::Expr>)],\n+fn check_arms<'p, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n+    arms: &[(&'p super::Pat<'tcx>, &hir::Pat, bool)],\n     source: hir::MatchSource,\n-) {\n+) -> Matrix<'p, 'tcx> {\n     let mut seen = Matrix::empty();\n     let mut catchall = None;\n-    for (arm_index, &(ref pats, guard)) in arms.iter().enumerate() {\n-        for &(pat, hir_pat) in pats {\n-            let v = PatStack::from_pattern(pat);\n-\n-            match is_useful(cx, &seen, &v, LeaveOutWitness, hir_pat.hir_id) {\n-                NotUseful => {\n-                    match source {\n-                        hir::MatchSource::IfDesugar { .. } | hir::MatchSource::WhileDesugar => {\n-                            bug!()\n-                        }\n-                        hir::MatchSource::IfLetDesugar { .. } => {\n-                            cx.tcx.lint_hir(\n-                                lint::builtin::IRREFUTABLE_LET_PATTERNS,\n-                                hir_pat.hir_id,\n-                                pat.span,\n-                                \"irrefutable if-let pattern\",\n-                            );\n-                        }\n-\n-                        hir::MatchSource::WhileLetDesugar => {\n-                            // check which arm we're on.\n-                            match arm_index {\n-                                // The arm with the user-specified pattern.\n-                                0 => {\n-                                    cx.tcx.lint_hir(\n-                                        lint::builtin::UNREACHABLE_PATTERNS,\n-                                        hir_pat.hir_id,\n-                                        pat.span,\n-                                        \"unreachable pattern\",\n-                                    );\n-                                }\n-                                // The arm with the wildcard pattern.\n-                                1 => {\n-                                    cx.tcx.lint_hir(\n-                                        lint::builtin::IRREFUTABLE_LET_PATTERNS,\n-                                        hir_pat.hir_id,\n-                                        pat.span,\n-                                        \"irrefutable while-let pattern\",\n-                                    );\n-                                }\n-                                _ => bug!(),\n+    for (arm_index, (pat, hir_pat, has_guard)) in arms.iter().enumerate() {\n+        let v = PatStack::from_pattern(pat);\n+\n+        match is_useful(cx, &seen, &v, LeaveOutWitness, hir_pat.hir_id) {\n+            NotUseful => {\n+                match source {\n+                    hir::MatchSource::IfDesugar { .. } | hir::MatchSource::WhileDesugar => bug!(),\n+\n+                    hir::MatchSource::IfLetDesugar { .. } | hir::MatchSource::WhileLetDesugar => {\n+                        // check which arm we're on.\n+                        match arm_index {\n+                            // The arm with the user-specified pattern.\n+                            0 => {\n+                                cx.tcx.lint_hir(\n+                                    lint::builtin::UNREACHABLE_PATTERNS,\n+                                    hir_pat.hir_id,\n+                                    pat.span,\n+                                    \"unreachable pattern\",\n+                                );\n                             }\n-                        }\n-\n-                        hir::MatchSource::ForLoopDesugar | hir::MatchSource::Normal => {\n-                            let mut err = cx.tcx.struct_span_lint_hir(\n-                                lint::builtin::UNREACHABLE_PATTERNS,\n-                                hir_pat.hir_id,\n-                                pat.span,\n-                                \"unreachable pattern\",\n-                            );\n-                            // if we had a catchall pattern, hint at that\n-                            if let Some(catchall) = catchall {\n-                                err.span_label(pat.span, \"unreachable pattern\");\n-                                err.span_label(catchall, \"matches any value\");\n+                            // The arm with the wildcard pattern.\n+                            1 => {\n+                                let msg = match source {\n+                                    hir::MatchSource::IfLetDesugar { .. } => {\n+                                        \"irrefutable if-let pattern\"\n+                                    }\n+                                    hir::MatchSource::WhileLetDesugar => {\n+                                        \"irrefutable while-let pattern\"\n+                                    }\n+                                    _ => bug!(),\n+                                };\n+                                cx.tcx.lint_hir(\n+                                    lint::builtin::IRREFUTABLE_LET_PATTERNS,\n+                                    hir_pat.hir_id,\n+                                    pat.span,\n+                                    msg,\n+                                );\n                             }\n-                            err.emit();\n+                            _ => bug!(),\n                         }\n+                    }\n \n-                        // Unreachable patterns in try and await expressions occur when one of\n-                        // the arms are an uninhabited type. Which is OK.\n-                        hir::MatchSource::AwaitDesugar | hir::MatchSource::TryDesugar => {}\n+                    hir::MatchSource::ForLoopDesugar | hir::MatchSource::Normal => {\n+                        let mut err = cx.tcx.struct_span_lint_hir(\n+                            lint::builtin::UNREACHABLE_PATTERNS,\n+                            hir_pat.hir_id,\n+                            pat.span,\n+                            \"unreachable pattern\",\n+                        );\n+                        // if we had a catchall pattern, hint at that\n+                        if let Some(catchall) = catchall {\n+                            err.span_label(pat.span, \"unreachable pattern\");\n+                            err.span_label(catchall, \"matches any value\");\n+                        }\n+                        err.emit();\n                     }\n+\n+                    // Unreachable patterns in try and await expressions occur when one of\n+                    // the arms are an uninhabited type. Which is OK.\n+                    hir::MatchSource::AwaitDesugar | hir::MatchSource::TryDesugar => {}\n                 }\n-                Useful => (),\n-                UsefulWithWitness(_) => bug!(),\n             }\n-            if guard.is_none() {\n-                seen.push(v);\n-                if catchall.is_none() && pat_is_catchall(hir_pat) {\n-                    catchall = Some(pat.span);\n+            Useful(unreachable_subpatterns) => {\n+                for pat in unreachable_subpatterns {\n+                    cx.tcx.lint_hir(\n+                        lint::builtin::UNREACHABLE_PATTERNS,\n+                        hir_pat.hir_id,\n+                        pat.span,\n+                        \"unreachable pattern\",\n+                    );\n                 }\n             }\n+            UsefulWithWitness(_) => bug!(),\n+        }\n+        if !has_guard {\n+            seen.push(v);\n+            if catchall.is_none() && pat_is_catchall(hir_pat) {\n+                catchall = Some(pat.span);\n+            }\n         }\n     }\n+    seen\n }\n \n-fn check_not_useful(\n-    cx: &mut MatchCheckCtxt<'_, 'tcx>,\n+fn check_not_useful<'p, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n     ty: Ty<'tcx>,\n-    matrix: &Matrix<'_, 'tcx>,\n+    matrix: &Matrix<'p, 'tcx>,\n     hir_id: HirId,\n ) -> Result<(), Vec<super::Pat<'tcx>>> {\n-    let wild_pattern = super::Pat::wildcard_from_ty(ty);\n-    match is_useful(cx, matrix, &PatStack::from_pattern(&wild_pattern), ConstructWitness, hir_id) {\n+    let wild_pattern = cx.pattern_arena.alloc(super::Pat::wildcard_from_ty(ty));\n+    match is_useful(cx, matrix, &PatStack::from_pattern(wild_pattern), ConstructWitness, hir_id) {\n         NotUseful => Ok(()), // This is good, wildcard pattern isn't reachable.\n         UsefulWithWitness(pats) => Err(if pats.is_empty() {\n-            vec![wild_pattern]\n+            bug!(\"Exhaustiveness check returned no witnesses\")\n         } else {\n             pats.into_iter().map(|w| w.single_pattern()).collect()\n         }),\n-        Useful => bug!(),\n+        Useful(_) => bug!(),\n     }\n }\n \n-fn check_exhaustive<'tcx>(\n-    cx: &mut MatchCheckCtxt<'_, 'tcx>,\n+fn check_exhaustive<'p, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n     scrut_ty: Ty<'tcx>,\n     sp: Span,\n-    matrix: &Matrix<'_, 'tcx>,\n+    matrix: &Matrix<'p, 'tcx>,\n     hir_id: HirId,\n ) {\n     let witnesses = match check_not_useful(cx, scrut_ty, matrix, hir_id) {"}, {"sha": "ce0fe6fc2a3751e05559b1d7b167e1f39c1cbcfd", "filename": "src/test/ui/or-patterns/exhaustiveness-pass.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bce77980a2611da10b42dbd8a672c8cd17f79a94/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce77980a2611da10b42dbd8a672c8cd17f79a94/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-pass.rs?ref=bce77980a2611da10b42dbd8a672c8cd17f79a94", "patch": "@@ -6,35 +6,40 @@\n // We wrap patterns in a tuple because top-level or-patterns are special-cased for now.\n fn main() {\n     // Get the fatal error out of the way\n-    match (0u8,) {\n+    match (0,) {\n         (0 | _,) => {}\n         //~^ ERROR or-patterns are not fully implemented yet\n     }\n \n-    match (0u8,) {\n+    match (0,) {\n         (1 | 2,) => {}\n         _ => {}\n     }\n \n-    match (0u8,) {\n-        (1 | 1,) => {} // FIXME(or_patterns): redundancy not detected for now.\n-        _ => {}\n-    }\n-    match (0u8, 0u8) {\n+    match (0, 0) {\n         (1 | 2, 3 | 4) => {}\n         (1, 2) => {}\n-        (2, 1) => {}\n+        (3, 1) => {}\n         _ => {}\n     }\n     match (Some(0u8),) {\n         (None | Some(0 | 1),) => {}\n         (Some(2..=255),) => {}\n     }\n-    match ((0u8,),) {\n+    match ((0,),) {\n         ((0 | 1,) | (2 | 3,),) => {},\n         ((_,),) => {},\n     }\n     match (&[0u8][..],) {\n         ([] | [0 | 1..=255] | [_, ..],) => {},\n     }\n+\n+    match ((0, 0),) {\n+        ((0, 0) | (0, 1),) => {}\n+        _ => {}\n+    }\n+    match ((0, 0),) {\n+        ((0, 0) | (1, 0),) => {}\n+        _ => {}\n+    }\n }"}, {"sha": "860c7a1bde5fbb6740b68a82b061d90d017edc6f", "filename": "src/test/ui/or-patterns/exhaustiveness-unreachable-pattern.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bce77980a2611da10b42dbd8a672c8cd17f79a94/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce77980a2611da10b42dbd8a672c8cd17f79a94/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs?ref=bce77980a2611da10b42dbd8a672c8cd17f79a94", "patch": "@@ -48,4 +48,32 @@ fn main() {\n         ((1..=4,),) => {}, //~ ERROR unreachable pattern\n         _ => {},\n     }\n+\n+    match (0,) {\n+        (1\n+         | 1,) => {} //~ ERROR unreachable\n+        _ => {}\n+    }\n+    match [0; 2] {\n+        [0\n+            | 0 //~ ERROR unreachable\n+        , 0\n+            | 0] => {} //~ ERROR unreachable\n+        _ => {}\n+    }\n+    match &[][..] {\n+        [0] => {}\n+        [0, _] => {}\n+        [0, _, _] => {}\n+        [1, ..] => {}\n+        [1 //~ ERROR unreachable\n+            | 2, ..] => {}\n+        _ => {}\n+    }\n+    match Some(0) {\n+        Some(0) => {}\n+        Some(0 //~ ERROR unreachable\n+             | 1) => {}\n+        _ => {}\n+    }\n }"}, {"sha": "87f69a484bbbcf89319a1471c7b2407cd1ec6f01", "filename": "src/test/ui/or-patterns/exhaustiveness-unreachable-pattern.stderr", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bce77980a2611da10b42dbd8a672c8cd17f79a94/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bce77980a2611da10b42dbd8a672c8cd17f79a94/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr?ref=bce77980a2611da10b42dbd8a672c8cd17f79a94", "patch": "@@ -70,11 +70,41 @@ error: unreachable pattern\n LL |         ((1..=4,),) => {},\n    |         ^^^^^^^^^^^\n \n+error: unreachable pattern\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:54:12\n+   |\n+LL |          | 1,) => {}\n+   |            ^\n+\n+error: unreachable pattern\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:61:15\n+   |\n+LL |             | 0] => {}\n+   |               ^\n+\n+error: unreachable pattern\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:59:15\n+   |\n+LL |             | 0\n+   |               ^\n+\n+error: unreachable pattern\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:69:10\n+   |\n+LL |         [1\n+   |          ^\n+\n+error: unreachable pattern\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:75:14\n+   |\n+LL |         Some(0\n+   |              ^\n+\n error: or-patterns are not fully implemented yet\n   --> $DIR/exhaustiveness-unreachable-pattern.rs:10:10\n    |\n LL |         (0 | _,) => {}\n    |          ^^^^^\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 17 previous errors\n "}, {"sha": "4b47b978930f30c6e6c21d2f734ccf35296fb912", "filename": "src/test/ui/pattern/usefulness/top-level-alternation.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bce77980a2611da10b42dbd8a672c8cd17f79a94/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftop-level-alternation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce77980a2611da10b42dbd8a672c8cd17f79a94/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftop-level-alternation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftop-level-alternation.rs?ref=bce77980a2611da10b42dbd8a672c8cd17f79a94", "patch": "@@ -0,0 +1,56 @@\n+#![deny(unreachable_patterns)]\n+\n+fn main() {\n+    while let 0..=2 | 1 = 0 {} //~ ERROR unreachable pattern\n+    if let 0..=2 | 1 = 0 {} //~ ERROR unreachable pattern\n+\n+    match 0u8 {\n+        0\n+            | 0 => {} //~ ERROR unreachable pattern\n+        _ => {}\n+    }\n+    match Some(0u8) {\n+        Some(0)\n+            | Some(0) => {} //~ ERROR unreachable pattern\n+        _ => {}\n+    }\n+    match (0u8, 0u8) {\n+        (0, _) | (_, 0) => {}\n+        (0, 0) => {} //~ ERROR unreachable pattern\n+        (1, 1) => {}\n+        _ => {}\n+    }\n+    match (0u8, 0u8) {\n+        (0, 1) | (2, 3) => {}\n+        (0, 3) => {}\n+        (2, 1) => {}\n+        _ => {}\n+    }\n+    match (0u8, 0u8) {\n+        (_, 0) | (_, 1) => {}\n+        _ => {}\n+    }\n+    match (0u8, 0u8) {\n+        (0, _) | (1, _) => {}\n+        _ => {}\n+    }\n+    match Some(0u8) {\n+        None | Some(_) => {}\n+        _ => {} //~ ERROR unreachable pattern\n+    }\n+    match Some(0u8) {\n+        None | Some(_) => {}\n+        Some(_) => {} //~ ERROR unreachable pattern\n+        None => {} //~ ERROR unreachable pattern\n+    }\n+    match Some(0u8) {\n+        Some(_) => {}\n+        None => {}\n+        None | Some(_) => {} //~ ERROR unreachable pattern\n+    }\n+    match 0u8 {\n+        1 | 2 => {},\n+        1..=2 => {}, //~ ERROR unreachable pattern\n+        _ => {},\n+    }\n+}"}, {"sha": "7c7c4fc4eba28ae65112190ace97a72bfa523515", "filename": "src/test/ui/pattern/usefulness/top-level-alternation.stderr", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/bce77980a2611da10b42dbd8a672c8cd17f79a94/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftop-level-alternation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bce77980a2611da10b42dbd8a672c8cd17f79a94/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftop-level-alternation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftop-level-alternation.stderr?ref=bce77980a2611da10b42dbd8a672c8cd17f79a94", "patch": "@@ -0,0 +1,68 @@\n+error: unreachable pattern\n+  --> $DIR/top-level-alternation.rs:4:23\n+   |\n+LL |     while let 0..=2 | 1 = 0 {}\n+   |                       ^\n+   |\n+note: lint level defined here\n+  --> $DIR/top-level-alternation.rs:1:9\n+   |\n+LL | #![deny(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/top-level-alternation.rs:5:20\n+   |\n+LL |     if let 0..=2 | 1 = 0 {}\n+   |                    ^\n+\n+error: unreachable pattern\n+  --> $DIR/top-level-alternation.rs:9:15\n+   |\n+LL |             | 0 => {}\n+   |               ^\n+\n+error: unreachable pattern\n+  --> $DIR/top-level-alternation.rs:14:15\n+   |\n+LL |             | Some(0) => {}\n+   |               ^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/top-level-alternation.rs:19:9\n+   |\n+LL |         (0, 0) => {}\n+   |         ^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/top-level-alternation.rs:39:9\n+   |\n+LL |         _ => {}\n+   |         ^\n+\n+error: unreachable pattern\n+  --> $DIR/top-level-alternation.rs:43:9\n+   |\n+LL |         Some(_) => {}\n+   |         ^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/top-level-alternation.rs:44:9\n+   |\n+LL |         None => {}\n+   |         ^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/top-level-alternation.rs:49:9\n+   |\n+LL |         None | Some(_) => {}\n+   |         ^^^^^^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/top-level-alternation.rs:53:9\n+   |\n+LL |         1..=2 => {},\n+   |         ^^^^^\n+\n+error: aborting due to 10 previous errors\n+"}]}