{"sha": "43a9d90b482c519462bad8c60ccd237506505c78", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzYTlkOTBiNDgyYzUxOTQ2MmJhZDhjNjBjY2QyMzc1MDY1MDVjNzg=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-09-28T23:05:33Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-09-28T23:05:45Z"}, "message": "De-export std::{arc,comm,sync}. Part of #3583.", "tree": {"sha": "dda2c3c6b0dbe7433870bfc5d768282819743835", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dda2c3c6b0dbe7433870bfc5d768282819743835"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43a9d90b482c519462bad8c60ccd237506505c78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43a9d90b482c519462bad8c60ccd237506505c78", "html_url": "https://github.com/rust-lang/rust/commit/43a9d90b482c519462bad8c60ccd237506505c78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43a9d90b482c519462bad8c60ccd237506505c78/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b7d4cd0cf273a3e379813710b164fd3a143f18b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b7d4cd0cf273a3e379813710b164fd3a143f18b", "html_url": "https://github.com/rust-lang/rust/commit/4b7d4cd0cf273a3e379813710b164fd3a143f18b"}], "stats": {"total": 53, "additions": 20, "deletions": 33}, "files": [{"sha": "9d15deab660726baaba36c5198fe0759a0f192ae", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/43a9d90b482c519462bad8c60ccd237506505c78/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43a9d90b482c519462bad8c60ccd237506505c78/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=43a9d90b482c519462bad8c60ccd237506505c78", "patch": "@@ -11,14 +11,9 @@ use private::{SharedMutableState, shared_mutable_state,\n use sync::{Mutex,  mutex_with_condvars,\n               RWlock, rwlock_with_condvars};\n \n-export ARC, clone, get;\n-export Condvar;\n-export MutexARC, mutex_arc_with_condvars, unwrap_mutex_arc;\n-export RWARC, rw_arc_with_condvars, RWWriteMode, RWReadMode;\n-export unwrap_rw_arc;\n \n /// As sync::condvar, a mechanism for unlock-and-descheduling and signalling.\n-struct Condvar { is_mutex: bool, failed: &mut bool, cond: &sync::Condvar }\n+pub struct Condvar { is_mutex: bool, failed: &mut bool, cond: &sync::Condvar }\n \n impl &Condvar {\n     /// Atomically exit the associated ARC and block until a signal is sent.\n@@ -71,15 +66,15 @@ impl &Condvar {\n struct ARC<T: Const Send> { x: SharedMutableState<T> }\n \n /// Create an atomically reference counted wrapper.\n-fn ARC<T: Const Send>(+data: T) -> ARC<T> {\n+pub fn ARC<T: Const Send>(+data: T) -> ARC<T> {\n     ARC { x: unsafe { shared_mutable_state(move data) } }\n }\n \n /**\n  * Access the underlying data in an atomically reference counted\n  * wrapper.\n  */\n-fn get<T: Const Send>(rc: &a/ARC<T>) -> &a/T {\n+pub fn get<T: Const Send>(rc: &a/ARC<T>) -> &a/T {\n     unsafe { get_shared_immutable_state(&rc.x) }\n }\n \n@@ -90,7 +85,7 @@ fn get<T: Const Send>(rc: &a/ARC<T>) -> &a/T {\n  * object. However, one of the `arc` objects can be sent to another task,\n  * allowing them to share the underlying data.\n  */\n-fn clone<T: Const Send>(rc: &ARC<T>) -> ARC<T> {\n+pub fn clone<T: Const Send>(rc: &ARC<T>) -> ARC<T> {\n     ARC { x: unsafe { clone_shared_mutable_state(&rc.x) } }\n }\n \n@@ -118,14 +113,14 @@ struct MutexARCInner<T: Send> { lock: Mutex, failed: bool, data: T }\n struct MutexARC<T: Send> { x: SharedMutableState<MutexARCInner<T>> }\n \n /// Create a mutex-protected ARC with the supplied data.\n-fn MutexARC<T: Send>(+user_data: T) -> MutexARC<T> {\n+pub fn MutexARC<T: Send>(+user_data: T) -> MutexARC<T> {\n     mutex_arc_with_condvars(move user_data, 1)\n }\n /**\n  * Create a mutex-protected ARC with the supplied data and a specified number\n  * of condvars (as sync::mutex_with_condvars).\n  */\n-fn mutex_arc_with_condvars<T: Send>(+user_data: T,\n+pub fn mutex_arc_with_condvars<T: Send>(+user_data: T,\n                                     num_condvars: uint) -> MutexARC<T> {\n     let data =\n         MutexARCInner { lock: mutex_with_condvars(num_condvars),\n@@ -196,7 +191,7 @@ impl<T: Send> &MutexARC<T> {\n  * Will additionally fail if another task has failed while accessing the arc.\n  */\n // FIXME(#2585) make this a by-move method on the arc\n-fn unwrap_mutex_arc<T: Send>(+arc: MutexARC<T>) -> T {\n+pub fn unwrap_mutex_arc<T: Send>(+arc: MutexARC<T>) -> T {\n     let MutexARC { x: x } <- arc;\n     let inner = unsafe { unwrap_shared_mutable_state(move x) };\n     let MutexARCInner { failed: failed, data: data, _ } <- inner;\n@@ -252,14 +247,14 @@ struct RWARC<T: Const Send> {\n }\n \n /// Create a reader/writer ARC with the supplied data.\n-fn RWARC<T: Const Send>(+user_data: T) -> RWARC<T> {\n+pub fn RWARC<T: Const Send>(+user_data: T) -> RWARC<T> {\n     rw_arc_with_condvars(move user_data, 1)\n }\n /**\n  * Create a reader/writer ARC with the supplied data and a specified number\n  * of condvars (as sync::rwlock_with_condvars).\n  */\n-fn rw_arc_with_condvars<T: Const Send>(+user_data: T,\n+pub fn rw_arc_with_condvars<T: Const Send>(+user_data: T,\n                                        num_condvars: uint) -> RWARC<T> {\n     let data =\n         RWARCInner { lock: rwlock_with_condvars(num_condvars),\n@@ -374,7 +369,7 @@ impl<T: Const Send> &RWARC<T> {\n  * in write mode.\n  */\n // FIXME(#2585) make this a by-move method on the arc\n-fn unwrap_rw_arc<T: Const Send>(+arc: RWARC<T>) -> T {\n+pub fn unwrap_rw_arc<T: Const Send>(+arc: RWARC<T>) -> T {\n     let RWARC { x: x, _ } <- arc;\n     let inner = unsafe { unwrap_shared_mutable_state(move x) };\n     let RWARCInner { failed: failed, data: data, _ } <- inner;\n@@ -395,10 +390,10 @@ fn borrow_rwlock<T: Const Send>(state: &r/mut RWARCInner<T>) -> &r/RWlock {\n // FIXME (#3154) ice with struct/&<T> prevents these from being structs.\n \n /// The \"write permission\" token used for RWARC.write_downgrade().\n-enum RWWriteMode<T: Const Send> =\n+pub enum RWWriteMode<T: Const Send> =\n     (&mut T, sync::RWlockWriteMode, PoisonOnFail);\n /// The \"read permission\" token used for RWARC.write_downgrade().\n-enum RWReadMode<T:Const Send> = (&T, sync::RWlockReadMode);\n+pub enum RWReadMode<T:Const Send> = (&T, sync::RWlockReadMode);\n \n impl<T: Const Send> &RWWriteMode<T> {\n     /// Access the pre-downgrade RWARC in write mode."}, {"sha": "4bed7d13d0b850c77df4b9dd005c34cfb1cc0f4a", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43a9d90b482c519462bad8c60ccd237506505c78/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43a9d90b482c519462bad8c60ccd237506505c78/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=43a9d90b482c519462bad8c60ccd237506505c78", "patch": "@@ -9,10 +9,8 @@ Higher level communication abstractions.\n \n use pipes::{Channel, Recv, Chan, Port, Selectable};\n \n-export DuplexStream;\n-\n /// An extension of `pipes::stream` that allows both sending and receiving.\n-struct DuplexStream<T: Send, U: Send> {\n+pub struct DuplexStream<T: Send, U: Send> {\n     priv chan: Chan<T>,\n     priv port: Port <U>,\n }"}, {"sha": "798ae4be6ddcd4173756ae375e0bcce215ff6d47", "filename": "src/libstd/std.rc", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43a9d90b482c519462bad8c60ccd237506505c78/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/43a9d90b482c519462bad8c60ccd237506505c78/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=43a9d90b482c519462bad8c60ccd237506505c78", "patch": "@@ -74,11 +74,8 @@ mod cell;\n \n // Concurrency\n \n-#[legacy_exports]\n mod sync;\n-#[legacy_exports]\n mod arc;\n-#[legacy_exports]\n mod comm;\n \n // Collections"}, {"sha": "2b2cd2b0ba72b22097d4c0d49c6784a866d2bcb3", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/43a9d90b482c519462bad8c60ccd237506505c78/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43a9d90b482c519462bad8c60ccd237506505c78/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=43a9d90b482c519462bad8c60ccd237506505c78", "patch": "@@ -7,9 +7,6 @@\n  * in std.\n  */\n \n-export Condvar, Semaphore, Mutex, mutex_with_condvars;\n-export RWlock, rwlock_with_condvars, RWlockReadMode, RWlockWriteMode;\n-\n use private::{Exclusive, exclusive};\n \n /****************************************************************************\n@@ -176,7 +173,7 @@ fn SemAndSignalRelease(sem: &r/Sem<~[mut Waitqueue]>)\n }\n \n /// A mechanism for atomic-unlock-and-deschedule blocking and signalling.\n-struct Condvar { priv sem: &Sem<~[mut Waitqueue]>, drop { } }\n+pub struct Condvar { priv sem: &Sem<~[mut Waitqueue]>, drop { } }\n \n impl &Condvar {\n     /**\n@@ -379,14 +376,14 @@ impl &Semaphore {\n struct Mutex { priv sem: Sem<~[mut Waitqueue]> }\n \n /// Create a new mutex, with one associated condvar.\n-fn Mutex() -> Mutex { mutex_with_condvars(1) }\n+pub fn Mutex() -> Mutex { mutex_with_condvars(1) }\n /**\n  * Create a new mutex, with a specified number of associated condvars. This\n  * will allow calling wait_on/signal_on/broadcast_on with condvar IDs between\n  * 0 and num_condvars-1. (If num_condvars is 0, lock_cond will be allowed but\n  * any operations on the condvar will fail.)\n  */\n-fn mutex_with_condvars(num_condvars: uint) -> Mutex {\n+pub fn mutex_with_condvars(num_condvars: uint) -> Mutex {\n     Mutex { sem: new_sem_and_signal(1, num_condvars) }\n }\n \n@@ -429,13 +426,13 @@ struct RWlock {\n }\n \n /// Create a new rwlock, with one associated condvar.\n-fn RWlock() -> RWlock { rwlock_with_condvars(1) }\n+pub fn RWlock() -> RWlock { rwlock_with_condvars(1) }\n \n /**\n  * Create a new rwlock, with a specified number of associated condvars.\n  * Similar to mutex_with_condvars.\n  */\n-fn rwlock_with_condvars(num_condvars: uint) -> RWlock {\n+pub fn rwlock_with_condvars(num_condvars: uint) -> RWlock {\n     RWlock { order_lock: semaphore(1),\n              access_lock: new_sem_and_signal(1, num_condvars),\n              state: exclusive(RWlockInner { read_mode:  false,\n@@ -646,9 +643,9 @@ fn RWlockReleaseDowngrade(lock: &r/RWlock) -> RWlockReleaseDowngrade/&r {\n }\n \n /// The \"write permission\" token used for rwlock.write_downgrade().\n-struct RWlockWriteMode { /* priv */ lock: &RWlock, drop { } }\n+pub struct RWlockWriteMode { /* priv */ lock: &RWlock, drop { } }\n /// The \"read permission\" token used for rwlock.write_downgrade().\n-struct RWlockReadMode  { priv lock: &RWlock, drop { } }\n+pub struct RWlockReadMode  { priv lock: &RWlock, drop { } }\n \n impl &RWlockWriteMode {\n     /// Access the pre-downgrade rwlock in write mode."}]}