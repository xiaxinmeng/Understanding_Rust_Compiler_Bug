{"sha": "2e1100997863c4951371cf39554c53266cacb37d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlMTEwMDk5Nzg2M2M0OTUxMzcxY2YzOTU1NGM1MzI2NmNhY2IzN2Q=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-15T05:13:57Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-22T17:42:33Z"}, "message": "std: Audit std::thread implementations\n\nMuch of this code hasn't been updated in quite some time and this commit does a\nsmall audit of the functionality:\n\n* Implementation functions now centralize all functionality on a locally defined\n  `Thread` type.\n* The `detach` method has been removed in favor of a `Drop` implementation. This\n  notably fixes leaking thread handles on Windows.\n* The `Thread` structure is now appropriately annotated with `Send` and `Sync`\n  automatically on Windows and in a custom fashion on Unix.\n* The unsafety of creating a thread has been pushed out to the right boundaries\n  now.\n\nCloses #24442", "tree": {"sha": "e4d266578d80fa55705ba349c4508191fd5a692b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4d266578d80fa55705ba349c4508191fd5a692b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e1100997863c4951371cf39554c53266cacb37d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e1100997863c4951371cf39554c53266cacb37d", "html_url": "https://github.com/rust-lang/rust/commit/2e1100997863c4951371cf39554c53266cacb37d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e1100997863c4951371cf39554c53266cacb37d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9e9279d87d5786fcb8e12482f2920979602267b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9e9279d87d5786fcb8e12482f2920979602267b", "html_url": "https://github.com/rust-lang/rust/commit/e9e9279d87d5786fcb8e12482f2920979602267b"}], "stats": {"total": 577, "additions": 290, "deletions": 287}, "files": [{"sha": "d19ef11c01fc7855f84d36c8f275f2cf2645d257", "filename": "src/libstd/sys/common/thread.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2e1100997863c4951371cf39554c53266cacb37d/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e1100997863c4951371cf39554c53266cacb37d/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs?ref=2e1100997863c4951371cf39554c53266cacb37d", "patch": "@@ -10,22 +10,22 @@\n \n use prelude::v1::*;\n \n-use usize;\n+use alloc::boxed::FnBox;\n use libc;\n-use thunk::Thunk;\n-use sys_common::stack;\n use sys::stack_overflow;\n+use sys_common::stack;\n+use usize;\n \n-// This is the starting point of rust os threads. The first thing we do\n-// is make sure that we don't trigger __morestack (also why this has a\n-// no_stack_check annotation), and then we extract the main function\n-// and invoke it.\n #[no_stack_check]\n-pub fn start_thread(main: *mut libc::c_void) {\n-    unsafe {\n-        stack::record_os_managed_stack_bounds(0, usize::MAX);\n-        let _handler = stack_overflow::Handler::new();\n-        let main: Box<Thunk> = Box::from_raw(main as *mut Thunk);\n-        main();\n-    }\n+pub unsafe fn start_thread(main: *mut libc::c_void) {\n+    // First ensure that we don't trigger __morestack (also why this has a\n+    // no_stack_check annotation).\n+    stack::record_os_managed_stack_bounds(0, usize::MAX);\n+\n+    // Next, set up our stack overflow handler which may get triggered if we run\n+    // out of stack.\n+    let _handler = stack_overflow::Handler::new();\n+\n+    // Finally, let's run some code.\n+    Box::from_raw(main as *mut Box<FnBox()>)()\n }"}, {"sha": "281ac37e671152845bc3caaddf807f9e4a533133", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 144, "deletions": 130, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/2e1100997863c4951371cf39554c53266cacb37d/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e1100997863c4951371cf39554c53266cacb37d/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=2e1100997863c4951371cf39554c53266cacb37d", "patch": "@@ -10,8 +10,9 @@\n \n #![allow(dead_code)]\n \n-use core::prelude::*;\n+use prelude::v1::*;\n \n+use alloc::boxed::FnBox;\n use cmp;\n use ffi::CString;\n use io;\n@@ -20,13 +21,148 @@ use libc;\n use mem;\n use ptr;\n use sys::os;\n-use thunk::Thunk;\n use time::Duration;\n \n use sys_common::stack::RED_ZONE;\n use sys_common::thread::*;\n \n-pub type rust_thread = libc::pthread_t;\n+pub struct Thread {\n+    id: libc::pthread_t,\n+}\n+\n+// Some platforms may have pthread_t as a pointer in which case we still want\n+// a thread to be Send/Sync\n+unsafe impl Send for Thread {}\n+unsafe impl Sync for Thread {}\n+\n+impl Thread {\n+    pub unsafe fn new<'a>(stack: usize, p: Box<FnBox() + 'a>)\n+                          -> io::Result<Thread> {\n+        let p = box p;\n+        let mut native: libc::pthread_t = mem::zeroed();\n+        let mut attr: libc::pthread_attr_t = mem::zeroed();\n+        assert_eq!(pthread_attr_init(&mut attr), 0);\n+\n+        // Reserve room for the red zone, the runtime's stack of last resort.\n+        let stack_size = cmp::max(stack, RED_ZONE + min_stack_size(&attr));\n+        match pthread_attr_setstacksize(&mut attr, stack_size as libc::size_t) {\n+            0 => {}\n+            n => {\n+                assert_eq!(n, libc::EINVAL);\n+                // EINVAL means |stack_size| is either too small or not a\n+                // multiple of the system page size.  Because it's definitely\n+                // >= PTHREAD_STACK_MIN, it must be an alignment issue.\n+                // Round up to the nearest page and try again.\n+                let page_size = os::page_size();\n+                let stack_size = (stack_size + page_size - 1) &\n+                                 (-(page_size as isize - 1) as usize - 1);\n+                let stack_size = stack_size as libc::size_t;\n+                assert_eq!(pthread_attr_setstacksize(&mut attr, stack_size), 0);\n+            }\n+        };\n+\n+        let ret = pthread_create(&mut native, &attr, thread_start,\n+                                 &*p as *const _ as *mut _);\n+        assert_eq!(pthread_attr_destroy(&mut attr), 0);\n+\n+        return if ret != 0 {\n+            Err(io::Error::from_raw_os_error(ret))\n+        } else {\n+            mem::forget(p); // ownership passed to pthread_create\n+            Ok(Thread { id: native })\n+        };\n+\n+        #[no_stack_check]\n+        extern fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void {\n+            unsafe { start_thread(main); }\n+            0 as *mut _\n+        }\n+    }\n+\n+    pub fn yield_now() {\n+        let ret = unsafe { sched_yield() };\n+        debug_assert_eq!(ret, 0);\n+    }\n+\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    pub fn set_name(name: &str) {\n+        // pthread wrapper only appeared in glibc 2.12, so we use syscall\n+        // directly.\n+        extern {\n+            fn prctl(option: libc::c_int, arg2: libc::c_ulong,\n+                     arg3: libc::c_ulong, arg4: libc::c_ulong,\n+                     arg5: libc::c_ulong) -> libc::c_int;\n+        }\n+        const PR_SET_NAME: libc::c_int = 15;\n+        let cname = CString::new(name).unwrap_or_else(|_| {\n+            panic!(\"thread name may not contain interior null bytes\")\n+        });\n+        unsafe {\n+            prctl(PR_SET_NAME, cname.as_ptr() as libc::c_ulong, 0, 0, 0);\n+        }\n+    }\n+\n+    #[cfg(any(target_os = \"freebsd\",\n+              target_os = \"dragonfly\",\n+              target_os = \"bitrig\",\n+              target_os = \"openbsd\"))]\n+    pub fn set_name(name: &str) {\n+        extern {\n+            fn pthread_set_name_np(tid: libc::pthread_t,\n+                                   name: *const libc::c_char);\n+        }\n+        let cname = CString::new(name).unwrap();\n+        unsafe {\n+            pthread_set_name_np(pthread_self(), cname.as_ptr());\n+        }\n+    }\n+\n+    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+    pub fn set_name(name: &str) {\n+        extern {\n+            fn pthread_setname_np(name: *const libc::c_char) -> libc::c_int;\n+        }\n+        let cname = CString::new(name).unwrap();\n+        unsafe {\n+            pthread_setname_np(cname.as_ptr());\n+        }\n+    }\n+\n+    pub fn sleep(dur: Duration) {\n+        if dur < Duration::zero() {\n+            return Thread::yield_now()\n+        }\n+        let seconds = dur.num_seconds();\n+        let ns = dur - Duration::seconds(seconds);\n+        let mut ts = libc::timespec {\n+            tv_sec: seconds as libc::time_t,\n+            tv_nsec: ns.num_nanoseconds().unwrap() as libc::c_long,\n+        };\n+\n+        // If we're awoken with a signal then the return value will be -1 and\n+        // nanosleep will fill in `ts` with the remaining time.\n+        unsafe {\n+            while libc::nanosleep(&ts, &mut ts) == -1 {\n+                assert_eq!(os::errno(), libc::EINTR);\n+            }\n+        }\n+    }\n+\n+    pub fn join(self) {\n+        unsafe {\n+            let ret = pthread_join(self.id, ptr::null_mut());\n+            mem::forget(self);\n+            debug_assert_eq!(ret, 0);\n+        }\n+    }\n+}\n+\n+impl Drop for Thread {\n+    fn drop(&mut self) {\n+        let ret = unsafe { pthread_detach(self.id) };\n+        debug_assert_eq!(ret, 0);\n+    }\n+}\n \n #[cfg(all(not(target_os = \"linux\"),\n           not(target_os = \"macos\"),\n@@ -183,128 +319,6 @@ pub mod guard {\n     }\n }\n \n-pub unsafe fn create(stack: usize, p: Thunk) -> io::Result<rust_thread> {\n-    let p = box p;\n-    let mut native: libc::pthread_t = mem::zeroed();\n-    let mut attr: libc::pthread_attr_t = mem::zeroed();\n-    assert_eq!(pthread_attr_init(&mut attr), 0);\n-\n-    // Reserve room for the red zone, the runtime's stack of last resort.\n-    let stack_size = cmp::max(stack, RED_ZONE + min_stack_size(&attr) as usize);\n-    match pthread_attr_setstacksize(&mut attr, stack_size as libc::size_t) {\n-        0 => {}\n-        n => {\n-            assert_eq!(n, libc::EINVAL);\n-            // EINVAL means |stack_size| is either too small or not a\n-            // multiple of the system page size.  Because it's definitely\n-            // >= PTHREAD_STACK_MIN, it must be an alignment issue.\n-            // Round up to the nearest page and try again.\n-            let page_size = os::page_size();\n-            let stack_size = (stack_size + page_size - 1) &\n-                             (-(page_size as isize - 1) as usize - 1);\n-            assert_eq!(pthread_attr_setstacksize(&mut attr,\n-                                                 stack_size as libc::size_t), 0);\n-        }\n-    };\n-\n-    let ret = pthread_create(&mut native, &attr, thread_start,\n-                             &*p as *const _ as *mut _);\n-    assert_eq!(pthread_attr_destroy(&mut attr), 0);\n-\n-    return if ret != 0 {\n-        Err(io::Error::from_raw_os_error(ret))\n-    } else {\n-        mem::forget(p); // ownership passed to pthread_create\n-        Ok(native)\n-    };\n-\n-    #[no_stack_check]\n-    extern fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void {\n-        start_thread(main);\n-        0 as *mut _\n-    }\n-}\n-\n-#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-pub unsafe fn set_name(name: &str) {\n-    // pthread wrapper only appeared in glibc 2.12, so we use syscall directly.\n-    extern {\n-        fn prctl(option: libc::c_int, arg2: libc::c_ulong, arg3: libc::c_ulong,\n-                 arg4: libc::c_ulong, arg5: libc::c_ulong) -> libc::c_int;\n-    }\n-    const PR_SET_NAME: libc::c_int = 15;\n-    let cname = CString::new(name).unwrap_or_else(|_| {\n-        panic!(\"thread name may not contain interior null bytes\")\n-    });\n-    prctl(PR_SET_NAME, cname.as_ptr() as libc::c_ulong, 0, 0, 0);\n-}\n-\n-#[cfg(any(target_os = \"freebsd\",\n-          target_os = \"dragonfly\",\n-          target_os = \"bitrig\",\n-          target_os = \"openbsd\"))]\n-pub unsafe fn set_name(name: &str) {\n-    extern {\n-        fn pthread_set_name_np(tid: libc::pthread_t, name: *const libc::c_char);\n-    }\n-    let cname = CString::new(name).unwrap();\n-    pthread_set_name_np(pthread_self(), cname.as_ptr());\n-}\n-\n-#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-pub unsafe fn set_name(name: &str) {\n-    extern {\n-        fn pthread_setname_np(name: *const libc::c_char) -> libc::c_int;\n-    }\n-    let cname = CString::new(name).unwrap();\n-    pthread_setname_np(cname.as_ptr());\n-}\n-\n-pub unsafe fn join(native: rust_thread) {\n-    assert_eq!(pthread_join(native, ptr::null_mut()), 0);\n-}\n-\n-pub unsafe fn detach(native: rust_thread) {\n-    assert_eq!(pthread_detach(native), 0);\n-}\n-\n-pub unsafe fn yield_now() {\n-    assert_eq!(sched_yield(), 0);\n-}\n-\n-pub fn sleep(dur: Duration) {\n-    unsafe {\n-        if dur < Duration::zero() {\n-            return yield_now()\n-        }\n-        let seconds = dur.num_seconds();\n-        let ns = dur - Duration::seconds(seconds);\n-        let mut ts = libc::timespec {\n-            tv_sec: seconds as libc::time_t,\n-            tv_nsec: ns.num_nanoseconds().unwrap() as libc::c_long,\n-        };\n-        // If we're awoken with a signal then the return value will be -1 and\n-        // nanosleep will fill in `ts` with the remaining time.\n-        while dosleep(&mut ts) == -1 {\n-            assert_eq!(os::errno(), libc::EINTR);\n-        }\n-    }\n-\n-    #[cfg(target_os = \"linux\")]\n-    unsafe fn dosleep(ts: *mut libc::timespec) -> libc::c_int {\n-        extern {\n-            fn clock_nanosleep(clock_id: libc::c_int, flags: libc::c_int,\n-                               request: *const libc::timespec,\n-                               remain: *mut libc::timespec) -> libc::c_int;\n-        }\n-        clock_nanosleep(libc::CLOCK_MONOTONIC, 0, ts, ts)\n-    }\n-    #[cfg(not(target_os = \"linux\"))]\n-    unsafe fn dosleep(ts: *mut libc::timespec) -> libc::c_int {\n-        libc::nanosleep(ts, ts)\n-    }\n-}\n-\n // glibc >= 2.15 has a __pthread_get_minstack() function that returns\n // PTHREAD_STACK_MIN plus however many bytes are needed for thread-local\n // storage.  We need that information to avoid blowing up when a small stack\n@@ -319,7 +333,7 @@ pub fn sleep(dur: Duration) {\n // but that caused Debian to detect an unnecessarily strict versioned\n // dependency on libc6 (#23628).\n #[cfg(target_os = \"linux\")]\n-fn min_stack_size(attr: *const libc::pthread_attr_t) -> libc::size_t {\n+fn min_stack_size(attr: *const libc::pthread_attr_t) -> usize {\n     use dynamic_lib::DynamicLibrary;\n     use sync::{Once, ONCE_INIT};\n \n@@ -337,16 +351,16 @@ fn min_stack_size(attr: *const libc::pthread_attr_t) -> libc::size_t {\n     });\n \n     match unsafe { __pthread_get_minstack } {\n-        None => PTHREAD_STACK_MIN,\n-        Some(f) => unsafe { f(attr) },\n+        None => PTHREAD_STACK_MIN as usize,\n+        Some(f) => unsafe { f(attr) as usize },\n     }\n }\n \n // No point in looking up __pthread_get_minstack() on non-glibc\n // platforms.\n #[cfg(not(target_os = \"linux\"))]\n-fn min_stack_size(_: *const libc::pthread_attr_t) -> libc::size_t {\n-    PTHREAD_STACK_MIN\n+fn min_stack_size(_: *const libc::pthread_attr_t) -> usize {\n+    PTHREAD_STACK_MIN as usize\n }\n \n extern {"}, {"sha": "b07d063de45c992630cd76c61459b1c08ac7823e", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2e1100997863c4951371cf39554c53266cacb37d/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e1100997863c4951371cf39554c53266cacb37d/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=2e1100997863c4951371cf39554c53266cacb37d", "patch": "@@ -471,6 +471,17 @@ extern \"system\" {\n                       hWritePipe: libc::LPHANDLE,\n                       lpPipeAttributes: libc::LPSECURITY_ATTRIBUTES,\n                       nSize: libc::DWORD) -> libc::BOOL;\n+    pub fn CreateThread(lpThreadAttributes: libc::LPSECURITY_ATTRIBUTES,\n+                        dwStackSize: libc::SIZE_T,\n+                        lpStartAddress: extern \"system\" fn(*mut libc::c_void)\n+                                                           -> libc::DWORD,\n+                        lpParameter: libc::LPVOID,\n+                        dwCreationFlags: libc::DWORD,\n+                        lpThreadId: libc::LPDWORD) -> libc::HANDLE;\n+    pub fn WaitForSingleObject(hHandle: libc::HANDLE,\n+                               dwMilliseconds: libc::DWORD) -> libc::DWORD;\n+    pub fn SwitchToThread() -> libc::BOOL;\n+    pub fn Sleep(dwMilliseconds: libc::DWORD);\n }\n \n #[link(name = \"userenv\")]"}, {"sha": "797f45f8702e7d00a6fe8159e9aafd4dbadfad49", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 66, "deletions": 77, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/2e1100997863c4951371cf39554c53266cacb37d/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e1100997863c4951371cf39554c53266cacb37d/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=2e1100997863c4951371cf39554c53266cacb37d", "patch": "@@ -10,102 +10,91 @@\n \n use prelude::v1::*;\n \n+use alloc::boxed::FnBox;\n use cmp;\n use io;\n-use libc::{self, c_void};\n-use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES, SIZE_T, BOOL,\n-                                   LPVOID, DWORD, LPDWORD, HANDLE};\n+use libc::{self, c_void, DWORD};\n use mem;\n use ptr;\n+use sys::c;\n+use sys::handle::Handle;\n use sys_common::stack::RED_ZONE;\n use sys_common::thread::*;\n-use thunk::Thunk;\n use time::Duration;\n \n-pub type rust_thread = HANDLE;\n-\n-pub mod guard {\n-    pub unsafe fn main() -> usize { 0 }\n-    pub unsafe fn current() -> usize { 0 }\n-    pub unsafe fn init() {}\n+pub struct Thread {\n+    handle: Handle\n }\n \n-pub unsafe fn create(stack: usize, p: Thunk) -> io::Result<rust_thread> {\n-    let p = box p;\n-    // FIXME On UNIX, we guard against stack sizes that are too small but\n-    // that's because pthreads enforces that stacks are at least\n-    // PTHREAD_STACK_MIN bytes big.  Windows has no such lower limit, it's\n-    // just that below a certain threshold you can't do anything useful.\n-    // That threshold is application and architecture-specific, however.\n-    // For now, the only requirement is that it's big enough to hold the\n-    // red zone.  Round up to the next 64 kB because that's what the NT\n-    // kernel does, might as well make it explicit.  With the current\n-    // 20 kB red zone, that makes for a 64 kB minimum stack.\n-    let stack_size = (cmp::max(stack, RED_ZONE) + 0xfffe) & (-0xfffe - 1);\n-    let ret = CreateThread(ptr::null_mut(), stack_size as libc::size_t,\n-                           thread_start, &*p as *const _ as *mut _,\n-                           0, ptr::null_mut());\n+impl Thread {\n+    pub unsafe fn new<'a>(stack: usize, p: Box<FnBox() + 'a>)\n+                          -> io::Result<Thread> {\n+        let p = box p;\n \n-    return if ret as usize == 0 {\n-        Err(io::Error::last_os_error())\n-    } else {\n-        mem::forget(p); // ownership passed to CreateThread\n-        Ok(ret)\n-    };\n+        // FIXME On UNIX, we guard against stack sizes that are too small but\n+        // that's because pthreads enforces that stacks are at least\n+        // PTHREAD_STACK_MIN bytes big.  Windows has no such lower limit, it's\n+        // just that below a certain threshold you can't do anything useful.\n+        // That threshold is application and architecture-specific, however.\n+        // For now, the only requirement is that it's big enough to hold the\n+        // red zone.  Round up to the next 64 kB because that's what the NT\n+        // kernel does, might as well make it explicit.  With the current\n+        // 20 kB red zone, that makes for a 64 kB minimum stack.\n+        let stack_size = (cmp::max(stack, RED_ZONE) + 0xfffe) & (-0xfffe - 1);\n+        let ret = c::CreateThread(ptr::null_mut(), stack_size as libc::size_t,\n+                                  thread_start, &*p as *const _ as *mut _,\n+                                  0, ptr::null_mut());\n \n-    #[no_stack_check]\n-    extern \"system\" fn thread_start(main: *mut libc::c_void) -> DWORD {\n-        start_thread(main);\n-        0\n-    }\n-}\n+        return if ret as usize == 0 {\n+            Err(io::Error::last_os_error())\n+        } else {\n+            mem::forget(p); // ownership passed to CreateThread\n+            Ok(Thread { handle: Handle::new(ret) })\n+        };\n \n-pub unsafe fn set_name(_name: &str) {\n-    // Windows threads are nameless\n-    // The names in MSVC debugger are obtained using a \"magic\" exception,\n-    // which requires a use of MS C++ extensions.\n-    // See https://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx\n-}\n+        #[no_stack_check]\n+        extern \"system\" fn thread_start(main: *mut libc::c_void) -> DWORD {\n+            unsafe { start_thread(main); }\n+            0\n+        }\n+    }\n \n-pub unsafe fn join(native: rust_thread) {\n-    use libc::consts::os::extra::INFINITE;\n-    WaitForSingleObject(native, INFINITE);\n-}\n+    pub fn set_name(_name: &str) {\n+        // Windows threads are nameless\n+        // The names in MSVC debugger are obtained using a \"magic\" exception,\n+        // which requires a use of MS C++ extensions.\n+        // See https://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx\n+    }\n \n-pub unsafe fn detach(native: rust_thread) {\n-    assert!(libc::CloseHandle(native) != 0);\n-}\n+    pub fn join(self) {\n+        use libc::consts::os::extra::INFINITE;\n+        unsafe { c::WaitForSingleObject(self.handle.raw(), INFINITE); }\n+    }\n \n-pub unsafe fn yield_now() {\n-    // This function will return 0 if there are no other threads to execute,\n-    // but this also means that the yield was useless so this isn't really a\n-    // case that needs to be worried about.\n-    SwitchToThread();\n-}\n+    pub fn yield_now() {\n+        // This function will return 0 if there are no other threads to execute,\n+        // but this also means that the yield was useless so this isn't really a\n+        // case that needs to be worried about.\n+        unsafe { c::SwitchToThread(); }\n+    }\n \n-pub fn sleep(dur: Duration) {\n-    unsafe {\n-        if dur < Duration::zero() {\n-            return yield_now()\n+    pub fn sleep(dur: Duration) {\n+        unsafe {\n+            if dur < Duration::zero() {\n+                return Thread::yield_now()\n+            }\n+            let ms = dur.num_milliseconds();\n+            // if we have a fractional number of milliseconds then add an extra\n+            // millisecond to sleep for\n+            let extra = dur - Duration::milliseconds(ms);\n+            let ms = ms + if extra.is_zero() {0} else {1};\n+            c::Sleep(ms as DWORD);\n         }\n-        let ms = dur.num_milliseconds();\n-        // if we have a fractional number of milliseconds then add an extra\n-        // millisecond to sleep for\n-        let extra = dur - Duration::milliseconds(ms);\n-        let ms = ms + if extra.is_zero() {0} else {1};\n-        Sleep(ms as DWORD);\n     }\n }\n \n-#[allow(non_snake_case)]\n-extern \"system\" {\n-    fn CreateThread(lpThreadAttributes: LPSECURITY_ATTRIBUTES,\n-                    dwStackSize: SIZE_T,\n-                    lpStartAddress: extern \"system\" fn(*mut c_void) -> DWORD,\n-                    lpParameter: LPVOID,\n-                    dwCreationFlags: DWORD,\n-                    lpThreadId: LPDWORD) -> HANDLE;\n-    fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;\n-    fn SwitchToThread() -> BOOL;\n-    fn Sleep(dwMilliseconds: DWORD);\n+pub mod guard {\n+    pub unsafe fn main() -> usize { 0 }\n+    pub unsafe fn current() -> usize { 0 }\n+    pub unsafe fn init() {}\n }"}, {"sha": "28e4650478bb346ddf50d89be06e8f356f069753", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 55, "deletions": 66, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/2e1100997863c4951371cf39554c53266cacb37d/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e1100997863c4951371cf39554c53266cacb37d/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=2e1100997863c4951371cf39554c53266cacb37d", "patch": "@@ -190,6 +190,7 @@\n \n use prelude::v1::*;\n \n+use alloc::boxed::FnBox;\n use any::Any;\n use cell::UnsafeCell;\n use fmt;\n@@ -199,7 +200,6 @@ use rt::{self, unwind};\n use sync::{Mutex, Condvar, Arc};\n use sys::thread as imp;\n use sys_common::{stack, thread_info};\n-use thunk::Thunk;\n use time::Duration;\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -276,7 +276,9 @@ impl Builder {\n     pub fn spawn<F, T>(self, f: F) -> io::Result<JoinHandle<T>> where\n         F: FnOnce() -> T, F: Send + 'static, T: Send + 'static\n     {\n-        self.spawn_inner(Box::new(f)).map(|i| JoinHandle(i))\n+        unsafe {\n+            self.spawn_inner(Box::new(f)).map(JoinHandle)\n+        }\n     }\n \n     /// Spawns a new child thread that must be joined within a given\n@@ -299,21 +301,27 @@ impl Builder {\n     pub fn scoped<'a, T, F>(self, f: F) -> io::Result<JoinGuard<'a, T>> where\n         T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n     {\n-        self.spawn_inner(Box::new(f)).map(|inner| {\n-            JoinGuard { inner: inner, _marker: PhantomData }\n-        })\n+        unsafe {\n+            self.spawn_inner(Box::new(f)).map(|inner| {\n+                JoinGuard { inner: inner, _marker: PhantomData }\n+            })\n+        }\n     }\n \n-    fn spawn_inner<T: Send>(self, f: Thunk<(), T>) -> io::Result<JoinInner<T>> {\n+    // NB: this function is unsafe as the lifetime parameter of the code to run\n+    //     in the new thread is not tied into the return value, and the return\n+    //     value must not outlast that lifetime.\n+    unsafe fn spawn_inner<'a, T: Send>(self, f: Box<FnBox() -> T + Send + 'a>)\n+                                       -> io::Result<JoinInner<T>> {\n         let Builder { name, stack_size } = self;\n \n         let stack_size = stack_size.unwrap_or(rt::min_stack());\n \n         let my_thread = Thread::new(name);\n         let their_thread = my_thread.clone();\n \n-        let my_packet = Packet(Arc::new(UnsafeCell::new(None)));\n-        let their_packet = Packet(my_packet.0.clone());\n+        let my_packet = Arc::new(UnsafeCell::new(None));\n+        let their_packet = my_packet.clone();\n \n         // Spawning a new OS thread guarantees that __morestack will never get\n         // triggered, but we must manually set up the actual stack bounds once\n@@ -326,48 +334,27 @@ impl Builder {\n             let addr = &something_around_the_top_of_the_stack as *const i32;\n             let my_stack_top = addr as usize;\n             let my_stack_bottom = my_stack_top - stack_size + 1024;\n-            unsafe {\n-                if let Some(name) = their_thread.name() {\n-                    imp::set_name(name);\n-                }\n-                stack::record_os_managed_stack_bounds(my_stack_bottom,\n-                                                      my_stack_top);\n-                thread_info::set(imp::guard::current(), their_thread);\n+            stack::record_os_managed_stack_bounds(my_stack_bottom, my_stack_top);\n+\n+            if let Some(name) = their_thread.name() {\n+                imp::Thread::set_name(name);\n             }\n+            thread_info::set(imp::guard::current(), their_thread);\n \n-            let mut output: Option<T> = None;\n+            let mut output = None;\n             let try_result = {\n                 let ptr = &mut output;\n-\n-                // There are two primary reasons that general try/catch is\n-                // unsafe. The first is that we do not support nested\n-                // try/catch. The fact that this is happening in a newly-spawned\n-                // thread suffices. The second is that unwinding while unwinding\n-                // is not defined.  We take care of that by having an\n-                // 'unwinding' flag in the thread itself. For these reasons,\n-                // this unsafety should be ok.\n-                unsafe {\n-                    unwind::try(move || {\n-                        let f: Thunk<(), T> = f;\n-                        let v: T = f();\n-                        *ptr = Some(v)\n-                    })\n-                }\n+                unwind::try(move || *ptr = Some(f()))\n             };\n-            unsafe {\n-                *their_packet.0.get() = Some(match (output, try_result) {\n-                    (Some(data), Ok(_)) => Ok(data),\n-                    (None, Err(cause)) => Err(cause),\n-                    _ => unreachable!()\n-                });\n-            }\n+            *their_packet.get() = Some(try_result.map(|()| {\n+                output.unwrap()\n+            }));\n         };\n \n         Ok(JoinInner {\n-            native: try!(unsafe { imp::create(stack_size, Box::new(main)) }),\n+            native: Some(try!(imp::Thread::new(stack_size, Box::new(main)))),\n             thread: my_thread,\n-            packet: my_packet,\n-            joined: false,\n+            packet: Packet(my_packet),\n         })\n     }\n }\n@@ -427,7 +414,7 @@ pub fn current() -> Thread {\n /// Cooperatively gives up a timeslice to the OS scheduler.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn yield_now() {\n-    unsafe { imp::yield_now() }\n+    imp::Thread::yield_now()\n }\n \n /// Determines whether the current thread is unwinding because of panic.\n@@ -494,7 +481,7 @@ pub fn catch_panic<F, R>(f: F) -> Result<R>\n /// spurious wakeup.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn sleep_ms(ms: u32) {\n-    imp::sleep(Duration::milliseconds(ms as i64))\n+    imp::Thread::sleep(Duration::milliseconds(ms as i64))\n }\n \n /// Blocks unless or until the current thread's token is made available (may wake spuriously).\n@@ -548,8 +535,6 @@ struct Inner {\n     cvar: Condvar,\n }\n \n-unsafe impl Sync for Inner {}\n-\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n /// A handle to a thread.\n@@ -610,24 +595,33 @@ impl thread_info::NewThread for Thread {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub type Result<T> = ::result::Result<T, Box<Any + Send + 'static>>;\n \n+// This packet is used to communicate the return value between the child thread\n+// and the parent thread. Memory is shared through the `Arc` within and there's\n+// no need for a mutex here because synchronization happens with `join()` (the\n+// parent thread never reads this packet until the child has exited).\n+//\n+// This packet itself is then stored into a `JoinInner` which in turns is placed\n+// in `JoinHandle` and `JoinGuard`. Due to the usage of `UnsafeCell` we need to\n+// manually worry about impls like Send and Sync. The type `T` should\n+// already always be Send (otherwise the thread could not have been created) and\n+// this type is inherently Sync because no methods take &self. Regardless,\n+// however, we add inheriting impls for Send/Sync to this type to ensure it's\n+// Send/Sync and that future modifications will still appropriately classify it.\n struct Packet<T>(Arc<UnsafeCell<Option<Result<T>>>>);\n \n-unsafe impl<T:Send> Send for Packet<T> {}\n-unsafe impl<T> Sync for Packet<T> {}\n+unsafe impl<T: Send> Send for Packet<T> {}\n+unsafe impl<T: Sync> Sync for Packet<T> {}\n \n /// Inner representation for JoinHandle and JoinGuard\n struct JoinInner<T> {\n-    native: imp::rust_thread,\n+    native: Option<imp::Thread>,\n     thread: Thread,\n     packet: Packet<T>,\n-    joined: bool,\n }\n \n impl<T> JoinInner<T> {\n     fn join(&mut self) -> Result<T> {\n-        assert!(!self.joined);\n-        unsafe { imp::join(self.native) };\n-        self.joined = true;\n+        self.native.take().unwrap().join();\n         unsafe {\n             (*self.packet.0.get()).take().unwrap()\n         }\n@@ -662,16 +656,6 @@ impl<T> JoinHandle<T> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[unsafe_destructor]\n-impl<T> Drop for JoinHandle<T> {\n-    fn drop(&mut self) {\n-        if !self.0.joined {\n-            unsafe { imp::detach(self.0.native) }\n-        }\n-    }\n-}\n-\n /// An RAII-style guard that will block until thread termination when dropped.\n ///\n /// The type `T` is the return type for the thread's main function.\n@@ -720,14 +704,19 @@ impl<'a, T: Send + 'a> JoinGuard<'a, T> {\n            reason = \"memory unsafe if destructor is avoided, see #24292\")]\n impl<'a, T: Send + 'a> Drop for JoinGuard<'a, T> {\n     fn drop(&mut self) {\n-        if !self.inner.joined {\n-            if self.inner.join().is_err() {\n-                panic!(\"child thread {:?} panicked\", self.thread());\n-            }\n+        if self.inner.native.is_some() && self.inner.join().is_err() {\n+            panic!(\"child thread {:?} panicked\", self.thread());\n         }\n     }\n }\n \n+fn _assert_sync_and_send() {\n+    fn _assert_both<T: Send + Sync>() {}\n+    _assert_both::<JoinHandle<()>>();\n+    _assert_both::<JoinGuard<()>>();\n+    _assert_both::<Thread>();\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Tests\n ////////////////////////////////////////////////////////////////////////////////"}]}