{"sha": "69a528eda688b3191127865f889fef65d979bb9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5YTUyOGVkYTY4OGIzMTkxMTI3ODY1Zjg4OWZlZjY1ZDk3OWJiOWM=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-20T22:30:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-20T22:30:53Z"}, "message": "Rollup merge of #69362 - CAD97:alloc_layout_extras, r=Amanieu\n\nStabilize most common subset of alloc_layout_extras\n\nTracking issue: https://github.com/rust-lang/rust/issues/55724\n\nSpecifically, this stabilizes:\n\n```rust\npub fn Layout::align_to(&self, align: usize) -> Result<Layout, LayoutErr>;\npub fn Layout::pad_to_align(&self) -> Layout;\npub fn Layout::extend(&self, next: Layout) -> Result<(Layout, usize), LayoutErr>;\npub fn Layout::array<T>(n: usize) -> Result<Layout, LayoutErr>;\n```\n\nMethods that are tracked by #55724 but are not stabilized here:\n\n```rust\npub fn Layout::padding_needed_for(&self, align: usize) -> usize;\npub fn Layout::repeat(&self, n: usize) -> Result<(Layout, usize), LayoutErr>;\npub fn Layout::repeat_packed(&self, n: usize) -> Result<Layout, LayoutErr>;\npub fn Layout::extend_packed(&self, next: Layout) -> Result<Layout, LayoutErr>;\n```\n\nCombined, these stabilized functions allow code to construct and manipulate `repr(C)` layouts while letting the standard library handle correctness in the face of edge cases. For example use cases, consider the usage in [hashbrown](https://github.com/Amanieu/hashbrown/blob/2f2af1d/src/raw/mod.rs#L143), [crossbeam-skiplist](https://github.com/crossbeam-rs/crossbeam-skiplist/blob/master/src/base.rs#L99), [pointer-utils/slice-dst](https://github.com/CAD97/pointer-utils/blob/92aeefeed9399f28d1b1654b63f8dcbe1242d8d4/crates/slice-dst/src/layout_polyfill.rs), and of course the standard library itself.\n\nProviding a higher-level API such as `Layout::repr_c<const N: usize>(fields: [Layout; N]) -> Result<(Layout, [usize; N]), LayoutErr>` is blocked on const generics, which are a ways off. Providing an API that doesn't provide offsets would be quite suboptimal, as the reason for calculating the layout like this rather than `Layout::new` is to get the field offsets.\n\nThe primary issue with the current API is having to call `.pad_to_align()` to match the layout of a `repr(C)` struct. However, I think this is not just a (failing? limitation?) of the API, but rather intrinsic complexity. While all Rust-defined types have size==stride, and probably will for the foreseeable future, there is no inherent reason why this is a limitation of all allocations. As such, the `Layout` manipulation APIs shouldn't impose this limitation, and instead the higher level api of `repr_c` (or just plain old using `Layout::new`) can make keeping it simple.\n\ncc @matklad r? @rust-lang/libs", "tree": {"sha": "337b095f994acffac33cf2e73756f6fcafc81dc4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/337b095f994acffac33cf2e73756f6fcafc81dc4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69a528eda688b3191127865f889fef65d979bb9c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeniKdCRBK7hj4Ov3rIwAAdHIIAEC1HFhdNC71A+VEc/1qy0zD\nEc9/uJXKQLffFih3roikbTj+9uRHv8DXYZTIjN8GVPsdFKIMDqHuSe3W4x9Gi/kG\n4KOUVK5YRXGXS1CHxXi7DmP9jUOZB91cxaFNoJusu+RHwe36kp90fzuMpo83Xd3w\nD7Tj2Jx0uEdc0GPRzcHIvCUEKEnAC9Fg5vpcHLAt/7NnuzuJ9hL9nLbsojwTFLdD\nnAdGVlvhiib/VIDkZNdnc80TfU2IdSzNH1qr3QMZ0TPXfeB9kz8Rwet8ES1+pF0p\n7PrKOIZvG8kk8/HpdzCixIlL9+JDeIaIHaGN+iyre2GV3Z9REh6XyeFTY/5UY00=\n=HsFM\n-----END PGP SIGNATURE-----\n", "payload": "tree 337b095f994acffac33cf2e73756f6fcafc81dc4\nparent 20fc02f836f3035b86b56a7cedb97c5cd4ed9612\nparent 98f0a8241b621b28ac58c7a5e80de4ead13ab0bb\nauthor Dylan DPC <dylan.dpc@gmail.com> 1587421853 +0200\ncommitter GitHub <noreply@github.com> 1587421853 +0200\n\nRollup merge of #69362 - CAD97:alloc_layout_extras, r=Amanieu\n\nStabilize most common subset of alloc_layout_extras\n\nTracking issue: https://github.com/rust-lang/rust/issues/55724\n\nSpecifically, this stabilizes:\n\n```rust\npub fn Layout::align_to(&self, align: usize) -> Result<Layout, LayoutErr>;\npub fn Layout::pad_to_align(&self) -> Layout;\npub fn Layout::extend(&self, next: Layout) -> Result<(Layout, usize), LayoutErr>;\npub fn Layout::array<T>(n: usize) -> Result<Layout, LayoutErr>;\n```\n\nMethods that are tracked by #55724 but are not stabilized here:\n\n```rust\npub fn Layout::padding_needed_for(&self, align: usize) -> usize;\npub fn Layout::repeat(&self, n: usize) -> Result<(Layout, usize), LayoutErr>;\npub fn Layout::repeat_packed(&self, n: usize) -> Result<Layout, LayoutErr>;\npub fn Layout::extend_packed(&self, next: Layout) -> Result<Layout, LayoutErr>;\n```\n\nCombined, these stabilized functions allow code to construct and manipulate `repr(C)` layouts while letting the standard library handle correctness in the face of edge cases. For example use cases, consider the usage in [hashbrown](https://github.com/Amanieu/hashbrown/blob/2f2af1d/src/raw/mod.rs#L143), [crossbeam-skiplist](https://github.com/crossbeam-rs/crossbeam-skiplist/blob/master/src/base.rs#L99), [pointer-utils/slice-dst](https://github.com/CAD97/pointer-utils/blob/92aeefeed9399f28d1b1654b63f8dcbe1242d8d4/crates/slice-dst/src/layout_polyfill.rs), and of course the standard library itself.\n\nProviding a higher-level API such as `Layout::repr_c<const N: usize>(fields: [Layout; N]) -> Result<(Layout, [usize; N]), LayoutErr>` is blocked on const generics, which are a ways off. Providing an API that doesn't provide offsets would be quite suboptimal, as the reason for calculating the layout like this rather than `Layout::new` is to get the field offsets.\n\nThe primary issue with the current API is having to call `.pad_to_align()` to match the layout of a `repr(C)` struct. However, I think this is not just a (failing? limitation?) of the API, but rather intrinsic complexity. While all Rust-defined types have size==stride, and probably will for the foreseeable future, there is no inherent reason why this is a limitation of all allocations. As such, the `Layout` manipulation APIs shouldn't impose this limitation, and instead the higher level api of `repr_c` (or just plain old using `Layout::new`) can make keeping it simple.\n\ncc @matklad r? @rust-lang/libs\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69a528eda688b3191127865f889fef65d979bb9c", "html_url": "https://github.com/rust-lang/rust/commit/69a528eda688b3191127865f889fef65d979bb9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69a528eda688b3191127865f889fef65d979bb9c/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20fc02f836f3035b86b56a7cedb97c5cd4ed9612", "url": "https://api.github.com/repos/rust-lang/rust/commits/20fc02f836f3035b86b56a7cedb97c5cd4ed9612", "html_url": "https://github.com/rust-lang/rust/commit/20fc02f836f3035b86b56a7cedb97c5cd4ed9612"}, {"sha": "98f0a8241b621b28ac58c7a5e80de4ead13ab0bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/98f0a8241b621b28ac58c7a5e80de4ead13ab0bb", "html_url": "https://github.com/rust-lang/rust/commit/98f0a8241b621b28ac58c7a5e80de4ead13ab0bb"}], "stats": {"total": 56, "additions": 43, "deletions": 13}, "files": [{"sha": "6200cd242667f13f3cc09e6ff31ea9f6a4276972", "filename": "src/libcore/alloc/layout.rs", "status": "modified", "additions": 43, "deletions": 13, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/69a528eda688b3191127865f889fef65d979bb9c/src%2Flibcore%2Falloc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69a528eda688b3191127865f889fef65d979bb9c/src%2Flibcore%2Falloc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Flayout.rs?ref=69a528eda688b3191127865f889fef65d979bb9c", "patch": "@@ -162,7 +162,7 @@ impl Layout {\n     /// Returns an error if the combination of `self.size()` and the given\n     /// `align` violates the conditions listed in\n     /// [`Layout::from_size_align`](#method.from_size_align).\n-    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[stable(feature = \"alloc_layout_manipulation\", since = \"1.44.0\")]\n     #[inline]\n     pub fn align_to(&self, align: usize) -> Result<Self, LayoutErr> {\n         Layout::from_size_align(self.size(), cmp::max(self.align(), align))\n@@ -218,7 +218,7 @@ impl Layout {\n     ///\n     /// This is equivalent to adding the result of `padding_needed_for`\n     /// to the layout's current size.\n-    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[stable(feature = \"alloc_layout_manipulation\", since = \"1.44.0\")]\n     #[inline]\n     pub fn pad_to_align(&self) -> Layout {\n         let pad = self.padding_needed_for(self.align());\n@@ -258,19 +258,50 @@ impl Layout {\n \n     /// Creates a layout describing the record for `self` followed by\n     /// `next`, including any necessary padding to ensure that `next`\n-    /// will be properly aligned. Note that the resulting layout will\n-    /// satisfy the alignment properties of both `self` and `next`.\n+    /// will be properly aligned, but *no trailing padding*.\n     ///\n-    /// The resulting layout will be the same as that of a C struct containing\n-    /// two fields with the layouts of `self` and `next`, in that order.\n+    /// In order to match C representation layout `repr(C)`, you should\n+    /// call `pad_to_align` after extending the layout with all fields.\n+    /// (There is no way to match the default Rust representation\n+    /// layout `repr(Rust)`, as it is unspecified.)\n     ///\n-    /// Returns `Some((k, offset))`, where `k` is layout of the concatenated\n+    /// Note that the alignment of the resulting layout will be the maximum of\n+    /// those of `self` and `next`, in order to ensure alignment of both parts.\n+    ///\n+    /// Returns `Ok((k, offset))`, where `k` is layout of the concatenated\n     /// record and `offset` is the relative location, in bytes, of the\n     /// start of the `next` embedded within the concatenated record\n     /// (assuming that the record itself starts at offset 0).\n     ///\n     /// On arithmetic overflow, returns `LayoutErr`.\n-    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    ///\n+    /// # Examples\n+    ///\n+    /// To calculate the layout of a `#[repr(C)]` structure and the offsets of\n+    /// the fields from its fields' layouts:\n+    ///\n+    /// ```rust\n+    /// # use std::alloc::{Layout, LayoutErr};\n+    /// pub fn repr_c(fields: &[Layout]) -> Result<(Layout, Vec<usize>), LayoutErr> {\n+    ///     let mut offsets = Vec::new();\n+    ///     let mut layout = Layout::from_size_align(0, 1)?;\n+    ///     for &field in fields {\n+    ///         let (new_layout, offset) = layout.extend(field)?;\n+    ///         layout = new_layout;\n+    ///         offsets.push(offset);\n+    ///     }\n+    ///     // Remember to finalize with `pad_to_align`!\n+    ///     Ok((layout.pad_to_align(), offsets))\n+    /// }\n+    /// # // test that it works\n+    /// # #[repr(C)] struct S { a: u64, b: u32, c: u16, d: u32 }\n+    /// # let s = Layout::new::<S>();\n+    /// # let u16 = Layout::new::<u16>();\n+    /// # let u32 = Layout::new::<u32>();\n+    /// # let u64 = Layout::new::<u64>();\n+    /// # assert_eq!(repr_c(&[u64, u32, u16, u32]), Ok((s, vec![0, 8, 12, 16])));\n+    /// ```\n+    #[stable(feature = \"alloc_layout_manipulation\", since = \"1.44.0\")]\n     #[inline]\n     pub fn extend(&self, next: Self) -> Result<(Self, usize), LayoutErr> {\n         let new_align = cmp::max(self.align(), next.align());\n@@ -318,13 +349,12 @@ impl Layout {\n     /// Creates a layout describing the record for a `[T; n]`.\n     ///\n     /// On arithmetic overflow, returns `LayoutErr`.\n-    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[stable(feature = \"alloc_layout_manipulation\", since = \"1.44.0\")]\n     #[inline]\n     pub fn array<T>(n: usize) -> Result<Self, LayoutErr> {\n-        Layout::new::<T>().repeat(n).map(|(k, offs)| {\n-            debug_assert!(offs == mem::size_of::<T>());\n-            k\n-        })\n+        let (layout, offset) = Layout::new::<T>().repeat(n)?;\n+        debug_assert_eq!(offset, mem::size_of::<T>());\n+        Ok(layout.pad_to_align())\n     }\n }\n "}]}