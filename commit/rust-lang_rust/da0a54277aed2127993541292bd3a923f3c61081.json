{"sha": "da0a54277aed2127993541292bd3a923f3c61081", "node_id": "C_kwDOAAsO6NoAKGRhMGE1NDI3N2FlZDIxMjc5OTM1NDEyOTJiZDNhOTIzZjNjNjEwODE", "commit": {"author": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2022-12-02T13:38:20Z"}, "committer": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2022-12-02T13:38:20Z"}, "message": "std: cleanup timeouts in pthread condvar", "tree": {"sha": "a697783c85cd653c90b0f5384a9fa7e218c47a76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a697783c85cd653c90b0f5384a9fa7e218c47a76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da0a54277aed2127993541292bd3a923f3c61081", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEVuz3PwcqDyifNyYbcE4BSbAZSzwFAmOJ/8wACgkQcE4BSbAZ\nSzxovA/+LcO1R4dv+cp/3otoPPRGC4LeUey5GcpXQ2/yxCvf6igVT3f/GBZh6mz5\n16cJOV+7ABmzDO4H0L2lDXE5HOtstPc1mXbdPW0MdSMnbKC8yJuFPKmO309TQ+HL\n4DZBXIHMGkK7K2kg/O7WpXCqy4zn5m1zar9Dzbin6wKaspR075VVFsC6pGDR29JW\nPiGPI26dhN0XV7jsiz2oJlnBCwYeZMFK+nTAmoh9uw/+DM7ldFOFjvkWIbr3GLSk\nS0VZAnqeFeFLgz4KV7GAr+fPeuRp8PzXwLK/nwja/a1HwUtPsJCmICfIv/W4KL4I\nx7Z84WZmGUtwHUQh9IAZaZ+kN1W6rxvkCekyZWYhz+RtrjZZa4F0Xw7AC/zjMZNv\nvZG0AZqno31Z07x9HLBRcuE/DlTm8TxRtKZbx0rZaIUd14fVLoM1ZcURmHDAFKF/\n0rkxo+Fqya3HjFOP7kC6l8DJPyfGX04BJuZFL/hoiUHu8xDVUXqElbA0tcAFzCHA\nuuDBU/bI+aGdfWBC5oKRfl95l9k1NejHxwl7jUuqWawlDJImaTMTlqb1E6iI9ldG\nidWte/izqScgGFDldaq4fFavyUzL2WKDPmwQjCoYCDoSWMK1GakzFBUNJwZ6KkR0\njr28QlKcfLjUkSTNR2zw7GJAD7MLWpkJ+1Prf16MZyEJTfZKaa4=\n=k7PO\n-----END PGP SIGNATURE-----", "payload": "tree a697783c85cd653c90b0f5384a9fa7e218c47a76\nparent 11663b1b4857ffeafbd85a9a36c234d117373b76\nauthor joboet <jonasboettiger@icloud.com> 1669988300 +0100\ncommitter joboet <jonasboettiger@icloud.com> 1669988300 +0100\n\nstd: cleanup timeouts in pthread condvar\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da0a54277aed2127993541292bd3a923f3c61081", "html_url": "https://github.com/rust-lang/rust/commit/da0a54277aed2127993541292bd3a923f3c61081", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da0a54277aed2127993541292bd3a923f3c61081/comments", "author": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11663b1b4857ffeafbd85a9a36c234d117373b76", "url": "https://api.github.com/repos/rust-lang/rust/commits/11663b1b4857ffeafbd85a9a36c234d117373b76", "html_url": "https://github.com/rust-lang/rust/commit/11663b1b4857ffeafbd85a9a36c234d117373b76"}], "stats": {"total": 100, "additions": 34, "deletions": 66}, "files": [{"sha": "6be1abc2b080a0164d772b5f6eed32b7f2bc9b9d", "filename": "library/std/src/sys/unix/locks/pthread_condvar.rs", "status": "modified", "additions": 30, "deletions": 63, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/da0a54277aed2127993541292bd3a923f3c61081/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_condvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0a54277aed2127993541292bd3a923f3c61081/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_condvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_condvar.rs?ref=da0a54277aed2127993541292bd3a923f3c61081", "patch": "@@ -2,6 +2,7 @@ use crate::cell::UnsafeCell;\n use crate::ptr;\n use crate::sync::atomic::{AtomicPtr, Ordering::Relaxed};\n use crate::sys::locks::{pthread_mutex, Mutex};\n+use crate::sys::time::TIMESPEC_MAX;\n use crate::sys_common::lazy_box::{LazyBox, LazyInit};\n use crate::time::Duration;\n \n@@ -12,13 +13,6 @@ pub struct Condvar {\n     mutex: AtomicPtr<libc::pthread_mutex_t>,\n }\n \n-const TIMESPEC_MAX: libc::timespec =\n-    libc::timespec { tv_sec: <libc::time_t>::MAX, tv_nsec: 1_000_000_000 - 1 };\n-\n-fn saturating_cast_to_time_t(value: u64) -> libc::time_t {\n-    if value > <libc::time_t>::MAX as u64 { <libc::time_t>::MAX } else { value as libc::time_t }\n-}\n-\n #[inline]\n fn raw(c: &Condvar) -> *mut libc::pthread_cond_t {\n     c.inner.0.get()\n@@ -133,26 +127,15 @@ impl Condvar {\n         target_os = \"horizon\"\n     )))]\n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n-        use crate::mem;\n+        use crate::sys::time::Timespec;\n \n         let mutex = pthread_mutex::raw(mutex);\n         self.verify(mutex);\n \n-        let mut now: libc::timespec = mem::zeroed();\n-        let r = libc::clock_gettime(libc::CLOCK_MONOTONIC, &mut now);\n-        assert_eq!(r, 0);\n-\n-        // Nanosecond calculations can't overflow because both values are below 1e9.\n-        let nsec = dur.subsec_nanos() + now.tv_nsec as u32;\n-\n-        let sec = saturating_cast_to_time_t(dur.as_secs())\n-            .checked_add((nsec / 1_000_000_000) as libc::time_t)\n-            .and_then(|s| s.checked_add(now.tv_sec));\n-        let nsec = nsec % 1_000_000_000;\n-\n-        let timeout =\n-            sec.map(|s| libc::timespec { tv_sec: s, tv_nsec: nsec as _ }).unwrap_or(TIMESPEC_MAX);\n-\n+        let timeout = Timespec::now(libc::CLOCK_MONOTONIC)\n+            .checked_add_duration(&dur)\n+            .and_then(|t| t.to_timespec())\n+            .unwrap_or(TIMESPEC_MAX);\n         let r = libc::pthread_cond_timedwait(raw(self), mutex, &timeout);\n         assert!(r == libc::ETIMEDOUT || r == 0);\n         r == 0\n@@ -169,57 +152,41 @@ impl Condvar {\n         target_os = \"espidf\",\n         target_os = \"horizon\"\n     ))]\n-    pub unsafe fn wait_timeout(&self, mutex: &Mutex, mut dur: Duration) -> bool {\n+    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n+        use crate::sys::time::SystemTime;\n         use crate::time::Instant;\n \n         let mutex = pthread_mutex::raw(mutex);\n         self.verify(mutex);\n \n-        // 1000 years\n-        let max_dur = Duration::from_secs(1000 * 365 * 86400);\n-\n-        if dur > max_dur {\n-            // OSX implementation of `pthread_cond_timedwait` is buggy\n-            // with super long durations. When duration is greater than\n-            // 0x100_0000_0000_0000 seconds, `pthread_cond_timedwait`\n-            // in macOS Sierra return error 316.\n-            //\n-            // This program demonstrates the issue:\n-            // https://gist.github.com/stepancheg/198db4623a20aad2ad7cddb8fda4a63c\n-            //\n-            // To work around this issue, and possible bugs of other OSes, timeout\n-            // is clamped to 1000 years, which is allowable per the API of `wait_timeout`\n-            // because of spurious wakeups.\n-\n-            dur = max_dur;\n-        }\n-\n-        // First, figure out what time it currently is, in both system and\n-        // stable time.  pthread_cond_timedwait uses system time, but we want to\n-        // report timeout based on stable time.\n-        let mut sys_now = libc::timeval { tv_sec: 0, tv_usec: 0 };\n-        let stable_now = Instant::now();\n-        let r = libc::gettimeofday(&mut sys_now, ptr::null_mut());\n-        assert_eq!(r, 0, \"unexpected error: {:?}\", crate::io::Error::last_os_error());\n-\n-        let nsec = dur.subsec_nanos() as libc::c_long + (sys_now.tv_usec * 1000) as libc::c_long;\n-        let extra = (nsec / 1_000_000_000) as libc::time_t;\n-        let nsec = nsec % 1_000_000_000;\n-        let seconds = saturating_cast_to_time_t(dur.as_secs());\n-\n-        let timeout = sys_now\n-            .tv_sec\n-            .checked_add(extra)\n-            .and_then(|s| s.checked_add(seconds))\n-            .map(|s| libc::timespec { tv_sec: s, tv_nsec: nsec })\n+        // OSX implementation of `pthread_cond_timedwait` is buggy\n+        // with super long durations. When duration is greater than\n+        // 0x100_0000_0000_0000 seconds, `pthread_cond_timedwait`\n+        // in macOS Sierra returns error 316.\n+        //\n+        // This program demonstrates the issue:\n+        // https://gist.github.com/stepancheg/198db4623a20aad2ad7cddb8fda4a63c\n+        //\n+        // To work around this issue, and possible bugs of other OSes, timeout\n+        // is clamped to 1000 years, which is allowable per the API of `wait_timeout`\n+        // because of spurious wakeups.\n+        let dur = Duration::min(dur, Duration::from_secs(1000 * 365 * 86400));\n+\n+        // pthread_cond_timedwait uses system time, but we want to report timeout\n+        // based on stable time.\n+        let now = Instant::now();\n+\n+        let timeout = SystemTime::now()\n+            .t\n+            .checked_add_duration(&dur)\n+            .and_then(|t| t.to_timespec())\n             .unwrap_or(TIMESPEC_MAX);\n \n-        // And wait!\n         let r = libc::pthread_cond_timedwait(raw(self), mutex, &timeout);\n         debug_assert!(r == libc::ETIMEDOUT || r == 0);\n \n         // ETIMEDOUT is not a totally reliable method of determining timeout due\n         // to clock shifts, so do the check ourselves\n-        stable_now.elapsed() < dur\n+        now.elapsed() < dur\n     }\n }"}, {"sha": "c400c7715676f7856d47e3be8ed83e0c839cd340", "filename": "library/std/src/sys/unix/thread_parker/pthread.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da0a54277aed2127993541292bd3a923f3c61081/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fpthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0a54277aed2127993541292bd3a923f3c61081/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fpthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fpthread.rs?ref=da0a54277aed2127993541292bd3a923f3c61081", "patch": "@@ -6,6 +6,7 @@ use crate::pin::Pin;\n use crate::ptr::addr_of_mut;\n use crate::sync::atomic::AtomicUsize;\n use crate::sync::atomic::Ordering::SeqCst;\n+use crate::sys::time::TIMESPEC_MAX;\n use crate::time::Duration;\n \n const EMPTY: usize = 0;\n@@ -32,9 +33,6 @@ unsafe fn wait(cond: *mut libc::pthread_cond_t, lock: *mut libc::pthread_mutex_t\n     debug_assert_eq!(r, 0);\n }\n \n-const TIMESPEC_MAX: libc::timespec =\n-    libc::timespec { tv_sec: <libc::time_t>::MAX, tv_nsec: 1_000_000_000 - 1 };\n-\n unsafe fn wait_timeout(\n     cond: *mut libc::pthread_cond_t,\n     lock: *mut libc::pthread_mutex_t,"}, {"sha": "2daad981b73e9a94af6e3b3f779b029d4026076e", "filename": "library/std/src/sys/unix/time.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da0a54277aed2127993541292bd3a923f3c61081/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0a54277aed2127993541292bd3a923f3c61081/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs?ref=da0a54277aed2127993541292bd3a923f3c61081", "patch": "@@ -5,6 +5,9 @@ pub use self::inner::Instant;\n \n const NSEC_PER_SEC: u64 = 1_000_000_000;\n pub const UNIX_EPOCH: SystemTime = SystemTime { t: Timespec::zero() };\n+#[allow(dead_code)] // Used for pthread condvar timeouts\n+pub const TIMESPEC_MAX: libc::timespec =\n+    libc::timespec { tv_sec: <libc::time_t>::MAX, tv_nsec: 1_000_000_000 - 1 };\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n #[repr(transparent)]"}]}