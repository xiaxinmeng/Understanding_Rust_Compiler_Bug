{"sha": "528366d3ffe0564c2e300aae6df06e6a1bfafde2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyODM2NmQzZmZlMDU2NGMyZTMwMGFhZTZkZjA2ZTZhMWJmYWZkZTI=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2019-03-28T12:08:56Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2019-03-28T12:08:56Z"}, "message": "Revise and generalize the macros-unlinted tests.\n\nReview feedback asked for the test to be generalized to include macros\n2.0; that generalization is dyn-2015-idents-in-decl-macros-unlinted.rs\n\nAs a drive-by, I also decided to revise the test to make it clear\n*why* we cannot generally lint these cases. (I already had similar\ndemonstrations in dyn-2015-edition-keyword-ident-lint.rs, but it does\nnot hurt to try to emphasize matters.)\n\nI also added some commentary on the cases where we could choose to\nmake the lint smarter, namely the situations where a macro is\n*definitely* using `dyn` as an identifier (because it is using it as a\npath component).", "tree": {"sha": "c0512cde36ced5031c4001e08cb336620cbbc8e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0512cde36ced5031c4001e08cb336620cbbc8e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/528366d3ffe0564c2e300aae6df06e6a1bfafde2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/528366d3ffe0564c2e300aae6df06e6a1bfafde2", "html_url": "https://github.com/rust-lang/rust/commit/528366d3ffe0564c2e300aae6df06e6a1bfafde2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/528366d3ffe0564c2e300aae6df06e6a1bfafde2/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f043d2da65a4da355aae4773204e073fef3e7cba", "url": "https://api.github.com/repos/rust-lang/rust/commits/f043d2da65a4da355aae4773204e073fef3e7cba", "html_url": "https://github.com/rust-lang/rust/commit/f043d2da65a4da355aae4773204e073fef3e7cba"}], "stats": {"total": 87, "additions": 85, "deletions": 2}, "files": [{"sha": "f535791d7fbe498ea1c8f18c8ce5019b5b0d9983", "filename": "src/test/ui/dyn-keyword/dyn-2015-idents-in-decl-macros-unlinted.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/528366d3ffe0564c2e300aae6df06e6a1bfafde2/src%2Ftest%2Fui%2Fdyn-keyword%2Fdyn-2015-idents-in-decl-macros-unlinted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528366d3ffe0564c2e300aae6df06e6a1bfafde2/src%2Ftest%2Fui%2Fdyn-keyword%2Fdyn-2015-idents-in-decl-macros-unlinted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-keyword%2Fdyn-2015-idents-in-decl-macros-unlinted.rs?ref=528366d3ffe0564c2e300aae6df06e6a1bfafde2", "patch": "@@ -0,0 +1,51 @@\n+// compile-pass\n+\n+// Under the 2015 edition with the keyword_idents lint, `dyn` is\n+// not entirely acceptable as an identifier.\n+//\n+// We currently do not attempt to detect or fix uses of `dyn` as an\n+// identifier under a macro, including under the declarative `macro`\n+// forms from macros 1.2 and macros 2.0.\n+\n+#![feature(decl_macro)]\n+#![allow(non_camel_case_types)]\n+#![deny(keyword_idents)]\n+\n+mod outer_mod {\n+    pub mod r#dyn {\n+        pub struct r#dyn;\n+    }\n+}\n+\n+// Here we are illustrating that the current lint does not flag the\n+// occurrences of `dyn` in this macro definition; however, it\n+// certainly *could* (and it would be nice if it did), since these\n+// occurrences are not compatible with the 2018 edition's\n+// interpretation of `dyn` as a keyword.\n+macro defn_has_dyn_idents() { ::outer_mod::dyn::dyn }\n+\n+struct X;\n+trait Trait { fn hello(&self) { }}\n+impl Trait for X { }\n+\n+macro tt_trait($arg:tt) { & $arg Trait }\n+macro id_trait($id:ident) { & $id Trait }\n+\n+fn main() {\n+    defn_has_dyn_idents!();\n+\n+    // Here we are illustrating that the current lint does not flag\n+    // the occurrences of `dyn` in these macro invocations. It\n+    // definitely should *not* flag the one in `tt_trait`, since that\n+    // is expanding in a valid fashion to `&dyn Trait`.\n+    //\n+    // It is arguable whether it would be valid to flag the occurrence\n+    // in `id_trait`, since that macro specifies that it takes an\n+    // `ident` as its input.\n+    fn f_tt(x: &X) -> tt_trait!(dyn) { x }\n+    fn f_id(x: &X) -> id_trait!(dyn) { x }\n+\n+    let x = X;\n+    f_tt(&x).hello();\n+    f_id(&x).hello();\n+}"}, {"sha": "27e490558689fe7fdc3ef18ff3063e7d4e5e1d9d", "filename": "src/test/ui/dyn-keyword/dyn-2015-idents-in-macros-unlinted.rs", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/528366d3ffe0564c2e300aae6df06e6a1bfafde2/src%2Ftest%2Fui%2Fdyn-keyword%2Fdyn-2015-idents-in-macros-unlinted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528366d3ffe0564c2e300aae6df06e6a1bfafde2/src%2Ftest%2Fui%2Fdyn-keyword%2Fdyn-2015-idents-in-macros-unlinted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-keyword%2Fdyn-2015-idents-in-macros-unlinted.rs?ref=528366d3ffe0564c2e300aae6df06e6a1bfafde2", "patch": "@@ -15,10 +15,42 @@ mod outer_mod {\n     }\n }\n \n+// Here we are illustrating that the current lint does not flag the\n+// occurrences of `dyn` in this macro definition; however, it\n+// certainly *could* (and it would be nice if it did), since these\n+// occurrences are not compatible with the 2018 edition's\n+// interpretation of `dyn` as a keyword.\n macro_rules! defn_has_dyn_idents {\n-    ($arg:ident) => { ::outer_mod::dyn::dyn }\n+    () => { ::outer_mod::dyn::dyn }\n+}\n+\n+struct X;\n+trait Trait { fn hello(&self) { }}\n+impl Trait for X { }\n+\n+macro_rules! tt_trait {\n+    ($arg:tt) => { & $arg Trait }\n+}\n+\n+macro_rules! id_trait {\n+    ($id:ident) => { & $id Trait }\n }\n \n fn main() {\n-    defn_has_dyn_idents!(dyn);\n+    defn_has_dyn_idents!();\n+\n+    // Here we are illustrating that the current lint does not flag\n+    // the occurrences of `dyn` in these macro invocations. It\n+    // definitely should *not* flag the one in `tt_trait`, since that\n+    // is expanding in a valid fashion to `&dyn Trait`.\n+    //\n+    // It is arguable whether it would be valid to flag the occurrence\n+    // in `id_trait`, since that macro specifies that it takes an\n+    // `ident` as its input.\n+    fn f_tt(x: &X) -> tt_trait!(dyn) { x }\n+    fn f_id(x: &X) -> id_trait!(dyn) { x }\n+\n+    let x = X;\n+    f_tt(&x).hello();\n+    f_id(&x).hello();\n }"}]}