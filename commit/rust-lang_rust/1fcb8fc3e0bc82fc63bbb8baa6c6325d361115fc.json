{"sha": "1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc", "node_id": "C_kwDOAAsO6NoAKDFmY2I4ZmMzZTBiYzgyZmM2M2JiYjhiYWE2YzYzMjVkMzYxMTE1ZmM", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-03-25T00:34:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-25T00:34:30Z"}, "message": "Rollup merge of #95179 - b-naber:eval-in-try-unify, r=lcnr\n\nTry to evaluate in try unify and postpone resolution of constants that contain inference variables\n\nWe want code like that in [`ui/const-generics/generic_const_exprs/eval-try-unify.rs`](https://github.com/rust-lang/rust/compare/master...b-naber:eval-in-try-unify?expand=1#diff-8027038201cf07a6c96abf3cbf0b0f4fdd8a64ce6292435f01c8ed995b87fe9b) to compile. To do that we need to try to evaluate constants in `try_unify_abstract_consts`, this requires us to be more careful about what constants we try to resolve, specifically we cannot try to resolve constants that still contain inference variables.\n\nr? `@lcnr`", "tree": {"sha": "5453b5ffbb5164b6b6afde0b0b1e45ecb978cb54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5453b5ffbb5164b6b6afde0b0b1e45ecb978cb54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiPQ4WCRBK7hj4Ov3rIwAASxoIAClfc4AKseLF0zBTJhM0KMUL\ne5epjUrpXRrcBmK7562lzmn78lhhOTVVQ/pTw11KmnqxetUQD1uO/wpZAcPgzqcY\nCnbmaHbxiZtgErY7sMy0/SnROTIFH5yl90zr9trfwbDnY+C7g/QI38o49nsVO7nl\nbzaBZirfRjxmDyXth72NsliN3KiZtGBbWqb1WwKfNdiHJj0nKywhjL4WYiz6XDI1\nDpqf4pL0xA4Mbd0VTp+N3Q7K6OOtliw02au1YMzzEu7jRhNPr9MHe+VuHbCb2oWX\nDll/5IPhTHgHbX4Pp7bP8YlTb9Ea8chr83hX4EKEUWKg6IzSaDabgUlvHa5Eii0=\n=ojzp\n-----END PGP SIGNATURE-----\n", "payload": "tree 5453b5ffbb5164b6b6afde0b0b1e45ecb978cb54\nparent c66e0c87267859a46f1a8851f30892985760cfd6\nparent 11a70dbc8ac49416598b0ff4525096845a0dc498\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1648168470 +0100\ncommitter GitHub <noreply@github.com> 1648168470 +0100\n\nRollup merge of #95179 - b-naber:eval-in-try-unify, r=lcnr\n\nTry to evaluate in try unify and postpone resolution of constants that contain inference variables\n\nWe want code like that in [`ui/const-generics/generic_const_exprs/eval-try-unify.rs`](https://github.com/rust-lang/rust/compare/master...b-naber:eval-in-try-unify?expand=1#diff-8027038201cf07a6c96abf3cbf0b0f4fdd8a64ce6292435f01c8ed995b87fe9b) to compile. To do that we need to try to evaluate constants in `try_unify_abstract_consts`, this requires us to be more careful about what constants we try to resolve, specifically we cannot try to resolve constants that still contain inference variables.\n\nr? `@lcnr`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc", "html_url": "https://github.com/rust-lang/rust/commit/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c66e0c87267859a46f1a8851f30892985760cfd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c66e0c87267859a46f1a8851f30892985760cfd6", "html_url": "https://github.com/rust-lang/rust/commit/c66e0c87267859a46f1a8851f30892985760cfd6"}, {"sha": "11a70dbc8ac49416598b0ff4525096845a0dc498", "url": "https://api.github.com/repos/rust-lang/rust/commits/11a70dbc8ac49416598b0ff4525096845a0dc498", "html_url": "https://github.com/rust-lang/rust/commit/11a70dbc8ac49416598b0ff4525096845a0dc498"}], "stats": {"total": 558, "additions": 277, "deletions": 281}, "files": [{"sha": "2886d921c705dcd42afb50279c474feb95a8c482", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc", "patch": "@@ -20,8 +20,7 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n-use rustc_middle::mir::interpret::ErrorHandled;\n-use rustc_middle::mir::interpret::EvalToConstValueResult;\n+use rustc_middle::mir::interpret::{ErrorHandled, EvalToConstValueResult};\n use rustc_middle::traits::select;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n@@ -71,7 +70,6 @@ mod sub;\n pub mod type_variable;\n mod undo_log;\n \n-use crate::infer::canonical::OriginalQueryValues;\n pub use rustc_middle::infer::unify_key;\n \n #[must_use]\n@@ -687,15 +685,28 @@ pub struct CombinedSnapshot<'a, 'tcx> {\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// calls `tcx.try_unify_abstract_consts` after\n     /// canonicalizing the consts.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn try_unify_abstract_consts(\n         &self,\n         a: ty::Unevaluated<'tcx, ()>,\n         b: ty::Unevaluated<'tcx, ()>,\n+        param_env: ty::ParamEnv<'tcx>,\n     ) -> bool {\n-        let canonical = self.canonicalize_query((a, b), &mut OriginalQueryValues::default());\n-        debug!(\"canonical consts: {:?}\", &canonical.value);\n+        // Reject any attempt to unify two unevaluated constants that contain inference\n+        // variables, since inference variables in queries lead to ICEs.\n+        if a.substs.has_infer_types_or_consts()\n+            || b.substs.has_infer_types_or_consts()\n+            || param_env.has_infer_types_or_consts()\n+        {\n+            debug!(\"a or b or param_env contain infer vars in its substs -> cannot unify\");\n+            return false;\n+        }\n+\n+        let param_env_and = param_env.and((a, b));\n+        let erased = self.tcx.erase_regions(param_env_and);\n+        debug!(\"after erase_regions: {:?}\", erased);\n \n-        self.tcx.try_unify_abstract_consts(canonical.value)\n+        self.tcx.try_unify_abstract_consts(erased)\n     }\n \n     pub fn is_in_snapshot(&self) -> bool {\n@@ -1598,22 +1609,27 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ///\n     /// This handles inferences variables within both `param_env` and `substs` by\n     /// performing the operation on their respective canonical forms.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn const_eval_resolve(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n         unevaluated: ty::Unevaluated<'tcx>,\n         span: Option<Span>,\n     ) -> EvalToConstValueResult<'tcx> {\n         let substs = self.resolve_vars_if_possible(unevaluated.substs);\n+        debug!(?substs);\n \n         // Postpone the evaluation of constants whose substs depend on inference\n         // variables\n         if substs.has_infer_types_or_consts() {\n+            debug!(\"substs have infer types or consts: {:?}\", substs);\n             return Err(ErrorHandled::TooGeneric);\n         }\n \n         let param_env_erased = self.tcx.erase_regions(param_env);\n         let substs_erased = self.tcx.erase_regions(substs);\n+        debug!(?param_env_erased);\n+        debug!(?substs_erased);\n \n         let unevaluated = ty::Unevaluated {\n             def: unevaluated.def,"}, {"sha": "7e5989b4112cff868e76f7e7f6da8fcb991365ad", "filename": "compiler/rustc_middle/src/mir/interpret/queries.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs?ref=1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc", "patch": "@@ -1,6 +1,7 @@\n use super::{ErrorHandled, EvalToConstValueResult, GlobalId};\n \n use crate::mir;\n+use crate::ty::fold::TypeFoldable;\n use crate::ty::subst::InternalSubsts;\n use crate::ty::{self, TyCtxt};\n use rustc_hir::def_id::DefId;\n@@ -38,6 +39,16 @@ impl<'tcx> TyCtxt<'tcx> {\n         ct: ty::Unevaluated<'tcx>,\n         span: Option<Span>,\n     ) -> EvalToConstValueResult<'tcx> {\n+        // Cannot resolve `Unevaluated` constants that contain inference\n+        // variables. We reject those here since `resolve_opt_const_arg`\n+        // would fail otherwise.\n+        //\n+        // When trying to evaluate constants containing inference variables,\n+        // use `Infcx::const_eval_resolve` instead.\n+        if ct.substs.has_infer_types_or_consts() {\n+            bug!(\"did not expect inference variables here\");\n+        }\n+\n         match ty::Instance::resolve_opt_const_arg(self, param_env, ct.def, ct.substs) {\n             Ok(Some(instance)) => {\n                 let cid = GlobalId { instance, promoted: ct.promoted };"}, {"sha": "cd6ff8254ad86c4cfb612faf0cd227ce2cc5b547", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc", "patch": "@@ -331,12 +331,12 @@ rustc_queries! {\n         }\n     }\n \n-    query try_unify_abstract_consts(key: (\n-        ty::Unevaluated<'tcx, ()>, ty::Unevaluated<'tcx, ()>\n-    )) -> bool {\n+    query try_unify_abstract_consts(key:\n+        ty::ParamEnvAnd<'tcx, (ty::Unevaluated<'tcx, ()>, ty::Unevaluated<'tcx, ()>\n+    )>) -> bool {\n         desc {\n             |tcx| \"trying to unify the generic constants {} and {}\",\n-            tcx.def_path_str(key.0.def.did), tcx.def_path_str(key.1.def.did)\n+            tcx.def_path_str(key.value.0.def.did), tcx.def_path_str(key.value.1.def.did)\n         }\n     }\n "}, {"sha": "5d6cbcf6907069f8b0823129782bd5ee27c0f1ab", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc", "patch": "@@ -585,7 +585,7 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n         (ty::ConstKind::Unevaluated(au), ty::ConstKind::Unevaluated(bu))\n             if tcx.features().generic_const_exprs =>\n         {\n-            tcx.try_unify_abstract_consts((au.shrink(), bu.shrink()))\n+            tcx.try_unify_abstract_consts(relation.param_env().and((au.shrink(), bu.shrink())))\n         }\n \n         // While this is slightly incorrect, it shouldn't matter for `min_const_generics`"}, {"sha": "959b644becd9b4012c8036619f75498ec49043f0", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 110, "deletions": 77, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc", "patch": "@@ -188,6 +188,7 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n     }\n }\n \n+#[instrument(skip(tcx), level = \"debug\")]\n fn satisfied_from_param_env<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ct: AbstractConst<'tcx>,\n@@ -197,14 +198,17 @@ fn satisfied_from_param_env<'tcx>(\n         match pred.kind().skip_binder() {\n             ty::PredicateKind::ConstEvaluatable(uv) => {\n                 if let Some(b_ct) = AbstractConst::new(tcx, uv)? {\n+                    let const_unify_ctxt = ConstUnifyCtxt { tcx, param_env };\n+\n                     // Try to unify with each subtree in the AbstractConst to allow for\n                     // `N + 1` being const evaluatable even if theres only a `ConstEvaluatable`\n                     // predicate for `(N + 1) * 2`\n-                    let result =\n-                        walk_abstract_const(tcx, b_ct, |b_ct| match try_unify(tcx, ct, b_ct) {\n+                    let result = walk_abstract_const(tcx, b_ct, |b_ct| {\n+                        match const_unify_ctxt.try_unify(ct, b_ct) {\n                             true => ControlFlow::BREAK,\n                             false => ControlFlow::CONTINUE,\n-                        });\n+                        }\n+                    });\n \n                     if let ControlFlow::Break(()) = result {\n                         debug!(\"is_const_evaluatable: abstract_const ~~> ok\");\n@@ -637,11 +641,13 @@ pub(super) fn thir_abstract_const<'tcx>(\n pub(super) fn try_unify_abstract_consts<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     (a, b): (ty::Unevaluated<'tcx, ()>, ty::Unevaluated<'tcx, ()>),\n+    param_env: ty::ParamEnv<'tcx>,\n ) -> bool {\n     (|| {\n         if let Some(a) = AbstractConst::new(tcx, a)? {\n             if let Some(b) = AbstractConst::new(tcx, b)? {\n-                return Ok(try_unify(tcx, a, b));\n+                let const_unify_ctxt = ConstUnifyCtxt { tcx, param_env };\n+                return Ok(const_unify_ctxt.try_unify(a, b));\n             }\n         }\n \n@@ -689,88 +695,115 @@ where\n     recurse(tcx, ct, &mut f)\n }\n \n-/// Tries to unify two abstract constants using structural equality.\n-pub(super) fn try_unify<'tcx>(\n+struct ConstUnifyCtxt<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    mut a: AbstractConst<'tcx>,\n-    mut b: AbstractConst<'tcx>,\n-) -> bool {\n-    // We substitute generics repeatedly to allow AbstractConsts to unify where a\n+    param_env: ty::ParamEnv<'tcx>,\n+}\n+\n+impl<'tcx> ConstUnifyCtxt<'tcx> {\n+    // Substitutes generics repeatedly to allow AbstractConsts to unify where a\n     // ConstKind::Unevalated could be turned into an AbstractConst that would unify e.g.\n     // Param(N) should unify with Param(T), substs: [Unevaluated(\"T2\", [Unevaluated(\"T3\", [Param(N)])])]\n-    while let Node::Leaf(a_ct) = a.root(tcx) {\n-        match AbstractConst::from_const(tcx, a_ct) {\n-            Ok(Some(a_act)) => a = a_act,\n-            Ok(None) => break,\n-            Err(_) => return true,\n-        }\n-    }\n-    while let Node::Leaf(b_ct) = b.root(tcx) {\n-        match AbstractConst::from_const(tcx, b_ct) {\n-            Ok(Some(b_act)) => b = b_act,\n-            Ok(None) => break,\n-            Err(_) => return true,\n+    #[inline]\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn try_replace_substs_in_root(\n+        &self,\n+        mut abstr_const: AbstractConst<'tcx>,\n+    ) -> Option<AbstractConst<'tcx>> {\n+        while let Node::Leaf(ct) = abstr_const.root(self.tcx) {\n+            match AbstractConst::from_const(self.tcx, ct) {\n+                Ok(Some(act)) => abstr_const = act,\n+                Ok(None) => break,\n+                Err(_) => return None,\n+            }\n         }\n-    }\n \n-    match (a.root(tcx), b.root(tcx)) {\n-        (Node::Leaf(a_ct), Node::Leaf(b_ct)) => {\n-            if a_ct.ty() != b_ct.ty() {\n-                return false;\n-            }\n+        Some(abstr_const)\n+    }\n \n-            match (a_ct.val(), b_ct.val()) {\n-                // We can just unify errors with everything to reduce the amount of\n-                // emitted errors here.\n-                (ty::ConstKind::Error(_), _) | (_, ty::ConstKind::Error(_)) => true,\n-                (ty::ConstKind::Param(a_param), ty::ConstKind::Param(b_param)) => {\n-                    a_param == b_param\n+    /// Tries to unify two abstract constants using structural equality.\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn try_unify(&self, a: AbstractConst<'tcx>, b: AbstractConst<'tcx>) -> bool {\n+        let a = if let Some(a) = self.try_replace_substs_in_root(a) {\n+            a\n+        } else {\n+            return true;\n+        };\n+\n+        let b = if let Some(b) = self.try_replace_substs_in_root(b) {\n+            b\n+        } else {\n+            return true;\n+        };\n+\n+        let a_root = a.root(self.tcx);\n+        let b_root = b.root(self.tcx);\n+        debug!(?a_root, ?b_root);\n+\n+        match (a_root, b_root) {\n+            (Node::Leaf(a_ct), Node::Leaf(b_ct)) => {\n+                let a_ct = a_ct.eval(self.tcx, self.param_env);\n+                debug!(\"a_ct evaluated: {:?}\", a_ct);\n+                let b_ct = b_ct.eval(self.tcx, self.param_env);\n+                debug!(\"b_ct evaluated: {:?}\", b_ct);\n+\n+                if a_ct.ty() != b_ct.ty() {\n+                    return false;\n                 }\n-                (ty::ConstKind::Value(a_val), ty::ConstKind::Value(b_val)) => a_val == b_val,\n-                // If we have `fn a<const N: usize>() -> [u8; N + 1]` and `fn b<const M: usize>() -> [u8; 1 + M]`\n-                // we do not want to use `assert_eq!(a(), b())` to infer that `N` and `M` have to be `1`. This\n-                // means that we only allow inference variables if they are equal.\n-                (ty::ConstKind::Infer(a_val), ty::ConstKind::Infer(b_val)) => a_val == b_val,\n-                // We expand generic anonymous constants at the start of this function, so this\n-                // branch should only be taking when dealing with associated constants, at\n-                // which point directly comparing them seems like the desired behavior.\n-                //\n-                // FIXME(generic_const_exprs): This isn't actually the case.\n-                // We also take this branch for concrete anonymous constants and\n-                // expand generic anonymous constants with concrete substs.\n-                (ty::ConstKind::Unevaluated(a_uv), ty::ConstKind::Unevaluated(b_uv)) => {\n-                    a_uv == b_uv\n+\n+                match (a_ct.val(), b_ct.val()) {\n+                    // We can just unify errors with everything to reduce the amount of\n+                    // emitted errors here.\n+                    (ty::ConstKind::Error(_), _) | (_, ty::ConstKind::Error(_)) => true,\n+                    (ty::ConstKind::Param(a_param), ty::ConstKind::Param(b_param)) => {\n+                        a_param == b_param\n+                    }\n+                    (ty::ConstKind::Value(a_val), ty::ConstKind::Value(b_val)) => a_val == b_val,\n+                    // If we have `fn a<const N: usize>() -> [u8; N + 1]` and `fn b<const M: usize>() -> [u8; 1 + M]`\n+                    // we do not want to use `assert_eq!(a(), b())` to infer that `N` and `M` have to be `1`. This\n+                    // means that we only allow inference variables if they are equal.\n+                    (ty::ConstKind::Infer(a_val), ty::ConstKind::Infer(b_val)) => a_val == b_val,\n+                    // We expand generic anonymous constants at the start of this function, so this\n+                    // branch should only be taking when dealing with associated constants, at\n+                    // which point directly comparing them seems like the desired behavior.\n+                    //\n+                    // FIXME(generic_const_exprs): This isn't actually the case.\n+                    // We also take this branch for concrete anonymous constants and\n+                    // expand generic anonymous constants with concrete substs.\n+                    (ty::ConstKind::Unevaluated(a_uv), ty::ConstKind::Unevaluated(b_uv)) => {\n+                        a_uv == b_uv\n+                    }\n+                    // FIXME(generic_const_exprs): We may want to either actually try\n+                    // to evaluate `a_ct` and `b_ct` if they are are fully concrete or something like\n+                    // this, for now we just return false here.\n+                    _ => false,\n                 }\n-                // FIXME(generic_const_exprs): We may want to either actually try\n-                // to evaluate `a_ct` and `b_ct` if they are are fully concrete or something like\n-                // this, for now we just return false here.\n-                _ => false,\n             }\n+            (Node::Binop(a_op, al, ar), Node::Binop(b_op, bl, br)) if a_op == b_op => {\n+                self.try_unify(a.subtree(al), b.subtree(bl))\n+                    && self.try_unify(a.subtree(ar), b.subtree(br))\n+            }\n+            (Node::UnaryOp(a_op, av), Node::UnaryOp(b_op, bv)) if a_op == b_op => {\n+                self.try_unify(a.subtree(av), b.subtree(bv))\n+            }\n+            (Node::FunctionCall(a_f, a_args), Node::FunctionCall(b_f, b_args))\n+                if a_args.len() == b_args.len() =>\n+            {\n+                self.try_unify(a.subtree(a_f), b.subtree(b_f))\n+                    && iter::zip(a_args, b_args)\n+                        .all(|(&an, &bn)| self.try_unify(a.subtree(an), b.subtree(bn)))\n+            }\n+            (Node::Cast(a_kind, a_operand, a_ty), Node::Cast(b_kind, b_operand, b_ty))\n+                if (a_ty == b_ty) && (a_kind == b_kind) =>\n+            {\n+                self.try_unify(a.subtree(a_operand), b.subtree(b_operand))\n+            }\n+            // use this over `_ => false` to make adding variants to `Node` less error prone\n+            (Node::Cast(..), _)\n+            | (Node::FunctionCall(..), _)\n+            | (Node::UnaryOp(..), _)\n+            | (Node::Binop(..), _)\n+            | (Node::Leaf(..), _) => false,\n         }\n-        (Node::Binop(a_op, al, ar), Node::Binop(b_op, bl, br)) if a_op == b_op => {\n-            try_unify(tcx, a.subtree(al), b.subtree(bl))\n-                && try_unify(tcx, a.subtree(ar), b.subtree(br))\n-        }\n-        (Node::UnaryOp(a_op, av), Node::UnaryOp(b_op, bv)) if a_op == b_op => {\n-            try_unify(tcx, a.subtree(av), b.subtree(bv))\n-        }\n-        (Node::FunctionCall(a_f, a_args), Node::FunctionCall(b_f, b_args))\n-            if a_args.len() == b_args.len() =>\n-        {\n-            try_unify(tcx, a.subtree(a_f), b.subtree(b_f))\n-                && iter::zip(a_args, b_args)\n-                    .all(|(&an, &bn)| try_unify(tcx, a.subtree(an), b.subtree(bn)))\n-        }\n-        (Node::Cast(a_kind, a_operand, a_ty), Node::Cast(b_kind, b_operand, b_ty))\n-            if (a_ty == b_ty) && (a_kind == b_kind) =>\n-        {\n-            try_unify(tcx, a.subtree(a_operand), b.subtree(b_operand))\n-        }\n-        // use this over `_ => false` to make adding variants to `Node` less error prone\n-        (Node::Cast(..), _)\n-        | (Node::FunctionCall(..), _)\n-        | (Node::UnaryOp(..), _)\n-        | (Node::Binop(..), _)\n-        | (Node::Leaf(..), _) => false,\n     }\n }"}, {"sha": "1b8628344671db5a577f57a66e68bcc836ae2034", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc", "patch": "@@ -580,7 +580,11 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                         if let (ty::ConstKind::Unevaluated(a), ty::ConstKind::Unevaluated(b)) =\n                             (c1.val(), c2.val())\n                         {\n-                            if infcx.try_unify_abstract_consts(a.shrink(), b.shrink()) {\n+                            if infcx.try_unify_abstract_consts(\n+                                a.shrink(),\n+                                b.shrink(),\n+                                obligation.param_env,\n+                            ) {\n                                 return ProcessResult::Changed(vec![]);\n                             }\n                         }"}, {"sha": "88750f272c8d3a0c7aa29e03960a8e1cb2addc44", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc", "patch": "@@ -862,7 +862,10 @@ pub fn provide(providers: &mut ty::query::Providers) {\n                 ty::WithOptConstParam { did, const_param_did: Some(param_did) },\n             )\n         },\n-        try_unify_abstract_consts: const_evaluatable::try_unify_abstract_consts,\n+        try_unify_abstract_consts: |tcx, param_env_and| {\n+            let (param_env, (a, b)) = param_env_and.into_parts();\n+            const_evaluatable::try_unify_abstract_consts(tcx, (a, b), param_env)\n+        },\n         ..*providers\n     };\n }"}, {"sha": "6d232d86d8a4f85feaab9e60c11b0cd1adf4baa8", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc", "patch": "@@ -639,7 +639,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         if let (ty::ConstKind::Unevaluated(a), ty::ConstKind::Unevaluated(b)) =\n                             (c1.val(), c2.val())\n                         {\n-                            if self.infcx.try_unify_abstract_consts(a.shrink(), b.shrink()) {\n+                            if self.infcx.try_unify_abstract_consts(\n+                                a.shrink(),\n+                                b.shrink(),\n+                                obligation.param_env,\n+                            ) {\n                                 return Ok(EvaluatedToOk);\n                             }\n                         }"}, {"sha": "4ab94f39357d8942dabcf787091e51279f7bd8fd", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc", "patch": "@@ -243,7 +243,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n                 (\n                     ty::PredicateKind::ConstEvaluatable(a),\n                     ty::PredicateKind::ConstEvaluatable(b),\n-                ) => tcx.try_unify_abstract_consts((a, b)),\n+                ) => tcx.try_unify_abstract_consts(self_param_env.and((a, b))),\n                 (\n                     ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_a, lt_a)),\n                     ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_b, lt_b)),"}, {"sha": "c59d62e576d9b95d55427b04bdd3c8d8d5173f1f", "filename": "src/test/ui/const-generics/generic_const_exprs/eval-try-unify.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Feval-try-unify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Feval-try-unify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Feval-try-unify.rs?ref=1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc", "patch": "@@ -0,0 +1,26 @@\n+// build-pass\n+\n+#![feature(generic_const_exprs)]\n+//~^ WARNING the feature `generic_const_exprs` is incomplete\n+\n+trait Generic {\n+    const ASSOC: usize;\n+}\n+\n+impl Generic for u8 {\n+    const ASSOC: usize = 17;\n+}\n+impl Generic for u16 {\n+    const ASSOC: usize = 13;\n+}\n+\n+\n+fn uses_assoc_type<T: Generic, const N: usize>() -> [u8; N + T::ASSOC] {\n+    [0; N + T::ASSOC]\n+}\n+\n+fn only_generic_n<const N: usize>() -> [u8; N + 13] {\n+    uses_assoc_type::<u16, N>()\n+}\n+\n+fn main() {}"}, {"sha": "b5719b3fe1dc29df5868573b9bfff7cdab8c2055", "filename": "src/test/ui/const-generics/generic_const_exprs/eval-try-unify.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Feval-try-unify.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Feval-try-unify.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Feval-try-unify.stderr?ref=1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `generic_const_exprs` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/eval-try-unify.rs:3:12\n+   |\n+LL | #![feature(generic_const_exprs)]\n+   |            ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #76560 <https://github.com/rust-lang/rust/issues/76560> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "71c164ab0a5bf68dd863951b0bd51bd98f7dff4c", "filename": "src/test/ui/const-generics/issues/issue-83765.rs", "status": "modified", "additions": 65, "deletions": 64, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.rs?ref=1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc", "patch": "@@ -2,114 +2,115 @@\n #![allow(incomplete_features)]\n \n trait TensorDimension {\n-    const DIM : usize;\n-    const ISSCALAR : bool = Self::DIM == 0;\n-    fn is_scalar(&self) -> bool {Self::ISSCALAR}\n+    const DIM: usize;\n+    //~^ ERROR cycle detected when resolving instance\n+    // FIXME Given the current state of the compiler its expected that we cycle here,\n+    // but the cycle is still wrong.\n+    const ISSCALAR: bool = Self::DIM == 0;\n+    fn is_scalar(&self) -> bool {\n+        Self::ISSCALAR\n+    }\n }\n \n-trait TensorSize : TensorDimension {\n-    fn size(&self) -> [usize;Self::DIM];\n-    fn inbounds(&self,index : [usize;Self::DIM]) -> bool {\n-        index.iter().zip(self.size().iter()).all(|(i,s)| i < s)\n+trait TensorSize: TensorDimension {\n+    fn size(&self) -> [usize; Self::DIM];\n+    fn inbounds(&self, index: [usize; Self::DIM]) -> bool {\n+        index.iter().zip(self.size().iter()).all(|(i, s)| i < s)\n     }\n }\n \n-\n trait Broadcastable: TensorSize + Sized {\n     type Element;\n-    fn bget(&self, index:[usize;Self::DIM]) -> Option<Self::Element>;\n-    fn lazy_updim<const NEWDIM : usize>(&self, size : [usize;NEWDIM] ) ->\n-       LazyUpdim<Self,{Self::DIM},NEWDIM>\n-    {\n-        assert!(NEWDIM >= Self::DIM,\n-            \"Updimmed tensor cannot have fewer indices than the initial one.\");\n-        LazyUpdim {size,reference:&self}\n+    fn bget(&self, index: [usize; Self::DIM]) -> Option<Self::Element>;\n+    fn lazy_updim<const NEWDIM: usize>(\n+        &self,\n+        size: [usize; NEWDIM],\n+    ) -> LazyUpdim<Self, { Self::DIM }, NEWDIM> {\n+        assert!(\n+            NEWDIM >= Self::DIM,\n+            \"Updimmed tensor cannot have fewer indices than the initial one.\"\n+        );\n+        LazyUpdim { size, reference: &self }\n     }\n-    fn bmap<T,F :Fn(Self::Element) -> T>(&self,foo : F) -> BMap<T,Self,F,{Self::DIM}>{\n-        BMap {reference:self,closure : foo}\n+    fn bmap<T, F: Fn(Self::Element) -> T>(&self, foo: F) -> BMap<T, Self, F, { Self::DIM }> {\n+        BMap { reference: self, closure: foo }\n     }\n }\n \n-\n-struct LazyUpdim<'a,T : Broadcastable,const OLDDIM : usize, const DIM : usize> {\n-    size : [usize;DIM],\n-    reference : &'a T\n+struct LazyUpdim<'a, T: Broadcastable, const OLDDIM: usize, const DIM: usize> {\n+    size: [usize; DIM],\n+    reference: &'a T,\n }\n \n-impl<'a,T : Broadcastable,const DIM : usize> TensorDimension for LazyUpdim<'a,T,{T::DIM},DIM> {\n-    const DIM : usize = DIM;\n+impl<'a, T: Broadcastable, const DIM: usize> TensorDimension for LazyUpdim<'a, T, { T::DIM }, DIM> {\n+    const DIM: usize = DIM;\n }\n \n-impl<'a,T : Broadcastable,const DIM : usize> TensorSize for LazyUpdim<'a,T,{T::DIM},DIM> {\n-    fn size(&self) -> [usize;DIM] {self.size}\n-    //~^ ERROR method not compatible with trait\n+impl<'a, T: Broadcastable, const DIM: usize> TensorSize for LazyUpdim<'a, T, { T::DIM }, DIM> {\n+    fn size(&self) -> [usize; DIM] {\n+        self.size\n+    }\n }\n \n-impl<'a,T : Broadcastable,const DIM : usize>  Broadcastable for LazyUpdim<'a,T,{T::DIM},DIM>\n-{\n+impl<'a, T: Broadcastable, const DIM: usize> Broadcastable for LazyUpdim<'a, T, { T::DIM }, DIM> {\n     type Element = T::Element;\n-    fn bget(&self,index:[usize;DIM]) -> Option<Self::Element> {\n-      //~^ ERROR method not compatible with trait\n+    fn bget(&self, index: [usize; DIM]) -> Option<Self::Element> {\n         assert!(DIM >= T::DIM);\n-        if !self.inbounds(index) {return None}\n-        //~^ ERROR unconstrained generic constant\n-        //~| ERROR mismatched types\n+        if !self.inbounds(index) {\n+            return None;\n+        }\n         let size = self.size();\n-        //~^ ERROR unconstrained generic constant\n-        let newindex : [usize;T::DIM] = Default::default();\n-        //~^ ERROR the trait bound `[usize; _]: Default` is not satisfied\n+        let newindex: [usize; T::DIM] = Default::default();\n         self.reference.bget(newindex)\n     }\n }\n \n-struct BMap<'a,R, T : Broadcastable, F :  Fn(T::Element) -> R  , const DIM: usize> {\n-    reference : &'a T,\n-    closure : F\n+struct BMap<'a, R, T: Broadcastable, F: Fn(T::Element) -> R, const DIM: usize> {\n+    reference: &'a T,\n+    closure: F,\n }\n \n-impl<'a,R, T : Broadcastable, F :  Fn(T::Element) -> R,\n-     const DIM: usize> TensorDimension for BMap<'a,R,T,F,DIM> {\n-\n-    const DIM : usize = DIM;\n+impl<'a, R, T: Broadcastable, F: Fn(T::Element) -> R, const DIM: usize> TensorDimension\n+    for BMap<'a, R, T, F, DIM>\n+{\n+    const DIM: usize = DIM;\n }\n-impl<'a,R, T : Broadcastable, F :  Fn(T::Element) -> R  ,\n-      const DIM: usize> TensorSize for BMap<'a,R,T,F,DIM> {\n-\n-    fn size(&self) -> [usize;DIM] {self.reference.size()}\n-    //~^ ERROR unconstrained generic constant\n-    //~| ERROR mismatched types\n-    //~| ERROR method not compatible with trait\n+impl<'a, R, T: Broadcastable, F: Fn(T::Element) -> R, const DIM: usize> TensorSize\n+    for BMap<'a, R, T, F, DIM>\n+{\n+    fn size(&self) -> [usize; DIM] {\n+        self.reference.size()\n+    }\n }\n \n-impl<'a,R, T : Broadcastable, F :  Fn(T::Element) -> R  ,\n-  const DIM: usize> Broadcastable for BMap<'a,R,T,F,DIM> {\n-\n+impl<'a, R, T: Broadcastable, F: Fn(T::Element) -> R, const DIM: usize> Broadcastable\n+    for BMap<'a, R, T, F, DIM>\n+{\n     type Element = R;\n-    fn bget(&self,index:[usize;DIM]) -> Option<Self::Element> {\n-      //~^ ERROR method not compatible with trait\n+    fn bget(&self, index: [usize; DIM]) -> Option<Self::Element> {\n         self.reference.bget(index).map(&self.closure)\n-        //~^ ERROR unconstrained generic constant\n-        //~| ERROR mismatched types\n     }\n }\n \n impl<T> TensorDimension for Vec<T> {\n-    const DIM : usize = 1;\n+    const DIM: usize = 1;\n }\n impl<T> TensorSize for Vec<T> {\n-    fn size(&self) -> [usize;1] {[self.len()]}\n+    fn size(&self) -> [usize; 1] {\n+        [self.len()]\n+    }\n }\n impl<T: Clone> Broadcastable for Vec<T> {\n     type Element = T;\n-    fn bget(& self,index : [usize;1]) -> Option<T> {\n+    fn bget(&self, index: [usize; 1]) -> Option<T> {\n         self.get(index[0]).cloned()\n     }\n }\n \n fn main() {\n-    let v = vec![1,2,3];\n-    let bv = v.lazy_updim([3,4]);\n-    let bbv = bv.bmap(|x| x*x);\n+    let v = vec![1, 2, 3];\n+    let bv = v.lazy_updim([3, 4]);\n+    let bbv = bv.bmap(|x| x * x);\n \n-    println!(\"The size of v is {:?}\",bbv.bget([0,2]).expect(\"Out of bounds.\"));\n+    println!(\"The size of v is {:?}\", bbv.bget([0, 2]).expect(\"Out of bounds.\"));\n }"}, {"sha": "8705a39fa4bcd3397061a59f03e9bfcec0821941", "filename": "src/test/ui/const-generics/issues/issue-83765.stderr", "status": "modified", "additions": 12, "deletions": 125, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr?ref=1fcb8fc3e0bc82fc63bbb8baa6c6325d361115fc", "patch": "@@ -1,130 +1,17 @@\n-error[E0308]: method not compatible with trait\n-  --> $DIR/issue-83765.rs:44:5\n+error[E0391]: cycle detected when resolving instance `<LazyUpdim<T, { T::DIM }, DIM> as TensorDimension>::DIM`\n+  --> $DIR/issue-83765.rs:5:5\n    |\n-LL |     fn size(&self) -> [usize;DIM] {self.size}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Self::DIM`, found `DIM`\n+LL |     const DIM: usize;\n+   |     ^^^^^^^^^^^^^^^^^\n    |\n-   = note: expected type `Self::DIM`\n-              found type `DIM`\n-\n-error[E0308]: method not compatible with trait\n-  --> $DIR/issue-83765.rs:51:5\n-   |\n-LL |     fn bget(&self,index:[usize;DIM]) -> Option<Self::Element> {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Self::DIM`, found `DIM`\n-   |\n-   = note: expected type `Self::DIM`\n-              found type `DIM`\n-\n-error[E0308]: method not compatible with trait\n-  --> $DIR/issue-83765.rs:78:5\n-   |\n-LL |     fn size(&self) -> [usize;DIM] {self.reference.size()}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Self::DIM`, found `DIM`\n-   |\n-   = note: expected type `Self::DIM`\n-              found type `DIM`\n-\n-error[E0308]: method not compatible with trait\n-  --> $DIR/issue-83765.rs:88:5\n-   |\n-LL |     fn bget(&self,index:[usize;DIM]) -> Option<Self::Element> {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Self::DIM`, found `DIM`\n-   |\n-   = note: expected type `Self::DIM`\n-              found type `DIM`\n-\n-error: unconstrained generic constant\n-  --> $DIR/issue-83765.rs:54:18\n-   |\n-LL |         if !self.inbounds(index) {return None}\n-   |                  ^^^^^^^^\n-   |\n-   = help: try adding a `where` bound using this expression: `where [(); Self::DIM]:`\n-note: required by a bound in `TensorSize::inbounds`\n-  --> $DIR/issue-83765.rs:12:38\n-   |\n-LL |     fn inbounds(&self,index : [usize;Self::DIM]) -> bool {\n-   |                                      ^^^^^^^^^ required by this bound in `TensorSize::inbounds`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/issue-83765.rs:54:27\n-   |\n-LL |         if !self.inbounds(index) {return None}\n-   |                           ^^^^^ expected `Self::DIM`, found `DIM`\n-   |\n-   = note: expected type `Self::DIM`\n-              found type `DIM`\n-\n-error: unconstrained generic constant\n-  --> $DIR/issue-83765.rs:57:25\n-   |\n-LL |         let size = self.size();\n-   |                         ^^^^\n-   |\n-   = help: try adding a `where` bound using this expression: `where [(); Self::DIM]:`\n-note: required by a bound in `TensorSize::size`\n-  --> $DIR/issue-83765.rs:11:30\n-   |\n-LL |     fn size(&self) -> [usize;Self::DIM];\n-   |                              ^^^^^^^^^ required by this bound in `TensorSize::size`\n-\n-error[E0277]: the trait bound `[usize; _]: Default` is not satisfied\n-  --> $DIR/issue-83765.rs:59:41\n-   |\n-LL |         let newindex : [usize;T::DIM] = Default::default();\n-   |                                         ^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `[usize; _]`\n-   |\n-help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n-   |\n-LL | impl<'a,T : Broadcastable,const DIM : usize>  Broadcastable for LazyUpdim<'a,T,{T::DIM},DIM> where [usize; _]: Default\n-   |                                                                                              +++++++++++++++++++++++++\n-\n-error: unconstrained generic constant\n-  --> $DIR/issue-83765.rs:78:51\n-   |\n-LL |     fn size(&self) -> [usize;DIM] {self.reference.size()}\n-   |                                                   ^^^^\n-   |\n-   = help: try adding a `where` bound using this expression: `where [(); Self::DIM]:`\n-note: required by a bound in `TensorSize::size`\n-  --> $DIR/issue-83765.rs:11:30\n-   |\n-LL |     fn size(&self) -> [usize;Self::DIM];\n-   |                              ^^^^^^^^^ required by this bound in `TensorSize::size`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/issue-83765.rs:78:36\n-   |\n-LL |     fn size(&self) -> [usize;DIM] {self.reference.size()}\n-   |                                    ^^^^^^^^^^^^^^^^^^^^^ expected `DIM`, found `Self::DIM`\n-   |\n-   = note: expected type `DIM`\n-              found type `Self::DIM`\n-\n-error: unconstrained generic constant\n-  --> $DIR/issue-83765.rs:90:24\n-   |\n-LL |         self.reference.bget(index).map(&self.closure)\n-   |                        ^^^^\n-   |\n-   = help: try adding a `where` bound using this expression: `where [(); Self::DIM]:`\n-note: required by a bound in `Broadcastable::bget`\n-  --> $DIR/issue-83765.rs:20:33\n-   |\n-LL |     fn bget(&self, index:[usize;Self::DIM]) -> Option<Self::Element>;\n-   |                                 ^^^^^^^^^ required by this bound in `Broadcastable::bget`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/issue-83765.rs:90:29\n-   |\n-LL |         self.reference.bget(index).map(&self.closure)\n-   |                             ^^^^^ expected `Self::DIM`, found `DIM`\n+note: ...which requires checking if `TensorDimension` fulfills its obligations...\n+  --> $DIR/issue-83765.rs:4:1\n    |\n-   = note: expected type `Self::DIM`\n-              found type `DIM`\n+LL | trait TensorDimension {\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which again requires resolving instance `<LazyUpdim<T, { T::DIM }, DIM> as TensorDimension>::DIM`, completing the cycle\n+   = note: cycle used when normalizing `<LazyUpdim<T, { T::DIM }, DIM> as TensorDimension>::DIM`\n \n-error: aborting due to 12 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0277, E0308.\n-For more information about an error, try `rustc --explain E0277`.\n+For more information about this error, try `rustc --explain E0391`."}]}