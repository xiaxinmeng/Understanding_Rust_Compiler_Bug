{"sha": "8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "node_id": "C_kwDOAAsO6NoAKDhjY2E0MmE0N2Y1ZDU3NGM4ZjczMDJjOThjM2Y5MThjZGM3NzJmYmI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-09T14:12:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-09T14:12:59Z"}, "message": "Auto merge of #107843 - bjorn3:sync_cg_clif-2023-02-09, r=bjorn3\n\nSync rustc_codegen_cranelift\n\n* Couple of bugfixes\n* A significant runtime perf improvement\n* Implemented sym and const support for inline asm\n* Improved self profile integration\n\nr? `@ghost`\n\n`@rustbot` label +A-codegen +A-cranelift +T-compiler", "tree": {"sha": "539e78dca393e9cdc1b0fe857c772a6a427b7e0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/539e78dca393e9cdc1b0fe857c772a6a427b7e0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "html_url": "https://github.com/rust-lang/rust/commit/8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5919f62cf6681979cb5401d3907445f14d27ec8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5919f62cf6681979cb5401d3907445f14d27ec8f", "html_url": "https://github.com/rust-lang/rust/commit/5919f62cf6681979cb5401d3907445f14d27ec8f"}, {"sha": "e25566e20b079b7eae57518768dee44fb53c8cbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/e25566e20b079b7eae57518768dee44fb53c8cbb", "html_url": "https://github.com/rust-lang/rust/commit/e25566e20b079b7eae57518768dee44fb53c8cbb"}], "stats": {"total": 971, "additions": 640, "deletions": 331}, "files": [{"sha": "9d3ed3ac5d0c38dc7d7d656c1821f9467448f699", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/main.yml", "status": "modified", "additions": 128, "deletions": 18, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml?ref=8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "patch": "@@ -21,6 +21,7 @@ jobs:\n         cargo fmt --check\n         rustfmt --check build_system/mod.rs\n \n+\n   build:\n     runs-on: ${{ matrix.os }}\n     timeout-minutes: 60\n@@ -33,7 +34,7 @@ jobs:\n       fail-fast: false\n       matrix:\n         include:\n-          - os: ubuntu-20.04 # FIXME switch to ubuntu-22.04 once #1303 is fixed\n+          - os: ubuntu-latest\n             env:\n               TARGET_TRIPLE: x86_64-unknown-linux-gnu\n           - os: macos-latest\n@@ -112,23 +113,6 @@ jobs:\n         TARGET_TRIPLE: ${{ matrix.env.TARGET_TRIPLE }}\n       run: ./y.rs test\n \n-    - name: Package prebuilt cg_clif\n-      run: tar cvfJ cg_clif.tar.xz dist\n-\n-    - name: Upload prebuilt cg_clif\n-      if: matrix.os == 'windows-latest' || matrix.env.TARGET_TRIPLE != 'x86_64-pc-windows-gnu'\n-      uses: actions/upload-artifact@v3\n-      with:\n-        name: cg_clif-${{ matrix.env.TARGET_TRIPLE }}\n-        path: cg_clif.tar.xz\n-\n-    - name: Upload prebuilt cg_clif (cross compile)\n-      if: matrix.os != 'windows-latest' && matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n-      uses: actions/upload-artifact@v3\n-      with:\n-        name: cg_clif-${{ runner.os }}-cross-x86_64-mingw\n-        path: cg_clif.tar.xz\n-\n \n   abi_cafe:\n     runs-on: ${{ matrix.os }}\n@@ -185,3 +169,129 @@ jobs:\n       env:\n         TARGET_TRIPLE: ${{ matrix.env.TARGET_TRIPLE }}\n       run: ./y.rs abi-cafe\n+\n+\n+  bench:\n+    runs-on: ubuntu-latest\n+    timeout-minutes: 60\n+\n+    defaults:\n+      run:\n+        shell: bash\n+\n+    steps:\n+    - uses: actions/checkout@v3\n+\n+    - name: Cache cargo target dir\n+      uses: actions/cache@v3\n+      with:\n+        path: build/cg_clif\n+        key: ${{ runner.os }}-x86_64-unknown-linux-gnu-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n+\n+    - name: Cache cargo bin dir\n+      uses: actions/cache@v3\n+      with:\n+        path: ~/.cargo/bin\n+        key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-cargo-bin-dir-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n+\n+    - name: Use sparse cargo registry\n+      run: |\n+        cat >> ~/.cargo/config.toml <<EOF\n+        [unstable]\n+        sparse-registry = true\n+        EOF\n+\n+    - name: Install hyperfine\n+      run: cargo install hyperfine || true\n+\n+    - name: Prepare dependencies\n+      run: ./y.rs prepare\n+\n+    - name: Build\n+      run: CI_OPT=1 ./y.rs build --sysroot none\n+\n+    - name: Benchmark\n+      run: CI_OPT=1 ./y.rs bench\n+\n+\n+  dist:\n+    runs-on: ${{ matrix.os }}\n+    timeout-minutes: 60\n+\n+    defaults:\n+      run:\n+        shell: bash\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        include:\n+          # FIXME update at some point in the future once most distros use a newer glibc\n+          - os: ubuntu-20.04\n+            env:\n+              TARGET_TRIPLE: x86_64-unknown-linux-gnu\n+          - os: macos-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-apple-darwin\n+          # cross-compile from Linux to Windows using mingw\n+          - os: ubuntu-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-pc-windows-gnu\n+          - os: windows-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-pc-windows-msvc\n+          - os: windows-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-pc-windows-gnu\n+\n+    steps:\n+    - uses: actions/checkout@v3\n+\n+    - name: Cache cargo target dir\n+      uses: actions/cache@v3\n+      with:\n+        path: build/cg_clif\n+        key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-dist-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n+\n+    - name: Set MinGW as the default toolchain\n+      if: matrix.os == 'windows-latest' && matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n+      run: rustup set default-host x86_64-pc-windows-gnu\n+\n+    - name: Install MinGW toolchain and wine\n+      if: matrix.os == 'ubuntu-latest' && matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n+      run: |\n+        sudo apt-get update\n+        sudo apt-get install -y gcc-mingw-w64-x86-64 wine-stable\n+\n+    - name: Use sparse cargo registry\n+      run: |\n+        cat >> ~/.cargo/config.toml <<EOF\n+        [unstable]\n+        sparse-registry = true\n+        EOF\n+\n+    - name: Prepare dependencies\n+      run: ./y.rs prepare\n+\n+    - name: Build backend\n+      run: CI_OPT=1 ./y.rs build --sysroot none\n+\n+    - name: Build sysroot\n+      run: CI_OPT=1 ./y.rs build\n+\n+    - name: Package prebuilt cg_clif\n+      run: tar cvfJ cg_clif.tar.xz dist\n+\n+    - name: Upload prebuilt cg_clif\n+      if: matrix.os == 'windows-latest' || matrix.env.TARGET_TRIPLE != 'x86_64-pc-windows-gnu'\n+      uses: actions/upload-artifact@v3\n+      with:\n+        name: cg_clif-${{ matrix.env.TARGET_TRIPLE }}\n+        path: cg_clif.tar.xz\n+\n+    - name: Upload prebuilt cg_clif (cross compile)\n+      if: matrix.os != 'windows-latest' && matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n+      uses: actions/upload-artifact@v3\n+      with:\n+        name: cg_clif-${{ runner.os }}-cross-x86_64-mingw\n+        path: cg_clif.tar.xz"}, {"sha": "b7e0b68a2a27a2cdb9ad71da9d885f7e4d8dc8db", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "patch": "@@ -34,9 +34,9 @@ dependencies = [\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.78\"\n+version = \"1.0.79\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a20104e2335ce8a659d6dd92a51a767a0c062599c73b343fd152cb401e828c3d\"\n+checksum = \"50d30906286121d95be3d479533b458f87493b30a4b5f79a607db8f5d11aa91f\"\n \n [[package]]\n name = \"cfg-if\""}, {"sha": "0da27f529b3ecd730a2f7a0cdfe16c55b04909b1", "filename": "compiler/rustc_codegen_cranelift/build_system/abi_cafe.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_cafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_cafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_cafe.rs?ref=8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "patch": "@@ -6,11 +6,10 @@ use super::prepare::GitRepo;\n use super::utils::{spawn_and_wait, CargoProject, Compiler};\n use super::SysrootKind;\n \n-pub(crate) static ABI_CAFE_REPO: GitRepo =\n+static ABI_CAFE_REPO: GitRepo =\n     GitRepo::github(\"Gankra\", \"abi-cafe\", \"4c6dc8c9c687e2b3a760ff2176ce236872b37212\", \"abi-cafe\");\n \n-pub(crate) static ABI_CAFE: CargoProject =\n-    CargoProject::new(&ABI_CAFE_REPO.source_dir(), \"abi_cafe\");\n+static ABI_CAFE: CargoProject = CargoProject::new(&ABI_CAFE_REPO.source_dir(), \"abi_cafe\");\n \n pub(crate) fn run(\n     channel: &str,\n@@ -19,6 +18,9 @@ pub(crate) fn run(\n     cg_clif_dylib: &Path,\n     bootstrap_host_compiler: &Compiler,\n ) {\n+    ABI_CAFE_REPO.fetch(dirs);\n+    spawn_and_wait(ABI_CAFE.fetch(\"cargo\", &bootstrap_host_compiler.rustc, dirs));\n+\n     eprintln!(\"Building sysroot for abi-cafe\");\n     build_sysroot::build_sysroot(\n         dirs,"}, {"sha": "a9a851d0a8afc882e0c24cc7f60c8259c0905fbf", "filename": "compiler/rustc_codegen_cranelift/build_system/bench.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbench.rs?ref=8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "patch": "@@ -5,20 +5,20 @@ use std::path::Path;\n use super::path::{Dirs, RelPath};\n use super::prepare::GitRepo;\n use super::rustc_info::get_file_name;\n-use super::utils::{hyperfine_command, is_ci, spawn_and_wait, CargoProject, Compiler};\n+use super::utils::{hyperfine_command, spawn_and_wait, CargoProject, Compiler};\n \n-pub(crate) static SIMPLE_RAYTRACER_REPO: GitRepo = GitRepo::github(\n+static SIMPLE_RAYTRACER_REPO: GitRepo = GitRepo::github(\n     \"ebobby\",\n     \"simple-raytracer\",\n     \"804a7a21b9e673a482797aa289a18ed480e4d813\",\n     \"<none>\",\n );\n \n // Use a separate target dir for the initial LLVM build to reduce unnecessary recompiles\n-pub(crate) static SIMPLE_RAYTRACER_LLVM: CargoProject =\n+static SIMPLE_RAYTRACER_LLVM: CargoProject =\n     CargoProject::new(&SIMPLE_RAYTRACER_REPO.source_dir(), \"simple_raytracer_llvm\");\n \n-pub(crate) static SIMPLE_RAYTRACER: CargoProject =\n+static SIMPLE_RAYTRACER: CargoProject =\n     CargoProject::new(&SIMPLE_RAYTRACER_REPO.source_dir(), \"simple_raytracer\");\n \n pub(crate) fn benchmark(dirs: &Dirs, bootstrap_host_compiler: &Compiler) {\n@@ -32,6 +32,15 @@ fn benchmark_simple_raytracer(dirs: &Dirs, bootstrap_host_compiler: &Compiler) {\n         std::process::exit(1);\n     }\n \n+    if !SIMPLE_RAYTRACER_REPO.source_dir().to_path(dirs).exists() {\n+        SIMPLE_RAYTRACER_REPO.fetch(dirs);\n+        spawn_and_wait(SIMPLE_RAYTRACER.fetch(\n+            &bootstrap_host_compiler.cargo,\n+            &bootstrap_host_compiler.rustc,\n+            dirs,\n+        ));\n+    }\n+\n     eprintln!(\"[LLVM BUILD] simple-raytracer\");\n     let build_cmd = SIMPLE_RAYTRACER_LLVM.build(bootstrap_host_compiler, dirs);\n     spawn_and_wait(build_cmd);\n@@ -45,10 +54,7 @@ fn benchmark_simple_raytracer(dirs: &Dirs, bootstrap_host_compiler: &Compiler) {\n     )\n     .unwrap();\n \n-    let run_runs = env::var(\"RUN_RUNS\")\n-        .unwrap_or(if is_ci() { \"2\" } else { \"10\" }.to_string())\n-        .parse()\n-        .unwrap();\n+    let bench_runs = env::var(\"BENCH_RUNS\").unwrap_or_else(|_| \"10\".to_string()).parse().unwrap();\n \n     eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer\");\n     let cargo_clif =\n@@ -57,24 +63,24 @@ fn benchmark_simple_raytracer(dirs: &Dirs, bootstrap_host_compiler: &Compiler) {\n     let target_dir = SIMPLE_RAYTRACER.target_dir(dirs);\n \n     let clean_cmd = format!(\n-        \"cargo clean --manifest-path {manifest_path} --target-dir {target_dir}\",\n+        \"RUSTC=rustc cargo clean --manifest-path {manifest_path} --target-dir {target_dir}\",\n         manifest_path = manifest_path.display(),\n         target_dir = target_dir.display(),\n     );\n     let llvm_build_cmd = format!(\n-        \"cargo build --manifest-path {manifest_path} --target-dir {target_dir}\",\n+        \"RUSTC=rustc cargo build --manifest-path {manifest_path} --target-dir {target_dir}\",\n         manifest_path = manifest_path.display(),\n         target_dir = target_dir.display(),\n     );\n     let clif_build_cmd = format!(\n-        \"{cargo_clif} build --manifest-path {manifest_path} --target-dir {target_dir}\",\n+        \"RUSTC=rustc {cargo_clif} build --manifest-path {manifest_path} --target-dir {target_dir}\",\n         cargo_clif = cargo_clif.display(),\n         manifest_path = manifest_path.display(),\n         target_dir = target_dir.display(),\n     );\n \n     let bench_compile =\n-        hyperfine_command(1, run_runs, Some(&clean_cmd), &llvm_build_cmd, &clif_build_cmd);\n+        hyperfine_command(1, bench_runs, Some(&clean_cmd), &llvm_build_cmd, &clif_build_cmd);\n \n     spawn_and_wait(bench_compile);\n \n@@ -87,7 +93,7 @@ fn benchmark_simple_raytracer(dirs: &Dirs, bootstrap_host_compiler: &Compiler) {\n \n     let mut bench_run = hyperfine_command(\n         0,\n-        run_runs,\n+        bench_runs,\n         None,\n         Path::new(\".\").join(get_file_name(\"raytracer_cg_llvm\", \"bin\")).to_str().unwrap(),\n         Path::new(\".\").join(get_file_name(\"raytracer_cg_clif\", \"bin\")).to_str().unwrap(),"}, {"sha": "4b740fa2db65f32947b1f86663193b22074ac585", "filename": "compiler/rustc_codegen_cranelift/build_system/build_backend.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs?ref=8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "patch": "@@ -3,7 +3,7 @@ use std::path::PathBuf;\n \n use super::path::{Dirs, RelPath};\n use super::rustc_info::get_file_name;\n-use super::utils::{is_ci, CargoProject, Compiler};\n+use super::utils::{is_ci, is_ci_opt, CargoProject, Compiler};\n \n pub(crate) static CG_CLIF: CargoProject = CargoProject::new(&RelPath::SOURCE, \"cg_clif\");\n \n@@ -26,7 +26,9 @@ pub(crate) fn build_backend(\n         // Disabling incr comp reduces cache size and incr comp doesn't save as much on CI anyway\n         cmd.env(\"CARGO_BUILD_INCREMENTAL\", \"false\");\n \n-        cmd.env(\"CARGO_PROFILE_RELEASE_DEBUG_ASSERTIONS\", \"true\");\n+        if !is_ci_opt() {\n+            cmd.env(\"CARGO_PROFILE_RELEASE_DEBUG_ASSERTIONS\", \"true\");\n+        }\n     }\n \n     if use_unstable_features {"}, {"sha": "2e04f2c68116ca749da28b81aaef687985e62d9c", "filename": "compiler/rustc_codegen_cranelift/build_system/build_sysroot.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs?ref=8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "patch": "@@ -248,6 +248,9 @@ fn build_clif_sysroot_for_triple(\n         build_cmd.arg(\"--release\");\n     }\n     build_cmd.env(\"__CARGO_DEFAULT_LIB_METADATA\", \"cg_clif\");\n+    if compiler.triple.contains(\"apple\") {\n+        build_cmd.env(\"CARGO_PROFILE_RELEASE_SPLIT_DEBUGINFO\", \"packed\");\n+    }\n     spawn_and_wait(build_cmd);\n \n     for entry in fs::read_dir(build_dir.join(\"deps\")).unwrap() {"}, {"sha": "8a53acdf7e3968983c7c31507bb3f4f8c3817c88", "filename": "compiler/rustc_codegen_cranelift/build_system/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs?ref=8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "patch": "@@ -2,7 +2,7 @@ use std::env;\n use std::path::PathBuf;\n use std::process;\n \n-use self::utils::{is_ci, Compiler};\n+use self::utils::{is_ci, is_ci_opt, Compiler};\n \n mod abi_cafe;\n mod bench;\n@@ -53,8 +53,10 @@ pub fn main() {\n         // Disabling incr comp reduces cache size and incr comp doesn't save as much on CI anyway\n         env::set_var(\"CARGO_BUILD_INCREMENTAL\", \"false\");\n \n-        // Enable the Cranelift verifier\n-        env::set_var(\"CG_CLIF_ENABLE_VERIFIER\", \"1\");\n+        if !is_ci_opt() {\n+            // Enable the Cranelift verifier\n+            env::set_var(\"CG_CLIF_ENABLE_VERIFIER\", \"1\");\n+        }\n     }\n \n     let mut args = env::args().skip(1);"}, {"sha": "50b1b7836dee1427e0b2476428032e776b65bf00", "filename": "compiler/rustc_codegen_cranelift/build_system/prepare.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs?ref=8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "patch": "@@ -11,22 +11,18 @@ use super::utils::{copy_dir_recursively, git_command, retry_spawn_and_wait, spaw\n pub(crate) fn prepare(dirs: &Dirs) {\n     RelPath::DOWNLOAD.ensure_fresh(dirs);\n \n-    spawn_and_wait(super::build_backend::CG_CLIF.fetch(\"cargo\", dirs));\n+    spawn_and_wait(super::build_backend::CG_CLIF.fetch(\"cargo\", \"rustc\", dirs));\n \n     prepare_sysroot(dirs);\n-    spawn_and_wait(super::build_sysroot::STANDARD_LIBRARY.fetch(\"cargo\", dirs));\n-    spawn_and_wait(super::tests::LIBCORE_TESTS.fetch(\"cargo\", dirs));\n+    spawn_and_wait(super::build_sysroot::STANDARD_LIBRARY.fetch(\"cargo\", \"rustc\", dirs));\n+    spawn_and_wait(super::tests::LIBCORE_TESTS.fetch(\"cargo\", \"rustc\", dirs));\n \n-    super::abi_cafe::ABI_CAFE_REPO.fetch(dirs);\n-    spawn_and_wait(super::abi_cafe::ABI_CAFE.fetch(\"cargo\", dirs));\n     super::tests::RAND_REPO.fetch(dirs);\n-    spawn_and_wait(super::tests::RAND.fetch(\"cargo\", dirs));\n+    spawn_and_wait(super::tests::RAND.fetch(\"cargo\", \"rustc\", dirs));\n     super::tests::REGEX_REPO.fetch(dirs);\n-    spawn_and_wait(super::tests::REGEX.fetch(\"cargo\", dirs));\n+    spawn_and_wait(super::tests::REGEX.fetch(\"cargo\", \"rustc\", dirs));\n     super::tests::PORTABLE_SIMD_REPO.fetch(dirs);\n-    spawn_and_wait(super::tests::PORTABLE_SIMD.fetch(\"cargo\", dirs));\n-    super::bench::SIMPLE_RAYTRACER_REPO.fetch(dirs);\n-    spawn_and_wait(super::bench::SIMPLE_RAYTRACER.fetch(\"cargo\", dirs));\n+    spawn_and_wait(super::tests::PORTABLE_SIMD.fetch(\"cargo\", \"rustc\", dirs));\n }\n \n fn prepare_sysroot(dirs: &Dirs) {\n@@ -80,7 +76,7 @@ impl GitRepo {\n         }\n     }\n \n-    fn fetch(&self, dirs: &Dirs) {\n+    pub(crate) fn fetch(&self, dirs: &Dirs) {\n         match self.url {\n             GitRepoUrl::Github { user, repo } => {\n                 clone_repo_shallow_github("}, {"sha": "e9486888f86a4093bd98bd3d71a79b4c45788a9c", "filename": "compiler/rustc_codegen_cranelift/build_system/tests.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs?ref=8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "patch": "@@ -1,4 +1,3 @@\n-use super::bench::SIMPLE_RAYTRACER;\n use super::build_sysroot::{self, SYSROOT_SRC};\n use super::config;\n use super::path::{Dirs, RelPath};\n@@ -134,10 +133,6 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n             spawn_and_wait(build_cmd);\n         }\n     }),\n-    TestCase::custom(\"test.simple-raytracer\", &|runner| {\n-        SIMPLE_RAYTRACER.clean(&runner.dirs);\n-        spawn_and_wait(SIMPLE_RAYTRACER.build(&runner.target_compiler, &runner.dirs));\n-    }),\n     TestCase::custom(\"test.libcore\", &|runner| {\n         LIBCORE_TESTS.clean(&runner.dirs);\n "}, {"sha": "abc5bab49422468454948ea77f79891c6c5f873c", "filename": "compiler/rustc_codegen_cranelift/build_system/utils.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs?ref=8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "patch": "@@ -121,10 +121,18 @@ impl CargoProject {\n     }\n \n     #[must_use]\n-    pub(crate) fn fetch(&self, cargo: impl AsRef<Path>, dirs: &Dirs) -> Command {\n+    pub(crate) fn fetch(\n+        &self,\n+        cargo: impl AsRef<Path>,\n+        rustc: impl AsRef<Path>,\n+        dirs: &Dirs,\n+    ) -> Command {\n         let mut cmd = Command::new(cargo.as_ref());\n \n-        cmd.arg(\"fetch\").arg(\"--manifest-path\").arg(self.manifest_path(dirs));\n+        cmd.env(\"RUSTC\", rustc.as_ref())\n+            .arg(\"fetch\")\n+            .arg(\"--manifest-path\")\n+            .arg(self.manifest_path(dirs));\n \n         cmd\n     }\n@@ -271,5 +279,9 @@ pub(crate) fn copy_dir_recursively(from: &Path, to: &Path) {\n }\n \n pub(crate) fn is_ci() -> bool {\n-    env::var(\"CI\").as_deref() == Ok(\"true\")\n+    env::var(\"CI\").is_ok()\n+}\n+\n+pub(crate) fn is_ci_opt() -> bool {\n+    env::var(\"CI_OPT\").is_ok()\n }"}, {"sha": "d6e3924a24d643f7550553874b7eb4d47495f577", "filename": "compiler/rustc_codegen_cranelift/config.txt", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fconfig.txt", "raw_url": "https://github.com/rust-lang/rust/raw/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fconfig.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fconfig.txt?ref=8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "patch": "@@ -44,7 +44,6 @@ aot.issue-72793\n \n testsuite.extended_sysroot\n test.rust-random/rand\n-test.simple-raytracer\n test.libcore\n test.regex-shootout-regex-dna\n test.regex"}, {"sha": "40fb54b915992b11257b306c543d6b82bf446872", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2023-01-20\"\n+channel = \"nightly-2023-02-06\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "e14a129dbc2d05f32263b7ff763754e1bba52875", "filename": "compiler/rustc_codegen_cranelift/scripts/test_rustc_tests.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh?ref=8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "patch": "@@ -91,6 +91,7 @@ rm tests/ui/proc-macro/proc-macro-deprecated-attr.rs # same\n rm tests/ui/proc-macro/quote-debug.rs # same\n rm tests/ui/proc-macro/no-missing-docs.rs # same\n rm tests/ui/rust-2018/proc-macro-crate-in-paths.rs # same\n+rm tests/ui/proc-macro/allowed-signatures.rs # same\n \n # doesn't work due to the way the rustc test suite is invoked.\n # should work when using ./x.py test the way it is intended"}, {"sha": "abf63e33c35370ce39bbccb9d0c999217a0ce330", "filename": "compiler/rustc_codegen_cranelift/src/abi/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs?ref=8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "patch": "@@ -98,12 +98,12 @@ pub(super) fn add_local_place_comments<'tcx>(\n         }\n         CPlaceInner::VarPair(place_local, var1, var2) => {\n             assert_eq!(local, place_local);\n-            (\"ssa\", Cow::Owned(format!(\",var=({}, {})\", var1.index(), var2.index())))\n+            (\"ssa\", Cow::Owned(format!(\"var=({}, {})\", var1.index(), var2.index())))\n         }\n         CPlaceInner::VarLane(_local, _var, _lane) => unreachable!(),\n         CPlaceInner::Addr(ptr, meta) => {\n             let meta = if let Some(meta) = meta {\n-                Cow::Owned(format!(\",meta={}\", meta))\n+                Cow::Owned(format!(\"meta={}\", meta))\n             } else {\n                 Cow::Borrowed(\"\")\n             };"}, {"sha": "1c73957ca571c0af73a40ddc6ff7bf17c63ebb37", "filename": "compiler/rustc_codegen_cranelift/src/allocator.rs", "status": "modified", "additions": 14, "deletions": 61, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs?ref=8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "patch": "@@ -70,74 +70,27 @@ fn codegen_inner(\n             params: arg_tys.iter().cloned().map(AbiParam::new).collect(),\n             returns: output.into_iter().map(AbiParam::new).collect(),\n         };\n-\n-        let caller_name = format!(\"__rust_{}\", method.name);\n-        let callee_name = kind.fn_name(method.name);\n-\n-        let func_id = module.declare_function(&caller_name, Linkage::Export, &sig).unwrap();\n-\n-        let callee_func_id = module.declare_function(&callee_name, Linkage::Import, &sig).unwrap();\n-\n-        let mut ctx = Context::new();\n-        ctx.func.signature = sig.clone();\n-        {\n-            let mut func_ctx = FunctionBuilderContext::new();\n-            let mut bcx = FunctionBuilder::new(&mut ctx.func, &mut func_ctx);\n-\n-            let block = bcx.create_block();\n-            bcx.switch_to_block(block);\n-            let args = arg_tys\n-                .into_iter()\n-                .map(|ty| bcx.append_block_param(block, ty))\n-                .collect::<Vec<Value>>();\n-\n-            let callee_func_ref = module.declare_func_in_func(callee_func_id, &mut bcx.func);\n-            let call_inst = bcx.ins().call(callee_func_ref, &args);\n-            let results = bcx.inst_results(call_inst).to_vec(); // Clone to prevent borrow error\n-\n-            bcx.ins().return_(&results);\n-            bcx.seal_all_blocks();\n-            bcx.finalize();\n-        }\n-        module.define_function(func_id, &mut ctx).unwrap();\n-        unwind_context.add_function(func_id, &ctx, module.isa());\n+        crate::common::create_wrapper_function(\n+            module,\n+            unwind_context,\n+            sig,\n+            &format!(\"__rust_{}\", method.name),\n+            &kind.fn_name(method.name),\n+        );\n     }\n \n     let sig = Signature {\n         call_conv: module.target_config().default_call_conv,\n         params: vec![AbiParam::new(usize_ty), AbiParam::new(usize_ty)],\n         returns: vec![],\n     };\n-\n-    let callee_name = alloc_error_handler_kind.fn_name(sym::oom);\n-\n-    let func_id =\n-        module.declare_function(\"__rust_alloc_error_handler\", Linkage::Export, &sig).unwrap();\n-\n-    let callee_func_id = module.declare_function(&callee_name, Linkage::Import, &sig).unwrap();\n-\n-    let mut ctx = Context::new();\n-    ctx.func.signature = sig;\n-    {\n-        let mut func_ctx = FunctionBuilderContext::new();\n-        let mut bcx = FunctionBuilder::new(&mut ctx.func, &mut func_ctx);\n-\n-        let block = bcx.create_block();\n-        bcx.switch_to_block(block);\n-        let args = (&[usize_ty, usize_ty])\n-            .iter()\n-            .map(|&ty| bcx.append_block_param(block, ty))\n-            .collect::<Vec<Value>>();\n-\n-        let callee_func_ref = module.declare_func_in_func(callee_func_id, &mut bcx.func);\n-        bcx.ins().call(callee_func_ref, &args);\n-\n-        bcx.ins().trap(TrapCode::UnreachableCodeReached);\n-        bcx.seal_all_blocks();\n-        bcx.finalize();\n-    }\n-    module.define_function(func_id, &mut ctx).unwrap();\n-    unwind_context.add_function(func_id, &ctx, module.isa());\n+    crate::common::create_wrapper_function(\n+        module,\n+        unwind_context,\n+        sig,\n+        \"__rust_alloc_error_handler\",\n+        &alloc_error_handler_kind.fn_name(sym::oom),\n+    );\n \n     let data_id = module.declare_data(OomStrategy::SYMBOL, Linkage::Export, false, false).unwrap();\n     let mut data_ctx = DataContext::new();"}, {"sha": "189d952a92f177a0101645b448526c97ef1dc6eb", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 58, "deletions": 33, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "patch": "@@ -21,23 +21,6 @@ pub(crate) struct CodegenedFunction {\n     func_debug_cx: Option<FunctionDebugContext>,\n }\n \n-#[cfg_attr(not(feature = \"jit\"), allow(dead_code))]\n-pub(crate) fn codegen_and_compile_fn<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    cx: &mut crate::CodegenCx,\n-    cached_context: &mut Context,\n-    module: &mut dyn Module,\n-    instance: Instance<'tcx>,\n-) {\n-    let _inst_guard =\n-        crate::PrintOnPanic(|| format!(\"{:?} {}\", instance, tcx.symbol_name(instance).name));\n-\n-    let cached_func = std::mem::replace(&mut cached_context.func, Function::new());\n-    let codegened_func = codegen_fn(tcx, cx, cached_func, module, instance);\n-\n-    compile_fn(cx, cached_context, module, codegened_func);\n-}\n-\n pub(crate) fn codegen_fn<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     cx: &mut crate::CodegenCx,\n@@ -47,6 +30,9 @@ pub(crate) fn codegen_fn<'tcx>(\n ) -> CodegenedFunction {\n     debug_assert!(!instance.substs.needs_infer());\n \n+    let symbol_name = tcx.symbol_name(instance).name.to_string();\n+    let _timer = tcx.prof.generic_activity_with_arg(\"codegen fn\", &*symbol_name);\n+\n     let mir = tcx.instance_mir(instance.def);\n     let _mir_guard = crate::PrintOnPanic(|| {\n         let mut buf = Vec::new();\n@@ -58,7 +44,6 @@ pub(crate) fn codegen_fn<'tcx>(\n     });\n \n     // Declare function\n-    let symbol_name = tcx.symbol_name(instance).name.to_string();\n     let sig = get_function_sig(tcx, module.target_config().default_call_conv, instance);\n     let func_id = module.declare_function(&symbol_name, Linkage::Local, &sig).unwrap();\n \n@@ -112,7 +97,7 @@ pub(crate) fn codegen_fn<'tcx>(\n         next_ssa_var: 0,\n     };\n \n-    tcx.sess.time(\"codegen clif ir\", || codegen_fn_body(&mut fx, start_block));\n+    tcx.prof.generic_activity(\"codegen clif ir\").run(|| codegen_fn_body(&mut fx, start_block));\n     fx.bcx.seal_all_blocks();\n     fx.bcx.finalize();\n \n@@ -146,6 +131,9 @@ pub(crate) fn compile_fn(\n     module: &mut dyn Module,\n     codegened_func: CodegenedFunction,\n ) {\n+    let _timer =\n+        cx.profiler.generic_activity_with_arg(\"compile function\", &*codegened_func.symbol_name);\n+\n     let clif_comments = codegened_func.clif_comments;\n \n     // Store function in context\n@@ -191,9 +179,30 @@ pub(crate) fn compile_fn(\n     };\n \n     // Define function\n-    cx.profiler.verbose_generic_activity(\"define function\").run(|| {\n+    cx.profiler.generic_activity(\"define function\").run(|| {\n         context.want_disasm = cx.should_write_ir;\n         module.define_function(codegened_func.func_id, context).unwrap();\n+\n+        if cx.profiler.enabled() {\n+            let mut recording_args = false;\n+            cx.profiler\n+                .generic_activity_with_arg_recorder(\n+                    \"define function (clif pass timings)\",\n+                    |recorder| {\n+                        let pass_times = cranelift_codegen::timing::take_current();\n+                        // Replace newlines with | as measureme doesn't allow control characters like\n+                        // newlines inside strings.\n+                        recorder.record_arg(format!(\"{}\", pass_times).replace(\"\\n\", \" | \"));\n+                        recording_args = true;\n+                    },\n+                )\n+                .run(|| {\n+                    if recording_args {\n+                        // Wait a tiny bit to ensure chrome's profiler doesn't hide the event\n+                        std::thread::sleep(std::time::Duration::from_nanos(2))\n+                    }\n+                });\n+        }\n     });\n \n     if cx.should_write_ir {\n@@ -220,7 +229,7 @@ pub(crate) fn compile_fn(\n     let isa = module.isa();\n     let debug_context = &mut cx.debug_context;\n     let unwind_context = &mut cx.unwind_context;\n-    cx.profiler.verbose_generic_activity(\"generate debug info\").run(|| {\n+    cx.profiler.generic_activity(\"generate debug info\").run(|| {\n         if let Some(debug_context) = debug_context {\n             codegened_func.func_debug_cx.unwrap().finalize(\n                 debug_context,\n@@ -237,7 +246,7 @@ pub(crate) fn verify_func(\n     writer: &crate::pretty_clif::CommentWriter,\n     func: &Function,\n ) {\n-    tcx.sess.time(\"verify clif ir\", || {\n+    tcx.prof.generic_activity(\"verify clif ir\").run(|| {\n         let flags = cranelift_codegen::settings::Flags::new(cranelift_codegen::settings::builder());\n         match cranelift_codegen::verify_function(&func, &flags) {\n             Ok(_) => {}\n@@ -273,7 +282,10 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n         fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n         return;\n     }\n-    fx.tcx.sess.time(\"codegen prelude\", || crate::abi::codegen_fn_prelude(fx, start_block));\n+    fx.tcx\n+        .prof\n+        .generic_activity(\"codegen prelude\")\n+        .run(|| crate::abi::codegen_fn_prelude(fx, start_block));\n \n     for (bb, bb_data) in fx.mir.basic_blocks.iter_enumerated() {\n         let block = fx.get_block(bb);\n@@ -434,7 +446,7 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n                 cleanup: _,\n                 from_hir_call: _,\n             } => {\n-                fx.tcx.sess.time(\"codegen call\", || {\n+                fx.tcx.prof.generic_activity(\"codegen call\").run(|| {\n                     crate::abi::codegen_terminator_call(\n                         fx,\n                         mir::SourceInfo { span: *fn_span, ..source_info },\n@@ -778,17 +790,30 @@ fn codegen_stmt<'tcx>(\n                     let val = CValue::const_val(fx, fx.layout_of(fx.tcx.types.usize), val.into());\n                     lval.write_cvalue(fx, val);\n                 }\n-                Rvalue::Aggregate(ref kind, ref operands) => match kind.as_ref() {\n-                    AggregateKind::Array(_ty) => {\n-                        for (i, operand) in operands.iter().enumerate() {\n-                            let operand = codegen_operand(fx, operand);\n-                            let index = fx.bcx.ins().iconst(fx.pointer_type, i as i64);\n-                            let to = lval.place_index(fx, index);\n-                            to.write_cvalue(fx, operand);\n+                Rvalue::Aggregate(ref kind, ref operands) => {\n+                    let (variant_index, variant_dest, active_field_index) = match **kind {\n+                        mir::AggregateKind::Adt(_, variant_index, _, _, active_field_index) => {\n+                            let variant_dest = lval.downcast_variant(fx, variant_index);\n+                            (variant_index, variant_dest, active_field_index)\n                         }\n+                        _ => (VariantIdx::from_u32(0), lval, None),\n+                    };\n+                    if active_field_index.is_some() {\n+                        assert_eq!(operands.len(), 1);\n+                    }\n+                    for (i, operand) in operands.iter().enumerate() {\n+                        let operand = codegen_operand(fx, operand);\n+                        let field_index = active_field_index.unwrap_or(i);\n+                        let to = if let mir::AggregateKind::Array(_) = **kind {\n+                            let index = fx.bcx.ins().iconst(fx.pointer_type, field_index as i64);\n+                            variant_dest.place_index(fx, index)\n+                        } else {\n+                            variant_dest.place_field(fx, mir::Field::new(field_index))\n+                        };\n+                        to.write_cvalue(fx, operand);\n                     }\n-                    _ => unreachable!(\"shouldn't exist at codegen {:?}\", to_place_and_rval.1),\n-                },\n+                    crate::discriminant::codegen_set_discriminant(fx, lval, variant_index);\n+                }\n             }\n         }\n         StatementKind::StorageLive(_)"}, {"sha": "a8be0d32cc8c7c4d6d2948134bf7e8abf2bcd8a7", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "patch": "@@ -254,6 +254,44 @@ pub(crate) fn type_sign(ty: Ty<'_>) -> bool {\n     }\n }\n \n+pub(crate) fn create_wrapper_function(\n+    module: &mut dyn Module,\n+    unwind_context: &mut UnwindContext,\n+    sig: Signature,\n+    wrapper_name: &str,\n+    callee_name: &str,\n+) {\n+    let wrapper_func_id = module.declare_function(wrapper_name, Linkage::Export, &sig).unwrap();\n+    let callee_func_id = module.declare_function(callee_name, Linkage::Import, &sig).unwrap();\n+\n+    let mut ctx = Context::new();\n+    ctx.func.signature = sig;\n+    {\n+        let mut func_ctx = FunctionBuilderContext::new();\n+        let mut bcx = FunctionBuilder::new(&mut ctx.func, &mut func_ctx);\n+\n+        let block = bcx.create_block();\n+        bcx.switch_to_block(block);\n+        let func = &mut bcx.func.stencil;\n+        let args = func\n+            .signature\n+            .params\n+            .iter()\n+            .map(|param| func.dfg.append_block_param(block, param.value_type))\n+            .collect::<Vec<Value>>();\n+\n+        let callee_func_ref = module.declare_func_in_func(callee_func_id, &mut bcx.func);\n+        let call_inst = bcx.ins().call(callee_func_ref, &args);\n+        let results = bcx.inst_results(call_inst).to_vec(); // Clone to prevent borrow error\n+\n+        bcx.ins().return_(&results);\n+        bcx.seal_all_blocks();\n+        bcx.finalize();\n+    }\n+    module.define_function(wrapper_func_id, &mut ctx).unwrap();\n+    unwind_context.add_function(wrapper_func_id, &ctx, module.isa());\n+}\n+\n pub(crate) struct FunctionCx<'m, 'clif, 'tcx: 'm> {\n     pub(crate) cx: &'clif mut crate::CodegenCx,\n     pub(crate) module: &'m mut dyn Module,"}, {"sha": "8a53baa763a7debeddf78d5769708676bfed9e7c", "filename": "compiler/rustc_codegen_cranelift/src/compiler_builtins.rs", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcompiler_builtins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcompiler_builtins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcompiler_builtins.rs?ref=8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "patch": "@@ -1,14 +1,33 @@\n+#[cfg(all(unix, feature = \"jit\"))]\n+use std::ffi::c_int;\n+#[cfg(feature = \"jit\")]\n+use std::ffi::c_void;\n+\n+// FIXME replace with core::ffi::c_size_t once stablized\n+#[allow(non_camel_case_types)]\n+#[cfg(feature = \"jit\")]\n+type size_t = usize;\n+\n macro_rules! builtin_functions {\n-    ($register:ident; $(fn $name:ident($($arg_name:ident: $arg_ty:ty),*) -> $ret_ty:ty;)*) => {\n+    (\n+        $register:ident;\n+        $(\n+            $(#[$attr:meta])?\n+            fn $name:ident($($arg_name:ident: $arg_ty:ty),*) -> $ret_ty:ty;\n+        )*\n+    ) => {\n         #[cfg(feature = \"jit\")]\n         #[allow(improper_ctypes)]\n         extern \"C\" {\n-            $(fn $name($($arg_name: $arg_ty),*) -> $ret_ty;)*\n+            $(\n+                $(#[$attr])?\n+                fn $name($($arg_name: $arg_ty),*) -> $ret_ty;\n+            )*\n         }\n \n         #[cfg(feature = \"jit\")]\n         pub(crate) fn $register(builder: &mut cranelift_jit::JITBuilder) {\n-            for (name, val) in [$((stringify!($name), $name as *const u8)),*] {\n+            for (name, val) in [$($(#[$attr])? (stringify!($name), $name as *const u8)),*] {\n                 builder.symbol(name, val);\n             }\n         }\n@@ -40,4 +59,17 @@ builtin_functions! {\n     fn __fixdfti(f: f64) -> i128;\n     fn __fixunssfti(f: f32) -> u128;\n     fn __fixunsdfti(f: f64) -> u128;\n+\n+    // allocator\n+    // NOTE: These need to be mentioned here despite not being part of compiler_builtins because\n+    // newer glibc resolve dlsym(\"malloc\") to libc.so despite the override in the rustc binary to\n+    // use jemalloc. Libraries opened with dlopen still get the jemalloc version, causing multiple\n+    // allocators to be mixed, resulting in a crash.\n+    fn calloc(nobj: size_t, size: size_t) -> *mut c_void;\n+    #[cfg(unix)]\n+    fn posix_memalign(memptr: *mut *mut c_void, align: size_t, size: size_t) -> c_int;\n+    fn malloc(size: size_t) -> *mut c_void;\n+    fn realloc(p: *mut c_void, size: size_t) -> *mut c_void;\n+    fn free(p: *mut c_void) -> ();\n+\n }"}, {"sha": "263401e1c4b8343f76a2ad52e8fc90097a58a1c7", "filename": "compiler/rustc_codegen_cranelift/src/config.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconfig.rs?ref=8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "patch": "@@ -42,12 +42,6 @@ pub struct BackendConfig {\n     /// Defaults to the value of `CG_CLIF_JIT_ARGS`.\n     pub jit_args: Vec<String>,\n \n-    /// Display the time it took to perform codegen for a crate.\n-    ///\n-    /// Defaults to true when the `CG_CLIF_DISPLAY_CG_TIME` env var is set to 1 or false otherwise.\n-    /// Can be set using `-Cllvm-args=display_cg_time=...`.\n-    pub display_cg_time: bool,\n-\n     /// Enable the Cranelift ir verifier for all compilation passes. If not set it will only run\n     /// once before passing the clif ir to Cranelift for compilation.\n     ///\n@@ -73,7 +67,6 @@ impl Default for BackendConfig {\n                 let args = std::env::var(\"CG_CLIF_JIT_ARGS\").unwrap_or_else(|_| String::new());\n                 args.split(' ').map(|arg| arg.to_string()).collect()\n             },\n-            display_cg_time: bool_env_var(\"CG_CLIF_DISPLAY_CG_TIME\"),\n             enable_verifier: cfg!(debug_assertions) || bool_env_var(\"CG_CLIF_ENABLE_VERIFIER\"),\n             disable_incr_cache: bool_env_var(\"CG_CLIF_DISABLE_INCR_CACHE\"),\n         }\n@@ -92,7 +85,6 @@ impl BackendConfig {\n             if let Some((name, value)) = opt.split_once('=') {\n                 match name {\n                     \"mode\" => config.codegen_mode = value.parse()?,\n-                    \"display_cg_time\" => config.display_cg_time = parse_bool(name, value)?,\n                     \"enable_verifier\" => config.enable_verifier = parse_bool(name, value)?,\n                     \"disable_incr_cache\" => config.disable_incr_cache = parse_bool(name, value)?,\n                     _ => return Err(format!(\"Unknown option `{}`\", name)),"}, {"sha": "58b01dfb5b0ec84b25600137467fbe733ca1fe51", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 72, "deletions": 58, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "patch": "@@ -272,25 +272,25 @@ fn module_codegen(\n         ConcurrencyLimiterToken,\n     ),\n ) -> OngoingModuleCodegen {\n-    let (cgu_name, mut cx, mut module, codegened_functions) = tcx.sess.time(\"codegen cgu\", || {\n-        let cgu = tcx.codegen_unit(cgu_name);\n-        let mono_items = cgu.items_in_deterministic_order(tcx);\n-\n-        let mut module = make_module(tcx.sess, &backend_config, cgu_name.as_str().to_string());\n-\n-        let mut cx = crate::CodegenCx::new(\n-            tcx,\n-            backend_config.clone(),\n-            module.isa(),\n-            tcx.sess.opts.debuginfo != DebugInfo::None,\n-            cgu_name,\n-        );\n-        super::predefine_mono_items(tcx, &mut module, &mono_items);\n-        let mut codegened_functions = vec![];\n-        for (mono_item, _) in mono_items {\n-            match mono_item {\n-                MonoItem::Fn(inst) => {\n-                    tcx.sess.time(\"codegen fn\", || {\n+    let (cgu_name, mut cx, mut module, codegened_functions) =\n+        tcx.prof.verbose_generic_activity_with_arg(\"codegen cgu\", cgu_name.as_str()).run(|| {\n+            let cgu = tcx.codegen_unit(cgu_name);\n+            let mono_items = cgu.items_in_deterministic_order(tcx);\n+\n+            let mut module = make_module(tcx.sess, &backend_config, cgu_name.as_str().to_string());\n+\n+            let mut cx = crate::CodegenCx::new(\n+                tcx,\n+                backend_config.clone(),\n+                module.isa(),\n+                tcx.sess.opts.debuginfo != DebugInfo::None,\n+                cgu_name,\n+            );\n+            super::predefine_mono_items(tcx, &mut module, &mono_items);\n+            let mut codegened_functions = vec![];\n+            for (mono_item, _) in mono_items {\n+                match mono_item {\n+                    MonoItem::Fn(inst) => {\n                         let codegened_function = crate::base::codegen_fn(\n                             tcx,\n                             &mut cx,\n@@ -299,53 +299,68 @@ fn module_codegen(\n                             inst,\n                         );\n                         codegened_functions.push(codegened_function);\n-                    });\n-                }\n-                MonoItem::Static(def_id) => {\n-                    crate::constant::codegen_static(tcx, &mut module, def_id)\n-                }\n-                MonoItem::GlobalAsm(item_id) => {\n-                    crate::global_asm::codegen_global_asm_item(tcx, &mut cx.global_asm, item_id);\n+                    }\n+                    MonoItem::Static(def_id) => {\n+                        crate::constant::codegen_static(tcx, &mut module, def_id)\n+                    }\n+                    MonoItem::GlobalAsm(item_id) => {\n+                        crate::global_asm::codegen_global_asm_item(\n+                            tcx,\n+                            &mut cx.global_asm,\n+                            item_id,\n+                        );\n+                    }\n                 }\n             }\n-        }\n-        crate::main_shim::maybe_create_entry_wrapper(\n-            tcx,\n-            &mut module,\n-            &mut cx.unwind_context,\n-            false,\n-            cgu.is_primary(),\n-        );\n+            crate::main_shim::maybe_create_entry_wrapper(\n+                tcx,\n+                &mut module,\n+                &mut cx.unwind_context,\n+                false,\n+                cgu.is_primary(),\n+            );\n \n-        let cgu_name = cgu.name().as_str().to_owned();\n+            let cgu_name = cgu.name().as_str().to_owned();\n \n-        (cgu_name, cx, module, codegened_functions)\n-    });\n+            (cgu_name, cx, module, codegened_functions)\n+        });\n \n     OngoingModuleCodegen::Async(std::thread::spawn(move || {\n-        cx.profiler.clone().verbose_generic_activity(\"compile functions\").run(|| {\n-            let mut cached_context = Context::new();\n-            for codegened_func in codegened_functions {\n-                crate::base::compile_fn(&mut cx, &mut cached_context, &mut module, codegened_func);\n-            }\n-        });\n+        cx.profiler.clone().verbose_generic_activity_with_arg(\"compile functions\", &*cgu_name).run(\n+            || {\n+                let mut cached_context = Context::new();\n+                for codegened_func in codegened_functions {\n+                    crate::base::compile_fn(\n+                        &mut cx,\n+                        &mut cached_context,\n+                        &mut module,\n+                        codegened_func,\n+                    );\n+                }\n+            },\n+        );\n \n-        let global_asm_object_file =\n-            cx.profiler.verbose_generic_activity(\"compile assembly\").run(|| {\n+        let global_asm_object_file = cx\n+            .profiler\n+            .verbose_generic_activity_with_arg(\"compile assembly\", &*cgu_name)\n+            .run(|| {\n                 crate::global_asm::compile_global_asm(&global_asm_config, &cgu_name, &cx.global_asm)\n             })?;\n \n-        let codegen_result = cx.profiler.verbose_generic_activity(\"write object file\").run(|| {\n-            emit_cgu(\n-                &global_asm_config.output_filenames,\n-                &cx.profiler,\n-                cgu_name,\n-                module,\n-                cx.debug_context,\n-                cx.unwind_context,\n-                global_asm_object_file,\n-            )\n-        });\n+        let codegen_result = cx\n+            .profiler\n+            .verbose_generic_activity_with_arg(\"write object file\", &*cgu_name)\n+            .run(|| {\n+                emit_cgu(\n+                    &global_asm_config.output_filenames,\n+                    &cx.profiler,\n+                    cgu_name,\n+                    module,\n+                    cx.debug_context,\n+                    cx.unwind_context,\n+                    global_asm_object_file,\n+                )\n+            });\n         std::mem::drop(token);\n         codegen_result\n     }))\n@@ -375,7 +390,7 @@ pub(crate) fn run_aot(\n \n     let mut concurrency_limiter = ConcurrencyLimiter::new(tcx.sess, cgus.len());\n \n-    let modules = super::time(tcx, backend_config.display_cg_time, \"codegen mono items\", || {\n+    let modules = tcx.sess.time(\"codegen mono items\", || {\n         cgus.iter()\n             .map(|cgu| {\n                 let cgu_reuse = if backend_config.disable_incr_cache {\n@@ -437,7 +452,6 @@ pub(crate) fn run_aot(\n     };\n \n     let metadata_module = if need_metadata_module {\n-        let _timer = tcx.prof.generic_activity(\"codegen crate metadata\");\n         let (metadata_cgu_name, tmp_file) = tcx.sess.time(\"write compressed metadata\", || {\n             use rustc_middle::mir::mono::CodegenUnitNameBuilder;\n "}, {"sha": "8b5a2da2c5944d631de0499f1905029de5c4b3c8", "filename": "compiler/rustc_codegen_cranelift/src/driver/jit.rs", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs?ref=8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "patch": "@@ -121,22 +121,20 @@ pub(crate) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n         .into_iter()\n         .collect::<Vec<(_, (_, _))>>();\n \n-    super::time(tcx, backend_config.display_cg_time, \"codegen mono items\", || {\n+    tcx.sess.time(\"codegen mono items\", || {\n         super::predefine_mono_items(tcx, &mut jit_module, &mono_items);\n         for (mono_item, _) in mono_items {\n             match mono_item {\n                 MonoItem::Fn(inst) => match backend_config.codegen_mode {\n                     CodegenMode::Aot => unreachable!(),\n                     CodegenMode::Jit => {\n-                        tcx.sess.time(\"codegen fn\", || {\n-                            crate::base::codegen_and_compile_fn(\n-                                tcx,\n-                                &mut cx,\n-                                &mut cached_context,\n-                                &mut jit_module,\n-                                inst,\n-                            )\n-                        });\n+                        codegen_and_compile_fn(\n+                            tcx,\n+                            &mut cx,\n+                            &mut cached_context,\n+                            &mut jit_module,\n+                            inst,\n+                        );\n                     }\n                     CodegenMode::JitLazy => {\n                         codegen_shim(tcx, &mut cx, &mut cached_context, &mut jit_module, inst)\n@@ -219,6 +217,24 @@ pub(crate) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n     }\n }\n \n+pub(crate) fn codegen_and_compile_fn<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    cx: &mut crate::CodegenCx,\n+    cached_context: &mut Context,\n+    module: &mut dyn Module,\n+    instance: Instance<'tcx>,\n+) {\n+    tcx.prof.generic_activity(\"codegen and compile fn\").run(|| {\n+        let _inst_guard =\n+            crate::PrintOnPanic(|| format!(\"{:?} {}\", instance, tcx.symbol_name(instance).name));\n+\n+        let cached_func = std::mem::replace(&mut cached_context.func, Function::new());\n+        let codegened_func = crate::base::codegen_fn(tcx, cx, cached_func, module, instance);\n+\n+        crate::base::compile_fn(cx, cached_context, module, codegened_func);\n+    });\n+}\n+\n extern \"C\" fn clif_jit_fn(\n     instance_ptr: *const Instance<'static>,\n     trampoline_ptr: *const u8,\n@@ -271,15 +287,7 @@ fn jit_fn(instance_ptr: *const Instance<'static>, trampoline_ptr: *const u8) ->\n                 false,\n                 Symbol::intern(\"dummy_cgu_name\"),\n             );\n-            tcx.sess.time(\"codegen fn\", || {\n-                crate::base::codegen_and_compile_fn(\n-                    tcx,\n-                    &mut cx,\n-                    &mut Context::new(),\n-                    jit_module,\n-                    instance,\n-                )\n-            });\n+            codegen_and_compile_fn(tcx, &mut cx, &mut Context::new(), jit_module, instance);\n \n             assert!(cx.global_asm.is_empty());\n             jit_module.finalize_definitions().unwrap();"}, {"sha": "d09d3a529759cab809e2e8d637b23999fcf57d23", "filename": "compiler/rustc_codegen_cranelift/src/driver/mod.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs?ref=8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "patch": "@@ -17,7 +17,7 @@ fn predefine_mono_items<'tcx>(\n     module: &mut dyn Module,\n     mono_items: &[(MonoItem<'tcx>, (RLinkage, Visibility))],\n ) {\n-    tcx.sess.time(\"predefine functions\", || {\n+    tcx.prof.generic_activity(\"predefine functions\").run(|| {\n         let is_compiler_builtins = tcx.is_compiler_builtins(LOCAL_CRATE);\n         for &(mono_item, (linkage, visibility)) in mono_items {\n             match mono_item {\n@@ -39,16 +39,3 @@ fn predefine_mono_items<'tcx>(\n         }\n     });\n }\n-\n-fn time<R>(tcx: TyCtxt<'_>, display: bool, name: &'static str, f: impl FnOnce() -> R) -> R {\n-    if display {\n-        println!(\"[{:<30}: {}] start\", tcx.crate_name(LOCAL_CRATE), name);\n-        let before = std::time::Instant::now();\n-        let res = tcx.sess.time(name, f);\n-        let after = std::time::Instant::now();\n-        println!(\"[{:<30}: {}] end time: {:?}\", tcx.crate_name(LOCAL_CRATE), name, after - before);\n-        res\n-    } else {\n-        tcx.sess.time(name, f)\n-    }\n-}"}, {"sha": "46c78ce6a1e344d251c62256d4db238f62154351", "filename": "compiler/rustc_codegen_cranelift/src/global_asm.rs", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fglobal_asm.rs?ref=8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "patch": "@@ -7,7 +7,7 @@ use std::process::{Command, Stdio};\n use std::sync::Arc;\n \n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n-use rustc_hir::ItemId;\n+use rustc_hir::{InlineAsmOperand, ItemId};\n use rustc_session::config::{OutputFilenames, OutputType};\n \n use crate::prelude::*;\n@@ -23,7 +23,46 @@ pub(crate) fn codegen_global_asm_item(tcx: TyCtxt<'_>, global_asm: &mut String,\n         for piece in asm.template {\n             match *piece {\n                 InlineAsmTemplatePiece::String(ref s) => global_asm.push_str(s),\n-                InlineAsmTemplatePiece::Placeholder { .. } => todo!(),\n+                InlineAsmTemplatePiece::Placeholder { operand_idx, modifier: _, span: op_sp } => {\n+                    match asm.operands[operand_idx].0 {\n+                        InlineAsmOperand::Const { ref anon_const } => {\n+                            let const_value =\n+                                tcx.const_eval_poly(anon_const.def_id.to_def_id()).unwrap_or_else(\n+                                    |_| span_bug!(op_sp, \"asm const cannot be resolved\"),\n+                                );\n+                            let ty = tcx.typeck_body(anon_const.body).node_type(anon_const.hir_id);\n+                            let string = rustc_codegen_ssa::common::asm_const_to_str(\n+                                tcx,\n+                                op_sp,\n+                                const_value,\n+                                RevealAllLayoutCx(tcx).layout_of(ty),\n+                            );\n+                            global_asm.push_str(&string);\n+                        }\n+                        InlineAsmOperand::SymFn { anon_const } => {\n+                            let ty = tcx.typeck_body(anon_const.body).node_type(anon_const.hir_id);\n+                            let instance = match ty.kind() {\n+                                &ty::FnDef(def_id, substs) => Instance::new(def_id, substs),\n+                                _ => span_bug!(op_sp, \"asm sym is not a function\"),\n+                            };\n+                            let symbol = tcx.symbol_name(instance);\n+                            // FIXME handle the case where the function was made private to the\n+                            // current codegen unit\n+                            global_asm.push_str(symbol.name);\n+                        }\n+                        InlineAsmOperand::SymStatic { path: _, def_id } => {\n+                            let instance = Instance::mono(tcx, def_id).polymorphize(tcx);\n+                            let symbol = tcx.symbol_name(instance);\n+                            global_asm.push_str(symbol.name);\n+                        }\n+                        InlineAsmOperand::In { .. }\n+                        | InlineAsmOperand::Out { .. }\n+                        | InlineAsmOperand::InOut { .. }\n+                        | InlineAsmOperand::SplitInOut { .. } => {\n+                            span_bug!(op_sp, \"invalid operand type for global_asm!\")\n+                        }\n+                    }\n+                }\n             }\n         }\n         global_asm.push_str(\"\\n.att_syntax\\n\\n\");"}, {"sha": "6206fbf7dd571505c5954fff7cb55e6ee560870c", "filename": "compiler/rustc_codegen_cranelift/src/inline_asm.rs", "status": "modified", "additions": 143, "deletions": 46, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs?ref=8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "patch": "@@ -9,9 +9,33 @@ use rustc_middle::mir::InlineAsmOperand;\n use rustc_span::sym;\n use rustc_target::asm::*;\n \n+enum CInlineAsmOperand<'tcx> {\n+    In {\n+        reg: InlineAsmRegOrRegClass,\n+        value: CValue<'tcx>,\n+    },\n+    Out {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        place: Option<CPlace<'tcx>>,\n+    },\n+    InOut {\n+        reg: InlineAsmRegOrRegClass,\n+        _late: bool,\n+        in_value: CValue<'tcx>,\n+        out_place: Option<CPlace<'tcx>>,\n+    },\n+    Const {\n+        value: String,\n+    },\n+    Symbol {\n+        symbol: String,\n+    },\n+}\n+\n pub(crate) fn codegen_inline_asm<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    _span: Span,\n+    span: Span,\n     template: &[InlineAsmTemplatePiece],\n     operands: &[InlineAsmOperand<'tcx>],\n     options: InlineAsmOptions,\n@@ -198,6 +222,81 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n         }\n     }\n \n+    let operands = operands\n+        .into_iter()\n+        .map(|operand| match *operand {\n+            InlineAsmOperand::In { reg, ref value } => {\n+                CInlineAsmOperand::In { reg, value: crate::base::codegen_operand(fx, value) }\n+            }\n+            InlineAsmOperand::Out { reg, late, ref place } => CInlineAsmOperand::Out {\n+                reg,\n+                late,\n+                place: place.map(|place| crate::base::codegen_place(fx, place)),\n+            },\n+            InlineAsmOperand::InOut { reg, late, ref in_value, ref out_place } => {\n+                CInlineAsmOperand::InOut {\n+                    reg,\n+                    _late: late,\n+                    in_value: crate::base::codegen_operand(fx, in_value),\n+                    out_place: out_place.map(|place| crate::base::codegen_place(fx, place)),\n+                }\n+            }\n+            InlineAsmOperand::Const { ref value } => {\n+                let (const_value, ty) = crate::constant::eval_mir_constant(fx, &*value)\n+                    .unwrap_or_else(|| span_bug!(span, \"asm const cannot be resolved\"));\n+                let value = rustc_codegen_ssa::common::asm_const_to_str(\n+                    fx.tcx,\n+                    span,\n+                    const_value,\n+                    fx.layout_of(ty),\n+                );\n+                CInlineAsmOperand::Const { value }\n+            }\n+            InlineAsmOperand::SymFn { ref value } => {\n+                let literal = fx.monomorphize(value.literal);\n+                if let ty::FnDef(def_id, substs) = *literal.ty().kind() {\n+                    let instance = ty::Instance::resolve_for_fn_ptr(\n+                        fx.tcx,\n+                        ty::ParamEnv::reveal_all(),\n+                        def_id,\n+                        substs,\n+                    )\n+                    .unwrap();\n+                    let symbol = fx.tcx.symbol_name(instance);\n+\n+                    // Pass a wrapper rather than the function itself as the function itself may not\n+                    // be exported from the main codegen unit and may thus be unreachable from the\n+                    // object file created by an external assembler.\n+                    let inline_asm_index = fx.cx.inline_asm_index.get();\n+                    fx.cx.inline_asm_index.set(inline_asm_index + 1);\n+                    let wrapper_name = format!(\n+                        \"__inline_asm_{}_wrapper_n{}\",\n+                        fx.cx.cgu_name.as_str().replace('.', \"__\").replace('-', \"_\"),\n+                        inline_asm_index\n+                    );\n+                    let sig =\n+                        get_function_sig(fx.tcx, fx.target_config.default_call_conv, instance);\n+                    create_wrapper_function(\n+                        fx.module,\n+                        &mut fx.cx.unwind_context,\n+                        sig,\n+                        &wrapper_name,\n+                        symbol.name,\n+                    );\n+\n+                    CInlineAsmOperand::Symbol { symbol: wrapper_name }\n+                } else {\n+                    span_bug!(span, \"invalid type for asm sym (fn)\");\n+                }\n+            }\n+            InlineAsmOperand::SymStatic { def_id } => {\n+                assert!(fx.tcx.is_static(def_id));\n+                let instance = Instance::mono(fx.tcx, def_id).polymorphize(fx.tcx);\n+                CInlineAsmOperand::Symbol { symbol: fx.tcx.symbol_name(instance).name.to_owned() }\n+            }\n+        })\n+        .collect::<Vec<_>>();\n+\n     let mut inputs = Vec::new();\n     let mut outputs = Vec::new();\n \n@@ -206,7 +305,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n         arch: fx.tcx.sess.asm_arch.unwrap(),\n         enclosing_def_id: fx.instance.def_id(),\n         template,\n-        operands,\n+        operands: &operands,\n         options,\n         registers: Vec::new(),\n         stack_slots_clobber: Vec::new(),\n@@ -229,36 +328,22 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n     fx.cx.global_asm.push_str(&generated_asm);\n \n     for (i, operand) in operands.iter().enumerate() {\n-        match *operand {\n-            InlineAsmOperand::In { reg: _, ref value } => {\n-                inputs.push((\n-                    asm_gen.stack_slots_input[i].unwrap(),\n-                    crate::base::codegen_operand(fx, value).load_scalar(fx),\n-                ));\n-            }\n-            InlineAsmOperand::Out { reg: _, late: _, place } => {\n+        match operand {\n+            CInlineAsmOperand::In { reg: _, value } => {\n+                inputs.push((asm_gen.stack_slots_input[i].unwrap(), value.load_scalar(fx)));\n+            }\n+            CInlineAsmOperand::Out { reg: _, late: _, place } => {\n                 if let Some(place) = place {\n-                    outputs.push((\n-                        asm_gen.stack_slots_output[i].unwrap(),\n-                        crate::base::codegen_place(fx, place),\n-                    ));\n+                    outputs.push((asm_gen.stack_slots_output[i].unwrap(), place.clone()));\n                 }\n             }\n-            InlineAsmOperand::InOut { reg: _, late: _, ref in_value, out_place } => {\n-                inputs.push((\n-                    asm_gen.stack_slots_input[i].unwrap(),\n-                    crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n-                ));\n+            CInlineAsmOperand::InOut { reg: _, _late: _, in_value, out_place } => {\n+                inputs.push((asm_gen.stack_slots_input[i].unwrap(), in_value.load_scalar(fx)));\n                 if let Some(out_place) = out_place {\n-                    outputs.push((\n-                        asm_gen.stack_slots_output[i].unwrap(),\n-                        crate::base::codegen_place(fx, out_place),\n-                    ));\n+                    outputs.push((asm_gen.stack_slots_output[i].unwrap(), out_place.clone()));\n                 }\n             }\n-            InlineAsmOperand::Const { value: _ } => todo!(),\n-            InlineAsmOperand::SymFn { value: _ } => todo!(),\n-            InlineAsmOperand::SymStatic { def_id: _ } => todo!(),\n+            CInlineAsmOperand::Const { value: _ } | CInlineAsmOperand::Symbol { symbol: _ } => {}\n         }\n     }\n \n@@ -280,7 +365,7 @@ struct InlineAssemblyGenerator<'a, 'tcx> {\n     arch: InlineAsmArch,\n     enclosing_def_id: DefId,\n     template: &'a [InlineAsmTemplatePiece],\n-    operands: &'a [InlineAsmOperand<'tcx>],\n+    operands: &'a [CInlineAsmOperand<'tcx>],\n     options: InlineAsmOptions,\n     registers: Vec<Option<InlineAsmReg>>,\n     stack_slots_clobber: Vec<Option<Size>>,\n@@ -304,18 +389,20 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         // Add explicit registers to the allocated set.\n         for (i, operand) in self.operands.iter().enumerate() {\n             match *operand {\n-                InlineAsmOperand::In { reg: InlineAsmRegOrRegClass::Reg(reg), .. } => {\n+                CInlineAsmOperand::In { reg: InlineAsmRegOrRegClass::Reg(reg), .. } => {\n                     regs[i] = Some(reg);\n                     allocated.entry(reg).or_default().0 = true;\n                 }\n-                InlineAsmOperand::Out {\n-                    reg: InlineAsmRegOrRegClass::Reg(reg), late: true, ..\n+                CInlineAsmOperand::Out {\n+                    reg: InlineAsmRegOrRegClass::Reg(reg),\n+                    late: true,\n+                    ..\n                 } => {\n                     regs[i] = Some(reg);\n                     allocated.entry(reg).or_default().1 = true;\n                 }\n-                InlineAsmOperand::Out { reg: InlineAsmRegOrRegClass::Reg(reg), .. }\n-                | InlineAsmOperand::InOut { reg: InlineAsmRegOrRegClass::Reg(reg), .. } => {\n+                CInlineAsmOperand::Out { reg: InlineAsmRegOrRegClass::Reg(reg), .. }\n+                | CInlineAsmOperand::InOut { reg: InlineAsmRegOrRegClass::Reg(reg), .. } => {\n                     regs[i] = Some(reg);\n                     allocated.insert(reg, (true, true));\n                 }\n@@ -326,12 +413,12 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         // Allocate out/inout/inlateout registers first because they are more constrained.\n         for (i, operand) in self.operands.iter().enumerate() {\n             match *operand {\n-                InlineAsmOperand::Out {\n+                CInlineAsmOperand::Out {\n                     reg: InlineAsmRegOrRegClass::RegClass(class),\n                     late: false,\n                     ..\n                 }\n-                | InlineAsmOperand::InOut {\n+                | CInlineAsmOperand::InOut {\n                     reg: InlineAsmRegOrRegClass::RegClass(class), ..\n                 } => {\n                     let mut alloc_reg = None;\n@@ -360,7 +447,7 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         // Allocate in/lateout.\n         for (i, operand) in self.operands.iter().enumerate() {\n             match *operand {\n-                InlineAsmOperand::In { reg: InlineAsmRegOrRegClass::RegClass(class), .. } => {\n+                CInlineAsmOperand::In { reg: InlineAsmRegOrRegClass::RegClass(class), .. } => {\n                     let mut alloc_reg = None;\n                     for &reg in &map[&class] {\n                         let mut used = false;\n@@ -380,7 +467,7 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n                     regs[i] = Some(reg);\n                     allocated.entry(reg).or_default().0 = true;\n                 }\n-                InlineAsmOperand::Out {\n+                CInlineAsmOperand::Out {\n                     reg: InlineAsmRegOrRegClass::RegClass(class),\n                     late: true,\n                     ..\n@@ -455,7 +542,7 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         // Allocate stack slots for inout\n         for (i, operand) in self.operands.iter().enumerate() {\n             match *operand {\n-                InlineAsmOperand::InOut { reg, out_place: Some(_), .. } => {\n+                CInlineAsmOperand::InOut { reg, out_place: Some(_), .. } => {\n                     let slot = new_slot(reg.reg_class());\n                     slots_input[i] = Some(slot);\n                     slots_output[i] = Some(slot);\n@@ -470,8 +557,8 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         // Allocate stack slots for input\n         for (i, operand) in self.operands.iter().enumerate() {\n             match *operand {\n-                InlineAsmOperand::In { reg, .. }\n-                | InlineAsmOperand::InOut { reg, out_place: None, .. } => {\n+                CInlineAsmOperand::In { reg, .. }\n+                | CInlineAsmOperand::InOut { reg, out_place: None, .. } => {\n                     slots_input[i] = Some(new_slot(reg.reg_class()));\n                 }\n                 _ => (),\n@@ -487,7 +574,7 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         // Allocate stack slots for output\n         for (i, operand) in self.operands.iter().enumerate() {\n             match *operand {\n-                InlineAsmOperand::Out { reg, place: Some(_), .. } => {\n+                CInlineAsmOperand::Out { reg, place: Some(_), .. } => {\n                     slots_output[i] = Some(new_slot(reg.reg_class()));\n                 }\n                 _ => (),\n@@ -549,13 +636,23 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n                     generated_asm.push_str(s);\n                 }\n                 InlineAsmTemplatePiece::Placeholder { operand_idx, modifier, span: _ } => {\n-                    if self.options.contains(InlineAsmOptions::ATT_SYNTAX) {\n-                        generated_asm.push('%');\n+                    match self.operands[*operand_idx] {\n+                        CInlineAsmOperand::In { .. }\n+                        | CInlineAsmOperand::Out { .. }\n+                        | CInlineAsmOperand::InOut { .. } => {\n+                            if self.options.contains(InlineAsmOptions::ATT_SYNTAX) {\n+                                generated_asm.push('%');\n+                            }\n+                            self.registers[*operand_idx]\n+                                .unwrap()\n+                                .emit(&mut generated_asm, self.arch, *modifier)\n+                                .unwrap();\n+                        }\n+                        CInlineAsmOperand::Const { ref value } => {\n+                            generated_asm.push_str(value);\n+                        }\n+                        CInlineAsmOperand::Symbol { ref symbol } => generated_asm.push_str(symbol),\n                     }\n-                    self.registers[*operand_idx]\n-                        .unwrap()\n-                        .emit(&mut generated_asm, self.arch, *modifier)\n-                        .unwrap();\n                 }\n             }\n         }"}, {"sha": "892e7c30e2f7a425d6cebde69198ed26bb766800", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "patch": "@@ -218,34 +218,18 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n     let intrinsic = fx.tcx.item_name(instance.def_id());\n     let substs = instance.substs;\n \n-    let target = if let Some(target) = target {\n-        target\n-    } else {\n-        // Insert non returning intrinsics here\n-        match intrinsic {\n-            sym::abort => {\n-                fx.bcx.ins().trap(TrapCode::User(0));\n-            }\n-            sym::transmute => {\n-                crate::base::codegen_panic(fx, \"Transmuting to uninhabited type.\", source_info);\n-            }\n-            _ => unimplemented!(\"unsupported intrinsic {}\", intrinsic),\n-        }\n-        return;\n-    };\n-\n     if intrinsic.as_str().starts_with(\"simd_\") {\n         self::simd::codegen_simd_intrinsic_call(\n             fx,\n             intrinsic,\n             substs,\n             args,\n             destination,\n-            target,\n+            target.expect(\"target for simd intrinsic\"),\n             source_info.span,\n         );\n     } else if codegen_float_intrinsic_call(fx, intrinsic, args, destination) {\n-        let ret_block = fx.get_block(target);\n+        let ret_block = fx.get_block(target.expect(\"target for float intrinsic\"));\n         fx.bcx.ins().jump(ret_block, &[]);\n     } else {\n         codegen_regular_intrinsic_call(\n@@ -255,7 +239,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             substs,\n             args,\n             destination,\n-            Some(target),\n+            target,\n             source_info,\n         );\n     }\n@@ -382,6 +366,10 @@ fn codegen_regular_intrinsic_call<'tcx>(\n     let usize_layout = fx.layout_of(fx.tcx.types.usize);\n \n     match intrinsic {\n+        sym::abort => {\n+            fx.bcx.ins().trap(TrapCode::User(0));\n+            return;\n+        }\n         sym::likely | sym::unlikely => {\n             intrinsic_args!(fx, args => (a); intrinsic);\n \n@@ -579,6 +567,11 @@ fn codegen_regular_intrinsic_call<'tcx>(\n         sym::transmute => {\n             intrinsic_args!(fx, args => (from); intrinsic);\n \n+            if ret.layout().abi.is_uninhabited() {\n+                crate::base::codegen_panic(fx, \"Transmuting to uninhabited type.\", source_info);\n+                return;\n+            }\n+\n             ret.write_cvalue_transmute(fx, from);\n         }\n         sym::write_bytes | sym::volatile_set_memory => {"}, {"sha": "320eecaee008e4da9fa98f8e9d0aab428b1f95b8", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cca42a47f5d574c8f7302c98c3f918cdc772fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=8cca42a47f5d574c8f7302c98c3f918cdc772fbb", "patch": "@@ -588,10 +588,13 @@ impl<'tcx> CPlace<'tcx> {\n                 return;\n             }\n             CPlaceInner::VarPair(_local, var1, var2) => {\n-                let (ptr, meta) = from.force_stack(fx);\n-                assert!(meta.is_none());\n-                let (data1, data2) =\n-                    CValue(CValueInner::ByRef(ptr, None), dst_layout).load_scalar_pair(fx);\n+                let (data1, data2) = if from.layout().ty == dst_layout.ty {\n+                    CValue(from.0, dst_layout).load_scalar_pair(fx)\n+                } else {\n+                    let (ptr, meta) = from.force_stack(fx);\n+                    assert!(meta.is_none());\n+                    CValue(CValueInner::ByRef(ptr, None), dst_layout).load_scalar_pair(fx)\n+                };\n                 let (dst_ty1, dst_ty2) = fx.clif_pair_type(self.layout().ty).unwrap();\n                 transmute_value(fx, var1, data1, dst_ty1);\n                 transmute_value(fx, var2, data2, dst_ty2);"}]}