{"sha": "b93cdbce36b1a42c77b5f3f721d7d64dec80f8f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5M2NkYmNlMzZiMWE0MmM3N2I1ZjNmNzIxZDdkNjRkZWM4MGY4ZjM=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-10-23T19:10:08Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-10-26T06:23:24Z"}, "message": "Remove `QualifResolver` abstraction\n\nThis is a relic from earlier attempts at dataflow-based const validation\nthat attempted to do promotion at the same time. #63812 takes a\ndifferent approach: `IsNotPromotable` is no longer a `Qualif` and is\ncomputed lazily instead of eagerly. As a result, there's no need for an\neager `TempPromotionResolver`, and we can use the only implementer of\n`QualifResolver` directly instead of through a trait.", "tree": {"sha": "f7258c9a1dc976a7c722228b6a50ec20391e4cf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7258c9a1dc976a7c722228b6a50ec20391e4cf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b93cdbce36b1a42c77b5f3f721d7d64dec80f8f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b93cdbce36b1a42c77b5f3f721d7d64dec80f8f3", "html_url": "https://github.com/rust-lang/rust/commit/b93cdbce36b1a42c77b5f3f721d7d64dec80f8f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b93cdbce36b1a42c77b5f3f721d7d64dec80f8f3/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "653865658d8ac4001d712fb26f382a84ed36f951", "url": "https://api.github.com/repos/rust-lang/rust/commits/653865658d8ac4001d712fb26f382a84ed36f951", "html_url": "https://github.com/rust-lang/rust/commit/653865658d8ac4001d712fb26f382a84ed36f951"}], "stats": {"total": 318, "additions": 112, "deletions": 206}, "files": [{"sha": "8909ef7db683d17f2682a5a01acb480ccd3227bd", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 9, "deletions": 144, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/b93cdbce36b1a42c77b5f3f721d7d64dec80f8f3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b93cdbce36b1a42c77b5f3f721d7d64dec80f8f3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=b93cdbce36b1a42c77b5f3f721d7d64dec80f8f3", "patch": "@@ -1,21 +1,18 @@\n //! Propagate `Qualif`s between locals and query the results.\n //!\n-//! This also contains the dataflow analysis used to track `Qualif`s on complex control-flow\n-//! graphs.\n+//! This contains the dataflow analysis used to track `Qualif`s on complex control-flow graphs.\n \n use rustc::mir::visit::Visitor;\n use rustc::mir::{self, BasicBlock, Local, Location};\n use rustc_index::bit_set::BitSet;\n \n-use std::cell::RefCell;\n use std::marker::PhantomData;\n \n use crate::dataflow::{self as old_dataflow, generic as dataflow};\n use super::{Item, Qualif};\n-use self::old_dataflow::IndirectlyMutableLocals;\n \n /// A `Visitor` that propagates qualifs between locals. This defines the transfer function of\n-/// `FlowSensitiveAnalysis` as well as the logic underlying `TempPromotionResolver`.\n+/// `FlowSensitiveAnalysis`.\n ///\n /// This transfer does nothing when encountering an indirect assignment. Consumers should rely on\n /// the `IndirectlyMutableLocals` dataflow pass to see if a `Local` may have become qualified via\n@@ -147,145 +144,6 @@ where\n     }\n }\n \n-/// Types that can compute the qualifs of each local at each location in a `mir::Body`.\n-///\n-/// Code that wishes to use a `QualifResolver` must call `visit_{statement,terminator}` for each\n-/// statement or terminator, processing blocks in reverse post-order beginning from the\n-/// `START_BLOCK`. Calling code may optionally call `get` after visiting each statement or\n-/// terminator to query the qualification state immediately before that statement or terminator.\n-///\n-/// These conditions are much more restrictive than woud be required by `FlowSensitiveResolver`\n-/// alone. This is to allow a linear, on-demand `TempPromotionResolver` that can operate\n-/// efficiently on simple CFGs.\n-pub trait QualifResolver<Q> {\n-    /// Get the qualifs of each local at the last location visited.\n-    ///\n-    /// This takes `&mut self` so qualifs can be computed lazily.\n-    fn get(&mut self) -> &BitSet<Local>;\n-\n-    /// A convenience method for `self.get().contains(local)`.\n-    fn contains(&mut self, local: Local) -> bool {\n-        self.get().contains(local)\n-    }\n-\n-    /// Resets the resolver to the `START_BLOCK`. This allows a resolver to be reused\n-    /// for multiple passes over a `mir::Body`.\n-    fn reset(&mut self);\n-}\n-\n-pub type IndirectlyMutableResults<'mir, 'tcx> =\n-    old_dataflow::DataflowResultsCursor<'mir, 'tcx, IndirectlyMutableLocals<'mir, 'tcx>>;\n-\n-/// A resolver for qualifs that works on arbitrarily complex CFGs.\n-///\n-/// As soon as a `Local` becomes writable through a reference (as determined by the\n-/// `IndirectlyMutableLocals` dataflow pass), we must assume that it takes on all other qualifs\n-/// possible for its type. This is because no effort is made to track qualifs across indirect\n-/// assignments (e.g. `*p = x` or calls to opaque functions).\n-///\n-/// It is possible to be more precise here by waiting until an indirect assignment actually occurs\n-/// before marking a borrowed `Local` as qualified.\n-pub struct FlowSensitiveResolver<'a, 'mir, 'tcx, Q>\n-where\n-    Q: Qualif,\n-{\n-    location: Location,\n-    indirectly_mutable_locals: &'a RefCell<IndirectlyMutableResults<'mir, 'tcx>>,\n-    cursor: dataflow::ResultsCursor<'mir, 'tcx, FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q>>,\n-    qualifs_per_local: BitSet<Local>,\n-\n-    /// The value of `Q::in_any_value_of_ty` for each local.\n-    qualifs_in_any_value_of_ty: BitSet<Local>,\n-}\n-\n-impl<Q> FlowSensitiveResolver<'a, 'mir, 'tcx, Q>\n-where\n-    Q: Qualif,\n-{\n-    pub fn new(\n-        _: Q,\n-        item: &'a Item<'mir, 'tcx>,\n-        indirectly_mutable_locals: &'a RefCell<IndirectlyMutableResults<'mir, 'tcx>>,\n-        dead_unwinds: &BitSet<BasicBlock>,\n-    ) -> Self {\n-        let analysis = FlowSensitiveAnalysis {\n-            item,\n-            _qualif: PhantomData,\n-        };\n-        let results =\n-            dataflow::Engine::new(item.tcx, item.body, item.def_id, dead_unwinds, analysis)\n-                .iterate_to_fixpoint();\n-        let cursor = dataflow::ResultsCursor::new(item.body, results);\n-\n-        let mut qualifs_in_any_value_of_ty = BitSet::new_empty(item.body.local_decls.len());\n-        for (local, decl) in item.body.local_decls.iter_enumerated() {\n-            if Q::in_any_value_of_ty(item, decl.ty) {\n-                qualifs_in_any_value_of_ty.insert(local);\n-            }\n-        }\n-\n-        FlowSensitiveResolver {\n-            cursor,\n-            indirectly_mutable_locals,\n-            qualifs_per_local: BitSet::new_empty(item.body.local_decls.len()),\n-            qualifs_in_any_value_of_ty,\n-            location: Location { block: mir::START_BLOCK, statement_index: 0 },\n-        }\n-    }\n-}\n-\n-impl<Q> Visitor<'tcx> for FlowSensitiveResolver<'_, '_, 'tcx, Q>\n-where\n-    Q: Qualif\n-{\n-    fn visit_statement(&mut self, _: &mir::Statement<'tcx>, location: Location) {\n-        self.location = location;\n-    }\n-\n-    fn visit_terminator(&mut self, _: &mir::Terminator<'tcx>, location: Location) {\n-        self.location = location;\n-    }\n-}\n-\n-impl<Q> QualifResolver<Q> for FlowSensitiveResolver<'_, '_, '_, Q>\n-where\n-    Q: Qualif\n-{\n-    fn get(&mut self) -> &BitSet<Local> {\n-        let mut indirectly_mutable_locals = self.indirectly_mutable_locals.borrow_mut();\n-\n-        indirectly_mutable_locals.seek(self.location);\n-        self.cursor.seek_before(self.location);\n-\n-        self.qualifs_per_local.overwrite(indirectly_mutable_locals.get());\n-        self.qualifs_per_local.union(self.cursor.get());\n-        self.qualifs_per_local.intersect(&self.qualifs_in_any_value_of_ty);\n-        &self.qualifs_per_local\n-    }\n-\n-    fn contains(&mut self, local: Local) -> bool {\n-        // No need to update the cursor if we know that `Local` cannot possibly be qualified.\n-        if !self.qualifs_in_any_value_of_ty.contains(local) {\n-            return false;\n-        }\n-\n-        // Otherwise, return `true` if this local is qualified or was indirectly mutable at any\n-        // point before this statement.\n-        self.cursor.seek_before(self.location);\n-        if self.cursor.get().contains(local) {\n-            return true;\n-        }\n-\n-        let mut indirectly_mutable_locals = self.indirectly_mutable_locals.borrow_mut();\n-        indirectly_mutable_locals.seek(self.location);\n-        indirectly_mutable_locals.get().contains(local)\n-    }\n-\n-    fn reset(&mut self)  {\n-        self.location = Location { block: mir::START_BLOCK, statement_index: 0 };\n-    }\n-}\n-\n /// The dataflow analysis used to propagate qualifs on arbitrary CFGs.\n pub(super) struct FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q> {\n     item: &'a Item<'mir, 'tcx>,\n@@ -296,6 +154,13 @@ impl<'a, 'mir, 'tcx, Q> FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q>\n where\n     Q: Qualif,\n {\n+    pub(super) fn new(_: Q, item: &'a Item<'mir, 'tcx>) -> Self {\n+        FlowSensitiveAnalysis {\n+            item,\n+            _qualif: PhantomData,\n+        }\n+    }\n+\n     fn transfer_function(\n         &self,\n         state: &'a mut BitSet<Local>,"}, {"sha": "244d434a51eabc8c96c2a37e697b831a698dfab4", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 102, "deletions": 60, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/b93cdbce36b1a42c77b5f3f721d7d64dec80f8f3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b93cdbce36b1a42c77b5f3f721d7d64dec80f8f3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=b93cdbce36b1a42c77b5f3f721d7d64dec80f8f3", "patch": "@@ -9,15 +9,15 @@ use rustc_target::spec::abi::Abi;\n use syntax::symbol::sym;\n use syntax_pos::Span;\n \n-use std::cell::RefCell;\n use std::fmt;\n use std::ops::Deref;\n \n-use crate::dataflow as old_dataflow;\n-use super::{ConstKind, Item, Qualif, is_lang_panic_fn};\n-use super::resolver::{FlowSensitiveResolver, IndirectlyMutableResults, QualifResolver};\n-use super::qualifs::{HasMutInterior, NeedsDrop};\n+use crate::dataflow::{self as old_dataflow, generic as dataflow};\n+use self::old_dataflow::IndirectlyMutableLocals;\n use super::ops::{self, NonConstOp};\n+use super::qualifs::{HasMutInterior, NeedsDrop};\n+use super::resolver::FlowSensitiveAnalysis;\n+use super::{ConstKind, Item, Qualif, is_lang_panic_fn};\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum CheckOpResult {\n@@ -26,9 +26,75 @@ pub enum CheckOpResult {\n     Allowed,\n }\n \n+pub type IndirectlyMutableResults<'mir, 'tcx> =\n+    old_dataflow::DataflowResultsCursor<'mir, 'tcx, IndirectlyMutableLocals<'mir, 'tcx>>;\n+\n+struct QualifCursor<'a, 'mir, 'tcx, Q: Qualif> {\n+    cursor: dataflow::ResultsCursor<'mir, 'tcx, FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q>>,\n+    in_any_value_of_ty: BitSet<Local>,\n+}\n+\n+impl<Q: Qualif> QualifCursor<'a, 'mir, 'tcx, Q> {\n+    pub fn new(\n+        q: Q,\n+        item: &'a Item<'mir, 'tcx>,\n+        dead_unwinds: &BitSet<BasicBlock>,\n+    ) -> Self {\n+        let analysis = FlowSensitiveAnalysis::new(q, item);\n+        let results =\n+            dataflow::Engine::new(item.tcx, item.body, item.def_id, dead_unwinds, analysis)\n+                .iterate_to_fixpoint();\n+        let cursor = dataflow::ResultsCursor::new(item.body, results);\n+\n+        let mut in_any_value_of_ty = BitSet::new_empty(item.body.local_decls.len());\n+        for (local, decl) in item.body.local_decls.iter_enumerated() {\n+            if Q::in_any_value_of_ty(item, decl.ty) {\n+                in_any_value_of_ty.insert(local);\n+            }\n+        }\n+\n+        QualifCursor {\n+            cursor,\n+            in_any_value_of_ty,\n+        }\n+    }\n+}\n+\n pub struct Qualifs<'a, 'mir, 'tcx> {\n-    has_mut_interior: FlowSensitiveResolver<'a, 'mir, 'tcx, HasMutInterior>,\n-    needs_drop: FlowSensitiveResolver<'a, 'mir, 'tcx, NeedsDrop>,\n+    has_mut_interior: QualifCursor<'a, 'mir, 'tcx, HasMutInterior>,\n+    needs_drop: QualifCursor<'a, 'mir, 'tcx, NeedsDrop>,\n+    indirectly_mutable: IndirectlyMutableResults<'mir, 'tcx>,\n+}\n+\n+impl Qualifs<'a, 'mir, 'tcx> {\n+    fn indirectly_mutable(&mut self, local: Local, location: Location) -> bool {\n+        self.indirectly_mutable.seek(location);\n+        self.indirectly_mutable.get().contains(local)\n+    }\n+\n+    /// Returns `true` if `local` is `NeedsDrop` at the given `Location`.\n+    ///\n+    /// Only updates the cursor if absolutely necessary\n+    fn needs_drop_lazy_seek(&mut self, local: Local, location: Location) -> bool {\n+        if !self.needs_drop.in_any_value_of_ty.contains(local) {\n+            return false;\n+        }\n+\n+        self.needs_drop.cursor.seek_before(location);\n+        self.needs_drop.cursor.get().contains(local)\n+            || self.indirectly_mutable(local, location)\n+    }\n+\n+    /// Returns `true` if `local` is `HasMutInterior`, but requires the `has_mut_interior` and\n+    /// `indirectly_mutable` cursors to be updated beforehand.\n+    fn has_mut_interior_eager_seek(&self, local: Local) -> bool {\n+        if !self.has_mut_interior.in_any_value_of_ty.contains(local) {\n+            return false;\n+        }\n+\n+        self.has_mut_interior.cursor.get().contains(local)\n+            || self.indirectly_mutable.get().contains(local)\n+    }\n }\n \n pub struct Validator<'a, 'mir, 'tcx> {\n@@ -63,53 +129,43 @@ impl Deref for Validator<'_, 'mir, 'tcx> {\n     }\n }\n \n-pub fn compute_indirectly_mutable_locals<'mir, 'tcx>(\n-    item: &Item<'mir, 'tcx>,\n-) -> RefCell<IndirectlyMutableResults<'mir, 'tcx>> {\n-    let dead_unwinds = BitSet::new_empty(item.body.basic_blocks().len());\n-\n-    let indirectly_mutable_locals = old_dataflow::do_dataflow(\n-        item.tcx,\n-        item.body,\n-        item.def_id,\n-        &item.tcx.get_attrs(item.def_id),\n-        &dead_unwinds,\n-        old_dataflow::IndirectlyMutableLocals::new(item.tcx, item.body, item.param_env),\n-        |_, local| old_dataflow::DebugFormatted::new(&local),\n-    );\n-\n-    let indirectly_mutable_locals = old_dataflow::DataflowResultsCursor::new(\n-        indirectly_mutable_locals,\n-        item.body,\n-    );\n-\n-    RefCell::new(indirectly_mutable_locals)\n-}\n-\n impl Validator<'a, 'mir, 'tcx> {\n     pub fn new(\n         item: &'a Item<'mir, 'tcx>,\n-        indirectly_mutable_locals: &'a RefCell<IndirectlyMutableResults<'mir, 'tcx>>,\n     ) -> Self {\n         let dead_unwinds = BitSet::new_empty(item.body.basic_blocks().len());\n \n-        let needs_drop = FlowSensitiveResolver::new(\n+        let needs_drop = QualifCursor::new(\n             NeedsDrop,\n             item,\n-            indirectly_mutable_locals,\n             &dead_unwinds,\n         );\n \n-        let has_mut_interior = FlowSensitiveResolver::new(\n+        let has_mut_interior = QualifCursor::new(\n             HasMutInterior,\n             item,\n-            indirectly_mutable_locals,\n             &dead_unwinds,\n         );\n \n+        let indirectly_mutable = old_dataflow::do_dataflow(\n+            item.tcx,\n+            item.body,\n+            item.def_id,\n+            &item.tcx.get_attrs(item.def_id),\n+            &dead_unwinds,\n+            old_dataflow::IndirectlyMutableLocals::new(item.tcx, item.body, item.param_env),\n+            |_, local| old_dataflow::DebugFormatted::new(&local),\n+        );\n+\n+        let indirectly_mutable = old_dataflow::DataflowResultsCursor::new(\n+            indirectly_mutable,\n+            item.body,\n+        );\n+\n         let qualifs = Qualifs {\n             needs_drop,\n             has_mut_interior,\n+            indirectly_mutable,\n         };\n \n         Validator {\n@@ -122,14 +178,6 @@ impl Validator<'a, 'mir, 'tcx> {\n         }\n     }\n \n-    /// Resets the `QualifResolver`s used by this `Validator` and returns them so they can be\n-    /// reused.\n-    pub fn into_qualifs(mut self) -> Qualifs<'a, 'mir, 'tcx> {\n-        self.qualifs.needs_drop.reset();\n-        self.qualifs.has_mut_interior.reset();\n-        self.qualifs\n-    }\n-\n     pub fn take_errors(&mut self) -> Vec<(Span, String)> {\n         std::mem::replace(&mut self.errors, vec![])\n     }\n@@ -304,10 +352,16 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n         // it depends on `HasMutInterior` being set for mutable borrows as well as values with\n         // interior mutability.\n         if let Rvalue::Ref(_, kind, ref borrowed_place) = *rvalue {\n-            let rvalue_has_mut_interior = {\n-                let has_mut_interior = self.qualifs.has_mut_interior.get();\n-                HasMutInterior::in_rvalue(&self.item, &|l| has_mut_interior.contains(l), rvalue)\n-            };\n+            // FIXME: Change the `in_*` methods to take a `FnMut` so we don't have to manually seek\n+            // the cursors beforehand.\n+            self.qualifs.has_mut_interior.cursor.seek_before(location);\n+            self.qualifs.indirectly_mutable.seek(location);\n+\n+            let rvalue_has_mut_interior = HasMutInterior::in_rvalue(\n+                &self.item,\n+                &|local| self.qualifs.has_mut_interior_eager_seek(local),\n+                rvalue,\n+            );\n \n             if rvalue_has_mut_interior {\n                 let is_derived_from_illegal_borrow = match borrowed_place.as_local() {\n@@ -402,9 +456,6 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n     fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n         trace!(\"visit_statement: statement={:?} location={:?}\", statement, location);\n \n-        self.qualifs.needs_drop.visit_statement(statement, location);\n-        self.qualifs.has_mut_interior.visit_statement(statement, location);\n-\n         match statement.kind {\n             StatementKind::Assign(..) => {\n                 self.super_statement(statement, location);\n@@ -424,15 +475,6 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n         }\n     }\n \n-    fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n-        trace!(\"visit_terminator: terminator={:?} location={:?}\", terminator, location);\n-\n-        self.qualifs.needs_drop.visit_terminator(terminator, location);\n-        self.qualifs.has_mut_interior.visit_terminator(terminator, location);\n-\n-        self.super_terminator(terminator, location);\n-    }\n-\n     fn visit_terminator_kind(&mut self, kind: &TerminatorKind<'tcx>, location: Location) {\n         trace!(\"visit_terminator_kind: kind={:?} location={:?}\", kind, location);\n         self.super_terminator_kind(kind, location);\n@@ -511,7 +553,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 let needs_drop = if let Some(local) = dropped_place.as_local() {\n                     // Use the span where the local was declared as the span of the drop error.\n                     err_span = self.body.local_decls[local].source_info.span;\n-                    self.qualifs.needs_drop.contains(local)\n+                    self.qualifs.needs_drop_lazy_seek(local, location)\n                 } else {\n                     true\n                 };"}, {"sha": "2f77cd5ddf71634aa427c40f238da5f6dc5eaf7f", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b93cdbce36b1a42c77b5f3f721d7d64dec80f8f3/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b93cdbce36b1a42c77b5f3f721d7d64dec80f8f3/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=b93cdbce36b1a42c77b5f3f721d7d64dec80f8f3", "patch": "@@ -968,8 +968,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         }\n \n         let item = new_checker::Item::new(self.tcx, self.def_id, self.body);\n-        let mut_borrowed_locals = new_checker::validation::compute_indirectly_mutable_locals(&item);\n-        let mut validator = new_checker::validation::Validator::new(&item, &mut_borrowed_locals);\n+        let mut validator = new_checker::validation::Validator::new(&item);\n \n         validator.suppress_errors = !use_new_validator;\n         self.suppress_errors = use_new_validator;"}]}