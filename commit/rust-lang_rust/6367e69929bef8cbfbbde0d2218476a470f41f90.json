{"sha": "6367e69929bef8cbfbbde0d2218476a470f41f90", "node_id": "C_kwDOAAsO6NoAKDYzNjdlNjk5MjliZWY4Y2JmYmJkZTBkMjIxODQ3NmE0NzBmNDFmOTA", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-09-29T09:31:46Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-09-29T09:31:46Z"}, "message": "Split collect.rs", "tree": {"sha": "25fa3aff9997e01884502245f3a27b1f6213d837", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25fa3aff9997e01884502245f3a27b1f6213d837"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6367e69929bef8cbfbbde0d2218476a470f41f90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6367e69929bef8cbfbbde0d2218476a470f41f90", "html_url": "https://github.com/rust-lang/rust/commit/6367e69929bef8cbfbbde0d2218476a470f41f90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6367e69929bef8cbfbbde0d2218476a470f41f90/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1536a53ea4798df052dc31a611c2f29c8f529be7", "url": "https://api.github.com/repos/rust-lang/rust/commits/1536a53ea4798df052dc31a611c2f29c8f529be7", "html_url": "https://github.com/rust-lang/rust/commit/1536a53ea4798df052dc31a611c2f29c8f529be7"}], "stats": {"total": 2382, "additions": 1204, "deletions": 1178}, "files": [{"sha": "8cd0a84274ec5507c37e6be95190828457bda060", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 16, "deletions": 1178, "changes": 1194, "blob_url": "https://github.com/rust-lang/rust/blob/6367e69929bef8cbfbbde0d2218476a470f41f90/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6367e69929bef8cbfbbde0d2218476a470f41f90/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=6367e69929bef8cbfbbde0d2218476a470f41f90", "patch": "@@ -15,46 +15,40 @@\n //! crate as a kind of pass. This should eventually be factored away.\n \n use crate::astconv::AstConv;\n-use crate::bounds::Bounds;\n use crate::check::intrinsic::intrinsic_operation_unsafety;\n-use crate::constrained_generic_params as cgp;\n use crate::errors;\n-use crate::middle::resolve_lifetime as rl;\n use rustc_ast as ast;\n use rustc_ast::{MetaItemKind, NestedMetaItem};\n use rustc_attr::{list_contains_name, InlineAttr, InstructionSetAttr, OptimizeAttr};\n use rustc_data_structures::captures::Captures;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, StashKey};\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorKind, DefKind};\n+use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::{DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::weak_lang_items;\n-use rustc_hir::{GenericParamKind, HirId, Node};\n+use rustc_hir::{GenericParamKind, Node};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::mono::Linkage;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::subst::InternalSubsts;\n-use rustc_middle::ty::util::Discr;\n-use rustc_middle::ty::util::IntTypeExt;\n+use rustc_middle::ty::util::{Discr, IntTypeExt};\n+use rustc_middle::ty::ReprOptions;\n use rustc_middle::ty::{self, AdtKind, Const, DefIdTree, IsSuggestable, Ty, TyCtxt};\n-use rustc_middle::ty::{ReprOptions, ToPredicate};\n use rustc_session::lint;\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::Span;\n use rustc_target::spec::{abi, SanitizerSet};\n use rustc_trait_selection::traits::error_reporting::suggestions::NextTypeParamName;\n use std::iter;\n \n+mod generics_of;\n mod item_bounds;\n+mod predicates_of;\n mod type_of;\n \n-#[derive(Debug)]\n-struct OnlySelfBounds(bool);\n-\n ///////////////////////////////////////////////////////////////////////////\n // Main entry point\n \n@@ -68,14 +62,15 @@ pub fn provide(providers: &mut Providers) {\n         type_of: type_of::type_of,\n         item_bounds: item_bounds::item_bounds,\n         explicit_item_bounds: item_bounds::explicit_item_bounds,\n-        generics_of,\n-        predicates_of,\n+        generics_of: generics_of::generics_of,\n+        predicates_of: predicates_of::predicates_of,\n         predicates_defined_on,\n-        explicit_predicates_of,\n-        super_predicates_of,\n-        super_predicates_that_define_assoc_type,\n-        trait_explicit_predicates_and_bounds,\n-        type_param_predicates,\n+        explicit_predicates_of: predicates_of::explicit_predicates_of,\n+        super_predicates_of: predicates_of::super_predicates_of,\n+        super_predicates_that_define_assoc_type:\n+            predicates_of::super_predicates_that_define_assoc_type,\n+        trait_explicit_predicates_and_bounds: predicates_of::trait_explicit_predicates_and_bounds,\n+        type_param_predicates: predicates_of::type_param_predicates,\n         trait_def,\n         adt_def,\n         fn_sig,\n@@ -572,160 +567,6 @@ fn get_new_lifetime_name<'tcx>(\n     (1..).flat_map(a_to_z_repeat_n).find(|lt| !existing_lifetimes.contains(lt.as_str())).unwrap()\n }\n \n-/// Returns the predicates defined on `item_def_id` of the form\n-/// `X: Foo` where `X` is the type parameter `def_id`.\n-#[instrument(level = \"trace\", skip(tcx))]\n-fn type_param_predicates(\n-    tcx: TyCtxt<'_>,\n-    (item_def_id, def_id, assoc_name): (DefId, LocalDefId, Ident),\n-) -> ty::GenericPredicates<'_> {\n-    use rustc_hir::*;\n-\n-    // In the AST, bounds can derive from two places. Either\n-    // written inline like `<T: Foo>` or in a where-clause like\n-    // `where T: Foo`.\n-\n-    let param_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-    let param_owner = tcx.hir().ty_param_owner(def_id);\n-    let generics = tcx.generics_of(param_owner);\n-    let index = generics.param_def_id_to_index[&def_id.to_def_id()];\n-    let ty = tcx.mk_ty_param(index, tcx.hir().ty_param_name(def_id));\n-\n-    // Don't look for bounds where the type parameter isn't in scope.\n-    let parent = if item_def_id == param_owner.to_def_id() {\n-        None\n-    } else {\n-        tcx.generics_of(item_def_id).parent\n-    };\n-\n-    let mut result = parent\n-        .map(|parent| {\n-            let icx = ItemCtxt::new(tcx, parent);\n-            icx.get_type_parameter_bounds(DUMMY_SP, def_id.to_def_id(), assoc_name)\n-        })\n-        .unwrap_or_default();\n-    let mut extend = None;\n-\n-    let item_hir_id = tcx.hir().local_def_id_to_hir_id(item_def_id.expect_local());\n-    let ast_generics = match tcx.hir().get(item_hir_id) {\n-        Node::TraitItem(item) => &item.generics,\n-\n-        Node::ImplItem(item) => &item.generics,\n-\n-        Node::Item(item) => {\n-            match item.kind {\n-                ItemKind::Fn(.., ref generics, _)\n-                | ItemKind::Impl(hir::Impl { ref generics, .. })\n-                | ItemKind::TyAlias(_, ref generics)\n-                | ItemKind::OpaqueTy(OpaqueTy {\n-                    ref generics,\n-                    origin: hir::OpaqueTyOrigin::TyAlias,\n-                    ..\n-                })\n-                | ItemKind::Enum(_, ref generics)\n-                | ItemKind::Struct(_, ref generics)\n-                | ItemKind::Union(_, ref generics) => generics,\n-                ItemKind::Trait(_, _, ref generics, ..) => {\n-                    // Implied `Self: Trait` and supertrait bounds.\n-                    if param_id == item_hir_id {\n-                        let identity_trait_ref = ty::TraitRef::identity(tcx, item_def_id);\n-                        extend =\n-                            Some((identity_trait_ref.without_const().to_predicate(tcx), item.span));\n-                    }\n-                    generics\n-                }\n-                _ => return result,\n-            }\n-        }\n-\n-        Node::ForeignItem(item) => match item.kind {\n-            ForeignItemKind::Fn(_, _, ref generics) => generics,\n-            _ => return result,\n-        },\n-\n-        _ => return result,\n-    };\n-\n-    let icx = ItemCtxt::new(tcx, item_def_id);\n-    let extra_predicates = extend.into_iter().chain(\n-        icx.type_parameter_bounds_in_generics(\n-            ast_generics,\n-            param_id,\n-            ty,\n-            OnlySelfBounds(true),\n-            Some(assoc_name),\n-        )\n-        .into_iter()\n-        .filter(|(predicate, _)| match predicate.kind().skip_binder() {\n-            ty::PredicateKind::Trait(data) => data.self_ty().is_param(index),\n-            _ => false,\n-        }),\n-    );\n-    result.predicates =\n-        tcx.arena.alloc_from_iter(result.predicates.iter().copied().chain(extra_predicates));\n-    result\n-}\n-\n-impl<'tcx> ItemCtxt<'tcx> {\n-    /// Finds bounds from `hir::Generics`. This requires scanning through the\n-    /// AST. We do this to avoid having to convert *all* the bounds, which\n-    /// would create artificial cycles. Instead, we can only convert the\n-    /// bounds for a type parameter `X` if `X::Foo` is used.\n-    #[instrument(level = \"trace\", skip(self, ast_generics))]\n-    fn type_parameter_bounds_in_generics(\n-        &self,\n-        ast_generics: &'tcx hir::Generics<'tcx>,\n-        param_id: hir::HirId,\n-        ty: Ty<'tcx>,\n-        only_self_bounds: OnlySelfBounds,\n-        assoc_name: Option<Ident>,\n-    ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n-        let param_def_id = self.tcx.hir().local_def_id(param_id).to_def_id();\n-        trace!(?param_def_id);\n-        ast_generics\n-            .predicates\n-            .iter()\n-            .filter_map(|wp| match *wp {\n-                hir::WherePredicate::BoundPredicate(ref bp) => Some(bp),\n-                _ => None,\n-            })\n-            .flat_map(|bp| {\n-                let bt = if bp.is_param_bound(param_def_id) {\n-                    Some(ty)\n-                } else if !only_self_bounds.0 {\n-                    Some(self.to_ty(bp.bounded_ty))\n-                } else {\n-                    None\n-                };\n-                let bvars = self.tcx.late_bound_vars(bp.hir_id);\n-\n-                bp.bounds.iter().filter_map(move |b| bt.map(|bt| (bt, b, bvars))).filter(\n-                    |(_, b, _)| match assoc_name {\n-                        Some(assoc_name) => self.bound_defines_assoc_item(b, assoc_name),\n-                        None => true,\n-                    },\n-                )\n-            })\n-            .flat_map(|(bt, b, bvars)| predicates_from_bound(self, bt, b, bvars))\n-            .collect()\n-    }\n-\n-    #[instrument(level = \"trace\", skip(self))]\n-    fn bound_defines_assoc_item(&self, b: &hir::GenericBound<'_>, assoc_name: Ident) -> bool {\n-        match b {\n-            hir::GenericBound::Trait(poly_trait_ref, _) => {\n-                let trait_ref = &poly_trait_ref.trait_ref;\n-                if let Some(trait_did) = trait_ref.trait_def_id() {\n-                    self.tcx.trait_may_define_assoc_type(trait_did, assoc_name)\n-                } else {\n-                    false\n-                }\n-            }\n-            _ => false,\n-        }\n-    }\n-}\n-\n fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n     let it = tcx.hir().item(item_id);\n     debug!(\"convert: item {} with id {}\", it.ident, it.hir_id());\n@@ -1097,96 +938,6 @@ fn adt_def<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> ty::AdtDef<'tcx> {\n     tcx.alloc_adt_def(def_id.to_def_id(), kind, variants, repr)\n }\n \n-/// Ensures that the super-predicates of the trait with a `DefId`\n-/// of `trait_def_id` are converted and stored. This also ensures that\n-/// the transitive super-predicates are converted.\n-fn super_predicates_of(tcx: TyCtxt<'_>, trait_def_id: DefId) -> ty::GenericPredicates<'_> {\n-    debug!(\"super_predicates(trait_def_id={:?})\", trait_def_id);\n-    tcx.super_predicates_that_define_assoc_type((trait_def_id, None))\n-}\n-\n-/// Ensures that the super-predicates of the trait with a `DefId`\n-/// of `trait_def_id` are converted and stored. This also ensures that\n-/// the transitive super-predicates are converted.\n-fn super_predicates_that_define_assoc_type(\n-    tcx: TyCtxt<'_>,\n-    (trait_def_id, assoc_name): (DefId, Option<Ident>),\n-) -> ty::GenericPredicates<'_> {\n-    debug!(\n-        \"super_predicates_that_define_assoc_type(trait_def_id={:?}, assoc_name={:?})\",\n-        trait_def_id, assoc_name\n-    );\n-    if trait_def_id.is_local() {\n-        debug!(\"super_predicates_that_define_assoc_type: local trait_def_id={:?}\", trait_def_id);\n-        let trait_hir_id = tcx.hir().local_def_id_to_hir_id(trait_def_id.expect_local());\n-\n-        let Node::Item(item) = tcx.hir().get(trait_hir_id) else {\n-            bug!(\"trait_node_id {} is not an item\", trait_hir_id);\n-        };\n-\n-        let (generics, bounds) = match item.kind {\n-            hir::ItemKind::Trait(.., ref generics, ref supertraits, _) => (generics, supertraits),\n-            hir::ItemKind::TraitAlias(ref generics, ref supertraits) => (generics, supertraits),\n-            _ => span_bug!(item.span, \"super_predicates invoked on non-trait\"),\n-        };\n-\n-        let icx = ItemCtxt::new(tcx, trait_def_id);\n-\n-        // Convert the bounds that follow the colon, e.g., `Bar + Zed` in `trait Foo: Bar + Zed`.\n-        let self_param_ty = tcx.types.self_param;\n-        let superbounds1 = if let Some(assoc_name) = assoc_name {\n-            <dyn AstConv<'_>>::compute_bounds_that_match_assoc_type(\n-                &icx,\n-                self_param_ty,\n-                bounds,\n-                assoc_name,\n-            )\n-        } else {\n-            <dyn AstConv<'_>>::compute_bounds(&icx, self_param_ty, bounds)\n-        };\n-\n-        let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n-\n-        // Convert any explicit superbounds in the where-clause,\n-        // e.g., `trait Foo where Self: Bar`.\n-        // In the case of trait aliases, however, we include all bounds in the where-clause,\n-        // so e.g., `trait Foo = where u32: PartialEq<Self>` would include `u32: PartialEq<Self>`\n-        // as one of its \"superpredicates\".\n-        let is_trait_alias = tcx.is_trait_alias(trait_def_id);\n-        let superbounds2 = icx.type_parameter_bounds_in_generics(\n-            generics,\n-            item.hir_id(),\n-            self_param_ty,\n-            OnlySelfBounds(!is_trait_alias),\n-            assoc_name,\n-        );\n-\n-        // Combine the two lists to form the complete set of superbounds:\n-        let superbounds = &*tcx.arena.alloc_from_iter(superbounds1.into_iter().chain(superbounds2));\n-        debug!(?superbounds);\n-\n-        // Now require that immediate supertraits are converted,\n-        // which will, in turn, reach indirect supertraits.\n-        if assoc_name.is_none() {\n-            // Now require that immediate supertraits are converted,\n-            // which will, in turn, reach indirect supertraits.\n-            for &(pred, span) in superbounds {\n-                debug!(\"superbound: {:?}\", pred);\n-                if let ty::PredicateKind::Trait(bound) = pred.kind().skip_binder() {\n-                    tcx.at(span).super_predicates_of(bound.def_id());\n-                }\n-            }\n-        }\n-\n-        ty::GenericPredicates { parent: None, predicates: superbounds }\n-    } else {\n-        // if `assoc_name` is None, then the query should've been redirected to an\n-        // external provider\n-        assert!(assoc_name.is_some());\n-        tcx.super_predicates_of(trait_def_id)\n-    }\n-}\n-\n fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {\n     let item = tcx.hir().expect_item(def_id.expect_local());\n \n@@ -1328,475 +1079,6 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {\n     )\n }\n \n-fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<Span> {\n-    struct LateBoundRegionsDetector<'tcx> {\n-        tcx: TyCtxt<'tcx>,\n-        outer_index: ty::DebruijnIndex,\n-        has_late_bound_regions: Option<Span>,\n-    }\n-\n-    impl<'tcx> Visitor<'tcx> for LateBoundRegionsDetector<'tcx> {\n-        fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n-            if self.has_late_bound_regions.is_some() {\n-                return;\n-            }\n-            match ty.kind {\n-                hir::TyKind::BareFn(..) => {\n-                    self.outer_index.shift_in(1);\n-                    intravisit::walk_ty(self, ty);\n-                    self.outer_index.shift_out(1);\n-                }\n-                _ => intravisit::walk_ty(self, ty),\n-            }\n-        }\n-\n-        fn visit_poly_trait_ref(&mut self, tr: &'tcx hir::PolyTraitRef<'tcx>) {\n-            if self.has_late_bound_regions.is_some() {\n-                return;\n-            }\n-            self.outer_index.shift_in(1);\n-            intravisit::walk_poly_trait_ref(self, tr);\n-            self.outer_index.shift_out(1);\n-        }\n-\n-        fn visit_lifetime(&mut self, lt: &'tcx hir::Lifetime) {\n-            if self.has_late_bound_regions.is_some() {\n-                return;\n-            }\n-\n-            match self.tcx.named_region(lt.hir_id) {\n-                Some(rl::Region::Static | rl::Region::EarlyBound(..)) => {}\n-                Some(rl::Region::LateBound(debruijn, _, _)) if debruijn < self.outer_index => {}\n-                Some(rl::Region::LateBound(..) | rl::Region::Free(..)) | None => {\n-                    self.has_late_bound_regions = Some(lt.span);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn has_late_bound_regions<'tcx>(\n-        tcx: TyCtxt<'tcx>,\n-        generics: &'tcx hir::Generics<'tcx>,\n-        decl: &'tcx hir::FnDecl<'tcx>,\n-    ) -> Option<Span> {\n-        let mut visitor = LateBoundRegionsDetector {\n-            tcx,\n-            outer_index: ty::INNERMOST,\n-            has_late_bound_regions: None,\n-        };\n-        for param in generics.params {\n-            if let GenericParamKind::Lifetime { .. } = param.kind {\n-                if tcx.is_late_bound(param.hir_id) {\n-                    return Some(param.span);\n-                }\n-            }\n-        }\n-        visitor.visit_fn_decl(decl);\n-        visitor.has_late_bound_regions\n-    }\n-\n-    match node {\n-        Node::TraitItem(item) => match item.kind {\n-            hir::TraitItemKind::Fn(ref sig, _) => {\n-                has_late_bound_regions(tcx, &item.generics, sig.decl)\n-            }\n-            _ => None,\n-        },\n-        Node::ImplItem(item) => match item.kind {\n-            hir::ImplItemKind::Fn(ref sig, _) => {\n-                has_late_bound_regions(tcx, &item.generics, sig.decl)\n-            }\n-            _ => None,\n-        },\n-        Node::ForeignItem(item) => match item.kind {\n-            hir::ForeignItemKind::Fn(fn_decl, _, ref generics) => {\n-                has_late_bound_regions(tcx, generics, fn_decl)\n-            }\n-            _ => None,\n-        },\n-        Node::Item(item) => match item.kind {\n-            hir::ItemKind::Fn(ref sig, .., ref generics, _) => {\n-                has_late_bound_regions(tcx, generics, sig.decl)\n-            }\n-            _ => None,\n-        },\n-        _ => None,\n-    }\n-}\n-\n-struct AnonConstInParamTyDetector {\n-    in_param_ty: bool,\n-    found_anon_const_in_param_ty: bool,\n-    ct: HirId,\n-}\n-\n-impl<'v> Visitor<'v> for AnonConstInParamTyDetector {\n-    fn visit_generic_param(&mut self, p: &'v hir::GenericParam<'v>) {\n-        if let GenericParamKind::Const { ty, default: _ } = p.kind {\n-            let prev = self.in_param_ty;\n-            self.in_param_ty = true;\n-            self.visit_ty(ty);\n-            self.in_param_ty = prev;\n-        }\n-    }\n-\n-    fn visit_anon_const(&mut self, c: &'v hir::AnonConst) {\n-        if self.in_param_ty && self.ct == c.hir_id {\n-            self.found_anon_const_in_param_ty = true;\n-        } else {\n-            intravisit::walk_anon_const(self, c)\n-        }\n-    }\n-}\n-\n-fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n-    use rustc_hir::*;\n-\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-\n-    let node = tcx.hir().get(hir_id);\n-    let parent_def_id = match node {\n-        Node::ImplItem(_)\n-        | Node::TraitItem(_)\n-        | Node::Variant(_)\n-        | Node::Ctor(..)\n-        | Node::Field(_) => {\n-            let parent_id = tcx.hir().get_parent_item(hir_id);\n-            Some(parent_id.to_def_id())\n-        }\n-        // FIXME(#43408) always enable this once `lazy_normalization` is\n-        // stable enough and does not need a feature gate anymore.\n-        Node::AnonConst(_) => {\n-            let parent_def_id = tcx.hir().get_parent_item(hir_id);\n-\n-            let mut in_param_ty = false;\n-            for (_parent, node) in tcx.hir().parent_iter(hir_id) {\n-                if let Some(generics) = node.generics() {\n-                    let mut visitor = AnonConstInParamTyDetector {\n-                        in_param_ty: false,\n-                        found_anon_const_in_param_ty: false,\n-                        ct: hir_id,\n-                    };\n-\n-                    visitor.visit_generics(generics);\n-                    in_param_ty = visitor.found_anon_const_in_param_ty;\n-                    break;\n-                }\n-            }\n-\n-            if in_param_ty {\n-                // We do not allow generic parameters in anon consts if we are inside\n-                // of a const parameter type, e.g. `struct Foo<const N: usize, const M: [u8; N]>` is not allowed.\n-                None\n-            } else if tcx.lazy_normalization() {\n-                if let Some(param_id) = tcx.hir().opt_const_param_default_param_hir_id(hir_id) {\n-                    // If the def_id we are calling generics_of on is an anon ct default i.e:\n-                    //\n-                    // struct Foo<const N: usize = { .. }>;\n-                    //        ^^^       ^          ^^^^^^ def id of this anon const\n-                    //        ^         ^ param_id\n-                    //        ^ parent_def_id\n-                    //\n-                    // then we only want to return generics for params to the left of `N`. If we don't do that we\n-                    // end up with that const looking like: `ty::ConstKind::Unevaluated(def_id, substs: [N#0])`.\n-                    //\n-                    // This causes ICEs (#86580) when building the substs for Foo in `fn foo() -> Foo { .. }` as\n-                    // we substitute the defaults with the partially built substs when we build the substs. Subst'ing\n-                    // the `N#0` on the unevaluated const indexes into the empty substs we're in the process of building.\n-                    //\n-                    // We fix this by having this function return the parent's generics ourselves and truncating the\n-                    // generics to only include non-forward declared params (with the exception of the `Self` ty)\n-                    //\n-                    // For the above code example that means we want `substs: []`\n-                    // For the following struct def we want `substs: [N#0]` when generics_of is called on\n-                    // the def id of the `{ N + 1 }` anon const\n-                    // struct Foo<const N: usize, const M: usize = { N + 1 }>;\n-                    //\n-                    // This has some implications for how we get the predicates available to the anon const\n-                    // see `explicit_predicates_of` for more information on this\n-                    let generics = tcx.generics_of(parent_def_id.to_def_id());\n-                    let param_def = tcx.hir().local_def_id(param_id).to_def_id();\n-                    let param_def_idx = generics.param_def_id_to_index[&param_def];\n-                    // In the above example this would be .params[..N#0]\n-                    let params = generics.params[..param_def_idx as usize].to_owned();\n-                    let param_def_id_to_index =\n-                        params.iter().map(|param| (param.def_id, param.index)).collect();\n-\n-                    return ty::Generics {\n-                        // we set the parent of these generics to be our parent's parent so that we\n-                        // dont end up with substs: [N, M, N] for the const default on a struct like this:\n-                        // struct Foo<const N: usize, const M: usize = { ... }>;\n-                        parent: generics.parent,\n-                        parent_count: generics.parent_count,\n-                        params,\n-                        param_def_id_to_index,\n-                        has_self: generics.has_self,\n-                        has_late_bound_regions: generics.has_late_bound_regions,\n-                    };\n-                }\n-\n-                // HACK(eddyb) this provides the correct generics when\n-                // `feature(generic_const_expressions)` is enabled, so that const expressions\n-                // used with const generics, e.g. `Foo<{N+1}>`, can work at all.\n-                //\n-                // Note that we do not supply the parent generics when using\n-                // `min_const_generics`.\n-                Some(parent_def_id.to_def_id())\n-            } else {\n-                let parent_node = tcx.hir().get(tcx.hir().get_parent_node(hir_id));\n-                match parent_node {\n-                    // HACK(eddyb) this provides the correct generics for repeat\n-                    // expressions' count (i.e. `N` in `[x; N]`), and explicit\n-                    // `enum` discriminants (i.e. `D` in `enum Foo { Bar = D }`),\n-                    // as they shouldn't be able to cause query cycle errors.\n-                    Node::Expr(&Expr { kind: ExprKind::Repeat(_, ref constant), .. })\n-                        if constant.hir_id() == hir_id =>\n-                    {\n-                        Some(parent_def_id.to_def_id())\n-                    }\n-                    Node::Variant(Variant { disr_expr: Some(ref constant), .. })\n-                        if constant.hir_id == hir_id =>\n-                    {\n-                        Some(parent_def_id.to_def_id())\n-                    }\n-                    Node::Expr(&Expr { kind: ExprKind::ConstBlock(_), .. }) => {\n-                        Some(tcx.typeck_root_def_id(def_id))\n-                    }\n-                    // Exclude `GlobalAsm` here which cannot have generics.\n-                    Node::Expr(&Expr { kind: ExprKind::InlineAsm(asm), .. })\n-                        if asm.operands.iter().any(|(op, _op_sp)| match op {\n-                            hir::InlineAsmOperand::Const { anon_const }\n-                            | hir::InlineAsmOperand::SymFn { anon_const } => {\n-                                anon_const.hir_id == hir_id\n-                            }\n-                            _ => false,\n-                        }) =>\n-                    {\n-                        Some(parent_def_id.to_def_id())\n-                    }\n-                    _ => None,\n-                }\n-            }\n-        }\n-        Node::Expr(&hir::Expr { kind: hir::ExprKind::Closure { .. }, .. }) => {\n-            Some(tcx.typeck_root_def_id(def_id))\n-        }\n-        Node::Item(item) => match item.kind {\n-            ItemKind::OpaqueTy(hir::OpaqueTy {\n-                origin:\n-                    hir::OpaqueTyOrigin::FnReturn(fn_def_id) | hir::OpaqueTyOrigin::AsyncFn(fn_def_id),\n-                in_trait,\n-                ..\n-            }) => {\n-                if in_trait {\n-                    assert!(matches!(tcx.def_kind(fn_def_id), DefKind::AssocFn))\n-                } else {\n-                    assert!(matches!(tcx.def_kind(fn_def_id), DefKind::AssocFn | DefKind::Fn))\n-                }\n-                Some(fn_def_id.to_def_id())\n-            }\n-            ItemKind::OpaqueTy(hir::OpaqueTy { origin: hir::OpaqueTyOrigin::TyAlias, .. }) => {\n-                let parent_id = tcx.hir().get_parent_item(hir_id);\n-                assert_ne!(parent_id, hir::CRATE_OWNER_ID);\n-                debug!(\"generics_of: parent of opaque ty {:?} is {:?}\", def_id, parent_id);\n-                // Opaque types are always nested within another item, and\n-                // inherit the generics of the item.\n-                Some(parent_id.to_def_id())\n-            }\n-            _ => None,\n-        },\n-        _ => None,\n-    };\n-\n-    enum Defaults {\n-        Allowed,\n-        // See #36887\n-        FutureCompatDisallowed,\n-        Deny,\n-    }\n-\n-    let no_generics = hir::Generics::empty();\n-    let ast_generics = node.generics().unwrap_or(&no_generics);\n-    let (opt_self, allow_defaults) = match node {\n-        Node::Item(item) => {\n-            match item.kind {\n-                ItemKind::Trait(..) | ItemKind::TraitAlias(..) => {\n-                    // Add in the self type parameter.\n-                    //\n-                    // Something of a hack: use the node id for the trait, also as\n-                    // the node id for the Self type parameter.\n-                    let opt_self = Some(ty::GenericParamDef {\n-                        index: 0,\n-                        name: kw::SelfUpper,\n-                        def_id,\n-                        pure_wrt_drop: false,\n-                        kind: ty::GenericParamDefKind::Type {\n-                            has_default: false,\n-                            synthetic: false,\n-                        },\n-                    });\n-\n-                    (opt_self, Defaults::Allowed)\n-                }\n-                ItemKind::TyAlias(..)\n-                | ItemKind::Enum(..)\n-                | ItemKind::Struct(..)\n-                | ItemKind::OpaqueTy(..)\n-                | ItemKind::Union(..) => (None, Defaults::Allowed),\n-                _ => (None, Defaults::FutureCompatDisallowed),\n-            }\n-        }\n-\n-        // GATs\n-        Node::TraitItem(item) if matches!(item.kind, TraitItemKind::Type(..)) => {\n-            (None, Defaults::Deny)\n-        }\n-        Node::ImplItem(item) if matches!(item.kind, ImplItemKind::TyAlias(..)) => {\n-            (None, Defaults::Deny)\n-        }\n-\n-        _ => (None, Defaults::FutureCompatDisallowed),\n-    };\n-\n-    let has_self = opt_self.is_some();\n-    let mut parent_has_self = false;\n-    let mut own_start = has_self as u32;\n-    let parent_count = parent_def_id.map_or(0, |def_id| {\n-        let generics = tcx.generics_of(def_id);\n-        assert!(!has_self);\n-        parent_has_self = generics.has_self;\n-        own_start = generics.count() as u32;\n-        generics.parent_count + generics.params.len()\n-    });\n-\n-    let mut params: Vec<_> = Vec::with_capacity(ast_generics.params.len() + has_self as usize);\n-\n-    if let Some(opt_self) = opt_self {\n-        params.push(opt_self);\n-    }\n-\n-    let early_lifetimes = early_bound_lifetimes_from_generics(tcx, ast_generics);\n-    params.extend(early_lifetimes.enumerate().map(|(i, param)| ty::GenericParamDef {\n-        name: param.name.ident().name,\n-        index: own_start + i as u32,\n-        def_id: tcx.hir().local_def_id(param.hir_id).to_def_id(),\n-        pure_wrt_drop: param.pure_wrt_drop,\n-        kind: ty::GenericParamDefKind::Lifetime,\n-    }));\n-\n-    // Now create the real type and const parameters.\n-    let type_start = own_start - has_self as u32 + params.len() as u32;\n-    let mut i = 0;\n-\n-    const TYPE_DEFAULT_NOT_ALLOWED: &'static str = \"defaults for type parameters are only allowed in \\\n-    `struct`, `enum`, `type`, or `trait` definitions\";\n-\n-    params.extend(ast_generics.params.iter().filter_map(|param| match param.kind {\n-        GenericParamKind::Lifetime { .. } => None,\n-        GenericParamKind::Type { ref default, synthetic, .. } => {\n-            if default.is_some() {\n-                match allow_defaults {\n-                    Defaults::Allowed => {}\n-                    Defaults::FutureCompatDisallowed\n-                        if tcx.features().default_type_parameter_fallback => {}\n-                    Defaults::FutureCompatDisallowed => {\n-                        tcx.struct_span_lint_hir(\n-                            lint::builtin::INVALID_TYPE_PARAM_DEFAULT,\n-                            param.hir_id,\n-                            param.span,\n-                            |lint| {\n-                                lint.build(TYPE_DEFAULT_NOT_ALLOWED).emit();\n-                            },\n-                        );\n-                    }\n-                    Defaults::Deny => {\n-                        tcx.sess.span_err(param.span, TYPE_DEFAULT_NOT_ALLOWED);\n-                    }\n-                }\n-            }\n-\n-            let kind = ty::GenericParamDefKind::Type { has_default: default.is_some(), synthetic };\n-\n-            let param_def = ty::GenericParamDef {\n-                index: type_start + i as u32,\n-                name: param.name.ident().name,\n-                def_id: tcx.hir().local_def_id(param.hir_id).to_def_id(),\n-                pure_wrt_drop: param.pure_wrt_drop,\n-                kind,\n-            };\n-            i += 1;\n-            Some(param_def)\n-        }\n-        GenericParamKind::Const { default, .. } => {\n-            if !matches!(allow_defaults, Defaults::Allowed) && default.is_some() {\n-                tcx.sess.span_err(\n-                    param.span,\n-                    \"defaults for const parameters are only allowed in \\\n-                    `struct`, `enum`, `type`, or `trait` definitions\",\n-                );\n-            }\n-\n-            let param_def = ty::GenericParamDef {\n-                index: type_start + i as u32,\n-                name: param.name.ident().name,\n-                def_id: tcx.hir().local_def_id(param.hir_id).to_def_id(),\n-                pure_wrt_drop: param.pure_wrt_drop,\n-                kind: ty::GenericParamDefKind::Const { has_default: default.is_some() },\n-            };\n-            i += 1;\n-            Some(param_def)\n-        }\n-    }));\n-\n-    // provide junk type parameter defs - the only place that\n-    // cares about anything but the length is instantiation,\n-    // and we don't do that for closures.\n-    if let Node::Expr(&hir::Expr {\n-        kind: hir::ExprKind::Closure(hir::Closure { movability: gen, .. }),\n-        ..\n-    }) = node\n-    {\n-        let dummy_args = if gen.is_some() {\n-            &[\"<resume_ty>\", \"<yield_ty>\", \"<return_ty>\", \"<witness>\", \"<upvars>\"][..]\n-        } else {\n-            &[\"<closure_kind>\", \"<closure_signature>\", \"<upvars>\"][..]\n-        };\n-\n-        params.extend(dummy_args.iter().enumerate().map(|(i, &arg)| ty::GenericParamDef {\n-            index: type_start + i as u32,\n-            name: Symbol::intern(arg),\n-            def_id,\n-            pure_wrt_drop: false,\n-            kind: ty::GenericParamDefKind::Type { has_default: false, synthetic: false },\n-        }));\n-    }\n-\n-    // provide junk type parameter defs for const blocks.\n-    if let Node::AnonConst(_) = node {\n-        let parent_node = tcx.hir().get(tcx.hir().get_parent_node(hir_id));\n-        if let Node::Expr(&Expr { kind: ExprKind::ConstBlock(_), .. }) = parent_node {\n-            params.push(ty::GenericParamDef {\n-                index: type_start,\n-                name: Symbol::intern(\"<const_ty>\"),\n-                def_id,\n-                pure_wrt_drop: false,\n-                kind: ty::GenericParamDefKind::Type { has_default: false, synthetic: false },\n-            });\n-        }\n-    }\n-\n-    let param_def_id_to_index = params.iter().map(|param| (param.def_id, param.index)).collect();\n-\n-    ty::Generics {\n-        parent: parent_def_id,\n-        parent_count,\n-        params,\n-        param_def_id_to_index,\n-        has_self: has_self || parent_has_self,\n-        has_late_bound_regions: has_late_bound_regions(tcx, node),\n-    }\n-}\n-\n fn are_suggestable_generic_args(generic_args: &[hir::GenericArg<'_>]) -> bool {\n     generic_args.iter().any(|arg| match arg {\n         hir::GenericArg::Type(ty) => is_suggestable_infer_ty(ty),\n@@ -2093,450 +1375,6 @@ fn predicates_defined_on(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicate\n     result\n }\n \n-/// Returns a list of all type predicates (explicit and implicit) for the definition with\n-/// ID `def_id`. This includes all predicates returned by `predicates_defined_on`, plus\n-/// `Self: Trait` predicates for traits.\n-fn predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicates<'_> {\n-    let mut result = tcx.predicates_defined_on(def_id);\n-\n-    if tcx.is_trait(def_id) {\n-        // For traits, add `Self: Trait` predicate. This is\n-        // not part of the predicates that a user writes, but it\n-        // is something that one must prove in order to invoke a\n-        // method or project an associated type.\n-        //\n-        // In the chalk setup, this predicate is not part of the\n-        // \"predicates\" for a trait item. But it is useful in\n-        // rustc because if you directly (e.g.) invoke a trait\n-        // method like `Trait::method(...)`, you must naturally\n-        // prove that the trait applies to the types that were\n-        // used, and adding the predicate into this list ensures\n-        // that this is done.\n-        //\n-        // We use a DUMMY_SP here as a way to signal trait bounds that come\n-        // from the trait itself that *shouldn't* be shown as the source of\n-        // an obligation and instead be skipped. Otherwise we'd use\n-        // `tcx.def_span(def_id);`\n-\n-        let constness = if tcx.has_attr(def_id, sym::const_trait) {\n-            ty::BoundConstness::ConstIfConst\n-        } else {\n-            ty::BoundConstness::NotConst\n-        };\n-\n-        let span = rustc_span::DUMMY_SP;\n-        result.predicates =\n-            tcx.arena.alloc_from_iter(result.predicates.iter().copied().chain(std::iter::once((\n-                ty::TraitRef::identity(tcx, def_id).with_constness(constness).to_predicate(tcx),\n-                span,\n-            ))));\n-    }\n-    debug!(\"predicates_of(def_id={:?}) = {:?}\", def_id, result);\n-    result\n-}\n-\n-/// Returns a list of user-specified type predicates for the definition with ID `def_id`.\n-/// N.B., this does not include any implied/inferred constraints.\n-#[instrument(level = \"trace\", skip(tcx), ret)]\n-fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicates<'_> {\n-    use rustc_hir::*;\n-\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-    let node = tcx.hir().get(hir_id);\n-\n-    let mut is_trait = None;\n-    let mut is_default_impl_trait = None;\n-\n-    let icx = ItemCtxt::new(tcx, def_id);\n-\n-    const NO_GENERICS: &hir::Generics<'_> = hir::Generics::empty();\n-\n-    // We use an `IndexSet` to preserves order of insertion.\n-    // Preserving the order of insertion is important here so as not to break UI tests.\n-    let mut predicates: FxIndexSet<(ty::Predicate<'_>, Span)> = FxIndexSet::default();\n-\n-    let ast_generics = match node {\n-        Node::TraitItem(item) => item.generics,\n-\n-        Node::ImplItem(item) => item.generics,\n-\n-        Node::Item(item) => {\n-            match item.kind {\n-                ItemKind::Impl(ref impl_) => {\n-                    if impl_.defaultness.is_default() {\n-                        is_default_impl_trait = tcx.impl_trait_ref(def_id).map(ty::Binder::dummy);\n-                    }\n-                    &impl_.generics\n-                }\n-                ItemKind::Fn(.., ref generics, _)\n-                | ItemKind::TyAlias(_, ref generics)\n-                | ItemKind::Enum(_, ref generics)\n-                | ItemKind::Struct(_, ref generics)\n-                | ItemKind::Union(_, ref generics) => *generics,\n-\n-                ItemKind::Trait(_, _, ref generics, ..) => {\n-                    is_trait = Some(ty::TraitRef::identity(tcx, def_id));\n-                    *generics\n-                }\n-                ItemKind::TraitAlias(ref generics, _) => {\n-                    is_trait = Some(ty::TraitRef::identity(tcx, def_id));\n-                    *generics\n-                }\n-                ItemKind::OpaqueTy(OpaqueTy {\n-                    origin: hir::OpaqueTyOrigin::AsyncFn(..) | hir::OpaqueTyOrigin::FnReturn(..),\n-                    ..\n-                }) => {\n-                    // return-position impl trait\n-                    //\n-                    // We don't inherit predicates from the parent here:\n-                    // If we have, say `fn f<'a, T: 'a>() -> impl Sized {}`\n-                    // then the return type is `f::<'static, T>::{{opaque}}`.\n-                    //\n-                    // If we inherited the predicates of `f` then we would\n-                    // require that `T: 'static` to show that the return\n-                    // type is well-formed.\n-                    //\n-                    // The only way to have something with this opaque type\n-                    // is from the return type of the containing function,\n-                    // which will ensure that the function's predicates\n-                    // hold.\n-                    return ty::GenericPredicates { parent: None, predicates: &[] };\n-                }\n-                ItemKind::OpaqueTy(OpaqueTy {\n-                    ref generics,\n-                    origin: hir::OpaqueTyOrigin::TyAlias,\n-                    ..\n-                }) => {\n-                    // type-alias impl trait\n-                    generics\n-                }\n-\n-                _ => NO_GENERICS,\n-            }\n-        }\n-\n-        Node::ForeignItem(item) => match item.kind {\n-            ForeignItemKind::Static(..) => NO_GENERICS,\n-            ForeignItemKind::Fn(_, _, ref generics) => *generics,\n-            ForeignItemKind::Type => NO_GENERICS,\n-        },\n-\n-        _ => NO_GENERICS,\n-    };\n-\n-    let generics = tcx.generics_of(def_id);\n-    let parent_count = generics.parent_count as u32;\n-    let has_own_self = generics.has_self && parent_count == 0;\n-\n-    // Below we'll consider the bounds on the type parameters (including `Self`)\n-    // and the explicit where-clauses, but to get the full set of predicates\n-    // on a trait we need to add in the supertrait bounds and bounds found on\n-    // associated types.\n-    if let Some(_trait_ref) = is_trait {\n-        predicates.extend(tcx.super_predicates_of(def_id).predicates.iter().cloned());\n-    }\n-\n-    // In default impls, we can assume that the self type implements\n-    // the trait. So in:\n-    //\n-    //     default impl Foo for Bar { .. }\n-    //\n-    // we add a default where clause `Foo: Bar`. We do a similar thing for traits\n-    // (see below). Recall that a default impl is not itself an impl, but rather a\n-    // set of defaults that can be incorporated into another impl.\n-    if let Some(trait_ref) = is_default_impl_trait {\n-        predicates.insert((trait_ref.without_const().to_predicate(tcx), tcx.def_span(def_id)));\n-    }\n-\n-    // Collect the region predicates that were declared inline as\n-    // well. In the case of parameters declared on a fn or method, we\n-    // have to be careful to only iterate over early-bound regions.\n-    let mut index = parent_count\n-        + has_own_self as u32\n-        + early_bound_lifetimes_from_generics(tcx, ast_generics).count() as u32;\n-\n-    trace!(?predicates);\n-    trace!(?ast_generics);\n-\n-    // Collect the predicates that were written inline by the user on each\n-    // type parameter (e.g., `<T: Foo>`).\n-    for param in ast_generics.params {\n-        match param.kind {\n-            // We already dealt with early bound lifetimes above.\n-            GenericParamKind::Lifetime { .. } => (),\n-            GenericParamKind::Type { .. } => {\n-                let name = param.name.ident().name;\n-                let param_ty = ty::ParamTy::new(index, name).to_ty(tcx);\n-                index += 1;\n-\n-                let mut bounds = Bounds::default();\n-                // Params are implicitly sized unless a `?Sized` bound is found\n-                <dyn AstConv<'_>>::add_implicitly_sized(\n-                    &icx,\n-                    &mut bounds,\n-                    &[],\n-                    Some((param.hir_id, ast_generics.predicates)),\n-                    param.span,\n-                );\n-                trace!(?bounds);\n-                predicates.extend(bounds.predicates(tcx, param_ty));\n-                trace!(?predicates);\n-            }\n-            GenericParamKind::Const { .. } => {\n-                // Bounds on const parameters are currently not possible.\n-                index += 1;\n-            }\n-        }\n-    }\n-\n-    trace!(?predicates);\n-    // Add in the bounds that appear in the where-clause.\n-    for predicate in ast_generics.predicates {\n-        match predicate {\n-            hir::WherePredicate::BoundPredicate(bound_pred) => {\n-                let ty = icx.to_ty(bound_pred.bounded_ty);\n-                let bound_vars = icx.tcx.late_bound_vars(bound_pred.hir_id);\n-\n-                // Keep the type around in a dummy predicate, in case of no bounds.\n-                // That way, `where Ty:` is not a complete noop (see #53696) and `Ty`\n-                // is still checked for WF.\n-                if bound_pred.bounds.is_empty() {\n-                    if let ty::Param(_) = ty.kind() {\n-                        // This is a `where T:`, which can be in the HIR from the\n-                        // transformation that moves `?Sized` to `T`'s declaration.\n-                        // We can skip the predicate because type parameters are\n-                        // trivially WF, but also we *should*, to avoid exposing\n-                        // users who never wrote `where Type:,` themselves, to\n-                        // compiler/tooling bugs from not handling WF predicates.\n-                    } else {\n-                        let span = bound_pred.bounded_ty.span;\n-                        let predicate = ty::Binder::bind_with_vars(\n-                            ty::PredicateKind::WellFormed(ty.into()),\n-                            bound_vars,\n-                        );\n-                        predicates.insert((predicate.to_predicate(tcx), span));\n-                    }\n-                }\n-\n-                let mut bounds = Bounds::default();\n-                <dyn AstConv<'_>>::add_bounds(\n-                    &icx,\n-                    ty,\n-                    bound_pred.bounds.iter(),\n-                    &mut bounds,\n-                    bound_vars,\n-                );\n-                predicates.extend(bounds.predicates(tcx, ty));\n-            }\n-\n-            hir::WherePredicate::RegionPredicate(region_pred) => {\n-                let r1 = <dyn AstConv<'_>>::ast_region_to_region(&icx, &region_pred.lifetime, None);\n-                predicates.extend(region_pred.bounds.iter().map(|bound| {\n-                    let (r2, span) = match bound {\n-                        hir::GenericBound::Outlives(lt) => {\n-                            (<dyn AstConv<'_>>::ast_region_to_region(&icx, lt, None), lt.span)\n-                        }\n-                        _ => bug!(),\n-                    };\n-                    let pred = ty::Binder::dummy(ty::PredicateKind::RegionOutlives(\n-                        ty::OutlivesPredicate(r1, r2),\n-                    ))\n-                    .to_predicate(icx.tcx);\n-\n-                    (pred, span)\n-                }))\n-            }\n-\n-            hir::WherePredicate::EqPredicate(..) => {\n-                // FIXME(#20041)\n-            }\n-        }\n-    }\n-\n-    if tcx.features().generic_const_exprs {\n-        predicates.extend(const_evaluatable_predicates_of(tcx, def_id.expect_local()));\n-    }\n-\n-    let mut predicates: Vec<_> = predicates.into_iter().collect();\n-\n-    // Subtle: before we store the predicates into the tcx, we\n-    // sort them so that predicates like `T: Foo<Item=U>` come\n-    // before uses of `U`.  This avoids false ambiguity errors\n-    // in trait checking. See `setup_constraining_predicates`\n-    // for details.\n-    if let Node::Item(&Item { kind: ItemKind::Impl { .. }, .. }) = node {\n-        let self_ty = tcx.type_of(def_id);\n-        let trait_ref = tcx.impl_trait_ref(def_id);\n-        cgp::setup_constraining_predicates(\n-            tcx,\n-            &mut predicates,\n-            trait_ref,\n-            &mut cgp::parameters_for_impl(self_ty, trait_ref),\n-        );\n-    }\n-\n-    ty::GenericPredicates {\n-        parent: generics.parent,\n-        predicates: tcx.arena.alloc_from_iter(predicates),\n-    }\n-}\n-\n-fn const_evaluatable_predicates_of<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: LocalDefId,\n-) -> FxIndexSet<(ty::Predicate<'tcx>, Span)> {\n-    struct ConstCollector<'tcx> {\n-        tcx: TyCtxt<'tcx>,\n-        preds: FxIndexSet<(ty::Predicate<'tcx>, Span)>,\n-    }\n-\n-    impl<'tcx> intravisit::Visitor<'tcx> for ConstCollector<'tcx> {\n-        fn visit_anon_const(&mut self, c: &'tcx hir::AnonConst) {\n-            let def_id = self.tcx.hir().local_def_id(c.hir_id);\n-            let ct = ty::Const::from_anon_const(self.tcx, def_id);\n-            if let ty::ConstKind::Unevaluated(uv) = ct.kind() {\n-                let span = self.tcx.hir().span(c.hir_id);\n-                self.preds.insert((\n-                    ty::Binder::dummy(ty::PredicateKind::ConstEvaluatable(uv))\n-                        .to_predicate(self.tcx),\n-                    span,\n-                ));\n-            }\n-        }\n-\n-        fn visit_const_param_default(&mut self, _param: HirId, _ct: &'tcx hir::AnonConst) {\n-            // Do not look into const param defaults,\n-            // these get checked when they are actually instantiated.\n-            //\n-            // We do not want the following to error:\n-            //\n-            //     struct Foo<const N: usize, const M: usize = { N + 1 }>;\n-            //     struct Bar<const N: usize>(Foo<N, 3>);\n-        }\n-    }\n-\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-    let node = tcx.hir().get(hir_id);\n-\n-    let mut collector = ConstCollector { tcx, preds: FxIndexSet::default() };\n-    if let hir::Node::Item(item) = node && let hir::ItemKind::Impl(ref impl_) = item.kind {\n-        if let Some(of_trait) = &impl_.of_trait {\n-            debug!(\"const_evaluatable_predicates_of({:?}): visit impl trait_ref\", def_id);\n-            collector.visit_trait_ref(of_trait);\n-        }\n-\n-        debug!(\"const_evaluatable_predicates_of({:?}): visit_self_ty\", def_id);\n-        collector.visit_ty(impl_.self_ty);\n-    }\n-\n-    if let Some(generics) = node.generics() {\n-        debug!(\"const_evaluatable_predicates_of({:?}): visit_generics\", def_id);\n-        collector.visit_generics(generics);\n-    }\n-\n-    if let Some(fn_sig) = tcx.hir().fn_sig_by_hir_id(hir_id) {\n-        debug!(\"const_evaluatable_predicates_of({:?}): visit_fn_decl\", def_id);\n-        collector.visit_fn_decl(fn_sig.decl);\n-    }\n-    debug!(\"const_evaluatable_predicates_of({:?}) = {:?}\", def_id, collector.preds);\n-\n-    collector.preds\n-}\n-\n-fn trait_explicit_predicates_and_bounds(\n-    tcx: TyCtxt<'_>,\n-    def_id: LocalDefId,\n-) -> ty::GenericPredicates<'_> {\n-    assert_eq!(tcx.def_kind(def_id), DefKind::Trait);\n-    gather_explicit_predicates_of(tcx, def_id.to_def_id())\n-}\n-\n-fn explicit_predicates_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> ty::GenericPredicates<'tcx> {\n-    let def_kind = tcx.def_kind(def_id);\n-    if let DefKind::Trait = def_kind {\n-        // Remove bounds on associated types from the predicates, they will be\n-        // returned by `explicit_item_bounds`.\n-        let predicates_and_bounds = tcx.trait_explicit_predicates_and_bounds(def_id.expect_local());\n-        let trait_identity_substs = InternalSubsts::identity_for_item(tcx, def_id);\n-\n-        let is_assoc_item_ty = |ty: Ty<'tcx>| {\n-            // For a predicate from a where clause to become a bound on an\n-            // associated type:\n-            // * It must use the identity substs of the item.\n-            //     * Since any generic parameters on the item are not in scope,\n-            //       this means that the item is not a GAT, and its identity\n-            //       substs are the same as the trait's.\n-            // * It must be an associated type for this trait (*not* a\n-            //   supertrait).\n-            if let ty::Projection(projection) = ty.kind() {\n-                projection.substs == trait_identity_substs\n-                    && tcx.associated_item(projection.item_def_id).container_id(tcx) == def_id\n-            } else {\n-                false\n-            }\n-        };\n-\n-        let predicates: Vec<_> = predicates_and_bounds\n-            .predicates\n-            .iter()\n-            .copied()\n-            .filter(|(pred, _)| match pred.kind().skip_binder() {\n-                ty::PredicateKind::Trait(tr) => !is_assoc_item_ty(tr.self_ty()),\n-                ty::PredicateKind::Projection(proj) => {\n-                    !is_assoc_item_ty(proj.projection_ty.self_ty())\n-                }\n-                ty::PredicateKind::TypeOutlives(outlives) => !is_assoc_item_ty(outlives.0),\n-                _ => true,\n-            })\n-            .collect();\n-        if predicates.len() == predicates_and_bounds.predicates.len() {\n-            predicates_and_bounds\n-        } else {\n-            ty::GenericPredicates {\n-                parent: predicates_and_bounds.parent,\n-                predicates: tcx.arena.alloc_slice(&predicates),\n-            }\n-        }\n-    } else {\n-        if matches!(def_kind, DefKind::AnonConst) && tcx.lazy_normalization() {\n-            let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-            if tcx.hir().opt_const_param_default_param_hir_id(hir_id).is_some() {\n-                // In `generics_of` we set the generics' parent to be our parent's parent which means that\n-                // we lose out on the predicates of our actual parent if we dont return those predicates here.\n-                // (See comment in `generics_of` for more information on why the parent shenanigans is necessary)\n-                //\n-                // struct Foo<T, const N: usize = { <T as Trait>::ASSOC }>(T) where T: Trait;\n-                //        ^^^                     ^^^^^^^^^^^^^^^^^^^^^^^ the def id we are calling\n-                //        ^^^                                             explicit_predicates_of on\n-                //        parent item we dont have set as the\n-                //        parent of generics returned by `generics_of`\n-                //\n-                // In the above code we want the anon const to have predicates in its param env for `T: Trait`\n-                let item_def_id = tcx.hir().get_parent_item(hir_id);\n-                // In the above code example we would be calling `explicit_predicates_of(Foo)` here\n-                return tcx.explicit_predicates_of(item_def_id);\n-            }\n-        }\n-        gather_explicit_predicates_of(tcx, def_id)\n-    }\n-}\n-\n-/// Converts a specific `GenericBound` from the AST into a set of\n-/// predicates that apply to the self type. A vector is returned\n-/// because this can be anywhere from zero predicates (`T: ?Sized` adds no\n-/// predicates) to one (`T: Foo`) to many (`T: Bar<X = i32>` adds `T: Bar`\n-/// and `<T as Bar>::X == i32`).\n-fn predicates_from_bound<'tcx>(\n-    astconv: &dyn AstConv<'tcx>,\n-    param_ty: Ty<'tcx>,\n-    bound: &'tcx hir::GenericBound<'tcx>,\n-    bound_vars: &'tcx ty::List<ty::BoundVariableKind>,\n-) -> Vec<(ty::Predicate<'tcx>, Span)> {\n-    let mut bounds = Bounds::default();\n-    astconv.add_bounds(param_ty, [bound].into_iter(), &mut bounds, bound_vars);\n-    bounds.predicates(astconv.tcx(), param_ty).collect()\n-}\n-\n fn compute_sig_of_foreign_fn_decl<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,"}, {"sha": "1deff17e8408049e51036d58bf1d8867e4e814c8", "filename": "compiler/rustc_hir_analysis/src/collect/generics_of.rs", "status": "added", "additions": 481, "deletions": 0, "changes": 481, "blob_url": "https://github.com/rust-lang/rust/blob/6367e69929bef8cbfbbde0d2218476a470f41f90/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6367e69929bef8cbfbbde0d2218476a470f41f90/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs?ref=6367e69929bef8cbfbbde0d2218476a470f41f90", "patch": "@@ -0,0 +1,481 @@\n+use crate::middle::resolve_lifetime as rl;\n+use hir::{\n+    intravisit::{self, Visitor},\n+    GenericParamKind, HirId, Node,\n+};\n+use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::ty::{self, TyCtxt};\n+use rustc_session::lint;\n+use rustc_span::symbol::{kw, Symbol};\n+use rustc_span::Span;\n+\n+pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n+    use rustc_hir::*;\n+\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+\n+    let node = tcx.hir().get(hir_id);\n+    let parent_def_id = match node {\n+        Node::ImplItem(_)\n+        | Node::TraitItem(_)\n+        | Node::Variant(_)\n+        | Node::Ctor(..)\n+        | Node::Field(_) => {\n+            let parent_id = tcx.hir().get_parent_item(hir_id);\n+            Some(parent_id.to_def_id())\n+        }\n+        // FIXME(#43408) always enable this once `lazy_normalization` is\n+        // stable enough and does not need a feature gate anymore.\n+        Node::AnonConst(_) => {\n+            let parent_def_id = tcx.hir().get_parent_item(hir_id);\n+\n+            let mut in_param_ty = false;\n+            for (_parent, node) in tcx.hir().parent_iter(hir_id) {\n+                if let Some(generics) = node.generics() {\n+                    let mut visitor = AnonConstInParamTyDetector {\n+                        in_param_ty: false,\n+                        found_anon_const_in_param_ty: false,\n+                        ct: hir_id,\n+                    };\n+\n+                    visitor.visit_generics(generics);\n+                    in_param_ty = visitor.found_anon_const_in_param_ty;\n+                    break;\n+                }\n+            }\n+\n+            if in_param_ty {\n+                // We do not allow generic parameters in anon consts if we are inside\n+                // of a const parameter type, e.g. `struct Foo<const N: usize, const M: [u8; N]>` is not allowed.\n+                None\n+            } else if tcx.lazy_normalization() {\n+                if let Some(param_id) = tcx.hir().opt_const_param_default_param_hir_id(hir_id) {\n+                    // If the def_id we are calling generics_of on is an anon ct default i.e:\n+                    //\n+                    // struct Foo<const N: usize = { .. }>;\n+                    //        ^^^       ^          ^^^^^^ def id of this anon const\n+                    //        ^         ^ param_id\n+                    //        ^ parent_def_id\n+                    //\n+                    // then we only want to return generics for params to the left of `N`. If we don't do that we\n+                    // end up with that const looking like: `ty::ConstKind::Unevaluated(def_id, substs: [N#0])`.\n+                    //\n+                    // This causes ICEs (#86580) when building the substs for Foo in `fn foo() -> Foo { .. }` as\n+                    // we substitute the defaults with the partially built substs when we build the substs. Subst'ing\n+                    // the `N#0` on the unevaluated const indexes into the empty substs we're in the process of building.\n+                    //\n+                    // We fix this by having this function return the parent's generics ourselves and truncating the\n+                    // generics to only include non-forward declared params (with the exception of the `Self` ty)\n+                    //\n+                    // For the above code example that means we want `substs: []`\n+                    // For the following struct def we want `substs: [N#0]` when generics_of is called on\n+                    // the def id of the `{ N + 1 }` anon const\n+                    // struct Foo<const N: usize, const M: usize = { N + 1 }>;\n+                    //\n+                    // This has some implications for how we get the predicates available to the anon const\n+                    // see `explicit_predicates_of` for more information on this\n+                    let generics = tcx.generics_of(parent_def_id.to_def_id());\n+                    let param_def = tcx.hir().local_def_id(param_id).to_def_id();\n+                    let param_def_idx = generics.param_def_id_to_index[&param_def];\n+                    // In the above example this would be .params[..N#0]\n+                    let params = generics.params[..param_def_idx as usize].to_owned();\n+                    let param_def_id_to_index =\n+                        params.iter().map(|param| (param.def_id, param.index)).collect();\n+\n+                    return ty::Generics {\n+                        // we set the parent of these generics to be our parent's parent so that we\n+                        // dont end up with substs: [N, M, N] for the const default on a struct like this:\n+                        // struct Foo<const N: usize, const M: usize = { ... }>;\n+                        parent: generics.parent,\n+                        parent_count: generics.parent_count,\n+                        params,\n+                        param_def_id_to_index,\n+                        has_self: generics.has_self,\n+                        has_late_bound_regions: generics.has_late_bound_regions,\n+                    };\n+                }\n+\n+                // HACK(eddyb) this provides the correct generics when\n+                // `feature(generic_const_expressions)` is enabled, so that const expressions\n+                // used with const generics, e.g. `Foo<{N+1}>`, can work at all.\n+                //\n+                // Note that we do not supply the parent generics when using\n+                // `min_const_generics`.\n+                Some(parent_def_id.to_def_id())\n+            } else {\n+                let parent_node = tcx.hir().get(tcx.hir().get_parent_node(hir_id));\n+                match parent_node {\n+                    // HACK(eddyb) this provides the correct generics for repeat\n+                    // expressions' count (i.e. `N` in `[x; N]`), and explicit\n+                    // `enum` discriminants (i.e. `D` in `enum Foo { Bar = D }`),\n+                    // as they shouldn't be able to cause query cycle errors.\n+                    Node::Expr(&Expr { kind: ExprKind::Repeat(_, ref constant), .. })\n+                        if constant.hir_id() == hir_id =>\n+                    {\n+                        Some(parent_def_id.to_def_id())\n+                    }\n+                    Node::Variant(Variant { disr_expr: Some(ref constant), .. })\n+                        if constant.hir_id == hir_id =>\n+                    {\n+                        Some(parent_def_id.to_def_id())\n+                    }\n+                    Node::Expr(&Expr { kind: ExprKind::ConstBlock(_), .. }) => {\n+                        Some(tcx.typeck_root_def_id(def_id))\n+                    }\n+                    // Exclude `GlobalAsm` here which cannot have generics.\n+                    Node::Expr(&Expr { kind: ExprKind::InlineAsm(asm), .. })\n+                        if asm.operands.iter().any(|(op, _op_sp)| match op {\n+                            hir::InlineAsmOperand::Const { anon_const }\n+                            | hir::InlineAsmOperand::SymFn { anon_const } => {\n+                                anon_const.hir_id == hir_id\n+                            }\n+                            _ => false,\n+                        }) =>\n+                    {\n+                        Some(parent_def_id.to_def_id())\n+                    }\n+                    _ => None,\n+                }\n+            }\n+        }\n+        Node::Expr(&hir::Expr { kind: hir::ExprKind::Closure { .. }, .. }) => {\n+            Some(tcx.typeck_root_def_id(def_id))\n+        }\n+        Node::Item(item) => match item.kind {\n+            ItemKind::OpaqueTy(hir::OpaqueTy {\n+                origin:\n+                    hir::OpaqueTyOrigin::FnReturn(fn_def_id) | hir::OpaqueTyOrigin::AsyncFn(fn_def_id),\n+                in_trait,\n+                ..\n+            }) => {\n+                if in_trait {\n+                    assert!(matches!(tcx.def_kind(fn_def_id), DefKind::AssocFn))\n+                } else {\n+                    assert!(matches!(tcx.def_kind(fn_def_id), DefKind::AssocFn | DefKind::Fn))\n+                }\n+                Some(fn_def_id.to_def_id())\n+            }\n+            ItemKind::OpaqueTy(hir::OpaqueTy { origin: hir::OpaqueTyOrigin::TyAlias, .. }) => {\n+                let parent_id = tcx.hir().get_parent_item(hir_id);\n+                assert_ne!(parent_id, hir::CRATE_OWNER_ID);\n+                debug!(\"generics_of: parent of opaque ty {:?} is {:?}\", def_id, parent_id);\n+                // Opaque types are always nested within another item, and\n+                // inherit the generics of the item.\n+                Some(parent_id.to_def_id())\n+            }\n+            _ => None,\n+        },\n+        _ => None,\n+    };\n+\n+    enum Defaults {\n+        Allowed,\n+        // See #36887\n+        FutureCompatDisallowed,\n+        Deny,\n+    }\n+\n+    let no_generics = hir::Generics::empty();\n+    let ast_generics = node.generics().unwrap_or(&no_generics);\n+    let (opt_self, allow_defaults) = match node {\n+        Node::Item(item) => {\n+            match item.kind {\n+                ItemKind::Trait(..) | ItemKind::TraitAlias(..) => {\n+                    // Add in the self type parameter.\n+                    //\n+                    // Something of a hack: use the node id for the trait, also as\n+                    // the node id for the Self type parameter.\n+                    let opt_self = Some(ty::GenericParamDef {\n+                        index: 0,\n+                        name: kw::SelfUpper,\n+                        def_id,\n+                        pure_wrt_drop: false,\n+                        kind: ty::GenericParamDefKind::Type {\n+                            has_default: false,\n+                            synthetic: false,\n+                        },\n+                    });\n+\n+                    (opt_self, Defaults::Allowed)\n+                }\n+                ItemKind::TyAlias(..)\n+                | ItemKind::Enum(..)\n+                | ItemKind::Struct(..)\n+                | ItemKind::OpaqueTy(..)\n+                | ItemKind::Union(..) => (None, Defaults::Allowed),\n+                _ => (None, Defaults::FutureCompatDisallowed),\n+            }\n+        }\n+\n+        // GATs\n+        Node::TraitItem(item) if matches!(item.kind, TraitItemKind::Type(..)) => {\n+            (None, Defaults::Deny)\n+        }\n+        Node::ImplItem(item) if matches!(item.kind, ImplItemKind::TyAlias(..)) => {\n+            (None, Defaults::Deny)\n+        }\n+\n+        _ => (None, Defaults::FutureCompatDisallowed),\n+    };\n+\n+    let has_self = opt_self.is_some();\n+    let mut parent_has_self = false;\n+    let mut own_start = has_self as u32;\n+    let parent_count = parent_def_id.map_or(0, |def_id| {\n+        let generics = tcx.generics_of(def_id);\n+        assert!(!has_self);\n+        parent_has_self = generics.has_self;\n+        own_start = generics.count() as u32;\n+        generics.parent_count + generics.params.len()\n+    });\n+\n+    let mut params: Vec<_> = Vec::with_capacity(ast_generics.params.len() + has_self as usize);\n+\n+    if let Some(opt_self) = opt_self {\n+        params.push(opt_self);\n+    }\n+\n+    let early_lifetimes = super::early_bound_lifetimes_from_generics(tcx, ast_generics);\n+    params.extend(early_lifetimes.enumerate().map(|(i, param)| ty::GenericParamDef {\n+        name: param.name.ident().name,\n+        index: own_start + i as u32,\n+        def_id: tcx.hir().local_def_id(param.hir_id).to_def_id(),\n+        pure_wrt_drop: param.pure_wrt_drop,\n+        kind: ty::GenericParamDefKind::Lifetime,\n+    }));\n+\n+    // Now create the real type and const parameters.\n+    let type_start = own_start - has_self as u32 + params.len() as u32;\n+    let mut i = 0;\n+\n+    const TYPE_DEFAULT_NOT_ALLOWED: &'static str = \"defaults for type parameters are only allowed in \\\n+    `struct`, `enum`, `type`, or `trait` definitions\";\n+\n+    params.extend(ast_generics.params.iter().filter_map(|param| match param.kind {\n+        GenericParamKind::Lifetime { .. } => None,\n+        GenericParamKind::Type { ref default, synthetic, .. } => {\n+            if default.is_some() {\n+                match allow_defaults {\n+                    Defaults::Allowed => {}\n+                    Defaults::FutureCompatDisallowed\n+                        if tcx.features().default_type_parameter_fallback => {}\n+                    Defaults::FutureCompatDisallowed => {\n+                        tcx.struct_span_lint_hir(\n+                            lint::builtin::INVALID_TYPE_PARAM_DEFAULT,\n+                            param.hir_id,\n+                            param.span,\n+                            |lint| {\n+                                lint.build(TYPE_DEFAULT_NOT_ALLOWED).emit();\n+                            },\n+                        );\n+                    }\n+                    Defaults::Deny => {\n+                        tcx.sess.span_err(param.span, TYPE_DEFAULT_NOT_ALLOWED);\n+                    }\n+                }\n+            }\n+\n+            let kind = ty::GenericParamDefKind::Type { has_default: default.is_some(), synthetic };\n+\n+            let param_def = ty::GenericParamDef {\n+                index: type_start + i as u32,\n+                name: param.name.ident().name,\n+                def_id: tcx.hir().local_def_id(param.hir_id).to_def_id(),\n+                pure_wrt_drop: param.pure_wrt_drop,\n+                kind,\n+            };\n+            i += 1;\n+            Some(param_def)\n+        }\n+        GenericParamKind::Const { default, .. } => {\n+            if !matches!(allow_defaults, Defaults::Allowed) && default.is_some() {\n+                tcx.sess.span_err(\n+                    param.span,\n+                    \"defaults for const parameters are only allowed in \\\n+                    `struct`, `enum`, `type`, or `trait` definitions\",\n+                );\n+            }\n+\n+            let param_def = ty::GenericParamDef {\n+                index: type_start + i as u32,\n+                name: param.name.ident().name,\n+                def_id: tcx.hir().local_def_id(param.hir_id).to_def_id(),\n+                pure_wrt_drop: param.pure_wrt_drop,\n+                kind: ty::GenericParamDefKind::Const { has_default: default.is_some() },\n+            };\n+            i += 1;\n+            Some(param_def)\n+        }\n+    }));\n+\n+    // provide junk type parameter defs - the only place that\n+    // cares about anything but the length is instantiation,\n+    // and we don't do that for closures.\n+    if let Node::Expr(&hir::Expr {\n+        kind: hir::ExprKind::Closure(hir::Closure { movability: gen, .. }),\n+        ..\n+    }) = node\n+    {\n+        let dummy_args = if gen.is_some() {\n+            &[\"<resume_ty>\", \"<yield_ty>\", \"<return_ty>\", \"<witness>\", \"<upvars>\"][..]\n+        } else {\n+            &[\"<closure_kind>\", \"<closure_signature>\", \"<upvars>\"][..]\n+        };\n+\n+        params.extend(dummy_args.iter().enumerate().map(|(i, &arg)| ty::GenericParamDef {\n+            index: type_start + i as u32,\n+            name: Symbol::intern(arg),\n+            def_id,\n+            pure_wrt_drop: false,\n+            kind: ty::GenericParamDefKind::Type { has_default: false, synthetic: false },\n+        }));\n+    }\n+\n+    // provide junk type parameter defs for const blocks.\n+    if let Node::AnonConst(_) = node {\n+        let parent_node = tcx.hir().get(tcx.hir().get_parent_node(hir_id));\n+        if let Node::Expr(&Expr { kind: ExprKind::ConstBlock(_), .. }) = parent_node {\n+            params.push(ty::GenericParamDef {\n+                index: type_start,\n+                name: Symbol::intern(\"<const_ty>\"),\n+                def_id,\n+                pure_wrt_drop: false,\n+                kind: ty::GenericParamDefKind::Type { has_default: false, synthetic: false },\n+            });\n+        }\n+    }\n+\n+    let param_def_id_to_index = params.iter().map(|param| (param.def_id, param.index)).collect();\n+\n+    ty::Generics {\n+        parent: parent_def_id,\n+        parent_count,\n+        params,\n+        param_def_id_to_index,\n+        has_self: has_self || parent_has_self,\n+        has_late_bound_regions: has_late_bound_regions(tcx, node),\n+    }\n+}\n+\n+fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<Span> {\n+    struct LateBoundRegionsDetector<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+        outer_index: ty::DebruijnIndex,\n+        has_late_bound_regions: Option<Span>,\n+    }\n+\n+    impl<'tcx> Visitor<'tcx> for LateBoundRegionsDetector<'tcx> {\n+        fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n+            if self.has_late_bound_regions.is_some() {\n+                return;\n+            }\n+            match ty.kind {\n+                hir::TyKind::BareFn(..) => {\n+                    self.outer_index.shift_in(1);\n+                    intravisit::walk_ty(self, ty);\n+                    self.outer_index.shift_out(1);\n+                }\n+                _ => intravisit::walk_ty(self, ty),\n+            }\n+        }\n+\n+        fn visit_poly_trait_ref(&mut self, tr: &'tcx hir::PolyTraitRef<'tcx>) {\n+            if self.has_late_bound_regions.is_some() {\n+                return;\n+            }\n+            self.outer_index.shift_in(1);\n+            intravisit::walk_poly_trait_ref(self, tr);\n+            self.outer_index.shift_out(1);\n+        }\n+\n+        fn visit_lifetime(&mut self, lt: &'tcx hir::Lifetime) {\n+            if self.has_late_bound_regions.is_some() {\n+                return;\n+            }\n+\n+            match self.tcx.named_region(lt.hir_id) {\n+                Some(rl::Region::Static | rl::Region::EarlyBound(..)) => {}\n+                Some(rl::Region::LateBound(debruijn, _, _)) if debruijn < self.outer_index => {}\n+                Some(rl::Region::LateBound(..) | rl::Region::Free(..)) | None => {\n+                    self.has_late_bound_regions = Some(lt.span);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn has_late_bound_regions<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        generics: &'tcx hir::Generics<'tcx>,\n+        decl: &'tcx hir::FnDecl<'tcx>,\n+    ) -> Option<Span> {\n+        let mut visitor = LateBoundRegionsDetector {\n+            tcx,\n+            outer_index: ty::INNERMOST,\n+            has_late_bound_regions: None,\n+        };\n+        for param in generics.params {\n+            if let GenericParamKind::Lifetime { .. } = param.kind {\n+                if tcx.is_late_bound(param.hir_id) {\n+                    return Some(param.span);\n+                }\n+            }\n+        }\n+        visitor.visit_fn_decl(decl);\n+        visitor.has_late_bound_regions\n+    }\n+\n+    match node {\n+        Node::TraitItem(item) => match item.kind {\n+            hir::TraitItemKind::Fn(ref sig, _) => {\n+                has_late_bound_regions(tcx, &item.generics, sig.decl)\n+            }\n+            _ => None,\n+        },\n+        Node::ImplItem(item) => match item.kind {\n+            hir::ImplItemKind::Fn(ref sig, _) => {\n+                has_late_bound_regions(tcx, &item.generics, sig.decl)\n+            }\n+            _ => None,\n+        },\n+        Node::ForeignItem(item) => match item.kind {\n+            hir::ForeignItemKind::Fn(fn_decl, _, ref generics) => {\n+                has_late_bound_regions(tcx, generics, fn_decl)\n+            }\n+            _ => None,\n+        },\n+        Node::Item(item) => match item.kind {\n+            hir::ItemKind::Fn(ref sig, .., ref generics, _) => {\n+                has_late_bound_regions(tcx, generics, sig.decl)\n+            }\n+            _ => None,\n+        },\n+        _ => None,\n+    }\n+}\n+\n+struct AnonConstInParamTyDetector {\n+    in_param_ty: bool,\n+    found_anon_const_in_param_ty: bool,\n+    ct: HirId,\n+}\n+\n+impl<'v> Visitor<'v> for AnonConstInParamTyDetector {\n+    fn visit_generic_param(&mut self, p: &'v hir::GenericParam<'v>) {\n+        if let GenericParamKind::Const { ty, default: _ } = p.kind {\n+            let prev = self.in_param_ty;\n+            self.in_param_ty = true;\n+            self.visit_ty(ty);\n+            self.in_param_ty = prev;\n+        }\n+    }\n+\n+    fn visit_anon_const(&mut self, c: &'v hir::AnonConst) {\n+        if self.in_param_ty && self.ct == c.hir_id {\n+            self.found_anon_const_in_param_ty = true;\n+        } else {\n+            intravisit::walk_anon_const(self, c)\n+        }\n+    }\n+}"}, {"sha": "db8f8de68f29d6ebb4ebbf7f9647a76b5f1460b5", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "added", "additions": 707, "deletions": 0, "changes": 707, "blob_url": "https://github.com/rust-lang/rust/blob/6367e69929bef8cbfbbde0d2218476a470f41f90/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6367e69929bef8cbfbbde0d2218476a470f41f90/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=6367e69929bef8cbfbbde0d2218476a470f41f90", "patch": "@@ -0,0 +1,707 @@\n+use crate::astconv::AstConv;\n+use crate::bounds::Bounds;\n+use crate::collect::ItemCtxt;\n+use crate::constrained_generic_params as cgp;\n+use hir::{HirId, Node};\n+use rustc_data_structures::fx::FxIndexSet;\n+use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::intravisit::{self, Visitor};\n+use rustc_middle::ty::subst::InternalSubsts;\n+use rustc_middle::ty::ToPredicate;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_span::symbol::{sym, Ident};\n+use rustc_span::{Span, DUMMY_SP};\n+\n+#[derive(Debug)]\n+struct OnlySelfBounds(bool);\n+\n+/// Returns a list of all type predicates (explicit and implicit) for the definition with\n+/// ID `def_id`. This includes all predicates returned by `predicates_defined_on`, plus\n+/// `Self: Trait` predicates for traits.\n+pub(super) fn predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicates<'_> {\n+    let mut result = tcx.predicates_defined_on(def_id);\n+\n+    if tcx.is_trait(def_id) {\n+        // For traits, add `Self: Trait` predicate. This is\n+        // not part of the predicates that a user writes, but it\n+        // is something that one must prove in order to invoke a\n+        // method or project an associated type.\n+        //\n+        // In the chalk setup, this predicate is not part of the\n+        // \"predicates\" for a trait item. But it is useful in\n+        // rustc because if you directly (e.g.) invoke a trait\n+        // method like `Trait::method(...)`, you must naturally\n+        // prove that the trait applies to the types that were\n+        // used, and adding the predicate into this list ensures\n+        // that this is done.\n+        //\n+        // We use a DUMMY_SP here as a way to signal trait bounds that come\n+        // from the trait itself that *shouldn't* be shown as the source of\n+        // an obligation and instead be skipped. Otherwise we'd use\n+        // `tcx.def_span(def_id);`\n+\n+        let constness = if tcx.has_attr(def_id, sym::const_trait) {\n+            ty::BoundConstness::ConstIfConst\n+        } else {\n+            ty::BoundConstness::NotConst\n+        };\n+\n+        let span = rustc_span::DUMMY_SP;\n+        result.predicates =\n+            tcx.arena.alloc_from_iter(result.predicates.iter().copied().chain(std::iter::once((\n+                ty::TraitRef::identity(tcx, def_id).with_constness(constness).to_predicate(tcx),\n+                span,\n+            ))));\n+    }\n+    debug!(\"predicates_of(def_id={:?}) = {:?}\", def_id, result);\n+    result\n+}\n+\n+/// Returns a list of user-specified type predicates for the definition with ID `def_id`.\n+/// N.B., this does not include any implied/inferred constraints.\n+#[instrument(level = \"trace\", skip(tcx), ret)]\n+fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicates<'_> {\n+    use rustc_hir::*;\n+\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+    let node = tcx.hir().get(hir_id);\n+\n+    let mut is_trait = None;\n+    let mut is_default_impl_trait = None;\n+\n+    let icx = ItemCtxt::new(tcx, def_id);\n+\n+    const NO_GENERICS: &hir::Generics<'_> = hir::Generics::empty();\n+\n+    // We use an `IndexSet` to preserves order of insertion.\n+    // Preserving the order of insertion is important here so as not to break UI tests.\n+    let mut predicates: FxIndexSet<(ty::Predicate<'_>, Span)> = FxIndexSet::default();\n+\n+    let ast_generics = match node {\n+        Node::TraitItem(item) => item.generics,\n+\n+        Node::ImplItem(item) => item.generics,\n+\n+        Node::Item(item) => {\n+            match item.kind {\n+                ItemKind::Impl(ref impl_) => {\n+                    if impl_.defaultness.is_default() {\n+                        is_default_impl_trait = tcx.impl_trait_ref(def_id).map(ty::Binder::dummy);\n+                    }\n+                    &impl_.generics\n+                }\n+                ItemKind::Fn(.., ref generics, _)\n+                | ItemKind::TyAlias(_, ref generics)\n+                | ItemKind::Enum(_, ref generics)\n+                | ItemKind::Struct(_, ref generics)\n+                | ItemKind::Union(_, ref generics) => *generics,\n+\n+                ItemKind::Trait(_, _, ref generics, ..) => {\n+                    is_trait = Some(ty::TraitRef::identity(tcx, def_id));\n+                    *generics\n+                }\n+                ItemKind::TraitAlias(ref generics, _) => {\n+                    is_trait = Some(ty::TraitRef::identity(tcx, def_id));\n+                    *generics\n+                }\n+                ItemKind::OpaqueTy(OpaqueTy {\n+                    origin: hir::OpaqueTyOrigin::AsyncFn(..) | hir::OpaqueTyOrigin::FnReturn(..),\n+                    ..\n+                }) => {\n+                    // return-position impl trait\n+                    //\n+                    // We don't inherit predicates from the parent here:\n+                    // If we have, say `fn f<'a, T: 'a>() -> impl Sized {}`\n+                    // then the return type is `f::<'static, T>::{{opaque}}`.\n+                    //\n+                    // If we inherited the predicates of `f` then we would\n+                    // require that `T: 'static` to show that the return\n+                    // type is well-formed.\n+                    //\n+                    // The only way to have something with this opaque type\n+                    // is from the return type of the containing function,\n+                    // which will ensure that the function's predicates\n+                    // hold.\n+                    return ty::GenericPredicates { parent: None, predicates: &[] };\n+                }\n+                ItemKind::OpaqueTy(OpaqueTy {\n+                    ref generics,\n+                    origin: hir::OpaqueTyOrigin::TyAlias,\n+                    ..\n+                }) => {\n+                    // type-alias impl trait\n+                    generics\n+                }\n+\n+                _ => NO_GENERICS,\n+            }\n+        }\n+\n+        Node::ForeignItem(item) => match item.kind {\n+            ForeignItemKind::Static(..) => NO_GENERICS,\n+            ForeignItemKind::Fn(_, _, ref generics) => *generics,\n+            ForeignItemKind::Type => NO_GENERICS,\n+        },\n+\n+        _ => NO_GENERICS,\n+    };\n+\n+    let generics = tcx.generics_of(def_id);\n+    let parent_count = generics.parent_count as u32;\n+    let has_own_self = generics.has_self && parent_count == 0;\n+\n+    // Below we'll consider the bounds on the type parameters (including `Self`)\n+    // and the explicit where-clauses, but to get the full set of predicates\n+    // on a trait we need to add in the supertrait bounds and bounds found on\n+    // associated types.\n+    if let Some(_trait_ref) = is_trait {\n+        predicates.extend(tcx.super_predicates_of(def_id).predicates.iter().cloned());\n+    }\n+\n+    // In default impls, we can assume that the self type implements\n+    // the trait. So in:\n+    //\n+    //     default impl Foo for Bar { .. }\n+    //\n+    // we add a default where clause `Foo: Bar`. We do a similar thing for traits\n+    // (see below). Recall that a default impl is not itself an impl, but rather a\n+    // set of defaults that can be incorporated into another impl.\n+    if let Some(trait_ref) = is_default_impl_trait {\n+        predicates.insert((trait_ref.without_const().to_predicate(tcx), tcx.def_span(def_id)));\n+    }\n+\n+    // Collect the region predicates that were declared inline as\n+    // well. In the case of parameters declared on a fn or method, we\n+    // have to be careful to only iterate over early-bound regions.\n+    let mut index = parent_count\n+        + has_own_self as u32\n+        + super::early_bound_lifetimes_from_generics(tcx, ast_generics).count() as u32;\n+\n+    trace!(?predicates);\n+    trace!(?ast_generics);\n+\n+    // Collect the predicates that were written inline by the user on each\n+    // type parameter (e.g., `<T: Foo>`).\n+    for param in ast_generics.params {\n+        match param.kind {\n+            // We already dealt with early bound lifetimes above.\n+            GenericParamKind::Lifetime { .. } => (),\n+            GenericParamKind::Type { .. } => {\n+                let name = param.name.ident().name;\n+                let param_ty = ty::ParamTy::new(index, name).to_ty(tcx);\n+                index += 1;\n+\n+                let mut bounds = Bounds::default();\n+                // Params are implicitly sized unless a `?Sized` bound is found\n+                <dyn AstConv<'_>>::add_implicitly_sized(\n+                    &icx,\n+                    &mut bounds,\n+                    &[],\n+                    Some((param.hir_id, ast_generics.predicates)),\n+                    param.span,\n+                );\n+                trace!(?bounds);\n+                predicates.extend(bounds.predicates(tcx, param_ty));\n+                trace!(?predicates);\n+            }\n+            GenericParamKind::Const { .. } => {\n+                // Bounds on const parameters are currently not possible.\n+                index += 1;\n+            }\n+        }\n+    }\n+\n+    trace!(?predicates);\n+    // Add in the bounds that appear in the where-clause.\n+    for predicate in ast_generics.predicates {\n+        match predicate {\n+            hir::WherePredicate::BoundPredicate(bound_pred) => {\n+                let ty = icx.to_ty(bound_pred.bounded_ty);\n+                let bound_vars = icx.tcx.late_bound_vars(bound_pred.hir_id);\n+\n+                // Keep the type around in a dummy predicate, in case of no bounds.\n+                // That way, `where Ty:` is not a complete noop (see #53696) and `Ty`\n+                // is still checked for WF.\n+                if bound_pred.bounds.is_empty() {\n+                    if let ty::Param(_) = ty.kind() {\n+                        // This is a `where T:`, which can be in the HIR from the\n+                        // transformation that moves `?Sized` to `T`'s declaration.\n+                        // We can skip the predicate because type parameters are\n+                        // trivially WF, but also we *should*, to avoid exposing\n+                        // users who never wrote `where Type:,` themselves, to\n+                        // compiler/tooling bugs from not handling WF predicates.\n+                    } else {\n+                        let span = bound_pred.bounded_ty.span;\n+                        let predicate = ty::Binder::bind_with_vars(\n+                            ty::PredicateKind::WellFormed(ty.into()),\n+                            bound_vars,\n+                        );\n+                        predicates.insert((predicate.to_predicate(tcx), span));\n+                    }\n+                }\n+\n+                let mut bounds = Bounds::default();\n+                <dyn AstConv<'_>>::add_bounds(\n+                    &icx,\n+                    ty,\n+                    bound_pred.bounds.iter(),\n+                    &mut bounds,\n+                    bound_vars,\n+                );\n+                predicates.extend(bounds.predicates(tcx, ty));\n+            }\n+\n+            hir::WherePredicate::RegionPredicate(region_pred) => {\n+                let r1 = <dyn AstConv<'_>>::ast_region_to_region(&icx, &region_pred.lifetime, None);\n+                predicates.extend(region_pred.bounds.iter().map(|bound| {\n+                    let (r2, span) = match bound {\n+                        hir::GenericBound::Outlives(lt) => {\n+                            (<dyn AstConv<'_>>::ast_region_to_region(&icx, lt, None), lt.span)\n+                        }\n+                        _ => bug!(),\n+                    };\n+                    let pred = ty::Binder::dummy(ty::PredicateKind::RegionOutlives(\n+                        ty::OutlivesPredicate(r1, r2),\n+                    ))\n+                    .to_predicate(icx.tcx);\n+\n+                    (pred, span)\n+                }))\n+            }\n+\n+            hir::WherePredicate::EqPredicate(..) => {\n+                // FIXME(#20041)\n+            }\n+        }\n+    }\n+\n+    if tcx.features().generic_const_exprs {\n+        predicates.extend(const_evaluatable_predicates_of(tcx, def_id.expect_local()));\n+    }\n+\n+    let mut predicates: Vec<_> = predicates.into_iter().collect();\n+\n+    // Subtle: before we store the predicates into the tcx, we\n+    // sort them so that predicates like `T: Foo<Item=U>` come\n+    // before uses of `U`.  This avoids false ambiguity errors\n+    // in trait checking. See `setup_constraining_predicates`\n+    // for details.\n+    if let Node::Item(&Item { kind: ItemKind::Impl { .. }, .. }) = node {\n+        let self_ty = tcx.type_of(def_id);\n+        let trait_ref = tcx.impl_trait_ref(def_id);\n+        cgp::setup_constraining_predicates(\n+            tcx,\n+            &mut predicates,\n+            trait_ref,\n+            &mut cgp::parameters_for_impl(self_ty, trait_ref),\n+        );\n+    }\n+\n+    ty::GenericPredicates {\n+        parent: generics.parent,\n+        predicates: tcx.arena.alloc_from_iter(predicates),\n+    }\n+}\n+\n+fn const_evaluatable_predicates_of<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: LocalDefId,\n+) -> FxIndexSet<(ty::Predicate<'tcx>, Span)> {\n+    struct ConstCollector<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+        preds: FxIndexSet<(ty::Predicate<'tcx>, Span)>,\n+    }\n+\n+    impl<'tcx> intravisit::Visitor<'tcx> for ConstCollector<'tcx> {\n+        fn visit_anon_const(&mut self, c: &'tcx hir::AnonConst) {\n+            let def_id = self.tcx.hir().local_def_id(c.hir_id);\n+            let ct = ty::Const::from_anon_const(self.tcx, def_id);\n+            if let ty::ConstKind::Unevaluated(uv) = ct.kind() {\n+                let span = self.tcx.hir().span(c.hir_id);\n+                self.preds.insert((\n+                    ty::Binder::dummy(ty::PredicateKind::ConstEvaluatable(uv))\n+                        .to_predicate(self.tcx),\n+                    span,\n+                ));\n+            }\n+        }\n+\n+        fn visit_const_param_default(&mut self, _param: HirId, _ct: &'tcx hir::AnonConst) {\n+            // Do not look into const param defaults,\n+            // these get checked when they are actually instantiated.\n+            //\n+            // We do not want the following to error:\n+            //\n+            //     struct Foo<const N: usize, const M: usize = { N + 1 }>;\n+            //     struct Bar<const N: usize>(Foo<N, 3>);\n+        }\n+    }\n+\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+    let node = tcx.hir().get(hir_id);\n+\n+    let mut collector = ConstCollector { tcx, preds: FxIndexSet::default() };\n+    if let hir::Node::Item(item) = node && let hir::ItemKind::Impl(ref impl_) = item.kind {\n+        if let Some(of_trait) = &impl_.of_trait {\n+            debug!(\"const_evaluatable_predicates_of({:?}): visit impl trait_ref\", def_id);\n+            collector.visit_trait_ref(of_trait);\n+        }\n+\n+        debug!(\"const_evaluatable_predicates_of({:?}): visit_self_ty\", def_id);\n+        collector.visit_ty(impl_.self_ty);\n+    }\n+\n+    if let Some(generics) = node.generics() {\n+        debug!(\"const_evaluatable_predicates_of({:?}): visit_generics\", def_id);\n+        collector.visit_generics(generics);\n+    }\n+\n+    if let Some(fn_sig) = tcx.hir().fn_sig_by_hir_id(hir_id) {\n+        debug!(\"const_evaluatable_predicates_of({:?}): visit_fn_decl\", def_id);\n+        collector.visit_fn_decl(fn_sig.decl);\n+    }\n+    debug!(\"const_evaluatable_predicates_of({:?}) = {:?}\", def_id, collector.preds);\n+\n+    collector.preds\n+}\n+\n+pub(super) fn trait_explicit_predicates_and_bounds(\n+    tcx: TyCtxt<'_>,\n+    def_id: LocalDefId,\n+) -> ty::GenericPredicates<'_> {\n+    assert_eq!(tcx.def_kind(def_id), DefKind::Trait);\n+    gather_explicit_predicates_of(tcx, def_id.to_def_id())\n+}\n+\n+pub(super) fn explicit_predicates_of<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+) -> ty::GenericPredicates<'tcx> {\n+    let def_kind = tcx.def_kind(def_id);\n+    if let DefKind::Trait = def_kind {\n+        // Remove bounds on associated types from the predicates, they will be\n+        // returned by `explicit_item_bounds`.\n+        let predicates_and_bounds = tcx.trait_explicit_predicates_and_bounds(def_id.expect_local());\n+        let trait_identity_substs = InternalSubsts::identity_for_item(tcx, def_id);\n+\n+        let is_assoc_item_ty = |ty: Ty<'tcx>| {\n+            // For a predicate from a where clause to become a bound on an\n+            // associated type:\n+            // * It must use the identity substs of the item.\n+            //     * Since any generic parameters on the item are not in scope,\n+            //       this means that the item is not a GAT, and its identity\n+            //       substs are the same as the trait's.\n+            // * It must be an associated type for this trait (*not* a\n+            //   supertrait).\n+            if let ty::Projection(projection) = ty.kind() {\n+                projection.substs == trait_identity_substs\n+                    && tcx.associated_item(projection.item_def_id).container_id(tcx) == def_id\n+            } else {\n+                false\n+            }\n+        };\n+\n+        let predicates: Vec<_> = predicates_and_bounds\n+            .predicates\n+            .iter()\n+            .copied()\n+            .filter(|(pred, _)| match pred.kind().skip_binder() {\n+                ty::PredicateKind::Trait(tr) => !is_assoc_item_ty(tr.self_ty()),\n+                ty::PredicateKind::Projection(proj) => {\n+                    !is_assoc_item_ty(proj.projection_ty.self_ty())\n+                }\n+                ty::PredicateKind::TypeOutlives(outlives) => !is_assoc_item_ty(outlives.0),\n+                _ => true,\n+            })\n+            .collect();\n+        if predicates.len() == predicates_and_bounds.predicates.len() {\n+            predicates_and_bounds\n+        } else {\n+            ty::GenericPredicates {\n+                parent: predicates_and_bounds.parent,\n+                predicates: tcx.arena.alloc_slice(&predicates),\n+            }\n+        }\n+    } else {\n+        if matches!(def_kind, DefKind::AnonConst) && tcx.lazy_normalization() {\n+            let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+            if tcx.hir().opt_const_param_default_param_hir_id(hir_id).is_some() {\n+                // In `generics_of` we set the generics' parent to be our parent's parent which means that\n+                // we lose out on the predicates of our actual parent if we dont return those predicates here.\n+                // (See comment in `generics_of` for more information on why the parent shenanigans is necessary)\n+                //\n+                // struct Foo<T, const N: usize = { <T as Trait>::ASSOC }>(T) where T: Trait;\n+                //        ^^^                     ^^^^^^^^^^^^^^^^^^^^^^^ the def id we are calling\n+                //        ^^^                                             explicit_predicates_of on\n+                //        parent item we dont have set as the\n+                //        parent of generics returned by `generics_of`\n+                //\n+                // In the above code we want the anon const to have predicates in its param env for `T: Trait`\n+                let item_def_id = tcx.hir().get_parent_item(hir_id);\n+                // In the above code example we would be calling `explicit_predicates_of(Foo)` here\n+                return tcx.explicit_predicates_of(item_def_id);\n+            }\n+        }\n+        gather_explicit_predicates_of(tcx, def_id)\n+    }\n+}\n+\n+/// Ensures that the super-predicates of the trait with a `DefId`\n+/// of `trait_def_id` are converted and stored. This also ensures that\n+/// the transitive super-predicates are converted.\n+pub(super) fn super_predicates_of(\n+    tcx: TyCtxt<'_>,\n+    trait_def_id: DefId,\n+) -> ty::GenericPredicates<'_> {\n+    tcx.super_predicates_that_define_assoc_type((trait_def_id, None))\n+}\n+\n+/// Ensures that the super-predicates of the trait with a `DefId`\n+/// of `trait_def_id` are converted and stored. This also ensures that\n+/// the transitive super-predicates are converted.\n+pub(super) fn super_predicates_that_define_assoc_type(\n+    tcx: TyCtxt<'_>,\n+    (trait_def_id, assoc_name): (DefId, Option<Ident>),\n+) -> ty::GenericPredicates<'_> {\n+    if trait_def_id.is_local() {\n+        debug!(\"local trait\");\n+        let trait_hir_id = tcx.hir().local_def_id_to_hir_id(trait_def_id.expect_local());\n+\n+        let Node::Item(item) = tcx.hir().get(trait_hir_id) else {\n+            bug!(\"trait_node_id {} is not an item\", trait_hir_id);\n+        };\n+\n+        let (generics, bounds) = match item.kind {\n+            hir::ItemKind::Trait(.., ref generics, ref supertraits, _) => (generics, supertraits),\n+            hir::ItemKind::TraitAlias(ref generics, ref supertraits) => (generics, supertraits),\n+            _ => span_bug!(item.span, \"super_predicates invoked on non-trait\"),\n+        };\n+\n+        let icx = ItemCtxt::new(tcx, trait_def_id);\n+\n+        // Convert the bounds that follow the colon, e.g., `Bar + Zed` in `trait Foo: Bar + Zed`.\n+        let self_param_ty = tcx.types.self_param;\n+        let superbounds1 = if let Some(assoc_name) = assoc_name {\n+            <dyn AstConv<'_>>::compute_bounds_that_match_assoc_type(\n+                &icx,\n+                self_param_ty,\n+                bounds,\n+                assoc_name,\n+            )\n+        } else {\n+            <dyn AstConv<'_>>::compute_bounds(&icx, self_param_ty, bounds)\n+        };\n+\n+        let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n+\n+        // Convert any explicit superbounds in the where-clause,\n+        // e.g., `trait Foo where Self: Bar`.\n+        // In the case of trait aliases, however, we include all bounds in the where-clause,\n+        // so e.g., `trait Foo = where u32: PartialEq<Self>` would include `u32: PartialEq<Self>`\n+        // as one of its \"superpredicates\".\n+        let is_trait_alias = tcx.is_trait_alias(trait_def_id);\n+        let superbounds2 = icx.type_parameter_bounds_in_generics(\n+            generics,\n+            item.hir_id(),\n+            self_param_ty,\n+            OnlySelfBounds(!is_trait_alias),\n+            assoc_name,\n+        );\n+\n+        // Combine the two lists to form the complete set of superbounds:\n+        let superbounds = &*tcx.arena.alloc_from_iter(superbounds1.into_iter().chain(superbounds2));\n+        debug!(?superbounds);\n+\n+        // Now require that immediate supertraits are converted,\n+        // which will, in turn, reach indirect supertraits.\n+        if assoc_name.is_none() {\n+            // Now require that immediate supertraits are converted,\n+            // which will, in turn, reach indirect supertraits.\n+            for &(pred, span) in superbounds {\n+                debug!(\"superbound: {:?}\", pred);\n+                if let ty::PredicateKind::Trait(bound) = pred.kind().skip_binder() {\n+                    tcx.at(span).super_predicates_of(bound.def_id());\n+                }\n+            }\n+        }\n+\n+        ty::GenericPredicates { parent: None, predicates: superbounds }\n+    } else {\n+        // if `assoc_name` is None, then the query should've been redirected to an\n+        // external provider\n+        assert!(assoc_name.is_some());\n+        tcx.super_predicates_of(trait_def_id)\n+    }\n+}\n+\n+/// Returns the predicates defined on `item_def_id` of the form\n+/// `X: Foo` where `X` is the type parameter `def_id`.\n+#[instrument(level = \"trace\", skip(tcx))]\n+pub(super) fn type_param_predicates(\n+    tcx: TyCtxt<'_>,\n+    (item_def_id, def_id, assoc_name): (DefId, LocalDefId, Ident),\n+) -> ty::GenericPredicates<'_> {\n+    use rustc_hir::*;\n+\n+    // In the AST, bounds can derive from two places. Either\n+    // written inline like `<T: Foo>` or in a where-clause like\n+    // `where T: Foo`.\n+\n+    let param_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+    let param_owner = tcx.hir().ty_param_owner(def_id);\n+    let generics = tcx.generics_of(param_owner);\n+    let index = generics.param_def_id_to_index[&def_id.to_def_id()];\n+    let ty = tcx.mk_ty_param(index, tcx.hir().ty_param_name(def_id));\n+\n+    // Don't look for bounds where the type parameter isn't in scope.\n+    let parent = if item_def_id == param_owner.to_def_id() {\n+        None\n+    } else {\n+        tcx.generics_of(item_def_id).parent\n+    };\n+\n+    let mut result = parent\n+        .map(|parent| {\n+            let icx = ItemCtxt::new(tcx, parent);\n+            icx.get_type_parameter_bounds(DUMMY_SP, def_id.to_def_id(), assoc_name)\n+        })\n+        .unwrap_or_default();\n+    let mut extend = None;\n+\n+    let item_hir_id = tcx.hir().local_def_id_to_hir_id(item_def_id.expect_local());\n+    let ast_generics = match tcx.hir().get(item_hir_id) {\n+        Node::TraitItem(item) => &item.generics,\n+\n+        Node::ImplItem(item) => &item.generics,\n+\n+        Node::Item(item) => {\n+            match item.kind {\n+                ItemKind::Fn(.., ref generics, _)\n+                | ItemKind::Impl(hir::Impl { ref generics, .. })\n+                | ItemKind::TyAlias(_, ref generics)\n+                | ItemKind::OpaqueTy(OpaqueTy {\n+                    ref generics,\n+                    origin: hir::OpaqueTyOrigin::TyAlias,\n+                    ..\n+                })\n+                | ItemKind::Enum(_, ref generics)\n+                | ItemKind::Struct(_, ref generics)\n+                | ItemKind::Union(_, ref generics) => generics,\n+                ItemKind::Trait(_, _, ref generics, ..) => {\n+                    // Implied `Self: Trait` and supertrait bounds.\n+                    if param_id == item_hir_id {\n+                        let identity_trait_ref = ty::TraitRef::identity(tcx, item_def_id);\n+                        extend =\n+                            Some((identity_trait_ref.without_const().to_predicate(tcx), item.span));\n+                    }\n+                    generics\n+                }\n+                _ => return result,\n+            }\n+        }\n+\n+        Node::ForeignItem(item) => match item.kind {\n+            ForeignItemKind::Fn(_, _, ref generics) => generics,\n+            _ => return result,\n+        },\n+\n+        _ => return result,\n+    };\n+\n+    let icx = ItemCtxt::new(tcx, item_def_id);\n+    let extra_predicates = extend.into_iter().chain(\n+        icx.type_parameter_bounds_in_generics(\n+            ast_generics,\n+            param_id,\n+            ty,\n+            OnlySelfBounds(true),\n+            Some(assoc_name),\n+        )\n+        .into_iter()\n+        .filter(|(predicate, _)| match predicate.kind().skip_binder() {\n+            ty::PredicateKind::Trait(data) => data.self_ty().is_param(index),\n+            _ => false,\n+        }),\n+    );\n+    result.predicates =\n+        tcx.arena.alloc_from_iter(result.predicates.iter().copied().chain(extra_predicates));\n+    result\n+}\n+\n+impl<'tcx> ItemCtxt<'tcx> {\n+    /// Finds bounds from `hir::Generics`. This requires scanning through the\n+    /// AST. We do this to avoid having to convert *all* the bounds, which\n+    /// would create artificial cycles. Instead, we can only convert the\n+    /// bounds for a type parameter `X` if `X::Foo` is used.\n+    #[instrument(level = \"trace\", skip(self, ast_generics))]\n+    fn type_parameter_bounds_in_generics(\n+        &self,\n+        ast_generics: &'tcx hir::Generics<'tcx>,\n+        param_id: hir::HirId,\n+        ty: Ty<'tcx>,\n+        only_self_bounds: OnlySelfBounds,\n+        assoc_name: Option<Ident>,\n+    ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n+        let param_def_id = self.tcx.hir().local_def_id(param_id).to_def_id();\n+        trace!(?param_def_id);\n+        ast_generics\n+            .predicates\n+            .iter()\n+            .filter_map(|wp| match *wp {\n+                hir::WherePredicate::BoundPredicate(ref bp) => Some(bp),\n+                _ => None,\n+            })\n+            .flat_map(|bp| {\n+                let bt = if bp.is_param_bound(param_def_id) {\n+                    Some(ty)\n+                } else if !only_self_bounds.0 {\n+                    Some(self.to_ty(bp.bounded_ty))\n+                } else {\n+                    None\n+                };\n+                let bvars = self.tcx.late_bound_vars(bp.hir_id);\n+\n+                bp.bounds.iter().filter_map(move |b| bt.map(|bt| (bt, b, bvars))).filter(\n+                    |(_, b, _)| match assoc_name {\n+                        Some(assoc_name) => self.bound_defines_assoc_item(b, assoc_name),\n+                        None => true,\n+                    },\n+                )\n+            })\n+            .flat_map(|(bt, b, bvars)| predicates_from_bound(self, bt, b, bvars))\n+            .collect()\n+    }\n+\n+    #[instrument(level = \"trace\", skip(self))]\n+    fn bound_defines_assoc_item(&self, b: &hir::GenericBound<'_>, assoc_name: Ident) -> bool {\n+        match b {\n+            hir::GenericBound::Trait(poly_trait_ref, _) => {\n+                let trait_ref = &poly_trait_ref.trait_ref;\n+                if let Some(trait_did) = trait_ref.trait_def_id() {\n+                    self.tcx.trait_may_define_assoc_type(trait_did, assoc_name)\n+                } else {\n+                    false\n+                }\n+            }\n+            _ => false,\n+        }\n+    }\n+}\n+\n+/// Converts a specific `GenericBound` from the AST into a set of\n+/// predicates that apply to the self type. A vector is returned\n+/// because this can be anywhere from zero predicates (`T: ?Sized` adds no\n+/// predicates) to one (`T: Foo`) to many (`T: Bar<X = i32>` adds `T: Bar`\n+/// and `<T as Bar>::X == i32`).\n+fn predicates_from_bound<'tcx>(\n+    astconv: &dyn AstConv<'tcx>,\n+    param_ty: Ty<'tcx>,\n+    bound: &'tcx hir::GenericBound<'tcx>,\n+    bound_vars: &'tcx ty::List<ty::BoundVariableKind>,\n+) -> Vec<(ty::Predicate<'tcx>, Span)> {\n+    let mut bounds = Bounds::default();\n+    astconv.add_bounds(param_ty, [bound].into_iter(), &mut bounds, bound_vars);\n+    bounds.predicates(astconv.tcx(), param_ty).collect()\n+}"}]}