{"sha": "762137e2121ac8998b5bb916453eb24ec6523450", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2MjEzN2UyMTIxYWM4OTk4YjViYjkxNjQ1M2ViMjRlYzY1MjM0NTA=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2020-08-04T13:34:24Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2020-08-16T14:42:25Z"}, "message": "hir: introduce `QPath::LangItem`\n\nThis commit introduces `QPath::LangItem` to the HIR and uses it in AST\nlowering instead of constructing a `hir::Path` from a slice of symbols.\n\nThis might be better for performance, but is also much cleaner as the\nprevious approach is fragile. In addition, it resolves a bug (#61019)\nwhere an extern crate imported as \"std\" would result in the paths\ncreated during AST lowering being resolved incorrectly (or not at all).\n\nCo-authored-by: Matthew Jasper <mjjasper1@gmail.com>\nSigned-off-by: David Wood <david@davidtw.co>", "tree": {"sha": "f4ab40e388ecea1038ef3c5bac0bf3b97809dc33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4ab40e388ecea1038ef3c5bac0bf3b97809dc33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/762137e2121ac8998b5bb916453eb24ec6523450", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEfgm2/wUjk9OnjxlyJZLnbIc4H9kFAl85RdEACgkQJZLnbIc4\nH9m4yg/+J25i3Ic1wD47c+oNm2fE9Ns/rxRa6V1AswFpOcYUmnTc6qxlvV29ceyo\nG5L4aWV3DclwexEvVokcS49tM1sV5X8PV9iZeDMdVOqUaYfMnNnhtFSaHMiEWMSg\nzJ46IWmeziVE07X//p4Wc2T1tnmlgnKS+fTWhLhl9QkT3YwuPNEw4D8L2NYq5/1R\nNXUu/fA1P2R03BLHXZot1GXrEKT/+yNdspiVM+WPiQCPhyqiMHrHxFA2BWZ0mrQq\nqWlcvNqMk8BEgZZqUqVRbaDxavsgI0E+ujhVaivbZirKSCPeifsv5cvubM8Jx/OI\nsu32qA8vbl/N7E08Da29Qh6pIZOHFhJVxnGAe6n/zskfr0uUBHup7/fbhS0ZvP0S\nf+/flB1rpJLO178qgobcRGbnJD79lxWK7vdQz4LaoxEmN8eGpfCfwnITof+qKCR1\naaA+WlobNOEYUdziv+rpSTf9zRRb5wkmbu9s4RkAB8H7Iqy8SLdyKYIBQoZCtO4I\nRMr378En2e02TOMYG2ndB8mMmSHiMclOoaFVhngkfRMT8S2/WddZnl2Uyie/Tr1+\nXvpz+BcsyiFrLGvxaSr3ASyk4N57fAIkFZ6Jt6T2kRID3izBSZsyv3RxNUB5CQjL\nv7cWXLpQjR8FGvecOt+T4wrlAB+xuCltHSNpKFNAjKFLWTzoEBQ=\n=/z2e\n-----END PGP SIGNATURE-----", "payload": "tree f4ab40e388ecea1038ef3c5bac0bf3b97809dc33\nparent 7dee5f824dad65d9edffb4de22aad248bd83faf9\nauthor David Wood <david@davidtw.co> 1596548064 +0100\ncommitter David Wood <david@davidtw.co> 1597588945 +0100\n\nhir: introduce `QPath::LangItem`\n\nThis commit introduces `QPath::LangItem` to the HIR and uses it in AST\nlowering instead of constructing a `hir::Path` from a slice of symbols.\n\nThis might be better for performance, but is also much cleaner as the\nprevious approach is fragile. In addition, it resolves a bug (#61019)\nwhere an extern crate imported as \"std\" would result in the paths\ncreated during AST lowering being resolved incorrectly (or not at all).\n\nCo-authored-by: Matthew Jasper <mjjasper1@gmail.com>\nSigned-off-by: David Wood <david@davidtw.co>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/762137e2121ac8998b5bb916453eb24ec6523450", "html_url": "https://github.com/rust-lang/rust/commit/762137e2121ac8998b5bb916453eb24ec6523450", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/762137e2121ac8998b5bb916453eb24ec6523450/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7dee5f824dad65d9edffb4de22aad248bd83faf9", "url": "https://api.github.com/repos/rust-lang/rust/commits/7dee5f824dad65d9edffb4de22aad248bd83faf9", "html_url": "https://github.com/rust-lang/rust/commit/7dee5f824dad65d9edffb4de22aad248bd83faf9"}], "stats": {"total": 603, "additions": 289, "deletions": 314}, "files": [{"sha": "65c9cd2e203d18038549203e0c5753a9976cd0b5", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 60, "deletions": 101, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=762137e2121ac8998b5bb916453eb24ec6523450", "patch": "@@ -449,7 +449,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n             // `::std::ops::Try::from_ok($tail_expr)`\n             block.expr = Some(this.wrap_in_try_constructor(\n-                sym::from_ok,\n+                hir::LangItem::TryFromOk,\n                 try_span,\n                 tail_expr,\n                 ok_wrapped_span,\n@@ -461,14 +461,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn wrap_in_try_constructor(\n         &mut self,\n-        method: Symbol,\n+        lang_item: hir::LangItem,\n         method_span: Span,\n         expr: &'hir hir::Expr<'hir>,\n         overall_span: Span,\n     ) -> &'hir hir::Expr<'hir> {\n-        let path = &[sym::ops, sym::Try, method];\n         let constructor =\n-            self.arena.alloc(self.expr_std_path(method_span, path, None, ThinVec::new()));\n+            self.arena.alloc(self.expr_lang_item_path(method_span, lang_item, ThinVec::new()));\n         self.expr_call(overall_span, constructor, std::slice::from_ref(expr))\n     }\n \n@@ -558,12 +557,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // `future::from_generator`:\n         let unstable_span =\n             self.mark_span_with_reason(DesugaringKind::Async, span, self.allow_gen_future.clone());\n-        let gen_future = self.expr_std_path(\n-            unstable_span,\n-            &[sym::future, sym::from_generator],\n-            None,\n-            ThinVec::new(),\n-        );\n+        let gen_future =\n+            self.expr_lang_item_path(unstable_span, hir::LangItem::FromGenerator, ThinVec::new());\n \n         // `future::from_generator(generator)`:\n         hir::ExprKind::Call(self.arena.alloc(gen_future), arena_vec![self; generator])\n@@ -630,23 +625,19 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // Use of `await` outside of an async context, we cannot use `task_context` here.\n                 self.expr_err(span)\n             };\n-            let pin_ty_id = self.next_id();\n-            let new_unchecked_expr_kind = self.expr_call_std_assoc_fn(\n-                pin_ty_id,\n+            let new_unchecked = self.expr_call_lang_item_fn_mut(\n                 span,\n-                &[sym::pin, sym::Pin],\n-                \"new_unchecked\",\n+                hir::LangItem::PinNewUnchecked,\n                 arena_vec![self; ref_mut_pinned],\n             );\n-            let new_unchecked = self.expr(span, new_unchecked_expr_kind, ThinVec::new());\n-            let get_context = self.expr_call_std_path_mut(\n+            let get_context = self.expr_call_lang_item_fn_mut(\n                 gen_future_span,\n-                &[sym::future, sym::get_context],\n+                hir::LangItem::GetContext,\n                 arena_vec![self; task_context],\n             );\n-            let call = self.expr_call_std_path(\n+            let call = self.expr_call_lang_item_fn(\n                 span,\n-                &[sym::future, sym::Future, sym::poll],\n+                hir::LangItem::FuturePoll,\n                 arena_vec![self; new_unchecked, get_context],\n             );\n             self.arena.alloc(self.expr_unsafe(call))\n@@ -659,11 +650,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             let x_ident = Ident::with_dummy_span(sym::result);\n             let (x_pat, x_pat_hid) = self.pat_ident(span, x_ident);\n             let x_expr = self.expr_ident(span, x_ident, x_pat_hid);\n-            let ready_pat = self.pat_std_enum(\n-                span,\n-                &[sym::task, sym::Poll, sym::Ready],\n-                arena_vec![self; x_pat],\n-            );\n+            let ready_field = self.single_pat_field(span, x_pat);\n+            let ready_pat = self.pat_lang_item_variant(span, hir::LangItem::PollReady, ready_field);\n             let break_x = self.with_loop_scope(loop_node_id, move |this| {\n                 let expr_break =\n                     hir::ExprKind::Break(this.lower_loop_destination(None), Some(x_expr));\n@@ -674,7 +662,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         // `::std::task::Poll::Pending => {}`\n         let pending_arm = {\n-            let pending_pat = self.pat_std_enum(span, &[sym::task, sym::Poll, sym::Pending], &[]);\n+            let pending_pat = self.pat_lang_item_variant(span, hir::LangItem::PollPending, &[]);\n             let empty_block = self.expr_block_empty(span);\n             self.arm(pending_pat, empty_block)\n         };\n@@ -842,16 +830,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     /// Desugar `<start>..=<end>` into `std::ops::RangeInclusive::new(<start>, <end>)`.\n     fn lower_expr_range_closed(&mut self, span: Span, e1: &Expr, e2: &Expr) -> hir::ExprKind<'hir> {\n-        let id = self.next_id();\n         let e1 = self.lower_expr_mut(e1);\n         let e2 = self.lower_expr_mut(e2);\n-        self.expr_call_std_assoc_fn(\n-            id,\n-            span,\n-            &[sym::ops, sym::RangeInclusive],\n-            \"new\",\n-            arena_vec![self; e1, e2],\n-        )\n+        let fn_path = hir::QPath::LangItem(hir::LangItem::RangeInclusiveNew, span);\n+        let fn_expr =\n+            self.arena.alloc(self.expr(span, hir::ExprKind::Path(fn_path), ThinVec::new()));\n+        hir::ExprKind::Call(fn_expr, arena_vec![self; e1, e2])\n     }\n \n     fn lower_expr_range(\n@@ -863,12 +847,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> hir::ExprKind<'hir> {\n         use rustc_ast::ast::RangeLimits::*;\n \n-        let path = match (e1, e2, lims) {\n-            (None, None, HalfOpen) => sym::RangeFull,\n-            (Some(..), None, HalfOpen) => sym::RangeFrom,\n-            (None, Some(..), HalfOpen) => sym::RangeTo,\n-            (Some(..), Some(..), HalfOpen) => sym::Range,\n-            (None, Some(..), Closed) => sym::RangeToInclusive,\n+        let lang_item = match (e1, e2, lims) {\n+            (None, None, HalfOpen) => hir::LangItem::RangeFull,\n+            (Some(..), None, HalfOpen) => hir::LangItem::RangeFrom,\n+            (None, Some(..), HalfOpen) => hir::LangItem::RangeTo,\n+            (Some(..), Some(..), HalfOpen) => hir::LangItem::Range,\n+            (None, Some(..), Closed) => hir::LangItem::RangeToInclusive,\n             (Some(..), Some(..), Closed) => unreachable!(),\n             (_, None, Closed) => {\n                 self.diagnostic().span_fatal(span, \"inclusive range with no end\").raise()\n@@ -883,16 +867,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }),\n         );\n \n-        let is_unit = fields.is_empty();\n-        let struct_path = [sym::ops, path];\n-        let struct_path = self.std_path(span, &struct_path, None, is_unit);\n-        let struct_path = hir::QPath::Resolved(None, struct_path);\n-\n-        if is_unit {\n-            hir::ExprKind::Path(struct_path)\n-        } else {\n-            hir::ExprKind::Struct(self.arena.alloc(struct_path), fields, None)\n-        }\n+        hir::ExprKind::Struct(self.arena.alloc(hir::QPath::LangItem(lang_item, span)), fields, None)\n     }\n \n     fn lower_loop_destination(&mut self, destination: Option<(NodeId, Label)>) -> hir::Destination {\n@@ -1412,9 +1387,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let match_expr = {\n             let iter = self.expr_ident(desugared_span, iter, iter_pat_nid);\n             let ref_mut_iter = self.expr_mut_addr_of(desugared_span, iter);\n-            let next_path = &[sym::iter, sym::Iterator, sym::next];\n-            let next_expr =\n-                self.expr_call_std_path(desugared_span, next_path, arena_vec![self; ref_mut_iter]);\n+            let next_expr = self.expr_call_lang_item_fn(\n+                desugared_span,\n+                hir::LangItem::IteratorNext,\n+                arena_vec![self; ref_mut_iter],\n+            );\n             let arms = arena_vec![self; pat_arm, break_arm];\n \n             self.expr_match(desugared_span, next_expr, arms, hir::MatchSource::ForLoopDesugar)\n@@ -1472,8 +1449,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n         let into_iter_expr = {\n-            let into_iter_path = &[sym::iter, sym::IntoIterator, sym::into_iter];\n-            self.expr_call_std_path(into_iter_span, into_iter_path, arena_vec![self; head])\n+            self.expr_call_lang_item_fn(\n+                into_iter_span,\n+                hir::LangItem::IntoIterIntoIter,\n+                arena_vec![self; head],\n+            )\n         };\n \n         let match_expr = self.arena.alloc(self.expr_match(\n@@ -1521,8 +1501,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             // expand <expr>\n             let sub_expr = self.lower_expr_mut(sub_expr);\n \n-            let path = &[sym::ops, sym::Try, sym::into_result];\n-            self.expr_call_std_path(unstable_span, path, arena_vec![self; sub_expr])\n+            self.expr_call_lang_item_fn(\n+                unstable_span,\n+                hir::LangItem::TryIntoResult,\n+                arena_vec![self; sub_expr],\n+            )\n         };\n \n         // `#[allow(unreachable_code)]`\n@@ -1558,12 +1541,19 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             let err_ident = Ident::with_dummy_span(sym::err);\n             let (err_local, err_local_nid) = self.pat_ident(try_span, err_ident);\n             let from_expr = {\n-                let from_path = &[sym::convert, sym::From, sym::from];\n                 let err_expr = self.expr_ident_mut(try_span, err_ident, err_local_nid);\n-                self.expr_call_std_path(try_span, from_path, arena_vec![self; err_expr])\n+                self.expr_call_lang_item_fn(\n+                    try_span,\n+                    hir::LangItem::FromFrom,\n+                    arena_vec![self; err_expr],\n+                )\n             };\n-            let from_err_expr =\n-                self.wrap_in_try_constructor(sym::from_error, unstable_span, from_expr, try_span);\n+            let from_err_expr = self.wrap_in_try_constructor(\n+                hir::LangItem::TryFromError,\n+                unstable_span,\n+                from_expr,\n+                try_span,\n+            );\n             let thin_attrs = ThinVec::from(attrs);\n             let catch_scope = self.catch_scopes.last().copied();\n             let ret_expr = if let Some(catch_node) = catch_scope {\n@@ -1674,63 +1664,32 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         self.arena.alloc(self.expr_call_mut(span, e, args))\n     }\n \n-    // Note: associated functions must use `expr_call_std_path`.\n-    fn expr_call_std_path_mut(\n+    fn expr_call_lang_item_fn_mut(\n         &mut self,\n         span: Span,\n-        path_components: &[Symbol],\n+        lang_item: hir::LangItem,\n         args: &'hir [hir::Expr<'hir>],\n     ) -> hir::Expr<'hir> {\n-        let path =\n-            self.arena.alloc(self.expr_std_path(span, path_components, None, ThinVec::new()));\n+        let path = self.arena.alloc(self.expr_lang_item_path(span, lang_item, ThinVec::new()));\n         self.expr_call_mut(span, path, args)\n     }\n \n-    fn expr_call_std_path(\n+    fn expr_call_lang_item_fn(\n         &mut self,\n         span: Span,\n-        path_components: &[Symbol],\n+        lang_item: hir::LangItem,\n         args: &'hir [hir::Expr<'hir>],\n     ) -> &'hir hir::Expr<'hir> {\n-        self.arena.alloc(self.expr_call_std_path_mut(span, path_components, args))\n-    }\n-\n-    // Create an expression calling an associated function of an std type.\n-    //\n-    // Associated functions cannot be resolved through the normal `std_path` function,\n-    // as they are resolved differently and so cannot use `expr_call_std_path`.\n-    //\n-    // This function accepts the path component (`ty_path_components`) separately from\n-    // the name of the associated function (`assoc_fn_name`) in order to facilitate\n-    // separate resolution of the type and creation of a path referring to its associated\n-    // function.\n-    fn expr_call_std_assoc_fn(\n-        &mut self,\n-        ty_path_id: hir::HirId,\n-        span: Span,\n-        ty_path_components: &[Symbol],\n-        assoc_fn_name: &str,\n-        args: &'hir [hir::Expr<'hir>],\n-    ) -> hir::ExprKind<'hir> {\n-        let ty_path = self.std_path(span, ty_path_components, None, false);\n-        let ty =\n-            self.arena.alloc(self.ty_path(ty_path_id, span, hir::QPath::Resolved(None, ty_path)));\n-        let fn_seg = self.arena.alloc(hir::PathSegment::from_ident(Ident::from_str(assoc_fn_name)));\n-        let fn_path = hir::QPath::TypeRelative(ty, fn_seg);\n-        let fn_expr =\n-            self.arena.alloc(self.expr(span, hir::ExprKind::Path(fn_path), ThinVec::new()));\n-        hir::ExprKind::Call(fn_expr, args)\n+        self.arena.alloc(self.expr_call_lang_item_fn_mut(span, lang_item, args))\n     }\n \n-    fn expr_std_path(\n+    fn expr_lang_item_path(\n         &mut self,\n         span: Span,\n-        components: &[Symbol],\n-        params: Option<&'hir hir::GenericArgs<'hir>>,\n+        lang_item: hir::LangItem,\n         attrs: AttrVec,\n     ) -> hir::Expr<'hir> {\n-        let path = self.std_path(span, components, params, true);\n-        self.expr(span, hir::ExprKind::Path(hir::QPath::Resolved(None, path)), attrs)\n+        self.expr(span, hir::ExprKind::Path(hir::QPath::LangItem(lang_item, span)), attrs)\n     }\n \n     pub(super) fn expr_ident("}, {"sha": "a2962008a6bd453facf6c28380ba2df4d26af186", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 34, "deletions": 76, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=762137e2121ac8998b5bb916453eb24ec6523450", "patch": "@@ -85,8 +85,6 @@ const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n rustc_hir::arena_types!(rustc_arena::declare_arena, [], 'tcx);\n \n struct LoweringContext<'a, 'hir: 'a> {\n-    crate_root: Option<Symbol>,\n-\n     /// Used to assign IDs to HIR nodes that do not directly correspond to AST nodes.\n     sess: &'a Session,\n \n@@ -189,16 +187,6 @@ pub trait ResolverAstLowering {\n     /// This should only return `None` during testing.\n     fn definitions(&mut self) -> &mut Definitions;\n \n-    /// Given suffix `[\"b\", \"c\", \"d\"]`, creates an AST path for `[::crate_root]::b::c::d` and\n-    /// resolves it based on `is_value`.\n-    fn resolve_str_path(\n-        &mut self,\n-        span: Span,\n-        crate_root: Option<Symbol>,\n-        components: &[Symbol],\n-        ns: Namespace,\n-    ) -> (ast::Path, Res<NodeId>);\n-\n     fn lint_buffer(&mut self) -> &mut LintBuffer;\n \n     fn next_node_id(&mut self) -> NodeId;\n@@ -305,7 +293,6 @@ pub fn lower_crate<'a, 'hir>(\n     let _prof_timer = sess.prof.verbose_generic_activity(\"hir_lowering\");\n \n     LoweringContext {\n-        crate_root: sess.parse_sess.injected_crate_name.get().copied(),\n         sess,\n         resolver,\n         nt_to_tokenstream,\n@@ -2064,23 +2051,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         };\n \n         // \"<Output = T>\"\n-        let future_params = self.arena.alloc(hir::GenericArgs {\n+        let future_args = self.arena.alloc(hir::GenericArgs {\n             args: &[],\n             bindings: arena_vec![self; self.output_ty_binding(span, output_ty)],\n             parenthesized: false,\n         });\n \n-        // ::std::future::Future<future_params>\n-        let future_path =\n-            self.std_path(span, &[sym::future, sym::Future], Some(future_params), false);\n-\n-        hir::GenericBound::Trait(\n-            hir::PolyTraitRef {\n-                trait_ref: hir::TraitRef { path: future_path, hir_ref_id: self.next_id() },\n-                bound_generic_params: &[],\n-                span,\n-            },\n-            hir::TraitBoundModifier::None,\n+        hir::GenericBound::LangItemTrait(\n+            // ::std::future::Future<future_params>\n+            hir::LangItem::FutureTraitLangItem,\n+            span,\n+            self.next_id(),\n+            future_args,\n         )\n     }\n \n@@ -2480,35 +2462,47 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn pat_ok(&mut self, span: Span, pat: &'hir hir::Pat<'hir>) -> &'hir hir::Pat<'hir> {\n-        self.pat_std_enum(span, &[sym::result, sym::Result, sym::Ok], arena_vec![self; pat])\n+        let field = self.single_pat_field(span, pat);\n+        self.pat_lang_item_variant(span, hir::LangItem::ResultOk, field)\n     }\n \n     fn pat_err(&mut self, span: Span, pat: &'hir hir::Pat<'hir>) -> &'hir hir::Pat<'hir> {\n-        self.pat_std_enum(span, &[sym::result, sym::Result, sym::Err], arena_vec![self; pat])\n+        let field = self.single_pat_field(span, pat);\n+        self.pat_lang_item_variant(span, hir::LangItem::ResultErr, field)\n     }\n \n     fn pat_some(&mut self, span: Span, pat: &'hir hir::Pat<'hir>) -> &'hir hir::Pat<'hir> {\n-        self.pat_std_enum(span, &[sym::option, sym::Option, sym::Some], arena_vec![self; pat])\n+        let field = self.single_pat_field(span, pat);\n+        self.pat_lang_item_variant(span, hir::LangItem::OptionSome, field)\n     }\n \n     fn pat_none(&mut self, span: Span) -> &'hir hir::Pat<'hir> {\n-        self.pat_std_enum(span, &[sym::option, sym::Option, sym::None], &[])\n+        self.pat_lang_item_variant(span, hir::LangItem::OptionNone, &[])\n     }\n \n-    fn pat_std_enum(\n+    fn single_pat_field(\n         &mut self,\n         span: Span,\n-        components: &[Symbol],\n-        subpats: &'hir [&'hir hir::Pat<'hir>],\n-    ) -> &'hir hir::Pat<'hir> {\n-        let path = self.std_path(span, components, None, true);\n-        let qpath = hir::QPath::Resolved(None, path);\n-        let pt = if subpats.is_empty() {\n-            hir::PatKind::Path(qpath)\n-        } else {\n-            hir::PatKind::TupleStruct(qpath, subpats, None)\n+        pat: &'hir hir::Pat<'hir>,\n+    ) -> &'hir [hir::FieldPat<'hir>] {\n+        let field = hir::FieldPat {\n+            hir_id: self.next_id(),\n+            ident: Ident::new(sym::integer(0), span),\n+            is_shorthand: false,\n+            pat,\n+            span,\n         };\n-        self.pat(span, pt)\n+        arena_vec![self; field]\n+    }\n+\n+    fn pat_lang_item_variant(\n+        &mut self,\n+        span: Span,\n+        lang_item: hir::LangItem,\n+        fields: &'hir [hir::FieldPat<'hir>],\n+    ) -> &'hir hir::Pat<'hir> {\n+        let qpath = hir::QPath::LangItem(lang_item, span);\n+        self.pat(span, hir::PatKind::Struct(qpath, fields, false))\n     }\n \n     fn pat_ident(&mut self, span: Span, ident: Ident) -> (&'hir hir::Pat<'hir>, hir::HirId) {\n@@ -2541,42 +2535,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.arena.alloc(hir::Pat { hir_id: self.next_id(), kind, span })\n     }\n \n-    /// Given a suffix `[\"b\", \"c\", \"d\"]`, returns path `::std::b::c::d` when\n-    /// `fld.cx.use_std`, and `::core::b::c::d` otherwise.\n-    /// The path is also resolved according to `is_value`.\n-    fn std_path(\n-        &mut self,\n-        span: Span,\n-        components: &[Symbol],\n-        params: Option<&'hir hir::GenericArgs<'hir>>,\n-        is_value: bool,\n-    ) -> &'hir hir::Path<'hir> {\n-        let ns = if is_value { Namespace::ValueNS } else { Namespace::TypeNS };\n-        let (path, res) = self.resolver.resolve_str_path(span, self.crate_root, components, ns);\n-\n-        let mut segments: Vec<_> = path\n-            .segments\n-            .iter()\n-            .map(|segment| {\n-                let res = self.expect_full_res(segment.id);\n-                hir::PathSegment {\n-                    ident: segment.ident,\n-                    hir_id: Some(self.lower_node_id(segment.id)),\n-                    res: Some(self.lower_res(res)),\n-                    infer_args: true,\n-                    args: None,\n-                }\n-            })\n-            .collect();\n-        segments.last_mut().unwrap().args = params;\n-\n-        self.arena.alloc(hir::Path {\n-            span,\n-            res: res.map_id(|_| panic!(\"unexpected `NodeId`\")),\n-            segments: self.arena.alloc_from_iter(segments),\n-        })\n-    }\n-\n     fn ty_path(\n         &mut self,\n         mut hir_id: hir::HirId,"}, {"sha": "e1ec60bcc0a2ce28209e9c84a0a3be72dbe1b4f6", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 45, "deletions": 5, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=762137e2121ac8998b5bb916453eb24ec6523450", "patch": "@@ -1,7 +1,7 @@\n use crate::def::{DefKind, Namespace, Res};\n use crate::def_id::DefId;\n crate use crate::hir_id::HirId;\n-use crate::itemlikevisit;\n+use crate::{itemlikevisit, LangItem};\n \n use rustc_ast::ast::{self, CrateSugar, LlvmAsmDialect};\n use rustc_ast::ast::{AttrVec, Attribute, FloatTy, IntTy, Label, LitKind, StrStyle, UintTy};\n@@ -363,6 +363,8 @@ pub enum TraitBoundModifier {\n #[derive(Debug, HashStable_Generic)]\n pub enum GenericBound<'hir> {\n     Trait(PolyTraitRef<'hir>, TraitBoundModifier),\n+    // FIXME(davidtwco): Introduce `PolyTraitRef::LangItem`\n+    LangItemTrait(LangItem, Span, HirId, &'hir GenericArgs<'hir>),\n     Outlives(Lifetime),\n }\n \n@@ -377,6 +379,7 @@ impl GenericBound<'_> {\n     pub fn span(&self) -> Span {\n         match self {\n             &GenericBound::Trait(ref t, ..) => t.span,\n+            &GenericBound::LangItemTrait(_, span, ..) => span,\n             &GenericBound::Outlives(ref l) => l.span,\n         }\n     }\n@@ -1419,10 +1422,10 @@ impl Expr<'_> {\n         self.is_place_expr(|_| true)\n     }\n \n-    // Whether this is a place expression.\n-    // `allow_projections_from` should return `true` if indexing a field or\n-    // index expression based on the given expression should be considered a\n-    // place expression.\n+    /// Whether this is a place expression.\n+    ///\n+    /// `allow_projections_from` should return `true` if indexing a field or index expression based\n+    /// on the given expression should be considered a place expression.\n     pub fn is_place_expr(&self, mut allow_projections_from: impl FnMut(&Self) -> bool) -> bool {\n         match self.kind {\n             ExprKind::Path(QPath::Resolved(_, ref path)) => match path.res {\n@@ -1441,6 +1444,9 @@ impl Expr<'_> {\n                 allow_projections_from(base) || base.is_place_expr(allow_projections_from)\n             }\n \n+            // Lang item paths cannot currently be local variables or statics.\n+            ExprKind::Path(QPath::LangItem(..)) => false,\n+\n             // Partially qualified paths in expressions can only legally\n             // refer to associated items which are always rvalues.\n             ExprKind::Path(QPath::TypeRelative(..))\n@@ -1677,6 +1683,40 @@ pub enum QPath<'hir> {\n     /// `<Vec>::new`, and `T::X::Y::method` into `<<<T>::X>::Y>::method`,\n     /// the `X` and `Y` nodes each being a `TyKind::Path(QPath::TypeRelative(..))`.\n     TypeRelative(&'hir Ty<'hir>, &'hir PathSegment<'hir>),\n+\n+    /// Reference to a `#[lang = \"foo\"]` item.\n+    LangItem(LangItem, Span),\n+}\n+\n+impl<'hir> QPath<'hir> {\n+    /// Returns the span of this `QPath`.\n+    pub fn span(&self) -> Span {\n+        match *self {\n+            QPath::Resolved(_, path) => path.span,\n+            QPath::TypeRelative(_, ps) => ps.ident.span,\n+            QPath::LangItem(_, span) => span,\n+        }\n+    }\n+\n+    /// Returns the span of the qself of this `QPath`. For example, `()` in\n+    /// `<() as Trait>::method`.\n+    pub fn qself_span(&self) -> Span {\n+        match *self {\n+            QPath::Resolved(_, path) => path.span,\n+            QPath::TypeRelative(qself, _) => qself.span,\n+            QPath::LangItem(_, span) => span,\n+        }\n+    }\n+\n+    /// Returns the span of the last segment of this `QPath`. For example, `method` in\n+    /// `<() as Trait>::method`.\n+    pub fn last_segment_span(&self) -> Span {\n+        match *self {\n+            QPath::Resolved(_, path) => path.segments.last().unwrap().ident.span,\n+            QPath::TypeRelative(_, segment) => segment.ident.span,\n+            QPath::LangItem(_, span) => span,\n+        }\n+    }\n }\n \n /// Hints at the original code for a let statement."}, {"sha": "66ef017713447938fed8def1c8a2a2354745c3a5", "filename": "src/librustc_hir/intravisit.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_hir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_hir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fintravisit.rs?ref=762137e2121ac8998b5bb916453eb24ec6523450", "patch": "@@ -724,6 +724,7 @@ pub fn walk_qpath<'v, V: Visitor<'v>>(\n             visitor.visit_ty(qself);\n             visitor.visit_path_segment(span, segment);\n         }\n+        QPath::LangItem(..) => {}\n     }\n }\n \n@@ -838,6 +839,10 @@ pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v GenericB\n         GenericBound::Trait(ref typ, modifier) => {\n             visitor.visit_poly_trait_ref(typ, modifier);\n         }\n+        GenericBound::LangItemTrait(_, span, hir_id, args) => {\n+            visitor.visit_id(hir_id);\n+            visitor.visit_generic_args(span, args);\n+        }\n         GenericBound::Outlives(ref lifetime) => visitor.visit_lifetime(lifetime),\n     }\n }"}, {"sha": "e124db9e355dd4db3abde6d96cca2cea039e9f53", "filename": "src/librustc_hir_pretty/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_hir_pretty%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_hir_pretty%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir_pretty%2Flib.rs?ref=762137e2121ac8998b5bb916453eb24ec6523450", "patch": "@@ -1729,6 +1729,11 @@ impl<'a> State<'a> {\n                     colons_before_params,\n                 )\n             }\n+            hir::QPath::LangItem(lang_item, span) => {\n+                self.s.word(\"#[lang = \\\"\");\n+                self.print_ident(Ident::new(lang_item.name(), span));\n+                self.s.word(\"\\\"]\");\n+            }\n         }\n     }\n \n@@ -2142,6 +2147,11 @@ impl<'a> State<'a> {\n                     }\n                     self.print_poly_trait_ref(tref);\n                 }\n+                GenericBound::LangItemTrait(lang_item, span, ..) => {\n+                    self.s.word(\"#[lang = \\\"\");\n+                    self.print_ident(Ident::new(lang_item.name(), *span));\n+                    self.s.word(\"\\\"]\");\n+                }\n                 GenericBound::Outlives(lt) => {\n                     self.print_lifetime(lt);\n                 }"}, {"sha": "97830e6c86f39eef373c547ee2515fb35f6c93c0", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=762137e2121ac8998b5bb916453eb24ec6523450", "patch": "@@ -1057,7 +1057,7 @@ impl TypeAliasBounds {\n                     _ => false,\n                 }\n             }\n-            hir::QPath::Resolved(..) => false,\n+            hir::QPath::Resolved(..) | hir::QPath::LangItem(..) => false,\n         }\n     }\n "}, {"sha": "5b91b77e4f02dc074e42c3ee8767c95dde998110", "filename": "src/librustc_lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_lint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_lint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fcontext.rs?ref=762137e2121ac8998b5bb916453eb24ec6523450", "patch": "@@ -703,7 +703,7 @@ impl<'tcx> LateContext<'tcx> {\n     pub fn qpath_res(&self, qpath: &hir::QPath<'_>, id: hir::HirId) -> Res {\n         match *qpath {\n             hir::QPath::Resolved(_, ref path) => path.res,\n-            hir::QPath::TypeRelative(..) => self\n+            hir::QPath::TypeRelative(..) | hir::QPath::LangItem(..) => self\n                 .maybe_typeck_results()\n                 .and_then(|typeck_results| typeck_results.type_dependent_def(id))\n                 .map_or(Res::Err, |(kind, def_id)| Res::Def(kind, def_id)),"}, {"sha": "3b10cb53885069a3fa100695e5bae0e8ef082e1c", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=762137e2121ac8998b5bb916453eb24ec6523450", "patch": "@@ -445,7 +445,7 @@ impl<'tcx> TypeckResults<'tcx> {\n     pub fn qpath_res(&self, qpath: &hir::QPath<'_>, id: hir::HirId) -> Res {\n         match *qpath {\n             hir::QPath::Resolved(_, ref path) => path.res,\n-            hir::QPath::TypeRelative(..) => self\n+            hir::QPath::TypeRelative(..) | hir::QPath::LangItem(..) => self\n                 .type_dependent_def(id)\n                 .map_or(Res::Err, |(kind, def_id)| Res::Def(kind, def_id)),\n         }"}, {"sha": "62c8680a8579899f50ae9fe30cee6994a29cc51e", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=762137e2121ac8998b5bb916453eb24ec6523450", "patch": "@@ -526,7 +526,8 @@ fn visit_expr<'tcx>(ir: &mut IrMaps<'tcx>, expr: &'tcx Expr<'tcx>) {\n         | hir::ExprKind::Yield(..)\n         | hir::ExprKind::Type(..)\n         | hir::ExprKind::Err\n-        | hir::ExprKind::Path(hir::QPath::TypeRelative(..)) => {\n+        | hir::ExprKind::Path(hir::QPath::TypeRelative(..))\n+        | hir::ExprKind::Path(hir::QPath::LangItem(..)) => {\n             intravisit::walk_expr(ir, expr);\n         }\n     }\n@@ -1310,7 +1311,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n             hir::ExprKind::Lit(..)\n             | hir::ExprKind::Err\n-            | hir::ExprKind::Path(hir::QPath::TypeRelative(..)) => succ,\n+            | hir::ExprKind::Path(hir::QPath::TypeRelative(..))\n+            | hir::ExprKind::Path(hir::QPath::LangItem(..)) => succ,\n \n             // Note that labels have been resolved, so we don't need to look\n             // at the label ident"}, {"sha": "deb4277cb3854bce0ca3630f5fe831b3e0864266", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=762137e2121ac8998b5bb916453eb24ec6523450", "patch": "@@ -1325,7 +1325,7 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n                 Res::Def(kind, def_id) => Some((kind, def_id)),\n                 _ => None,\n             },\n-            hir::QPath::TypeRelative(..) => self\n+            hir::QPath::TypeRelative(..) | hir::QPath::LangItem(..) => self\n                 .maybe_typeck_results\n                 .and_then(|typeck_results| typeck_results.type_dependent_def(id)),\n         };\n@@ -1340,7 +1340,9 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n                 let sess = self.tcx.sess;\n                 let sm = sess.source_map();\n                 let name = match qpath {\n-                    hir::QPath::Resolved(_, path) => sm.span_to_snippet(path.span).ok(),\n+                    hir::QPath::Resolved(..) | hir::QPath::LangItem(..) => {\n+                        sm.span_to_snippet(qpath.span()).ok()\n+                    }\n                     hir::QPath::TypeRelative(_, segment) => Some(segment.ident.to_string()),\n                 };\n                 let kind = kind.descr(def_id);"}, {"sha": "32b8ea410ad22c5b837173a379eea1524074df80", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=762137e2121ac8998b5bb916453eb24ec6523450", "patch": "@@ -1076,37 +1076,6 @@ impl ResolverAstLowering for Resolver<'_> {\n         self.cstore().item_generics_num_lifetimes(def_id, sess)\n     }\n \n-    fn resolve_str_path(\n-        &mut self,\n-        span: Span,\n-        crate_root: Option<Symbol>,\n-        components: &[Symbol],\n-        ns: Namespace,\n-    ) -> (ast::Path, Res) {\n-        let root = if crate_root.is_some() { kw::PathRoot } else { kw::Crate };\n-        let segments = iter::once(Ident::with_dummy_span(root))\n-            .chain(\n-                crate_root\n-                    .into_iter()\n-                    .chain(components.iter().cloned())\n-                    .map(Ident::with_dummy_span),\n-            )\n-            .map(|i| self.new_ast_path_segment(i))\n-            .collect::<Vec<_>>();\n-\n-        let path = ast::Path { span, segments };\n-\n-        let parent_scope = &ParentScope::module(self.graph_root);\n-        let res = match self.resolve_ast_path(&path, ns, parent_scope) {\n-            Ok(res) => res,\n-            Err((span, error)) => {\n-                self.report_error(span, error);\n-                Res::Err\n-            }\n-        };\n-        (path, res)\n-    }\n-\n     fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes> {\n         self.partial_res_map.get(&id).cloned()\n     }"}, {"sha": "c1c165a9901f820fc857988a5383dd23969d851c", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=762137e2121ac8998b5bb916453eb24ec6523450", "patch": "@@ -705,6 +705,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n             let trait_ref = match *super_bound {\n                 hir::GenericBound::Trait(ref trait_ref, _) => trait_ref,\n                 hir::GenericBound::Outlives(..) => continue,\n+                hir::GenericBound::LangItemTrait(..) => unimplemented!(),\n             };\n \n             let trait_ref = &trait_ref.trait_ref;\n@@ -765,6 +766,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         let span = match path {\n             hir::QPath::Resolved(_, path) => path.span,\n             hir::QPath::TypeRelative(_, segment) => segment.ident.span,\n+            hir::QPath::LangItem(..) => unimplemented!(),\n         };\n         if self.span.filter_generated(span) {\n             return;\n@@ -783,6 +785,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 self.visit_ty(ty);\n                 std::slice::from_ref(*segment)\n             }\n+            hir::QPath::LangItem(..) => unimplemented!(),\n         };\n         for seg in segments {\n             if let Some(ref generic_args) = seg.args {\n@@ -1358,6 +1361,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                     let sub_span = match path {\n                         hir::QPath::Resolved(_, path) => path.segments.last().unwrap().ident.span,\n                         hir::QPath::TypeRelative(_, segment) => segment.ident.span,\n+                        hir::QPath::LangItem(..) => unimplemented!(),\n                     };\n                     let span = self.span_from_span(sub_span);\n                     self.dumper.dump_ref(Ref {"}, {"sha": "a7eb344ff09f78818fa0453caf010a0087f58f19", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=762137e2121ac8998b5bb916453eb24ec6523450", "patch": "@@ -555,6 +555,7 @@ impl<'tcx> SaveContext<'tcx> {\n                 let segment = match qpath {\n                     hir::QPath::Resolved(_, path) => path.segments.last().unwrap(),\n                     hir::QPath::TypeRelative(_, segment) => segment,\n+                    hir::QPath::LangItem(..) => unimplemented!(),\n                 };\n                 match ty.kind {\n                     ty::Adt(def, _) => {\n@@ -639,6 +640,7 @@ impl<'tcx> SaveContext<'tcx> {\n                 hir::QPath::TypeRelative(..) => self\n                     .maybe_typeck_results\n                     .map_or(Res::Err, |typeck_results| typeck_results.qpath_res(qpath, hir_id)),\n+                hir::QPath::LangItem(..) => unimplemented!(),\n             },\n \n             Node::Binding(&hir::Pat {\n@@ -653,6 +655,7 @@ impl<'tcx> SaveContext<'tcx> {\n         let segment = match path {\n             hir::QPath::Resolved(_, path) => path.segments.last(),\n             hir::QPath::TypeRelative(_, segment) => Some(*segment),\n+            hir::QPath::LangItem(..) => unimplemented!(),\n         };\n         segment.and_then(|seg| {\n             self.get_path_segment_data(seg).or_else(|| self.get_path_segment_data_with_id(seg, id))"}, {"sha": "6a9ad3c38f496d3b0ed304aee5d2fd0ebdee3e35", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=762137e2121ac8998b5bb916453eb24ec6523450", "patch": "@@ -286,6 +286,7 @@ impl<'hir> Sig for hir::Ty<'hir> {\n                     refs: vec![SigElement { id, start, end }],\n                 })\n             }\n+            hir::TyKind::Path(hir::QPath::LangItem(..)) => unimplemented!(),\n             hir::TyKind::TraitObject(bounds, ..) => {\n                 // FIXME recurse into bounds\n                 let bounds: Vec<hir::GenericBound<'_>> = bounds"}, {"sha": "5e52a5ef16fb55690cd70e9fe1eb6997f36480ec", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=762137e2121ac8998b5bb916453eb24ec6523450", "patch": "@@ -1202,6 +1202,36 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         )\n     }\n \n+    pub fn instantiate_lang_item_trait_ref(\n+        &self,\n+        lang_item: hir::LangItem,\n+        span: Span,\n+        hir_id: hir::HirId,\n+        args: &GenericArgs<'_>,\n+        self_ty: Ty<'tcx>,\n+        bounds: &mut Bounds<'tcx>,\n+    ) {\n+        let trait_def_id = self.tcx().require_lang_item(lang_item, Some(span));\n+\n+        let (substs, assoc_bindings, _) =\n+            self.create_substs_for_ast_path(span, trait_def_id, &[], args, false, Some(self_ty));\n+        let poly_trait_ref = ty::Binder::bind(ty::TraitRef::new(trait_def_id, substs));\n+        bounds.trait_bounds.push((poly_trait_ref, span, Constness::NotConst));\n+\n+        let mut dup_bindings = FxHashMap::default();\n+        for binding in assoc_bindings {\n+            let _: Result<_, ErrorReported> = self.add_predicates_for_ast_type_binding(\n+                hir_id,\n+                poly_trait_ref,\n+                &binding,\n+                bounds,\n+                false,\n+                &mut dup_bindings,\n+                span,\n+            );\n+        }\n+    }\n+\n     fn ast_path_to_mono_trait_ref(\n         &self,\n         span: Span,\n@@ -1392,6 +1422,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     trait_bounds.push((b, Constness::NotConst))\n                 }\n                 hir::GenericBound::Trait(_, hir::TraitBoundModifier::Maybe) => {}\n+                hir::GenericBound::LangItemTrait(lang_item, span, hir_id, args) => self\n+                    .instantiate_lang_item_trait_ref(\n+                        lang_item, span, hir_id, args, param_ty, bounds,\n+                    ),\n                 hir::GenericBound::Outlives(ref l) => region_bounds.push(l),\n             }\n         }\n@@ -2960,6 +2994,18 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     .map(|(ty, _, _)| ty)\n                     .unwrap_or_else(|_| tcx.ty_error())\n             }\n+            hir::TyKind::Path(hir::QPath::LangItem(lang_item, span)) => {\n+                let def_id = tcx.require_lang_item(lang_item, Some(span));\n+                let (substs, _, _) = self.create_substs_for_ast_path(\n+                    span,\n+                    def_id,\n+                    &[],\n+                    &GenericArgs::none(),\n+                    true,\n+                    None,\n+                );\n+                self.normalize_ty(span, tcx.at(span).type_of(def_id).subst(tcx, substs))\n+            }\n             hir::TyKind::Array(ref ty, ref length) => {\n                 let length_def_id = tcx.hir().local_def_id(length.hir_id);\n                 let length = ty::Const::from_anon_const(tcx, length_def_id);"}, {"sha": "e2c90cce178fe01b1a396a1002d7306e7ea8e0a9", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=762137e2121ac8998b5bb916453eb24ec6523450", "patch": "@@ -236,6 +236,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::AddrOf(kind, mutbl, ref oprnd) => {\n                 self.check_expr_addr_of(kind, mutbl, oprnd, expected, expr)\n             }\n+            ExprKind::Path(QPath::LangItem(lang_item, _)) => {\n+                self.check_lang_item_path(lang_item, expr)\n+            }\n             ExprKind::Path(ref qpath) => self.check_expr_path(qpath, expr),\n             ExprKind::InlineAsm(asm) => self.check_expr_asm(asm),\n             ExprKind::LlvmInlineAsm(ref asm) => {\n@@ -447,6 +450,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn check_lang_item_path(\n+        &self,\n+        lang_item: hir::LangItem,\n+        expr: &'tcx hir::Expr<'tcx>,\n+    ) -> Ty<'tcx> {\n+        self.resolve_lang_item_path(lang_item, expr.span, expr.hir_id).1\n+    }\n+\n     fn check_expr_path(&self, qpath: &hir::QPath<'_>, expr: &'tcx hir::Expr<'tcx>) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let (res, opt_ty, segs) = self.resolve_ty_and_res_ufcs(qpath, expr.hir_id, expr.span);\n@@ -1077,11 +1088,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return self.tcx.ty_error();\n         };\n \n-        let path_span = match *qpath {\n-            QPath::Resolved(_, ref path) => path.span,\n-            QPath::TypeRelative(ref qself, _) => qself.span,\n-        };\n-\n         // Prohibit struct expressions when non-exhaustive flag is set.\n         let adt = adt_ty.ty_adt_def().expect(\"`check_struct_path` returned non-ADT type\");\n         if !adt.did.is_local() && variant.is_field_list_non_exhaustive() {\n@@ -1099,7 +1105,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             adt_ty,\n             expected,\n             expr.hir_id,\n-            path_span,\n+            qpath.span(),\n             variant,\n             fields,\n             base_expr.is_none(),"}, {"sha": "c46d2388f3d93e47582ce3507801d49458e48ca7", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=762137e2121ac8998b5bb916453eb24ec6523450", "patch": "@@ -122,10 +122,9 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{self, InternalSubsts, Subst, SubstsRef};\n use rustc_middle::ty::subst::{GenericArgKind, UserSelfTy, UserSubsts};\n use rustc_middle::ty::util::{Discr, IntTypeExt, Representability};\n-use rustc_middle::ty::{\n-    self, AdtKind, CanonicalUserType, Const, GenericParamDefKind, RegionKind, ToPolyTraitRef,\n-    ToPredicate, Ty, TyCtxt, UserType, WithConstness,\n-};\n+use rustc_middle::ty::WithConstness;\n+use rustc_middle::ty::{self, AdtKind, CanonicalUserType, Const, DefIdTree, GenericParamDefKind};\n+use rustc_middle::ty::{RegionKind, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, UserType};\n use rustc_session::config::{self, EntryFnType};\n use rustc_session::lint;\n use rustc_session::parse::feature_err;\n@@ -4430,10 +4429,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         qpath: &QPath<'_>,\n         hir_id: hir::HirId,\n     ) -> Option<(&'tcx ty::VariantDef, Ty<'tcx>)> {\n-        let path_span = match *qpath {\n-            QPath::Resolved(_, ref path) => path.span,\n-            QPath::TypeRelative(ref qself, _) => qself.span,\n-        };\n+        let path_span = qpath.qself_span();\n         let (def, ty) = self.finish_resolving_struct_path(qpath, path_span, hir_id);\n         let variant = match def {\n             Res::Err => {\n@@ -4511,9 +4507,34 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 (result.map(|(kind, def_id)| Res::Def(kind, def_id)).unwrap_or(Res::Err), ty)\n             }\n+            QPath::LangItem(lang_item, span) => {\n+                self.resolve_lang_item_path(lang_item, span, hir_id)\n+            }\n         }\n     }\n \n+    fn resolve_lang_item_path(\n+        &self,\n+        lang_item: hir::LangItem,\n+        span: Span,\n+        hir_id: hir::HirId,\n+    ) -> (Res, Ty<'tcx>) {\n+        let def_id = self.tcx.require_lang_item(lang_item, Some(span));\n+        let def_kind = self.tcx.def_kind(def_id);\n+\n+        let item_ty = if let DefKind::Variant = def_kind {\n+            self.tcx.type_of(self.tcx.parent(def_id).expect(\"variant w/out parent\"))\n+        } else {\n+            self.tcx.type_of(def_id)\n+        };\n+        let substs = self.infcx.fresh_substs_for_item(span, def_id);\n+        let ty = item_ty.subst(self.tcx, substs);\n+\n+        self.write_resolution(hir_id, Ok((def_kind, def_id)));\n+        self.add_required_obligations(span, def_id, &substs);\n+        (Res::Def(def_kind, def_id), ty)\n+    }\n+\n     /// Resolves an associated value path into a base type and associated constant, or method\n     /// resolution. The newly resolved definition is written into `type_dependent_defs`.\n     pub fn resolve_ty_and_res_ufcs<'b>(\n@@ -4532,6 +4553,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n             }\n             QPath::TypeRelative(ref qself, ref segment) => (self.to_ty(qself), qself, segment),\n+            QPath::LangItem(..) => bug!(\"`resolve_ty_and_res_ufcs` called on `LangItem`\"),\n         };\n         if let Some(&cached_result) = self.typeck_results.borrow().type_dependent_defs().get(hir_id)\n         {"}, {"sha": "35c7b7a703cc07f4a2ae27f51735eb87afc24f3b", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=762137e2121ac8998b5bb916453eb24ec6523450", "patch": "@@ -947,13 +947,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 //   |\n                 // L |     let A(()) = A(());\n                 //   |          ^  ^\n-                [] => {\n-                    let qpath_span = match qpath {\n-                        hir::QPath::Resolved(_, path) => path.span,\n-                        hir::QPath::TypeRelative(_, ps) => ps.ident.span,\n-                    };\n-                    (qpath_span.shrink_to_hi(), pat_span)\n-                }\n+                [] => (qpath.span().shrink_to_hi(), pat_span),\n                 // Easy case. Just take the \"lo\" of the first sub-pattern and the \"hi\" of the\n                 // last sub-pattern. In the case of `A(x)` the first and last may coincide.\n                 // This looks like:"}, {"sha": "15743b0643662a3c16b14e57f13b9fea35d68063", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/762137e2121ac8998b5bb916453eb24ec6523450/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=762137e2121ac8998b5bb916453eb24ec6523450", "patch": "@@ -1959,6 +1959,20 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                             predicates.extend(bounds.predicates(tcx, ty));\n                         }\n \n+                        &hir::GenericBound::LangItemTrait(lang_item, span, hir_id, args) => {\n+                            let mut bounds = Bounds::default();\n+                            AstConv::instantiate_lang_item_trait_ref(\n+                                &icx,\n+                                lang_item,\n+                                span,\n+                                hir_id,\n+                                args,\n+                                ty,\n+                                &mut bounds,\n+                            );\n+                            predicates.extend(bounds.predicates(tcx, ty));\n+                        }\n+\n                         &hir::GenericBound::Outlives(ref lifetime) => {\n                             let region = AstConv::ast_region_to_region(&icx, lifetime, None);\n                             predicates.push((\n@@ -2108,6 +2122,18 @@ fn predicates_from_bound<'tcx>(\n             let _ = astconv.instantiate_poly_trait_ref(tr, constness, param_ty, &mut bounds);\n             bounds.predicates(astconv.tcx(), param_ty)\n         }\n+        hir::GenericBound::LangItemTrait(lang_item, span, hir_id, args) => {\n+            let mut bounds = Bounds::default();\n+            astconv.instantiate_lang_item_trait_ref(\n+                lang_item,\n+                span,\n+                hir_id,\n+                args,\n+                param_ty,\n+                &mut bounds,\n+            );\n+            bounds.predicates(astconv.tcx(), param_ty)\n+        }\n         hir::GenericBound::Outlives(ref lifetime) => {\n             let region = astconv.ast_region_to_region(lifetime, None);\n             let pred = ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(param_ty, region))"}, {"sha": "c26cf5fdb5b050cb5944633f62193d2000eec2a4", "filename": "src/test/ui/hygiene/hir-res-hygiene.rs", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/762137e2121ac8998b5bb916453eb24ec6523450/src%2Ftest%2Fui%2Fhygiene%2Fhir-res-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/762137e2121ac8998b5bb916453eb24ec6523450/src%2Ftest%2Fui%2Fhygiene%2Fhir-res-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fhir-res-hygiene.rs?ref=762137e2121ac8998b5bb916453eb24ec6523450", "patch": "@@ -1,27 +1,4 @@\n-//~ ERROR failed to resolve: could not find `future` in `std` [E0433]\n-//~^ ERROR failed to resolve: could not find `pin` in `std` [E0433]\n-//~^^ ERROR failed to resolve: could not find `future` in `std` [E0433]\n-//~^^^ ERROR failed to resolve: could not find `future` in `std` [E0433]\n-//~^^^^ ERROR failed to resolve: could not find `task` in `std` [E0433]\n-//~^^^^^ ERROR failed to resolve: could not find `task` in `std` [E0433]\n-//~^^^^^^ ERROR failed to resolve: could not find `future` in `std` [E0433]\n-//~^^^^^^^ ERROR failed to resolve: could not find `future` in `std` [E0433]\n-//~^^^^^^^^ ERROR failed to resolve: could not find `ops` in `std` [E0433]\n-//~^^^^^^^^^ ERROR failed to resolve: could not find `option` in `std` [E0433]\n-//~^^^^^^^^^^ ERROR failed to resolve: could not find `option` in `std` [E0433]\n-//~^^^^^^^^^^^ ERROR failed to resolve: could not find `iter` in `std` [E0433]\n-//~^^^^^^^^^^^^ ERROR failed to resolve: could not find `iter` in `std` [E0433]\n-//~^^^^^^^^^^^^^ ERROR failed to resolve: could not find `ops` in `std` [E0433]\n-//~^^^^^^^^^^^^^^ ERROR failed to resolve: could not find `option` in `std` [E0433]\n-//~^^^^^^^^^^^^^^^ ERROR failed to resolve: could not find `option` in `std` [E0433]\n-//~^^^^^^^^^^^^^^^^ ERROR failed to resolve: could not find `iter` in `std` [E0433]\n-//~^^^^^^^^^^^^^^^^^ ERROR failed to resolve: could not find `iter` in `std` [E0433]\n-//~^^^^^^^^^^^^^^^^^^ ERROR failed to resolve: could not find `ops` in `std` [E0433]\n-//~^^^^^^^^^^^^^^^^^^^ ERROR failed to resolve: could not find `result` in `std` [E0433]\n-//~^^^^^^^^^^^^^^^^^^^^ ERROR failed to resolve: could not find `convert` in `std` [E0433]\n-//~^^^^^^^^^^^^^^^^^^^^^ ERROR failed to resolve: could not find `ops` in `std` [E0433]\n-//~^^^^^^^^^^^^^^^^^^^^^^ ERROR failed to resolve: could not find `result` in `std` [E0433]\n-\n+// check-pass\n // edition:2018\n // aux-build:not-libstd.rs\n "}, {"sha": "73a1bd5c626320a59a5903afed2525a3c7fcbbad", "filename": "src/test/ui/hygiene/hir-res-hygiene.stderr", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7dee5f824dad65d9edffb4de22aad248bd83faf9/src%2Ftest%2Fui%2Fhygiene%2Fhir-res-hygiene.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7dee5f824dad65d9edffb4de22aad248bd83faf9/src%2Ftest%2Fui%2Fhygiene%2Fhir-res-hygiene.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fhir-res-hygiene.stderr?ref=7dee5f824dad65d9edffb4de22aad248bd83faf9", "patch": "@@ -1,49 +0,0 @@\n-error[E0433]: failed to resolve: could not find `future` in `std`\n-\n-error[E0433]: failed to resolve: could not find `pin` in `std`\n-\n-error[E0433]: failed to resolve: could not find `future` in `std`\n-\n-error[E0433]: failed to resolve: could not find `future` in `std`\n-\n-error[E0433]: failed to resolve: could not find `task` in `std`\n-\n-error[E0433]: failed to resolve: could not find `task` in `std`\n-\n-error[E0433]: failed to resolve: could not find `future` in `std`\n-\n-error[E0433]: failed to resolve: could not find `future` in `std`\n-\n-error[E0433]: failed to resolve: could not find `ops` in `std`\n-\n-error[E0433]: failed to resolve: could not find `option` in `std`\n-\n-error[E0433]: failed to resolve: could not find `option` in `std`\n-\n-error[E0433]: failed to resolve: could not find `iter` in `std`\n-\n-error[E0433]: failed to resolve: could not find `iter` in `std`\n-\n-error[E0433]: failed to resolve: could not find `ops` in `std`\n-\n-error[E0433]: failed to resolve: could not find `option` in `std`\n-\n-error[E0433]: failed to resolve: could not find `option` in `std`\n-\n-error[E0433]: failed to resolve: could not find `iter` in `std`\n-\n-error[E0433]: failed to resolve: could not find `iter` in `std`\n-\n-error[E0433]: failed to resolve: could not find `ops` in `std`\n-\n-error[E0433]: failed to resolve: could not find `result` in `std`\n-\n-error[E0433]: failed to resolve: could not find `convert` in `std`\n-\n-error[E0433]: failed to resolve: could not find `ops` in `std`\n-\n-error[E0433]: failed to resolve: could not find `result` in `std`\n-\n-error: aborting due to 23 previous errors\n-\n-For more information about this error, try `rustc --explain E0433`."}]}