{"sha": "289f3a4ca79916d6445b452fc19a18a1e42a879a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4OWYzYTRjYTc5OTE2ZDY0NDViNDUyZmMxOWExOGExZTQyYTg3OWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-29T18:20:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-29T18:20:02Z"}, "message": "Auto merge of #36377 - tormol:encode_utf, r=alexcrichton\n\nChange encode_utf{8,16}() to write to a buffer and panic if it's too small\n\ncc #27784\n\nShould the \"A buffer that's too small\" examples be removed and replaced by tests?", "tree": {"sha": "ff6191e3e2f803fa54875567235f301ed5a762bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff6191e3e2f803fa54875567235f301ed5a762bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/289f3a4ca79916d6445b452fc19a18a1e42a879a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/289f3a4ca79916d6445b452fc19a18a1e42a879a", "html_url": "https://github.com/rust-lang/rust/commit/289f3a4ca79916d6445b452fc19a18a1e42a879a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/289f3a4ca79916d6445b452fc19a18a1e42a879a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473", "html_url": "https://github.com/rust-lang/rust/commit/ff67da63ea4ca9b19e1e8ee97de002a64a2a0473"}, {"sha": "13a2dd96fe824cc5d61e94ed380db0114efdd014", "url": "https://api.github.com/repos/rust-lang/rust/commits/13a2dd96fe824cc5d61e94ed380db0114efdd014", "html_url": "https://github.com/rust-lang/rust/commit/13a2dd96fe824cc5d61e94ed380db0114efdd014"}], "stats": {"total": 351, "additions": 163, "deletions": 188}, "files": [{"sha": "e4930ae3572085169ecb0cec30ad4dec55636470", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/289f3a4ca79916d6445b452fc19a18a1e42a879a/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/289f3a4ca79916d6445b452fc19a18a1e42a879a/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=289f3a4ca79916d6445b452fc19a18a1e42a879a", "patch": "@@ -975,7 +975,7 @@ impl String {\n     pub fn push(&mut self, ch: char) {\n         match ch.len_utf8() {\n             1 => self.vec.push(ch as u8),\n-            _ => self.vec.extend_from_slice(ch.encode_utf8().as_slice()),\n+            _ => self.vec.extend_from_slice(ch.encode_utf8(&mut [0;4]).as_bytes()),\n         }\n     }\n \n@@ -1131,10 +1131,11 @@ impl String {\n         let len = self.len();\n         assert!(idx <= len);\n         assert!(self.is_char_boundary(idx));\n-        let bits = ch.encode_utf8();\n+        let mut bits = [0; 4];\n+        let bits = ch.encode_utf8(&mut bits).as_bytes();\n \n         unsafe {\n-            self.insert_bytes(idx, bits.as_slice());\n+            self.insert_bytes(idx, bits);\n         }\n     }\n "}, {"sha": "560895f721bbf7aefc8f103bfa2639e532fcf2bd", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/289f3a4ca79916d6445b452fc19a18a1e42a879a/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/289f3a4ca79916d6445b452fc19a18a1e42a879a/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=289f3a4ca79916d6445b452fc19a18a1e42a879a", "patch": "@@ -786,9 +786,9 @@ fn test_rev_iterator() {\n \n #[test]\n fn test_chars_decoding() {\n+    let mut bytes = [0; 4];\n     for c in (0..0x110000).filter_map(::std::char::from_u32) {\n-        let bytes = c.encode_utf8();\n-        let s = ::std::str::from_utf8(bytes.as_slice()).unwrap();\n+        let s = c.encode_utf8(&mut bytes);\n         if Some(c) != s.chars().next() {\n             panic!(\"character {:x}={} does not decode correctly\", c as u32, c);\n         }\n@@ -797,9 +797,9 @@ fn test_chars_decoding() {\n \n #[test]\n fn test_chars_rev_decoding() {\n+    let mut bytes = [0; 4];\n     for c in (0..0x110000).filter_map(::std::char::from_u32) {\n-        let bytes = c.encode_utf8();\n-        let s = ::std::str::from_utf8(bytes.as_slice()).unwrap();\n+        let s = c.encode_utf8(&mut bytes);\n         if Some(c) != s.chars().rev().next() {\n             panic!(\"character {:x}={} does not decode correctly\", c as u32, c);\n         }"}, {"sha": "26d28049a474d3f6d4076a3a52c8092a977963d9", "filename": "src/libcore/char.rs", "status": "modified", "additions": 51, "deletions": 119, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/289f3a4ca79916d6445b452fc19a18a1e42a879a/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/289f3a4ca79916d6445b452fc19a18a1e42a879a/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=289f3a4ca79916d6445b452fc19a18a1e42a879a", "patch": "@@ -18,6 +18,7 @@\n use char_private::is_printable;\n use convert::TryFrom;\n use fmt;\n+use slice;\n use iter::FusedIterator;\n use mem::transmute;\n \n@@ -327,9 +328,9 @@ pub trait CharExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn len_utf16(self) -> usize;\n     #[unstable(feature = \"unicode\", issue = \"27784\")]\n-    fn encode_utf8(self) -> EncodeUtf8;\n+    fn encode_utf8(self, dst: &mut [u8]) -> &mut str;\n     #[unstable(feature = \"unicode\", issue = \"27784\")]\n-    fn encode_utf16(self) -> EncodeUtf16;\n+    fn encode_utf16(self, dst: &mut [u16]) -> &mut [u16];\n }\n \n #[stable(feature = \"core\", since = \"1.6.0\")]\n@@ -419,47 +420,59 @@ impl CharExt for char {\n     }\n \n     #[inline]\n-    fn encode_utf8(self) -> EncodeUtf8 {\n+    fn encode_utf8(self, dst: &mut [u8]) -> &mut str {\n         let code = self as u32;\n-        let mut buf = [0; 4];\n-        let pos = if code < MAX_ONE_B {\n-            buf[3] = code as u8;\n-            3\n-        } else if code < MAX_TWO_B {\n-            buf[2] = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n-            buf[3] = (code & 0x3F) as u8 | TAG_CONT;\n-            2\n-        } else if code < MAX_THREE_B {\n-            buf[1] = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n-            buf[2] = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n-            buf[3] = (code & 0x3F) as u8 | TAG_CONT;\n-            1\n-        } else {\n-            buf[0] = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n-            buf[1] = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n-            buf[2] = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n-            buf[3] = (code & 0x3F) as u8 | TAG_CONT;\n-            0\n-        };\n-        EncodeUtf8 { buf: buf, pos: pos }\n+        unsafe {\n+            let len =\n+            if code < MAX_ONE_B && !dst.is_empty() {\n+                *dst.get_unchecked_mut(0) = code as u8;\n+                1\n+            } else if code < MAX_TWO_B && dst.len() >= 2 {\n+                *dst.get_unchecked_mut(0) = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n+                *dst.get_unchecked_mut(1) = (code & 0x3F) as u8 | TAG_CONT;\n+                2\n+            } else if code < MAX_THREE_B && dst.len() >= 3  {\n+                *dst.get_unchecked_mut(0) = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n+                *dst.get_unchecked_mut(1) = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n+                *dst.get_unchecked_mut(2) = (code & 0x3F) as u8 | TAG_CONT;\n+                3\n+            } else if dst.len() >= 4 {\n+                *dst.get_unchecked_mut(0) = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n+                *dst.get_unchecked_mut(1) = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n+                *dst.get_unchecked_mut(2) = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n+                *dst.get_unchecked_mut(3) = (code & 0x3F) as u8 | TAG_CONT;\n+                4\n+            } else {\n+                panic!(\"encode_utf8: need {} bytes to encode U+{:X}, but the buffer has {}\",\n+                    from_u32_unchecked(code).len_utf8(),\n+                    code,\n+                    dst.len())\n+            };\n+            transmute(slice::from_raw_parts_mut(dst.as_mut_ptr(), len))\n+        }\n     }\n \n     #[inline]\n-    fn encode_utf16(self) -> EncodeUtf16 {\n-        let mut buf = [0; 2];\n+    fn encode_utf16(self, dst: &mut [u16]) -> &mut [u16] {\n         let mut code = self as u32;\n-        let pos = if (code & 0xFFFF) == code {\n-            // The BMP falls through (assuming non-surrogate, as it should)\n-            buf[1] = code as u16;\n-            1\n-        } else {\n-            // Supplementary planes break into surrogates.\n-            code -= 0x1_0000;\n-            buf[0] = 0xD800 | ((code >> 10) as u16);\n-            buf[1] = 0xDC00 | ((code as u16) & 0x3FF);\n-            0\n-        };\n-        EncodeUtf16 { buf: buf, pos: pos }\n+        unsafe {\n+            if (code & 0xFFFF) == code && !dst.is_empty() {\n+                // The BMP falls through (assuming non-surrogate, as it should)\n+                *dst.get_unchecked_mut(0) = code as u16;\n+                slice::from_raw_parts_mut(dst.as_mut_ptr(), 1)\n+            } else if dst.len() >= 2 {\n+                // Supplementary planes break into surrogates.\n+                code -= 0x1_0000;\n+                *dst.get_unchecked_mut(0) = 0xD800 | ((code >> 10) as u16);\n+                *dst.get_unchecked_mut(1) = 0xDC00 | ((code as u16) & 0x3FF);\n+                slice::from_raw_parts_mut(dst.as_mut_ptr(), 2)\n+            } else {\n+                panic!(\"encode_utf16: need {} units to encode U+{:X}, but the buffer has {}\",\n+                    from_u32_unchecked(code).len_utf16(),\n+                    code,\n+                    dst.len())\n+            }\n+        }\n     }\n }\n \n@@ -702,88 +715,7 @@ impl ExactSizeIterator for EscapeDebug { }\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl FusedIterator for EscapeDebug {}\n \n-/// An iterator over `u8` entries represending the UTF-8 encoding of a `char`\n-/// value.\n-///\n-/// Constructed via the `.encode_utf8()` method on `char`.\n-#[unstable(feature = \"unicode\", issue = \"27784\")]\n-#[derive(Debug)]\n-pub struct EncodeUtf8 {\n-    buf: [u8; 4],\n-    pos: usize,\n-}\n-\n-impl EncodeUtf8 {\n-    /// Returns the remaining bytes of this iterator as a slice.\n-    #[unstable(feature = \"unicode\", issue = \"27784\")]\n-    pub fn as_slice(&self) -> &[u8] {\n-        &self.buf[self.pos..]\n-    }\n-}\n-\n-#[unstable(feature = \"unicode\", issue = \"27784\")]\n-impl Iterator for EncodeUtf8 {\n-    type Item = u8;\n-\n-    fn next(&mut self) -> Option<u8> {\n-        if self.pos == self.buf.len() {\n-            None\n-        } else {\n-            let ret = Some(self.buf[self.pos]);\n-            self.pos += 1;\n-            ret\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.as_slice().iter().size_hint()\n-    }\n-}\n-\n-#[unstable(feature = \"fused\", issue = \"35602\")]\n-impl FusedIterator for EncodeUtf8 {}\n-\n-/// An iterator over `u16` entries represending the UTF-16 encoding of a `char`\n-/// value.\n-///\n-/// Constructed via the `.encode_utf16()` method on `char`.\n-#[unstable(feature = \"unicode\", issue = \"27784\")]\n-#[derive(Debug)]\n-pub struct EncodeUtf16 {\n-    buf: [u16; 2],\n-    pos: usize,\n-}\n-\n-impl EncodeUtf16 {\n-    /// Returns the remaining bytes of this iterator as a slice.\n-    #[unstable(feature = \"unicode\", issue = \"27784\")]\n-    pub fn as_slice(&self) -> &[u16] {\n-        &self.buf[self.pos..]\n-    }\n-}\n-\n-\n-#[unstable(feature = \"unicode\", issue = \"27784\")]\n-impl Iterator for EncodeUtf16 {\n-    type Item = u16;\n-\n-    fn next(&mut self) -> Option<u16> {\n-        if self.pos == self.buf.len() {\n-            None\n-        } else {\n-            let ret = Some(self.buf[self.pos]);\n-            self.pos += 1;\n-            ret\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.as_slice().iter().size_hint()\n-    }\n-}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n-impl FusedIterator for EncodeUtf16 {}\n \n /// An iterator over an iterator of bytes of the characters the bytes represent\n /// as UTF-8"}, {"sha": "5d7f41556c25f6ec9e52e70e4f35a4847bc9f605", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/289f3a4ca79916d6445b452fc19a18a1e42a879a/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/289f3a4ca79916d6445b452fc19a18a1e42a879a/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=289f3a4ca79916d6445b452fc19a18a1e42a879a", "patch": "@@ -97,9 +97,7 @@ pub trait Write {\n     /// This function will return an instance of `Error` on error.\n     #[stable(feature = \"fmt_write_char\", since = \"1.1.0\")]\n     fn write_char(&mut self, c: char) -> Result {\n-        self.write_str(unsafe {\n-            str::from_utf8_unchecked(c.encode_utf8().as_slice())\n-        })\n+        self.write_str(c.encode_utf8(&mut [0; 4]))\n     }\n \n     /// Glue for usage of the `write!` macro with implementors of this trait.\n@@ -924,9 +922,7 @@ impl<'a> Formatter<'a> {\n         // Writes the sign if it exists, and then the prefix if it was requested\n         let write_prefix = |f: &mut Formatter| {\n             if let Some(c) = sign {\n-                f.buf.write_str(unsafe {\n-                    str::from_utf8_unchecked(c.encode_utf8().as_slice())\n-                })?;\n+                f.buf.write_str(c.encode_utf8(&mut [0; 4]))?;\n             }\n             if prefixed { f.buf.write_str(prefix) }\n             else { Ok(()) }\n@@ -1032,10 +1028,8 @@ impl<'a> Formatter<'a> {\n             rt::v1::Alignment::Center => (padding / 2, (padding + 1) / 2),\n         };\n \n-        let fill = self.fill.encode_utf8();\n-        let fill = unsafe {\n-            str::from_utf8_unchecked(fill.as_slice())\n-        };\n+        let mut fill = [0; 4];\n+        let fill = self.fill.encode_utf8(&mut fill);\n \n         for _ in 0..pre_pad {\n             self.buf.write_str(fill)?;\n@@ -1435,9 +1429,7 @@ impl Display for char {\n         if f.width.is_none() && f.precision.is_none() {\n             f.write_char(*self)\n         } else {\n-            f.pad(unsafe {\n-                str::from_utf8_unchecked(self.encode_utf8().as_slice())\n-            })\n+            f.pad(self.encode_utf8(&mut [0; 4]))\n         }\n     }\n }"}, {"sha": "7da0b6902f2717f5f6a584cd77d2c15eba74ed96", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/289f3a4ca79916d6445b452fc19a18a1e42a879a/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/289f3a4ca79916d6445b452fc19a18a1e42a879a/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=289f3a4ca79916d6445b452fc19a18a1e42a879a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::char;\n+use std::{char,str};\n use std::convert::TryFrom;\n \n #[test]\n@@ -248,10 +248,12 @@ fn test_escape_unicode() {\n #[test]\n fn test_encode_utf8() {\n     fn check(input: char, expect: &[u8]) {\n-        assert_eq!(input.encode_utf8().as_slice(), expect);\n-        for (a, b) in input.encode_utf8().zip(expect) {\n-            assert_eq!(a, *b);\n-        }\n+        let mut buf = [0; 4];\n+        let ptr = buf.as_ptr();\n+        let s = input.encode_utf8(&mut buf);\n+        assert_eq!(s.as_ptr() as usize, ptr as usize);\n+        assert!(str::from_utf8(s.as_bytes()).is_ok());\n+        assert_eq!(s.as_bytes(), expect);\n     }\n \n     check('x', &[0x78]);\n@@ -263,10 +265,11 @@ fn test_encode_utf8() {\n #[test]\n fn test_encode_utf16() {\n     fn check(input: char, expect: &[u16]) {\n-        assert_eq!(input.encode_utf16().as_slice(), expect);\n-        for (a, b) in input.encode_utf16().zip(expect) {\n-            assert_eq!(a, *b);\n-        }\n+        let mut buf = [0; 2];\n+        let ptr = buf.as_mut_ptr();\n+        let b = input.encode_utf16(&mut buf);\n+        assert_eq!(b.as_mut_ptr() as usize, ptr as usize);\n+        assert_eq!(b, expect);\n     }\n \n     check('x', &[0x0078]);"}, {"sha": "702d7d8b4b2ca421aac2a4bf796d7a1aeabd0d18", "filename": "src/librustc_unicode/char.rs", "status": "modified", "additions": 69, "deletions": 23, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/289f3a4ca79916d6445b452fc19a18a1e42a879a/src%2Flibrustc_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/289f3a4ca79916d6445b452fc19a18a1e42a879a/src%2Flibrustc_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fchar.rs?ref=289f3a4ca79916d6445b452fc19a18a1e42a879a", "patch": "@@ -37,7 +37,7 @@ use tables::{conversions, derived_property, general_category, property};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::char::{MAX, from_digit, from_u32, from_u32_unchecked};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::char::{EncodeUtf16, EncodeUtf8, EscapeDebug, EscapeDefault, EscapeUnicode};\n+pub use core::char::{EscapeDebug, EscapeDefault, EscapeUnicode};\n \n // unstable reexports\n #[unstable(feature = \"try_from\", issue = \"33417\")]\n@@ -435,50 +435,96 @@ impl char {\n         C::len_utf16(self)\n     }\n \n-    /// Returns an iterator over the bytes of this character as UTF-8.\n+    /// Encodes this character as UTF-8 into the provided byte buffer,\n+    /// and then returns the subslice of the buffer that contains the encoded character.\n     ///\n-    /// The returned iterator also has an `as_slice()` method to view the\n-    /// encoded bytes as a byte slice.\n+    /// # Panics\n+    ///\n+    /// Panics if the buffer is not large enough.\n+    /// A buffer of length four is large enough to encode any `char`.\n     ///\n     /// # Examples\n     ///\n+    /// In both of these examples, '\u00df' takes two bytes to encode.\n+    ///\n     /// ```\n     /// #![feature(unicode)]\n     ///\n-    /// let iterator = '\u00df'.encode_utf8();\n-    /// assert_eq!(iterator.as_slice(), [0xc3, 0x9f]);\n+    /// let mut b = [0; 2];\n     ///\n-    /// for (i, byte) in iterator.enumerate() {\n-    ///     println!(\"byte {}: {:x}\", i, byte);\n-    /// }\n+    /// let result = '\u00df'.encode_utf8(&mut b);\n+    ///\n+    /// assert_eq!(result, \"\u00df\");\n+    ///\n+    /// assert_eq!(result.len(), 2);\n+    /// ```\n+    ///\n+    /// A buffer that's too small:\n+    ///\n+    /// ```\n+    /// #![feature(unicode)]\n+    /// use std::thread;\n+    ///\n+    /// let result = thread::spawn(|| {\n+    ///     let mut b = [0; 1];\n+    ///\n+    ///     // this panics\n+    ///    '\u00df'.encode_utf8(&mut b);\n+    /// }).join();\n+    ///\n+    /// assert!(result.is_err());\n     /// ```\n-    #[unstable(feature = \"unicode\", issue = \"27784\")]\n+    #[unstable(feature = \"unicode\",\n+               reason = \"pending decision about Iterator/Writer/Reader\",\n+               issue = \"27784\")]\n     #[inline]\n-    pub fn encode_utf8(self) -> EncodeUtf8 {\n-        C::encode_utf8(self)\n+    pub fn encode_utf8(self, dst: &mut [u8]) -> &mut str {\n+        C::encode_utf8(self, dst)\n     }\n \n-    /// Returns an iterator over the `u16` entries of this character as UTF-16.\n+    /// Encodes this character as UTF-16 into the provided `u16` buffer,\n+    /// and then returns the subslice of the buffer that contains the encoded character.\n     ///\n-    /// The returned iterator also has an `as_slice()` method to view the\n-    /// encoded form as a slice.\n+    /// # Panics\n+    ///\n+    /// Panics if the buffer is not large enough.\n+    /// A buffer of length 2 is large enough to encode any `char`.\n     ///\n     /// # Examples\n     ///\n+    /// In both of these examples, '\ud835\udd4a' takes two `u16`s to encode.\n+    ///\n     /// ```\n     /// #![feature(unicode)]\n     ///\n-    /// let iterator = '\ud835\udd4a'.encode_utf16();\n-    /// assert_eq!(iterator.as_slice(), [0xd835, 0xdd4a]);\n+    /// let mut b = [0; 2];\n     ///\n-    /// for (i, val) in iterator.enumerate() {\n-    ///     println!(\"entry {}: {:x}\", i, val);\n-    /// }\n+    /// let result = '\ud835\udd4a'.encode_utf16(&mut b);\n+    ///\n+    /// assert_eq!(result.len(), 2);\n     /// ```\n-    #[unstable(feature = \"unicode\", issue = \"27784\")]\n+    ///\n+    /// A buffer that's too small:\n+    ///\n+    /// ```\n+    /// #![feature(unicode)]\n+    /// use std::thread;\n+    ///\n+    /// let result = thread::spawn(|| {\n+    ///     let mut b = [0; 1];\n+    ///\n+    ///     // this panics\n+    ///     '\ud835\udd4a'.encode_utf16(&mut b);\n+    /// }).join();\n+    ///\n+    /// assert!(result.is_err());\n+    /// ```\n+    #[unstable(feature = \"unicode\",\n+               reason = \"pending decision about Iterator/Writer/Reader\",\n+               issue = \"27784\")]\n     #[inline]\n-    pub fn encode_utf16(self) -> EncodeUtf16 {\n-        C::encode_utf16(self)\n+    pub fn encode_utf16(self, dst: &mut [u16]) -> &mut [u16] {\n+        C::encode_utf16(self, dst)\n     }\n \n     /// Returns true if this `char` is an alphabetic code point, and false if not."}, {"sha": "19e419e37a09c3be92715ae9158a8fd1c0d0207d", "filename": "src/librustc_unicode/u_str.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/289f3a4ca79916d6445b452fc19a18a1e42a879a/src%2Flibrustc_unicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/289f3a4ca79916d6445b452fc19a18a1e42a879a/src%2Flibrustc_unicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fu_str.rs?ref=289f3a4ca79916d6445b452fc19a18a1e42a879a", "patch": "@@ -157,13 +157,13 @@ impl<I> Iterator for Utf16Encoder<I>\n             return Some(tmp);\n         }\n \n+        let mut buf = [0; 2];\n         self.chars.next().map(|ch| {\n-            let n = CharExt::encode_utf16(ch);\n-            let n = n.as_slice();\n-            if n.len() == 2 {\n-                self.extra = n[1];\n+            let n = CharExt::encode_utf16(ch, &mut buf).len();\n+            if n == 2 {\n+                self.extra = buf[1];\n             }\n-            n[0]\n+            buf[0]\n         })\n     }\n "}, {"sha": "5e25c61bae995b254b239644df01c38a3b25fd12", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/289f3a4ca79916d6445b452fc19a18a1e42a879a/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/289f3a4ca79916d6445b452fc19a18a1e42a879a/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=289f3a4ca79916d6445b452fc19a18a1e42a879a", "patch": "@@ -433,9 +433,7 @@ fn escape_str(wr: &mut fmt::Write, v: &str) -> EncodeResult {\n }\n \n fn escape_char(writer: &mut fmt::Write, v: char) -> EncodeResult {\n-    escape_str(writer, unsafe {\n-        str::from_utf8_unchecked(v.encode_utf8().as_slice())\n-    })\n+    escape_str(writer, v.encode_utf8(&mut [0; 4]))\n }\n \n fn spaces(wr: &mut fmt::Write, mut n: usize) -> EncodeResult {"}, {"sha": "0a94ff1e958236e6337d8700ab4bb9f36bfff905", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/289f3a4ca79916d6445b452fc19a18a1e42a879a/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/289f3a4ca79916d6445b452fc19a18a1e42a879a/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=289f3a4ca79916d6445b452fc19a18a1e42a879a", "patch": "@@ -206,10 +206,12 @@ impl Wtf8Buf {\n     /// Copied from String::push\n     /// This does **not** include the WTF-8 concatenation check.\n     fn push_code_point_unchecked(&mut self, code_point: CodePoint) {\n-        let bytes = unsafe {\n-            char::from_u32_unchecked(code_point.value).encode_utf8()\n+        let c = unsafe {\n+            char::from_u32_unchecked(code_point.value)\n         };\n-        self.bytes.extend_from_slice(bytes.as_slice());\n+        let mut bytes = [0; 4];\n+        let bytes = c.encode_utf8(&mut bytes).as_bytes();\n+        self.bytes.extend_from_slice(bytes)\n     }\n \n     #[inline]\n@@ -738,15 +740,16 @@ impl<'a> Iterator for EncodeWide<'a> {\n             return Some(tmp);\n         }\n \n+        let mut buf = [0; 2];\n         self.code_points.next().map(|code_point| {\n-            let n = unsafe {\n-                char::from_u32_unchecked(code_point.value).encode_utf16()\n+            let c = unsafe {\n+                char::from_u32_unchecked(code_point.value)\n             };\n-            let n = n.as_slice();\n-            if n.len() == 2 {\n-                self.extra = n[1];\n+            let n = c.encode_utf16(&mut buf).len();\n+            if n == 2 {\n+                self.extra = buf[1];\n             }\n-            n[0]\n+            buf[0]\n         })\n     }\n "}]}