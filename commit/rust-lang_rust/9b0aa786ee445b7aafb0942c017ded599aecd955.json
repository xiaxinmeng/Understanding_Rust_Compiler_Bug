{"sha": "9b0aa786ee445b7aafb0942c017ded599aecd955", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliMGFhNzg2ZWU0NDViN2FhZmIwOTQyYzAxN2RlZDU5OWFlY2Q5NTU=", "commit": {"author": {"name": "Pascal Hertleif", "email": "killercup@gmail.com", "date": "2019-01-20T20:28:29Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-21T08:27:01Z"}, "message": "Apply suggestions from code review\n\nCo-Authored-By: matklad <aleksey.kladov@gmail.com>", "tree": {"sha": "07c03a5c14f644f77253d1c1c6491c2f4a33eca1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07c03a5c14f644f77253d1c1c6491c2f4a33eca1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b0aa786ee445b7aafb0942c017ded599aecd955", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b0aa786ee445b7aafb0942c017ded599aecd955", "html_url": "https://github.com/rust-lang/rust/commit/9b0aa786ee445b7aafb0942c017ded599aecd955", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b0aa786ee445b7aafb0942c017ded599aecd955/comments", "author": {"login": "killercup", "id": 20063, "node_id": "MDQ6VXNlcjIwMDYz", "avatar_url": "https://avatars.githubusercontent.com/u/20063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killercup", "html_url": "https://github.com/killercup", "followers_url": "https://api.github.com/users/killercup/followers", "following_url": "https://api.github.com/users/killercup/following{/other_user}", "gists_url": "https://api.github.com/users/killercup/gists{/gist_id}", "starred_url": "https://api.github.com/users/killercup/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killercup/subscriptions", "organizations_url": "https://api.github.com/users/killercup/orgs", "repos_url": "https://api.github.com/users/killercup/repos", "events_url": "https://api.github.com/users/killercup/events{/privacy}", "received_events_url": "https://api.github.com/users/killercup/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0a26d93c75791042052705f4aa62adff623315c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0a26d93c75791042052705f4aa62adff623315c", "html_url": "https://github.com/rust-lang/rust/commit/f0a26d93c75791042052705f4aa62adff623315c"}], "stats": {"total": 142, "additions": 71, "deletions": 71}, "files": [{"sha": "621a76046805e72169cc88eac9e3a762c9c87596", "filename": "guide.md", "status": "modified", "additions": 71, "deletions": 71, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/9b0aa786ee445b7aafb0942c017ded599aecd955/guide.md", "raw_url": "https://github.com/rust-lang/rust/raw/9b0aa786ee445b7aafb0942c017ded599aecd955/guide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/guide.md?ref=9b0aa786ee445b7aafb0942c017ded599aecd955", "patch": "@@ -96,37 +96,37 @@ Soon we'll talk how we build an LSP server on top of `Analysis`, but first,\n let's deal with that paths issue.\n \n \n-## Source roots (aka filesystems are horrible)\n+## Source roots (a.k.a. \"Filesystems are horrible\")\n \n This is a non-essential section, feel free to skip.\n \n-The previous section said that the file system path is an attribute of a file,\n-but this is not a whole truth. Making it an absolute `PathBuf` will be bad for\n-several reasons. First, file-systems are full of (platform-dependent) edge cases:\n+The previous section said that the filesystem path is an attribute of a file,\n+but this is not the whole truth. Making it an absolute `PathBuf` will be bad for\n+several reasons. First, filesystems are full of (platform-dependent) edge cases:\n \n * it's hard (requires a syscall) to decide if two paths are equivalent\n-* some file-systems are case-sensitive\n+* some filesystems are case-sensitive (e.g. on macOS)\n * paths are not necessary UTF-8\n * symlinks can form cycles\n \n Second, this might hurt reproducibility and hermeticity of builds. In theory,\n moving a project from `/foo/bar/my-project` to `/spam/eggs/my-project` should\n-not change a bit in the output. However, if absolute path is a part of the\n+not change a bit in the output. However, if the absolute path is a part of the\n input, it is at least in theory observable, and *could* affect the output.\n \n-Yet another problem is that we really-really want to avoid doing IO, but with\n+Yet another problem is that we really *really* want to avoid doing I/O, but with\n Rust the set of \"input\" files is not necessary known up-front. In theory, you\n can have `#[path=\"/dev/random\"] mod foo;`.\n \n To solve (or explicitly refuse to solve) these problems rust-analyzer uses the\n-concept of source root. Roughly speaking, source roots is a contents of a\n+concept of a \"source root\". Roughly speaking, source roots are the contents of a\n directory on a file systems, like `/home/matklad/projects/rustraytracer/**.rs`.\n \n More precisely, all files (`FileId`s) are partitioned into disjoint\n-`SourceRoot`s. Each file has a relative utf-8 path within the `SourceRoot`.\n-`SourceRoot` has an identity (integer id). Crucially, the root path of the\n-source root itself is unknown to the analyzer: client is supposed to maintain a\n-mapping between SourceRoot ids (which are assigned by the client) and actual\n+`SourceRoot`s. Each file has a relative UTF-8 path within the `SourceRoot`.\n+`SourceRoot` has an identity (integer ID). Crucially, the root path of the\n+source root itself is unknown to the analyzer: A client is supposed to maintain a\n+mapping between `SourceRoot` IDs (which are assigned by the client) and actual\n `PathBuf`s. `SourceRoot`s give a sane tree model of the file system to the\n analyzer.\n \n@@ -136,7 +136,7 @@ the source root, even `/dev/random`.\n \n ## Language Server Protocol\n \n-Now let's see how `Analysis` API is exposed via JSON RPC based LSP protocol. The\n+Now let's see how the `Analysis` API is exposed via the JSON RPC based language server protocol. The\n hard part here is managing changes (which can come either from the file system\n or from the editor) and concurrency (we want to spawn background jobs for things\n like syntax highlighting). We use the event loop pattern to manage the zoo, and\n@@ -151,7 +151,7 @@ Let's walk through a typical analyzer session!\n \n First, we need to figure out what to analyze. To do this, we run `cargo\n metadata` to learn about Cargo packages for current workspace and dependencies,\n-and we run `rustc --print sysroot` and scan sysroot to learn about crates like\n+and we run `rustc --print sysroot` and scan the \"sysroot\" (the directory containing the current Rust toolchain's files) to learn about crates like\n `std`. Currently we load this configuration once at the start of the server, but\n it should be possible to dynamically reconfigure it later without restart.\n \n@@ -162,26 +162,26 @@ it needs to be lowered to get the input in the form of `AnalysisChange`. This\n happens in [`ServerWorldState::new`] method. Specifically\n \n * Create a `SourceRoot` for each Cargo package and sysroot.\n-* Schedule a file system scan of the roots.\n+* Schedule a filesystem scan of the roots.\n * Create an analyzer's `Crate` for each Cargo **target** and sysroot crate.\n * Setup dependencies between the crates.\n \n [`ProjectModel`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_lsp_server/src/project_model.rs#L16-L20\n [`ServerWorldState::new`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_lsp_server/src/server_world.rs#L38-L160\n \n The results of the scan (which may take a while) will be processed in the body\n-of the main loop, just like any other change. Here's where we handle\n+of the main loop, just like any other change. Here's where we handle:\n \n * [File system changes](https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_lsp_server/src/main_loop.rs#L194)\n * [Changes from the editor](https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_lsp_server/src/main_loop.rs#L377)\n \n-After a single loop's turn, we group them into one `AnalysisChange` and\n+After a single loop's turn, we group the changes into one `AnalysisChange` and\n [apply] it. This always happens on the main thread and blocks the loop.\n \n [apply]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_lsp_server/src/server_world.rs#L216\n \n To handle requests, like [\"goto definition\"], we create an instance of the\n-`Analysis` and [`schedule`] the task (which consumes `Analysis`) onto\n+`Analysis` and [`schedule`] the task (which consumes `Analysis`) on the\n threadpool. [The task] calls the corresponding `Analysis` method, while\n massaging the types into the LSP representation. Keep in mind that if we are\n executing \"goto definition\" on the threadpool and a new change comes in, the\n@@ -197,24 +197,24 @@ dig into the implementation!\n \n ## Salsa\n \n-The most straightforward way to implement \"apply change, get analysis, repeat\"\n+The most straightforward way to implement an \"apply change, get analysis, repeat\"\n API would be to maintain the input state and to compute all possible analysis\n information from scratch after every change. This works, but scales poorly with\n the size of the project. To make this fast, we need to take advantage of the\n fact that most of the changes are small, and that analysis results are unlikely\n to change significantly between invocations.\n \n To do this we use [salsa]: a framework for incremental on-demand computation.\n-You can skip the rest of the section if you are familiar with rustc red-green\n-algorithm.\n+You can skip the rest of the section if you are familiar with rustc's red-green\n+algorithm (which is used for incremental compilation).\n \n [salsa]: https://github.com/salsa-rs/salsa\n \n It's better to refer to salsa's docs to learn about it. Here's a small excerpt:\n \n The key idea of salsa is that you define your program as a set of queries. Every\n-query is used like function K -> V that maps from some key of type K to a value\n-of type V. Queries come in two basic varieties:\n+query is used like a function `K -> V` that maps from some key of type `K` to a value\n+of type `V`. Queries come in two basic varieties:\n \n * **Inputs**: the base inputs to your system. You can change these whenever you\n   like.\n@@ -254,23 +254,23 @@ indeed, what `apply_change` does is it sets the values of input queries.\n \n ## From text to semantic model\n \n-The bulk of the rust-analyzer is transforming input text into semantic model of\n+The bulk of the rust-analyzer is transforming input text into a semantic model of\n Rust code: a web of entities like modules, structs, functions and traits.\n \n An important fact to realize is that (unlike most other languages like C# or\n-Java) there isn't a one-to-one mapping between source code and semantic model. A\n+Java) there isn't a one-to-one mapping between source code and the semantic model. A\n single function definition in the source code might result in several semantic\n functions: for example, the same source file might be included as a module into\n several crate, or a single \"crate\" might be present in the compilation DAG\n several times, with different sets of `cfg`s enabled. The IDE-specific task of\n-mapping source code position into semantic model is inherently imprecise for\n+mapping source code position into a semantic model is inherently imprecise for\n this reason, and is handled by the [`source_binder`].\n \n [`source_binder`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/source_binder.rs\n \n-The semantic interface is declared in [`code_model_api`] module. Each entity is\n-identified by integer id and has a bunch of methods which take a salsa database\n-as an argument and returns other entities (which are ids). Internally, this\n+The semantic interface is declared in the [`code_model_api`] module. Each entity is\n+identified by an integer ID and has a bunch of methods which take a salsa database\n+as an argument and returns other entities (which are also IDs). Internally, these\n methods invoke various queries on the database to build the model on demand.\n Here's [the list of queries].\n \n@@ -287,7 +287,7 @@ syntax. For this reason, rust-analyzer can build a syntax tree for each \"source\n file\", which could then be reused by several semantic models if this file\n happens to be a part of several crates.\n \n-Rust-analyzer uses a similar representation of syntax trees to that of `Roslyn`\n+The representation of syntax trees that rust-analyzer uses is similar to that of `Roslyn`\n and Swift's new [libsyntax]. Swift's docs give an excellent overview of the\n approach, so I skip this part here and instead outline the main characteristics\n of the syntax trees:\n@@ -328,9 +328,9 @@ The next step in constructing the semantic model is ...\n ## Building a Module Tree\n \n The algorithm for building a tree of modules is to start with a crate root\n-(remember, each `Crate` from a `CrateGraph` has a `FileId`), collect all mod\n+(remember, each `Crate` from a `CrateGraph` has a `FileId`), collect all `mod`\n declarations and recursively process child modules. This is handled by the\n-[`module_tree_query`], with a two slight variations.\n+[`module_tree_query`], with two slight variations.\n \n [`module_tree_query`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/module_tree.rs#L116-L123\n \n@@ -358,41 +358,41 @@ declarations.\n [`submodules_query`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/module_tree.rs#L41\n \n We store the resulting modules in a `Vec`-based indexed arena. The indices in\n-the arena becomes module ids. And this brings us to the next topic:\n-assigning ids in the general case.\n+the arena becomes module IDs. And this brings us to the next topic:\n+assigning IDs in the general case.\n \n ## Location Interner pattern\n \n-One way to assign ids is how we've dealt with modules: collect all items into a\n-single array in some specific order and use index in the array as an id. The\n-main drawback of this approach is that ids are not stable: adding a new item can\n-shift ids of all other items. This works for modules, because adding a module is\n-a comparatively rare operation, but would be less convenient for, for example\n+One way to assign IDs is how we've dealt with modules: Collect all items into a\n+single array in some specific order and use the index in the array as an ID. The\n+main drawback of this approach is that these IDs are not stable: Adding a new item can\n+shift the IDs of all other items. This works for modules, because adding a module is\n+a comparatively rare operation, but would be less convenient for, for example,\n functions.\n \n-Another solution here is positional ids: we can identify a function as \"the\n+Another solution here is positional IDs: We can identify a function as \"the\n function with name `foo` in a ModuleId(92) module\". Such locations are stable:\n adding a new function to the module (unless it is also named `foo`) does not\n-change the location. However, such \"id\" ceases to be a `Copy` integer and in\n-general can become pretty large if we account for nesting (third parameter of\n-the foo function of the bar impl in the baz module).\n+change the location. However, such \"ID\" types ceases to be a `Copy`able integer and in\n+general can become pretty large if we account for nesting (for example: \"third parameter of\n+the `foo` function of the `bar` `impl` in the `baz` module\").\n \n-[`LocationInterner`] allows us to combine benefits of positional and numeric\n-ids. It is a bidirectional append only map between locations and consecutive\n-integers which can \"intern\" a location and return an integer id back. Salsa\n+[`LocationInterner`] allows us to combine the benefits of positional and numeric\n+IDs. It is a bidirectional append-only map between locations and consecutive\n+integers which can \"intern\" a location and return an integer ID back. The salsa\n database we use includes a couple of [interners]. How to \"garbage collect\"\n unused locations is an open question.\n \n [`LocationInterner`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_db/src/loc2id.rs#L65-L71\n [interners]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/db.rs#L22-L23\n \n-For example, we use `LocationInterner` to assign ids to defs: functions,\n+For example, we use `LocationInterner` to assign IDs to definitions of functions,\n structs, enums, etc. The location, [`DefLoc`] contains two bits of information:\n \n-* the id of the module which contains the def,\n-* the id of the specific item in the modules source code.\n+* the ID of the module which contains the definition,\n+* the ID of the specific item in the modules source code.\n \n-We \"could\" use a text offset for location a particular item, but that would play\n+We \"could\" use a text offset for the location of a particular item, but that would play\n badly with salsa: offsets change after edits. So, as a rule of thumb, we avoid\n using offsets, text ranges or syntax trees as keys and values for queries. What\n we do instead is we store \"index\" of the item among all of the items of a file\n@@ -402,7 +402,7 @@ we do instead is we store \"index\" of the item among all of the items of a file\n \n One thing we've glossed over for the time being is support for macros. We have\n only proof of concept handling of macros at the moment, but they are extremely\n-interesting from \"assigning ids\" perspective.\n+interesting from an \"assigning IDs\" perspective.\n \n ## Macros and recursive locations\n \n@@ -440,28 +440,28 @@ macro-generated file, we can discuss name resolution a bit.\n \n Name resolution faces the same problem as the module tree: if we look at the\n syntax tree directly, we'll have to recompute name resolution after every\n-modification. The solution to the problem is the same: we [lower] source code of\n+modification. The solution to the problem is the same: We [lower] the source code of\n each module into a position-independent representation which does not change if\n we modify bodies of the items. After that we [loop] resolving all imports until\n we've reached a fixed point.\n \n [lower]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/nameres/lower.rs#L113-L117\n [loop]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/nameres.rs#L186-L196\n \n-And, given all our preparation with ids and position-independent representation,\n+And, given all our preparation with IDs and a position-independent representation,\n it is satisfying to [test] that typing inside function body does not invalidate\n name resolution results.\n \n [test]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/nameres/tests.rs#L376\n \n-An interesting fact about name resolution is that it \"erases\" all of\n+An interesting fact about name resolution is that it \"erases\" all of the\n intermediate paths from the imports: in the end, we know which items are defined\n and which items are imported in each module, but, if the import was `use\n foo::bar::baz`, we deliberately forget what modules `foo` and `bar` resolve to.\n \n To serve \"goto definition\" requests on intermediate segments we need this info\n-in IDE. Luckily, we need it only for a tiny fraction of imports, so we just ask\n-the module explicitly, \"where does `foo::bar` path resolve to?\". This is a\n+in the IDE, however. Luckily, we need it only for a tiny fraction of imports, so we just ask\n+the module explicitly, \"What does the path `foo::bar` resolve to?\". This is a\n general pattern: we try to compute the minimal possible amount of information\n during analysis while allowing IDE to ask for additional specific bits.\n \n@@ -476,9 +476,9 @@ store the syntax node as a part of name resolution: this will break\n incrementality, due to the fact that syntax changes after every file\n modification.\n \n-We solve this problem during the lowering step of name resolution. Lowering\n+We solve this problem during the lowering step of name resolution. The lowering\n query actually produces a *pair* of outputs: `LoweredModule` and [`SourceMap`].\n-`LoweredModule` module contains [imports], but in a position-independent form.\n+The `LoweredModule` module contains [imports], but in a position-independent form.\n The `SourceMap` contains a mapping from position-independent imports to\n (position-dependent) syntax nodes.\n \n@@ -500,20 +500,20 @@ by [@flodiebold]. [#327] was an awesome Christmas present, thank you, Florian!\n Type inference runs on per-function granularity and uses the patterns we've\n discussed previously.\n \n-First, we [lower ast] of function body into a position-independent\n+First, we [lower the AST] of a function body into a position-independent\n representation. In this representation, each expression is assigned a\n-[positional id]. Alongside the lowered expression, [a source map] is produced,\n+[positional ID]. Alongside the lowered expression, [a source map] is produced,\n which maps between expression ids and original syntax. This lowering step also\n deals with \"incomplete\" source trees by replacing missing expressions by an\n explicit `Missing` expression.\n \n-Given the lower body of the function, we can now run [type inference] and\n+Given the lowered body of the function, we can now run [type inference] and\n construct a mapping from `ExprId`s to types.\n \n [@flodiebold]: https://github.com/flodiebold\n [#327]: https://github.com/rust-analyzer/rust-analyzer/pull/327\n-[lower ast]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/expr.rs\n-[positional id]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/expr.rs#L13-L15\n+[lower the AST]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/expr.rs\n+[positional ID]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/expr.rs#L13-L15\n [a source map]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/expr.rs#L41-L44\n [type inference]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/ty.rs#L1208-L1223\n \n@@ -524,15 +524,15 @@ To conclude the overview of the rust-analyzer, let's trace the request for\n \n We start by [receiving a message] from the language client. We decode the\n message as a request for completion and [schedule it on the threadpool]. This is\n-the place where we [catch] canceled error if, immediately after completion, the\n+the also place where we [catch] canceled errors if, immediately after completion, the\n client sends some modification.\n \n-In [the handler] we deserialize LSP request into rust-analyzer specific data\n+In [the handler] we a deserialize LSP request into the rust-analyzer specific data\n types (by converting a file url into a numeric `FileId`), [ask analysis for\n completion] and serializer results to LSP.\n \n-[Completion implementation] is finally the place where we start doing the actual\n-work. The first step is to collection `CompletionContext` -- a struct which\n+The [completion implementation] is finally the place where we start doing the actual\n+work. The first step is to collect the `CompletionContext` -- a struct which\n describes the cursor position in terms of Rust syntax and semantics. For\n example, `function_syntax: Option<&'a ast::FnDef>` stores a reference to\n enclosing function *syntax*, while `function: Option<hir::Function>` is the\n@@ -541,14 +541,14 @@ enclosing function *syntax*, while `function: Option<hir::Function>` is the\n To construct the context, we first do an [\"IntelliJ Trick\"]: we insert a dummy\n identifier at the cursor's position and parse this modified file, to get a\n reasonably looking syntax tree. Then we do a bunch of \"classification\" routines\n-to figure out the context. For example, we [find ancestor fn node] and we get a\n+to figure out the context. For example, we [find an ancestor `fn` node] and we get a\n [semantic model] for it (using the lossy `source_binder` infrastructure).\n \n The second step is to run a [series of independent completion routines]. Let's\n take a closer look at [`complete_dot`], which completes fields and methods in\n `foo.bar|`. First we extract a semantic function and a syntactic receiver\n expression out of the `Context`. Then we run type-inference for this single\n-function and map our syntactic expression to `ExprId`. Using the id, we figure\n+function and map our syntactic expression to `ExprId`. Using the ID, we figure\n out the type of the receiver expression. Then we add all fields & methods from\n the type to completion.\n \n@@ -557,10 +557,10 @@ the type to completion.\n [catch]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_lsp_server/src/main_loop.rs#L436-L442\n [the handler]: https://salsa.zulipchat.com/#narrow/stream/181542-rfcs.2Fsalsa-query-group/topic/design.20next.20steps\n [ask analysis for completion]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/lib.rs#L439-L444\n-[Completion implementation]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/completion.rs#L46-L62\n+[completion implementation]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/completion.rs#L46-L62\n [`CompletionContext`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/completion/completion_context.rs#L14-L37\n [\"IntelliJ Trick\"]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/completion/completion_context.rs#L72-L75\n-[find ancestor fn node]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/completion/completion_context.rs#L116-L120\n+[find an ancestor `fn` node]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/completion/completion_context.rs#L116-L120\n [semantic model]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/completion/completion_context.rs#L123\n [series of independent completion routines]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/completion.rs#L52-L59\n [`complete_dot`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/completion/complete_dot.rs#L6-L22"}]}