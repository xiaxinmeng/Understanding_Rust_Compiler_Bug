{"sha": "88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4YzU2NzljNGUwYmEwYmQyMWExNWVhYWY4ZTVmYWZjYzZiY2RhZmQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-02T08:08:16Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-20T17:08:01Z"}, "message": "rustc_metadata: remove ty{en,de}code and move to auto-derived serialization.", "tree": {"sha": "89925a5218d802a70befb0607015cf3e11ec4dda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89925a5218d802a70befb0607015cf3e11ec4dda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd", "html_url": "https://github.com/rust-lang/rust/commit/88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcbb4107a1a966ea8ad48d370f553dffde780392", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcbb4107a1a966ea8ad48d370f553dffde780392", "html_url": "https://github.com/rust-lang/rust/commit/bcbb4107a1a966ea8ad48d370f553dffde780392"}], "stats": {"total": 1348, "additions": 235, "deletions": 1113}, "files": [{"sha": "338ea6b0dd6d4a686105abe40c55db91d83afdbb", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 70, "deletions": 38, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd", "patch": "@@ -25,7 +25,7 @@ use middle::stability;\n use ty::subst::Substs;\n use traits;\n use ty::{self, TraitRef, Ty, TypeAndMut};\n-use ty::{TyS, TypeVariants};\n+use ty::{TyS, TypeVariants, Slice};\n use ty::{AdtKind, AdtDef, ClosureSubsts, Region};\n use hir::FreevarMap;\n use ty::{BareFnTy, InferTy, ParamTy, ProjectionTy, TraitObject};\n@@ -92,7 +92,7 @@ pub struct CtxtInterners<'tcx> {\n     /// Specifically use a speedy hash algorithm for these hash sets,\n     /// they're accessed quite often.\n     type_: RefCell<FnvHashSet<Interned<'tcx, TyS<'tcx>>>>,\n-    type_list: RefCell<FnvHashSet<Interned<'tcx, [Ty<'tcx>]>>>,\n+    type_list: RefCell<FnvHashSet<Interned<'tcx, Slice<Ty<'tcx>>>>>,\n     substs: RefCell<FnvHashSet<Interned<'tcx, Substs<'tcx>>>>,\n     bare_fn: RefCell<FnvHashSet<Interned<'tcx, BareFnTy<'tcx>>>>,\n     region: RefCell<FnvHashSet<Interned<'tcx, Region>>>,\n@@ -847,10 +847,11 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Region {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a [Ty<'a>] {\n-    type Lifted = &'tcx [Ty<'tcx>];\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx [Ty<'tcx>]> {\n-        if let Some(&Interned(list)) = tcx.interners.type_list.borrow().get(*self) {\n+impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Ty<'a>> {\n+    type Lifted = &'tcx Slice<Ty<'tcx>>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n+                             -> Option<&'tcx Slice<Ty<'tcx>>> {\n+        if let Some(&Interned(list)) = tcx.interners.type_list.borrow().get(&self[..]) {\n             if *self as *const _ == list as *const _ {\n                 return Some(list);\n             }\n@@ -1067,9 +1068,24 @@ impl<'tcx: 'lcx, 'lcx> Borrow<TypeVariants<'lcx>> for Interned<'tcx, TyS<'tcx>>\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<[Ty<'lcx>]> for Interned<'tcx, [Ty<'tcx>]> {\n+// NB: An Interned<Slice<T>> compares and hashes as its elements.\n+impl<'tcx, T: PartialEq> PartialEq for Interned<'tcx, Slice<T>> {\n+    fn eq(&self, other: &Interned<'tcx, Slice<T>>) -> bool {\n+        self.0[..] == other.0[..]\n+    }\n+}\n+\n+impl<'tcx, T: Eq> Eq for Interned<'tcx, Slice<T>> {}\n+\n+impl<'tcx, T: Hash> Hash for Interned<'tcx, Slice<T>> {\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        self.0[..].hash(s)\n+    }\n+}\n+\n+impl<'tcx: 'lcx, 'lcx> Borrow<[Ty<'lcx>]> for Interned<'tcx, Slice<Ty<'tcx>>> {\n     fn borrow<'a>(&'a self) -> &'a [Ty<'lcx>] {\n-        self.0\n+        &self.0[..]\n     }\n }\n \n@@ -1091,32 +1107,23 @@ impl<'tcx> Borrow<Region> for Interned<'tcx, Region> {\n     }\n }\n \n-macro_rules! items { ($($item:item)+) => ($($item)+) }\n-macro_rules! impl_interners {\n-    ($lt_tcx:tt, $($name:ident: $method:ident($alloc:ty, $needs_infer:expr)-> $ty:ty),+) => {\n-        items!($(impl<$lt_tcx> PartialEq for Interned<$lt_tcx, $ty> {\n-            fn eq(&self, other: &Self) -> bool {\n-                self.0 == other.0\n-            }\n-        }\n-\n-        impl<$lt_tcx> Eq for Interned<$lt_tcx, $ty> {}\n-\n-        impl<$lt_tcx> Hash for Interned<$lt_tcx, $ty> {\n-            fn hash<H: Hasher>(&self, s: &mut H) {\n-                self.0.hash(s)\n-            }\n-        }\n-\n+macro_rules! intern_method {\n+    ($lt_tcx:tt, $name:ident: $method:ident($alloc:ty,\n+                                            $alloc_to_key:expr,\n+                                            $alloc_to_ret:expr,\n+                                            $needs_infer:expr) -> $ty:ty) => {\n         impl<'a, 'gcx, $lt_tcx> TyCtxt<'a, 'gcx, $lt_tcx> {\n             pub fn $method(self, v: $alloc) -> &$lt_tcx $ty {\n-                if let Some(i) = self.interners.$name.borrow().get::<$ty>(&v) {\n-                    return i.0;\n-                }\n-                if !self.is_global() {\n-                    if let Some(i) = self.global_interners.$name.borrow().get::<$ty>(&v) {\n+                {\n+                    let key = ($alloc_to_key)(&v);\n+                    if let Some(i) = self.interners.$name.borrow().get(key) {\n                         return i.0;\n                     }\n+                    if !self.is_global() {\n+                        if let Some(i) = self.global_interners.$name.borrow().get(key) {\n+                            return i.0;\n+                        }\n+                    }\n                 }\n \n                 // HACK(eddyb) Depend on flags being accurate to\n@@ -1127,7 +1134,7 @@ macro_rules! impl_interners {\n                         let v = unsafe {\n                             mem::transmute(v)\n                         };\n-                        let i = self.global_interners.arenas.$name.alloc(v);\n+                        let i = ($alloc_to_ret)(self.global_interners.arenas.$name.alloc(v));\n                         self.global_interners.$name.borrow_mut().insert(Interned(i));\n                         return i;\n                     }\n@@ -1141,34 +1148,59 @@ macro_rules! impl_interners {\n                     }\n                 }\n \n-                let i = self.interners.arenas.$name.alloc(v);\n+                let i = ($alloc_to_ret)(self.interners.arenas.$name.alloc(v));\n                 self.interners.$name.borrow_mut().insert(Interned(i));\n                 i\n             }\n-        })+);\n+        }\n+    }\n+}\n+\n+macro_rules! direct_interners {\n+    ($lt_tcx:tt, $($name:ident: $method:ident($needs_infer:expr) -> $ty:ty),+) => {\n+        $(impl<$lt_tcx> PartialEq for Interned<$lt_tcx, $ty> {\n+            fn eq(&self, other: &Self) -> bool {\n+                self.0 == other.0\n+            }\n+        }\n+\n+        impl<$lt_tcx> Eq for Interned<$lt_tcx, $ty> {}\n+\n+        impl<$lt_tcx> Hash for Interned<$lt_tcx, $ty> {\n+            fn hash<H: Hasher>(&self, s: &mut H) {\n+                self.0.hash(s)\n+            }\n+        }\n+\n+        intern_method!($lt_tcx, $name: $method($ty, |x| x, |x| x, $needs_infer) -> $ty);)+\n     }\n }\n \n fn keep_local<'tcx, T: ty::TypeFoldable<'tcx>>(x: &T) -> bool {\n     x.has_type_flags(ty::TypeFlags::KEEP_IN_LOCAL_TCX)\n }\n \n-impl_interners!('tcx,\n-    type_list: mk_type_list(Vec<Ty<'tcx>>, keep_local) -> [Ty<'tcx>],\n-    substs: mk_substs(Substs<'tcx>, |substs: &Substs| {\n+direct_interners!('tcx,\n+    substs: mk_substs(|substs: &Substs| {\n         substs.params().iter().any(keep_local)\n     }) -> Substs<'tcx>,\n-    bare_fn: mk_bare_fn(BareFnTy<'tcx>, |fty: &BareFnTy| {\n+    bare_fn: mk_bare_fn(|fty: &BareFnTy| {\n         keep_local(&fty.sig)\n     }) -> BareFnTy<'tcx>,\n-    region: mk_region(Region, |r| {\n+    region: mk_region(|r| {\n         match r {\n             &ty::ReVar(_) | &ty::ReSkolemized(..) => true,\n             _ => false\n         }\n     }) -> Region\n );\n \n+intern_method!('tcx,\n+    type_list: mk_type_list(Vec<Ty<'tcx>>, Deref::deref, |xs: &[Ty]| -> &Slice<Ty> {\n+        unsafe { mem::transmute(xs) }\n+    }, keep_local) -> Slice<Ty<'tcx>>\n+);\n+\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Create an unsafe fn ty based on a safe fn ty.\n     pub fn safe_to_unsafe_fn_ty(self, bare_fn: &BareFnTy<'tcx>) -> Ty<'tcx> {"}, {"sha": "59475b4222635f692f6bbf10b8817214df6700e4", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd", "patch": "@@ -38,6 +38,7 @@ use std::borrow::Cow;\n use std::cell::Cell;\n use std::hash::{Hash, Hasher};\n use std::iter;\n+use std::ops::Deref;\n use std::rc::Rc;\n use std::slice;\n use std::vec::IntoIter;\n@@ -569,6 +570,45 @@ pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n impl<'tcx> serialize::UseSpecializedEncodable for Ty<'tcx> {}\n impl<'tcx> serialize::UseSpecializedDecodable for Ty<'tcx> {}\n \n+/// A wrapper for slices with the additioanl invariant\n+/// that the slice is interned and no other slice with\n+/// the same contents can exist in the same context.\n+/// This means we can use pointer + length for both\n+/// equality comparisons and hashing.\n+#[derive(Debug, RustcEncodable)]\n+pub struct Slice<T>([T]);\n+\n+impl<T> PartialEq for Slice<T> {\n+    #[inline]\n+    fn eq(&self, other: &Slice<T>) -> bool {\n+        (&self.0 as *const [T]) == (&other.0 as *const [T])\n+    }\n+}\n+impl<T> Eq for Slice<T> {}\n+\n+impl<T> Hash for Slice<T> {\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        (self.as_ptr(), self.len()).hash(s)\n+    }\n+}\n+\n+impl<T> Deref for Slice<T> {\n+    type Target = [T];\n+    fn deref(&self) -> &[T] {\n+        &self.0\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a Slice<T> {\n+    type Item = &'a T;\n+    type IntoIter = <&'a [T] as IntoIterator>::IntoIter;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self[..].iter()\n+    }\n+}\n+\n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Slice<Ty<'tcx>> {}\n+\n /// Upvars do not get their own node-id. Instead, we use the pair of\n /// the original var id (that is, the root variable that is referenced\n /// by the upvar) and the id of the closure expression."}, {"sha": "5a87ea1473d982fbda294e9dc4f5e13566aa2faf", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd", "patch": "@@ -14,7 +14,6 @@ use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use std::rc::Rc;\n use syntax::abi;\n-use syntax::ptr::P;\n \n use hir;\n \n@@ -437,16 +436,6 @@ impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     }\n }\n \n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for P<[T]> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        self.iter().map(|t| t.fold_with(folder)).collect()\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.iter().any(|t| t.visit_with(visitor))\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::TraitObject<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::TraitObject {\n@@ -464,7 +453,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TraitObject<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx [Ty<'tcx>] {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<Ty<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let tys = self.iter().map(|t| t.fold_with(folder)).collect();\n         folder.tcx().mk_type_list(tys)"}, {"sha": "302cab0446cd3178e6048f342d1b02e9ab83e14f", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd", "patch": "@@ -13,12 +13,12 @@\n use hir::def_id::DefId;\n use middle::region;\n use ty::subst::Substs;\n-use ty::{self, AdtDef, ToPredicate, TypeFlags, Ty, TyCtxt, TyS, TypeFoldable};\n+use ty::{self, AdtDef, ToPredicate, TypeFlags, Ty, TyCtxt, TypeFoldable};\n+use ty::{Slice, TyS};\n use util::common::ErrorReported;\n \n use collections::enum_set::{self, EnumSet, CLike};\n use std::fmt;\n-use std::mem;\n use std::ops;\n use syntax::abi;\n use syntax::ast::{self, Name};\n@@ -31,7 +31,7 @@ use hir;\n use self::InferTy::*;\n use self::TypeVariants::*;\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct TypeAndMut<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub mutbl: hir::Mutability,\n@@ -87,7 +87,7 @@ pub enum Issue32330 {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in libsyntax/ast.rs as well.\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub enum TypeVariants<'tcx> {\n     /// The primitive boolean type. Written as `bool`.\n     TyBool,\n@@ -155,7 +155,7 @@ pub enum TypeVariants<'tcx> {\n     TyNever,\n \n     /// A tuple type.  For example, `(i32, bool)`.\n-    TyTuple(&'tcx [Ty<'tcx>]),\n+    TyTuple(&'tcx Slice<Ty<'tcx>>),\n \n     /// The projection of an associated type.  For example,\n     /// `<T as Trait<..>>::N`.\n@@ -252,7 +252,7 @@ pub enum TypeVariants<'tcx> {\n /// closure C wind up influencing the decisions we ought to make for\n /// closure C (which would then require fixed point iteration to\n /// handle). Plus it fixes an ICE. :P\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct ClosureSubsts<'tcx> {\n     /// Lifetime and type parameters from the enclosing function.\n     /// These are separated out because trans wants to pass them around\n@@ -262,12 +262,10 @@ pub struct ClosureSubsts<'tcx> {\n     /// The types of the upvars. The list parallels the freevars and\n     /// `upvar_borrows` lists. These are kept distinct so that we can\n     /// easily index into them.\n-    pub upvar_tys: &'tcx [Ty<'tcx>]\n+    pub upvar_tys: &'tcx Slice<Ty<'tcx>>\n }\n \n-impl<'tcx> serialize::UseSpecializedDecodable for ClosureSubsts<'tcx> {}\n-\n-#[derive(Clone, PartialEq, Eq, Hash)]\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct TraitObject<'tcx> {\n     pub principal: PolyExistentialTraitRef<'tcx>,\n     pub region_bound: &'tcx ty::Region,\n@@ -330,7 +328,7 @@ impl<'tcx> PolyTraitRef<'tcx> {\n ///\n /// The substitutions don't include the erased `Self`, only trait\n /// type and lifetime parameters (`[X, Y]` and `['a, 'b]` above).\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct ExistentialTraitRef<'tcx> {\n     pub def_id: DefId,\n     pub substs: &'tcx Substs<'tcx>,\n@@ -423,13 +421,15 @@ pub struct ProjectionTy<'tcx> {\n     pub item_name: Name,\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct BareFnTy<'tcx> {\n     pub unsafety: hir::Unsafety,\n     pub abi: abi::Abi,\n     pub sig: PolyFnSig<'tcx>,\n }\n \n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx BareFnTy<'tcx> {}\n+\n #[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct ClosureTy<'tcx> {\n     pub unsafety: hir::Unsafety,\n@@ -467,7 +467,7 @@ impl<'tcx> PolyFnSig<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct ParamTy {\n     pub idx: u32,\n     pub name: Name,\n@@ -654,17 +654,17 @@ pub struct EarlyBoundRegion {\n     pub name: Name,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct TyVid {\n     pub index: u32,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct IntVid {\n     pub index: u32\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct FloatVid {\n     pub index: u32\n }\n@@ -679,7 +679,7 @@ pub struct SkolemizedRegionVid {\n     pub index: u32\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum InferTy {\n     TyVar(TyVid),\n     IntVar(IntVid),\n@@ -694,7 +694,7 @@ pub enum InferTy {\n }\n \n /// A `ProjectionPredicate` for an `ExistentialTraitRef`.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct ExistentialProjection<'tcx> {\n     pub trait_ref: ExistentialTraitRef<'tcx>,\n     pub item_name: Name,\n@@ -739,7 +739,7 @@ impl<'a, 'tcx, 'gcx> PolyExistentialProjection<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct BuiltinBounds(EnumSet<BuiltinBound>);\n \n impl<'a, 'gcx, 'tcx> BuiltinBounds {\n@@ -782,20 +782,25 @@ impl<'a> IntoIterator for &'a BuiltinBounds {\n \n #[derive(Clone, RustcEncodable, PartialEq, Eq, RustcDecodable, Hash,\n            Debug, Copy)]\n-#[repr(usize)]\n pub enum BuiltinBound {\n-    Send,\n-    Sized,\n-    Copy,\n-    Sync,\n+    Send = 0,\n+    Sized = 1,\n+    Copy = 2,\n+    Sync = 3,\n }\n \n impl CLike for BuiltinBound {\n     fn to_usize(&self) -> usize {\n         *self as usize\n     }\n     fn from_usize(v: usize) -> BuiltinBound {\n-        unsafe { mem::transmute(v) }\n+        match v {\n+            0 => BuiltinBound::Send,\n+            1 => BuiltinBound::Sized,\n+            2 => BuiltinBound::Copy,\n+            3 => BuiltinBound::Sync,\n+            _ => bug!(\"{} is not a valid BuiltinBound\", v)\n+        }\n     }\n }\n "}, {"sha": "8af06286189b1f60ccb0e5386474ad04775e68cb", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd", "patch": "@@ -26,8 +26,7 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization::{cmt};\n use rustc::hir::pat_util::*;\n use rustc::traits::Reveal;\n-use rustc::ty::*;\n-use rustc::ty;\n+use rustc::ty::{self, Ty, TyCtxt};\n use std::cmp::Ordering;\n use std::fmt;\n use std::iter::{FromIterator, IntoIterator, repeat};\n@@ -110,7 +109,7 @@ impl<'a, 'tcx> FromIterator<Vec<(&'a Pat, Option<Ty<'tcx>>)>> for Matrix<'a, 'tc\n //NOTE: appears to be the only place other then InferCtxt to contain a ParamEnv\n pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    pub param_env: ParameterEnvironment<'tcx>,\n+    pub param_env: ty::ParameterEnvironment<'tcx>,\n }\n \n #[derive(Clone, Debug, PartialEq)]\n@@ -248,7 +247,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n                 if edef.is_enum() {\n                     if let Def::Local(..) = cx.tcx.expect_def(p.id) {\n                         if edef.variants.iter().any(|variant| {\n-                            variant.name == name.node && variant.kind == VariantKind::Unit\n+                            variant.name == name.node && variant.kind == ty::VariantKind::Unit\n                         }) {\n                             let ty_path = cx.tcx.item_path_str(edef.did);\n                             let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n@@ -579,7 +578,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n         ty::TyAdt(adt, _) => {\n             let v = ctor.variant_for_adt(adt);\n             match v.kind {\n-                VariantKind::Struct => {\n+                ty::VariantKind::Struct => {\n                     let field_pats: hir::HirVec<_> = v.fields.iter()\n                         .zip(pats)\n                         .filter(|&(_, ref pat)| pat.node != PatKind::Wild)\n@@ -594,10 +593,10 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n                     let has_more_fields = field_pats.len() < pats_len;\n                     PatKind::Struct(def_to_path(cx.tcx, v.did), field_pats, has_more_fields)\n                 }\n-                VariantKind::Tuple => {\n+                ty::VariantKind::Tuple => {\n                     PatKind::TupleStruct(def_to_path(cx.tcx, v.did), pats.collect(), None)\n                 }\n-                VariantKind::Unit => {\n+                ty::VariantKind::Unit => {\n                     PatKind::Path(None, def_to_path(cx.tcx, v.did))\n                 }\n             }\n@@ -639,7 +638,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n impl Constructor {\n     fn variant_for_adt<'tcx, 'container, 'a>(&self,\n                                              adt: &'a ty::AdtDefData<'tcx, 'container>)\n-                                             -> &'a VariantDefData<'tcx, 'container> {\n+                                             -> &'a ty::VariantDefData<'tcx, 'container> {\n         match self {\n             &Variant(vid) => adt.variant_with_id(vid),\n             _ => adt.struct_variant()\n@@ -878,7 +877,7 @@ fn wrap_pat<'a, 'b, 'tcx>(cx: &MatchCheckCtxt<'b, 'tcx>,\n     let pat_ty = cx.tcx.pat_ty(pat);\n     (pat, Some(match pat.node {\n         PatKind::Binding(hir::BindByRef(..), ..) => {\n-            pat_ty.builtin_deref(false, NoPreference).unwrap().ty\n+            pat_ty.builtin_deref(false, ty::NoPreference).unwrap().ty\n         }\n         _ => pat_ty\n     }))\n@@ -1068,7 +1067,7 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n             fn_id: NodeId) {\n     match kind {\n         FnKind::Closure(_) => {}\n-        _ => cx.param_env = ParameterEnvironment::for_item(cx.tcx, fn_id),\n+        _ => cx.param_env = ty::ParameterEnvironment::for_item(cx.tcx, fn_id),\n     }\n \n     intravisit::walk_fn(cx, kind, decl, body, sp, fn_id);\n@@ -1187,17 +1186,17 @@ impl<'a, 'gcx, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'gcx> {\n               _: NodeId,\n               span: Span,\n               _: cmt,\n-              _: &'tcx Region,\n-              kind: BorrowKind,\n+              _: &'tcx ty::Region,\n+              kind:ty:: BorrowKind,\n               _: LoanCause) {\n         match kind {\n-            MutBorrow => {\n+            ty::MutBorrow => {\n                 struct_span_err!(self.cx.tcx.sess, span, E0301,\n                           \"cannot mutably borrow in a pattern guard\")\n                     .span_label(span, &format!(\"borrowed mutably in pattern guard\"))\n                     .emit();\n             }\n-            ImmBorrow | UniqueImmBorrow => {}\n+            ty::ImmBorrow | ty::UniqueImmBorrow => {}\n         }\n     }\n     fn decl_without_init(&mut self, _: NodeId, _: Span) {}"}, {"sha": "123ed11a7a513d9e8ea7dc0d1a1f62b698599f79", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd", "patch": "@@ -10,9 +10,7 @@\n \n #![allow(non_camel_case_types, non_upper_case_globals)]\n \n-pub const tag_opaque: usize = 0x00;\n-\n-// GAP 0x01...0x19\n+// GAP 0x00...0x19\n \n pub const tag_items: usize = 0x100; // top-level only\n \n@@ -214,3 +212,8 @@ pub const tag_macro_derive_registrar: usize = 0x115;\n // NB: increment this if you change the format of metadata such that\n // rustc_version can't be found.\n pub const metadata_encoding_version : &'static [u8] = &[b'r', b'u', b's', b't', 0, 0, 0, 2];\n+\n+/// The shorthand encoding of `Ty` uses `TypeVariants`' variant `usize`\n+/// and is offset by this value so it never matches a real variant.\n+/// This offset is also chosen so that the first byte is never < 0x80.\n+pub const TYPE_SHORTHAND_OFFSET: usize = 0x80;"}, {"sha": "0118cacad182eccacc896b0c686b2605e5c80807", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd", "patch": "@@ -20,7 +20,6 @@ use common::*;\n use def_key;\n use encoder::def_to_u64;\n use index;\n-use tydecode::TyDecoder;\n \n use rustc::hir::def_id::CRATE_DEF_INDEX;\n use rustc::hir::svh::Svh;\n@@ -45,13 +44,14 @@ use rustc_const_math::ConstInt;\n use rustc::mir::repr::Mir;\n \n use std::io;\n+use std::mem;\n use std::rc::Rc;\n use std::str;\n use std::u32;\n \n use rbml::reader;\n use rbml;\n-use rustc_serialize::{Decodable, SpecializedDecoder, opaque};\n+use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n use rustc_serialize as serialize;\n use syntax::attr;\n use syntax::parse::token;\n@@ -233,35 +233,53 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n \n impl<'a, 'tcx> SpecializedDecoder<Ty<'tcx>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Ty<'tcx>, Self::Error> {\n-        let pos = self.opaque.position();\n-        let doc = rbml::Doc::at(self.opaque.data, pos);\n-        self.opaque.advance(doc.end - pos);\n-        Ok(TyDecoder::with_doc(self.tcx(), self.cdata().cnum, doc,\n-                               &mut |d| translate_def_id(self.cdata(), d))\n-            .parse_ty())\n+        let tcx = self.tcx();\n+\n+        // Handle shorthands first, if we have an usize > 0x80.\n+        if self.opaque.data[self.opaque.position()] & 0x80 != 0 {\n+            let pos = self.read_usize()?;\n+            assert!(pos >= TYPE_SHORTHAND_OFFSET);\n+            let key = ty::CReaderCacheKey {\n+                cnum: self.cdata().cnum,\n+                pos: pos - TYPE_SHORTHAND_OFFSET\n+            };\n+            if let Some(ty) = tcx.rcache.borrow().get(&key).cloned() {\n+                return Ok(ty);\n+            }\n+\n+            let new = opaque::Decoder::new(self.opaque.data, key.pos);\n+            let old = mem::replace(&mut self.opaque, new);\n+            let ty = Ty::decode(self)?;\n+            self.opaque = old;\n+            tcx.rcache.borrow_mut().insert(key, ty);\n+            return Ok(ty);\n+        }\n+\n+        Ok(tcx.mk_ty(ty::TypeVariants::decode(self)?))\n     }\n }\n \n impl<'a, 'tcx> SpecializedDecoder<&'tcx Substs<'tcx>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<&'tcx Substs<'tcx>, Self::Error> {\n-        let substs = Substs::decode(self)?;\n-        Ok(self.tcx().mk_substs(substs))\n+        Ok(self.tcx().mk_substs(Decodable::decode(self)?))\n     }\n }\n \n impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Region> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<&'tcx ty::Region, Self::Error> {\n-        let r = ty::Region::decode(self)?;\n-        Ok(self.tcx().mk_region(r))\n+        Ok(self.tcx().mk_region(Decodable::decode(self)?))\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<ty::ClosureSubsts<'tcx>> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<ty::ClosureSubsts<'tcx>, Self::Error> {\n-        Ok(ty::ClosureSubsts {\n-            func_substs: Decodable::decode(self)?,\n-            upvar_tys: self.tcx().mk_type_list(Decodable::decode(self)?)\n-        })\n+impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Slice<Ty<'tcx>>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<&'tcx ty::Slice<Ty<'tcx>>, Self::Error> {\n+        Ok(self.tcx().mk_type_list(Decodable::decode(self)?))\n+    }\n+}\n+\n+impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::BareFnTy<'tcx>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<&'tcx ty::BareFnTy<'tcx>, Self::Error> {\n+        Ok(self.tcx().mk_bare_fn(Decodable::decode(self)?))\n     }\n }\n "}, {"sha": "e414275f8b4258482bb1bf197ac6d68362ff563d", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd", "patch": "@@ -18,7 +18,6 @@ use common::*;\n use cstore;\n use decoder;\n use def_key;\n-use tyencode;\n use index::{self, IndexData};\n \n use middle::cstore::{InlinedItemRef, LinkMeta};\n@@ -34,8 +33,10 @@ use rustc::mir::mir_map::MirMap;\n use rustc::session::config::{self, PanicStrategy, CrateTypeRustcMacro};\n use rustc::util::nodemap::{FnvHashMap, NodeSet};\n \n-use rustc_serialize::{Encodable, SpecializedEncoder, opaque};\n+use rustc_serialize::{Encodable, Encoder, SpecializedEncoder, opaque};\n use rustc_serialize as serialize;\n+use std::cell::RefCell;\n+use std::intrinsics;\n use std::io::prelude::*;\n use std::io::Cursor;\n use std::ops::{Deref, DerefMut};\n@@ -55,14 +56,14 @@ use rustc::hir::map::DefKey;\n use super::index_builder::{FromId, IndexBuilder, ItemContentBuilder, Untracked, XRef};\n \n pub struct EncodeContext<'a, 'tcx: 'a> {\n-    pub rbml_w: rbml::writer::Encoder<'a>,\n+    rbml_w: rbml::writer::Encoder<'a>,\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    pub reexports: &'a def::ExportMap,\n-    pub link_meta: &'a LinkMeta,\n-    pub cstore: &'a cstore::CStore,\n-    pub type_abbrevs: &'a tyencode::abbrev_map<'tcx>,\n-    pub reachable: &'a NodeSet,\n-    pub mir_map: &'a MirMap<'tcx>,\n+    reexports: &'a def::ExportMap,\n+    link_meta: &'a LinkMeta,\n+    cstore: &'a cstore::CStore,\n+    type_shorthands: RefCell<FnvHashMap<Ty<'tcx>, usize>>,\n+    reachable: &'a NodeSet,\n+    mir_map: &'a MirMap<'tcx>,\n }\n \n impl<'a, 'tcx> Deref for EncodeContext<'a, 'tcx> {\n@@ -116,12 +117,32 @@ impl<'a, 'tcx> serialize::Encoder for ::encoder::EncodeContext<'a, 'tcx> {\n \n impl<'a, 'tcx> SpecializedEncoder<Ty<'tcx>> for EncodeContext<'a, 'tcx> {\n     fn specialized_encode(&mut self, ty: &Ty<'tcx>) -> Result<(), Self::Error> {\n-        let cx = self.ty_str_ctxt();\n+        let existing_shorthand = self.type_shorthands.borrow().get(ty).cloned();\n+        if let Some(shorthand) = existing_shorthand {\n+            return self.emit_usize(shorthand);\n+        }\n+\n+        let start = self.mark_stable_position();\n+        ty.sty.encode(self)?;\n+        let len = self.mark_stable_position() - start;\n+\n+        // The shorthand encoding uses the same usize as the\n+        // discriminant, with an offset so they can't conflict.\n+        let discriminant = unsafe { intrinsics::discriminant_value(&ty.sty) };\n+        assert!(discriminant < TYPE_SHORTHAND_OFFSET as u64);\n+        let shorthand = start + TYPE_SHORTHAND_OFFSET;\n+\n+        // Get the number of bits that leb128 could fit\n+        // in the same space as the fully encoded type.\n+        let leb128_bits = len * 7;\n \n-        self.start_tag(tag_opaque)?;\n-        tyencode::enc_ty(&mut self.rbml_w.opaque.cursor, &cx, ty);\n-        self.mark_stable_position();\n-        self.end_tag()\n+        // Check that the shorthand is a not longer than the\n+        // full encoding itself, i.e. it's an obvious win.\n+        if leb128_bits >= 64 || (shorthand as u64) < (1 << leb128_bits) {\n+            self.type_shorthands.borrow_mut().insert(*ty, shorthand);\n+        }\n+\n+        Ok(())\n     }\n }\n \n@@ -1742,7 +1763,7 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         cstore: cstore,\n         reachable: reachable,\n         mir_map: mir_map,\n-        type_abbrevs: &Default::default(),\n+        type_shorthands: Default::default(),\n     });\n \n     // RBML compacts the encoded bytes whenever appropriate,"}, {"sha": "e5f7aab38c364a3e540dd24f69e78261a8b1876b", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd", "patch": "@@ -17,9 +17,9 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![cfg_attr(not(stage0), deny(warnings))]\n \n+#![feature(core_intrinsics)]\n #![feature(box_patterns)]\n #![feature(dotdot_in_tuple_patterns)]\n-#![feature(enumset)]\n #![feature(question_mark)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n@@ -63,8 +63,6 @@ pub mod diagnostics;\n pub mod astencode;\n pub mod common;\n pub mod def_key;\n-pub mod tyencode;\n-pub mod tydecode;\n pub mod encoder;\n mod index_builder;\n pub mod decoder;"}, {"sha": "ccc4894fcdda27ae162e1be0ba97830579cf062e", "filename": "src/librustc_metadata/tydecode.rs", "status": "removed", "additions": 0, "deletions": 598, "changes": 598, "blob_url": "https://github.com/rust-lang/rust/blob/bcbb4107a1a966ea8ad48d370f553dffde780392/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcbb4107a1a966ea8ad48d370f553dffde780392/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=bcbb4107a1a966ea8ad48d370f553dffde780392", "patch": "@@ -1,598 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-// Type decoding\n-\n-// tjc note: Would be great to have a `match check` macro equivalent\n-// for some of these\n-\n-#![allow(non_camel_case_types)]\n-\n-use rustc::hir;\n-\n-use rustc::hir::def_id::{CrateNum, DefId, DefIndex};\n-use middle::region;\n-use rustc::ty::subst::{Kind, Substs};\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-\n-use rbml;\n-use rustc_serialize::leb128;\n-use std::str;\n-use syntax::abi;\n-use syntax::ast;\n-use syntax::parse::token;\n-\n-// Compact string representation for Ty values. API TyStr &\n-// parse_from_str. Extra parameters are for converting to/from def_ids in the\n-// data buffer. Whatever format you choose should not contain pipe characters.\n-\n-pub type DefIdConvert<'a> = &'a mut FnMut(DefId) -> DefId;\n-\n-pub struct TyDecoder<'a, 'tcx: 'a> {\n-    data: &'a [u8],\n-    krate: CrateNum,\n-    pos: usize,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    conv_def_id: DefIdConvert<'a>,\n-}\n-\n-impl<'a,'tcx> TyDecoder<'a,'tcx> {\n-    pub fn with_doc(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    crate_num: CrateNum,\n-                    doc: rbml::Doc<'a>,\n-                    conv: DefIdConvert<'a>)\n-                    -> TyDecoder<'a,'tcx> {\n-        TyDecoder::new(doc.data, crate_num, doc.start, tcx, conv)\n-    }\n-\n-    pub fn new(data: &'a [u8],\n-               crate_num: CrateNum,\n-               pos: usize,\n-               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-               conv: DefIdConvert<'a>)\n-               -> TyDecoder<'a, 'tcx> {\n-        TyDecoder {\n-            data: data,\n-            krate: crate_num,\n-            pos: pos,\n-            tcx: tcx,\n-            conv_def_id: conv,\n-        }\n-    }\n-\n-    pub fn position(&self) -> usize {\n-        self.pos\n-    }\n-\n-    fn peek(&self) -> char {\n-        self.data[self.pos] as char\n-    }\n-\n-    fn next(&mut self) -> char {\n-        let ch = self.data[self.pos] as char;\n-        self.pos = self.pos + 1;\n-        return ch;\n-    }\n-\n-    fn next_byte(&mut self) -> u8 {\n-        let b = self.data[self.pos];\n-        self.pos = self.pos + 1;\n-        return b;\n-    }\n-\n-    fn scan<F>(&mut self, mut is_last: F) -> &'a [u8]\n-        where F: FnMut(char) -> bool,\n-    {\n-        let start_pos = self.pos;\n-        debug!(\"scan: '{}' (start)\", self.data[self.pos] as char);\n-        while !is_last(self.data[self.pos] as char) {\n-            self.pos += 1;\n-            debug!(\"scan: '{}'\", self.data[self.pos] as char);\n-        }\n-        let end_pos = self.pos;\n-        self.pos += 1;\n-        return &self.data[start_pos..end_pos];\n-    }\n-\n-    fn parse_vuint(&mut self) -> usize {\n-        let (value, bytes_read) = leb128::read_unsigned_leb128(self.data,\n-                                                               self.pos);\n-        self.pos += bytes_read;\n-        value as usize\n-    }\n-\n-    fn parse_size(&mut self) -> Option<usize> {\n-        assert_eq!(self.next(), '/');\n-\n-        if self.peek() == '|' {\n-            assert_eq!(self.next(), '|');\n-            None\n-        } else {\n-            let n = self.parse_uint();\n-            assert_eq!(self.next(), '|');\n-            Some(n)\n-        }\n-    }\n-\n-    fn parse_substs(&mut self) -> &'tcx Substs<'tcx> {\n-        let mut params = vec![];\n-        assert_eq!(self.next(), '[');\n-        while self.peek() != ']' {\n-            let k = match self.next() {\n-                'r' => Kind::from(self.parse_region()),\n-                't' => Kind::from(self.parse_ty()),\n-                _ => bug!()\n-            };\n-            params.push(k);\n-        }\n-        assert_eq!(self.next(), ']');\n-\n-        Substs::new(self.tcx, params)\n-    }\n-\n-    fn parse_bound_region(&mut self) -> ty::BoundRegion {\n-        match self.next() {\n-            'a' => {\n-                let id = self.parse_u32();\n-                assert_eq!(self.next(), '|');\n-                ty::BrAnon(id)\n-            }\n-            '[' => {\n-                let def = self.parse_def();\n-                let name = token::intern(&self.parse_str('|'));\n-                let issue32330 = match self.next() {\n-                    'n' => {\n-                        assert_eq!(self.next(), ']');\n-                        ty::Issue32330::WontChange\n-                    }\n-                    'y' => {\n-                        ty::Issue32330::WillChange {\n-                            fn_def_id: self.parse_def(),\n-                            region_name: token::intern(&self.parse_str(']')),\n-                        }\n-                    }\n-                    c => panic!(\"expected n or y not {}\", c)\n-                };\n-                ty::BrNamed(def, name, issue32330)\n-            }\n-            'f' => {\n-                let id = self.parse_u32();\n-                assert_eq!(self.next(), '|');\n-                ty::BrFresh(id)\n-            }\n-            'e' => ty::BrEnv,\n-            _ => bug!(\"parse_bound_region: bad input\")\n-        }\n-    }\n-\n-    fn parse_region(&mut self) -> &'tcx ty::Region {\n-        self.tcx.mk_region(match self.next() {\n-            'b' => {\n-                assert_eq!(self.next(), '[');\n-                let id = ty::DebruijnIndex::new(self.parse_u32());\n-                assert_eq!(self.next(), '|');\n-                let br = self.parse_bound_region();\n-                assert_eq!(self.next(), ']');\n-                ty::ReLateBound(id, br)\n-            }\n-            'B' => {\n-                assert_eq!(self.next(), '[');\n-                let index = self.parse_u32();\n-                assert_eq!(self.next(), '|');\n-                let name = token::intern(&self.parse_str(']'));\n-                ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                    index: index,\n-                    name: name\n-                })\n-            }\n-            'f' => {\n-                assert_eq!(self.next(), '[');\n-                let scope = self.parse_scope();\n-                assert_eq!(self.next(), '|');\n-                let br = self.parse_bound_region();\n-                assert_eq!(self.next(), ']');\n-                ty::ReFree(ty::FreeRegion { scope: scope,\n-                                            bound_region: br})\n-            }\n-            's' => {\n-                let scope = self.parse_scope();\n-                assert_eq!(self.next(), '|');\n-                ty::ReScope(scope)\n-            }\n-            't' => ty::ReStatic,\n-            'e' => ty::ReEmpty,\n-            'E' => ty::ReErased,\n-            _ => bug!(\"parse_region: bad input\")\n-        })\n-    }\n-\n-    fn parse_scope(&mut self) -> region::CodeExtent {\n-        self.tcx.region_maps.bogus_code_extent(match self.next() {\n-            // This creates scopes with the wrong NodeId. This isn't\n-            // actually a problem because scopes only exist *within*\n-            // functions, and functions aren't loaded until trans which\n-            // doesn't care about regions.\n-            //\n-            // May still be worth fixing though.\n-            'C' => {\n-                assert_eq!(self.next(), '[');\n-                let fn_id = ast::NodeId::new(self.parse_uint());\n-                assert_eq!(self.next(), '|');\n-                let body_id = ast::NodeId::new(self.parse_uint());\n-                assert_eq!(self.next(), ']');\n-                region::CodeExtentData::CallSiteScope {\n-                    fn_id: fn_id, body_id: body_id\n-                }\n-            }\n-            // This creates scopes with the wrong NodeId. (See note above.)\n-            'P' => {\n-                assert_eq!(self.next(), '[');\n-                let fn_id = ast::NodeId::new(self.parse_uint());\n-                assert_eq!(self.next(), '|');\n-                let body_id = ast::NodeId::new(self.parse_uint());\n-                assert_eq!(self.next(), ']');\n-                region::CodeExtentData::ParameterScope {\n-                    fn_id: fn_id, body_id: body_id\n-                }\n-            }\n-            'M' => {\n-                let node_id = ast::NodeId::new(self.parse_uint());\n-                region::CodeExtentData::Misc(node_id)\n-            }\n-            'D' => {\n-                let node_id = ast::NodeId::new(self.parse_uint());\n-                region::CodeExtentData::DestructionScope(node_id)\n-            }\n-            'B' => {\n-                assert_eq!(self.next(), '[');\n-                let node_id = ast::NodeId::new(self.parse_uint());\n-                assert_eq!(self.next(), '|');\n-                let first_stmt_index = self.parse_u32();\n-                assert_eq!(self.next(), ']');\n-                let block_remainder = region::BlockRemainder {\n-                    block: node_id, first_statement_index: first_stmt_index,\n-                };\n-                region::CodeExtentData::Remainder(block_remainder)\n-            }\n-            _ => bug!(\"parse_scope: bad input\")\n-        })\n-    }\n-\n-    fn parse_str(&mut self, term: char) -> String {\n-        let mut result = String::new();\n-        while self.peek() != term {\n-            unsafe {\n-                result.as_mut_vec().extend_from_slice(&[self.next_byte()])\n-            }\n-        }\n-        self.next();\n-        result\n-    }\n-\n-    fn parse_trait_ref(&mut self) -> ty::TraitRef<'tcx> {\n-        ty::TraitRef {\n-            def_id: self.parse_def(),\n-            substs: self.parse_substs()\n-        }\n-    }\n-\n-    fn parse_existential_trait_ref(&mut self) -> ty::ExistentialTraitRef<'tcx> {\n-        ty::ExistentialTraitRef {\n-            def_id: self.parse_def(),\n-            substs: self.parse_substs()\n-        }\n-    }\n-\n-    pub fn parse_ty(&mut self) -> Ty<'tcx> {\n-        let tcx = self.tcx;\n-        match self.next() {\n-            'b' => return tcx.types.bool,\n-            '!' => return tcx.types.never,\n-            'i' => { /* eat the s of is */ self.next(); return tcx.types.isize },\n-            'u' => { /* eat the s of us */ self.next(); return tcx.types.usize },\n-            'M' => {\n-                match self.next() {\n-                    'b' => return tcx.types.u8,\n-                    'w' => return tcx.types.u16,\n-                    'l' => return tcx.types.u32,\n-                    'd' => return tcx.types.u64,\n-                    'B' => return tcx.types.i8,\n-                    'W' => return tcx.types.i16,\n-                    'L' => return tcx.types.i32,\n-                    'D' => return tcx.types.i64,\n-                    'f' => return tcx.types.f32,\n-                    'F' => return tcx.types.f64,\n-                    _ => bug!(\"parse_ty: bad numeric type\")\n-                }\n-            }\n-            'c' => return tcx.types.char,\n-            'x' => {\n-                assert_eq!(self.next(), '[');\n-                let trait_ref = ty::Binder(self.parse_existential_trait_ref());\n-                let builtin_bounds = self.parse_builtin_bounds();\n-                let region_bound = self.parse_region();\n-                let mut projection_bounds = Vec::new();\n-\n-                loop {\n-                    match self.next() {\n-                        'P' => {\n-                            let bound = self.parse_existential_projection();\n-                            projection_bounds.push(ty::Binder(bound));\n-                        }\n-                        '.' => { break; }\n-                        c => {\n-                            bug!(\"parse_bounds: bad bounds ('{}')\", c)\n-                        }\n-                    }\n-                }\n-                assert_eq!(self.next(), ']');\n-                return tcx.mk_trait(ty::TraitObject {\n-                    principal: trait_ref,\n-                    region_bound: region_bound,\n-                    builtin_bounds: builtin_bounds,\n-                    projection_bounds: projection_bounds\n-                });\n-            }\n-            'p' => {\n-                assert_eq!(self.next(), '[');\n-                let index = self.parse_u32();\n-                assert_eq!(self.next(), '|');\n-                let name = token::intern(&self.parse_str(']'));\n-                return tcx.mk_param(index, name);\n-            }\n-            '~' => return tcx.mk_box(self.parse_ty()),\n-            '*' => return tcx.mk_ptr(self.parse_mt()),\n-            '&' => {\n-                return tcx.mk_ref(self.parse_region(), self.parse_mt());\n-            }\n-            'V' => {\n-                let t = self.parse_ty();\n-                return match self.parse_size() {\n-                    Some(n) => tcx.mk_array(t, n),\n-                    None => tcx.mk_slice(t)\n-                };\n-            }\n-            'v' => {\n-                return tcx.mk_str();\n-            }\n-            'T' => {\n-                assert_eq!(self.next(), '[');\n-                let mut params = Vec::new();\n-                while self.peek() != ']' { params.push(self.parse_ty()); }\n-                self.pos = self.pos + 1;\n-                return tcx.mk_tup(params);\n-            }\n-            'F' => {\n-                let def_id = self.parse_def();\n-                let substs = self.parse_substs();\n-                return tcx.mk_fn_def(def_id, substs, self.parse_bare_fn_ty());\n-            }\n-            'G' => {\n-                return tcx.mk_fn_ptr(self.parse_bare_fn_ty());\n-            }\n-            '#' => {\n-                // This is a hacky little caching scheme. The idea is that if we encode\n-                // the same type twice, the second (and third, and fourth...) time we will\n-                // just write `#123`, where `123` is the offset in the metadata of the\n-                // first appearance. Now when we are *decoding*, if we see a `#123`, we\n-                // can first check a cache (`tcx.rcache`) for that offset. If we find something,\n-                // we return it (modulo closure types, see below). But if not, then we\n-                // jump to offset 123 and read the type from there.\n-\n-                let pos = self.parse_vuint();\n-                let key = ty::CReaderCacheKey { cnum: self.krate, pos: pos };\n-                if let Some(tt) = tcx.rcache.borrow().get(&key).cloned() {\n-                    // If there is a closure buried in the type some where, then we\n-                    // need to re-convert any def ids (see case 'k', below). That means\n-                    // we can't reuse the cached version.\n-                    if !tt.has_closure_types() {\n-                        return tt;\n-                    }\n-                }\n-\n-                let mut substate = TyDecoder::new(self.data,\n-                                                  self.krate,\n-                                                  pos,\n-                                                  self.tcx,\n-                                                  self.conv_def_id);\n-                let tt = substate.parse_ty();\n-                tcx.rcache.borrow_mut().insert(key, tt);\n-                return tt;\n-            }\n-            '\\\"' => {\n-                let _ = self.parse_def();\n-                let inner = self.parse_ty();\n-                inner\n-            }\n-            'a' => {\n-                assert_eq!(self.next(), '[');\n-                let did = self.parse_def();\n-                let substs = self.parse_substs();\n-                assert_eq!(self.next(), ']');\n-                let def = self.tcx.lookup_adt_def(did);\n-                return self.tcx.mk_adt(def, substs);\n-            }\n-            'k' => {\n-                assert_eq!(self.next(), '[');\n-                let did = self.parse_def();\n-                let substs = self.parse_substs();\n-                let mut tys = vec![];\n-                while self.peek() != '.' {\n-                    tys.push(self.parse_ty());\n-                }\n-                assert_eq!(self.next(), '.');\n-                assert_eq!(self.next(), ']');\n-                return self.tcx.mk_closure(did, substs, tys);\n-            }\n-            'P' => {\n-                assert_eq!(self.next(), '[');\n-                let trait_ref = self.parse_trait_ref();\n-                let name = token::intern(&self.parse_str(']'));\n-                return tcx.mk_projection(trait_ref, name);\n-            }\n-            'A' => {\n-                assert_eq!(self.next(), '[');\n-                let def_id = self.parse_def();\n-                let substs = self.parse_substs();\n-                assert_eq!(self.next(), ']');\n-                return self.tcx.mk_anon(def_id, substs);\n-            }\n-            'e' => {\n-                return tcx.types.err;\n-            }\n-            c => { bug!(\"unexpected char in type string: {}\", c);}\n-        }\n-    }\n-\n-    fn parse_mutability(&mut self) -> hir::Mutability {\n-        match self.peek() {\n-            'm' => { self.next(); hir::MutMutable }\n-            _ => { hir::MutImmutable }\n-        }\n-    }\n-\n-    fn parse_mt(&mut self) -> ty::TypeAndMut<'tcx> {\n-        let m = self.parse_mutability();\n-        ty::TypeAndMut { ty: self.parse_ty(), mutbl: m }\n-    }\n-\n-    fn parse_def(&mut self) -> DefId {\n-        let def_id = parse_defid(self.scan(|c| c == '|'));\n-        return (self.conv_def_id)(def_id);\n-    }\n-\n-    fn parse_uint(&mut self) -> usize {\n-        let mut n = 0;\n-        loop {\n-            let cur = self.peek();\n-            if cur < '0' || cur > '9' { return n; }\n-            self.pos = self.pos + 1;\n-            n *= 10;\n-            n += (cur as usize) - ('0' as usize);\n-        };\n-    }\n-\n-    fn parse_u32(&mut self) -> u32 {\n-        let n = self.parse_uint();\n-        let m = n as u32;\n-        assert_eq!(m as usize, n);\n-        m\n-    }\n-\n-    fn parse_abi_set(&mut self) -> abi::Abi {\n-        assert_eq!(self.next(), '[');\n-        let bytes = self.scan(|c| c == ']');\n-        let abi_str = str::from_utf8(bytes).unwrap();\n-        abi::lookup(&abi_str[..]).expect(abi_str)\n-    }\n-\n-    fn parse_bare_fn_ty(&mut self) -> &'tcx ty::BareFnTy<'tcx> {\n-        let unsafety = parse_unsafety(self.next());\n-        let abi = self.parse_abi_set();\n-        let sig = self.parse_sig();\n-        self.tcx.mk_bare_fn(ty::BareFnTy {\n-            unsafety: unsafety,\n-            abi: abi,\n-            sig: sig\n-        })\n-    }\n-\n-    fn parse_sig(&mut self) -> ty::PolyFnSig<'tcx> {\n-        assert_eq!(self.next(), '[');\n-        let mut inputs = Vec::new();\n-        while self.peek() != ']' {\n-            inputs.push(self.parse_ty());\n-        }\n-        self.pos += 1; // eat the ']'\n-        let variadic = match self.next() {\n-            'V' => true,\n-            'N' => false,\n-            r => bug!(\"bad variadic: {}\", r),\n-        };\n-        let output = self.parse_ty();\n-        ty::Binder(ty::FnSig {inputs: inputs,\n-                              output: output,\n-                              variadic: variadic})\n-    }\n-\n-    fn parse_existential_projection(&mut self) -> ty::ExistentialProjection<'tcx> {\n-        ty::ExistentialProjection {\n-            trait_ref: self.parse_existential_trait_ref(),\n-            item_name: token::intern(&self.parse_str('|')),\n-            ty: self.parse_ty(),\n-        }\n-    }\n-\n-    fn parse_builtin_bounds(&mut self) -> ty::BuiltinBounds {\n-        let mut builtin_bounds = ty::BuiltinBounds::empty();\n-        loop {\n-            match self.next() {\n-                'S' => {\n-                    builtin_bounds.insert(ty::BoundSend);\n-                }\n-                'Z' => {\n-                    builtin_bounds.insert(ty::BoundSized);\n-                }\n-                'P' => {\n-                    builtin_bounds.insert(ty::BoundCopy);\n-                }\n-                'T' => {\n-                    builtin_bounds.insert(ty::BoundSync);\n-                }\n-                '.' => {\n-                    return builtin_bounds;\n-                }\n-                c => {\n-                    bug!(\"parse_bounds: bad builtin bounds ('{}')\", c)\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-// Rust metadata parsing\n-fn parse_defid(buf: &[u8]) -> DefId {\n-    let mut colon_idx = 0;\n-    let len = buf.len();\n-    while colon_idx < len && buf[colon_idx] != ':' as u8 { colon_idx += 1; }\n-    if colon_idx == len {\n-        error!(\"didn't find ':' when parsing def id\");\n-        bug!();\n-    }\n-\n-    let crate_part = &buf[0..colon_idx];\n-    let def_part = &buf[colon_idx + 1..len];\n-\n-    let crate_num = match str::from_utf8(crate_part).ok().and_then(|s| {\n-        s.parse::<usize>().ok()\n-    }) {\n-        Some(cn) => CrateNum::new(cn),\n-        None => bug!(\"internal error: parse_defid: crate number expected, found {:?}\",\n-                       crate_part)\n-    };\n-    let def_num = match str::from_utf8(def_part).ok().and_then(|s| {\n-        s.parse::<usize>().ok()\n-    }) {\n-        Some(dn) => dn,\n-        None => bug!(\"internal error: parse_defid: id expected, found {:?}\",\n-                       def_part)\n-    };\n-    let index = DefIndex::new(def_num);\n-    DefId { krate: crate_num, index: index }\n-}\n-\n-fn parse_unsafety(c: char) -> hir::Unsafety {\n-    match c {\n-        'u' => hir::Unsafety::Unsafe,\n-        'n' => hir::Unsafety::Normal,\n-        _ => bug!(\"parse_unsafety: bad unsafety {}\", c)\n-    }\n-}"}, {"sha": "54b4dc933424e7eca4f2274f244849e9e3801823", "filename": "src/librustc_metadata/tyencode.rs", "status": "removed", "additions": 0, "deletions": 385, "changes": 385, "blob_url": "https://github.com/rust-lang/rust/blob/bcbb4107a1a966ea8ad48d370f553dffde780392/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcbb4107a1a966ea8ad48d370f553dffde780392/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=bcbb4107a1a966ea8ad48d370f553dffde780392", "patch": "@@ -1,385 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Type encoding\n-\n-#![allow(unused_must_use)] // as with encoding, everything is a no-fail MemWriter\n-#![allow(non_camel_case_types)]\n-\n-use std::cell::RefCell;\n-use std::io::Cursor;\n-use std::io::prelude::*;\n-\n-use rustc::hir::def_id::DefId;\n-use middle::region;\n-use rustc::ty::subst::Substs;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::util::nodemap::FnvHashMap;\n-\n-use rustc::hir;\n-\n-use syntax::abi::Abi;\n-use syntax::ast;\n-\n-use rustc_serialize::leb128;\n-use encoder;\n-\n-pub struct ctxt<'a, 'tcx: 'a> {\n-    // Def -> str Callback:\n-    pub ds: for<'b> fn(TyCtxt<'b, 'tcx, 'tcx>, DefId) -> String,\n-    // The type context.\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    pub abbrevs: &'a abbrev_map<'tcx>\n-}\n-\n-impl<'a, 'tcx> encoder::EncodeContext<'a, 'tcx> {\n-    pub fn ty_str_ctxt(&self) -> ctxt<'a, 'tcx> {\n-        ctxt {\n-            ds: encoder::def_to_string,\n-            tcx: self.tcx,\n-            abbrevs: self.type_abbrevs\n-        }\n-    }\n-}\n-\n-// Compact string representation for Ty values. API TyStr & parse_from_str.\n-// Extra parameters are for converting to/from def_ids in the string rep.\n-// Whatever format you choose should not contain pipe characters.\n-pub struct ty_abbrev {\n-    s: Vec<u8>\n-}\n-\n-pub type abbrev_map<'tcx> = RefCell<FnvHashMap<Ty<'tcx>, ty_abbrev>>;\n-\n-pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n-    if let Some(a) = cx.abbrevs.borrow_mut().get(&t) {\n-        w.write_all(&a.s);\n-        return;\n-    }\n-\n-    let pos = w.position();\n-\n-    match t.sty {\n-        ty::TyBool => { write!(w, \"b\"); }\n-        ty::TyChar => { write!(w, \"c\"); }\n-        ty::TyNever => { write!(w, \"!\"); }\n-        ty::TyInt(t) => {\n-            match t {\n-                ast::IntTy::Is => write!(w, \"is\"),\n-                ast::IntTy::I8 => write!(w, \"MB\"),\n-                ast::IntTy::I16 => write!(w, \"MW\"),\n-                ast::IntTy::I32 => write!(w, \"ML\"),\n-                ast::IntTy::I64 => write!(w, \"MD\")\n-            };\n-        }\n-        ty::TyUint(t) => {\n-            match t {\n-                ast::UintTy::Us => write!(w, \"us\"),\n-                ast::UintTy::U8 => write!(w, \"Mb\"),\n-                ast::UintTy::U16 => write!(w, \"Mw\"),\n-                ast::UintTy::U32 => write!(w, \"Ml\"),\n-                ast::UintTy::U64 => write!(w, \"Md\")\n-            };\n-        }\n-        ty::TyFloat(t) => {\n-            match t {\n-                ast::FloatTy::F32 => write!(w, \"Mf\"),\n-                ast::FloatTy::F64 => write!(w, \"MF\"),\n-            };\n-        }\n-        ty::TyTrait(ref obj) => {\n-            write!(w, \"x[\");\n-            enc_existential_trait_ref(w, cx, obj.principal.0);\n-            enc_builtin_bounds(w, cx, &obj.builtin_bounds);\n-\n-            enc_region(w, cx, obj.region_bound);\n-\n-            for tp in &obj.projection_bounds {\n-                write!(w, \"P\");\n-                enc_existential_projection(w, cx, &tp.0);\n-            }\n-\n-            write!(w, \".\");\n-            write!(w, \"]\");\n-        }\n-        ty::TyTuple(ts) => {\n-            write!(w, \"T[\");\n-            for t in ts { enc_ty(w, cx, *t); }\n-            write!(w, \"]\");\n-        }\n-        ty::TyBox(typ) => { write!(w, \"~\"); enc_ty(w, cx, typ); }\n-        ty::TyRawPtr(mt) => { write!(w, \"*\"); enc_mt(w, cx, mt); }\n-        ty::TyRef(r, mt) => {\n-            write!(w, \"&\");\n-            enc_region(w, cx, r);\n-            enc_mt(w, cx, mt);\n-        }\n-        ty::TyArray(t, sz) => {\n-            write!(w, \"V\");\n-            enc_ty(w, cx, t);\n-            write!(w, \"/{}|\", sz);\n-        }\n-        ty::TySlice(t) => {\n-            write!(w, \"V\");\n-            enc_ty(w, cx, t);\n-            write!(w, \"/|\");\n-        }\n-        ty::TyStr => {\n-            write!(w, \"v\");\n-        }\n-        ty::TyFnDef(def_id, substs, f) => {\n-            write!(w, \"F\");\n-            write!(w, \"{}|\", (cx.ds)(cx.tcx, def_id));\n-            enc_substs(w, cx, substs);\n-            enc_bare_fn_ty(w, cx, f);\n-        }\n-        ty::TyFnPtr(f) => {\n-            write!(w, \"G\");\n-            enc_bare_fn_ty(w, cx, f);\n-        }\n-        ty::TyInfer(_) => {\n-            bug!(\"cannot encode inference variable types\");\n-        }\n-        ty::TyParam(p) => {\n-            write!(w, \"p[{}|{}]\", p.idx, p.name);\n-        }\n-        ty::TyAdt(def, substs) => {\n-            write!(w, \"a[{}|\", (cx.ds)(cx.tcx, def.did));\n-            enc_substs(w, cx, substs);\n-            write!(w, \"]\");\n-        }\n-        ty::TyClosure(def, substs) => {\n-            write!(w, \"k[{}|\", (cx.ds)(cx.tcx, def));\n-            enc_substs(w, cx, substs.func_substs);\n-            for ty in substs.upvar_tys {\n-                enc_ty(w, cx, ty);\n-            }\n-            write!(w, \".\");\n-            write!(w, \"]\");\n-        }\n-        ty::TyProjection(ref data) => {\n-            write!(w, \"P[\");\n-            enc_trait_ref(w, cx, data.trait_ref);\n-            write!(w, \"{}]\", data.item_name);\n-        }\n-        ty::TyAnon(def_id, substs) => {\n-            write!(w, \"A[{}|\", (cx.ds)(cx.tcx, def_id));\n-            enc_substs(w, cx, substs);\n-            write!(w, \"]\");\n-        }\n-        ty::TyError => {\n-            write!(w, \"e\");\n-        }\n-    }\n-\n-    let end = w.position();\n-    let len = end - pos;\n-\n-    let mut abbrev = Cursor::new(Vec::with_capacity(16));\n-    abbrev.write_all(b\"#\");\n-    {\n-        let start_position = abbrev.position() as usize;\n-        let meta_start = 8 + ::common::metadata_encoding_version.len() as u64;\n-        let bytes_written = leb128::write_unsigned_leb128(abbrev.get_mut(),\n-                                                          start_position,\n-                                                          pos - meta_start);\n-        abbrev.set_position((start_position + bytes_written) as u64);\n-    }\n-\n-    cx.abbrevs.borrow_mut().insert(t, ty_abbrev {\n-        s: if abbrev.position() < len {\n-            abbrev.get_ref()[..abbrev.position() as usize].to_owned()\n-        } else {\n-            // if the abbreviation is longer than the real type,\n-            // don't use #-notation. However, insert it here so\n-            // other won't have to `mark_stable_position`\n-            w.get_ref()[pos as usize .. end as usize].to_owned()\n-        }\n-    });\n-}\n-\n-fn enc_mutability(w: &mut Cursor<Vec<u8>>, mt: hir::Mutability) {\n-    match mt {\n-        hir::MutImmutable => (),\n-        hir::MutMutable => {\n-            write!(w, \"m\");\n-        }\n-    };\n-}\n-\n-fn enc_mt<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n-                    mt: ty::TypeAndMut<'tcx>) {\n-    enc_mutability(w, mt.mutbl);\n-    enc_ty(w, cx, mt.ty);\n-}\n-\n-fn enc_substs<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n-                        substs: &Substs<'tcx>) {\n-    write!(w, \"[\");\n-    for &k in substs.params() {\n-        if let Some(ty) = k.as_type() {\n-            write!(w, \"t\");\n-            enc_ty(w, cx, ty);\n-        } else if let Some(r) = k.as_region() {\n-            write!(w, \"r\");\n-            enc_region(w, cx, r);\n-        } else {\n-            bug!()\n-        }\n-    }\n-    write!(w, \"]\");\n-}\n-\n-fn enc_region(w: &mut Cursor<Vec<u8>>, cx: &ctxt, r: &ty::Region) {\n-    match *r {\n-        ty::ReLateBound(id, br) => {\n-            write!(w, \"b[{}|\", id.depth);\n-            enc_bound_region(w, cx, br);\n-            write!(w, \"]\");\n-        }\n-        ty::ReEarlyBound(ref data) => {\n-            write!(w, \"B[{}|{}]\",\n-                   data.index,\n-                   data.name);\n-        }\n-        ty::ReFree(ref fr) => {\n-            write!(w, \"f[\");\n-            enc_scope(w, cx, fr.scope);\n-            write!(w, \"|\");\n-            enc_bound_region(w, cx, fr.bound_region);\n-            write!(w, \"]\");\n-        }\n-        ty::ReScope(scope) => {\n-            write!(w, \"s\");\n-            enc_scope(w, cx, scope);\n-            write!(w, \"|\");\n-        }\n-        ty::ReStatic => {\n-            write!(w, \"t\");\n-        }\n-        ty::ReEmpty => {\n-            write!(w, \"e\");\n-        }\n-        ty::ReErased => {\n-            write!(w, \"E\");\n-        }\n-        ty::ReVar(_) | ty::ReSkolemized(..) => {\n-            // these should not crop up after typeck\n-            bug!(\"cannot encode region variables\");\n-        }\n-    }\n-}\n-\n-fn enc_scope(w: &mut Cursor<Vec<u8>>, cx: &ctxt, scope: region::CodeExtent) {\n-    match cx.tcx.region_maps.code_extent_data(scope) {\n-        region::CodeExtentData::CallSiteScope {\n-            fn_id, body_id } => write!(w, \"C[{}|{}]\", fn_id, body_id),\n-        region::CodeExtentData::ParameterScope {\n-            fn_id, body_id } => write!(w, \"P[{}|{}]\", fn_id, body_id),\n-        region::CodeExtentData::Misc(node_id) => write!(w, \"M{}\", node_id),\n-        region::CodeExtentData::Remainder(region::BlockRemainder {\n-            block: b, first_statement_index: i }) => write!(w, \"B[{}|{}]\", b, i),\n-        region::CodeExtentData::DestructionScope(node_id) => write!(w, \"D{}\", node_id),\n-    };\n-}\n-\n-fn enc_bound_region(w: &mut Cursor<Vec<u8>>, cx: &ctxt, br: ty::BoundRegion) {\n-    match br {\n-        ty::BrAnon(idx) => {\n-            write!(w, \"a{}|\", idx);\n-        }\n-        ty::BrNamed(d, name, issue32330) => {\n-            write!(w, \"[{}|{}|\",\n-                   (cx.ds)(cx.tcx, d),\n-                   name);\n-\n-            match issue32330 {\n-                ty::Issue32330::WontChange =>\n-                    write!(w, \"n]\"),\n-                ty::Issue32330::WillChange { fn_def_id, region_name } =>\n-                    write!(w, \"y{}|{}]\", (cx.ds)(cx.tcx, fn_def_id), region_name),\n-            };\n-        }\n-        ty::BrFresh(id) => {\n-            write!(w, \"f{}|\", id);\n-        }\n-        ty::BrEnv => {\n-            write!(w, \"e|\");\n-        }\n-    }\n-}\n-\n-fn enc_trait_ref<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n-                           s: ty::TraitRef<'tcx>) {\n-    write!(w, \"{}|\", (cx.ds)(cx.tcx, s.def_id));\n-    enc_substs(w, cx, s.substs);\n-}\n-\n-fn enc_existential_trait_ref<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n-                                       s: ty::ExistentialTraitRef<'tcx>) {\n-    write!(w, \"{}|\", (cx.ds)(cx.tcx, s.def_id));\n-    enc_substs(w, cx, s.substs);\n-}\n-\n-fn enc_unsafety(w: &mut Cursor<Vec<u8>>, p: hir::Unsafety) {\n-    match p {\n-        hir::Unsafety::Normal => write!(w, \"n\"),\n-        hir::Unsafety::Unsafe => write!(w, \"u\"),\n-    };\n-}\n-\n-fn enc_abi(w: &mut Cursor<Vec<u8>>, abi: Abi) {\n-    write!(w, \"[\");\n-    write!(w, \"{}\", abi.name());\n-    write!(w, \"]\");\n-}\n-\n-fn enc_bare_fn_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n-                            ft: &ty::BareFnTy<'tcx>) {\n-    enc_unsafety(w, ft.unsafety);\n-    enc_abi(w, ft.abi);\n-    enc_fn_sig(w, cx, &ft.sig);\n-}\n-\n-fn enc_fn_sig<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n-                        fsig: &ty::PolyFnSig<'tcx>) {\n-    write!(w, \"[\");\n-    for ty in &fsig.0.inputs {\n-        enc_ty(w, cx, *ty);\n-    }\n-    write!(w, \"]\");\n-    if fsig.0.variadic {\n-        write!(w, \"V\");\n-    } else {\n-        write!(w, \"N\");\n-    }\n-    enc_ty(w, cx, fsig.0.output);\n-}\n-\n-fn enc_builtin_bounds(w: &mut Cursor<Vec<u8>>, _cx: &ctxt, bs: &ty::BuiltinBounds) {\n-    for bound in bs {\n-        match bound {\n-            ty::BoundSend => write!(w, \"S\"),\n-            ty::BoundSized => write!(w, \"Z\"),\n-            ty::BoundCopy => write!(w, \"P\"),\n-            ty::BoundSync => write!(w, \"T\"),\n-        };\n-    }\n-\n-    write!(w, \".\");\n-}\n-\n-fn enc_existential_projection<'a, 'tcx>(w: &mut Cursor<Vec<u8>>,\n-                                        cx: &ctxt<'a, 'tcx>,\n-                                        data: &ty::ExistentialProjection<'tcx>) {\n-    enc_existential_trait_ref(w, cx, data.trait_ref);\n-    write!(w, \"{}|\", data.item_name);\n-    enc_ty(w, cx, data.ty);\n-}"}, {"sha": "ba9bf2b86a60fbcf1de9f0873ddbd2898ac0915f", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=88c5679c4e0ba0bd21a15eaaf8e5fafcc6bcdafd", "patch": "@@ -134,7 +134,7 @@ impl<\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         let mut bits = 0;\n         for item in self {\n-            bits |= item.to_usize();\n+            bits |= 1 << item.to_usize();\n         }\n         s.emit_usize(bits)\n     }\n@@ -148,7 +148,7 @@ impl<\n         let mut set = EnumSet::new();\n         for bit in 0..(mem::size_of::<usize>()*8) {\n             if bits & (1 << bit) != 0 {\n-                set.insert(CLike::from_usize(1 << bit));\n+                set.insert(CLike::from_usize(bit));\n             }\n         }\n         Ok(set)"}]}