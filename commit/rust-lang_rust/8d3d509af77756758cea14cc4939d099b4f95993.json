{"sha": "8d3d509af77756758cea14cc4939d099b4f95993", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkM2Q1MDlhZjc3NzU2NzU4Y2VhMTRjYzQ5MzlkMDk5YjRmOTU5OTM=", "commit": {"author": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2020-10-24T07:47:23Z"}, "committer": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2020-10-24T07:47:23Z"}, "message": "Remove dependency on 'assists' from 'completion' crate", "tree": {"sha": "a9aa8cccf437facc9e7a300ce688cb727aa2a783", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9aa8cccf437facc9e7a300ce688cb727aa2a783"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d3d509af77756758cea14cc4939d099b4f95993", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d3d509af77756758cea14cc4939d099b4f95993", "html_url": "https://github.com/rust-lang/rust/commit/8d3d509af77756758cea14cc4939d099b4f95993", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d3d509af77756758cea14cc4939d099b4f95993/comments", "author": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4105378dc7479a3dbd39a4afb3eba67d083bd7f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4105378dc7479a3dbd39a4afb3eba67d083bd7f8", "html_url": "https://github.com/rust-lang/rust/commit/4105378dc7479a3dbd39a4afb3eba67d083bd7f8"}], "stats": {"total": 280, "additions": 151, "deletions": 129}, "files": [{"sha": "a69aef199f853c46269b7fe62a04c65212a10016", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d509af77756758cea14cc4939d099b4f95993/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d509af77756758cea14cc4939d099b4f95993/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=8d3d509af77756758cea14cc4939d099b4f95993", "patch": "@@ -268,7 +268,6 @@ dependencies = [\n name = \"completion\"\n version = \"0.0.0\"\n dependencies = [\n- \"assists\",\n  \"base_db\",\n  \"call_info\",\n  \"expect-test\","}, {"sha": "b82fb30ad47a023f1f949707223c7da3b6bee5e2", "filename": "crates/assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d509af77756758cea14cc4939d099b4f95993/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d509af77756758cea14cc4939d099b4f95993/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=8d3d509af77756758cea14cc4939d099b4f95993", "patch": "@@ -1,4 +1,5 @@\n use hir::HasSource;\n+use ide_db::traits::{get_missing_assoc_items, resolve_target_trait};\n use syntax::{\n     ast::{\n         self,\n@@ -11,7 +12,7 @@ use syntax::{\n use crate::{\n     assist_context::{AssistContext, Assists},\n     ast_transform::{self, AstTransform, QualifyPaths, SubstituteTypeParams},\n-    utils::{get_missing_assoc_items, render_snippet, resolve_target_trait, Cursor},\n+    utils::{render_snippet, Cursor},\n     AssistId, AssistKind,\n };\n "}, {"sha": "9a49c48c1fae967710c9100e38aa28ec281a471e", "filename": "crates/assists/src/handlers/replace_if_let_with_match.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d509af77756758cea14cc4939d099b4f95993/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d509af77756758cea14cc4939d099b4f95993/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs?ref=8d3d509af77756758cea14cc4939d099b4f95993", "patch": "@@ -7,10 +7,8 @@ use syntax::{\n     AstNode,\n };\n \n-use crate::{\n-    utils::{unwrap_trivial_block, TryEnum},\n-    AssistContext, AssistId, AssistKind, Assists,\n-};\n+use crate::{utils::unwrap_trivial_block, AssistContext, AssistId, AssistKind, Assists};\n+use ide_db::ty_filter::TryEnum;\n \n // Assist: replace_if_let_with_match\n //"}, {"sha": "a5bcbda24e1d1aab64ebae8cc4ee2ec06a191041", "filename": "crates/assists/src/handlers/replace_let_with_if_let.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d509af77756758cea14cc4939d099b4f95993/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d509af77756758cea14cc4939d099b4f95993/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs?ref=8d3d509af77756758cea14cc4939d099b4f95993", "patch": "@@ -9,7 +9,8 @@ use syntax::{\n     AstNode, T,\n };\n \n-use crate::{utils::TryEnum, AssistContext, AssistId, AssistKind, Assists};\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n+use ide_db::ty_filter::TryEnum;\n \n // Assist: replace_let_with_if_let\n //"}, {"sha": "f547066f0da9bc5ade3a2390ef79dc861ed501ba", "filename": "crates/assists/src/handlers/replace_unwrap_with_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d509af77756758cea14cc4939d099b4f95993/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d509af77756758cea14cc4939d099b4f95993/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs?ref=8d3d509af77756758cea14cc4939d099b4f95993", "patch": "@@ -10,9 +10,10 @@ use syntax::{\n };\n \n use crate::{\n-    utils::{render_snippet, Cursor, TryEnum},\n+    utils::{render_snippet, Cursor},\n     AssistContext, AssistId, AssistKind, Assists,\n };\n+use ide_db::ty_filter::TryEnum;\n \n // Assist: replace_unwrap_with_match\n //"}, {"sha": "56f925ee699837d928fa2067ccd5a2df692c1cae", "filename": "crates/assists/src/utils.rs", "status": "modified", "additions": 3, "deletions": 118, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d509af77756758cea14cc4939d099b4f95993/crates%2Fassists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d509af77756758cea14cc4939d099b4f95993/crates%2Fassists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils.rs?ref=8d3d509af77756758cea14cc4939d099b4f95993", "patch": "@@ -2,14 +2,13 @@\n pub(crate) mod insert_use;\n pub(crate) mod import_assets;\n \n-use std::{iter, ops};\n+use std::ops;\n \n-use hir::{Adt, Crate, Enum, Module, ScopeDef, Semantics, Trait, Type};\n+use hir::{Crate, Enum, Module, ScopeDef, Semantics, Trait};\n use ide_db::RootDatabase;\n use itertools::Itertools;\n-use rustc_hash::FxHashSet;\n use syntax::{\n-    ast::{self, make, ArgListOwner, NameOwner},\n+    ast::{self, make, ArgListOwner},\n     AstNode, Direction,\n     SyntaxKind::*,\n     SyntaxNode, TextSize, T,\n@@ -115,72 +114,6 @@ pub(crate) fn render_snippet(_cap: SnippetCap, node: &SyntaxNode, cursor: Cursor\n     }\n }\n \n-pub fn get_missing_assoc_items(\n-    sema: &Semantics<RootDatabase>,\n-    impl_def: &ast::Impl,\n-) -> Vec<hir::AssocItem> {\n-    // Names must be unique between constants and functions. However, type aliases\n-    // may share the same name as a function or constant.\n-    let mut impl_fns_consts = FxHashSet::default();\n-    let mut impl_type = FxHashSet::default();\n-\n-    if let Some(item_list) = impl_def.assoc_item_list() {\n-        for item in item_list.assoc_items() {\n-            match item {\n-                ast::AssocItem::Fn(f) => {\n-                    if let Some(n) = f.name() {\n-                        impl_fns_consts.insert(n.syntax().to_string());\n-                    }\n-                }\n-\n-                ast::AssocItem::TypeAlias(t) => {\n-                    if let Some(n) = t.name() {\n-                        impl_type.insert(n.syntax().to_string());\n-                    }\n-                }\n-\n-                ast::AssocItem::Const(c) => {\n-                    if let Some(n) = c.name() {\n-                        impl_fns_consts.insert(n.syntax().to_string());\n-                    }\n-                }\n-                ast::AssocItem::MacroCall(_) => (),\n-            }\n-        }\n-    }\n-\n-    resolve_target_trait(sema, impl_def).map_or(vec![], |target_trait| {\n-        target_trait\n-            .items(sema.db)\n-            .iter()\n-            .filter(|i| match i {\n-                hir::AssocItem::Function(f) => {\n-                    !impl_fns_consts.contains(&f.name(sema.db).to_string())\n-                }\n-                hir::AssocItem::TypeAlias(t) => !impl_type.contains(&t.name(sema.db).to_string()),\n-                hir::AssocItem::Const(c) => c\n-                    .name(sema.db)\n-                    .map(|n| !impl_fns_consts.contains(&n.to_string()))\n-                    .unwrap_or_default(),\n-            })\n-            .cloned()\n-            .collect()\n-    })\n-}\n-\n-pub(crate) fn resolve_target_trait(\n-    sema: &Semantics<RootDatabase>,\n-    impl_def: &ast::Impl,\n-) -> Option<hir::Trait> {\n-    let ast_path =\n-        impl_def.trait_().map(|it| it.syntax().clone()).and_then(ast::PathType::cast)?.path()?;\n-\n-    match sema.resolve_path(&ast_path) {\n-        Some(hir::PathResolution::Def(hir::ModuleDef::Trait(def))) => Some(def),\n-        _ => None,\n-    }\n-}\n-\n pub(crate) fn vis_offset(node: &SyntaxNode) -> TextSize {\n     node.children_with_tokens()\n         .find(|it| !matches!(it.kind(), WHITESPACE | COMMENT | ATTR))\n@@ -223,54 +156,6 @@ fn invert_special_case(expr: &ast::Expr) -> Option<ast::Expr> {\n     }\n }\n \n-#[derive(Clone, Copy)]\n-pub enum TryEnum {\n-    Result,\n-    Option,\n-}\n-\n-impl TryEnum {\n-    const ALL: [TryEnum; 2] = [TryEnum::Option, TryEnum::Result];\n-\n-    pub fn from_ty(sema: &Semantics<RootDatabase>, ty: &Type) -> Option<TryEnum> {\n-        let enum_ = match ty.as_adt() {\n-            Some(Adt::Enum(it)) => it,\n-            _ => return None,\n-        };\n-        TryEnum::ALL.iter().find_map(|&var| {\n-            if &enum_.name(sema.db).to_string() == var.type_name() {\n-                return Some(var);\n-            }\n-            None\n-        })\n-    }\n-\n-    pub(crate) fn happy_case(self) -> &'static str {\n-        match self {\n-            TryEnum::Result => \"Ok\",\n-            TryEnum::Option => \"Some\",\n-        }\n-    }\n-\n-    pub(crate) fn sad_pattern(self) -> ast::Pat {\n-        match self {\n-            TryEnum::Result => make::tuple_struct_pat(\n-                make::path_unqualified(make::path_segment(make::name_ref(\"Err\"))),\n-                iter::once(make::wildcard_pat().into()),\n-            )\n-            .into(),\n-            TryEnum::Option => make::ident_pat(make::name(\"None\")).into(),\n-        }\n-    }\n-\n-    fn type_name(self) -> &'static str {\n-        match self {\n-            TryEnum::Result => \"Result\",\n-            TryEnum::Option => \"Option\",\n-        }\n-    }\n-}\n-\n /// Helps with finding well-know things inside the standard library. This is\n /// somewhat similar to the known paths infra inside hir, but it different; We\n /// want to make sure that IDE specific paths don't become interesting inside"}, {"sha": "8b6e80448f6c82da370d94585bdfb2783b0b23c0", "filename": "crates/completion/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d509af77756758cea14cc4939d099b4f95993/crates%2Fcompletion%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d509af77756758cea14cc4939d099b4f95993/crates%2Fcompletion%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2FCargo.toml?ref=8d3d509af77756758cea14cc4939d099b4f95993", "patch": "@@ -21,7 +21,6 @@ base_db = { path = \"../base_db\", version = \"0.0.0\" }\n ide_db = { path = \"../ide_db\", version = \"0.0.0\" }\n profile = { path = \"../profile\", version = \"0.0.0\" }\n test_utils = { path = \"../test_utils\", version = \"0.0.0\" }\n-assists = { path = \"../assists\", version = \"0.0.0\" }\n call_info = { path = \"../call_info\", version = \"0.0.0\" }\n \n # completions crate should depend only on the top-level `hir` package. if you need"}, {"sha": "2622f12ab13b0e97750c7a235068ea5e8e6a852f", "filename": "crates/completion/src/complete_postfix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d509af77756758cea14cc4939d099b4f95993/crates%2Fcompletion%2Fsrc%2Fcomplete_postfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d509af77756758cea14cc4939d099b4f95993/crates%2Fcompletion%2Fsrc%2Fcomplete_postfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcomplete_postfix.rs?ref=8d3d509af77756758cea14cc4939d099b4f95993", "patch": "@@ -2,7 +2,7 @@\n \n mod format_like;\n \n-use assists::utils::TryEnum;\n+use ide_db::ty_filter::TryEnum;\n use syntax::{\n     ast::{self, AstNode, AstToken},\n     TextRange, TextSize,"}, {"sha": "a14be9c73b21f02e161645347f6e60f02af1660e", "filename": "crates/completion/src/complete_trait_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d509af77756758cea14cc4939d099b4f95993/crates%2Fcompletion%2Fsrc%2Fcomplete_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d509af77756758cea14cc4939d099b4f95993/crates%2Fcompletion%2Fsrc%2Fcomplete_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcomplete_trait_impl.rs?ref=8d3d509af77756758cea14cc4939d099b4f95993", "patch": "@@ -31,8 +31,8 @@\n //! }\n //! ```\n \n-use assists::utils::get_missing_assoc_items;\n use hir::{self, HasAttrs, HasSource};\n+use ide_db::traits::get_missing_assoc_items;\n use syntax::{\n     ast::{self, edit, Impl},\n     display::function_declaration,"}, {"sha": "88f74265cf60a1538f73fab2ae3df1734896c8e7", "filename": "crates/ide_db/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d509af77756758cea14cc4939d099b4f95993/crates%2Fide_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d509af77756758cea14cc4939d099b4f95993/crates%2Fide_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Flib.rs?ref=8d3d509af77756758cea14cc4939d099b4f95993", "patch": "@@ -10,6 +10,8 @@ pub mod defs;\n pub mod search;\n pub mod imports_locator;\n pub mod source_change;\n+pub mod ty_filter;\n+pub mod traits;\n \n use std::{fmt, sync::Arc};\n "}, {"sha": "dcd61a5950212abdfef22b4493198ca1eab13dcb", "filename": "crates/ide_db/src/traits.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d509af77756758cea14cc4939d099b4f95993/crates%2Fide_db%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d509af77756758cea14cc4939d099b4f95993/crates%2Fide_db%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Ftraits.rs?ref=8d3d509af77756758cea14cc4939d099b4f95993", "patch": "@@ -0,0 +1,78 @@\n+//! Functionality for obtaining data related to traits from the DB.\n+\n+use crate::RootDatabase;\n+use hir::Semantics;\n+use rustc_hash::FxHashSet;\n+use syntax::{\n+    ast::{self, NameOwner},\n+    AstNode,\n+};\n+\n+/// Given the `impl` block, attempts to find the trait this `impl` corresponds to.\n+pub fn resolve_target_trait(\n+    sema: &Semantics<RootDatabase>,\n+    impl_def: &ast::Impl,\n+) -> Option<hir::Trait> {\n+    let ast_path =\n+        impl_def.trait_().map(|it| it.syntax().clone()).and_then(ast::PathType::cast)?.path()?;\n+\n+    match sema.resolve_path(&ast_path) {\n+        Some(hir::PathResolution::Def(hir::ModuleDef::Trait(def))) => Some(def),\n+        _ => None,\n+    }\n+}\n+\n+/// Given the `impl` block, returns the list of associated items (e.g. functions or types) that are\n+/// missing in this `impl` block.\n+pub fn get_missing_assoc_items(\n+    sema: &Semantics<RootDatabase>,\n+    impl_def: &ast::Impl,\n+) -> Vec<hir::AssocItem> {\n+    // Names must be unique between constants and functions. However, type aliases\n+    // may share the same name as a function or constant.\n+    let mut impl_fns_consts = FxHashSet::default();\n+    let mut impl_type = FxHashSet::default();\n+\n+    if let Some(item_list) = impl_def.assoc_item_list() {\n+        for item in item_list.assoc_items() {\n+            match item {\n+                ast::AssocItem::Fn(f) => {\n+                    if let Some(n) = f.name() {\n+                        impl_fns_consts.insert(n.syntax().to_string());\n+                    }\n+                }\n+\n+                ast::AssocItem::TypeAlias(t) => {\n+                    if let Some(n) = t.name() {\n+                        impl_type.insert(n.syntax().to_string());\n+                    }\n+                }\n+\n+                ast::AssocItem::Const(c) => {\n+                    if let Some(n) = c.name() {\n+                        impl_fns_consts.insert(n.syntax().to_string());\n+                    }\n+                }\n+                ast::AssocItem::MacroCall(_) => (),\n+            }\n+        }\n+    }\n+\n+    resolve_target_trait(sema, impl_def).map_or(vec![], |target_trait| {\n+        target_trait\n+            .items(sema.db)\n+            .iter()\n+            .filter(|i| match i {\n+                hir::AssocItem::Function(f) => {\n+                    !impl_fns_consts.contains(&f.name(sema.db).to_string())\n+                }\n+                hir::AssocItem::TypeAlias(t) => !impl_type.contains(&t.name(sema.db).to_string()),\n+                hir::AssocItem::Const(c) => c\n+                    .name(sema.db)\n+                    .map(|n| !impl_fns_consts.contains(&n.to_string()))\n+                    .unwrap_or_default(),\n+            })\n+            .cloned()\n+            .collect()\n+    })\n+}"}, {"sha": "63a94528259b9a7f6ac858718c4c7e9e53390450", "filename": "crates/ide_db/src/ty_filter.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d509af77756758cea14cc4939d099b4f95993/crates%2Fide_db%2Fsrc%2Fty_filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d509af77756758cea14cc4939d099b4f95993/crates%2Fide_db%2Fsrc%2Fty_filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fty_filter.rs?ref=8d3d509af77756758cea14cc4939d099b4f95993", "patch": "@@ -0,0 +1,58 @@\n+//! This module contains structures for filtering the expected types.\n+//! Use case for structures in this module is, for example, situation when you need to process\n+//! only certain `Enum`s.\n+\n+use crate::RootDatabase;\n+use hir::{Adt, Semantics, Type};\n+use std::iter;\n+use syntax::ast::{self, make};\n+\n+/// Enum types that implement `std::ops::Try` trait.\n+#[derive(Clone, Copy)]\n+pub enum TryEnum {\n+    Result,\n+    Option,\n+}\n+\n+impl TryEnum {\n+    const ALL: [TryEnum; 2] = [TryEnum::Option, TryEnum::Result];\n+\n+    /// Returns `Some(..)` if the provided type is an enum that implements `std::ops::Try`.\n+    pub fn from_ty(sema: &Semantics<RootDatabase>, ty: &Type) -> Option<TryEnum> {\n+        let enum_ = match ty.as_adt() {\n+            Some(Adt::Enum(it)) => it,\n+            _ => return None,\n+        };\n+        TryEnum::ALL.iter().find_map(|&var| {\n+            if &enum_.name(sema.db).to_string() == var.type_name() {\n+                return Some(var);\n+            }\n+            None\n+        })\n+    }\n+\n+    pub fn happy_case(self) -> &'static str {\n+        match self {\n+            TryEnum::Result => \"Ok\",\n+            TryEnum::Option => \"Some\",\n+        }\n+    }\n+\n+    pub fn sad_pattern(self) -> ast::Pat {\n+        match self {\n+            TryEnum::Result => make::tuple_struct_pat(\n+                make::path_unqualified(make::path_segment(make::name_ref(\"Err\"))),\n+                iter::once(make::wildcard_pat().into()),\n+            )\n+            .into(),\n+            TryEnum::Option => make::ident_pat(make::name(\"None\")).into(),\n+        }\n+    }\n+\n+    fn type_name(self) -> &'static str {\n+        match self {\n+            TryEnum::Result => \"Result\",\n+            TryEnum::Option => \"Option\",\n+        }\n+    }\n+}"}]}