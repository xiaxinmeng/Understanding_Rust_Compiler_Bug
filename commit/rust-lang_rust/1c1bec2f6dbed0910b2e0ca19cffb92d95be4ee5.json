{"sha": "1c1bec2f6dbed0910b2e0ca19cffb92d95be4ee5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjMWJlYzJmNmRiZWQwOTEwYjJlMGNhMTljZmZiOTJkOTViZTRlZTU=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-29T15:53:54Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-12-02T16:03:03Z"}, "message": "Remove top-level or-pattern hack", "tree": {"sha": "89720a41cd7a0c26fe58a5428f93b31388f10281", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89720a41cd7a0c26fe58a5428f93b31388f10281"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c1bec2f6dbed0910b2e0ca19cffb92d95be4ee5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c1bec2f6dbed0910b2e0ca19cffb92d95be4ee5", "html_url": "https://github.com/rust-lang/rust/commit/1c1bec2f6dbed0910b2e0ca19cffb92d95be4ee5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c1bec2f6dbed0910b2e0ca19cffb92d95be4ee5/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef087d96f0fd44ce83ac8c44d11bbe3faa8e1c6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef087d96f0fd44ce83ac8c44d11bbe3faa8e1c6a", "html_url": "https://github.com/rust-lang/rust/commit/ef087d96f0fd44ce83ac8c44d11bbe3faa8e1c6a"}], "stats": {"total": 199, "additions": 85, "deletions": 114}, "files": [{"sha": "737af3e1358f4593924610c8f8b7f50b6f64b67e", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 80, "deletions": 102, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/1c1bec2f6dbed0910b2e0ca19cffb92d95be4ee5/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c1bec2f6dbed0910b2e0ca19cffb92d95be4ee5/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=1c1bec2f6dbed0910b2e0ca19cffb92d95be4ee5", "patch": "@@ -139,39 +139,22 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n             let mut have_errors = false;\n \n-            let inlined_arms: Vec<(Vec<_>, _)> = arms\n+            let inlined_arms: Vec<_> = arms\n                 .iter()\n                 .map(|arm| {\n-                    (\n-                        // HACK(or_patterns; Centril | dlrobertson): Remove this and\n-                        // correctly handle exhaustiveness checking for nested or-patterns.\n-                        match &arm.pat.kind {\n-                            hir::PatKind::Or(pats) => pats,\n-                            _ => std::slice::from_ref(&arm.pat),\n-                        }\n-                        .iter()\n-                        .map(|pat| {\n-                            let mut patcx = PatCtxt::new(\n-                                self.tcx,\n-                                self.param_env.and(self.identity_substs),\n-                                self.tables,\n-                            );\n-                            patcx.include_lint_checks();\n-                            let pattern = cx\n-                                .pattern_arena\n-                                .alloc(expand_pattern(cx, patcx.lower_pattern(&pat)))\n-                                as &_;\n-                            if !patcx.errors.is_empty() {\n-                                patcx.report_inlining_errors(pat.span);\n-                                have_errors = true;\n-                            }\n-                            (pattern, &**pat)\n-                        })\n-                        .collect(),\n-                        arm.guard.as_ref().map(|g| match g {\n-                            hir::Guard::If(ref e) => &**e,\n-                        }),\n-                    )\n+                    let mut patcx = PatCtxt::new(\n+                        self.tcx,\n+                        self.param_env.and(self.identity_substs),\n+                        self.tables,\n+                    );\n+                    patcx.include_lint_checks();\n+                    let pattern: &_ =\n+                        cx.pattern_arena.alloc(expand_pattern(cx, patcx.lower_pattern(&arm.pat)));\n+                    if !patcx.errors.is_empty() {\n+                        patcx.report_inlining_errors(arm.pat.span);\n+                        have_errors = true;\n+                    }\n+                    (pattern, &*arm.pat, arm.guard.is_some())\n                 })\n                 .collect();\n \n@@ -399,95 +382,90 @@ fn pat_is_catchall(pat: &Pat) -> bool {\n // Check for unreachable patterns\n fn check_arms<'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'p, 'tcx>,\n-    arms: &[(Vec<(&'p super::Pat<'tcx>, &hir::Pat)>, Option<&hir::Expr>)],\n+    arms: &[(&'p super::Pat<'tcx>, &hir::Pat, bool)],\n     source: hir::MatchSource,\n ) -> Matrix<'p, 'tcx> {\n     let mut seen = Matrix::empty();\n     let mut catchall = None;\n-    for (arm_index, &(ref pats, guard)) in arms.iter().enumerate() {\n-        for &(pat, hir_pat) in pats {\n-            let v = PatStack::from_pattern(pat);\n-\n-            match is_useful(cx, &seen, &v, LeaveOutWitness, hir_pat.hir_id) {\n-                NotUseful => {\n-                    match source {\n-                        hir::MatchSource::IfDesugar { .. } | hir::MatchSource::WhileDesugar => {\n-                            bug!()\n-                        }\n-\n-                        hir::MatchSource::IfLetDesugar { .. }\n-                        | hir::MatchSource::WhileLetDesugar => {\n-                            // check which arm we're on.\n-                            match arm_index {\n-                                // The arm with the user-specified pattern.\n-                                0 => {\n-                                    cx.tcx.lint_hir(\n-                                        lint::builtin::UNREACHABLE_PATTERNS,\n-                                        hir_pat.hir_id,\n-                                        pat.span,\n-                                        \"unreachable pattern\",\n-                                    );\n-                                }\n-                                // The arm with the wildcard pattern.\n-                                1 => {\n-                                    let msg = match source {\n-                                        hir::MatchSource::IfLetDesugar { .. } => {\n-                                            \"irrefutable if-let pattern\"\n-                                        }\n-                                        hir::MatchSource::WhileLetDesugar => {\n-                                            \"irrefutable while-let pattern\"\n-                                        }\n-                                        _ => bug!(),\n-                                    };\n-                                    cx.tcx.lint_hir(\n-                                        lint::builtin::IRREFUTABLE_LET_PATTERNS,\n-                                        hir_pat.hir_id,\n-                                        pat.span,\n-                                        msg,\n-                                    );\n-                                }\n-                                _ => bug!(),\n+    for (arm_index, (pat, hir_pat, has_guard)) in arms.iter().enumerate() {\n+        let v = PatStack::from_pattern(pat);\n+\n+        match is_useful(cx, &seen, &v, LeaveOutWitness, hir_pat.hir_id) {\n+            NotUseful => {\n+                match source {\n+                    hir::MatchSource::IfDesugar { .. } | hir::MatchSource::WhileDesugar => bug!(),\n+\n+                    hir::MatchSource::IfLetDesugar { .. } | hir::MatchSource::WhileLetDesugar => {\n+                        // check which arm we're on.\n+                        match arm_index {\n+                            // The arm with the user-specified pattern.\n+                            0 => {\n+                                cx.tcx.lint_hir(\n+                                    lint::builtin::UNREACHABLE_PATTERNS,\n+                                    hir_pat.hir_id,\n+                                    pat.span,\n+                                    \"unreachable pattern\",\n+                                );\n                             }\n-                        }\n-\n-                        hir::MatchSource::ForLoopDesugar | hir::MatchSource::Normal => {\n-                            let mut err = cx.tcx.struct_span_lint_hir(\n-                                lint::builtin::UNREACHABLE_PATTERNS,\n-                                hir_pat.hir_id,\n-                                pat.span,\n-                                \"unreachable pattern\",\n-                            );\n-                            // if we had a catchall pattern, hint at that\n-                            if let Some(catchall) = catchall {\n-                                err.span_label(pat.span, \"unreachable pattern\");\n-                                err.span_label(catchall, \"matches any value\");\n+                            // The arm with the wildcard pattern.\n+                            1 => {\n+                                let msg = match source {\n+                                    hir::MatchSource::IfLetDesugar { .. } => {\n+                                        \"irrefutable if-let pattern\"\n+                                    }\n+                                    hir::MatchSource::WhileLetDesugar => {\n+                                        \"irrefutable while-let pattern\"\n+                                    }\n+                                    _ => bug!(),\n+                                };\n+                                cx.tcx.lint_hir(\n+                                    lint::builtin::IRREFUTABLE_LET_PATTERNS,\n+                                    hir_pat.hir_id,\n+                                    pat.span,\n+                                    msg,\n+                                );\n                             }\n-                            err.emit();\n+                            _ => bug!(),\n                         }\n-\n-                        // Unreachable patterns in try and await expressions occur when one of\n-                        // the arms are an uninhabited type. Which is OK.\n-                        hir::MatchSource::AwaitDesugar | hir::MatchSource::TryDesugar => {}\n                     }\n-                }\n-                Useful(unreachable_subpatterns) => {\n-                    for pat in unreachable_subpatterns {\n-                        cx.tcx.lint_hir(\n+\n+                    hir::MatchSource::ForLoopDesugar | hir::MatchSource::Normal => {\n+                        let mut err = cx.tcx.struct_span_lint_hir(\n                             lint::builtin::UNREACHABLE_PATTERNS,\n                             hir_pat.hir_id,\n                             pat.span,\n                             \"unreachable pattern\",\n                         );\n+                        // if we had a catchall pattern, hint at that\n+                        if let Some(catchall) = catchall {\n+                            err.span_label(pat.span, \"unreachable pattern\");\n+                            err.span_label(catchall, \"matches any value\");\n+                        }\n+                        err.emit();\n                     }\n+\n+                    // Unreachable patterns in try and await expressions occur when one of\n+                    // the arms are an uninhabited type. Which is OK.\n+                    hir::MatchSource::AwaitDesugar | hir::MatchSource::TryDesugar => {}\n                 }\n-                UsefulWithWitness(_) => bug!(),\n             }\n-            if guard.is_none() {\n-                seen.push(v);\n-                if catchall.is_none() && pat_is_catchall(hir_pat) {\n-                    catchall = Some(pat.span);\n+            Useful(unreachable_subpatterns) => {\n+                for pat in unreachable_subpatterns {\n+                    cx.tcx.lint_hir(\n+                        lint::builtin::UNREACHABLE_PATTERNS,\n+                        hir_pat.hir_id,\n+                        pat.span,\n+                        \"unreachable pattern\",\n+                    );\n                 }\n             }\n+            UsefulWithWitness(_) => bug!(),\n+        }\n+        if !has_guard {\n+            seen.push(v);\n+            if catchall.is_none() && pat_is_catchall(hir_pat) {\n+                catchall = Some(pat.span);\n+            }\n         }\n     }\n     seen"}, {"sha": "4b47b978930f30c6e6c21d2f734ccf35296fb912", "filename": "src/test/ui/pattern/usefulness/top-level-alternation.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1c1bec2f6dbed0910b2e0ca19cffb92d95be4ee5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftop-level-alternation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c1bec2f6dbed0910b2e0ca19cffb92d95be4ee5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftop-level-alternation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftop-level-alternation.rs?ref=1c1bec2f6dbed0910b2e0ca19cffb92d95be4ee5", "patch": "@@ -46,8 +46,7 @@ fn main() {\n     match Some(0u8) {\n         Some(_) => {}\n         None => {}\n-        None //~ ERROR unreachable pattern\n-            | Some(_) => {} //~ ERROR unreachable pattern\n+        None | Some(_) => {} //~ ERROR unreachable pattern\n     }\n     match 0u8 {\n         1 | 2 => {},"}, {"sha": "7c7c4fc4eba28ae65112190ace97a72bfa523515", "filename": "src/test/ui/pattern/usefulness/top-level-alternation.stderr", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1c1bec2f6dbed0910b2e0ca19cffb92d95be4ee5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftop-level-alternation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1c1bec2f6dbed0910b2e0ca19cffb92d95be4ee5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftop-level-alternation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftop-level-alternation.stderr?ref=1c1bec2f6dbed0910b2e0ca19cffb92d95be4ee5", "patch": "@@ -55,20 +55,14 @@ LL |         None => {}\n error: unreachable pattern\n   --> $DIR/top-level-alternation.rs:49:9\n    |\n-LL |         None\n-   |         ^^^^\n-\n-error: unreachable pattern\n-  --> $DIR/top-level-alternation.rs:50:15\n-   |\n-LL |             | Some(_) => {}\n-   |               ^^^^^^^\n+LL |         None | Some(_) => {}\n+   |         ^^^^^^^^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/top-level-alternation.rs:54:9\n+  --> $DIR/top-level-alternation.rs:53:9\n    |\n LL |         1..=2 => {},\n    |         ^^^^^\n \n-error: aborting due to 11 previous errors\n+error: aborting due to 10 previous errors\n "}]}