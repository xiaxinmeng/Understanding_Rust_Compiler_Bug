{"sha": "3e613c1648141ac757d1f0608ad845686ebbe97e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlNjEzYzE2NDgxNDFhYzc1N2QxZjA2MDhhZDg0NTY4NmViYmU5N2U=", "commit": {"author": {"name": "Rafael Avila de Espindola", "email": "espindola@dream.(none)", "date": "2011-02-07T20:07:27Z"}, "committer": {"name": "Rafael Avila de Espindola", "email": "espindola@dream.(none)", "date": "2011-02-07T20:07:27Z"}, "message": "Add native modules to resolve. With this hello world gets to typecheck.", "tree": {"sha": "01bdf6fcfdd25e0148bda8cb2647cf8e59497844", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01bdf6fcfdd25e0148bda8cb2647cf8e59497844"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e613c1648141ac757d1f0608ad845686ebbe97e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e613c1648141ac757d1f0608ad845686ebbe97e", "html_url": "https://github.com/rust-lang/rust/commit/3e613c1648141ac757d1f0608ad845686ebbe97e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e613c1648141ac757d1f0608ad845686ebbe97e/comments", "author": null, "committer": null, "parents": [{"sha": "ff6864aa5ca14795ae0e23e97e0e67b1122a6b68", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff6864aa5ca14795ae0e23e97e0e67b1122a6b68", "html_url": "https://github.com/rust-lang/rust/commit/ff6864aa5ca14795ae0e23e97e0e67b1122a6b68"}], "stats": {"total": 79, "additions": 60, "deletions": 19}, "files": [{"sha": "5f315e58262510495e7b9d81863bb3cb078bcace", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e613c1648141ac757d1f0608ad845686ebbe97e/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e613c1648141ac757d1f0608ad845686ebbe97e/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=3e613c1648141ac757d1f0608ad845686ebbe97e", "patch": "@@ -36,6 +36,8 @@ tag def {\n     def_ty_arg(def_id);\n     def_binding(def_id);\n     def_use(def_id);\n+    def_native_ty(def_id);\n+    def_native_fn(def_id);\n }\n \n type crate = spanned[crate_];"}, {"sha": "0a8f238d4890eb34a65d50c0411de10b1076391a", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 58, "deletions": 19, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/3e613c1648141ac757d1f0608ad845686ebbe97e/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e613c1648141ac757d1f0608ad845686ebbe97e/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=3e613c1648141ac757d1f0608ad845686ebbe97e", "patch": "@@ -34,6 +34,7 @@ tag def_wrap {\n     def_wrap_use(@ast.view_item);\n     def_wrap_import(@ast.view_item);\n     def_wrap_mod(@ast.item);\n+    def_wrap_native_mod(@ast.item);\n     def_wrap_other(def);\n     def_wrap_expr_field(uint, def);\n     def_wrap_resolving;\n@@ -103,6 +104,29 @@ fn find_final_def(&env e, import_map index,\n     // should return what a.b.c.d points to in the end.\n     fn found_something(&env e, import_map index,\n                        &span sp, vec[ident] idents, def_wrap d) -> def_wrap {\n+\n+        fn found_mod(&env e, &import_map index, &span sp,\n+                     vec[ident] idents, @ast.item i) -> def_wrap {\n+            auto len = _vec.len[ident](idents);\n+            auto rest_idents = _vec.slice[ident](idents, 1u, len);\n+            auto empty_e = rec(scopes = nil[scope],\n+                               sess = e.sess);\n+            auto tmp_e = update_env_for_item(empty_e, i);\n+            auto next_i = rest_idents.(0);\n+            auto next_ = lookup_name_wrapped(tmp_e, next_i);\n+            alt (next_) {\n+                case (none[tup(@env, def_wrap)]) {\n+                    e.sess.span_err(sp, \"unresolved name: \" + next_i);\n+                    fail;\n+                }\n+                case (some[tup(@env, def_wrap)](?next)) {\n+                    auto combined_e = update_env_for_item(e, i);\n+                    ret found_something(combined_e, index, sp,\n+                                        rest_idents, next._1);\n+                }\n+            }\n+        }\n+\n         alt (d) {\n             case (def_wrap_import(?imp)) {\n                 alt (imp.node) {\n@@ -122,23 +146,10 @@ fn find_final_def(&env e, import_map index,\n         }\n         alt (d) {\n             case (def_wrap_mod(?i)) {\n-                auto rest_idents = _vec.slice[ident](idents, 1u, len);\n-                auto empty_e = rec(scopes = nil[scope],\n-                                   sess = e.sess);\n-                auto tmp_e = update_env_for_item(empty_e, i);\n-                auto next_i = rest_idents.(0);\n-                auto next_ = lookup_name_wrapped(tmp_e, next_i);\n-                alt (next_) {\n-                    case (none[tup(@env, def_wrap)]) {\n-                        e.sess.span_err(sp, \"unresolved name: \" + next_i);\n-                        fail;\n-                    }\n-                    case (some[tup(@env, def_wrap)](?next)) {\n-                        auto combined_e = update_env_for_item(e, i);\n-                        ret found_something(combined_e, index, sp,\n-                                            rest_idents, next._1);\n-                    }\n-                }\n+                ret found_mod(e, index, sp, idents, i);\n+            }\n+            case (def_wrap_native_mod(?i)) {\n+                ret found_mod(e, index, sp, idents, i);\n             }\n             case (def_wrap_use(?c)) {\n                 e.sess.span_err(sp, \"Crate access is not implemented\");\n@@ -201,6 +212,9 @@ fn lookup_name_wrapped(&env e, ast.ident i) -> option.t[tup(@env, def_wrap)] {\n             case (ast.item_mod(_, _, ?id)) {\n                 ret def_wrap_mod(i);\n             }\n+            case (ast.item_native_mod(_, _, ?id)) {\n+                ret def_wrap_native_mod(i);\n+            }\n             case (ast.item_ty(_, _, _, ?id, _)) {\n                 ret def_wrap_other(ast.def_ty(id));\n             }\n@@ -213,6 +227,17 @@ fn lookup_name_wrapped(&env e, ast.ident i) -> option.t[tup(@env, def_wrap)] {\n         }\n     }\n \n+    fn found_def_native_item(@ast.native_item i) -> def_wrap {\n+        alt (i.node) {\n+            case (ast.native_item_ty(_, ?id)) {\n+                ret def_wrap_other(ast.def_native_ty(id));\n+            }\n+            case (ast.native_item_fn(_, _, _, ?id)) {\n+                ret def_wrap_other(ast.def_native_fn(id));\n+            }\n+        }\n+    }\n+\n     fn found_decl_stmt(@ast.stmt s) -> def_wrap {\n         alt (s.node) {\n             case (ast.stmt_decl(?d)) {\n@@ -267,11 +292,22 @@ fn lookup_name_wrapped(&env e, ast.ident i) -> option.t[tup(@env, def_wrap)] {\n                     }\n                 }\n             }\n-            case (none[ast.mod_index_entry]) { /* fall through */ }\n+            case (none[ast.mod_index_entry]) {\n+                ret none[def_wrap];\n+            }\n         }\n-        ret none[def_wrap];\n     }\n \n+    fn check_native_mod(ast.ident i, ast.native_mod m) -> option.t[def_wrap] {\n+        alt (m.index.find(i)) {\n+            case (some[@ast.native_item](?item)) {\n+                ret some(found_def_native_item(item));\n+            }\n+            case (_) {\n+                ret none[def_wrap];\n+            }\n+        }\n+    }\n \n     fn in_scope(ast.ident i, &scope s) -> option.t[def_wrap] {\n         alt (s) {\n@@ -313,6 +349,9 @@ fn lookup_name_wrapped(&env e, ast.ident i) -> option.t[tup(@env, def_wrap)] {\n                     case (ast.item_mod(_, ?m, _)) {\n                         ret check_mod(i, m);\n                     }\n+                    case (ast.item_native_mod(_, ?m, _)) {\n+                        ret check_native_mod(i, m);\n+                    }\n                     case (ast.item_ty(_, _, ?ty_params, _, _)) {\n                         for (ast.ty_param tp in ty_params) {\n                             if (_str.eq(tp.ident, i)) {"}]}