{"sha": "357f4ce4318088b541b98148cfcdff18552bb2cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1N2Y0Y2U0MzE4MDg4YjU0MWI5ODE0OGNmY2RmZjE4NTUyYmIyY2Y=", "commit": {"author": {"name": "Alex Aktsipetrov", "email": "alex.akts@gmail.com", "date": "2020-03-31T16:49:05Z"}, "committer": {"name": "Alex Aktsipetrov", "email": "alex.akts@gmail.com", "date": "2020-04-25T16:19:27Z"}, "message": "Replace thread_local with generator resume arguments in box_region.", "tree": {"sha": "678177f92ff775cf41709445f454fb1da318573d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/678177f92ff775cf41709445f454fb1da318573d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/357f4ce4318088b541b98148cfcdff18552bb2cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/357f4ce4318088b541b98148cfcdff18552bb2cf", "html_url": "https://github.com/rust-lang/rust/commit/357f4ce4318088b541b98148cfcdff18552bb2cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/357f4ce4318088b541b98148cfcdff18552bb2cf/comments", "author": {"login": "gizmondo", "id": 3333919, "node_id": "MDQ6VXNlcjMzMzM5MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3333919?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gizmondo", "html_url": "https://github.com/gizmondo", "followers_url": "https://api.github.com/users/gizmondo/followers", "following_url": "https://api.github.com/users/gizmondo/following{/other_user}", "gists_url": "https://api.github.com/users/gizmondo/gists{/gist_id}", "starred_url": "https://api.github.com/users/gizmondo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gizmondo/subscriptions", "organizations_url": "https://api.github.com/users/gizmondo/orgs", "repos_url": "https://api.github.com/users/gizmondo/repos", "events_url": "https://api.github.com/users/gizmondo/events{/privacy}", "received_events_url": "https://api.github.com/users/gizmondo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gizmondo", "id": 3333919, "node_id": "MDQ6VXNlcjMzMzM5MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3333919?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gizmondo", "html_url": "https://github.com/gizmondo", "followers_url": "https://api.github.com/users/gizmondo/followers", "following_url": "https://api.github.com/users/gizmondo/following{/other_user}", "gists_url": "https://api.github.com/users/gizmondo/gists{/gist_id}", "starred_url": "https://api.github.com/users/gizmondo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gizmondo/subscriptions", "organizations_url": "https://api.github.com/users/gizmondo/orgs", "repos_url": "https://api.github.com/users/gizmondo/repos", "events_url": "https://api.github.com/users/gizmondo/events{/privacy}", "received_events_url": "https://api.github.com/users/gizmondo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a58b1ed44f5e06976de2bdc4d7dc81c36a96934f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a58b1ed44f5e06976de2bdc4d7dc81c36a96934f", "html_url": "https://github.com/rust-lang/rust/commit/a58b1ed44f5e06976de2bdc4d7dc81c36a96934f"}], "stats": {"total": 54, "additions": 31, "deletions": 23}, "files": [{"sha": "eb6f4e8213ec711dac0b945cc5c2f751c9511451", "filename": "src/librustc_data_structures/box_region.rs", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/357f4ce4318088b541b98148cfcdff18552bb2cf/src%2Flibrustc_data_structures%2Fbox_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357f4ce4318088b541b98148cfcdff18552bb2cf/src%2Flibrustc_data_structures%2Fbox_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbox_region.rs?ref=357f4ce4318088b541b98148cfcdff18552bb2cf", "patch": "@@ -1,4 +1,15 @@\n-use std::cell::Cell;\n+//! This module provides a way to deal with self-referential data.\n+//!\n+//! The main idea is to allocate such data in a generator frame and then\n+//! give access to it by executing user-provided closures inside that generator.\n+//! The module provides a safe abstraction for the latter task.\n+//!\n+//! The interface consists of two exported macros meant to be used together:\n+//! * `declare_box_region_type` wraps a generator inside a struct with `access`\n+//!   method which accepts closures.\n+//! * `box_region_allow_access` is a helper which should be called inside\n+//!   a generator to actually execute those closures.\n+\n use std::marker::PhantomData;\n use std::ops::{Generator, GeneratorState};\n use std::pin::Pin;\n@@ -14,24 +25,23 @@ impl AccessAction {\n \n #[derive(Copy, Clone)]\n pub enum Action {\n+    Initial,\n     Access(AccessAction),\n     Complete,\n }\n \n-thread_local!(pub static BOX_REGION_ARG: Cell<Action> = Cell::new(Action::Complete));\n-\n pub struct PinnedGenerator<I, A, R> {\n-    generator: Pin<Box<dyn Generator<Yield = YieldType<I, A>, Return = R>>>,\n+    generator: Pin<Box<dyn Generator<Action, Yield = YieldType<I, A>, Return = R>>>,\n }\n \n impl<I, A, R> PinnedGenerator<I, A, R> {\n-    pub fn new<T: Generator<Yield = YieldType<I, A>, Return = R> + 'static>(\n+    pub fn new<T: Generator<Action, Yield = YieldType<I, A>, Return = R> + 'static>(\n         generator: T,\n     ) -> (I, Self) {\n         let mut result = PinnedGenerator { generator: Box::pin(generator) };\n \n         // Run it to the first yield to set it up\n-        let init = match Pin::new(&mut result.generator).resume(()) {\n+        let init = match Pin::new(&mut result.generator).resume(Action::Initial) {\n             GeneratorState::Yielded(YieldType::Initial(y)) => y,\n             _ => panic!(),\n         };\n@@ -40,21 +50,17 @@ impl<I, A, R> PinnedGenerator<I, A, R> {\n     }\n \n     pub unsafe fn access(&mut self, closure: *mut dyn FnMut()) {\n-        BOX_REGION_ARG.with(|i| {\n-            i.set(Action::Access(AccessAction(closure)));\n-        });\n-\n-        // Call the generator, which in turn will call the closure in BOX_REGION_ARG\n-        if let GeneratorState::Complete(_) = Pin::new(&mut self.generator).resume(()) {\n+        // Call the generator, which in turn will call the closure\n+        if let GeneratorState::Complete(_) =\n+            Pin::new(&mut self.generator).resume(Action::Access(AccessAction(closure)))\n+        {\n             panic!()\n         }\n     }\n \n     pub fn complete(&mut self) -> R {\n         // Tell the generator we want it to complete, consuming it and yielding a result\n-        BOX_REGION_ARG.with(|i| i.set(Action::Complete));\n-\n-        let result = Pin::new(&mut self.generator).resume(());\n+        let result = Pin::new(&mut self.generator).resume(Action::Complete);\n         if let GeneratorState::Complete(r) = result { r } else { panic!() }\n     }\n }\n@@ -89,7 +95,7 @@ macro_rules! declare_box_region_type {\n         >);\n \n         impl $name {\n-            fn new<T: ::std::ops::Generator<Yield = $yield_type, Return = $retc> + 'static>(\n+            fn new<T: ::std::ops::Generator<$crate::box_region::Action, Yield = $yield_type, Return = $retc> + 'static>(\n                 generator: T\n             ) -> ($reti, Self) {\n                 let (initial, pinned) = $crate::box_region::PinnedGenerator::new(generator);\n@@ -98,7 +104,7 @@ macro_rules! declare_box_region_type {\n \n             $v fn access<F: for<$($lifetimes)*> FnOnce($($args,)*) -> R, R>(&mut self, f: F) -> R {\n                 // Turn the FnOnce closure into *mut dyn FnMut()\n-                // so we can pass it in to the generator using the BOX_REGION_ARG thread local\n+                // so we can pass it in to the generator\n                 let mut r = None;\n                 let mut f = Some(f);\n                 let mut_f: &mut dyn for<$($lifetimes)*> FnMut(($($args,)*)) =\n@@ -140,9 +146,9 @@ macro_rules! declare_box_region_type {\n #[macro_export]\n #[allow_internal_unstable(fn_traits)]\n macro_rules! box_region_allow_access {\n-    (for($($lifetimes:tt)*), ($($args:ty),*), ($($exprs:expr),*) ) => {\n+    (for($($lifetimes:tt)*), ($($args:ty),*), ($($exprs:expr),*), $action:ident) => {\n         loop {\n-            match $crate::box_region::BOX_REGION_ARG.with(|i| i.get()) {\n+            match $action {\n                 $crate::box_region::Action::Access(accessor) => {\n                     let accessor: &mut dyn for<$($lifetimes)*> FnMut($($args),*) = unsafe {\n                         ::std::mem::transmute(accessor.get())\n@@ -152,10 +158,11 @@ macro_rules! box_region_allow_access {\n                         let marker = $crate::box_region::Marker::<\n                             for<$($lifetimes)*> fn(($($args,)*))\n                         >::new();\n-                        yield $crate::box_region::YieldType::Accessor(marker)\n+                        $action = yield $crate::box_region::YieldType::Accessor(marker);\n                     };\n                 }\n                 $crate::box_region::Action::Complete => break,\n+                $crate::box_region::Action::Initial => panic!(\"unexpected box_region action: Initial\"),\n             }\n         }\n     }"}, {"sha": "4b09148eab61f8269c1c5a95e91650906fd8d969", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/357f4ce4318088b541b98148cfcdff18552bb2cf/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357f4ce4318088b541b98148cfcdff18552bb2cf/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=357f4ce4318088b541b98148cfcdff18552bb2cf", "patch": "@@ -109,7 +109,8 @@ pub fn configure_and_expand(\n     // its contents but the results of name resolution on those contents. Hopefully we'll push\n     // this back at some point.\n     let crate_name = crate_name.to_string();\n-    let (result, resolver) = BoxedResolver::new(static move || {\n+    let (result, resolver) = BoxedResolver::new(static move |mut action| {\n+        let _ = action;\n         let sess = &*sess;\n         let resolver_arenas = Resolver::arenas();\n         let res = configure_and_expand_inner(\n@@ -126,11 +127,11 @@ pub fn configure_and_expand(\n                 panic!()\n             }\n             Ok((krate, resolver)) => {\n-                yield BoxedResolver::initial_yield(Ok(krate));\n+                action = yield BoxedResolver::initial_yield(Ok(krate));\n                 resolver\n             }\n         };\n-        box_region_allow_access!(for(), (&mut Resolver<'_>), (&mut resolver));\n+        box_region_allow_access!(for(), (&mut Resolver<'_>), (&mut resolver), action);\n         resolver.into_outputs()\n     });\n     result.map(|k| (k, resolver))"}]}