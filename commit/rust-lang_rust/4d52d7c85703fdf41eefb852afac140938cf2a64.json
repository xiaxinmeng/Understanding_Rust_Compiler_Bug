{"sha": "4d52d7c85703fdf41eefb852afac140938cf2a64", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkNTJkN2M4NTcwM2ZkZjQxZWVmYjg1MmFmYWMxNDA5MzhjZjJhNjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-30T00:56:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-30T00:56:01Z"}, "message": "Auto merge of #27032 - Gankro:tarpl, r=aturon,acrichto,arielb,pnkfelix,nrc,nmatsakis,huonw\n\nI've been baking this out of tree for long enough. This is currently about ~2/5ths the size of TRPL. Time to get it in tree so it can be more widely maintained and scrutinized. I've preserved the whole gruesome history including various rewrites. I can definitely squash these a fair amount if desired. Some random people submitted minor fixes though, so they're mixed in.\r\n\r\nEdit: forgot to link to rendered http://cglab.ca/~abeinges/blah/turpl/_book/\r\n\r\nEdit2:\r\n\r\nTo streamline the review process, I'm going to break this into sections that need official \"domain expert\" approval:\r\n\r\n# Summary\r\n\r\n* [ ] references.md -- very important, needs work\r\n\r\n* [x] Meet Safe and Unsafe: reviewed by @aturon\r\n* [x] Data Layout: reviewed by @arielb1 \r\n* [x] Ownership: reviewed by @aturon ( and sorta @nikomatsakis ) -- significantly updated, may need re-r\r\n* [x] Coversions:  reviewed by @nrc \r\n* [x] Uninitialized Memory: reviewed by @pnkfelix \r\n* [x] Ownership-Oriented Resource Management: reviewed by @aturon\r\n* [x] Unwinding: reviewed by @alexcrichton \r\n* [x] Concurrency: reviewed by @aturon\r\n* [x] Implementing Vec:  r? @huonw", "tree": {"sha": "e5369239d83181178dfc37950be679a78e83498b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5369239d83181178dfc37950be679a78e83498b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d52d7c85703fdf41eefb852afac140938cf2a64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d52d7c85703fdf41eefb852afac140938cf2a64", "html_url": "https://github.com/rust-lang/rust/commit/4d52d7c85703fdf41eefb852afac140938cf2a64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d52d7c85703fdf41eefb852afac140938cf2a64/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "186707893bdb50a0954b04b7451a334620137784", "url": "https://api.github.com/repos/rust-lang/rust/commits/186707893bdb50a0954b04b7451a334620137784", "html_url": "https://github.com/rust-lang/rust/commit/186707893bdb50a0954b04b7451a334620137784"}, {"sha": "ddb029034b734ec078589724c45e6eb8bf2e6645", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddb029034b734ec078589724c45e6eb8bf2e6645", "html_url": "https://github.com/rust-lang/rust/commit/ddb029034b734ec078589724c45e6eb8bf2e6645"}], "stats": {"total": 5444, "additions": 5442, "deletions": 2}, "files": [{"sha": "3acc3c68b8fd11faa35f4844a462fd985fa1dc72", "filename": "mk/docs.mk", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -77,7 +77,7 @@ ERR_IDX_GEN = $(RPATH_VAR2_T_$(CFG_BUILD)_H_$(CFG_BUILD)) $(ERR_IDX_GEN_EXE)\n \n D := $(S)src/doc\n \n-DOC_TARGETS := trpl style error-index\n+DOC_TARGETS := trpl tarpl style error-index\n COMPILER_DOC_TARGETS :=\n DOC_L10N_TARGETS :=\n \n@@ -287,6 +287,13 @@ doc/book/index.html: $(RUSTBOOK_EXE) $(wildcard $(S)/src/doc/trpl/*.md) | doc/\n \t$(Q)rm -rf doc/book\n \t$(Q)$(RUSTBOOK) build $(S)src/doc/trpl doc/book\n \n+tarpl: doc/adv-book/index.html\n+\n+doc/adv-book/index.html: $(RUSTBOOK_EXE) $(wildcard $(S)/src/doc/tarpl/*.md) | doc/\n+\t@$(call E, rustbook: $@)\n+\t$(Q)rm -rf doc/adv-book\n+\t$(Q)$(RUSTBOOK) build $(S)src/doc/tarpl doc/adv-book\n+\n style: doc/style/index.html\n \n doc/style/index.html: $(RUSTBOOK_EXE) $(wildcard $(S)/src/doc/style/*.md) | doc/"}, {"sha": "c0962a1b0e78b5101439dd3e9041cd4eab32d9d5", "filename": "mk/tests.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -162,7 +162,8 @@ $(foreach doc,$(DOCS), \\\n   $(eval $(call DOCTEST,md-$(doc),$(S)src/doc/$(doc).md)))\n $(foreach file,$(wildcard $(S)src/doc/trpl/*.md), \\\n   $(eval $(call DOCTEST,$(file:$(S)src/doc/trpl/%.md=trpl-%),$(file))))\n-\n+$(foreach file,$(wildcard $(S)src/doc/tarpl/*.md), \\\n+  $(eval $(call DOCTEST,$(file:$(S)src/doc/tarpl/%.md=tarpl-%),$(file))))\n ######################################################################\n # Main test targets\n ######################################################################"}, {"sha": "0b627737138adc724d90602b3f3f9615bf797f45", "filename": "src/doc/tarpl/README.md", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2FREADME.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,39 @@\n+% The Advanced Rust Programming Language\n+\n+# NOTE: This is a draft document, and may contain serious errors\n+\n+So you've played around with Rust a bit. You've written a few simple programs and\n+you think you grok the basics. Maybe you've even read through\n+*[The Rust Programming Language][trpl]*. Now you want to get neck-deep in all the\n+nitty-gritty details of the language. You want to know those weird corner-cases.\n+You want to know what the heck `unsafe` really means, and how to properly use it.\n+This is the book for you.\n+\n+To be clear, this book goes into *serious* detail. We're going to dig into\n+exception-safety and pointer aliasing. We're going to talk about memory\n+models. We're even going to do some type-theory. This is stuff that you\n+absolutely *don't* need to know to write fast and safe Rust programs.\n+You could probably close this book *right now* and still have a productive\n+and happy career in Rust.\n+\n+However if you intend to write unsafe code -- or just *really* want to dig into\n+the guts of the language -- this book contains *invaluable* information.\n+\n+Unlike *The Rust Programming Language* we *will* be assuming considerable prior\n+knowledge. In particular, you should be comfortable with:\n+\n+* Basic Systems Programming:\n+    * Pointers\n+    * [The stack and heap][]\n+    * The memory hierarchy (caches)\n+    * Threads\n+\n+* [Basic Rust][]\n+\n+Due to the nature of advanced Rust programming, we will be spending a lot of time\n+talking about *safety* and *guarantees*. In particular, a significant portion of\n+the book will be dedicated to correctly writing and understanding Unsafe Rust.\n+\n+[trpl]: ../book/\n+[The stack and heap]: ../book/the-stack-and-the-heap.html\n+[Basic Rust]: ../book/syntax-and-semantics.html"}, {"sha": "aeab8fc727693a5883f1c2f1b47f52de2550ebf6", "filename": "src/doc/tarpl/SUMMARY.md", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2FSUMMARY.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,53 @@\n+# Summary\n+\n+* [Meet Safe and Unsafe](meet-safe-and-unsafe.md)\n+\t* [How Safe and Unsafe Interact](safe-unsafe-meaning.md)\n+\t* [Working with Unsafe](working-with-unsafe.md)\n+* [Data Layout](data.md)\n+\t* [repr(Rust)](repr-rust.md)\n+\t* [Exotically Sized Types](exotic-sizes.md)\n+\t* [Other reprs](other-reprs.md)\n+* [Ownership](ownership.md)\n+\t* [References](references.md)\n+\t* [Lifetimes](lifetimes.md)\n+\t* [Limits of lifetimes](lifetime-mismatch.md)\n+\t* [Lifetime Elision](lifetime-elision.md)\n+\t* [Unbounded Lifetimes](unbounded-lifetimes.md)\n+\t* [Higher-Rank Trait Bounds](hrtb.md)\n+\t* [Subtyping and Variance](subtyping.md)\n+\t* [Drop Check](dropck.md)\n+\t* [PhantomData](phantom-data.md)\n+\t* [Splitting Borrows](borrow-splitting.md)\n+* [Type Conversions](conversions.md)\n+\t* [Coercions](coercions.md)\n+\t* [The Dot Operator](dot-operator.md)\n+\t* [Casts](casts.md)\n+\t* [Transmutes](transmutes.md)\n+* [Uninitialized Memory](uninitialized.md)\n+\t* [Checked](checked-uninit.md)\n+\t* [Drop Flags](drop-flags.md)\n+\t* [Unchecked](unchecked-uninit.md)\n+* [Ownership Based Resource Management](obrm.md)\n+\t* [Constructors](constructors.md)\n+\t* [Destructors](destructors.md)\n+\t* [Leaking](leaking.md)\n+* [Unwinding](unwinding.md)\n+\t* [Exception Safety](exception-safety.md)\n+\t* [Poisoning](poisoning.md)\n+* [Concurrency](concurrency.md)\n+\t* [Races](races.md)\n+\t* [Send and Sync](send-and-sync.md)\n+\t* [Atomics](atomics.md)\n+* [Implementing Vec](vec.md)\n+\t* [Layout](vec-layout.md)\n+\t* [Allocating](vec-alloc.md)\n+\t* [Push and Pop](vec-push-pop.md)\n+\t* [Deallocating](vec-dealloc.md)\n+\t* [Deref](vec-deref.md)\n+\t* [Insert and Remove](vec-insert-remove.md)\n+\t* [IntoIter](vec-into-iter.md)\n+\t* [RawVec](vec-raw.md)\n+\t* [Drain](vec-drain.md)\n+\t* [Handling Zero-Sized Types](vec-zsts.md)\n+\t* [Final Code](vec-final.md)\n+* [Implementing Arc and Mutex](arc-and-mutex.md)"}, {"sha": "fcafe55e409b8293827f5e6804c164e023e8de62", "filename": "src/doc/tarpl/arc-and-mutex.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Farc-and-mutex.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Farc-and-mutex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Farc-and-mutex.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,7 @@\n+% Implementing Arc and Mutex\n+\n+Knowing the theory is all fine and good, but the *best* way to understand\n+something is to use it. To better understand atomics and interior mutability,\n+we'll be implementing versions of the standard library's Arc and Mutex types.\n+\n+TODO: ALL OF THIS OMG"}, {"sha": "87378da7c5235871c0a4d42a5c59fb8dafbc6cca", "filename": "src/doc/tarpl/atomics.md", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fatomics.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fatomics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fatomics.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,250 @@\n+% Atomics\n+\n+Rust pretty blatantly just inherits C11's memory model for atomics. This is not\n+due this model being particularly excellent or easy to understand. Indeed, this\n+model is quite complex and known to have [several flaws][C11-busted]. Rather, it\n+is a pragmatic concession to the fact that *everyone* is pretty bad at modeling\n+atomics. At very least, we can benefit from existing tooling and research around\n+C.\n+\n+Trying to fully explain the model in this book is fairly hopeless. It's defined\n+in terms of madness-inducing causality graphs that require a full book to\n+properly understand in a practical way. If you want all the nitty-gritty\n+details, you should check out [C's specification (Section 7.17)][C11-model].\n+Still, we'll try to cover the basics and some of the problems Rust developers\n+face.\n+\n+The C11 memory model is fundamentally about trying to bridge the gap between the\n+semantics we want, the optimizations compilers want, and the inconsistent chaos\n+our hardware wants. *We* would like to just write programs and have them do\n+exactly what we said but, you know, *fast*. Wouldn't that be great?\n+\n+\n+\n+\n+# Compiler Reordering\n+\n+Compilers fundamentally want to be able to do all sorts of crazy transformations\n+to reduce data dependencies and eliminate dead code. In particular, they may\n+radically change the actual order of events, or make events never occur! If we\n+write something like\n+\n+```rust,ignore\n+x = 1;\n+y = 3;\n+x = 2;\n+```\n+\n+The compiler may conclude that it would *really* be best if your program did\n+\n+```rust,ignore\n+x = 2;\n+y = 3;\n+```\n+\n+This has inverted the order of events *and* completely eliminated one event.\n+From a single-threaded perspective this is completely unobservable: after all\n+the statements have executed we are in exactly the same state. But if our\n+program is multi-threaded, we may have been relying on `x` to *actually* be\n+assigned to 1 before `y` was assigned. We would *really* like the compiler to be\n+able to make these kinds of optimizations, because they can seriously improve\n+performance. On the other hand, we'd really like to be able to depend on our\n+program *doing the thing we said*.\n+\n+\n+\n+\n+# Hardware Reordering\n+\n+On the other hand, even if the compiler totally understood what we wanted and\n+respected our wishes, our *hardware* might instead get us in trouble. Trouble\n+comes from CPUs in the form of memory hierarchies. There is indeed a global\n+shared memory space somewhere in your hardware, but from the perspective of each\n+CPU core it is *so very far away* and *so very slow*. Each CPU would rather work\n+with its local cache of the data and only go through all the *anguish* of\n+talking to shared memory *only* when it doesn't actually have that memory in\n+cache.\n+\n+After all, that's the whole *point* of the cache, right? If every read from the\n+cache had to run back to shared memory to double check that it hadn't changed,\n+what would the point be? The end result is that the hardware doesn't guarantee\n+that events that occur in the same order on *one* thread, occur in the same\n+order on *another* thread. To guarantee this, we must issue special instructions\n+to the CPU telling it to be a bit less smart.\n+\n+For instance, say we convince the compiler to emit this logic:\n+\n+```text\n+initial state: x = 0, y = 1\n+\n+THREAD 1        THREAD2\n+y = 3;          if x == 1 {\n+x = 1;              y *= 2;\n+                }\n+```\n+\n+Ideally this program has 2 possible final states:\n+\n+* `y = 3`: (thread 2 did the check before thread 1 completed)\n+* `y = 6`: (thread 2 did the check after thread 1 completed)\n+\n+However there's a third potential state that the hardware enables:\n+\n+* `y = 2`: (thread 2 saw `x = 1`, but not `y = 3`, and then overwrote `y = 3`)\n+\n+It's worth noting that different kinds of CPU provide different guarantees. It\n+is common to separate hardware into two categories: strongly-ordered and weakly-\n+ordered. Most notably x86/64 provides strong ordering guarantees, while ARM\n+provides weak ordering guarantees. This has two consequences for concurrent\n+programming:\n+\n+* Asking for stronger guarantees on strongly-ordered hardware may be cheap or\n+  even *free* because they already provide strong guarantees unconditionally.\n+  Weaker guarantees may only yield performance wins on weakly-ordered hardware.\n+\n+* Asking for guarantees that are *too* weak on strongly-ordered hardware   is\n+  more likely to *happen* to work, even though your program is strictly\n+  incorrect. If possible, concurrent algorithms should be tested on   weakly-\n+  ordered hardware.\n+\n+\n+\n+\n+\n+# Data Accesses\n+\n+The C11 memory model attempts to bridge the gap by allowing us to talk about the\n+*causality* of our program. Generally, this is by establishing a *happens\n+before* relationships between parts of the program and the threads that are\n+running them. This gives the hardware and compiler room to optimize the program\n+more aggressively where a strict happens-before relationship isn't established,\n+but forces them to be more careful where one *is* established. The way we\n+communicate these relationships are through *data accesses* and *atomic\n+accesses*.\n+\n+Data accesses are the bread-and-butter of the programming world. They are\n+fundamentally unsynchronized and compilers are free to aggressively optimize\n+them. In particular, data accesses are free to be reordered by the compiler on\n+the assumption that the program is single-threaded. The hardware is also free to\n+propagate the changes made in data accesses to other threads as lazily and\n+inconsistently as it wants. Mostly critically, data accesses are how data races\n+happen. Data accesses are very friendly to the hardware and compiler, but as\n+we've seen they offer *awful* semantics to try to write synchronized code with.\n+Actually, that's too weak. *It is literally impossible to write correct\n+synchronized code using only data accesses*.\n+\n+Atomic accesses are how we tell the hardware and compiler that our program is\n+multi-threaded. Each atomic access can be marked with an *ordering* that\n+specifies what kind of relationship it establishes with other accesses. In\n+practice, this boils down to telling the compiler and hardware certain things\n+they *can't* do. For the compiler, this largely revolves around re-ordering of\n+instructions. For the hardware, this largely revolves around how writes are\n+propagated to other threads. The set of orderings Rust exposes are:\n+\n+* Sequentially Consistent (SeqCst) Release Acquire Relaxed\n+\n+(Note: We explicitly do not expose the C11 *consume* ordering)\n+\n+TODO: negative reasoning vs positive reasoning? TODO: \"can't forget to\n+synchronize\"\n+\n+\n+\n+# Sequentially Consistent\n+\n+Sequentially Consistent is the most powerful of all, implying the restrictions\n+of all other orderings. Intuitively, a sequentially consistent operation\n+*cannot* be reordered: all accesses on one thread that happen before and after a\n+SeqCst access *stay* before and after it. A data-race-free program that uses\n+only sequentially consistent atomics and data accesses has the very nice\n+property that there is a single global execution of the program's instructions\n+that all threads agree on. This execution is also particularly nice to reason\n+about: it's just an interleaving of each thread's individual executions. This\n+*does not* hold if you start using the weaker atomic orderings.\n+\n+The relative developer-friendliness of sequential consistency doesn't come for\n+free. Even on strongly-ordered platforms sequential consistency involves\n+emitting memory fences.\n+\n+In practice, sequential consistency is rarely necessary for program correctness.\n+However sequential consistency is definitely the right choice if you're not\n+confident about the other memory orders. Having your program run a bit slower\n+than it needs to is certainly better than it running incorrectly! It's also\n+*mechanically* trivial to downgrade atomic operations to have a weaker\n+consistency later on. Just change `SeqCst` to e.g. `Relaxed` and you're done! Of\n+course, proving that this transformation is *correct* is a whole other matter.\n+\n+\n+\n+\n+# Acquire-Release\n+\n+Acquire and Release are largely intended to be paired. Their names hint at their\n+use case: they're perfectly suited for acquiring and releasing locks, and\n+ensuring that critical sections don't overlap.\n+\n+Intuitively, an acquire access ensures that every access after it *stays* after\n+it. However operations that occur before an acquire are free to be reordered to\n+occur after it. Similarly, a release access ensures that every access before it\n+*stays* before it. However operations that occur after a release are free to be\n+reordered to occur before it.\n+\n+When thread A releases a location in memory and then thread B subsequently\n+acquires *the same* location in memory, causality is established. Every write\n+that happened *before* A's release will be observed by B *after* its release.\n+However no causality is established with any other threads. Similarly, no\n+causality is established if A and B access *different* locations in memory.\n+\n+Basic use of release-acquire is therefore simple: you acquire a location of\n+memory to begin the critical section, and then release that location to end it.\n+For instance, a simple spinlock might look like:\n+\n+```rust\n+use std::sync::Arc;\n+use std::sync::atomic::{AtomicBool, Ordering};\n+use std::thread;\n+\n+fn main() {\n+    let lock = Arc::new(AtomicBool::new(true)); // value answers \"am I locked?\"\n+\n+    // ... distribute lock to threads somehow ...\n+\n+    // Try to acquire the lock by setting it to false\n+    while !lock.compare_and_swap(true, false, Ordering::Acquire) { }\n+    // broke out of the loop, so we successfully acquired the lock!\n+\n+    // ... scary data accesses ...\n+\n+    // ok we're done, release the lock\n+    lock.store(true, Ordering::Release);\n+}\n+```\n+\n+On strongly-ordered platforms most accesses have release or acquire semantics,\n+making release and acquire often totally free. This is not the case on\n+weakly-ordered platforms.\n+\n+\n+\n+\n+# Relaxed\n+\n+Relaxed accesses are the absolute weakest. They can be freely re-ordered and\n+provide no happens-before relationship. Still, relaxed operations *are* still\n+atomic. That is, they don't count as data accesses and any read-modify-write\n+operations done to them occur atomically. Relaxed operations are appropriate for\n+things that you definitely want to happen, but don't particularly otherwise care\n+about. For instance, incrementing a counter can be safely done by multiple\n+threads using a relaxed `fetch_add` if you're not using the counter to\n+synchronize any other accesses.\n+\n+There's rarely a benefit in making an operation relaxed on strongly-ordered\n+platforms, since they usually provide release-acquire semantics anyway. However\n+relaxed operations can be cheaper on weakly-ordered platforms.\n+\n+\n+\n+\n+\n+[C11-busted]: http://plv.mpi-sws.org/c11comp/popl15.pdf\n+[C11-model]: http://www.open-std.org/jtc1/sc22/wg14/www/standards.html#9899"}, {"sha": "123e2baf8fafd5ac0f5a2150b9bf3df27eafed0b", "filename": "src/doc/tarpl/borrow-splitting.md", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fborrow-splitting.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fborrow-splitting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fborrow-splitting.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,283 @@\n+% Splitting Borrows\n+\n+The mutual exclusion property of mutable references can be very limiting when\n+working with a composite structure. The borrow checker understands some basic\n+stuff, but will fall over pretty easily. It *does* understand structs\n+sufficiently to know that it's possible to borrow disjoint fields of a struct\n+simultaneously. So this works today:\n+\n+```rust\n+struct Foo {\n+    a: i32,\n+    b: i32,\n+    c: i32,\n+}\n+\n+let mut x = Foo {a: 0, b: 0, c: 0};\n+let a = &mut x.a;\n+let b = &mut x.b;\n+let c = &x.c;\n+*b += 1;\n+let c2 = &x.c;\n+*a += 10;\n+println!(\"{} {} {} {}\", a, b, c, c2);\n+```\n+\n+However borrowck doesn't understand arrays or slices in any way, so this doesn't\n+work:\n+\n+```rust,ignore\n+let x = [1, 2, 3];\n+let a = &mut x[0];\n+let b = &mut x[1];\n+println!(\"{} {}\", a, b);\n+```\n+\n+```text\n+<anon>:3:18: 3:22 error: cannot borrow immutable indexed content `x[..]` as mutable\n+<anon>:3     let a = &mut x[0];\n+                          ^~~~\n+<anon>:4:18: 4:22 error: cannot borrow immutable indexed content `x[..]` as mutable\n+<anon>:4     let b = &mut x[1];\n+                          ^~~~\n+error: aborting due to 2 previous errors\n+```\n+\n+While it was plausible that borrowck could understand this simple case, it's\n+pretty clearly hopeless for borrowck to understand disjointness in general\n+container types like a tree, especially if distinct keys actually *do* map\n+to the same value.\n+\n+In order to \"teach\" borrowck that what we're doing is ok, we need to drop down\n+to unsafe code. For instance, mutable slices expose a `split_at_mut` function\n+that consumes the slice and returns *two* mutable slices. One for everything to\n+the left of the index, and one for everything to the right. Intuitively we know\n+this is safe because the slices don't overlap, and therefore alias. However\n+the implementation requires some unsafety:\n+\n+```rust,ignore\n+fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n+    let len = self.len();\n+    let ptr = self.as_mut_ptr();\n+    assert!(mid <= len);\n+    unsafe {\n+        (from_raw_parts_mut(ptr, mid),\n+         from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n+    }\n+}\n+```\n+\n+This is actually a bit subtle. So as to avoid ever making two `&mut`'s to the\n+same value, we explicitly construct brand-new slices through raw pointers.\n+\n+However more subtle is how iterators that yield mutable references work.\n+The iterator trait is defined as follows:\n+\n+```rust\n+trait Iterator {\n+    type Item;\n+\n+    fn next(&mut self) -> Option<Self::Item>;\n+}\n+```\n+\n+Given this definition, Self::Item has *no* connection to `self`. This means that\n+we can call `next` several times in a row, and hold onto all the results\n+*concurrently*. This is perfectly fine for by-value iterators, which have\n+exactly these semantics. It's also actually fine for shared references, as they\n+admit arbitrarily many references to the same thing (although the iterator needs\n+to be a separate object from the thing being shared).\n+\n+But mutable references make this a mess. At first glance, they might seem\n+completely incompatible with this API, as it would produce multiple mutable\n+references to the same object!\n+\n+However it actually *does* work, exactly because iterators are one-shot objects.\n+Everything an IterMut yields will be yielded *at most* once, so we don't\n+*actually* ever yield multiple mutable references to the same piece of data.\n+\n+Perhaps surprisingly, mutable iterators *don't* require unsafe code to be\n+implemented for many types!\n+\n+For instance here's a singly linked list:\n+\n+```rust\n+# fn main() {}\n+type Link<T> = Option<Box<Node<T>>>;\n+\n+struct Node<T> {\n+    elem: T,\n+    next: Link<T>,\n+}\n+\n+pub struct LinkedList<T> {\n+    head: Link<T>,\n+}\n+\n+pub struct IterMut<'a, T: 'a>(Option<&'a mut Node<T>>);\n+\n+impl<T> LinkedList<T> {\n+    fn iter_mut(&mut self) -> IterMut<T> {\n+        IterMut(self.head.as_mut().map(|node| &mut **node))\n+    }\n+}\n+\n+impl<'a, T> Iterator for IterMut<'a, T> {\n+    type Item = &'a mut T;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.0.take().map(|node| {\n+            self.0 = node.next.as_mut().map(|node| &mut **node);\n+            &mut node.elem\n+        })\n+    }\n+}\n+```\n+\n+Here's a mutable slice:\n+\n+```rust\n+# fn main() {}\n+use std::mem;\n+\n+pub struct IterMut<'a, T: 'a>(&'a mut[T]);\n+\n+impl<'a, T> Iterator for IterMut<'a, T> {\n+    type Item = &'a mut T;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let slice = mem::replace(&mut self.0, &mut []);\n+        if slice.is_empty() { return None; }\n+\n+        let (l, r) = slice.split_at_mut(1);\n+        self.0 = r;\n+        l.get_mut(0)\n+    }\n+}\n+\n+impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        let slice = mem::replace(&mut self.0, &mut []);\n+        if slice.is_empty() { return None; }\n+\n+        let new_len = slice.len() - 1;\n+        let (l, r) = slice.split_at_mut(new_len);\n+        self.0 = l;\n+        r.get_mut(0)\n+    }\n+}\n+```\n+\n+And here's a binary tree:\n+\n+```rust\n+# fn main() {}\n+use std::collections::VecDeque;\n+\n+type Link<T> = Option<Box<Node<T>>>;\n+\n+struct Node<T> {\n+    elem: T,\n+    left: Link<T>,\n+    right: Link<T>,\n+}\n+\n+pub struct Tree<T> {\n+    root: Link<T>,\n+}\n+\n+struct NodeIterMut<'a, T: 'a> {\n+    elem: Option<&'a mut T>,\n+    left: Option<&'a mut Node<T>>,\n+    right: Option<&'a mut Node<T>>,\n+}\n+\n+enum State<'a, T: 'a> {\n+    Elem(&'a mut T),\n+    Node(&'a mut Node<T>),\n+}\n+\n+pub struct IterMut<'a, T: 'a>(VecDeque<NodeIterMut<'a, T>>);\n+\n+impl<T> Tree<T> {\n+    pub fn iter_mut(&mut self) -> IterMut<T> {\n+        let mut deque = VecDeque::new();\n+        self.root.as_mut().map(|root| deque.push_front(root.iter_mut()));\n+        IterMut(deque)\n+    }\n+}\n+\n+impl<T> Node<T> {\n+    pub fn iter_mut(&mut self) -> NodeIterMut<T> {\n+        NodeIterMut {\n+            elem: Some(&mut self.elem),\n+            left: self.left.as_mut().map(|node| &mut **node),\n+            right: self.right.as_mut().map(|node| &mut **node),\n+        }\n+    }\n+}\n+\n+\n+impl<'a, T> Iterator for NodeIterMut<'a, T> {\n+    type Item = State<'a, T>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        match self.left.take() {\n+            Some(node) => Some(State::Node(node)),\n+            None => match self.elem.take() {\n+                Some(elem) => Some(State::Elem(elem)),\n+                None => match self.right.take() {\n+                    Some(node) => Some(State::Node(node)),\n+                    None => None,\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, T> DoubleEndedIterator for NodeIterMut<'a, T> {\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        match self.right.take() {\n+            Some(node) => Some(State::Node(node)),\n+            None => match self.elem.take() {\n+                Some(elem) => Some(State::Elem(elem)),\n+                None => match self.left.take() {\n+                    Some(node) => Some(State::Node(node)),\n+                    None => None,\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, T> Iterator for IterMut<'a, T> {\n+    type Item = &'a mut T;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        loop {\n+            match self.0.front_mut().and_then(|node_it| node_it.next()) {\n+                Some(State::Elem(elem)) => return Some(elem),\n+                Some(State::Node(node)) => self.0.push_front(node.iter_mut()),\n+                None => if let None = self.0.pop_front() { return None },\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        loop {\n+            match self.0.back_mut().and_then(|node_it| node_it.next_back()) {\n+                Some(State::Elem(elem)) => return Some(elem),\n+                Some(State::Node(node)) => self.0.push_back(node.iter_mut()),\n+                None => if let None = self.0.pop_back() { return None },\n+            }\n+        }\n+    }\n+}\n+```\n+\n+All of these are completely safe and work on stable Rust! This ultimately\n+falls out of the simple struct case we saw before: Rust understands that you\n+can safely split a mutable reference into subfields. We can then encode\n+permanently consuming a reference via Options (or in the case of slices,\n+replacing with an empty slice)."}, {"sha": "cb12ffe8d21453a21c06ea2c14f8c7f7d5c52bc2", "filename": "src/doc/tarpl/casts.md", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fcasts.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fcasts.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fcasts.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,71 @@\n+% Casts\n+\n+Casts are a superset of coercions: every coercion can be explicitly\n+invoked via a cast. However some conversions *require* a cast.\n+While coercions are pervasive and largely harmless, these \"true casts\"\n+are rare and potentially dangerous. As such, casts must be explicitly invoked\n+using the `as` keyword: `expr as Type`.\n+\n+True casts generally revolve around raw pointers and the primitive numeric\n+types. Even though they're dangerous, these casts are *infallible* at runtime.\n+If a cast triggers some subtle corner case no indication will be given that\n+this occurred. The cast will simply succeed. That said, casts must be valid\n+at the type level, or else they will be prevented statically. For instance,\n+`7u8 as bool` will not compile.\n+\n+That said, casts aren't `unsafe` because they generally can't violate memory\n+safety *on their own*. For instance, converting an integer to a raw pointer can\n+very easily lead to terrible things. However the act of creating the pointer\n+itself is safe, because actually using a raw pointer is already marked as\n+`unsafe`.\n+\n+Here's an exhaustive list of all the true casts. For brevity, we will use `*`\n+to denote either a `*const` or `*mut`, and `integer` to denote any integral\n+primitive:\n+\n+ * `*T as *U` where `T, U: Sized`\n+ * `*T as *U` TODO: explain unsized situation\n+ * `*T as integer`\n+ * `integer as *T`\n+ * `number as number`\n+ * `C-like-enum as integer`\n+ * `bool as integer`\n+ * `char as integer`\n+ * `u8 as char`\n+ * `&[T; n] as *const T`\n+ * `fn as *T` where `T: Sized`\n+ * `fn as integer`\n+\n+Note that lengths are not adjusted when casting raw slices -\n+`*const [u16] as *const [u8]` creates a slice that only includes\n+half of the original memory.\n+\n+Casting is not transitive, that is, even if `e as U1 as U2` is a valid\n+expression, `e as U2` is not necessarily so.\n+\n+For numeric casts, there are quite a few cases to consider:\n+\n+* casting between two integers of the same size (e.g. i32 -> u32) is a no-op\n+* casting from a larger integer to a smaller integer (e.g. u32 -> u8) will\n+  truncate\n+* casting from a smaller integer to a larger integer (e.g. u8 -> u32) will\n+    * zero-extend if the source is unsigned\n+    * sign-extend if the source is signed\n+* casting from a float to an integer will round the float towards zero\n+    * **[NOTE: currently this will cause Undefined Behaviour if the rounded\n+      value cannot be represented by the target integer type][float-int]**.\n+      This includes Inf and NaN. This is a bug and will be fixed.\n+* casting from an integer to float will produce the floating point\n+  representation of the integer, rounded if necessary (rounding strategy\n+  unspecified)\n+* casting from an f32 to an f64 is perfect and lossless\n+* casting from an f64 to an f32 will produce the closest possible value\n+  (rounding strategy unspecified)\n+    * **[NOTE: currently this will cause Undefined Behaviour if the value\n+      is finite but larger or smaller than the largest or smallest finite\n+      value representable by f32][float-float]**. This is a bug and will\n+      be fixed.\n+\n+\n+[float-int]: https://github.com/rust-lang/rust/issues/10184\n+[float-float]: https://github.com/rust-lang/rust/issues/15536"}, {"sha": "706016a480c6625c9362c41876418197687dff12", "filename": "src/doc/tarpl/checked-uninit.md", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fchecked-uninit.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fchecked-uninit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fchecked-uninit.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,117 @@\n+% Checked Uninitialized Memory\n+\n+Like C, all stack variables in Rust are uninitialized until a value is\n+explicitly assigned to them. Unlike C, Rust statically prevents you from ever\n+reading them until you do:\n+\n+```rust,ignore\n+fn main() {\n+    let x: i32;\n+    println!(\"{}\", x);\n+}\n+```\n+\n+```text\n+src/main.rs:3:20: 3:21 error: use of possibly uninitialized variable: `x`\n+src/main.rs:3     println!(\"{}\", x);\n+                                 ^\n+```\n+\n+This is based off of a basic branch analysis: every branch must assign a value\n+to `x` before it is first used. Interestingly, Rust doesn't require the variable\n+to be mutable to perform a delayed initialization if every branch assigns\n+exactly once. However the analysis does not take advantage of constant analysis\n+or anything like that. So this compiles:\n+\n+```rust\n+fn main() {\n+    let x: i32;\n+\n+    if true {\n+        x = 1;\n+    } else {\n+        x = 2;\n+    }\n+\n+    println!(\"{}\", x);\n+}\n+```\n+\n+but this doesn't:\n+\n+```rust,ignore\n+fn main() {\n+    let x: i32;\n+    if true {\n+        x = 1;\n+    }\n+    println!(\"{}\", x);\n+}\n+```\n+\n+```text\n+src/main.rs:6:17: 6:18 error: use of possibly uninitialized variable: `x`\n+src/main.rs:6   println!(\"{}\", x);\n+```\n+\n+while this does:\n+\n+```rust\n+fn main() {\n+    let x: i32;\n+    if true {\n+        x = 1;\n+        println!(\"{}\", x);\n+    }\n+    // Don't care that there are branches where it's not initialized\n+    // since we don't use the value in those branches\n+}\n+```\n+\n+Of course, while the analysis doesn't consider actual values, it does\n+have a relatively sophisticated understanding of dependencies and control\n+flow. For instance, this works:\n+\n+```rust\n+let x: i32;\n+\n+loop {\n+    // Rust doesn't understand that this branch will be taken unconditionally,\n+    // because it relies on actual values.\n+    if true {\n+        // But it does understand that it will only be taken once because\n+        // we *do* unconditionally break out of it. Therefore `x` doesn't\n+        // need to be marked as mutable.\n+        x = 0;\n+        break;\n+    }\n+}\n+// It also knows that it's impossible to get here without reaching the break.\n+// And therefore that `x` must be initialized here!\n+println!(\"{}\", x);\n+```\n+\n+If a value is moved out of a variable, that variable becomes logically\n+uninitialized if the type of the value isn't Copy. That is:\n+\n+```rust\n+fn main() {\n+    let x = 0;\n+    let y = Box::new(0);\n+    let z1 = x; // x is still valid because i32 is Copy\n+    let z2 = y; // y is now logically uninitialized because Box isn't Copy\n+}\n+```\n+\n+However reassigning `y` in this example *would* require `y` to be marked as\n+mutable, as a Safe Rust program could observe that the value of `y` changed:\n+\n+```rust\n+fn main() {\n+    let mut y = Box::new(0);\n+    let z = y; // y is now logically uninitialized because Box isn't Copy\n+    y = Box::new(1); // reinitialize y\n+}\n+```\n+\n+Otherwise it's like `y` is a brand new variable."}, {"sha": "2e33a6729d1cc8bf23f95b336f64e9fc660b4fee", "filename": "src/doc/tarpl/coercions.md", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fcoercions.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fcoercions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fcoercions.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,70 @@\n+% Coercions\n+\n+Types can implicitly be coerced to change in certain contexts. These changes are\n+generally just *weakening* of types, largely focused around pointers and\n+lifetimes. They mostly exist to make Rust \"just work\" in more cases, and are\n+largely harmless.\n+\n+Here's all the kinds of coercion:\n+\n+Coercion is allowed between the following types:\n+\n+* Transitivity: `T_1` to `T_3` where `T_1` coerces to `T_2` and `T_2` coerces to\n+  `T_3`\n+* Pointer Weakening:\n+    * `&mut T` to `&T`\n+    * `*mut T` to `*const T`\n+    * `&T` to `*const T`\n+    * `&mut T` to `*mut T`\n+* Unsizing: `T` to `U` if `T` implements `CoerceUnsized<U>`\n+\n+`CoerceUnsized<Pointer<U>> for Pointer<T> where T: Unsize<U>` is implemented\n+for all pointer types (including smart pointers like Box and Rc). Unsize is\n+only implemented automatically, and enables the following transformations:\n+\n+* `[T, ..n]` => `[T]`\n+* `T` => `Trait` where `T: Trait`\n+* `Foo<..., T, ...>` => `Foo<..., U, ...>` where:\n+    * `T: Unsize<U>`\n+    * `Foo` is a struct\n+    * Only the last field of `Foo` has type `T`\n+    * `T` is not part of the type of any other fields\n+\n+Coercions occur at a *coercion site*. Any location that is explicitly typed\n+will cause a coercion to its type. If inference is necessary, the coercion will\n+not be performed. Exhaustively, the coercion sites for an expression `e` to\n+type `U` are:\n+\n+* let statements, statics, and consts: `let x: U = e`\n+* Arguments to functions: `takes_a_U(e)`\n+* Any expression that will be returned: `fn foo() -> U { e }`\n+* Struct literals: `Foo { some_u: e }`\n+* Array literals: `let x: [U; 10] = [e, ..]`\n+* Tuple literals: `let x: (U, ..) = (e, ..)`\n+* The last expression in a block: `let x: U = { ..; e }`\n+\n+Note that we do not perform coercions when matching traits (except for\n+receivers, see below). If there is an impl for some type `U` and `T` coerces to\n+`U`, that does not constitute an implementation for `T`. For example, the\n+following will not type check, even though it is OK to coerce `t` to `&T` and\n+there is an impl for `&T`:\n+\n+```rust,ignore\n+trait Trait {}\n+\n+fn foo<X: Trait>(t: X) {}\n+\n+impl<'a> Trait for &'a i32 {}\n+\n+\n+fn main() {\n+    let t: &mut i32 = &mut 0;\n+    foo(t);\n+}\n+```\n+\n+```text\n+<anon>:10:5: 10:8 error: the trait `Trait` is not implemented for the type `&mut i32` [E0277]\n+<anon>:10     foo(t);\n+              ^~~\n+```"}, {"sha": "95973b35d4ffe88583f86c1ec7db0b63258cafe6", "filename": "src/doc/tarpl/concurrency.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fconcurrency.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,13 @@\n+% Concurrency and Paralellism\n+\n+Rust as a language doesn't *really* have an opinion on how to do concurrency or\n+parallelism. The standard library exposes OS threads and blocking sys-calls\n+because *everyone* has those, and they're uniform enough that you can provide\n+an abstraction over them in a relatively uncontroversial way. Message passing,\n+green threads, and async APIs are all diverse enough that any abstraction over\n+them tends to involve trade-offs that we weren't willing to commit to for 1.0.\n+\n+However the way Rust models concurrency makes it relatively easy design your own\n+concurrency paradigm as a library and have *everyone else's* code Just Work\n+with yours. Just require the right lifetimes and Send and Sync where appropriate\n+and you're off to the races. Or rather, off to the... not... having... races.\n\\ No newline at end of file"}, {"sha": "023dea08444a436f403fbdb209e326486d993e76", "filename": "src/doc/tarpl/constructors.md", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fconstructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fconstructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fconstructors.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,59 @@\n+% Constructors\n+\n+There is exactly one way to create an instance of a user-defined type: name it,\n+and initialize all its fields at once:\n+\n+```rust\n+struct Foo {\n+    a: u8,\n+    b: u32,\n+    c: bool,\n+}\n+\n+enum Bar {\n+    X(u32),\n+    Y(bool),\n+}\n+\n+struct Unit;\n+\n+let foo = Foo { a: 0, b: 1, c: false };\n+let bar = Bar::X(0);\n+let empty = Unit;\n+```\n+\n+That's it. Every other way you make an instance of a type is just calling a\n+totally vanilla function that does some stuff and eventually bottoms out to The\n+One True Constructor.\n+\n+Unlike C++, Rust does not come with a slew of built-in kinds of constructor.\n+There are no Copy, Default, Assignment, Move, or whatever constructors. The\n+reasons for this are varied, but it largely boils down to Rust's philosophy of\n+*being explicit*.\n+\n+Move constructors are meaningless in Rust because we don't enable types to\n+\"care\" about their location in memory. Every type must be ready for it to be\n+blindly memcopied to somewhere else in memory. This means pure on-the-stack-but-\n+still-movable intrusive linked lists are simply not happening in Rust (safely).\n+\n+Assignment and copy constructors similarly don't exist because move semantics\n+are the *only* semantics in Rust. At most `x = y` just moves the bits of y into\n+the x variable. Rust *does* provide two facilities for providing C++'s copy-\n+oriented semantics: `Copy` and `Clone`. Clone is our moral equivalent of a copy\n+constructor, but it's never implicitly invoked. You have to explicitly call\n+`clone` on an element you want to be cloned. Copy is a special case of Clone\n+where the implementation is just \"copy the bits\". Copy types *are* implicitly\n+cloned whenever they're moved, but because of the definition of Copy this just\n+means *not* treating the old copy as uninitialized -- a no-op.\n+\n+While Rust provides a `Default` trait for specifying the moral equivalent of a\n+default constructor, it's incredibly rare for this trait to be used. This is\n+because variables [aren't implicitly initialized][uninit]. Default is basically\n+only useful for generic programming. In concrete contexts, a type will provide a\n+static `new` method for any kind of \"default\" constructor. This has no relation\n+to `new` in other languages and has no special meaning. It's just a naming\n+convention.\n+\n+TODO: talk about \"placement new\"?\n+\n+[uninit]: uninitialized.html"}, {"sha": "2309c45c6a84fee8e28e8ae12d0ba5e7a62f28b4", "filename": "src/doc/tarpl/conversions.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fconversions.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fconversions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fconversions.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,34 @@\n+% Type Conversions\n+\n+At the end of the day, everything is just a pile of bits somewhere, and type\n+systems are just there to help us use those bits right. There are two common\n+problems with typing bits: needing to reinterpret those exact bits as a\n+different type, and needing to change the bits to have equivalent meaning for\n+a different type. Because Rust encourages encoding important properties in the\n+type system, these problems are incredibly pervasive. As such, Rust\n+consequently gives you several ways to solve them.\n+\n+First we'll look at the ways that *Safe Rust* gives you to reinterpret values.\n+The most trivial way to do this is to just destructure a value into its\n+constituent parts and then build a new type out of them. e.g.\n+\n+```rust\n+struct Foo {\n+    x: u32,\n+    y: u16,\n+}\n+\n+struct Bar {\n+    a: u32,\n+    b: u16,\n+}\n+\n+fn reinterpret(foo: Foo) -> Bar {\n+    let Foo { x, y } = foo;\n+    Bar { a: x, b: y }\n+}\n+```\n+\n+But this is, at best, annoying. For common conversions, Rust provides\n+more ergonomic alternatives.\n+"}, {"sha": "88d169c3709aa1cc83164df41fa487801cd82b22", "filename": "src/doc/tarpl/data.md", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fdata.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fdata.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fdata.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,5 @@\n+% Data Representation in Rust\n+\n+Low-level programming cares a lot about data layout. It's a big deal. It also pervasively\n+influences the rest of the language, so we're going to start by digging into how data is\n+represented in Rust."}, {"sha": "34c8b2b8624d3122cc4a4d52fbe1311a089bff99", "filename": "src/doc/tarpl/destructors.md", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fdestructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fdestructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fdestructors.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,178 @@\n+% Destructors\n+\n+What the language *does* provide is full-blown automatic destructors through the\n+`Drop` trait, which provides the following method:\n+\n+```rust,ignore\n+fn drop(&mut self);\n+```\n+\n+This method gives the type time to somehow finish what it was doing. **After\n+`drop` is run, Rust will recursively try to drop all of the fields of `self`**.\n+This is a convenience feature so that you don't have to write \"destructor\n+boilerplate\" to drop children. If a struct has no special logic for being\n+dropped other than dropping its children, then it means `Drop` doesn't need to\n+be implemented at all!\n+\n+**There is no stable way to prevent this behaviour in Rust 1.0.\n+\n+Note that taking `&mut self` means that even if you *could* suppress recursive\n+Drop, Rust will prevent you from e.g. moving fields out of self. For most types,\n+this is totally fine.\n+\n+For instance, a custom implementation of `Box` might write `Drop` like this:\n+\n+```rust\n+#![feature(heap_api, core_intrinsics, unique)]\n+\n+use std::rt::heap;\n+use std::ptr::Unique;\n+use std::intrinsics::drop_in_place;\n+use std::mem;\n+\n+struct Box<T>{ ptr: Unique<T> }\n+\n+impl<T> Drop for Box<T> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            drop_in_place(*self.ptr);\n+            heap::deallocate((*self.ptr) as *mut u8,\n+                             mem::size_of::<T>(),\n+                             mem::align_of::<T>());\n+        }\n+    }\n+}\n+```\n+\n+and this works fine because when Rust goes to drop the `ptr` field it just sees\n+a [Unique][] that has no actual `Drop` implementation. Similarly nothing can\n+use-after-free the `ptr` because when drop exits, it becomes inacessible.\n+\n+However this wouldn't work:\n+\n+```rust\n+#![feature(heap_api, core_intrinsics, unique)]\n+\n+use std::rt::heap;\n+use std::ptr::Unique;\n+use std::intrinsics::drop_in_place;\n+use std::mem;\n+\n+struct Box<T>{ ptr: Unique<T> }\n+\n+impl<T> Drop for Box<T> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            drop_in_place(*self.ptr);\n+            heap::deallocate((*self.ptr) as *mut u8,\n+                             mem::size_of::<T>(),\n+                             mem::align_of::<T>());\n+        }\n+    }\n+}\n+\n+struct SuperBox<T> { my_box: Box<T> }\n+\n+impl<T> Drop for SuperBox<T> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            // Hyper-optimized: deallocate the box's contents for it\n+            // without `drop`ing the contents\n+            heap::deallocate((*self.my_box.ptr) as *mut u8,\n+                             mem::size_of::<T>(),\n+                             mem::align_of::<T>());\n+        }\n+    }\n+}\n+```\n+\n+After we deallocate the `box`'s ptr in SuperBox's destructor, Rust will\n+happily proceed to tell the box to Drop itself and everything will blow up with\n+use-after-frees and double-frees.\n+\n+Note that the recursive drop behaviour applies to *all* structs and enums\n+regardless of whether they implement Drop. Therefore something like\n+\n+```rust\n+struct Boxy<T> {\n+    data1: Box<T>,\n+    data2: Box<T>,\n+    info: u32,\n+}\n+```\n+\n+will have its data1 and data2's fields destructors whenever it \"would\" be\n+dropped, even though it itself doesn't implement Drop. We say that such a type\n+*needs Drop*, even though it is not itself Drop.\n+\n+Similarly,\n+\n+```rust\n+enum Link {\n+    Next(Box<Link>),\n+    None,\n+}\n+```\n+\n+will have its inner Box field dropped *if and only if* an instance stores the\n+Next variant.\n+\n+In general this works really nice because you don't need to worry about\n+adding/removing drops when you refactor your data layout. Still there's\n+certainly many valid usecases for needing to do trickier things with\n+destructors.\n+\n+The classic safe solution to overriding recursive drop and allowing moving out\n+of Self during `drop` is to use an Option:\n+\n+```rust\n+#![feature(heap_api, core_intrinsics, unique)]\n+\n+use std::rt::heap;\n+use std::ptr::Unique;\n+use std::intrinsics::drop_in_place;\n+use std::mem;\n+\n+struct Box<T>{ ptr: Unique<T> }\n+\n+impl<T> Drop for Box<T> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            drop_in_place(*self.ptr);\n+            heap::deallocate((*self.ptr) as *mut u8,\n+                             mem::size_of::<T>(),\n+                             mem::align_of::<T>());\n+        }\n+    }\n+}\n+\n+struct SuperBox<T> { my_box: Option<Box<T>> }\n+\n+impl<T> Drop for SuperBox<T> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            // Hyper-optimized: deallocate the box's contents for it\n+            // without `drop`ing the contents. Need to set the `box`\n+            // field as `None` to prevent Rust from trying to Drop it.\n+            let my_box = self.my_box.take().unwrap();\n+            heap::deallocate((*my_box.ptr) as *mut u8,\n+                             mem::size_of::<T>(),\n+                             mem::align_of::<T>());\n+            mem::forget(my_box);\n+        }\n+    }\n+}\n+```\n+\n+However this has fairly odd semantics: you're saying that a field that *should*\n+always be Some may be None, just because that happens in the destructor. Of\n+course this conversely makes a lot of sense: you can call arbitrary methods on\n+self during the destructor, and this should prevent you from ever doing so after\n+deinitializing the field. Not that it will prevent you from producing any other\n+arbitrarily invalid state in there.\n+\n+On balance this is an ok choice. Certainly what you should reach for by default.\n+However, in the future we expect there to be a first-class way to announce that\n+a field shouldn't be automatically dropped.\n+\n+[Unique]: phantom-data.html"}, {"sha": "5d2010d15a80381e735dc1dc375d4e1b40b0e220", "filename": "src/doc/tarpl/dot-operator.md", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fdot-operator.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fdot-operator.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fdot-operator.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,6 @@\n+% The Dot Operator\n+\n+The dot operator will perform a lot of magic to convert types. It will perform\n+auto-referencing, auto-dereferencing, and coercion until types match.\n+\n+TODO: steal information from http://stackoverflow.com/questions/28519997/what-are-rusts-exact-auto-dereferencing-rules/28552082#28552082"}, {"sha": "f95ccc00329e55f5d240e055efd31961dfa5c510", "filename": "src/doc/tarpl/drop-flags.md", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fdrop-flags.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fdrop-flags.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fdrop-flags.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,95 @@\n+% Drop Flags\n+\n+The examples in the previous section introduce an interesting problem for Rust.\n+We have seen that's possible to conditionally initialize, deinitialize, and\n+reinitialize locations of memory totally safely. For Copy types, this isn't\n+particularly notable since they're just a random pile of bits. However types\n+with destructors are a different story: Rust needs to know whether to call a\n+destructor whenever a variable is assigned to, or a variable goes out of scope.\n+How can it do this with conditional initialization?\n+\n+Note that this is not a problem that all assignments need worry about. In\n+particular, assigning through a dereference unconditionally drops, and assigning\n+in a `let` unconditionally *doesn't* drop:\n+\n+```\n+let mut x = Box::new(0); // let makes a fresh variable, so never need to drop\n+let y = &mut x;\n+*y = Box::new(1); // Deref assumes the referent is initialized, so always drops\n+```\n+\n+This is only a problem when overwriting a previously initialized variable or\n+one of its subfields.\n+\n+It turns out that Rust actually tracks whether a type should be dropped or not\n+*at runtime*. As a variable becomes initialized and uninitialized, a *drop flag*\n+for that variable is toggled. When a variable *might* need to be dropped, this\n+flag is evaluated to determine if it *should* be dropped.\n+\n+Of course, it is *often* the case that a value's initialization state can be\n+*statically* known at every point in the program. If this is the case, then the\n+compiler can theoretically generate more efficient code! For instance, straight-\n+line code has such *static drop semantics*:\n+\n+```rust\n+let mut x = Box::new(0); // x was uninit; just overwrite.\n+let mut y = x;           // y was uninit; just overwrite and make x uninit.\n+x = Box::new(0);         // x was uninit; just overwrite.\n+y = x;                   // y was init; Drop y, overwrite it, and make x uninit!\n+                         // y goes out of scope; y was init; Drop y!\n+                         // x goes out of scope; x was uninit; do nothing.\n+```\n+\n+And even branched code where all branches have the same behaviour with respect\n+to initialization:\n+\n+```rust\n+# let condition = true;\n+let mut x = Box::new(0);    // x was uninit; just overwrite.\n+if condition {\n+    drop(x)                 // x gets moved out; make x uninit.\n+} else {\n+    println!(\"{}\", x);\n+    drop(x)                 // x gets moved out; make x uninit.\n+}\n+x = Box::new(0);            // x was uninit; just overwrite.\n+                            // x goes out of scope; x was init; Drop x!\n+```\n+\n+However code like this *requires* runtime information to correctly Drop:\n+\n+```rust\n+# let condition = true;\n+let x;\n+if condition {\n+    x = Box::new(0);        // x was uninit; just overwrite.\n+    println!(\"{}\", x);\n+}\n+                            // x goes out of scope; x *might* be uninit;\n+                            // check the flag!\n+```\n+\n+Of course, in this case it's trivial to retrieve static drop semantics:\n+\n+```rust\n+# let condition = true;\n+if condition {\n+    let x = Box::new(0);\n+    println!(\"{}\", x);\n+}\n+```\n+\n+As of Rust 1.0, the drop flags are actually not-so-secretly stashed in a hidden\n+field of any type that implements Drop. Rust sets the drop flag by overwriting\n+the *entire* value with a particular bit pattern. This is pretty obviously Not\n+The Fastest and causes a bunch of trouble with optimizing code. It's legacy from\n+a time when you could do much more complex conditional initialization.\n+\n+As such work is currently under way to move the flags out onto the stack frame\n+where they more reasonably belong. Unfortunately, this work will take some time\n+as it requires fairly substantial changes to the compiler.\n+\n+Regardless, Rust programs don't need to worry about uninitialized values on\n+the stack for correctness. Although they might care for performance. Thankfully,\n+Rust makes it easy to take control here! Uninitialized values are there, and\n+you can work with them in Safe Rust, but you're *never* in danger."}, {"sha": "c75bf8b11794c2afecca427eba51071f6c0ffad6", "filename": "src/doc/tarpl/dropck.md", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fdropck.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fdropck.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fdropck.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,127 @@\n+% Drop Check\n+\n+We have seen how lifetimes provide us some fairly simple rules for ensuring\n+that never read dangling references. However up to this point we have only ever\n+interacted with the *outlives* relationship in an inclusive manner. That is,\n+when we talked about `'a: 'b`, it was ok for `'a` to live *exactly* as long as\n+`'b`. At first glance, this seems to be a meaningless distinction. Nothing ever\n+gets dropped at the same time as another, right? This is why we used the\n+following desugarring of `let` statements:\n+\n+```rust,ignore\n+let x;\n+let y;\n+```\n+\n+```rust,ignore\n+{\n+    let x;\n+    {\n+        let y;\n+    }\n+}\n+```\n+\n+Each creates its own scope, clearly establishing that one drops before the\n+other. However, what if we do the following?\n+\n+```rust,ignore\n+let (x, y) = (vec![], vec![]);\n+```\n+\n+Does either value strictly outlive the other? The answer is in fact *no*,\n+neither value  strictly outlives the other. Of course, one of x or y will be\n+dropped before the other, but the actual order is not specified. Tuples aren't\n+special in this regard; composite structures just don't guarantee their\n+destruction order as of Rust 1.0.\n+\n+We *could* specify this for the fields of built-in composites like tuples and\n+structs. However, what about something like Vec? Vec has to manually drop its\n+elements via pure-library code. In general, anything that implements Drop has\n+a chance to fiddle with its innards during its final death knell. Therefore\n+the compiler can't sufficiently reason about the actual destruction order\n+of the contents of any type that implements Drop.\n+\n+So why do we care? We care because if the type system isn't careful, it could\n+accidentally make dangling pointers. Consider the following simple program:\n+\n+```rust\n+struct Inspector<'a>(&'a u8);\n+\n+fn main() {\n+    let (inspector, days);\n+    days = Box::new(1);\n+    inspector = Inspector(&days);\n+}\n+```\n+\n+This program is totally sound and compiles today. The fact that `days` does\n+not *strictly* outlive `inspector` doesn't matter. As long as the `inspector`\n+is alive, so is days.\n+\n+However if we add a destructor, the program will no longer compile!\n+\n+```rust,ignore\n+struct Inspector<'a>(&'a u8);\n+\n+impl<'a> Drop for Inspector<'a> {\n+    fn drop(&mut self) {\n+        println!(\"I was only {} days from retirement!\", self.0);\n+    }\n+}\n+\n+fn main() {\n+    let (inspector, days);\n+    days = Box::new(1);\n+    inspector = Inspector(&days);\n+    // Let's say `days` happens to get dropped first.\n+    // Then when Inspector is dropped, it will try to read free'd memory!\n+}\n+```\n+\n+```text\n+<anon>:12:28: 12:32 error: `days` does not live long enough\n+<anon>:12     inspector = Inspector(&days);\n+                                     ^~~~\n+<anon>:9:11: 15:2 note: reference must be valid for the block at 9:10...\n+<anon>:9 fn main() {\n+<anon>:10     let (inspector, days);\n+<anon>:11     days = Box::new(1);\n+<anon>:12     inspector = Inspector(&days);\n+<anon>:13     // Let's say `days` happens to get dropped first.\n+<anon>:14     // Then when Inspector is dropped, it will try to read free'd memory!\n+          ...\n+<anon>:10:27: 15:2 note: ...but borrowed value is only valid for the block suffix following statement 0 at 10:26\n+<anon>:10     let (inspector, days);\n+<anon>:11     days = Box::new(1);\n+<anon>:12     inspector = Inspector(&days);\n+<anon>:13     // Let's say `days` happens to get dropped first.\n+<anon>:14     // Then when Inspector is dropped, it will try to read free'd memory!\n+<anon>:15 }\n+```\n+\n+Implementing Drop lets the Inspector execute some arbitrary code *during* its\n+death. This means it can potentially observe that types that are supposed to\n+live as long as it does actually were destroyed first.\n+\n+Interestingly, only *generic* types need to worry about this. If they aren't\n+generic, then the only lifetimes they can harbor are `'static`, which will truly\n+live *forever*. This is why this problem is referred to as *sound generic drop*.\n+Sound generic drop is enforced by the *drop checker*. As of this writing, some\n+of the finer details of how the drop checker validates types is totally up in\n+the air. However The Big Rule is the subtlety that we have focused on this whole\n+section:\n+\n+**For a generic type to soundly implement drop, its generics arguments must\n+strictly outlive it.**\n+\n+This rule is sufficient but not necessary to satisfy the drop checker. That is,\n+if your type obeys this rule then it's *definitely* sound to drop. However\n+there are special cases where you can fail to satisfy this, but still\n+successfully pass the borrow checker. These are the precise rules that are\n+currently up in the air.\n+\n+It turns out that when writing unsafe code, we generally don't need to\n+worry at all about doing the right thing for the drop checker. However there\n+is *one* special case that you need to worry about, which we will look at in\n+the next section."}, {"sha": "a43eec4f37ea3de9c7b79ff0a30bca5a829666ed", "filename": "src/doc/tarpl/exception-safety.md", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fexception-safety.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fexception-safety.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fexception-safety.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,218 @@\n+% Exception Safety\n+\n+Although programs should use unwinding sparingly, there's *a lot* of code that\n+*can* panic. If you unwrap a None, index out of bounds, or divide by 0, your\n+program *will* panic. On debug builds, *every* arithmetic operation can panic\n+if it overflows. Unless you are very careful and tightly control what code runs,\n+pretty much everything can unwind, and you need to be ready for it.\n+\n+Being ready for unwinding is often referred to as *exception safety*\n+in the broader programming world. In Rust, there are two levels of exception\n+safety that one may concern themselves with:\n+\n+* In unsafe code, we *must* be exception safe to the point of not violating\n+  memory safety. We'll call this *minimal* exception safety.\n+\n+* In safe code, it is *good* to be exception safe to the point of your program\n+  doing the right thing. We'll call this *maximal* exception safety.\n+\n+As is the case in many places in Rust, Unsafe code must be ready to deal with\n+bad Safe code when it comes to unwinding. Code that transiently creates\n+unsound states must be careful that a panic does not cause that state to be\n+used. Generally this means ensuring that only non-panicking code is run while\n+these states exist, or making a guard that cleans up the state in the case of\n+a panic. This does not necessarily mean that the state a panic witnesses is a\n+fully *coherent* state. We need only guarantee that it's a *safe* state.\n+\n+Most Unsafe code is leaf-like, and therefore fairly easy to make exception-safe.\n+It controls all the code that runs, and most of that code can't panic. However\n+it is not uncommon for Unsafe code to work with arrays of temporarily\n+uninitialized data while repeatedly invoking caller-provided code. Such code\n+needs to be careful and consider exception safety.\n+\n+\n+\n+\n+\n+## Vec::push_all\n+\n+`Vec::push_all` is a temporary hack to get extending a Vec by a slice reliably\n+efficient without specialization. Here's a simple implementation:\n+\n+```rust,ignore\n+impl<T: Clone> Vec<T> {\n+    fn push_all(&mut self, to_push: &[T]) {\n+        self.reserve(to_push.len());\n+        unsafe {\n+            // can't overflow because we just reserved this\n+            self.set_len(self.len() + to_push.len());\n+\n+            for (i, x) in to_push.iter().enumerate() {\n+                self.ptr().offset(i as isize).write(x.clone());\n+            }\n+        }\n+    }\n+}\n+```\n+\n+We bypass `push` in order to avoid redundant capacity and `len` checks on the\n+Vec that we definitely know has capacity. The logic is totally correct, except\n+there's a subtle problem with our code: it's not exception-safe! `set_len`,\n+`offset`, and `write` are all fine, but *clone* is the panic bomb we over-\n+looked.\n+\n+Clone is completely out of our control, and is totally free to panic. If it\n+does, our function will exit early with the length of the Vec set too large. If\n+the Vec is looked at or dropped, uninitialized memory will be read!\n+\n+The fix in this case is fairly simple. If we want to guarantee that the values\n+we *did* clone are dropped we can set the len *in* the loop. If we just want to\n+guarantee that uninitialized memory can't be observed, we can set the len\n+*after* the loop.\n+\n+\n+\n+\n+\n+## BinaryHeap::sift_up\n+\n+Bubbling an element up a heap is a bit more complicated than extending a Vec.\n+The pseudocode is as follows:\n+\n+```text\n+bubble_up(heap, index):\n+    while index != 0 && heap[index] < heap[parent(index)]:\n+        heap.swap(index, parent(index))\n+        index = parent(index)\n+\n+```\n+\n+A literal transcription of this code to Rust is totally fine, but has an annoying\n+performance characteristic: the `self` element is swapped over and over again\n+uselessly. We would *rather* have the following:\n+\n+```text\n+bubble_up(heap, index):\n+    let elem = heap[index]\n+    while index != 0 && element < heap[parent(index)]:\n+        heap[index] = heap[parent(index)]\n+        index = parent(index)\n+    heap[index] = elem\n+```\n+\n+This code ensures that each element is copied as little as possible (it is in\n+fact necessary that elem be copied twice in general). However it now exposes\n+some exception safety trouble! At all times, there exists two copies of one\n+value. If we panic in this function something will be double-dropped.\n+Unfortunately, we also don't have full control of the code: that comparison is\n+user-defined!\n+\n+Unlike Vec, the fix isn't as easy here. One option is to break the user-defined\n+code and the unsafe code into two separate phases:\n+\n+```text\n+bubble_up(heap, index):\n+    let end_index = index;\n+    while end_index != 0 && heap[end_index] < heap[parent(end_index)]:\n+        end_index = parent(end_index)\n+\n+    let elem = heap[index]\n+    while index != end_index:\n+        heap[index] = heap[parent(index)]\n+        index = parent(index)\n+    heap[index] = elem\n+```\n+\n+If the user-defined code blows up, that's no problem anymore, because we haven't\n+actually touched the state of the heap yet. Once we do start messing with the\n+heap, we're working with only data and functions that we trust, so there's no\n+concern of panics.\n+\n+Perhaps you're not happy with this design. Surely, it's cheating! And we have\n+to do the complex heap traversal *twice*! Alright, let's bite the bullet. Let's\n+intermix untrusted and unsafe code *for reals*.\n+\n+If Rust had `try` and `finally` like in Java, we could do the following:\n+\n+```text\n+bubble_up(heap, index):\n+    let elem = heap[index]\n+    try:\n+        while index != 0 && element < heap[parent(index)]:\n+            heap[index] = heap[parent(index)]\n+            index = parent(index)\n+    finally:\n+        heap[index] = elem\n+```\n+\n+The basic idea is simple: if the comparison panics, we just toss the loose\n+element in the logically uninitialized index and bail out. Anyone who observes\n+the heap will see a potentially *inconsistent* heap, but at least it won't\n+cause any double-drops! If the algorithm terminates normally, then this\n+operation happens to coincide precisely with the how we finish up regardless.\n+\n+Sadly, Rust has no such construct, so we're going to need to roll our own! The\n+way to do this is to store the algorithm's state in a separate struct with a\n+destructor for the \"finally\" logic. Whether we panic or not, that destructor\n+will run and clean up after us.\n+\n+```rust,ignore\n+struct Hole<'a, T: 'a> {\n+    data: &'a mut [T],\n+    /// `elt` is always `Some` from new until drop.\n+    elt: Option<T>,\n+    pos: usize,\n+}\n+\n+impl<'a, T> Hole<'a, T> {\n+    fn new(data: &'a mut [T], pos: usize) -> Self {\n+        unsafe {\n+            let elt = ptr::read(&data[pos]);\n+            Hole {\n+                data: data,\n+                elt: Some(elt),\n+                pos: pos,\n+            }\n+        }\n+    }\n+\n+    fn pos(&self) -> usize { self.pos }\n+\n+    fn removed(&self) -> &T { self.elt.as_ref().unwrap() }\n+\n+    unsafe fn get(&self, index: usize) -> &T { &self.data[index] }\n+\n+    unsafe fn move_to(&mut self, index: usize) {\n+        let index_ptr: *const _ = &self.data[index];\n+        let hole_ptr = &mut self.data[self.pos];\n+        ptr::copy_nonoverlapping(index_ptr, hole_ptr, 1);\n+        self.pos = index;\n+    }\n+}\n+\n+impl<'a, T> Drop for Hole<'a, T> {\n+    fn drop(&mut self) {\n+        // fill the hole again\n+        unsafe {\n+            let pos = self.pos;\n+            ptr::write(&mut self.data[pos], self.elt.take().unwrap());\n+        }\n+    }\n+}\n+\n+impl<T: Ord> BinaryHeap<T> {\n+    fn sift_up(&mut self, pos: usize) {\n+        unsafe {\n+            // Take out the value at `pos` and create a hole.\n+            let mut hole = Hole::new(&mut self.data, pos);\n+\n+            while hole.pos() != 0 {\n+                let parent = parent(hole.pos());\n+                if hole.removed() <= hole.get(parent) { break }\n+                hole.move_to(parent);\n+            }\n+            // Hole will be unconditionally filled here; panic or not!\n+        }\n+    }\n+}\n+```"}, {"sha": "d75d12e716e3158bb2112366aab8604c9d3a17f0", "filename": "src/doc/tarpl/exotic-sizes.md", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fexotic-sizes.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fexotic-sizes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fexotic-sizes.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,137 @@\n+% Exotically Sized Types\n+\n+Most of the time, we think in terms of types with a fixed, positive size. This\n+is not always the case, however.\n+\n+\n+\n+\n+\n+# Dynamically Sized Types (DSTs)\n+\n+Rust in fact supports Dynamically Sized Types (DSTs): types without a statically\n+known size or alignment. On the surface, this is a bit nonsensical: Rust *must*\n+know the size and alignment of something in order to correctly work with it! In\n+this regard, DSTs are not normal types. Due to their lack of a statically known\n+size, these types can only exist behind some kind of pointer. Any pointer to a\n+DST consequently becomes a *fat* pointer consisting of the pointer and the\n+information that \"completes\" them (more on this below).\n+\n+There are two major DSTs exposed by the language: trait objects, and slices.\n+\n+A trait object represents some type that implements the traits it specifies.\n+The exact original type is *erased* in favour of runtime reflection\n+with a vtable containing all the information necessary to use the type.\n+This is the information that completes a trait object: a pointer to its vtable.\n+\n+A slice is simply a view into some contiguous storage -- typically an array or\n+`Vec`. The information that completes a slice is just the number of elements\n+it points to.\n+\n+Structs can actually store a single DST directly as their last field, but this\n+makes them a DST as well:\n+\n+```rust\n+// Can't be stored on the stack directly\n+struct Foo {\n+    info: u32,\n+    data: [u8],\n+}\n+```\n+\n+**NOTE: [As of Rust 1.0 struct DSTs are broken if the last field has\n+a variable position based on its alignment][dst-issue].**\n+\n+\n+\n+\n+\n+# Zero Sized Types (ZSTs)\n+\n+Rust actually allows types to be specified that occupy *no* space:\n+\n+```rust\n+struct Foo; // No fields = no size\n+\n+// All fields have no size = no size\n+struct Baz {\n+    foo: Foo,\n+    qux: (),      // empty tuple has no size\n+    baz: [u8; 0], // empty array has no size\n+}\n+```\n+\n+On their own, Zero Sized Types (ZSTs) are, for obvious reasons, pretty useless.\n+However as with many curious layout choices in Rust, their potential is realized\n+in a generic context: Rust largely understands that any operation that  produces\n+or stores a ZST can be reduced to a no-op. First off, storing it  doesn't even\n+make sense -- it doesn't occupy any space. Also there's only one  value of that\n+type, so anything that loads it can just produce it from the  aether -- which is\n+also a no-op since it doesn't occupy any space.\n+\n+One of the most extreme example's of this is Sets and Maps. Given a\n+`Map<Key, Value>`, it is common to implement a `Set<Key>` as just a thin wrapper\n+around `Map<Key, UselessJunk>`. In many languages, this would necessitate\n+allocating space for UselessJunk and doing work to store and load UselessJunk\n+only to discard it. Proving this unnecessary would be a difficult analysis for\n+the compiler.\n+\n+However in Rust, we can just say that  `Set<Key> = Map<Key, ()>`. Now Rust\n+statically knows that every load and store is useless, and no allocation has any\n+size. The result is that the monomorphized code is basically a custom\n+implementation of a HashSet with none of the overhead that HashMap would have to\n+support values.\n+\n+Safe code need not worry about ZSTs, but *unsafe* code must be careful about the\n+consequence of types with no size. In particular, pointer offsets are no-ops,\n+and standard allocators (including jemalloc, the one used by default in Rust)\n+generally consider passing in `0` for the size of an allocation as Undefined\n+Behaviour.\n+\n+\n+\n+\n+\n+# Empty Types\n+\n+Rust also enables types to be declared that *cannot even be instantiated*. These\n+types can only be talked about at the type level, and never at the value level.\n+Empty types can be declared by specifying an enum with no variants:\n+\n+```rust\n+enum Void {} // No variants = EMPTY\n+```\n+\n+Empty types are even more marginal than ZSTs. The primary motivating example for\n+Void types is type-level unreachability. For instance, suppose an API needs to\n+return a Result in general, but a specific case actually is infallible. It's\n+actually possible to communicate this at the type level by returning a\n+`Result<T, Void>`. Consumers of the API can confidently unwrap such a Result\n+knowing that it's *statically impossible* for this value to be an `Err`, as\n+this would require providing a value of type `Void`.\n+\n+In principle, Rust can do some interesting analyses and optimizations based\n+on this fact. For instance, `Result<T, Void>` could be represented as just `T`,\n+because the `Err` case doesn't actually exist. The following *could* also\n+compile:\n+\n+```rust,ignore\n+enum Void {}\n+\n+let res: Result<u32, Void> = Ok(0);\n+\n+// Err doesn't exist anymore, so Ok is actually irrefutable.\n+let Ok(num) = res;\n+```\n+\n+But neither of these tricks work today, so all Void types get you today is\n+the ability to be confident that certain situations are statically impossible.\n+\n+One final subtle detail about empty types is that raw pointers to them are\n+actually valid to construct, but dereferencing them is Undefined Behaviour\n+because that doesn't actually make sense. That is, you could model C's `void *`\n+type with `*const Void`, but this doesn't necessarily gain anything over using\n+e.g. `*const ()`, which *is* safe to randomly dereference.\n+\n+\n+[dst-issue]: https://github.com/rust-lang/rust/issues/26403"}, {"sha": "3cc06f21df0007176f99f1ed360974af68f3b731", "filename": "src/doc/tarpl/hrtb.md", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fhrtb.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fhrtb.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fhrtb.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,73 @@\n+% Higher-Rank Trait Bounds (HRTBs)\n+\n+Rust's `Fn` traits are a little bit magic. For instance, we can write the\n+following code:\n+\n+```rust\n+struct Closure<F> {\n+    data: (u8, u16),\n+    func: F,\n+}\n+\n+impl<F> Closure<F>\n+    where F: Fn(&(u8, u16)) -> &u8,\n+{\n+    fn call(&self) -> &u8 {\n+        (self.func)(&self.data)\n+    }\n+}\n+\n+fn do_it(data: &(u8, u16)) -> &u8 { &data.0 }\n+\n+fn main() {\n+    let clo = Closure { data: (0, 1), func: do_it };\n+    println!(\"{}\", clo.call());\n+}\n+```\n+\n+If we try to naively desugar this code in the same way that we did in the\n+lifetimes section, we run into some trouble:\n+\n+```rust,ignore\n+struct Closure<F> {\n+    data: (u8, u16),\n+    func: F,\n+}\n+\n+impl<F> Closure<F>\n+    // where F: Fn(&'??? (u8, u16)) -> &'??? u8,\n+{\n+    fn call<'a>(&'a self) -> &'a u8 {\n+        (self.func)(&self.data)\n+    }\n+}\n+\n+fn do_it<'b>(data: &'b (u8, u16)) -> &'b u8 { &'b data.0 }\n+\n+fn main() {\n+    'x: {\n+        let clo = Closure { data: (0, 1), func: do_it };\n+        println!(\"{}\", clo.call());\n+    }\n+}\n+```\n+\n+How on earth are we supposed to express the lifetimes on `F`'s trait bound? We\n+need to provide some lifetime there, but the lifetime we care about can't be\n+named until we enter the body of `call`! Also, that isn't some fixed lifetime;\n+call works with *any* lifetime `&self` happens to have at that point.\n+\n+This job requires The Magic of Higher-Rank Trait Bounds (HRTBs). The way we\n+desugar this is as follows:\n+\n+```rust,ignore\n+where for<'a> F: Fn(&'a (u8, u16)) -> &'a u8,\n+```\n+\n+(Where `Fn(a, b, c) -> d` is itself just sugar for the unstable *real* `Fn`\n+trait)\n+\n+`for<'a>` can be read as \"for all choices of `'a`\", and basically produces an\n+*infinite list* of trait bounds that F must satisfy. Intense. There aren't many\n+places outside of the `Fn` traits where we encounter HRTBs, and even for\n+those we have a nice magic sugar for the common cases."}, {"sha": "343de99f08ad0270427d3dadc9c0bfdf3e1466f1", "filename": "src/doc/tarpl/leaking.md", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fleaking.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fleaking.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fleaking.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,252 @@\n+% Leaking\n+\n+Ownership-based resource management is intended to simplify composition. You\n+acquire resources when you create the object, and you release the resources when\n+it gets destroyed. Since destruction is handled for you, it means you can't\n+forget to release the resources, and it happens as soon as possible! Surely this\n+is perfect and all of our problems are solved.\n+\n+Everything is terrible and we have new and exotic problems to try to solve.\n+\n+Many people like to believe that Rust eliminates resource leaks. In practice,\n+this is basically true. You would be surprised to see a Safe Rust program\n+leak resources in an uncontrolled way.\n+\n+However from a theoretical perspective this is absolutely not the case, no\n+matter how you look at it. In the strictest sense, \"leaking\" is so abstract as\n+to be unpreventable. It's quite trivial to initialize a collection at the start\n+of a program, fill it with tons of objects with destructors, and then enter an\n+infinite event loop that never refers to it. The collection will sit around\n+uselessly, holding on to its precious resources until the program terminates (at\n+which point all those resources would have been reclaimed by the OS anyway).\n+\n+We may consider a more restricted form of leak: failing to drop a value that is\n+unreachable. Rust also doesn't prevent this. In fact Rust has a *function for\n+doing this*: `mem::forget`. This function consumes the value it is passed *and\n+then doesn't run its destructor*.\n+\n+In the past `mem::forget` was marked as unsafe as a sort of lint against using\n+it, since failing to call a destructor is generally not a well-behaved thing to\n+do (though useful for some special unsafe code). However this was generally\n+determined to be an untenable stance to take: there are *many* ways to fail to\n+call a destructor in safe code. The most famous example is creating a cycle of\n+reference-counted pointers using interior mutability.\n+\n+It is reasonable for safe code to assume that destructor leaks do not happen, as\n+any program that leaks destructors is probably wrong. However *unsafe* code\n+cannot rely on destructors to be run to be *safe*. For most types this doesn't\n+matter: if you leak the destructor then the type is *by definition*\n+inaccessible, so it doesn't matter, right? For instance, if you leak a `Box<u8>`\n+then you waste some memory but that's hardly going to violate memory-safety.\n+\n+However where we must be careful with destructor leaks are *proxy* types. These\n+are types which manage access to a distinct object, but don't actually own it.\n+Proxy objects are quite rare. Proxy objects you'll need to care about are even\n+rarer. However we'll focus on three interesting examples in the standard\n+library:\n+\n+* `vec::Drain`\n+* `Rc`\n+* `thread::scoped::JoinGuard`\n+\n+\n+\n+## Drain\n+\n+`drain` is a collections API that moves data out of the container without\n+consuming the container. This enables us to reuse the allocation of a `Vec`\n+after claiming ownership over all of its contents. It produces an iterator\n+(Drain) that returns the contents of the Vec by-value.\n+\n+Now, consider Drain in the middle of iteration: some values have been moved out,\n+and others haven't. This means that part of the Vec is now full of logically\n+uninitialized data! We could backshift all the elements in the Vec every time we\n+remove a value, but this would have pretty catastrophic performance\n+consequences.\n+\n+Instead, we would like Drain to *fix* the Vec's backing storage when it is\n+dropped. It should run itself to completion, backshift any elements that weren't\n+removed (drain supports subranges), and then fix Vec's `len`. It's even\n+unwinding-safe! Easy!\n+\n+Now consider the following:\n+\n+```rust,ignore\n+let mut vec = vec![Box::new(0); 4];\n+\n+{\n+    // start draining, vec can no longer be accessed\n+    let mut drainer = vec.drain(..);\n+\n+    // pull out two elements and immediately drop them\n+    drainer.next();\n+    drainer.next();\n+\n+    // get rid of drainer, but don't call its destructor\n+    mem::forget(drainer);\n+}\n+\n+// Oops, vec[0] was dropped, we're reading a pointer into free'd memory!\n+println!(\"{}\", vec[0]);\n+```\n+\n+This is pretty clearly Not Good. Unfortunately, we're kind've stuck between a\n+rock and a hard place: maintaining consistent state at every step has an\n+enormous cost (and would negate any benefits of the API). Failing to maintain\n+consistent state gives us Undefined Behaviour in safe code (making the API\n+unsound).\n+\n+So what can we do? Well, we can pick a trivially consistent state: set the Vec's\n+len to be 0 when we *start* the iteration, and fix it up if necessary in the\n+destructor. That way, if everything executes like normal we get the desired\n+behaviour with minimal overhead. But if someone has the *audacity* to\n+mem::forget us in the middle of the iteration, all that does is *leak even more*\n+(and possibly leave the Vec in an *unexpected* but consistent state). Since\n+we've accepted that mem::forget is safe, this is definitely safe. We call leaks\n+causing more leaks a *leak amplification*.\n+\n+\n+\n+\n+## Rc\n+\n+Rc is an interesting case because at first glance it doesn't appear to be a\n+proxy value at all. After all, it manages the data it points to, and dropping\n+all the Rcs for a value will drop that value. Leaking an Rc doesn't seem like it\n+would be particularly dangerous. It will leave the refcount permanently\n+incremented and prevent the data from being freed or dropped, but that seems\n+just like Box, right?\n+\n+Nope.\n+\n+Let's consider a simplified implementation of Rc:\n+\n+```rust,ignore\n+struct Rc<T> {\n+    ptr: *mut RcBox<T>,\n+}\n+\n+struct RcBox<T> {\n+    data: T,\n+    ref_count: usize,\n+}\n+\n+impl<T> Rc<T> {\n+    fn new(data: T) -> Self {\n+        unsafe {\n+            // Wouldn't it be nice if heap::allocate worked like this?\n+            let ptr = heap::allocate<RcBox<T>>();\n+            ptr::write(ptr, RcBox {\n+                data: data,\n+                ref_count: 1,\n+            });\n+            Rc { ptr: ptr }\n+        }\n+    }\n+\n+    fn clone(&self) -> Self {\n+        unsafe {\n+            (*self.ptr).ref_count += 1;\n+        }\n+        Rc { ptr: self.ptr }\n+    }\n+}\n+\n+impl<T> Drop for Rc<T> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            let inner = &mut ;\n+            (*self.ptr).ref_count -= 1;\n+            if (*self.ptr).ref_count == 0 {\n+                // drop the data and then free it\n+                ptr::read(self.ptr);\n+                heap::deallocate(self.ptr);\n+            }\n+        }\n+    }\n+}\n+```\n+\n+This code contains an implicit and subtle assumption: ref_count can fit in a\n+`usize`, because there can't be more than `usize::MAX` Rcs in memory. However\n+this itself assumes that the ref_count accurately reflects the number of Rcs\n+in memory, which we know is false with mem::forget. Using mem::forget we can\n+overflow the ref_count, and then get it down to 0 with outstanding Rcs. Then we\n+can happily use-after-free the inner data. Bad Bad Not Good.\n+\n+This can be solved by *saturating* the ref_count, which is sound because\n+decreasing the refcount by `n` still requires `n` Rcs simultaneously living\n+in memory.\n+\n+\n+\n+\n+## thread::scoped::JoinGuard\n+\n+The thread::scoped API intends to allow threads to be spawned that reference\n+data on their parent's stack without any synchronization over that data by\n+ensuring the parent joins the thread before any of the shared data goes out\n+of scope.\n+\n+```rust,ignore\n+pub fn scoped<'a, F>(f: F) -> JoinGuard<'a>\n+    where F: FnOnce() + Send + 'a\n+```\n+\n+Here `f` is some closure for the other thread to execute. Saying that\n+`F: Send +'a` is saying that it closes over data that lives for `'a`, and it\n+either owns that data or the data was Sync (implying `&data` is Send).\n+\n+Because JoinGuard has a lifetime, it keeps all the data it closes over\n+borrowed in the parent thread. This means the JoinGuard can't outlive\n+the data that the other thread is working on. When the JoinGuard *does* get\n+dropped it blocks the parent thread, ensuring the child terminates before any\n+of the closed-over data goes out of scope in the parent.\n+\n+Usage looked like:\n+\n+```rust,ignore\n+let mut data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+{\n+    let guards = vec![];\n+    for x in &mut data {\n+        // Move the mutable reference into the closure, and execute\n+        // it on a different thread. The closure has a lifetime bound\n+        // by the lifetime of the mutable reference `x` we store in it.\n+        // The guard that is returned is in turn assigned the lifetime\n+        // of the closure, so it also mutably borrows `data` as `x` did.\n+        // This means we cannot access `data` until the guard goes away.\n+        let guard = thread::scoped(move || {\n+            *x *= 2;\n+        });\n+        // store the thread's guard for later\n+        guards.push(guard);\n+    }\n+    // All guards are dropped here, forcing the threads to join\n+    // (this thread blocks here until the others terminate).\n+    // Once the threads join, the borrow expires and the data becomes\n+    // accessible again in this thread.\n+}\n+// data is definitely mutated here.\n+```\n+\n+In principle, this totally works! Rust's ownership system perfectly ensures it!\n+...except it relies on a destructor being called to be safe.\n+\n+```rust,ignore\n+let mut data = Box::new(0);\n+{\n+    let guard = thread::scoped(|| {\n+        // This is at best a data race. At worst, it's *also* a use-after-free.\n+        *data += 1;\n+    });\n+    // Because the guard is forgotten, expiring the loan without blocking this\n+    // thread.\n+    mem::forget(guard);\n+}\n+// So the Box is dropped here while the scoped thread may or may not be trying\n+// to access it.\n+```\n+\n+Dang. Here the destructor running was pretty fundamental to the API, and it had\n+to be scrapped in favour of a completely different design."}, {"sha": "41014f46dd953827374f55791adf5f7d0ed7b135", "filename": "src/doc/tarpl/lifetime-elision.md", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Flifetime-elision.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Flifetime-elision.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Flifetime-elision.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,64 @@\n+% Lifetime Elision\n+\n+In order to make common patterns more ergonomic, Rust allows lifetimes to be\n+*elided* in function signatures.\n+\n+A *lifetime position* is anywhere you can write a lifetime in a type:\n+\n+```rust,ignore\n+&'a T\n+&'a mut T\n+T<'a>\n+```\n+\n+Lifetime positions can appear as either \"input\" or \"output\":\n+\n+* For `fn` definitions, input refers to the types of the formal arguments\n+  in the `fn` definition, while output refers to\n+  result types. So `fn foo(s: &str) -> (&str, &str)` has elided one lifetime in\n+  input position and two lifetimes in output position.\n+  Note that the input positions of a `fn` method definition do not\n+  include the lifetimes that occur in the method's `impl` header\n+  (nor lifetimes that occur in the trait header, for a default method).\n+\n+* In the future, it should be possible to elide `impl` headers in the same manner.\n+\n+Elision rules are as follows:\n+\n+* Each elided lifetime in input position becomes a distinct lifetime\n+  parameter.\n+\n+* If there is exactly one input lifetime position (elided or not), that lifetime\n+  is assigned to *all* elided output lifetimes.\n+\n+* If there are multiple input lifetime positions, but one of them is `&self` or\n+  `&mut self`, the lifetime of `self` is assigned to *all* elided output lifetimes.\n+\n+* Otherwise, it is an error to elide an output lifetime.\n+\n+Examples:\n+\n+```rust,ignore\n+fn print(s: &str);                                      // elided\n+fn print<'a>(s: &'a str);                               // expanded\n+\n+fn debug(lvl: uint, s: &str);                           // elided\n+fn debug<'a>(lvl: uint, s: &'a str);                    // expanded\n+\n+fn substr(s: &str, until: uint) -> &str;                // elided\n+fn substr<'a>(s: &'a str, until: uint) -> &'a str;      // expanded\n+\n+fn get_str() -> &str;                                   // ILLEGAL\n+\n+fn frob(s: &str, t: &str) -> &str;                      // ILLEGAL\n+\n+fn get_mut(&mut self) -> &mut T;                        // elided\n+fn get_mut<'a>(&'a mut self) -> &'a mut T;              // expanded\n+\n+fn args<T:ToCStr>(&mut self, args: &[T]) -> &mut Command                  // elided\n+fn args<'a, 'b, T:ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command // expanded\n+\n+fn new(buf: &mut [u8]) -> BufWriter;                    // elided\n+fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a>          // expanded\n+\n+```"}, {"sha": "93ecb51c010db266b2c444ac93acb8ff13886399", "filename": "src/doc/tarpl/lifetime-mismatch.md", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Flifetime-mismatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Flifetime-mismatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Flifetime-mismatch.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,81 @@\n+% Limits of Lifetimes\n+\n+Given the following code:\n+\n+```rust,ignore\n+struct Foo;\n+\n+impl Foo {\n+    fn mutate_and_share(&mut self) -> &Self { &*self }\n+    fn share(&self) {}\n+}\n+\n+fn main() {\n+    let mut foo = Foo;\n+    let loan = foo.mutate_and_share();\n+    foo.share();\n+}\n+```\n+\n+One might expect it to compile. We call `mutate_and_share`, which mutably borrows\n+`foo` *temporarily*, but then returns *only* a shared reference. Therefore we\n+would expect `foo.share()` to succeed as `foo` shouldn't be mutably borrowed.\n+\n+However when we try to compile it:\n+\n+```text\n+<anon>:11:5: 11:8 error: cannot borrow `foo` as immutable because it is also borrowed as mutable\n+<anon>:11     foo.share();\n+              ^~~\n+<anon>:10:16: 10:19 note: previous borrow of `foo` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `foo` until the borrow ends\n+<anon>:10     let loan = foo.mutate_and_share();\n+                         ^~~\n+<anon>:12:2: 12:2 note: previous borrow ends here\n+<anon>:8 fn main() {\n+<anon>:9     let mut foo = Foo;\n+<anon>:10     let loan = foo.mutate_and_share();\n+<anon>:11     foo.share();\n+<anon>:12 }\n+          ^\n+```\n+\n+What happened? Well, we got the exact same reasoning as we did for\n+[Example 2 in the previous section][ex2]. We desugar the program and we get\n+the following:\n+\n+```rust,ignore\n+struct Foo;\n+\n+impl Foo {\n+    fn mutate_and_share<'a>(&'a mut self) -> &'a Self { &'a *self }\n+    fn share<'a>(&'a self) {}\n+}\n+\n+fn main() {\n+\t'b: {\n+    \tlet mut foo: Foo = Foo;\n+    \t'c: {\n+    \t\tlet loan: &'c Foo = Foo::mutate_and_share::<'c>(&'c mut foo);\n+    \t\t'd: {\n+    \t\t\tFoo::share::<'d>(&'d foo);\n+    \t\t}\n+    \t}\n+    }\n+}\n+```\n+\n+The lifetime system is forced to extend the `&mut foo` to have lifetime `'c`,\n+due to the lifetime of `loan` and mutate_and_share's signature. Then when we\n+try to call `share`, and it sees we're trying to alias that `&'c mut foo` and\n+blows up in our face!\n+\n+This program is clearly correct according to the reference semantics we *actually*\n+care about, but the lifetime system is too coarse-grained to handle that.\n+\n+\n+TODO: other common problems? SEME regions stuff, mostly?\n+\n+\n+\n+\n+[ex2]: lifetimes.html#example-2:-aliasing-a-mutable-reference\n\\ No newline at end of file"}, {"sha": "37d035733613941bc339b0352d6c0b20f8520f24", "filename": "src/doc/tarpl/lifetimes.md", "status": "added", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Flifetimes.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,215 @@\n+% Lifetimes\n+\n+Rust enforces these rules through *lifetimes*. Lifetimes are effectively\n+just names for scopes somewhere in the program. Each reference,\n+and anything that contains a reference, is tagged with a lifetime specifying\n+the scope it's valid for.\n+\n+Within a function body, Rust generally doesn't let you explicitly name the\n+lifetimes involved. This is because it's generally not really *necessary*\n+to talk about lifetimes in a local context; Rust has all the information and\n+can work out everything as optimally as possible. Many anonymous scopes and\n+temporaries that you would otherwise have to write are often introduced to\n+make your code *just work*.\n+\n+However once you cross the function boundary, you need to start talking about\n+lifetimes. Lifetimes are denoted with an apostrophe: `'a`, `'static`. To dip\n+our toes with lifetimes, we're going to pretend that we're actually allowed\n+to label scopes with lifetimes, and desugar the examples from the start of\n+this chapter.\n+\n+Originally, our examples made use of *aggressive* sugar -- high fructose corn\n+syrup even -- around scopes and lifetimes, because writing everything out\n+explicitly is *extremely noisy*. All Rust code relies on aggressive inference\n+and elision of \"obvious\" things.\n+\n+One particularly interesting piece of sugar is that each `let` statement implicitly\n+introduces a scope. For the most part, this doesn't really matter. However it\n+does matter for variables that refer to each other. As a simple example, let's\n+completely desugar this simple piece of Rust code:\n+\n+```rust\n+let x = 0;\n+let y = &x;\n+let z = &y;\n+```\n+\n+The borrow checker always tries to minimize the extent of a lifetime, so it will\n+likely desugar to the following:\n+\n+```rust,ignore\n+// NOTE: `'a: {` and `&'b x` is not valid syntax!\n+'a: {\n+    let x: i32 = 0;\n+    'b: {\n+        // lifetime used is 'b because that's *good enough*.\n+        let y: &'b i32 = &'b x;\n+        'c: {\n+            // ditto on 'c\n+            let z: &'c &'b i32 = &'c y;\n+        }\n+    }\n+}\n+```\n+\n+Wow. That's... awful. Let's all take a moment to thank Rust for being a\n+diabetes-inducing torrent of syrupy-goodness.\n+\n+Actually passing references to outer scopes will cause Rust to infer\n+a larger lifetime:\n+\n+```rust\n+let x = 0;\n+let z;\n+let y = &x;\n+z = y;\n+```\n+\n+```rust,ignore\n+'a: {\n+    let x: i32 = 0;\n+    'b: {\n+        let z: &'b i32;\n+        'c: {\n+            // Must use 'b here because this reference is\n+            // being passed to that scope.\n+            let y: &'b i32 = &'b x;\n+            z = y;\n+        }\n+    }\n+}\n+```\n+\n+\n+\n+# Example: references that outlive referents\n+\n+Alright, let's look at some of those examples from before:\n+\n+```rust,ignore\n+fn as_str(data: &u32) -> &str {\n+    let s = format!(\"{}\", data);\n+    &s\n+}\n+```\n+\n+desugars to:\n+\n+```rust,ignore\n+fn as_str<'a>(data: &'a u32) -> &'a str {\n+    'b: {\n+        let s = format!(\"{}\", data);\n+        return &'a s;\n+    }\n+}\n+```\n+\n+This signature of `as_str` takes a reference to a u32 with *some* lifetime, and\n+promises that it can produce a reference to a str that can live *just as long*.\n+Already we can see why this signature might be trouble. That basically implies\n+that we're going to *find* a str somewhere in the scope the scope the reference\n+to the u32 originated in, or somewhere *even* earlier. That's a *bit* of a big ask.\n+\n+We then proceed to compute the string `s`, and return a reference to it. Since\n+the contract of our function says the reference must outlive `'a`, that's the\n+lifetime we infer for the reference. Unfortunately, `s` was defined in the\n+scope `'b`, so the only way this is sound is if `'b` contains `'a` -- which is\n+clearly false since `'a` must contain the function call itself. We have therefore\n+created a reference whose lifetime outlives its referent, which is *literally*\n+the first thing we said that references can't do. The compiler rightfully blows\n+up in our face.\n+\n+To make this more clear, we can expand the example:\n+\n+```rust,ignore\n+fn as_str<'a>(data: &'a u32) -> &'a str {\n+    'b: {\n+        let s = format!(\"{}\", data);\n+        return &'a s\n+    }\n+}\n+\n+fn main() {\n+    'c: {\n+        let x: u32 = 0;\n+        'd: {\n+            // An anonymous scope is introduced because the borrow does not\n+            // need to last for the whole scope x is valid for. The return\n+            // of as_str must find a str somewhere *before* this function\n+            // call. Obviously not happening.\n+            println!(\"{}\", as_str::<'d>(&'d x));\n+        }\n+    }\n+}\n+```\n+\n+Shoot!\n+\n+Of course, the right way to write this function is as follows:\n+\n+```rust\n+fn to_string(data: &u32) -> String {\n+    format!(\"{}\", data)\n+}\n+```\n+\n+We must produce an owned value inside the function to return it! The only way\n+we could have returned an `&'a str` would have been if it was in a field of the\n+`&'a u32`, which is obviously not the case.\n+\n+(Actually we could have also just returned a string literal, which as a global\n+can be considered to reside at the bottom of the stack; though this limits\n+our implementation *just a bit*.)\n+\n+\n+\n+\n+\n+# Example: aliasing a mutable reference\n+\n+How about the other example:\n+\n+```rust,ignore\n+let mut data = vec![1, 2, 3];\n+let x = &data[0];\n+data.push(4);\n+println!(\"{}\", x);\n+```\n+\n+```rust,ignore\n+'a: {\n+    let mut data: Vec<i32> = vec![1, 2, 3];\n+    'b: {\n+        // 'b is as big as we need this borrow to be\n+        // (just need to get to `println!`)\n+        let x: &'b i32 = Index::index::<'b>(&'b data, 0);\n+        'c: {\n+            // Temporary scope because we don't need the\n+            // &mut to last any longer.\n+            Vec::push(&'c mut data, 4);\n+        }\n+        println!(\"{}\", x);\n+    }\n+}\n+```\n+\n+The problem here is is bit more subtle and interesting. We want Rust to\n+reject this program for the following reason: We have a live shared reference `x`\n+to a descendent of `data` when try to take a *mutable* reference to `data`\n+when we call `push`. This would create an aliased mutable reference, which would\n+violate the *second* rule of references.\n+\n+However this is *not at all* how Rust reasons that this program is bad. Rust\n+doesn't understand that `x` is a reference to a subpath of `data`. It doesn't\n+understand Vec at all. What it *does* see is that `x` has to live for `'b` to\n+be printed. The signature of `Index::index` subsequently demands that the\n+reference we take to *data* has to survive for `'b`. When we try to call `push`,\n+it then sees us try to make an `&'c mut data`. Rust knows that `'c` is contained\n+within `'b`, and rejects our program because the `&'b data` must still be live!\n+\n+Here we see that the lifetime system is *much* more coarse than the reference\n+semantics we're actually interested in preserving. For the most part, *that's\n+totally ok*, because it keeps us from spending all day explaining our program\n+to the compiler. However it does mean that several programs that are *totally*\n+correct with respect to Rust's *true* semantics are rejected because lifetimes\n+are too dumb."}, {"sha": "a5e3136c54acf10da82c47e24463c3178907c1ec", "filename": "src/doc/tarpl/meet-safe-and-unsafe.md", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fmeet-safe-and-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fmeet-safe-and-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fmeet-safe-and-unsafe.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,98 @@\n+% Meet Safe and Unsafe\n+\n+Programmers in safe \"high-level\" languages face a fundamental dilemma. On one\n+hand, it would be *really* great to just say what you want and not worry about\n+how it's done. On the other hand, that can lead to unacceptably poor\n+performance. It may be necessary to drop down to less clear or idiomatic\n+practices to get the performance characteristics you want. Or maybe you just\n+throw up your hands in disgust and decide to shell out to an implementation in\n+a less sugary-wonderful *unsafe* language.\n+\n+Worse, when you want to talk directly to the operating system, you *have* to\n+talk to an unsafe language: *C*. C is ever-present and unavoidable. It's the\n+lingua-franca of the programming world.\n+Even other safe languages generally expose C interfaces for the world at large!\n+Regardless of why you're doing it, as soon as your program starts talking to\n+C it stops being safe.\n+\n+With that said, Rust is *totally* a safe programming language.\n+\n+Well, Rust *has* a safe programming language. Let's step back a bit.\n+\n+Rust can be thought of as being composed of two programming languages: *Safe\n+Rust* and *Unsafe Rust*. Safe Rust is For Reals  Totally Safe. Unsafe Rust,\n+unsurprisingly, is *not* For Reals Totally Safe.  In fact, Unsafe Rust lets you\n+do some really crazy unsafe things.\n+\n+Safe Rust is the *true* Rust programming language. If all you do is write Safe\n+Rust, you will never have to worry about type-safety or memory-safety. You will\n+never endure a null or dangling pointer, or any of that Undefined Behaviour\n+nonsense.\n+\n+*That's totally awesome*.\n+\n+The standard library also gives you enough utilities out-of-the-box that you'll\n+be able to write awesome high-performance applications and libraries in pure\n+idiomatic Safe Rust.\n+\n+But maybe you want to talk to another language. Maybe you're writing a\n+low-level abstraction not exposed by the standard library. Maybe you're\n+*writing* the standard library (which is written entirely in Rust). Maybe you\n+need to do something the type-system doesn't understand and just *frob some dang\n+bits*. Maybe you need Unsafe Rust.\n+\n+Unsafe Rust is exactly like Safe Rust with *all* the same rules and semantics.\n+However Unsafe Rust lets you do some *extra* things that are Definitely Not Safe.\n+\n+The only things that are different in Unsafe Rust are that you can:\n+\n+* Dereference raw pointers\n+* Call `unsafe` functions (including C functions, intrinsics, and the raw allocator)\n+* Implement `unsafe` traits\n+* Mutate statics\n+\n+That's it. The reason these operations are relegated to Unsafe is that misusing\n+any of these things will cause the ever dreaded Undefined Behaviour. Invoking\n+Undefined Behaviour gives the compiler full rights to do arbitrarily bad things\n+to your program. You definitely *should not* invoke Undefined Behaviour.\n+\n+Unlike C, Undefined Behaviour is pretty limited in scope in Rust. All the core\n+language cares about is preventing the following things:\n+\n+* Dereferencing null or dangling pointers\n+* Reading [uninitialized memory][]\n+* Breaking the [pointer aliasing rules][]\n+* Producing invalid primitive values:\n+    * dangling/null references\n+    * a `bool` that isn't 0 or 1\n+    * an undefined `enum` discriminant\n+    * a `char` outside the ranges [0x0, 0xD7FF] and [0xE000, 0x10FFFF]\n+    * A non-utf8 `str`\n+* Unwinding into another language\n+* Causing a [data race][race]\n+\n+That's it. That's all the causes of Undefined Behaviour baked into Rust. Of\n+course, unsafe functions and traits are free to declare arbitrary other\n+constraints that a program must maintain to avoid Undefined Behaviour. However,\n+generally violations of these constraints will just transitively lead to one of\n+the above problems. Some additional constraints may also derive from compiler\n+intrinsics that make special assumptions about how code can be optimized.\n+\n+Rust is otherwise quite permissive with respect to other dubious operations.\n+Rust considers it \"safe\" to:\n+\n+* Deadlock\n+* Have a [race condition][race]\n+* Leak memory\n+* Fail to call destructors\n+* Overflow integers\n+* Abort the program\n+* Delete the production database\n+\n+However any program that actually manages to do such a thing is *probably*\n+incorrect. Rust provides lots of tools to make these things rare, but\n+these problems are considered impractical to categorically prevent.\n+\n+[pointer aliasing rules]: references.html\n+[uninitialized memory]: uninitialized.html\n+[race]: races.html"}, {"sha": "2c495240c1278859aaaae31fdfb1e86e3e9b760d", "filename": "src/doc/tarpl/obrm.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fobrm.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fobrm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fobrm.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,14 @@\n+% The Perils Of Ownership Based Resource Management (OBRM)\n+\n+OBRM (AKA RAII: Resource Acquisition Is Initialization) is something you'll\n+interact with a lot in Rust. Especially if you use the standard library.\n+\n+Roughly speaking the pattern is as follows: to acquire a resource, you create an\n+object that manages it. To release the resource, you simply destroy the object,\n+and it cleans up the resource for you. The most common \"resource\" this pattern\n+manages is simply *memory*. `Box`, `Rc`, and basically everything in\n+`std::collections` is a convenience to enable correctly managing memory. This is\n+particularly important in Rust because we have no pervasive GC to rely on for\n+memory management. Which is the point, really: Rust is about control. However we\n+are not limited to just memory. Pretty much every other system resource like a\n+thread, file, or socket is exposed through this kind of API."}, {"sha": "93ef2c13cdf8c5de5b2ad459b9aa0cfc9313b786", "filename": "src/doc/tarpl/other-reprs.md", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fother-reprs.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fother-reprs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fother-reprs.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,76 @@\n+% Alternative representations\n+\n+Rust allows you to specify alternative data layout strategies from the default.\n+\n+\n+\n+\n+# repr(C)\n+\n+This is the most important `repr`. It has fairly simple intent: do what C does.\n+The order, size, and alignment of fields is exactly what you would expect from C\n+or C++. Any type you expect to pass through an FFI boundary should have\n+`repr(C)`, as C is the lingua-franca of the programming world. This is also\n+necessary to soundly do more elaborate tricks with data layout such as\n+reinterpreting values as a different type.\n+\n+However, the interaction with Rust's more exotic data layout features must be\n+kept in mind. Due to its dual purpose as \"for FFI\" and \"for layout control\",\n+`repr(C)` can be applied to types that will be nonsensical or problematic if\n+passed through the FFI boundary.\n+\n+* ZSTs are still zero-sized, even though this is not a standard behaviour in\n+C, and is explicitly contrary to the behaviour of an empty type in C++, which\n+still consumes a byte of space.\n+\n+* DSTs, tuples, and tagged unions are not a concept in C and as such are never\n+FFI safe.\n+\n+* **If the type would have any [drop flags][], they will still be added**\n+\n+* This is equivalent to one of `repr(u*)` (see the next section) for enums. The\n+chosen size is the default enum size for the target platform's C ABI. Note that\n+enum representation in C is implementation defined, so this is really a \"best\n+guess\". In particular, this may be incorrect when the C code of interest is\n+compiled with certain flags.\n+\n+\n+\n+# repr(u8), repr(u16), repr(u32), repr(u64)\n+\n+These specify the size to make a C-like enum. If the discriminant overflows the\n+integer it has to fit in, it will produce a compile-time error. You can manually\n+ask Rust to allow this by setting the overflowing element to explicitly be 0.\n+However Rust will not allow you to create an enum where two variants have the\n+same discriminant.\n+\n+On non-C-like enums, this will inhibit certain optimizations like the null-\n+pointer optimization.\n+\n+These reprs have no effect on a struct.\n+\n+\n+\n+\n+# repr(packed)\n+\n+`repr(packed)` forces rust to strip any padding, and only align the type to a\n+byte. This may improve the memory footprint, but will likely have other negative\n+side-effects.\n+\n+In particular, most architectures *strongly* prefer values to be aligned. This\n+may mean the unaligned loads are penalized (x86), or even fault (some ARM\n+chips). For simple cases like directly loading or storing a packed field, the\n+compiler might be able to paper over alignment issues with shifts and masks.\n+However if you take a reference to a packed field, it's unlikely that the\n+compiler will be able to emit code to avoid an unaligned load.\n+\n+**[As of Rust 1.0 this can cause undefined behaviour.][ub loads]**\n+\n+`repr(packed)` is not to be used lightly. Unless you have extreme requirements,\n+this should not be used.\n+\n+This repr is a modifier on `repr(C)` and `repr(rust)`.\n+\n+[drop flags]: drop-flags.html\n+[ub loads]: https://github.com/rust-lang/rust/issues/27060"}, {"sha": "f79cd92479f0b1e61800d4cb2c8cb28c1c451afb", "filename": "src/doc/tarpl/ownership.md", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fownership.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,67 @@\n+% Ownership and Lifetimes\n+\n+Ownership is the breakout feature of Rust. It allows Rust to be completely\n+memory-safe and efficient, while avoiding garbage collection. Before getting\n+into the ownership system in detail, we will consider the motivation of this\n+design.\n+\n+We will assume that you accept that garbage collection (GC) is not always an\n+optimal solution, and that it is desirable to manually manage memory in some\n+contexts. If you do not accept this, might I interest you in a different\n+language?\n+\n+Regardless of your feelings on GC, it is pretty clearly a *massive* boon to\n+making code safe. You never have to worry about things going away *too soon*\n+(although whether you still *wanted* to be pointing at that thing is a different\n+issue...). This is a pervasive problem that C and C++ programs need to deal\n+with. Consider this simple mistake that all of us who have used a non-GC'd\n+language have made at one point:\n+\n+```rust,ignore\n+fn as_str(data: &u32) -> &str {\n+    // compute the string\n+    let s = format!(\"{}\", data);\n+\n+    // OH NO! We returned a reference to something that\n+    // exists only in this function!\n+    // Dangling pointer! Use after free! Alas!\n+    // (this does not compile in Rust)\n+    &s\n+}\n+```\n+\n+This is exactly what Rust's ownership system was built to solve.\n+Rust knows the scope in which the `&s` lives, and as such can prevent it from\n+escaping. However this is a simple case that even a C compiler could plausibly\n+catch. Things get more complicated as code gets bigger and pointers get fed through\n+various functions. Eventually, a C compiler will fall down and won't be able to\n+perform sufficient escape analysis to prove your code unsound. It will consequently\n+be forced to accept your program on the assumption that it is correct.\n+\n+This will never happen to Rust. It's up to the programmer to prove to the\n+compiler that everything is sound.\n+\n+Of course, Rust's story around ownership is much more complicated than just\n+verifying that references don't escape the scope of their referent. That's\n+because ensuring pointers are always valid is much more complicated than this.\n+For instance in this code,\n+\n+```rust,ignore\n+let mut data = vec![1, 2, 3];\n+// get an internal reference\n+let x = &data[0];\n+\n+// OH NO! `push` causes the backing storage of `data` to be reallocated.\n+// Dangling pointer! User after free! Alas!\n+// (this does not compile in Rust)\n+data.push(4);\n+\n+println!(\"{}\", x);\n+```\n+\n+naive scope analysis would be insufficient to prevent this bug, because `data`\n+does in fact live as long as we needed. However it was *changed* while we had\n+a reference into it. This is why Rust requires any references to freeze the\n+referent and its owners.\n+\n+"}, {"sha": "034f31784295df76ba3fdc05b2e9bd40cee91fe3", "filename": "src/doc/tarpl/phantom-data.md", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fphantom-data.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fphantom-data.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fphantom-data.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,87 @@\n+% PhantomData\n+\n+When working with unsafe code, we can often end up in a situation where\n+types or lifetimes are logically associated with a struct, but not actually\n+part of a field. This most commonly occurs with lifetimes. For instance, the\n+`Iter` for `&'a [T]` is (approximately) defined as follows:\n+\n+```rust,ignore\n+struct Iter<'a, T: 'a> {\n+    ptr: *const T,\n+    end: *const T,\n+}\n+```\n+\n+However because `'a` is unused within the struct's body, it's *unbounded*.\n+Because of the troubles this has historically caused, unbounded lifetimes and\n+types are *illegal* in struct definitions. Therefore we must somehow refer\n+to these types in the body. Correctly doing this is necessary to have\n+correct variance and drop checking.\n+\n+We do this using *PhantomData*, which is a special marker type. PhantomData\n+consumes no space, but simulates a field of the given type for the purpose of\n+static analysis. This was deemed to be less error-prone than explicitly telling\n+the type-system the kind of variance that you want, while also providing other\n+useful such as the information needed by drop check.\n+\n+Iter logically contains a bunch of `&'a T`s, so this is exactly what we tell\n+the PhantomData to simulate:\n+\n+```\n+use std::marker;\n+\n+struct Iter<'a, T: 'a> {\n+    ptr: *const T,\n+    end: *const T,\n+    _marker: marker::PhantomData<&'a T>,\n+}\n+```\n+\n+and that's it. The lifetime will be bounded, and your iterator will be variant\n+over `'a` and `T`. Everything Just Works.\n+\n+Another important example is Vec, which is (approximately) defined as follows:\n+\n+```\n+struct Vec<T> {\n+    data: *const T, // *const for variance!\n+    len: usize,\n+    cap: usize,\n+}\n+```\n+\n+Unlike the previous example it *appears* that everything is exactly as we\n+want. Every generic argument to Vec shows up in the at least one field.\n+Good to go!\n+\n+Nope.\n+\n+The drop checker will generously determine that Vec<T> does not own any values\n+of type T. This will in turn make it conclude that it does *not* need to worry\n+about Vec dropping any T's in its destructor for determining drop check\n+soundness. This will in turn allow people to create unsoundness using\n+Vec's destructor.\n+\n+In order to tell dropck that we *do* own values of type T, and therefore may\n+drop some T's when *we* drop, we must add an extra PhantomData saying exactly\n+that:\n+\n+```\n+use std::marker;\n+\n+struct Vec<T> {\n+    data: *const T, // *const for covariance!\n+    len: usize,\n+    cap: usize,\n+    _marker: marker::PhantomData<T>,\n+}\n+```\n+\n+Raw pointers that own an allocation is such a pervasive pattern that the\n+standard library made a utility for itself called `Unique<T>` which:\n+\n+* wraps a `*const T` for variance\n+* includes a `PhantomData<T>`,\n+* auto-derives Send/Sync as if T was contained\n+* marks the pointer as NonZero for the null-pointer optimization\n+"}, {"sha": "6fb16f28e343501828e78067a21859bc1d83edee", "filename": "src/doc/tarpl/poisoning.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fpoisoning.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fpoisoning.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fpoisoning.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,35 @@\n+% Poisoning\n+\n+Although all unsafe code *must* ensure it has minimal exception safety, not all\n+types ensure *maximal* exception safety. Even if the type does, your code may\n+ascribe additional meaning to it. For instance, an integer is certainly\n+exception-safe, but has no semantics on its own. It's possible that code that\n+panics could fail to correctly update the integer, producing an inconsistent\n+program state.\n+\n+This is *usually* fine, because anything that witnesses an exception is about\n+to get destroyed. For instance, if you send a Vec to another thread and that\n+thread panics, it doesn't matter if the Vec is in a weird state. It will be\n+dropped and go away forever. However some types are especially good at smuggling\n+values across the panic boundary.\n+\n+These types may choose to explicitly *poison* themselves if they witness a panic.\n+Poisoning doesn't entail anything in particular. Generally it just means\n+preventing normal usage from proceeding. The most notable example of this is the\n+standard library's Mutex type. A Mutex will poison itself if one of its\n+MutexGuards (the thing it returns when a lock is obtained) is dropped during a\n+panic. Any future attempts to lock the Mutex will return an `Err` or panic.\n+\n+Mutex poisons not for *true* safety in the sense that Rust normally cares about. It\n+poisons as a safety-guard against blindly using the data that comes out of a Mutex\n+that has witnessed a panic while locked. The data in such a Mutex was likely in the\n+middle of being modified, and as such may be in an inconsistent or incomplete state.\n+It is important to note that one cannot violate memory safety with such a type\n+if it is correctly written. After all, it must be minimally exception-safe!\n+\n+However if the Mutex contained, say, a BinaryHeap that does not actually have the\n+heap property, it's unlikely that any code that uses it will do\n+what the author intended. As such, the program should not proceed normally.\n+Still, if you're double-plus-sure that you can do *something* with the value,\n+the Mutex exposes a method to get the lock anyway. It *is* safe, after all.\n+Just maybe nonsense."}, {"sha": "240e4aca7f6b6a6df9fb7220d912905535709bfc", "filename": "src/doc/tarpl/races.md", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fraces.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fraces.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fraces.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,66 @@\n+% Data Races and Race Conditions\n+\n+Safe Rust guarantees an absence of data races, which are defined as:\n+\n+* two or more threads concurrently accessing a location of memory\n+* one of them is a write\n+* one of them is unsynchronized\n+\n+A data race has Undefined Behaviour, and is therefore impossible to perform\n+in Safe Rust. Data races are *mostly* prevented through rust's ownership system:\n+it's impossible to alias a mutable reference, so it's impossible to perform a\n+data race. Interior mutability makes this more complicated, which is largely why\n+we have the Send and Sync traits (see below).\n+\n+However Rust *does not* prevent general race conditions. This is\n+pretty fundamentally impossible, and probably honestly undesirable. Your hardware\n+is racy, your OS is racy, the other programs on your computer are racy, and the\n+world this all runs in is racy. Any system that could genuinely claim to prevent\n+*all* race conditions would be pretty awful to use, if not just incorrect.\n+\n+So it's perfectly \"fine\" for a Safe Rust program to get deadlocked or do\n+something incredibly stupid with incorrect synchronization. Obviously such a\n+program isn't very good, but Rust can only hold your hand so far. Still, a\n+race condition can't violate memory safety in a Rust program on\n+its own. Only in conjunction with some other unsafe code can a race condition\n+actually violate memory safety. For instance:\n+\n+```rust\n+use std::thread;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::sync::Arc;\n+\n+let data = vec![1, 2, 3, 4];\n+// Arc so that the memory the AtomicUsize is stored in still exists for\n+// the other thread to increment, even if we completely finish executing\n+// before it. Rust won't compile the program without it, because of the\n+// lifetime requirements of thread::spawn!\n+let idx = Arc::new(AtomicUsize::new(0));\n+let other_idx = idx.clone();\n+\n+// `move` captures other_idx by-value, moving it into this thread\n+thread::spawn(move || {\n+    // It's ok to mutate idx because this value\n+    // is an atomic, so it can't cause a Data Race.\n+    other_idx.fetch_add(10, Ordering::SeqCst);\n+});\n+\n+// Index with the value loaded from the atomic. This is safe because we\n+// read the atomic memory only once, and then pass a *copy* of that value\n+// to the Vec's indexing implementation. This indexing will be correctly\n+// bounds checked, and there's no chance of the value getting changed\n+// in the middle. However our program may panic if the thread we spawned\n+// managed to increment before this ran. A race condition because correct\n+// program execution (panicing is rarely correct) depends on order of\n+// thread execution.\n+println!(\"{}\", data[idx.load(Ordering::SeqCst)]);\n+\n+if idx.load(Ordering::SeqCst) < data.len() {\n+    unsafe {\n+        // Incorrectly loading the idx *after* we did the bounds check.\n+        // It could have changed. This is a race condition, *and dangerous*\n+        // because we decided to do `get_unchecked`, which is `unsafe`.\n+        println!(\"{}\", data.get_unchecked(idx.load(Ordering::SeqCst)));\n+    }\n+}\n+```"}, {"sha": "3d7369eca0fed3e31c4eaba18fd5436d94932718", "filename": "src/doc/tarpl/references.md", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Freferences.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Freferences.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Freferences.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,177 @@\n+% References\n+\n+This section gives a high-level view of the memory model that *all* Rust\n+programs must satisfy to be correct. Safe code is statically verified\n+to obey this model by the borrow checker. Unsafe code may go above\n+and beyond the borrow checker while still satisfying this model. The borrow\n+checker may also be extended to allow more programs to compile, as long as\n+this more fundamental model is satisfied.\n+\n+There are two kinds of reference:\n+\n+* Shared reference: `&`\n+* Mutable reference: `&mut`\n+\n+Which obey the following rules:\n+\n+* A reference cannot outlive its referent\n+* A mutable reference cannot be aliased\n+\n+That's it. That's the whole model. Of course, we should probably define\n+what *aliased* means. To define aliasing, we must define the notion of\n+*paths* and *liveness*.\n+\n+\n+**NOTE: The model that follows is generally agreed to be dubious and have\n+issues. It's ok-ish as an intuitive model, but fails to capture the desired\n+semantics. We leave this here to be able to use notions introduced here in later\n+sections. This will be significantly changed in the future. TODO: do that.**\n+\n+\n+# Paths\n+\n+If all Rust had were values (no pointers), then every value would be uniquely\n+owned by a variable or composite structure. From this we naturally derive a\n+*tree* of ownership. The stack itself is the root of the tree, with every\n+variable as its direct children. Each variable's direct children would be their\n+fields (if any), and so on.\n+\n+From this view, every value in Rust has a unique *path* in the tree of\n+ownership. Of particular interest are *ancestors* and *descendants*: if `x` owns\n+`y`, then `x` is an ancestor of `y`, and `y` is a descendant of `x`. Note\n+that this is an inclusive relationship: `x` is a descendant and ancestor of\n+itself.\n+\n+We can then define references as simply *names* for paths. When you create a\n+reference, you're declaring that an ownership path exists to this address\n+of memory.\n+\n+Tragically, plenty of data doesn't reside on the stack, and we must also\n+accommodate this. Globals and thread-locals are simple enough to model as\n+residing at the bottom of the stack (though we must be careful with mutable\n+globals). Data on the heap poses a different problem.\n+\n+If all Rust had on the heap was data uniquely owned by a pointer on the stack,\n+then we could just treat such a pointer as a struct that owns the value on the\n+heap. Box, Vec, String, and HashMap, are examples of types which uniquely\n+own data on the heap.\n+\n+Unfortunately, data on the heap is not *always* uniquely owned. Rc for instance\n+introduces a notion of *shared* ownership. Shared ownership of a value means\n+there is no unique path to it. A value with no unique path limits what we can do\n+with it.\n+\n+In general, only shared references can be created to non-unique paths. However\n+mechanisms which ensure mutual exclusion may establish One True Owner\n+temporarily, establishing a unique path to that value (and therefore all\n+its children). If this is done, the value may be mutated. In particular, a\n+mutable reference can be taken.\n+\n+The most common way to establish such a path is through *interior mutability*,\n+in contrast to the *inherited mutability* that everything in Rust normally uses.\n+Cell, RefCell, Mutex, and RWLock are all examples of interior mutability types.\n+These types provide exclusive access through runtime restrictions.\n+\n+An interesting case of this effect is Rc itself: if an Rc has refcount 1,\n+then it is safe to mutate or even move its internals. Note however that the\n+refcount itself uses interior mutability.\n+\n+In order to correctly communicate to the type system that a variable or field of\n+a struct can have interior mutability, it must be wrapped in an UnsafeCell. This\n+does not in itself make it safe to perform interior mutability operations on\n+that value. You still must yourself ensure that mutual exclusion is upheld.\n+\n+\n+\n+\n+# Liveness\n+\n+Note: Liveness is not the same thing as a *lifetime*, which will be explained\n+in detail in the next section of this chapter.\n+\n+Roughly, a reference is *live* at some point in a program if it can be\n+dereferenced. Shared references are always live unless they are literally\n+unreachable (for instance, they reside in freed or leaked memory). Mutable\n+references can be reachable but *not* live through the process of *reborrowing*.\n+\n+A mutable reference can be reborrowed to either a shared or mutable reference to\n+one of its descendants. A reborrowed reference will only be live again once all\n+reborrows derived from it expire. For instance, a mutable reference can be\n+reborrowed to point to a field of its referent:\n+\n+```rust\n+let x = &mut (1, 2);\n+{\n+    // reborrow x to a subfield\n+    let y = &mut x.0;\n+    // y is now live, but x isn't\n+    *y = 3;\n+}\n+// y goes out of scope, so x is live again\n+*x = (5, 7);\n+```\n+\n+It is also possible to reborrow into *multiple* mutable references, as long as\n+they are *disjoint*: no reference is an ancestor of another. Rust\n+explicitly enables this to be done with disjoint struct fields, because\n+disjointness can be statically proven:\n+\n+```rust\n+let x = &mut (1, 2);\n+{\n+    // reborrow x to two disjoint subfields\n+    let y = &mut x.0;\n+    let z = &mut x.1;\n+\n+    // y and z are now live, but x isn't\n+    *y = 3;\n+    *z = 4;\n+}\n+// y and z go out of scope, so x is live again\n+*x = (5, 7);\n+```\n+\n+However it's often the case that Rust isn't sufficiently smart to prove that\n+multiple borrows are disjoint. *This does not mean it is fundamentally illegal\n+to make such a borrow*, just that Rust isn't as smart as you want.\n+\n+To simplify things, we can model variables as a fake type of reference: *owned*\n+references. Owned references have much the same semantics as mutable references:\n+they can be re-borrowed in a mutable or shared manner, which makes them no\n+longer live. Live owned references have the unique property that they can be\n+moved out of (though mutable references *can* be swapped out of). This power is\n+only given to *live* owned references because moving its referent would of\n+course invalidate all outstanding references prematurely.\n+\n+As a local lint against inappropriate mutation, only variables that are marked\n+as `mut` can be borrowed mutably.\n+\n+It is interesting to note that Box behaves exactly like an owned reference. It\n+can be moved out of, and Rust understands it sufficiently to reason about its\n+paths like a normal variable.\n+\n+\n+\n+\n+# Aliasing\n+\n+With liveness and paths defined, we can now properly define *aliasing*:\n+\n+**A mutable reference is aliased if there exists another live reference to one\n+of its ancestors or descendants.**\n+\n+(If you prefer, you may also say the two live references alias *each other*.\n+This has no semantic consequences, but is probably a more useful notion when\n+verifying the soundness of a construct.)\n+\n+That's it. Super simple right? Except for the fact that it took us two pages to\n+define all of the terms in that definition. You know: Super. Simple.\n+\n+Actually it's a bit more complicated than that. In addition to references, Rust\n+has *raw pointers*: `*const T` and `*mut T`. Raw pointers have no inherent\n+ownership or aliasing semantics. As a result, Rust makes absolutely no effort to\n+track that they are used correctly, and they are wildly unsafe.\n+\n+**It is an open question to what degree raw pointers have alias semantics.\n+However it is important for these definitions to be sound that the existence of\n+a raw pointer does not imply some kind of live path.**"}, {"sha": "639d64adc18b8dae273e9960cbe67606c9f5bf6b", "filename": "src/doc/tarpl/repr-rust.md", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Frepr-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Frepr-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Frepr-rust.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,152 @@\n+% repr(Rust)\n+\n+First and foremost, all types have an alignment specified in bytes. The\n+alignment of a type specifies what addresses are valid to store the value at. A\n+value of alignment `n` must only be stored at an address that is a multiple of\n+`n`. So alignment 2 means you must be stored at an even address, and 1 means\n+that you can be stored anywhere. Alignment is at least 1, and always a power of\n+2. Most primitives are generally aligned to their size, although this is\n+platform-specific behaviour. In particular, on x86 `u64` and `f64` may be only\n+aligned to 32 bits.\n+\n+A type's size must always be a multiple of its alignment. This ensures that an\n+array of that type may always be indexed by offsetting by a multiple of its\n+size. Note that the size and alignment of a type may not be known\n+statically in the case of [dynamically sized types][dst].\n+\n+Rust gives you the following ways to lay out composite data:\n+\n+* structs (named product types)\n+* tuples (anonymous product types)\n+* arrays (homogeneous product types)\n+* enums (named sum types -- tagged unions)\n+\n+An enum is said to be *C-like* if none of its variants have associated data.\n+\n+Composite structures will have an alignment equal to the maximum\n+of their fields' alignment. Rust will consequently insert padding where\n+necessary to ensure that all fields are properly aligned and that the overall\n+type's size is a multiple of its alignment. For instance:\n+\n+```rust\n+struct A {\n+    a: u8,\n+    c: u32,\n+    b: u16,\n+}\n+```\n+\n+will be 32-bit aligned assuming these primitives are aligned to their size.\n+It will therefore have a size that is a multiple of 32-bits. It will potentially\n+*really* become:\n+\n+```rust\n+struct A {\n+    a: u8,\n+    _pad1: [u8; 3], // to align `b`\n+    b: u32,\n+    c: u16,\n+    _pad2: [u8; 2], // to make overall size multiple of 4\n+}\n+```\n+\n+There is *no indirection* for these types; all data is stored contiguously as\n+you would expect in C. However with the exception of arrays (which are densely\n+packed and in-order), the layout of data is not by default specified in Rust.\n+Given the two following struct definitions:\n+\n+```rust\n+struct A {\n+    a: i32,\n+    b: u64,\n+}\n+\n+struct B {\n+    x: i32,\n+    b: u64,\n+}\n+```\n+\n+Rust *does* guarantee that two instances of A have their data laid out in\n+exactly the same way. However Rust *does not* guarantee that an instance of A\n+has the same field ordering or padding as an instance of B (in practice there's\n+no *particular* reason why they wouldn't, other than that its not currently\n+guaranteed).\n+\n+With A and B as written, this is basically nonsensical, but several other\n+features of Rust make it desirable for the language to play with data layout in\n+complex ways.\n+\n+For instance, consider this struct:\n+\n+```rust\n+struct Foo<T, U> {\n+    count: u16,\n+    data1: T,\n+    data2: U,\n+}\n+```\n+\n+Now consider the monomorphizations of `Foo<u32, u16>` and `Foo<u16, u32>`. If\n+Rust lays out the fields in the order specified, we expect it to *pad* the\n+values in the struct to satisfy their *alignment* requirements. So if Rust\n+didn't reorder fields, we would expect Rust to produce the following:\n+\n+```rust,ignore\n+struct Foo<u16, u32> {\n+    count: u16,\n+    data1: u16,\n+    data2: u32,\n+}\n+\n+struct Foo<u32, u16> {\n+    count: u16,\n+    _pad1: u16,\n+    data1: u32,\n+    data2: u16,\n+    _pad2: u16,\n+}\n+```\n+\n+The latter case quite simply wastes space. An optimal use of space therefore\n+requires different monomorphizations to have *different field orderings*.\n+\n+**Note: this is a hypothetical optimization that is not yet implemented in Rust\n+**1.0\n+\n+Enums make this consideration even more complicated. Naively, an enum such as:\n+\n+```rust\n+enum Foo {\n+    A(u32),\n+    B(u64),\n+    C(u8),\n+}\n+```\n+\n+would be laid out as:\n+\n+```rust\n+struct FooRepr {\n+    data: u64, // this is *really* either a u64, u32, or u8 based on `tag`\n+    tag: u8, // 0 = A, 1 = B, 2 = C\n+}\n+```\n+\n+And indeed this is approximately how it would be laid out in general\n+(modulo the size and position of `tag`). However there are several cases where\n+such a representation is inefficient. The classic case of this is Rust's\n+\"null pointer optimization\". Given a pointer that is known to not be null\n+(e.g. `&u32`), an enum can *store* a discriminant bit *inside* the pointer\n+by using null as a special value. The net result is that\n+`size_of::<Option<&T>>() == size_of::<&T>()`\n+\n+There are many types in Rust that are, or contain, \"not null\" pointers such as\n+`Box<T>`, `Vec<T>`, `String`, `&T`, and `&mut T`. Similarly, one can imagine\n+nested enums pooling their tags into a single discriminant, as they are by\n+definition known to have a limited range of valid values. In principle enums can\n+use fairly elaborate algorithms to cache bits throughout nested types with\n+special constrained representations. As such it is *especially* desirable that\n+we leave enum layout unspecified today.\n+\n+[dst]: exotic-sizes.html#dynamically-sized-types-(dsts)"}, {"sha": "909308397d717bff7ff172c7d3aa5d477fdc3e2c", "filename": "src/doc/tarpl/safe-unsafe-meaning.md", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fsafe-unsafe-meaning.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fsafe-unsafe-meaning.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fsafe-unsafe-meaning.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,150 @@\n+% How Safe and Unsafe Interact\n+\n+So what's the relationship between Safe and Unsafe Rust? How do they interact?\n+\n+Rust models the separation between Safe and Unsafe Rust with the `unsafe`\n+keyword, which can be thought as a sort of *foreign function interface* (FFI)\n+between Safe and Unsafe Rust. This is the magic behind why we can say Safe Rust\n+is a safe language: all the scary unsafe bits are relegated *exclusively* to FFI\n+*just like every other safe language*.\n+\n+However because one language is a subset of the other, the two can be cleanly\n+intermixed as long as the boundary between Safe and Unsafe Rust is denoted with\n+the `unsafe` keyword. No need to write headers, initialize runtimes, or any of\n+that other FFI boiler-plate.\n+\n+There are several places `unsafe` can appear in Rust today, which can largely be\n+grouped into two categories:\n+\n+* There are unchecked contracts here. To declare you understand this, I require\n+you to write `unsafe` elsewhere:\n+    * On functions, `unsafe` is declaring the function to be unsafe to call.\n+      Users of the function must check the documentation to determine what this\n+      means, and then have to write `unsafe` somewhere to identify that they're\n+      aware of the danger.\n+    * On trait declarations, `unsafe` is declaring that *implementing* the trait\n+      is an unsafe operation, as it has contracts that other unsafe code is free\n+      to trust blindly. (More on this below.)\n+\n+* I am declaring that I have, to the best of my knowledge, adhered to the\n+unchecked contracts:\n+    * On trait implementations, `unsafe` is declaring that the contract of the\n+      `unsafe` trait has been upheld.\n+    * On blocks, `unsafe` is declaring any unsafety from an unsafe\n+      operation within to be handled, and therefore the parent function is safe.\n+\n+There is also `#[unsafe_no_drop_flag]`, which is a special case that exists for\n+historical reasons and is in the process of being phased out. See the section on\n+[drop flags][] for details.\n+\n+Some examples of unsafe functions:\n+\n+* `slice::get_unchecked` will perform unchecked indexing, allowing memory\n+  safety to be freely violated.\n+* `ptr::offset` is an intrinsic that invokes Undefined Behaviour if it is\n+  not \"in bounds\" as defined by LLVM.\n+* `mem::transmute` reinterprets some value as having the given type,\n+  bypassing type safety in arbitrary ways. (see [conversions][] for details)\n+* All FFI functions are `unsafe` because they can do arbitrary things.\n+  C being an obvious culprit, but generally any language can do something\n+  that Rust isn't happy about.\n+\n+As of Rust 1.0 there are exactly two unsafe traits:\n+\n+* `Send` is a marker trait (it has no actual API) that promises implementors\n+  are safe to send (move) to another thread.\n+* `Sync` is a marker trait that promises that threads can safely share\n+  implementors through a shared reference.\n+\n+The need for unsafe traits boils down to the fundamental property of safe code:\n+\n+**No matter how completely awful Safe code is, it can't cause Undefined\n+Behaviour.**\n+\n+This means that Unsafe, **the royal vanguard of Undefined Behaviour**, has to be\n+*super paranoid* about generic safe code. Unsafe is free to trust *specific* safe\n+code (or else you would degenerate into infinite spirals of paranoid despair).\n+It is generally regarded as ok to trust the standard library to be correct, as\n+`std` is effectively an extension of the language (and you *really* just have\n+to trust the language). If `std` fails to uphold the guarantees it declares,\n+then it's basically a language bug.\n+\n+That said, it would be best to minimize *needlessly* relying on properties of\n+concrete safe code. Bugs happen! Of course, I must reinforce that this is only\n+a concern for Unsafe code. Safe code can blindly trust anyone and everyone\n+as far as basic memory-safety is concerned.\n+\n+On the other hand, safe traits are free to declare arbitrary contracts, but because\n+implementing them is Safe, Unsafe can't trust those contracts to actually\n+be upheld. This is different from the concrete case because *anyone* can\n+randomly implement the interface. There is something fundamentally different\n+about trusting a *particular* piece of code to be correct, and trusting *all the\n+code that will ever be written* to be correct.\n+\n+For instance Rust has `PartialOrd` and `Ord` traits to try to differentiate\n+between types which can \"just\" be compared, and those that actually implement a\n+*total* ordering. Pretty much every API that wants to work with data that can be\n+compared *really* wants Ord data. For instance, a sorted map like BTreeMap\n+*doesn't even make sense* for partially ordered types. If you claim to implement\n+Ord for a type, but don't actually provide a proper total ordering, BTreeMap will\n+get *really confused* and start making a total mess of itself. Data that is\n+inserted may be impossible to find!\n+\n+But that's okay. BTreeMap is safe, so it guarantees that even if you give it a\n+*completely* garbage Ord implementation, it will still do something *safe*. You\n+won't start reading uninitialized memory or unallocated memory. In fact, BTreeMap\n+manages to not actually lose any of your data. When the map is dropped, all the\n+destructors will be successfully called! Hooray!\n+\n+However BTreeMap is implemented using a modest spoonful of Unsafe (most collections\n+are). That means that it is not necessarily *trivially true* that a bad Ord\n+implementation will make BTreeMap behave safely. Unsafe must be sure not to rely\n+on Ord *where safety is at stake*. Ord is provided by Safe, and safety is not\n+Safe's responsibility to uphold.\n+\n+But wouldn't it be grand if there was some way for Unsafe to trust *some* trait\n+contracts *somewhere*? This is the problem that unsafe traits tackle: by marking\n+*the trait itself* as unsafe *to implement*, Unsafe can trust the implementation\n+to uphold the trait's contract. Although the trait implementation may be\n+incorrect in arbitrary other ways.\n+\n+For instance, given a hypothetical UnsafeOrd trait, this is technically a valid\n+implementation:\n+\n+```rust\n+# use std::cmp::Ordering;\n+# struct MyType;\n+# unsafe trait UnsafeOrd { fn cmp(&self, other: &Self) -> Ordering; }\n+unsafe impl UnsafeOrd for MyType {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        Ordering::Equal\n+    }\n+}\n+```\n+\n+But it's probably not the implementation you want.\n+\n+Rust has traditionally avoided making traits unsafe because it makes Unsafe\n+pervasive, which is not desirable. Send and Sync are unsafe is because thread\n+safety is a *fundamental property* that Unsafe cannot possibly hope to defend\n+against in the same way it would defend against a bad Ord implementation. The\n+only way to possibly defend against thread-unsafety would be to *not use\n+threading at all*. Making every load and store atomic isn't even sufficient,\n+because it's possible for complex invariants to exist between disjoint locations\n+in memory. For instance, the pointer and capacity of a Vec must be in sync.\n+\n+Even concurrent paradigms that are traditionally regarded as Totally Safe like\n+message passing implicitly rely on some notion of thread safety -- are you\n+really message-passing if you pass a *pointer*? Send and Sync therefore require\n+some *fundamental* level of trust that Safe code can't provide, so they must be\n+unsafe to implement. To help obviate the pervasive unsafety that this would\n+introduce, Send (resp. Sync) is *automatically* derived for all types composed only\n+of Send (resp. Sync) values. 99% of types are Send and Sync, and 99% of those\n+never actually say it (the remaining 1% is overwhelmingly synchronization\n+primitives).\n+\n+\n+\n+\n+[drop flags]: drop-flags.html\n+[conversions]: conversions.html"}, {"sha": "5b00709a1bf40d1045e7a33267ec066410d7b73b", "filename": "src/doc/tarpl/send-and-sync.md", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fsend-and-sync.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fsend-and-sync.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fsend-and-sync.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,79 @@\n+% Send and Sync\n+\n+Not everything obeys inherited mutability, though. Some types allow you to\n+multiply alias a location in memory while mutating it. Unless these types use\n+synchronization to manage this access, they are absolutely not thread safe. Rust\n+captures this with through the `Send` and `Sync` traits.\n+\n+* A type is Send if it is safe to send it to another thread. A type is Sync if\n+* it is safe to share between threads (`&T` is Send).\n+\n+Send and Sync are *very* fundamental to Rust's concurrency story. As such, a\n+substantial amount of special tooling exists to make them work right. First and\n+foremost, they're *unsafe traits*. This means that they are unsafe *to\n+implement*, and other unsafe code can *trust* that they are correctly\n+implemented. Since they're *marker traits* (they have no associated items like\n+methods), correctly implemented simply means that they have the intrinsic\n+properties an implementor should have. Incorrectly implementing Send or Sync can\n+cause Undefined Behaviour.\n+\n+Send and Sync are also what Rust calls *opt-in builtin traits*. This means that,\n+unlike every other trait, they are *automatically* derived: if a type is\n+composed entirely of Send or Sync types, then it is Send or Sync. Almost all\n+primitives are Send and Sync, and as a consequence pretty much all types you'll\n+ever interact with are Send and Sync.\n+\n+Major exceptions include:\n+\n+* raw pointers are neither Send nor Sync (because they have no safety guards)\n+* `UnsafeCell` isn't Sync (and therefore `Cell` and `RefCell` aren't) `Rc` isn't\n+* Send or Sync (because the refcount is shared and unsynchronized)\n+\n+`Rc` and `UnsafeCell` are very fundamentally not thread-safe: they enable\n+unsynchronized shared mutable state. However raw pointers are, strictly\n+speaking, marked as thread-unsafe as more of a *lint*. Doing anything useful\n+with a raw pointer requires dereferencing it, which is already unsafe. In that\n+sense, one could argue that it would be \"fine\" for them to be marked as thread\n+safe.\n+\n+However it's important that they aren't thread safe to prevent types that\n+*contain them* from being automatically marked as thread safe. These types have\n+non-trivial untracked ownership, and it's unlikely that their author was\n+necessarily thinking hard about thread safety. In the case of Rc, we have a nice\n+example of a type that contains a `*mut` that is *definitely* not thread safe.\n+\n+Types that aren't automatically derived can *opt-in* to Send and Sync by simply\n+implementing them:\n+\n+```rust\n+struct MyBox(*mut u8);\n+\n+unsafe impl Send for MyBox {}\n+unsafe impl Sync for MyBox {}\n+```\n+\n+In the *incredibly rare* case that a type is *inappropriately* automatically\n+derived to be Send or Sync, then one can also *unimplement* Send and Sync:\n+\n+```rust\n+#![feature(optin_builtin_traits)]\n+\n+struct SpecialThreadToken(u8);\n+\n+impl !Send for SpecialThreadToken {}\n+impl !Sync for SpecialThreadToken {}\n+```\n+\n+Note that *in and of itself* it is impossible to incorrectly derive Send and\n+Sync. Only types that are ascribed special meaning by other unsafe code can\n+possible cause trouble by being incorrectly Send or Sync.\n+\n+Most uses of raw pointers should be encapsulated behind a sufficient abstraction\n+that Send and Sync can be derived. For instance all of Rust's standard\n+collections are Send and Sync (when they contain Send and Sync types) in spite\n+of their pervasive use raw pointers to manage allocations and complex ownership.\n+Similarly, most iterators into these collections are Send and Sync because they\n+largely behave like an `&` or `&mut` into the collection.\n+\n+TODO: better explain what can or can't be Send or Sync. Sufficient to appeal\n+only to data races?"}, {"sha": "767a0aca542f96b26ec7127f428aa6184439bffd", "filename": "src/doc/tarpl/subtyping.md", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fsubtyping.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fsubtyping.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fsubtyping.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,210 @@\n+% Subtyping and Variance\n+\n+Although Rust doesn't have any notion of structural inheritance, it *does*\n+include subtyping. In Rust, subtyping derives entirely from *lifetimes*. Since\n+lifetimes are scopes, we can partially order them based on the *contains*\n+(outlives) relationship. We can even express this as a generic bound.\n+\n+Subtyping on lifetimes in terms of that relationship: if `'a: 'b` (\"a contains\n+b\" or \"a outlives b\"), then `'a` is a subtype of `'b`. This is a large source of\n+confusion, because it seems intuitively backwards to many: the bigger scope is a\n+*sub type* of the smaller scope.\n+\n+This does in fact make sense, though. The intuitive reason for this is that if\n+you expect an `&'a u8`, then it's totally fine for me to hand you an `&'static\n+u8`, in the same way that if you expect an Animal in Java, it's totally fine for\n+me to hand you a Cat. Cats are just Animals *and more*, just as `'static` is\n+just `'a` *and more*.\n+\n+(Note, the subtyping relationship and typed-ness of lifetimes is a fairly\n+arbitrary construct that some disagree with. However it simplifies our analysis\n+to treat lifetimes and types uniformly.)\n+\n+Higher-ranked lifetimes are also subtypes of every concrete lifetime. This is\n+because taking an arbitrary lifetime is strictly more general than taking a\n+specific one.\n+\n+\n+\n+# Variance\n+\n+Variance is where things get a bit complicated.\n+\n+Variance is a property that *type constructors* have with respect to their\n+arguments. A type constructor in Rust is a generic type with unbound arguments.\n+For instance `Vec` is a type constructor that takes a `T` and returns a\n+`Vec<T>`. `&` and `&mut` are type constructors that take two inputs: a\n+lifetime, and a type to point to.\n+\n+A type constructor's *variance* is how the subtyping of its inputs affects the\n+subtyping of its outputs. There are two kinds of variance in Rust:\n+\n+* F is *variant* over `T` if `T` being a subtype of `U` implies\n+  `F<T>` is a subtype of `F<U>` (subtyping \"passes through\")\n+* F is *invariant* over `T` otherwise (no subtyping relation can be derived)\n+\n+(For those of you who are familiar with variance from other languages, what we\n+refer to as \"just\" variance is in fact *covariance*. Rust does not have\n+contravariance. Historically Rust did have some contravariance but it was\n+scrapped due to poor interactions with other features. If you experience\n+contravariance in Rust call your local compiler developer for medical advice.)\n+\n+Some important variances:\n+\n+* `&'a T` is variant over `'a` and `T` (as is `*const T` by metaphor)\n+* `&'a mut T` is variant with over `'a` but invariant over `T`\n+* `Fn(T) -> U` is invariant over `T`, but variant over `U`\n+* `Box`, `Vec`, and all other collections are variant over the types of\n+  their contents\n+* `UnsafeCell<T>`, `Cell<T>`, `RefCell<T>`, `Mutex<T>` and all other\n+  interior mutability types are invariant over T (as is `*mut T` by metaphor)\n+\n+To understand why these variances are correct and desirable, we will consider\n+several examples.\n+\n+\n+We have already covered why `&'a T` should be variant over `'a` when\n+introducing subtyping: it's desirable to be able to pass longer-lived things\n+where shorter-lived things are needed.\n+\n+Similar reasoning applies to why it should be variant over T. It is reasonable\n+to be able to pass `&&'static str` where an `&&'a str` is expected. The\n+additional level of indirection does not change the desire to be able to pass\n+longer lived things where shorted lived things are expected.\n+\n+However this logic *does not* apply to `&mut`. To see why `&mut` should\n+be invariant over T, consider the following code:\n+\n+```rust,ignore\n+fn overwrite<T: Copy>(input: &mut T, new: &mut T) {\n+    *input = *new;\n+}\n+\n+fn main() {\n+    let mut forever_str: &'static str = \"hello\";\n+    {\n+        let string = String::from(\"world\");\n+        overwrite(&mut forever_str, &mut &*string);\n+    }\n+    // Oops, printing free'd memory\n+    println!(\"{}\", forever_str);\n+}\n+```\n+\n+The signature of `overwrite` is clearly valid: it takes mutable references to\n+two values of the same type, and overwrites one with the other. If `&mut T` was\n+variant over T, then `&mut &'a str` would be a subtype of `&mut &'static str`,\n+since `&'a str` is a subtype of `&'static str`. Therefore the lifetime of\n+`forever_str` would successfully be \"shrunk\" down to the shorter lifetime of\n+`string`, and `overwrite` would be called successfully. `string` would\n+subsequently be dropped, and `forever_str` would point to freed memory when we\n+print it! Therefore `&mut` should be invariant.\n+\n+This is the general theme of variance vs invariance: if variance would allow you\n+to store a short-lived value into a longer-lived slot, then you must be\n+invariant.\n+\n+However it *is* sound for `&'a mut T` to be variant over `'a`. The key difference\n+between `'a` and T is that `'a` is a property of the reference itself,\n+while T is something the reference is borrowing. If you change T's type, then\n+the source still remembers the original type. However if you change the\n+lifetime's type, no one but the reference knows this information, so it's fine.\n+Put another way, `&'a mut T` owns `'a`, but only *borrows* T.\n+\n+`Box` and `Vec` are interesting cases because they're variant, but you can\n+definitely store values in them! This is where Rust gets really clever: it's\n+fine for them to be variant because you can only store values\n+in them *via a mutable reference*! The mutable reference makes the whole type\n+invariant, and therefore prevents you from smuggling a short-lived type into\n+them.\n+\n+Being variant *does* allows `Box` and `Vec` to be weakened when shared\n+immutably. So you can pass a `&Box<&'static str>` where a `&Box<&'a str>` is\n+expected.\n+\n+However what should happen when passing *by-value* is less obvious. It turns out\n+that, yes, you can use subtyping when passing by-value. That is, this works:\n+\n+```rust\n+fn get_box<'a>(str: &'a u8) -> Box<&'a str> {\n+    // string literals are `&'static str`s\n+    Box::new(\"hello\")\n+}\n+```\n+\n+Weakening when you pass by-value is fine because there's no one else who\n+\"remembers\" the old lifetime in the Box. The reason a variant `&mut` was\n+trouble was because there's always someone else who remembers the original\n+subtype: the actual owner.\n+\n+The invariance of the cell types can be seen as follows: `&` is like an `&mut`\n+for a cell, because you can still store values in them through an `&`. Therefore\n+cells must be invariant to avoid lifetime smuggling.\n+\n+`Fn` is the most subtle case because it has mixed variance. To see why\n+`Fn(T) -> U` should be invariant over T, consider the following function\n+signature:\n+\n+```rust,ignore\n+// 'a is derived from some parent scope\n+fn foo(&'a str) -> usize;\n+```\n+\n+This signature claims that it can handle any `&str` that lives *at least* as\n+long as `'a`. Now if this signature was variant over `&'a str`, that\n+would mean\n+\n+```rust,ignore\n+fn foo(&'static str) -> usize;\n+```\n+\n+could be provided in its place, as it would be a subtype. However this function\n+has a *stronger* requirement: it says that it can *only* handle `&'static str`s,\n+and nothing else. Therefore functions are not variant over their arguments.\n+\n+To see why `Fn(T) -> U` should be *variant* over U, consider the following\n+function signature:\n+\n+```rust,ignore\n+// 'a is derived from some parent scope\n+fn foo(usize) -> &'a str;\n+```\n+\n+This signature claims that it will return something that outlives `'a`. It is\n+therefore completely reasonable to provide\n+\n+```rust,ignore\n+fn foo(usize) -> &'static str;\n+```\n+\n+in its place. Therefore functions *are* variant over their return type.\n+\n+`*const` has the exact same semantics as `&`, so variance follows. `*mut` on the\n+other hand can dereference to an `&mut` whether shared or not, so it is marked\n+as invariant just like cells.\n+\n+This is all well and good for the types the standard library provides, but\n+how is variance determined for type that *you* define? A struct, informally\n+speaking, inherits the variance of its fields. If a struct `Foo`\n+has a generic argument `A` that is used in a field `a`, then Foo's variance\n+over `A` is exactly `a`'s variance. However this is complicated if `A` is used\n+in multiple fields.\n+\n+* If all uses of A are variant, then Foo is variant over A\n+* Otherwise, Foo is invariant over A\n+\n+```rust\n+use std::cell::Cell;\n+\n+struct Foo<'a, 'b, A: 'a, B: 'b, C, D, E, F, G, H> {\n+    a: &'a A,     // variant over 'a and A\n+    b: &'b mut B, // invariant over 'b and B\n+    c: *const C,  // variant over C\n+    d: *mut D,    // invariant over D\n+    e: Vec<E>,    // variant over E\n+    f: Cell<F>,   // invariant over F\n+    g: G,         // variant over G\n+    h1: H,        // would also be variant over H except...\n+    h2: Cell<H>,  // invariant over H, because invariance wins\n+}\n+```"}, {"sha": "f19dda0d8b81fd948b54b36b1c5cb255192ad0e5", "filename": "src/doc/tarpl/transmutes.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Ftransmutes.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Ftransmutes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Ftransmutes.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,35 @@\n+% Transmutes\n+\n+Get out of our way type system! We're going to reinterpret these bits or die\n+trying! Even though this book is all about doing things that are unsafe, I\n+really can't emphasize that you should deeply think about finding Another Way\n+than the operations covered in this section. This is really, truly, the most\n+horribly unsafe thing you can do in Rust. The railguards here are dental floss.\n+\n+`mem::transmute<T, U>` takes a value of type `T` and reinterprets it to have\n+type `U`. The only restriction is that the `T` and `U` are verified to have the\n+same size. The ways to cause Undefined Behaviour with this are mind boggling.\n+\n+* First and foremost, creating an instance of *any* type with an invalid state\n+  is going to cause arbitrary chaos that can't really be predicted.\n+* Transmute has an overloaded return type. If you do not specify the return type\n+  it may produce a surprising type to satisfy inference.\n+* Making a primitive with an invalid value is UB\n+* Transmuting between non-repr(C) types is UB\n+* Transmuting an & to &mut is UB\n+    * Transmuting an & to &mut is *always* UB\n+    * No you can't do it\n+    * No you're not special\n+* Transmuting to a reference without an explicitly provided lifetime\n+  produces an [unbounded lifetime][]\n+\n+`mem::transmute_copy<T, U>` somehow manages to be *even more* wildly unsafe than\n+this. It copies `size_of<U>` bytes out of an `&T` and interprets them as a `U`.\n+The size check that `mem::transmute` has is gone (as it may be valid to copy\n+out a prefix), though it is Undefined Behaviour for `U` to be larger than `T`.\n+\n+Also of course you can get most of the functionality of these functions using\n+pointer casts.\n+\n+\n+[unbounded lifetime]: unbounded-lifetimes.html"}, {"sha": "b540ab4ed5d999d5c70c972fc207bd3df7c76415", "filename": "src/doc/tarpl/unbounded-lifetimes.md", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Funbounded-lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Funbounded-lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Funbounded-lifetimes.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,37 @@\n+% Unbounded Lifetimes\n+\n+Unsafe code can often end up producing references or lifetimes out of thin air.\n+Such lifetimes come into the world as *unbounded*. The most common source of this\n+is derefencing a raw pointer, which produces a reference with an unbounded lifetime.\n+Such a lifetime becomes as big as context demands. This is in fact more powerful\n+than simply becoming `'static`, because for instance `&'static &'a T`\n+will fail to typecheck, but the unbound lifetime will perfectly mold into\n+`&'a &'a T` as needed. However for most intents and purposes, such an unbounded\n+lifetime can be regarded as `'static`.\n+\n+Almost no reference is `'static`, so this is probably wrong. `transmute` and\n+`transmute_copy` are the two other primary offenders. One should endeavour to\n+bound an unbounded lifetime as quick as possible, especially across function\n+boundaries.\n+\n+Given a function, any output lifetimes that don't derive from inputs are\n+unbounded. For instance:\n+\n+```rust,ignore\n+fn get_str<'a>() -> &'a str;\n+```\n+\n+will produce an `&str` with an unbounded lifetime. The easiest way to avoid\n+unbounded lifetimes is to use lifetime elision at the function boundary.\n+If an output lifetime is elided, then it *must* be bounded by an input lifetime.\n+Of course it might be bounded by the *wrong* lifetime, but this will usually\n+just cause a compiler error, rather than allow memory safety to be trivially\n+violated.\n+\n+Within a function, bounding lifetimes is more error-prone. The safest and easiest\n+way to bound a lifetime is to return it from a function with a bound lifetime.\n+However if this is unacceptable, the reference can be placed in a location with\n+a specific lifetime. Unfortunately it's impossible to name all lifetimes involved\n+in a function. To get around this, you can in principle use `copy_lifetime`, though\n+these are unstable due to their awkward nature and questionable utility.\n+"}, {"sha": "da9fb294a1eab7f12d41cbdde625c544434a299b", "filename": "src/doc/tarpl/unchecked-uninit.md", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Funchecked-uninit.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Funchecked-uninit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Funchecked-uninit.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,85 @@\n+% Unchecked Uninitialized Memory\n+\n+One interesting exception to this rule is working with arrays. Safe Rust doesn't\n+permit you to partially initialize an array. When you initialize an array, you\n+can either set every value to the same thing with `let x = [val; N]`, or you can\n+specify each member individually with `let x = [val1, val2, val3]`.\n+Unfortunately this is pretty rigid, especially if you need to initialize your\n+array in a more incremental or dynamic way.\n+\n+Unsafe Rust gives us a powerful tool to handle this problem:\n+`mem::uninitialized`. This function pretends to return a value when really\n+it does nothing at all. Using it, we can convince Rust that we have initialized\n+a variable, allowing us to do trickier things with conditional and incremental\n+initialization.\n+\n+Unfortunately, this opens us up to all kinds of problems. Assignment has a\n+different meaning to Rust based on whether it believes that a variable is\n+initialized or not. If it's believed uninitialized, then Rust will semantically\n+just memcopy the bits over the uninitialized ones, and do nothing else. However\n+if Rust believes a value to be initialized, it will try to `Drop` the old value!\n+Since we've tricked Rust into believing that the value is initialized, we can no\n+longer safely use normal assignment.\n+\n+This is also a problem if you're working with a raw system allocator, which\n+returns a pointer to uninitialized memory.\n+\n+To handle this, we must use the `ptr` module. In particular, it provides\n+three functions that allow us to assign bytes to a location in memory without\n+dropping the old value: `write`, `copy`, and `copy_nonoverlapping`.\n+\n+* `ptr::write(ptr, val)` takes a `val` and moves it into the address pointed\n+  to by `ptr`.\n+* `ptr::copy(src, dest, count)` copies the bits that `count` T's would occupy\n+  from src to dest. (this is equivalent to memmove -- note that the argument\n+  order is reversed!)\n+* `ptr::copy_nonoverlapping(src, dest, count)` does what `copy` does, but a\n+  little faster on the assumption that the two ranges of memory don't overlap.\n+  (this is equivalent to memcpy -- note that the argument order is reversed!)\n+\n+It should go without saying that these functions, if misused, will cause serious\n+havoc or just straight up Undefined Behaviour. The only things that these\n+functions *themselves* require is that the locations you want to read and write\n+are allocated. However the ways writing arbitrary bits to arbitrary\n+locations of memory can break things are basically uncountable!\n+\n+Putting this all together, we get the following:\n+\n+```rust\n+use std::mem;\n+use std::ptr;\n+\n+// size of the array is hard-coded but easy to change. This means we can't\n+// use [a, b, c] syntax to initialize the array, though!\n+const SIZE: usize = 10;\n+\n+let mut x: [Box<u32>; SIZE];\n+\n+unsafe {\n+\t// convince Rust that x is Totally Initialized\n+\tx = mem::uninitialized();\n+\tfor i in 0..SIZE {\n+\t\t// very carefully overwrite each index without reading it\n+\t\t// NOTE: exception safety is not a concern; Box can't panic\n+\t\tptr::write(&mut x[i], Box::new(i as u32));\n+\t}\n+}\n+\n+println!(\"{:?}\", x);\n+```\n+\n+It's worth noting that you don't need to worry about `ptr::write`-style\n+shenanigans with types which don't implement `Drop` or contain `Drop` types,\n+because Rust knows not to try to drop them. Similarly you should be able to\n+assign to fields of partially initialized structs directly if those fields don't\n+contain any `Drop` types.\n+\n+However when working with uninitialized memory you need to be ever-vigilant for\n+Rust trying to drop values you make like this before they're fully initialized.\n+Every control path through that variable's scope must initialize the value\n+before it ends, if has a destructor.\n+*[This includes code panicking](unwinding.html)*.\n+\n+And that's about it for working with uninitialized memory! Basically nothing\n+anywhere expects to be handed uninitialized memory, so if you're going to pass\n+it around at all, be sure to be *really* careful."}, {"sha": "915ea8602918e6133e419b041f5128eb9b620b17", "filename": "src/doc/tarpl/uninitialized.md", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Funinitialized.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Funinitialized.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Funinitialized.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,10 @@\n+% Working With Uninitialized Memory\n+\n+All runtime-allocated memory in a Rust program begins its life as\n+*uninitialized*. In this state the value of the memory is an indeterminate pile\n+of bits that may or may not even reflect a valid state for the type that is\n+supposed to inhabit that location of memory. Attempting to interpret this memory\n+as a value of *any* type will cause Undefined Behaviour. Do Not Do This.\n+\n+Rust provides mechanisms to work with uninitialized memory in checked (safe) and\n+unchecked (unsafe) ways.\n\\ No newline at end of file"}, {"sha": "59494d8647467921b74c33ce81f6a65ab0b42e8a", "filename": "src/doc/tarpl/unwinding.md", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Funwinding.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Funwinding.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Funwinding.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,49 @@\n+% Unwinding\n+\n+Rust has a *tiered* error-handling scheme:\n+\n+* If something might reasonably be absent, Option is used.\n+* If something goes wrong and can reasonably be handled, Result is used.\n+* If something goes wrong and cannot reasonably be handled, the thread panics.\n+* If something catastrophic happens, the program aborts.\n+\n+Option and Result are overwhelmingly preferred in most situations, especially\n+since they can be promoted into a panic or abort at the API user's discretion.\n+Panics cause the thread to halt normal execution and unwind its stack, calling\n+destructors as if every function instantly returned.\n+\n+As of 1.0, Rust is of two minds when it comes to panics. In the long-long-ago,\n+Rust was much more like Erlang. Like Erlang, Rust had lightweight tasks,\n+and tasks were intended to kill themselves with a panic when they reached an\n+untenable state. Unlike an exception in Java or C++, a panic could not be\n+caught at any time. Panics could only be caught by the owner of the task, at which\n+point they had to be handled or *that* task would itself panic.\n+\n+Unwinding was important to this story because if a task's\n+destructors weren't called, it would cause memory and other system resources to\n+leak. Since tasks were expected to die during normal execution, this would make\n+Rust very poor for long-running systems!\n+\n+As the Rust we know today came to be, this style of programming grew out of\n+fashion in the push for less-and-less abstraction. Light-weight tasks were\n+killed in the name of heavy-weight OS threads. Still, on stable Rust as of 1.0\n+panics can only be caught by the parent thread. This means catching a panic\n+requires spinning up an entire OS thread! This unfortunately stands in conflict\n+to Rust's philosophy of zero-cost abstractions.\n+\n+There is an *unstable* API called `catch_panic` that enables catching a panic\n+without spawning a thread. Still, we would encourage you to only do this\n+sparingly. In particular, Rust's current unwinding implementation is heavily\n+optimized for the \"doesn't unwind\" case. If a program doesn't unwind, there\n+should be no runtime cost for the program being *ready* to unwind. As a\n+consequence, *actually* unwinding will be more expensive than in e.g. Java.\n+Don't build your programs to unwind under normal circumstances. Ideally, you\n+should only panic for programming errors or *extreme* problems.\n+\n+Rust's unwinding strategy is not specified to be fundamentally compatible\n+with any other language's unwinding. As such, unwinding into Rust from another\n+language, or unwinding into another language from Rust is Undefined Behaviour.\n+You must *absolutely* catch any panics at the FFI boundary! What you do at that\n+point is up to you, but *something* must be done. If you fail to do this,\n+at best, your application will crash and burn. At worst, your application *won't*\n+crash and burn, and will proceed with completely clobbered state."}, {"sha": "93efbbbdf89a2e49df2bedad48ca8361c26dd518", "filename": "src/doc/tarpl/vec-alloc.md", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fvec-alloc.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fvec-alloc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-alloc.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,222 @@\n+% Allocating Memory\n+\n+Using Unique throws a wrench in an important feature of Vec (and indeed all of\n+the std collections): an empty Vec doesn't actually allocate at all. So if we\n+can't allocate, but also can't put a null pointer in `ptr`, what do we do in\n+`Vec::new`? Well, we just put some other garbage in there!\n+\n+This is perfectly fine because we already have `cap == 0` as our sentinel for no\n+allocation. We don't even need to handle it specially in almost any code because\n+we usually need to check if `cap > len` or `len > 0` anyway. The traditional\n+Rust value to put here is `0x01`. The standard library actually exposes this\n+as `std::rt::heap::EMPTY`. There are quite a few places where we'll\n+want to use `heap::EMPTY` because there's no real allocation to talk about but\n+`null` would make the compiler do bad things.\n+\n+All of the `heap` API is totally unstable under the `heap_api` feature, though.\n+We could trivially define `heap::EMPTY` ourselves, but we'll want the rest of\n+the `heap` API anyway, so let's just get that dependency over with.\n+\n+So:\n+\n+```rust,ignore\n+#![feature(heap_api)]\n+\n+use std::rt::heap::EMPTY;\n+use std::mem;\n+\n+impl<T> Vec<T> {\n+    fn new() -> Self {\n+        assert!(mem::size_of::<T>() != 0, \"We're not ready to handle ZSTs\");\n+        unsafe {\n+            // need to cast EMPTY to the actual ptr type we want, let\n+            // inference handle it.\n+            Vec { ptr: Unique::new(heap::EMPTY as *mut _), len: 0, cap: 0 }\n+        }\n+    }\n+}\n+```\n+\n+I slipped in that assert there because zero-sized types will require some\n+special handling throughout our code, and I want to defer the issue for now.\n+Without this assert, some of our early drafts will do some Very Bad Things.\n+\n+Next we need to figure out what to actually do when we *do* want space. For\n+that, we'll need to use the rest of the heap APIs. These basically allow us to\n+talk directly to Rust's allocator (jemalloc by default).\n+\n+We'll also need a way to handle out-of-memory (OOM) conditions. The standard\n+library calls the `abort` intrinsic, which just calls an illegal instruction to\n+crash the whole program. The reason we abort and don't panic is because\n+unwinding can cause allocations to happen, and that seems like a bad thing to do\n+when your allocator just came back with \"hey I don't have any more memory\".\n+\n+Of course, this is a bit silly since most platforms don't actually run out of\n+memory in a conventional way. Your operating system will probably kill the\n+application by another means if you legitimately start using up all the memory.\n+The most likely way we'll trigger OOM is by just asking for ludicrous quantities\n+of memory at once (e.g. half the theoretical address space). As such it's\n+*probably* fine to panic and nothing bad will happen. Still, we're trying to be\n+like the standard library as much as possible, so we'll just kill the whole\n+program.\n+\n+We said we don't want to use intrinsics, so doing *exactly* what `std` does is\n+out. Instead, we'll call `std::process::exit` with some random number.\n+\n+```rust\n+fn oom() {\n+    ::std::process::exit(-9999);\n+}\n+```\n+\n+Okay, now we can write growing. Roughly, we want to have this logic:\n+\n+```text\n+if cap == 0:\n+    allocate()\n+    cap = 1\n+else:\n+    reallocate()\n+    cap *= 2\n+```\n+\n+But Rust's only supported allocator API is so low level that we'll need to do a\n+fair bit of extra work. We also need to guard against some special\n+conditions that can occur with really large allocations or empty allocations.\n+\n+In particular, `ptr::offset` will cause us *a lot* of trouble, because it has\n+the semantics of LLVM's GEP inbounds instruction. If you're fortunate enough to\n+not have dealt with this instruction, here's the basic story with GEP: alias\n+analysis, alias analysis, alias analysis. It's super important to an optimizing\n+compiler to be able to reason about data dependencies and aliasing.\n+\n+As a simple example, consider the following fragment of code:\n+\n+```rust\n+# let x = &mut 0;\n+# let y = &mut 0;\n+*x *= 7;\n+*y *= 3;\n+```\n+\n+If the compiler can prove that `x` and `y` point to different locations in\n+memory, the two operations can in theory be executed in parallel (by e.g.\n+loading them into different registers and working on them independently).\n+However in *general* the compiler can't do this because if x and y point to\n+the same location in memory, the operations need to be done to the same value,\n+and they can't just be merged afterwards.\n+\n+When you use GEP inbounds, you are specifically telling LLVM that the offsets\n+you're about to do are within the bounds of a single \"allocated\" entity. The\n+ultimate payoff being that LLVM can assume that if two pointers are known to\n+point to two disjoint objects, all the offsets of those pointers are *also*\n+known to not alias (because you won't just end up in some random place in\n+memory). LLVM is heavily optimized to work with GEP offsets, and inbounds\n+offsets are the best of all, so it's important that we use them as much as\n+possible.\n+\n+So that's what GEP's about, how can it cause us trouble?\n+\n+The first problem is that we index into arrays with unsigned integers, but\n+GEP (and as a consequence `ptr::offset`) takes a *signed integer*. This means\n+that half of the seemingly valid indices into an array will overflow GEP and\n+actually go in the wrong direction! As such we must limit all allocations to\n+`isize::MAX` elements. This actually means we only need to worry about\n+byte-sized objects, because e.g. `> isize::MAX` `u16`s will truly exhaust all of\n+the system's memory. However in order to avoid subtle corner cases where someone\n+reinterprets some array of `< isize::MAX` objects as bytes, std limits all\n+allocations to `isize::MAX` bytes.\n+\n+On all 64-bit targets that Rust currently supports we're artificially limited\n+to significantly less than all 64 bits of the address space (modern x64\n+platforms only expose 48-bit addressing), so we can rely on just running out of\n+memory first. However on 32-bit targets, particularly those with extensions to\n+use more of the address space (PAE x86 or x32), it's theoretically possible to\n+successfully allocate more than `isize::MAX` bytes of memory.\n+\n+However since this is a tutorial, we're not going to be particularly optimal\n+here, and just unconditionally check, rather than use clever platform-specific\n+`cfg`s.\n+\n+The other corner-case we need to worry about is *empty* allocations. There will\n+be two kinds of empty allocations we need to worry about: `cap = 0` for all T,\n+and `cap > 0` for zero-sized types.\n+\n+These cases are tricky because they come\n+down to what LLVM means by \"allocated\". LLVM's notion of an\n+allocation is significantly more abstract than how we usually use it. Because\n+LLVM needs to work with different languages' semantics and custom allocators,\n+it can't really intimately understand allocation. Instead, the main idea behind\n+allocation is \"doesn't overlap with other stuff\". That is, heap allocations,\n+stack allocations, and globals don't randomly overlap. Yep, it's about alias\n+analysis. As such, Rust can technically play a bit fast an loose with the notion of\n+an allocation as long as it's *consistent*.\n+\n+Getting back to the empty allocation case, there are a couple of places where\n+we want to offset by 0 as a consequence of generic code. The question is then:\n+is it consistent to do so? For zero-sized types, we have concluded that it is\n+indeed consistent to do a GEP inbounds offset by an arbitrary number of\n+elements. This is a runtime no-op because every element takes up no space,\n+and it's fine to pretend that there's infinite zero-sized types allocated\n+at `0x01`. No allocator will ever allocate that address, because they won't\n+allocate `0x00` and they generally allocate to some minimal alignment higher\n+than a byte. Also generally the whole first page of memory is\n+protected from being allocated anyway (a whole 4k, on many platforms).\n+\n+However what about for positive-sized types? That one's a bit trickier. In\n+principle, you can argue that offsetting by 0 gives LLVM no information: either\n+there's an element before the address, or after it, but it can't know which.\n+However we've chosen to conservatively assume that it may do bad things. As\n+such we *will* guard against this case explicitly.\n+\n+*Phew*\n+\n+Ok with all the nonsense out of the way, let's actually allocate some memory:\n+\n+```rust,ignore\n+fn grow(&mut self) {\n+    // this is all pretty delicate, so let's say it's all unsafe\n+    unsafe {\n+        // current API requires us to specify size and alignment manually.\n+        let align = mem::align_of::<T>();\n+        let elem_size = mem::size_of::<T>();\n+\n+        let (new_cap, ptr) = if self.cap == 0 {\n+            let ptr = heap::allocate(elem_size, align);\n+            (1, ptr)\n+        } else {\n+            // as an invariant, we can assume that `self.cap < isize::MAX`,\n+            // so this doesn't need to be checked.\n+            let new_cap = self.cap * 2;\n+            // Similarly this can't overflow due to previously allocating this\n+            let old_num_bytes = self.cap * elem_size;\n+\n+            // check that the new allocation doesn't exceed `isize::MAX` at all\n+            // regardless of the actual size of the capacity. This combines the\n+            // `new_cap <= isize::MAX` and `new_num_bytes <= usize::MAX` checks\n+            // we need to make. We lose the ability to allocate e.g. 2/3rds of\n+            // the address space with a single Vec of i16's on 32-bit though.\n+            // Alas, poor Yorick -- I knew him, Horatio.\n+            assert!(old_num_bytes <= (::std::isize::MAX as usize) / 2,\n+                    \"capacity overflow\");\n+\n+            let new_num_bytes = old_num_bytes * 2;\n+            let ptr = heap::reallocate(*self.ptr as *mut _,\n+                                        old_num_bytes,\n+                                        new_num_bytes,\n+                                        align);\n+            (new_cap, ptr)\n+        };\n+\n+        // If allocate or reallocate fail, we'll get `null` back\n+        if ptr.is_null() { oom(); }\n+\n+        self.ptr = Unique::new(ptr as *mut _);\n+        self.cap = new_cap;\n+    }\n+}\n+```\n+\n+Nothing particularly tricky here. Just computing sizes and alignments and doing\n+some careful multiplication checks.\n+"}, {"sha": "b767caa4912364e9ae52e7c543f8d3f625409d58", "filename": "src/doc/tarpl/vec-dealloc.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fvec-dealloc.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fvec-dealloc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-dealloc.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,29 @@\n+% Deallocating\n+\n+Next we should implement Drop so that we don't massively leak tons of resources.\n+The easiest way is to just call `pop` until it yields None, and then deallocate\n+our buffer. Note that calling `pop` is unneeded if `T: !Drop`. In theory we can\n+ask Rust if `T` `needs_drop` and omit the calls to `pop`. However in practice\n+LLVM is *really* good at removing simple side-effect free code like this, so I\n+wouldn't bother unless you notice it's not being stripped (in this case it is).\n+\n+We must not call `heap::deallocate` when `self.cap == 0`, as in this case we\n+haven't actually allocated any memory.\n+\n+\n+```rust,ignore\n+impl<T> Drop for Vec<T> {\n+    fn drop(&mut self) {\n+        if self.cap != 0 {\n+            while let Some(_) = self.pop() { }\n+\n+            let align = mem::align_of::<T>();\n+            let elem_size = mem::size_of::<T>();\n+            let num_bytes = elem_size * self.cap;\n+            unsafe {\n+                heap::deallocate(*self.ptr, num_bytes, align);\n+            }\n+        }\n+    }\n+}\n+```"}, {"sha": "6460eab479bd42c5a0e50aa00eb3336ba6bd8a17", "filename": "src/doc/tarpl/vec-deref.md", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fvec-deref.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fvec-deref.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-deref.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,42 @@\n+% Deref\n+\n+Alright! We've got a decent minimal stack implemented. We can push, we can\n+pop, and we can clean up after ourselves. However there's a whole mess of\n+functionality we'd reasonably want. In particular, we have a proper array, but\n+none of the slice functionality. That's actually pretty easy to solve: we can\n+implement `Deref<Target=[T]>`. This will magically make our Vec coerce to, and\n+behave like, a slice in all sorts of conditions.\n+\n+All we need is `slice::from_raw_parts`. It will correctly handle empty slices\n+for us. Later once we set up zero-sized type support it will also Just Work\n+for those too.\n+\n+```rust,ignore\n+use std::ops::Deref;\n+\n+impl<T> Deref for Vec<T> {\n+    type Target = [T];\n+    fn deref(&self) -> &[T] {\n+        unsafe {\n+            ::std::slice::from_raw_parts(*self.ptr, self.len)\n+        }\n+    }\n+}\n+```\n+\n+And let's do DerefMut too:\n+\n+```rust,ignore\n+use std::ops::DerefMut;\n+\n+impl<T> DerefMut for Vec<T> {\n+    fn deref_mut(&mut self) -> &mut [T] {\n+        unsafe {\n+            ::std::slice::from_raw_parts_mut(*self.ptr, self.len)\n+        }\n+    }\n+}\n+```\n+\n+Now we have `len`, `first`, `last`, indexing, slicing, sorting, `iter`,\n+`iter_mut`, and all other sorts of bells and whistles provided by slice. Sweet!"}, {"sha": "3be295f1adc2d301ad643c8294469725312e9d4f", "filename": "src/doc/tarpl/vec-drain.md", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fvec-drain.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fvec-drain.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-drain.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,150 @@\n+% Drain\n+\n+Let's move on to Drain. Drain is largely the same as IntoIter, except that\n+instead of consuming the Vec, it borrows the Vec and leaves its allocation\n+untouched. For now we'll only implement the \"basic\" full-range version.\n+\n+```rust,ignore\n+use std::marker::PhantomData;\n+\n+struct Drain<'a, T: 'a> {\n+    // Need to bound the lifetime here, so we do it with `&'a mut Vec<T>`\n+    // because that's semantically what we contain. We're \"just\" calling\n+    // `pop()` and `remove(0)`.\n+    vec: PhantomData<&'a mut Vec<T>>\n+    start: *const T,\n+    end: *const T,\n+}\n+\n+impl<'a, T> Iterator for Drain<'a, T> {\n+    type Item = T;\n+    fn next(&mut self) -> Option<T> {\n+        if self.start == self.end {\n+            None\n+```\n+\n+-- wait, this is seeming familiar. Let's do some more compression. Both\n+IntoIter and Drain have the exact same structure, let's just factor it out.\n+\n+```rust\n+struct RawValIter<T> {\n+    start: *const T,\n+    end: *const T,\n+}\n+\n+impl<T> RawValIter<T> {\n+    // unsafe to construct because it has no associated lifetimes.\n+    // This is necessary to store a RawValIter in the same struct as\n+    // its actual allocation. OK since it's a private implementation\n+    // detail.\n+    unsafe fn new(slice: &[T]) -> Self {\n+        RawValIter {\n+            start: slice.as_ptr(),\n+            end: if slice.len() == 0 {\n+                // if `len = 0`, then this is not actually allocated memory.\n+                // Need to avoid offsetting because that will give wrong\n+                // information to LLVM via GEP.\n+                slice.as_ptr()\n+            } else {\n+                slice.as_ptr().offset(slice.len() as isize)\n+            }\n+        }\n+    }\n+}\n+\n+// Iterator and DoubleEndedIterator impls identical to IntoIter.\n+```\n+\n+And IntoIter becomes the following:\n+\n+```rust,ignore\n+pub struct IntoIter<T> {\n+    _buf: RawVec<T>, // we don't actually care about this. Just need it to live.\n+    iter: RawValIter<T>,\n+}\n+\n+impl<T> Iterator for IntoIter<T> {\n+    type Item = T;\n+    fn next(&mut self) -> Option<T> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+\n+impl<T> DoubleEndedIterator for IntoIter<T> {\n+    fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n+}\n+\n+impl<T> Drop for IntoIter<T> {\n+    fn drop(&mut self) {\n+        for _ in &mut self.iter {}\n+    }\n+}\n+\n+impl<T> Vec<T> {\n+    pub fn into_iter(self) -> IntoIter<T> {\n+        unsafe {\n+            let iter = RawValIter::new(&self);\n+\n+            let buf = ptr::read(&self.buf);\n+            mem::forget(self);\n+\n+            IntoIter {\n+                iter: iter,\n+                _buf: buf,\n+            }\n+        }\n+    }\n+}\n+```\n+\n+Note that I've left a few quirks in this design to make upgrading Drain to work\n+with arbitrary subranges a bit easier. In particular we *could* have RawValIter\n+drain itself on drop, but that won't work right for a more complex Drain.\n+We also take a slice to simplify Drain initialization.\n+\n+Alright, now Drain is really easy:\n+\n+```rust,ignore\n+use std::marker::PhantomData;\n+\n+pub struct Drain<'a, T: 'a> {\n+    vec: PhantomData<&'a mut Vec<T>>,\n+    iter: RawValIter<T>,\n+}\n+\n+impl<'a, T> Iterator for Drain<'a, T> {\n+    type Item = T;\n+    fn next(&mut self) -> Option<T> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+\n+impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n+    fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n+}\n+\n+impl<'a, T> Drop for Drain<'a, T> {\n+    fn drop(&mut self) {\n+        for _ in &mut self.iter {}\n+    }\n+}\n+\n+impl<T> Vec<T> {\n+    pub fn drain(&mut self) -> Drain<T> {\n+        // this is a mem::forget safety thing. If Drain is forgotten, we just\n+        // leak the whole Vec's contents. Also we need to do this *eventually*\n+        // anyway, so why not do it now?\n+        self.len = 0;\n+\n+        unsafe {\n+            Drain {\n+                iter: RawValIter::new(&self),\n+                vec: PhantomData,\n+            }\n+        }\n+    }\n+}\n+```\n+\n+For more details on the `mem::forget` problem, see the\n+[section on leaks][leaks].\n+\n+[leaks]: leaking.html"}, {"sha": "847957e2ea977d048c1ab09c0a48c0801ce484bb", "filename": "src/doc/tarpl/vec-final.md", "status": "added", "additions": 311, "deletions": 0, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fvec-final.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fvec-final.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-final.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,311 @@\n+% The Final Code\n+\n+```rust\n+#![feature(unique)]\n+#![feature(heap_api)]\n+\n+use std::ptr::{Unique, self};\n+use std::rt::heap;\n+use std::mem;\n+use std::ops::{Deref, DerefMut};\n+use std::marker::PhantomData;\n+\n+\n+\n+\n+\n+struct RawVec<T> {\n+    ptr: Unique<T>,\n+    cap: usize,\n+}\n+\n+impl<T> RawVec<T> {\n+    fn new() -> Self {\n+        unsafe {\n+            // !0 is usize::MAX. This branch should be stripped at compile time.\n+            let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n+\n+            // heap::EMPTY doubles as \"unallocated\" and \"zero-sized allocation\"\n+            RawVec { ptr: Unique::new(heap::EMPTY as *mut T), cap: cap }\n+        }\n+    }\n+\n+    fn grow(&mut self) {\n+        unsafe {\n+            let elem_size = mem::size_of::<T>();\n+\n+            // since we set the capacity to usize::MAX when elem_size is\n+            // 0, getting to here necessarily means the Vec is overfull.\n+            assert!(elem_size != 0, \"capacity overflow\");\n+\n+            let align = mem::align_of::<T>();\n+\n+            let (new_cap, ptr) = if self.cap == 0 {\n+                let ptr = heap::allocate(elem_size, align);\n+                (1, ptr)\n+            } else {\n+                let new_cap = 2 * self.cap;\n+                let ptr = heap::reallocate(*self.ptr as *mut _,\n+                                            self.cap * elem_size,\n+                                            new_cap * elem_size,\n+                                            align);\n+                (new_cap, ptr)\n+            };\n+\n+            // If allocate or reallocate fail, we'll get `null` back\n+            if ptr.is_null() { oom() }\n+\n+            self.ptr = Unique::new(ptr as *mut _);\n+            self.cap = new_cap;\n+        }\n+    }\n+}\n+\n+impl<T> Drop for RawVec<T> {\n+    fn drop(&mut self) {\n+        let elem_size = mem::size_of::<T>();\n+        if self.cap != 0 && elem_size != 0 {\n+            let align = mem::align_of::<T>();\n+\n+            let num_bytes = elem_size * self.cap;\n+            unsafe {\n+                heap::deallocate(*self.ptr as *mut _, num_bytes, align);\n+            }\n+        }\n+    }\n+}\n+\n+\n+\n+\n+\n+pub struct Vec<T> {\n+    buf: RawVec<T>,\n+    len: usize,\n+}\n+\n+impl<T> Vec<T> {\n+    fn ptr(&self) -> *mut T { *self.buf.ptr }\n+\n+    fn cap(&self) -> usize { self.buf.cap }\n+\n+    pub fn new() -> Self {\n+        Vec { buf: RawVec::new(), len: 0 }\n+    }\n+    pub fn push(&mut self, elem: T) {\n+        if self.len == self.cap() { self.buf.grow(); }\n+\n+        unsafe {\n+            ptr::write(self.ptr().offset(self.len as isize), elem);\n+        }\n+\n+        // Can't fail, we'll OOM first.\n+        self.len += 1;\n+    }\n+\n+    pub fn pop(&mut self) -> Option<T> {\n+        if self.len == 0 {\n+            None\n+        } else {\n+            self.len -= 1;\n+            unsafe {\n+                Some(ptr::read(self.ptr().offset(self.len as isize)))\n+            }\n+        }\n+    }\n+\n+    pub fn insert(&mut self, index: usize, elem: T) {\n+        assert!(index <= self.len, \"index out of bounds\");\n+        if self.cap() == self.len { self.buf.grow(); }\n+\n+        unsafe {\n+            if index < self.len {\n+                ptr::copy(self.ptr().offset(index as isize),\n+                          self.ptr().offset(index as isize + 1),\n+                          self.len - index);\n+            }\n+            ptr::write(self.ptr().offset(index as isize), elem);\n+            self.len += 1;\n+        }\n+    }\n+\n+    pub fn remove(&mut self, index: usize) -> T {\n+        assert!(index < self.len, \"index out of bounds\");\n+        unsafe {\n+            self.len -= 1;\n+            let result = ptr::read(self.ptr().offset(index as isize));\n+            ptr::copy(self.ptr().offset(index as isize + 1),\n+                      self.ptr().offset(index as isize),\n+                      self.len - index);\n+            result\n+        }\n+    }\n+\n+    pub fn into_iter(self) -> IntoIter<T> {\n+        unsafe {\n+            let iter = RawValIter::new(&self);\n+            let buf = ptr::read(&self.buf);\n+            mem::forget(self);\n+\n+            IntoIter {\n+                iter: iter,\n+                _buf: buf,\n+            }\n+        }\n+    }\n+\n+    pub fn drain(&mut self) -> Drain<T> {\n+        // this is a mem::forget safety thing. If this is forgotten, we just\n+        // leak the whole Vec's contents. Also we need to do this *eventually*\n+        // anyway, so why not do it now?\n+        self.len = 0;\n+        unsafe {\n+            Drain {\n+                iter: RawValIter::new(&self),\n+                vec: PhantomData,\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> Drop for Vec<T> {\n+    fn drop(&mut self) {\n+        while let Some(_) = self.pop() {}\n+        // allocation is handled by RawVec\n+    }\n+}\n+\n+impl<T> Deref for Vec<T> {\n+    type Target = [T];\n+    fn deref(&self) -> &[T] {\n+        unsafe {\n+            ::std::slice::from_raw_parts(self.ptr(), self.len)\n+        }\n+    }\n+}\n+\n+impl<T> DerefMut for Vec<T> {\n+    fn deref_mut(&mut self) -> &mut [T] {\n+        unsafe {\n+            ::std::slice::from_raw_parts_mut(self.ptr(), self.len)\n+        }\n+    }\n+}\n+\n+\n+\n+\n+\n+struct RawValIter<T> {\n+    start: *const T,\n+    end: *const T,\n+}\n+\n+impl<T> RawValIter<T> {\n+    unsafe fn new(slice: &[T]) -> Self {\n+        RawValIter {\n+            start: slice.as_ptr(),\n+            end: if mem::size_of::<T>() == 0 {\n+                ((slice.as_ptr() as usize) + slice.len()) as *const _\n+            } else if slice.len() == 0 {\n+                slice.as_ptr()\n+            } else {\n+                slice.as_ptr().offset(slice.len() as isize)\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> Iterator for RawValIter<T> {\n+    type Item = T;\n+    fn next(&mut self) -> Option<T> {\n+        if self.start == self.end {\n+            None\n+        } else {\n+            unsafe {\n+                let result = ptr::read(self.start);\n+                self.start = self.start.offset(1);\n+                Some(result)\n+            }\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let elem_size = mem::size_of::<T>();\n+        let len = (self.end as usize - self.start as usize)\n+                  / if elem_size == 0 { 1 } else { elem_size };\n+        (len, Some(len))\n+    }\n+}\n+\n+impl<T> DoubleEndedIterator for RawValIter<T> {\n+    fn next_back(&mut self) -> Option<T> {\n+        if self.start == self.end {\n+            None\n+        } else {\n+            unsafe {\n+                self.end = self.end.offset(-1);\n+                Some(ptr::read(self.end))\n+            }\n+        }\n+    }\n+}\n+\n+\n+\n+\n+pub struct IntoIter<T> {\n+    _buf: RawVec<T>, // we don't actually care about this. Just need it to live.\n+    iter: RawValIter<T>,\n+}\n+\n+impl<T> Iterator for IntoIter<T> {\n+    type Item = T;\n+    fn next(&mut self) -> Option<T> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+\n+impl<T> DoubleEndedIterator for IntoIter<T> {\n+    fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n+}\n+\n+impl<T> Drop for IntoIter<T> {\n+    fn drop(&mut self) {\n+        for _ in &mut *self {}\n+    }\n+}\n+\n+\n+\n+\n+pub struct Drain<'a, T: 'a> {\n+    vec: PhantomData<&'a mut Vec<T>>,\n+    iter: RawValIter<T>,\n+}\n+\n+impl<'a, T> Iterator for Drain<'a, T> {\n+    type Item = T;\n+    fn next(&mut self) -> Option<T> { self.iter.next_back() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+\n+impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n+    fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n+}\n+\n+impl<'a, T> Drop for Drain<'a, T> {\n+    fn drop(&mut self) {\n+        // pre-drain the iter\n+        for _ in &mut self.iter {}\n+    }\n+}\n+\n+/// Abort the process, we're out of memory!\n+///\n+/// In practice this is probably dead code on most OSes\n+fn oom() {\n+    ::std::process::exit(-9999);\n+}\n+\n+# fn main() {}\n+```"}, {"sha": "6f88a77b32a7537378f2576ca2f9218b9dc3eacf", "filename": "src/doc/tarpl/vec-insert-remove.md", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fvec-insert-remove.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fvec-insert-remove.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-insert-remove.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,51 @@\n+% Insert and Remove\n+\n+Something *not* provided by slice is `insert` and `remove`, so let's do those\n+next.\n+\n+Insert needs to shift all the elements at the target index to the right by one.\n+To do this we need to use `ptr::copy`, which is our version of C's `memmove`.\n+This copies some chunk of memory from one location to another, correctly\n+handling the case where the source and destination overlap (which will\n+definitely happen here).\n+\n+If we insert at index `i`, we want to shift the `[i .. len]` to `[i+1 .. len+1]`\n+using the *old* len.\n+\n+```rust,ignore\n+pub fn insert(&mut self, index: usize, elem: T) {\n+    // Note: `<=` because it's valid to insert after everything\n+    // which would be equivalent to push.\n+    assert!(index <= self.len, \"index out of bounds\");\n+    if self.cap == self.len { self.grow(); }\n+\n+    unsafe {\n+        if index < self.len {\n+            // ptr::copy(src, dest, len): \"copy from source to dest len elems\"\n+            ptr::copy(self.ptr.offset(index as isize),\n+                      self.ptr.offset(index as isize + 1),\n+                      len - index);\n+        }\n+        ptr::write(self.ptr.offset(index as isize), elem);\n+        self.len += 1;\n+    }\n+}\n+```\n+\n+Remove behaves in the opposite manner. We need to shift all the elements from\n+`[i+1 .. len + 1]` to `[i .. len]` using the *new* len.\n+\n+```rust,ignore\n+pub fn remove(&mut self, index: usize) -> T {\n+    // Note: `<` because it's *not* valid to remove after everything\n+    assert!(index < self.len, \"index out of bounds\");\n+    unsafe {\n+        self.len -= 1;\n+        let result = ptr::read(self.ptr.offset(index as isize));\n+        ptr::copy(self.ptr.offset(index as isize + 1),\n+                  self.ptr.offset(index as isize),\n+                  len - index);\n+        result\n+    }\n+}\n+```"}, {"sha": "a9c1917feb9c64213ceab007a5311a037452298a", "filename": "src/doc/tarpl/vec-into-iter.md", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fvec-into-iter.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fvec-into-iter.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-into-iter.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,147 @@\n+% IntoIter\n+\n+Let's move on to writing iterators. `iter` and `iter_mut` have already been\n+written for us thanks to The Magic of Deref. However there's two interesting\n+iterators that Vec provides that slices can't: `into_iter` and `drain`.\n+\n+IntoIter consumes the Vec by-value, and can consequently yield its elements\n+by-value. In order to enable this, IntoIter needs to take control of Vec's\n+allocation.\n+\n+IntoIter needs to be DoubleEnded as well, to enable reading from both ends.\n+Reading from the back could just be implemented as calling `pop`, but reading\n+from the front is harder. We could call `remove(0)` but that would be insanely\n+expensive. Instead we're going to just use ptr::read to copy values out of\n+either end of the Vec without mutating the buffer at all.\n+\n+To do this we're going to use a very common C idiom for array iteration. We'll\n+make two pointers; one that points to the start of the array, and one that\n+points to one-element past the end. When we want an element from one end, we'll\n+read out the value pointed to at that end and move the pointer over by one. When\n+the two pointers are equal, we know we're done.\n+\n+Note that the order of read and offset are reversed for `next` and `next_back`\n+For `next_back` the pointer is always *after* the element it wants to read next,\n+while for `next` the pointer is always *at* the element it wants to read next.\n+To see why this is, consider the case where every element but one has been\n+yielded.\n+\n+The array looks like this:\n+\n+```text\n+          S  E\n+[X, X, X, O, X, X, X]\n+```\n+\n+If E pointed directly at the element it wanted to yield next, it would be\n+indistinguishable from the case where there are no more elements to yield.\n+\n+Although we don't actually care about it during iteration, we also need to hold\n+onto the Vec's allocation information in order to free it once IntoIter is\n+dropped.\n+\n+So we're going to use the following struct:\n+\n+```rust,ignore\n+struct IntoIter<T> {\n+    buf: Unique<T>,\n+    cap: usize,\n+    start: *const T,\n+    end: *const T,\n+}\n+```\n+\n+And this is what we end up with for initialization:\n+\n+```rust,ignore\n+impl<T> Vec<T> {\n+    fn into_iter(self) -> IntoIter<T> {\n+        // Can't destructure Vec since it's Drop\n+        let ptr = self.ptr;\n+        let cap = self.cap;\n+        let len = self.len;\n+\n+        // Make sure not to drop Vec since that will free the buffer\n+        mem::forget(self);\n+\n+        unsafe {\n+            IntoIter {\n+                buf: ptr,\n+                cap: cap,\n+                start: *ptr,\n+                end: if cap == 0 {\n+                    // can't offset off this pointer, it's not allocated!\n+                    *ptr\n+                } else {\n+                    ptr.offset(len as isize)\n+                }\n+            }\n+        }\n+    }\n+}\n+```\n+\n+Here's iterating forward:\n+\n+```rust,ignore\n+impl<T> Iterator for IntoIter<T> {\n+    type Item = T;\n+    fn next(&mut self) -> Option<T> {\n+        if self.start == self.end {\n+            None\n+        } else {\n+            unsafe {\n+                let result = ptr::read(self.start);\n+                self.start = self.start.offset(1);\n+                Some(result)\n+            }\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let len = (self.end as usize - self.start as usize)\n+                  / mem::size_of::<T>();\n+        (len, Some(len))\n+    }\n+}\n+```\n+\n+And here's iterating backwards.\n+\n+```rust,ignore\n+impl<T> DoubleEndedIterator for IntoIter<T> {\n+    fn next_back(&mut self) -> Option<T> {\n+        if self.start == self.end {\n+            None\n+        } else {\n+            unsafe {\n+                self.end = self.end.offset(-1);\n+                Some(ptr::read(self.end))\n+            }\n+        }\n+    }\n+}\n+```\n+\n+Because IntoIter takes ownership of its allocation, it needs to implement Drop\n+to free it. However it *also* wants to implement Drop to drop any elements it\n+contains that weren't yielded.\n+\n+\n+```rust,ignore\n+impl<T> Drop for IntoIter<T> {\n+    fn drop(&mut self) {\n+        if self.cap != 0 {\n+            // drop any remaining elements\n+            for _ in &mut *self {}\n+\n+            let align = mem::align_of::<T>();\n+            let elem_size = mem::size_of::<T>();\n+            let num_bytes = elem_size * self.cap;\n+            unsafe {\n+                heap::deallocate(*self.buf as *mut _, num_bytes, align);\n+            }\n+        }\n+    }\n+}\n+```"}, {"sha": "3df63d5249c55efbe4fd3b2724e5dd208d5c3e18", "filename": "src/doc/tarpl/vec-layout.md", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fvec-layout.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fvec-layout.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-layout.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,100 @@\n+% Layout\n+\n+First off, we need to come up with the struct layout. A Vec has three parts:\n+a pointer to the allocation, the size of the allocation, and the number of\n+elements that have been initialized.\n+\n+Naively, this means we just want this design:\n+\n+```rust\n+pub struct Vec<T> {\n+    ptr: *mut T,\n+    cap: usize,\n+    len: usize,\n+}\n+# fn main() {}\n+```\n+\n+And indeed this would compile. Unfortunately, it would be incorrect. First, the\n+compiler will give us too strict variance. So a `&Vec<&'static str>`\n+couldn't be used where an `&Vec<&'a str>` was expected. More importantly, it\n+will give incorrect ownership information to the drop checker, as it will\n+conservatively assume we don't own any values of type `T`. See [the chapter\n+on ownership and lifetimes][ownership] for all the details on variance and\n+drop check.\n+\n+As we saw in the ownership chapter, we should use `Unique<T>` in place of\n+`*mut T` when we have a raw pointer to an allocation we own. Unique is unstable,\n+so we'd like to not use it if possible, though.\n+\n+As a recap, Unique is a wrapper around a raw pointer that declares that:\n+\n+* We are variant over `T`\n+* We may own a value of type `T` (for drop check)\n+* We are Send/Sync if `T` is Send/Sync\n+* We deref to `*mut T` (so it largely acts like a `*mut` in our code)\n+* Our pointer is never null (so `Option<Vec<T>>` is null-pointer-optimized)\n+\n+We can implement all of the above requirements except for the last\n+one in stable Rust:\n+\n+```rust\n+use std::marker::PhantomData;\n+use std::ops::Deref;\n+use std::mem;\n+\n+struct Unique<T> {\n+    ptr: *const T,              // *const for variance\n+    _marker: PhantomData<T>,    // For the drop checker\n+}\n+\n+// Deriving Send and Sync is safe because we are the Unique owners\n+// of this data. It's like Unique<T> is \"just\" T.\n+unsafe impl<T: Send> Send for Unique<T> {}\n+unsafe impl<T: Sync> Sync for Unique<T> {}\n+\n+impl<T> Unique<T> {\n+    pub fn new(ptr: *mut T) -> Self {\n+        Unique { ptr: ptr, _marker: PhantomData }\n+    }\n+}\n+\n+impl<T> Deref for Unique<T> {\n+    type Target = *mut T;\n+    fn deref(&self) -> &*mut T {\n+        // There's no way to cast the *const to a *mut\n+        // while also taking a reference. So we just\n+        // transmute it since it's all \"just pointers\".\n+        unsafe { mem::transmute(&self.ptr) }\n+    }\n+}\n+# fn main() {}\n+```\n+\n+Unfortunately the mechanism for stating that your value is non-zero is\n+unstable and unlikely to be stabilized soon. As such we're just going to\n+take the hit and use std's Unique:\n+\n+\n+```rust\n+#![feature(unique)]\n+\n+use std::ptr::{Unique, self};\n+\n+pub struct Vec<T> {\n+    ptr: Unique<T>,\n+    cap: usize,\n+    len: usize,\n+}\n+\n+# fn main() {}\n+```\n+\n+If you don't care about the null-pointer optimization, then you can use the\n+stable code. However we will be designing the rest of the code around enabling\n+the optimization. In particular, `Unique::new` is unsafe to call, because\n+putting `null` inside of it is Undefined Behaviour. Our stable Unique doesn't\n+need `new` to be unsafe because it doesn't make any interesting guarantees about\n+its contents.\n+\n+[ownership]: ownership.html"}, {"sha": "2ef15e324b6e9ae2561d83788ca963fc4e7a1004", "filename": "src/doc/tarpl/vec-push-pop.md", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fvec-push-pop.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fvec-push-pop.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-push-pop.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,55 @@\n+% Push and Pop\n+\n+Alright. We can initialize. We can allocate. Let's actually implement some\n+functionality! Let's start with `push`. All it needs to do is check if we're\n+full to grow, unconditionally write to the next index, and then increment our\n+length.\n+\n+To do the write we have to be careful not to evaluate the memory we want to write\n+to. At worst, it's truly uninitialized memory from the allocator. At best it's the\n+bits of some old value we popped off. Either way, we can't just index to the memory\n+and dereference it, because that will evaluate the memory as a valid instance of\n+T. Worse, `foo[idx] = x` will try to call `drop` on the old value of `foo[idx]`!\n+\n+The correct way to do this is with `ptr::write`, which just blindly overwrites the\n+target address with the bits of the value we provide. No evaluation involved.\n+\n+For `push`, if the old len (before push was called) is 0, then we want to write\n+to the 0th index. So we should offset by the old len.\n+\n+```rust,ignore\n+pub fn push(&mut self, elem: T) {\n+    if self.len == self.cap { self.grow(); }\n+\n+    unsafe {\n+        ptr::write(self.ptr.offset(self.len as isize), elem);\n+    }\n+\n+    // Can't fail, we'll OOM first.\n+    self.len += 1;\n+}\n+```\n+\n+Easy! How about `pop`? Although this time the index we want to access is\n+initialized, Rust won't just let us dereference the location of memory to move\n+the value out, because that *would* leave the memory uninitialized! For this we\n+need `ptr::read`, which just copies out the bits from the target address and\n+intrprets it as a value of type T. This will leave the memory at this address\n+*logically* uninitialized, even though there is in fact a perfectly good instance\n+of T there.\n+\n+For `pop`, if the old len is 1, we want to read out of the 0th index. So we\n+should offset by the *new* len.\n+\n+```rust,ignore\n+pub fn pop(&mut self) -> Option<T> {\n+    if self.len == 0 {\n+        None\n+    } else {\n+        self.len -= 1;\n+        unsafe {\n+            Some(ptr::read(self.ptr.offset(self.len as isize)))\n+        }\n+    }\n+}\n+```"}, {"sha": "8f78462cf40271218ccd7d52b69e8fcd63e2d2b2", "filename": "src/doc/tarpl/vec-raw.md", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fvec-raw.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fvec-raw.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-raw.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,136 @@\n+% RawVec\n+\n+We've actually reached an interesting situation here: we've duplicated the logic\n+for specifying a buffer and freeing its memory in Vec and IntoIter. Now that\n+we've implemented it and identified *actual* logic duplication, this is a good\n+time to perform some logic compression.\n+\n+We're going to abstract out the `(ptr, cap)` pair and give them the logic for\n+allocating, growing, and freeing:\n+\n+```rust,ignore\n+struct RawVec<T> {\n+    ptr: Unique<T>,\n+    cap: usize,\n+}\n+\n+impl<T> RawVec<T> {\n+    fn new() -> Self {\n+        assert!(mem::size_of::<T>() != 0, \"TODO: implement ZST support\");\n+        unsafe {\n+            RawVec { ptr: Unique::new(heap::EMPTY as *mut T), cap: 0 }\n+        }\n+    }\n+\n+    // unchanged from Vec\n+    fn grow(&mut self) {\n+        unsafe {\n+            let align = mem::align_of::<T>();\n+            let elem_size = mem::size_of::<T>();\n+\n+            let (new_cap, ptr) = if self.cap == 0 {\n+                let ptr = heap::allocate(elem_size, align);\n+                (1, ptr)\n+            } else {\n+                let new_cap = 2 * self.cap;\n+                let ptr = heap::reallocate(*self.ptr as *mut _,\n+                                            self.cap * elem_size,\n+                                            new_cap * elem_size,\n+                                            align);\n+                (new_cap, ptr)\n+            };\n+\n+            // If allocate or reallocate fail, we'll get `null` back\n+            if ptr.is_null() { oom() }\n+\n+            self.ptr = Unique::new(ptr as *mut _);\n+            self.cap = new_cap;\n+        }\n+    }\n+}\n+\n+\n+impl<T> Drop for RawVec<T> {\n+    fn drop(&mut self) {\n+        if self.cap != 0 {\n+            let align = mem::align_of::<T>();\n+            let elem_size = mem::size_of::<T>();\n+            let num_bytes = elem_size * self.cap;\n+            unsafe {\n+                heap::deallocate(*self.ptr as *mut _, num_bytes, align);\n+            }\n+        }\n+    }\n+}\n+```\n+\n+And change Vec as follows:\n+\n+```rust,ignore\n+pub struct Vec<T> {\n+    buf: RawVec<T>,\n+    len: usize,\n+}\n+\n+impl<T> Vec<T> {\n+    fn ptr(&self) -> *mut T { *self.buf.ptr }\n+\n+    fn cap(&self) -> usize { self.buf.cap }\n+\n+    pub fn new() -> Self {\n+        Vec { buf: RawVec::new(), len: 0 }\n+    }\n+\n+    // push/pop/insert/remove largely unchanged:\n+    // * `self.ptr -> self.ptr()`\n+    // * `self.cap -> self.cap()`\n+    // * `self.grow -> self.buf.grow()`\n+}\n+\n+impl<T> Drop for Vec<T> {\n+    fn drop(&mut self) {\n+        while let Some(_) = self.pop() {}\n+        // deallocation is handled by RawVec\n+    }\n+}\n+```\n+\n+And finally we can really simplify IntoIter:\n+\n+```rust,ignore\n+struct IntoIter<T> {\n+    _buf: RawVec<T>, // we don't actually care about this. Just need it to live.\n+    start: *const T,\n+    end: *const T,\n+}\n+\n+// next and next_back literally unchanged since they never referred to the buf\n+\n+impl<T> Drop for IntoIter<T> {\n+    fn drop(&mut self) {\n+        // only need to ensure all our elements are read;\n+        // buffer will clean itself up afterwards.\n+        for _ in &mut *self {}\n+    }\n+}\n+\n+impl<T> Vec<T> {\n+    pub fn into_iter(self) -> IntoIter<T> {\n+        unsafe {\n+            // need to use ptr::read to unsafely move the buf out since it's\n+            // not Copy, and Vec implements Drop (so we can't destructure it).\n+            let buf = ptr::read(&self.buf);\n+            let len = self.len;\n+            mem::forget(self);\n+\n+            IntoIter {\n+                start: *buf.ptr,\n+                end: buf.ptr.offset(len as isize),\n+                _buf: buf,\n+            }\n+        }\n+    }\n+}\n+```\n+\n+Much better."}, {"sha": "931aed33ef5d5d8312525313f26781cfbedae684", "filename": "src/doc/tarpl/vec-zsts.md", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fvec-zsts.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fvec-zsts.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-zsts.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,176 @@\n+% Handling Zero-Sized Types\n+\n+It's time. We're going to fight the spectre that is zero-sized types. Safe Rust\n+*never* needs to care about this, but Vec is very intensive on raw pointers and\n+raw allocations, which are exactly the *only* two things that care about\n+zero-sized types. We need to be careful of two things:\n+\n+* The raw allocator API has undefined behaviour if you pass in 0 for an\n+  allocation size.\n+* raw pointer offsets are no-ops for zero-sized types, which will break our\n+  C-style pointer iterator.\n+\n+Thankfully we abstracted out pointer-iterators and allocating handling into\n+RawValIter and RawVec respectively. How mysteriously convenient.\n+\n+\n+\n+\n+## Allocating Zero-Sized Types\n+\n+So if the allocator API doesn't support zero-sized allocations, what on earth\n+do we store as our allocation? Why, `heap::EMPTY` of course! Almost every operation\n+with a ZST is a no-op since ZSTs have exactly one value, and therefore no state needs\n+to be considered to store or load them. This actually extends to `ptr::read` and\n+`ptr::write`: they won't actually look at the pointer at all. As such we *never* need\n+to change the pointer.\n+\n+Note however that our previous reliance on running out of memory before overflow is\n+no longer valid with zero-sized types. We must explicitly guard against capacity\n+overflow for zero-sized types.\n+\n+Due to our current architecture, all this means is writing 3 guards, one in each\n+method of RawVec.\n+\n+```rust,ignore\n+impl<T> RawVec<T> {\n+    fn new() -> Self {\n+        unsafe {\n+            // !0 is usize::MAX. This branch should be stripped at compile time.\n+            let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n+\n+            // heap::EMPTY doubles as \"unallocated\" and \"zero-sized allocation\"\n+            RawVec { ptr: Unique::new(heap::EMPTY as *mut T), cap: cap }\n+        }\n+    }\n+\n+    fn grow(&mut self) {\n+        unsafe {\n+            let elem_size = mem::size_of::<T>();\n+\n+            // since we set the capacity to usize::MAX when elem_size is\n+            // 0, getting to here necessarily means the Vec is overfull.\n+            assert!(elem_size != 0, \"capacity overflow\");\n+\n+            let align = mem::align_of::<T>();\n+\n+            let (new_cap, ptr) = if self.cap == 0 {\n+                let ptr = heap::allocate(elem_size, align);\n+                (1, ptr)\n+            } else {\n+                let new_cap = 2 * self.cap;\n+                let ptr = heap::reallocate(*self.ptr as *mut _,\n+                                            self.cap * elem_size,\n+                                            new_cap * elem_size,\n+                                            align);\n+                (new_cap, ptr)\n+            };\n+\n+            // If allocate or reallocate fail, we'll get `null` back\n+            if ptr.is_null() { oom() }\n+\n+            self.ptr = Unique::new(ptr as *mut _);\n+            self.cap = new_cap;\n+        }\n+    }\n+}\n+\n+impl<T> Drop for RawVec<T> {\n+    fn drop(&mut self) {\n+        let elem_size = mem::size_of::<T>();\n+\n+        // don't free zero-sized allocations, as they were never allocated.\n+        if self.cap != 0 && elem_size != 0 {\n+            let align = mem::align_of::<T>();\n+\n+            let num_bytes = elem_size * self.cap;\n+            unsafe {\n+                heap::deallocate(*self.ptr as *mut _, num_bytes, align);\n+            }\n+        }\n+    }\n+}\n+```\n+\n+That's it. We support pushing and popping zero-sized types now. Our iterators\n+(that aren't provided by slice Deref) are still busted, though.\n+\n+\n+\n+\n+## Iterating Zero-Sized Types\n+\n+Zero-sized offsets are no-ops. This means that our current design will always\n+initialize `start` and `end` as the same value, and our iterators will yield\n+nothing. The current solution to this is to cast the pointers to integers,\n+increment, and then cast them back:\n+\n+```rust,ignore\n+impl<T> RawValIter<T> {\n+    unsafe fn new(slice: &[T]) -> Self {\n+        RawValIter {\n+            start: slice.as_ptr(),\n+            end: if mem::size_of::<T>() == 0 {\n+                ((slice.as_ptr() as usize) + slice.len()) as *const _\n+            } else if slice.len() == 0 {\n+                slice.as_ptr()\n+            } else {\n+                slice.as_ptr().offset(slice.len() as isize)\n+            }\n+        }\n+    }\n+}\n+```\n+\n+Now we have a different bug. Instead of our iterators not running at all, our\n+iterators now run *forever*. We need to do the same trick in our iterator impls.\n+Also, our size_hint computation code will divide by 0 for ZSTs. Since we'll\n+basically be treating the two pointers as if they point to bytes, we'll just\n+map size 0 to divide by 1.\n+\n+```rust,ignore\n+impl<T> Iterator for RawValIter<T> {\n+    type Item = T;\n+    fn next(&mut self) -> Option<T> {\n+        if self.start == self.end {\n+            None\n+        } else {\n+            unsafe {\n+                let result = ptr::read(self.start);\n+                self.start = if mem::size_of::<T>() == 0 {\n+                    (self.start as usize + 1) as *const _\n+                } else {\n+                    self.start.offset(1);\n+                }\n+                Some(result)\n+            }\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let elem_size = mem::size_of::<T>();\n+        let len = (self.end as usize - self.start as usize)\n+                  / if elem_size == 0 { 1 } else { elem_size };\n+        (len, Some(len))\n+    }\n+}\n+\n+impl<T> DoubleEndedIterator for RawValIter<T> {\n+    fn next_back(&mut self) -> Option<T> {\n+        if self.start == self.end {\n+            None\n+        } else {\n+            unsafe {\n+                self.end = if mem::size_of::<T>() == 0 {\n+                    (self.end as usize - 1) as *const _\n+                } else {\n+                    self.end.offset(-1);\n+                }\n+                Some(ptr::read(self.end))\n+            }\n+        }\n+    }\n+}\n+```\n+\n+And that's it. Iteration works!"}, {"sha": "63f83788c4bac55a8298fe17874d3fd8f99e94ce", "filename": "src/doc/tarpl/vec.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fvec.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fvec.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,20 @@\n+% Example: Implementing Vec\n+\n+To bring everything together, we're going to write `std::Vec` from scratch.\n+Because all the best tools for writing unsafe code are unstable, this\n+project will only work on nightly (as of Rust 1.2.0). With the exception of the\n+allocator API, much of the unstable code we'll use is expected to be stabilized\n+in a similar form as it is today.\n+\n+However we will generally try to avoid unstable code where possible. In\n+particular we won't use any intrinsics that could make a code a little\n+bit nicer or efficient because intrinsics are permanently unstable. Although\n+many intrinsics *do* become stabilized elsewhere (`std::ptr` and `str::mem`\n+consist of many intrinsics).\n+\n+Ultimately this means our implementation may not take advantage of all\n+possible optimizations, though it will be by no means *naive*. We will\n+definitely get into the weeds over nitty-gritty details, even\n+when the problem doesn't *really* merit it.\n+\n+You wanted advanced. We're gonna go advanced."}, {"sha": "b20dff72e1c6a38cac2f391f648e6bfb2793c4da", "filename": "src/doc/tarpl/working-with-unsafe.md", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fworking-with-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d52d7c85703fdf41eefb852afac140938cf2a64/src%2Fdoc%2Ftarpl%2Fworking-with-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fworking-with-unsafe.md?ref=4d52d7c85703fdf41eefb852afac140938cf2a64", "patch": "@@ -0,0 +1,119 @@\n+% Working with Unsafe\n+\n+Rust generally only gives us the tools to talk about Unsafe Rust in a scoped and\n+binary manner. Unfortunately, reality is significantly more complicated than\n+that. For instance, consider the following toy function:\n+\n+```rust\n+fn index(idx: usize, arr: &[u8]) -> Option<u8> {\n+    if idx < arr.len() {\n+        unsafe {\n+            Some(*arr.get_unchecked(idx))\n+        }\n+    } else {\n+        None\n+    }\n+}\n+```\n+\n+Clearly, this function is safe. We check that the index is in bounds, and if it\n+is, index into the array in an unchecked manner. But even in such a trivial\n+function, the scope of the unsafe block is questionable. Consider changing the\n+`<` to a `<=`:\n+\n+```rust\n+fn index(idx: usize, arr: &[u8]) -> Option<u8> {\n+    if idx <= arr.len() {\n+        unsafe {\n+            Some(*arr.get_unchecked(idx))\n+        }\n+    } else {\n+        None\n+    }\n+}\n+```\n+\n+This program is now unsound, and yet *we only modified safe code*. This is the\n+fundamental problem of safety: it's non-local. The soundness of our unsafe\n+operations necessarily depends on the state established by otherwise\n+\"safe\" operations.\n+\n+Safety is modular in the sense that opting into unsafety doesn't require you\n+to consider arbitrary other kinds of badness. For instance, doing an unchecked\n+index into a slice doesn't mean you suddenly need to worry about the slice being\n+null or containing uninitialized memory. Nothing fundamentally changes. However\n+safety *isn't* modular in the sense that programs are inherently stateful and\n+your unsafe operations may depend on arbitrary other state.\n+\n+Trickier than that is when we get into actual statefulness. Consider a simple\n+implementation of `Vec`:\n+\n+```rust\n+use std::ptr;\n+\n+// Note this definition is insufficient. See the section on implementing Vec.\n+pub struct Vec<T> {\n+    ptr: *mut T,\n+    len: usize,\n+    cap: usize,\n+}\n+\n+// Note this implementation does not correctly handle zero-sized types.\n+// We currently live in a nice imaginary world of only positive fixed-size\n+// types.\n+impl<T> Vec<T> {\n+    pub fn push(&mut self, elem: T) {\n+        if self.len == self.cap {\n+            // not important for this example\n+            self.reallocate();\n+        }\n+        unsafe {\n+            ptr::write(self.ptr.offset(self.len as isize), elem);\n+            self.len += 1;\n+        }\n+    }\n+\n+    # fn reallocate(&mut self) { }\n+}\n+\n+# fn main() {}\n+```\n+\n+This code is simple enough to reasonably audit and verify. Now consider\n+adding the following method:\n+\n+```rust,ignore\n+fn make_room(&mut self) {\n+    // grow the capacity\n+    self.cap += 1;\n+}\n+```\n+\n+This code is 100% Safe Rust but it is also completely unsound. Changing the\n+capacity violates the invariants of Vec (that `cap` reflects the allocated space\n+in the Vec). This is not something the rest of Vec can guard against. It *has*\n+to trust the capacity field because there's no way to verify it.\n+\n+`unsafe` does more than pollute a whole function: it pollutes a whole *module*.\n+Generally, the only bullet-proof way to limit the scope of unsafe code is at the\n+module boundary with privacy.\n+\n+However this works *perfectly*. The existence of `make_room` is *not* a\n+problem for the soundness of Vec because we didn't mark it as public. Only the\n+module that defines this function can call it. Also, `make_room` directly\n+accesses the private fields of Vec, so it can only be written in the same module\n+as Vec.\n+\n+It is therefore possible for us to write a completely safe abstraction that\n+relies on complex invariants. This is *critical* to the relationship between\n+Safe Rust and Unsafe Rust. We have already seen that Unsafe code must trust\n+*some* Safe code, but can't trust *generic* Safe code. It can't trust an\n+arbitrary implementor of a trait or any function that was passed to it to be\n+well-behaved in a way that safe code doesn't care about.\n+\n+However if unsafe code couldn't prevent client safe code from messing with its\n+state in arbitrary ways, safety would be a lost cause. Thankfully, it *can*\n+prevent arbitrary code from messing with critical state due to privacy.\n+\n+Safety lives!\n+"}]}