{"sha": "b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyZjM3OWNkYzIzYWVjNWM1ZDBkNjJhY2ZjYzVhNGExOGViZjBlMzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-23T00:25:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-23T00:25:42Z"}, "message": "Auto merge of #28535 - petrochenkov:name, r=nrc\n\nPart of https://github.com/rust-lang/rust/issues/6993\r\n\r\nThis patch replaces `Ident`s with `Name`s in data structures of HIR and updates the dependent crates to compile and pass `make check`.\r\nSome HIR structures still use `Ident`s, namely `PathSegment`, `PatIdent`, `ExprWhile`, `ExprLoop`, `ExprBreak` and `ExprAgain`,  they need them for resolve (but `PathSegment` is special, see https://github.com/rust-lang/rust/issues/6993#issuecomment-141256292).\r\n\r\nr? @nrc", "tree": {"sha": "5c758f791c9591be310ef5b3197f9bdfe5654896", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c758f791c9591be310ef5b3197f9bdfe5654896"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "html_url": "https://github.com/rust-lang/rust/commit/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad82e0ac180deef65b5757a6e4d7fa79aab5521a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad82e0ac180deef65b5757a6e4d7fa79aab5521a", "html_url": "https://github.com/rust-lang/rust/commit/ad82e0ac180deef65b5757a6e4d7fa79aab5521a"}, {"sha": "0af8e4754632279bf0b6a7143274c5d817f2833d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0af8e4754632279bf0b6a7143274c5d817f2833d", "html_url": "https://github.com/rust-lang/rust/commit/0af8e4754632279bf0b6a7143274c5d817f2833d"}], "stats": {"total": 958, "additions": 485, "deletions": 473}, "files": [{"sha": "7d4809d457c80c37e9739f38e8a3db2a066fd6d9", "filename": "src/librustc/front/map/blocks.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Ffront%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Ffront%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fblocks.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -26,7 +26,7 @@ pub use self::Code::*;\n use front::map::{self, Node};\n use syntax::abi;\n use rustc_front::hir::{Block, FnDecl};\n-use syntax::ast::{NodeId, Ident};\n+use syntax::ast::{Name, NodeId};\n use rustc_front::hir as ast;\n use syntax::codemap::Span;\n use rustc_front::visit::FnKind;\n@@ -107,7 +107,7 @@ impl<'a> Code<'a> {\n /// These are all the components one can extract from a fn item for\n /// use when implementing FnLikeNode operations.\n struct ItemFnParts<'a> {\n-    ident:    Ident,\n+    name:     Name,\n     decl:     &'a ast::FnDecl,\n     unsafety: ast::Unsafety,\n     constness: ast::Constness,\n@@ -189,21 +189,21 @@ impl<'a> FnLikeNode<'a> {\n \n     pub fn kind(self) -> FnKind<'a> {\n         let item = |p: ItemFnParts<'a>| -> FnKind<'a> {\n-            FnKind::ItemFn(p.ident, p.generics, p.unsafety, p.constness, p.abi, p.vis)\n+            FnKind::ItemFn(p.name, p.generics, p.unsafety, p.constness, p.abi, p.vis)\n         };\n         let closure = |_: ClosureParts| {\n             FnKind::Closure\n         };\n-        let method = |_, ident, sig: &'a ast::MethodSig, vis, _, _| {\n-            FnKind::Method(ident, sig, vis)\n+        let method = |_, name: Name, sig: &'a ast::MethodSig, vis, _, _| {\n+            FnKind::Method(name, sig, vis)\n         };\n         self.handle(item, method, closure)\n     }\n \n     fn handle<A, I, M, C>(self, item_fn: I, method: M, closure: C) -> A where\n         I: FnOnce(ItemFnParts<'a>) -> A,\n         M: FnOnce(NodeId,\n-                  Ident,\n+                  Name,\n                   &'a ast::MethodSig,\n                   Option<ast::Visibility>,\n                   &'a ast::Block,\n@@ -216,7 +216,7 @@ impl<'a> FnLikeNode<'a> {\n                 ast::ItemFn(ref decl, unsafety, constness, abi, ref generics, ref block) =>\n                     item_fn(ItemFnParts {\n                         id: i.id,\n-                        ident: i.ident,\n+                        name: i.name,\n                         decl: &**decl,\n                         unsafety: unsafety,\n                         body: &**block,\n@@ -230,14 +230,14 @@ impl<'a> FnLikeNode<'a> {\n             },\n             map::NodeTraitItem(ti) => match ti.node {\n                 ast::MethodTraitItem(ref sig, Some(ref body)) => {\n-                    method(ti.id, ti.ident, sig, None, body, ti.span)\n+                    method(ti.id, ti.name, sig, None, body, ti.span)\n                 }\n                 _ => panic!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n             map::NodeImplItem(ii) => {\n                 match ii.node {\n                     ast::MethodImplItem(ref sig, ref body) => {\n-                        method(ii.id, ii.ident, sig, Some(ii.vis), body, ii.span)\n+                        method(ii.id, ii.name, sig, Some(ii.vis), body, ii.span)\n                     }\n                     _ => {\n                         panic!(\"impl method FnLikeNode that is not fn-like\")"}, {"sha": "74fb1ce18b345e5c8ad2a8af03d97e3f088dc28f", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -17,7 +17,7 @@ use metadata::inline::InlinedItem as II;\n use middle::def_id::DefId;\n \n use syntax::abi;\n-use syntax::ast::{self, Name, NodeId, Ident, CRATE_NODE_ID, DUMMY_NODE_ID};\n+use syntax::ast::{self, Name, NodeId, CRATE_NODE_ID, DUMMY_NODE_ID};\n use syntax::codemap::{Span, Spanned};\n use syntax::parse::token;\n \n@@ -475,15 +475,15 @@ impl<'ast> Map<'ast> {\n             NodeItem(item) => {\n                 match item.node {\n                     ItemMod(_) | ItemForeignMod(_) => {\n-                        PathMod(item.ident.name)\n+                        PathMod(item.name)\n                     }\n-                    _ => PathName(item.ident.name)\n+                    _ => PathName(item.name)\n                 }\n             }\n-            NodeForeignItem(i) => PathName(i.ident.name),\n-            NodeImplItem(ii) => PathName(ii.ident.name),\n-            NodeTraitItem(ti) => PathName(ti.ident.name),\n-            NodeVariant(v) => PathName(v.node.name.name),\n+            NodeForeignItem(i) => PathName(i.name),\n+            NodeImplItem(ii) => PathName(ii.name),\n+            NodeTraitItem(ti) => PathName(ti.name),\n+            NodeVariant(v) => PathName(v.node.name),\n             NodeLifetime(lt) => PathName(lt.name),\n             _ => panic!(\"no path elem for {:?}\", node)\n         }\n@@ -499,9 +499,9 @@ impl<'ast> Map<'ast> {\n         self.with_path(id, |path| path_to_string(path))\n     }\n \n-    fn path_to_str_with_ident(&self, id: NodeId, i: Ident) -> String {\n+    fn path_to_str_with_name(&self, id: NodeId, name: Name) -> String {\n         self.with_path(id, |path| {\n-            path_to_string(path.chain(Some(PathName(i.name))))\n+            path_to_string(path.chain(Some(PathName(name))))\n         })\n     }\n \n@@ -652,7 +652,7 @@ impl<'a, 'ast> NodesMatchingSuffix<'a, 'ast> {\n                 match map.find(id) {\n                     None => return None,\n                     Some(NodeItem(item)) if item_is_mod(&*item) =>\n-                        return Some((id, item.ident.name)),\n+                        return Some((id, item.name)),\n                     _ => {}\n                 }\n                 let parent = map.get_parent(id);\n@@ -708,11 +708,11 @@ trait Named {\n \n impl<T:Named> Named for Spanned<T> { fn name(&self) -> Name { self.node.name() } }\n \n-impl Named for Item { fn name(&self) -> Name { self.ident.name } }\n-impl Named for ForeignItem { fn name(&self) -> Name { self.ident.name } }\n-impl Named for Variant_ { fn name(&self) -> Name { self.name.name } }\n-impl Named for TraitItem { fn name(&self) -> Name { self.ident.name } }\n-impl Named for ImplItem { fn name(&self) -> Name { self.ident.name } }\n+impl Named for Item { fn name(&self) -> Name { self.name } }\n+impl Named for ForeignItem { fn name(&self) -> Name { self.name } }\n+impl Named for Variant_ { fn name(&self) -> Name { self.name } }\n+impl Named for TraitItem { fn name(&self) -> Name { self.name } }\n+impl Named for ImplItem { fn name(&self) -> Name { self.name } }\n \n pub trait FoldOps {\n     fn new_id(&self, id: NodeId) -> NodeId {\n@@ -1040,7 +1040,7 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n \n     match map.find(id) {\n         Some(NodeItem(item)) => {\n-            let path_str = map.path_to_str_with_ident(id, item.ident);\n+            let path_str = map.path_to_str_with_name(id, item.name);\n             let item_str = match item.node {\n                 ItemExternCrate(..) => \"extern crate\",\n                 ItemUse(..) => \"use\",\n@@ -1059,25 +1059,25 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n             format!(\"{} {}{}\", item_str, path_str, id_str)\n         }\n         Some(NodeForeignItem(item)) => {\n-            let path_str = map.path_to_str_with_ident(id, item.ident);\n+            let path_str = map.path_to_str_with_name(id, item.name);\n             format!(\"foreign item {}{}\", path_str, id_str)\n         }\n         Some(NodeImplItem(ii)) => {\n             match ii.node {\n                 ConstImplItem(..) => {\n                     format!(\"assoc const {} in {}{}\",\n-                            ii.ident,\n+                            ii.name,\n                             map.path_to_string(id),\n                             id_str)\n                 }\n                 MethodImplItem(..) => {\n                     format!(\"method {} in {}{}\",\n-                            ii.ident,\n+                            ii.name,\n                             map.path_to_string(id), id_str)\n                 }\n                 TypeImplItem(_) => {\n                     format!(\"assoc type {} in {}{}\",\n-                            ii.ident,\n+                            ii.name,\n                             map.path_to_string(id),\n                             id_str)\n                 }\n@@ -1092,7 +1092,7 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n \n             format!(\"{} {} in {}{}\",\n                     kind,\n-                    ti.ident,\n+                    ti.name,\n                     map.path_to_string(id),\n                     id_str)\n         }"}, {"sha": "ae9c3ce7e0b4689988d6a2d499431d7270561847", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -663,12 +663,12 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n \n     fn visit_struct_def(&mut self,\n                         s: &hir::StructDef,\n-                        ident: ast::Ident,\n+                        name: ast::Name,\n                         g: &hir::Generics,\n                         id: ast::NodeId) {\n-        run_lints!(self, check_struct_def, late_passes, s, ident, g, id);\n+        run_lints!(self, check_struct_def, late_passes, s, name, g, id);\n         hir_visit::walk_struct_def(self, s);\n-        run_lints!(self, check_struct_def_post, late_passes, s, ident, g, id);\n+        run_lints!(self, check_struct_def_post, late_passes, s, name, g, id);\n     }\n \n     fn visit_struct_field(&mut self, s: &hir::StructField) {\n@@ -691,8 +691,8 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n         hir_visit::walk_ty(self, t);\n     }\n \n-    fn visit_ident(&mut self, sp: Span, id: ast::Ident) {\n-        run_lints!(self, check_ident, late_passes, sp, id);\n+    fn visit_name(&mut self, sp: Span, name: ast::Name) {\n+        run_lints!(self, check_name, late_passes, sp, name);\n     }\n \n     fn visit_mod(&mut self, m: &hir::Mod, s: Span, n: ast::NodeId) {"}, {"sha": "b30ac7033b7bc1d55f2cc7ec79d5a8beb4d0c2d7", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -130,7 +130,7 @@ pub trait LintPass {\n // FIXME: eliminate the duplication with `Visitor`. But this also\n // contains a few lint-specific methods with no equivalent in `Visitor`.\n pub trait LateLintPass: LintPass {\n-    fn check_ident(&mut self, _: &LateContext, _: Span, _: ast::Ident) { }\n+    fn check_name(&mut self, _: &LateContext, _: Span, _: ast::Name) { }\n     fn check_crate(&mut self, _: &LateContext, _: &hir::Crate) { }\n     fn check_mod(&mut self, _: &LateContext, _: &hir::Mod, _: Span, _: ast::NodeId) { }\n     fn check_foreign_item(&mut self, _: &LateContext, _: &hir::ForeignItem) { }\n@@ -150,9 +150,9 @@ pub trait LateLintPass: LintPass {\n     fn check_trait_item(&mut self, _: &LateContext, _: &hir::TraitItem) { }\n     fn check_impl_item(&mut self, _: &LateContext, _: &hir::ImplItem) { }\n     fn check_struct_def(&mut self, _: &LateContext,\n-        _: &hir::StructDef, _: ast::Ident, _: &hir::Generics, _: ast::NodeId) { }\n+        _: &hir::StructDef, _: ast::Name, _: &hir::Generics, _: ast::NodeId) { }\n     fn check_struct_def_post(&mut self, _: &LateContext,\n-        _: &hir::StructDef, _: ast::Ident, _: &hir::Generics, _: ast::NodeId) { }\n+        _: &hir::StructDef, _: ast::Name, _: &hir::Generics, _: ast::NodeId) { }\n     fn check_struct_field(&mut self, _: &LateContext, _: &hir::StructField) { }\n     fn check_variant(&mut self, _: &LateContext, _: &hir::Variant, _: &hir::Generics) { }\n     fn check_variant_post(&mut self, _: &LateContext, _: &hir::Variant, _: &hir::Generics) { }"}, {"sha": "8a879815980361d2e99dcf2ce85f80f55f918877", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -201,17 +201,17 @@ impl<'a> CrateReader<'a> {\n         match i.node {\n             hir::ItemExternCrate(ref path_opt) => {\n                 debug!(\"resolving extern crate stmt. ident: {} path_opt: {:?}\",\n-                       i.ident, path_opt);\n+                       i.name, path_opt);\n                 let name = match *path_opt {\n                     Some(name) => {\n                         validate_crate_name(Some(self.sess), &name.as_str(),\n                                             Some(i.span));\n                         name.to_string()\n                     }\n-                    None => i.ident.to_string(),\n+                    None => i.name.to_string(),\n                 };\n                 Some(CrateInfo {\n-                    ident: i.ident.to_string(),\n+                    ident: i.name.to_string(),\n                     name: name,\n                     id: i.id,\n                     should_link: should_link_hir(i),"}, {"sha": "b19c0f2ecc5d2f9f490aba6062fd189243102114", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -426,16 +426,16 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n         // encoded metadata for static methods relative to Bar,\n         // but not yet for Foo.\n         //\n-        if path_differs || item.ident.name != exp.name {\n+        if path_differs || item.name != exp.name {\n             if !encode_reexported_static_base_methods(ecx, rbml_w, exp) {\n                 if encode_reexported_static_trait_methods(ecx, rbml_w, exp) {\n                     debug!(\"(encode reexported static methods) {} [trait]\",\n-                           item.ident.name);\n+                           item.name);\n                 }\n             }\n             else {\n                 debug!(\"(encode reexported static methods) {} [base]\",\n-                       item.ident.name);\n+                       item.name);\n             }\n         }\n     }\n@@ -520,7 +520,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n         });\n \n         if let hir::ItemImpl(..) = item.node {\n-            let (ident, did) = (item.ident, item.id);\n+            let (ident, did) = (item.name, item.id);\n             debug!(\"(encoding info for module) ... encoding impl {} ({}/{})\",\n                    ident,\n                    did, ecx.tcx.map.node_to_string(did));\n@@ -1014,7 +1014,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         }\n         encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n         encode_symbol(ecx, rbml_w, item.id);\n-        encode_name(rbml_w, item.ident.name);\n+        encode_name(rbml_w, item.name);\n         encode_path(rbml_w, path);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n@@ -1027,7 +1027,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, 'C');\n         encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n-        encode_name(rbml_w, item.ident.name);\n+        encode_name(rbml_w, item.name);\n         encode_path(rbml_w, path);\n         encode_attributes(rbml_w, &item.attrs);\n         encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n@@ -1042,7 +1042,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_family(rbml_w, FN_FAMILY);\n         let tps_len = generics.ty_params.len();\n         encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n-        encode_name(rbml_w, item.ident.name);\n+        encode_name(rbml_w, item.name);\n         encode_path(rbml_w, path);\n         encode_attributes(rbml_w, &item.attrs);\n         let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n@@ -1066,15 +1066,15 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                             &item.attrs,\n                             item.id,\n                             path,\n-                            item.ident.name,\n+                            item.name,\n                             item.vis);\n       }\n       hir::ItemForeignMod(ref fm) => {\n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, 'n');\n-        encode_name(rbml_w, item.ident.name);\n+        encode_name(rbml_w, item.name);\n         encode_path(rbml_w, path);\n \n         // Encode all the items in this module.\n@@ -1092,7 +1092,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, 'y');\n         encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n-        encode_name(rbml_w, item.ident.name);\n+        encode_name(rbml_w, item.name);\n         encode_path(rbml_w, path);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n@@ -1106,7 +1106,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_family(rbml_w, 't');\n         encode_item_variances(rbml_w, ecx, item.id);\n         encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n-        encode_name(rbml_w, item.ident.name);\n+        encode_name(rbml_w, item.name);\n         encode_attributes(rbml_w, &item.attrs);\n         encode_repr_attrs(rbml_w, ecx, &item.attrs);\n         for v in &enum_definition.variants {\n@@ -1146,7 +1146,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n \n         encode_item_variances(rbml_w, ecx, item.id);\n-        encode_name(rbml_w, item.ident.name);\n+        encode_name(rbml_w, item.name);\n         encode_attributes(rbml_w, &item.attrs);\n         encode_path(rbml_w, path.clone());\n         encode_stability(rbml_w, stab);\n@@ -1168,7 +1168,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // If this is a tuple-like struct, encode the type of the constructor.\n         match struct_def.ctor_id {\n             Some(ctor_id) => {\n-                encode_info_for_struct_ctor(ecx, rbml_w, item.ident.name,\n+                encode_info_for_struct_ctor(ecx, rbml_w, item.name,\n                                             ctor_id, index, def_id.node);\n             }\n             None => {}\n@@ -1179,7 +1179,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n           rbml_w.start_tag(tag_items_data_item);\n           encode_def_id(rbml_w, def_id);\n           encode_family(rbml_w, 'd');\n-          encode_name(rbml_w, item.ident.name);\n+          encode_name(rbml_w, item.name);\n           encode_unsafety(rbml_w, unsafety);\n \n           let trait_ref = tcx.impl_trait_ref(DefId::local(item.id)).unwrap();\n@@ -1197,7 +1197,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, 'i');\n         encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n-        encode_name(rbml_w, item.ident.name);\n+        encode_name(rbml_w, item.name);\n         encode_attributes(rbml_w, &item.attrs);\n         encode_unsafety(rbml_w, unsafety);\n         encode_polarity(rbml_w, polarity);\n@@ -1306,7 +1306,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_predicates(rbml_w, ecx, &tcx.lookup_super_predicates(def_id),\n                           tag_item_super_predicates);\n         encode_trait_ref(rbml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n-        encode_name(rbml_w, item.ident.name);\n+        encode_name(rbml_w, item.name);\n         encode_attributes(rbml_w, &item.attrs);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n@@ -1483,7 +1483,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n       hir::ForeignItemFn(ref fndecl, _) => {\n         encode_family(rbml_w, FN_FAMILY);\n         encode_bounds_and_type_for_item(rbml_w, ecx, nitem.id);\n-        encode_name(rbml_w, nitem.ident.name);\n+        encode_name(rbml_w, nitem.name);\n         if abi == abi::RustIntrinsic || abi == abi::PlatformIntrinsic {\n             encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(nitem));\n         }\n@@ -1504,7 +1504,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         let stab = stability::lookup(ecx.tcx, DefId::local(nitem.id));\n         encode_stability(rbml_w, stab);\n         encode_symbol(ecx, rbml_w, nitem.id);\n-        encode_name(rbml_w, nitem.ident.name);\n+        encode_name(rbml_w, nitem.name);\n       }\n     }\n     encode_path(rbml_w, path);\n@@ -1528,7 +1528,7 @@ fn my_visit_foreign_item(ni: &hir::ForeignItem,\n                          index: &mut Vec<IndexEntry>) {\n     debug!(\"writing foreign item {}::{}\",\n             ecx.tcx.map.path_to_string(ni.id),\n-            ni.ident);\n+            ni.name);\n \n     let abi = ecx.tcx.map.get_foreign_abi(ni.id);\n     ecx.tcx.map.with_path(ni.id, |path| {\n@@ -1787,7 +1787,7 @@ fn encode_macro_defs(rbml_w: &mut Encoder,\n     for def in &krate.exported_macros {\n         rbml_w.start_tag(tag_macro_def);\n \n-        encode_name(rbml_w, def.ident.name);\n+        encode_name(rbml_w, def.name);\n         encode_attributes(rbml_w, &def.attrs);\n \n         rbml_w.wr_tagged_str(tag_macro_def_body,"}, {"sha": "270734a21e23977240fe6f2ac2d572d8945782ec", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -155,16 +155,16 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n         let raw_ii = decode_ast(ast_doc);\n         let ii = ast_map::map_decoded_item(&dcx.tcx.map, path, raw_ii, dcx);\n \n-        let ident = match *ii {\n-            InlinedItem::Item(ref i) => i.ident,\n-            InlinedItem::Foreign(ref i) => i.ident,\n-            InlinedItem::TraitItem(_, ref ti) => ti.ident,\n-            InlinedItem::ImplItem(_, ref ii) => ii.ident\n+        let name = match *ii {\n+            InlinedItem::Item(ref i) => i.name,\n+            InlinedItem::Foreign(ref i) => i.name,\n+            InlinedItem::TraitItem(_, ref ti) => ti.name,\n+            InlinedItem::ImplItem(_, ref ii) => ii.name\n         };\n-        debug!(\"Fn named: {}\", ident);\n+        debug!(\"Fn named: {}\", name);\n         debug!(\"< Decoded inlined fn: {}::{}\",\n                path_as_str.unwrap(),\n-               ident);\n+               name);\n         region::resolve_inlined_item(&tcx.sess, &tcx.region_maps, ii);\n         decode_side_tables(dcx, ast_doc);\n         match *ii {"}, {"sha": "40d7b63cff9bb277d9b100722f180c3c15e75cf7", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -526,7 +526,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n                     .map(|(field, pat)| Spanned {\n                         span: DUMMY_SP,\n                         node: hir::FieldPat {\n-                            ident: ast::Ident::new(field.name),\n+                            name: field.name,\n                             pat: pat,\n                             is_shorthand: false,\n                         }\n@@ -910,7 +910,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             let def_variant = adt.variant_of_def(def);\n             if variant.did == def_variant.did {\n                 Some(variant.fields.iter().map(|sf| {\n-                    match pattern_fields.iter().find(|f| f.node.ident.name == sf.name) {\n+                    match pattern_fields.iter().find(|f| f.node.name == sf.name) {\n                         Some(ref f) => &*f.node.pat,\n                         _ => DUMMY_WILD_PAT\n                     }"}, {"sha": "4894a78f1acb4b6fd9bd5a6884381b15f90aa65a", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -314,7 +314,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<hir::Pat>\n             let field_pats = fields.iter().map(|field| codemap::Spanned {\n                 span: codemap::DUMMY_SP,\n                 node: hir::FieldPat {\n-                    ident: field.ident.node,\n+                    name: field.name.node,\n                     pat: const_expr_to_pat(tcx, &*field.expr, span),\n                     is_shorthand: false,\n                 },\n@@ -1040,8 +1040,8 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                 if let hir::ExprStruct(_, ref fields, _) = tcx.map.expect_expr(struct_id).node {\n                     // Check that the given field exists and evaluate it\n                     // if the idents are compared run-pass/issue-19244 fails\n-                    if let Some(f) = fields.iter().find(|f| f.ident.node.name\n-                                                         == field_name.node.name) {\n+                    if let Some(f) = fields.iter().find(|f| f.name.node\n+                                                         == field_name.node) {\n                         return eval_const_expr_partial(tcx, &*f.expr, base_hint)\n                     } else {\n                         signal!(e, MissingStructField);\n@@ -1109,7 +1109,7 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n     match selection {\n         traits::VtableImpl(ref impl_data) => {\n             match tcx.associated_consts(impl_data.impl_def_id)\n-                     .iter().find(|ic| ic.name == ti.ident.name) {\n+                     .iter().find(|ic| ic.name == ti.name) {\n                 Some(ic) => lookup_const_by_id(tcx, ic.def_id, None),\n                 None => match ti.node {\n                     hir::ConstTraitItem(_, Some(ref expr)) => Some(&*expr),"}, {"sha": "92592f049e0b19184d6644fb285cc36bb17e38e8", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -137,7 +137,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             if let hir::PatWild(hir::PatWildSingle) = pat.node.pat.node {\n                 continue;\n             }\n-            self.live_symbols.insert(variant.field_named(pat.node.ident.name).did.node);\n+            self.live_symbols.insert(variant.field_named(pat.node.name).did.node);\n         }\n     }\n \n@@ -207,7 +207,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n \n-    fn visit_struct_def(&mut self, def: &hir::StructDef, _: ast::Ident,\n+    fn visit_struct_def(&mut self, def: &hir::StructDef, _: ast::Name,\n                         _: &hir::Generics, _: ast::NodeId) {\n         let has_extern_repr = self.struct_has_extern_repr;\n         let inherited_pub_visibility = self.inherited_pub_visibility;\n@@ -227,8 +227,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n             hir::ExprMethodCall(..) => {\n                 self.lookup_and_handle_method(expr.id);\n             }\n-            hir::ExprField(ref lhs, ref ident) => {\n-                self.handle_field_access(&**lhs, ident.node.name);\n+            hir::ExprField(ref lhs, ref name) => {\n+                self.handle_field_access(&**lhs, name.node);\n             }\n             hir::ExprTupField(ref lhs, idx) => {\n                 self.handle_tup_field_access(&**lhs, idx.node);\n@@ -443,7 +443,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     }\n \n     fn should_warn_about_field(&mut self, node: &hir::StructField_) -> bool {\n-        let is_named = node.ident().is_some();\n+        let is_named = node.name().is_some();\n         let field_type = self.tcx.node_id_to_type(node.id);\n         let is_marker_field = match field_type.ty_to_def_id() {\n             Some(def_id) => self.tcx.lang_items.items().any(|(_, item)| *item == Some(def_id)),\n@@ -520,7 +520,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n             self.warn_dead_code(\n                 item.id,\n                 item.span,\n-                item.ident.name,\n+                item.name,\n                 item.node.descriptive_variant()\n             );\n         } else {\n@@ -529,7 +529,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n                     for variant in &enum_def.variants {\n                         if self.should_warn_about_variant(&variant.node) {\n                             self.warn_dead_code(variant.node.id, variant.span,\n-                                                variant.node.name.name, \"variant\");\n+                                                variant.node.name, \"variant\");\n                         }\n                     }\n                 },\n@@ -541,15 +541,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, fi: &hir::ForeignItem) {\n         if !self.symbol_is_live(fi.id, None) {\n-            self.warn_dead_code(fi.id, fi.span, fi.ident.name, fi.node.descriptive_variant());\n+            self.warn_dead_code(fi.id, fi.span, fi.name, fi.node.descriptive_variant());\n         }\n         visit::walk_foreign_item(self, fi);\n     }\n \n     fn visit_struct_field(&mut self, field: &hir::StructField) {\n         if self.should_warn_about_field(&field.node) {\n             self.warn_dead_code(field.node.id, field.span,\n-                                field.node.ident().unwrap().name, \"struct field\");\n+                                field.node.name().unwrap(), \"struct field\");\n         }\n \n         visit::walk_struct_field(self, field);\n@@ -560,14 +560,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n             hir::ConstImplItem(_, ref expr) => {\n                 if !self.symbol_is_live(impl_item.id, None) {\n                     self.warn_dead_code(impl_item.id, impl_item.span,\n-                                        impl_item.ident.name, \"associated const\");\n+                                        impl_item.name, \"associated const\");\n                 }\n                 visit::walk_expr(self, expr)\n             }\n             hir::MethodImplItem(_, ref body) => {\n                 if !self.symbol_is_live(impl_item.id, None) {\n                     self.warn_dead_code(impl_item.id, impl_item.span,\n-                                        impl_item.ident.name, \"method\");\n+                                        impl_item.name, \"method\");\n                 }\n                 visit::walk_block(self, body)\n             }"}, {"sha": "4b45aedd47640c9dfb69026e5a6572b0af792966", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -85,7 +85,7 @@ fn entry_point_type(item: &Item, depth: usize) -> EntryPointType {\n                 EntryPointType::Start\n             } else if attr::contains_name(&item.attrs, \"main\") {\n                 EntryPointType::MainAttr\n-            } else if item.ident.name == \"main\" {\n+            } else if item.name == \"main\" {\n                 if depth == 1 {\n                     // This is a top-level function so can be 'main'\n                     EntryPointType::MainNamed"}, {"sha": "a8eb109398a78395af9ec8fe99644a69536ce481", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -710,7 +710,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                                 -> bool\n         {\n             fields.iter().any(\n-                |f| f.ident.node.name == field.name)\n+                |f| f.name.node == field.name)\n         }\n     }\n "}, {"sha": "fa2856e2f30c3793342c352359a24b5e09ce69ec", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -284,7 +284,7 @@ trait ErrorReportingHelpers<'tcx> {\n                                 decl: &hir::FnDecl,\n                                 unsafety: hir::Unsafety,\n                                 constness: hir::Constness,\n-                                ident: ast::Ident,\n+                                name: ast::Name,\n                                 opt_explicit_self: Option<&hir::ExplicitSelf_>,\n                                 generics: &hir::Generics,\n                                 span: Span);\n@@ -978,7 +978,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     match item.node {\n                         hir::ItemFn(ref fn_decl, unsafety, constness, _, ref gen, _) => {\n                             Some((fn_decl, gen, unsafety, constness,\n-                                  item.ident, None, item.span))\n+                                  item.name, None, item.span))\n                         },\n                         _ => None\n                     }\n@@ -990,7 +990,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                   &sig.generics,\n                                   sig.unsafety,\n                                   sig.constness,\n-                                  item.ident,\n+                                  item.name,\n                                   Some(&sig.explicit_self.node),\n                                   item.span))\n                         }\n@@ -1004,7 +1004,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                   &sig.generics,\n                                   sig.unsafety,\n                                   sig.constness,\n-                                  item.ident,\n+                                  item.name,\n                                   Some(&sig.explicit_self.node),\n                                   item.span))\n                         }\n@@ -1198,7 +1198,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                                                       lifetime,\n                                                       region_names);\n             hir::TyParam {\n-                ident: ty_param.ident,\n+                name: ty_param.name,\n                 id: ty_param.id,\n                 bounds: bounds,\n                 default: ty_param.default.clone(),\n@@ -1541,7 +1541,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                 let new_bindings = data.bindings.map(|b| {\n                     P(hir::TypeBinding {\n                         id: b.id,\n-                        ident: b.ident,\n+                        name: b.name,\n                         ty: self.rebuild_arg_ty_or_output(&*b.ty,\n                                                           lifetime,\n                                                           anon_nums,\n@@ -1576,11 +1576,11 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                                 decl: &hir::FnDecl,\n                                 unsafety: hir::Unsafety,\n                                 constness: hir::Constness,\n-                                ident: ast::Ident,\n+                                name: ast::Name,\n                                 opt_explicit_self: Option<&hir::ExplicitSelf_>,\n                                 generics: &hir::Generics,\n                                 span: Span) {\n-        let suggested_fn = pprust::fun_to_string(decl, unsafety, constness, ident,\n+        let suggested_fn = pprust::fun_to_string(decl, unsafety, constness, name,\n                                                  opt_explicit_self, generics);\n         let msg = format!(\"consider using an explicit lifetime \\\n                            parameter as shown: {}\", suggested_fn);"}, {"sha": "2e7d9e89824439e075fe11a6a09ddb9d42e81680", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -474,7 +474,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                    expr.id,\n                    expr,\n                    base_cmt);\n-            Ok(self.cat_field(expr, base_cmt, f_name.node.name, expr_ty))\n+            Ok(self.cat_field(expr, base_cmt, f_name.node, expr_ty))\n           }\n \n           hir::ExprTupField(ref base, idx) => {\n@@ -1272,7 +1272,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             // {f1: p1, ..., fN: pN}\n             for fp in field_pats {\n                 let field_ty = try!(self.pat_ty(&*fp.node.pat)); // see (*2)\n-                let cmt_field = self.cat_field(pat, cmt.clone(), fp.node.ident.name, field_ty);\n+                let cmt_field = self.cat_field(pat, cmt.clone(), fp.node.name, field_ty);\n                 try!(self.cat_pattern_(cmt_field, &*fp.node.pat, op));\n             }\n           }"}, {"sha": "6f55ddfdfd2017dc013a2c20a78d1c469c8aec19", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -16,7 +16,7 @@ use util::nodemap::FnvHashMap;\n use syntax::ast;\n use rustc_front::hir;\n use rustc_front::util::walk_pat;\n-use syntax::codemap::{Span, DUMMY_SP};\n+use syntax::codemap::{Span, Spanned, DUMMY_SP};\n \n pub type PatIdMap = FnvHashMap<ast::Ident, ast::NodeId>;\n \n@@ -109,7 +109,7 @@ pub fn pat_is_binding_or_wild(dm: &DefMap, pat: &hir::Pat) -> bool {\n /// Call `it` on every \"binding\" in a pattern, e.g., on `a` in\n /// `match foo() { Some(a) => (), None => () }`\n pub fn pat_bindings<I>(dm: &DefMap, pat: &hir::Pat, mut it: I) where\n-    I: FnMut(hir::BindingMode, ast::NodeId, Span, &hir::SpannedIdent),\n+    I: FnMut(hir::BindingMode, ast::NodeId, Span, &Spanned<ast::Ident>),\n {\n     walk_pat(pat, |p| {\n         match p.node {"}, {"sha": "bc83f42b90860d734f4bfb34bcb632407f86cd81", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -336,7 +336,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n         // When compiling with --test we don't enforce stability on the\n         // compiler-generated test module, demarcated with `DUMMY_SP` plus the\n         // name `__test`\n-        if item.span == DUMMY_SP && item.ident.name == \"__test\" { return }\n+        if item.span == DUMMY_SP && item.name == \"__test\" { return }\n \n         check_item(self.tcx, item, true,\n                    &mut |id, sp, stab| self.check(id, sp, stab));\n@@ -393,7 +393,7 @@ pub fn check_item(tcx: &ty::ctxt, item: &hir::Item, warn_about_defns: bool,\n \n             for impl_item in impl_items {\n                 let item = trait_items.iter().find(|item| {\n-                    item.name() == impl_item.ident.name\n+                    item.name() == impl_item.name\n                 }).unwrap();\n                 if warn_about_defns {\n                     maybe_do_stability_check(tcx, item.def_id(), impl_item.span, cb);\n@@ -418,7 +418,7 @@ pub fn check_expr(tcx: &ty::ctxt, e: &hir::Expr,\n         hir::ExprField(ref base_e, ref field) => {\n             span = field.span;\n             match tcx.expr_ty_adjusted(base_e).sty {\n-                ty::TyStruct(def, _) => def.struct_variant().field_named(field.node.name).did,\n+                ty::TyStruct(def, _) => def.struct_variant().field_named(field.node).did,\n                 _ => tcx.sess.span_bug(e.span,\n                                        \"stability::check_expr: named field access on non-struct\")\n             }\n@@ -441,7 +441,7 @@ pub fn check_expr(tcx: &ty::ctxt, e: &hir::Expr,\n                     // in the construction expression.\n                     for field in expr_fields {\n                         let did = def.struct_variant()\n-                            .field_named(field.ident.node.name)\n+                            .field_named(field.name.node)\n                             .did;\n                         maybe_do_stability_check(tcx, did, field.span, cb);\n                     }\n@@ -513,7 +513,7 @@ pub fn check_pat(tcx: &ty::ctxt, pat: &hir::Pat,\n         // Foo { a, b, c }\n         hir::PatStruct(_, ref pat_fields, _) => {\n             for field in pat_fields {\n-                let did = v.field_named(field.node.ident.name).did;\n+                let did = v.field_named(field.node.name).did;\n                 maybe_do_stability_check(tcx, did, field.span, cb);\n             }\n         }"}, {"sha": "7004e72f8f581685a0533a31f94cf21172ba797d", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -131,7 +131,7 @@ mod svh_visitor {\n     pub use self::SawExprComponent::*;\n     pub use self::SawStmtComponent::*;\n     use self::SawAbiComponent::*;\n-    use syntax::ast::{self, NodeId, Ident};\n+    use syntax::ast::{self, Name, NodeId};\n     use syntax::codemap::Span;\n     use syntax::parse::token;\n     use rustc_front::visit;\n@@ -270,7 +270,7 @@ mod svh_visitor {\n             ExprBlock(..)            => SawExprBlock,\n             ExprAssign(..)           => SawExprAssign,\n             ExprAssignOp(op, _, _)   => SawExprAssignOp(op.node),\n-            ExprField(_, id)         => SawExprField(id.node.name.as_str()),\n+            ExprField(_, name)       => SawExprField(name.node.as_str()),\n             ExprTupField(_, id)      => SawExprTupField(id.node),\n             ExprIndex(..)            => SawExprIndex,\n             ExprRange(..)            => SawExprRange,\n@@ -302,9 +302,9 @@ mod svh_visitor {\n     }\n \n     impl<'a, 'v> Visitor<'v> for StrictVersionHashVisitor<'a> {\n-        fn visit_struct_def(&mut self, s: &StructDef, ident: Ident,\n+        fn visit_struct_def(&mut self, s: &StructDef, name: Name,\n                             g: &Generics, _: NodeId) {\n-            SawStructDef(ident.name.as_str()).hash(self.st);\n+            SawStructDef(name.as_str()).hash(self.st);\n             visit::walk_generics(self, g);\n             visit::walk_struct_def(self, s)\n         }\n@@ -341,8 +341,8 @@ mod svh_visitor {\n         // (If you edit a method such that it deviates from the\n         // pattern, please move that method up above this comment.)\n \n-        fn visit_ident(&mut self, _: Span, ident: Ident) {\n-            SawIdent(ident.name.as_str()).hash(self.st);\n+        fn visit_name(&mut self, _: Span, name: Name) {\n+            SawIdent(name.as_str()).hash(self.st);\n         }\n \n         fn visit_lifetime_ref(&mut self, l: &Lifetime) {"}, {"sha": "cf98b1bd8fda2b32df1b65615813e668545285d4", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -195,7 +195,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                       -> Option<ast::NodeId> {\n             assert!(idx < names.len());\n             for item in &m.items {\n-                if item.ident.to_string() == names[idx] {\n+                if item.name.to_string() == names[idx] {\n                     return search(this, &**item, idx+1, names);\n                 }\n             }"}, {"sha": "8ef0b5e6648b9b4e4df79770c6e86e510330a14a", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 30, "deletions": 22, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -12,7 +12,7 @@\n //! and returns a piece of the same type.\n \n use hir::*;\n-use syntax::ast::{Ident, NodeId, DUMMY_NODE_ID, Attribute, Attribute_, MetaItem};\n+use syntax::ast::{Ident, Name, NodeId, DUMMY_NODE_ID, Attribute, Attribute_, MetaItem};\n use syntax::ast::{MetaWord, MetaList, MetaNameValue};\n use hir;\n use syntax::codemap::{respan, Span, Spanned};\n@@ -147,6 +147,10 @@ pub trait Folder : Sized {\n         noop_fold_variant(v, self)\n     }\n \n+    fn fold_name(&mut self, n: Name) -> Name {\n+        noop_fold_name(n, self)\n+    }\n+\n     fn fold_ident(&mut self, i: Ident) -> Ident {\n         noop_fold_ident(i, self)\n     }\n@@ -351,9 +355,9 @@ pub fn noop_fold_decl<T: Folder>(d: P<Decl>, fld: &mut T) -> SmallVector<P<Decl>\n }\n \n pub fn noop_fold_ty_binding<T: Folder>(b: P<TypeBinding>, fld: &mut T) -> P<TypeBinding> {\n-    b.map(|TypeBinding { id, ident, ty, span }| TypeBinding {\n+    b.map(|TypeBinding { id, name, ty, span }| TypeBinding {\n         id: fld.new_id(id),\n-        ident: ident,\n+        name: name,\n         ty: fld.fold_ty(ty),\n         span: fld.new_span(span),\n     })\n@@ -435,6 +439,10 @@ pub fn noop_fold_variant<T: Folder>(v: P<Variant>, fld: &mut T) -> P<Variant> {\n     })\n }\n \n+pub fn noop_fold_name<T: Folder>(n: Name, _: &mut T) -> Name {\n+    n\n+}\n+\n pub fn noop_fold_ident<T: Folder>(i: Ident, _: &mut T) -> Ident {\n     i\n }\n@@ -572,10 +580,10 @@ pub fn noop_fold_ty_param_bound<T>(tpb: TyParamBound, fld: &mut T)\n }\n \n pub fn noop_fold_ty_param<T: Folder>(tp: TyParam, fld: &mut T) -> TyParam {\n-    let TyParam {id, ident, bounds, default, span} = tp;\n+    let TyParam {id, name, bounds, default, span} = tp;\n     TyParam {\n         id: fld.new_id(id),\n-        ident: ident,\n+        name: name,\n         bounds: fld.fold_bounds(bounds),\n         default: default.map(|x| fld.fold_ty(x)),\n         span: span\n@@ -717,9 +725,9 @@ pub fn noop_fold_struct_field<T: Folder>(f: StructField, fld: &mut T) -> StructF\n     }\n }\n \n-pub fn noop_fold_field<T: Folder>(Field {ident, expr, span}: Field, folder: &mut T) -> Field {\n+pub fn noop_fold_field<T: Folder>(Field {name, expr, span}: Field, folder: &mut T) -> Field {\n     Field {\n-        ident: respan(ident.span, folder.fold_ident(ident.node)),\n+        name: respan(folder.new_span(name.span), folder.fold_name(name.node)),\n         expr: folder.fold_expr(expr),\n         span: folder.new_span(span)\n     }\n@@ -833,9 +841,9 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n \n pub fn noop_fold_trait_item<T: Folder>(i: P<TraitItem>, folder: &mut T)\n                                        -> SmallVector<P<TraitItem>> {\n-    SmallVector::one(i.map(|TraitItem {id, ident, attrs, node, span}| TraitItem {\n+    SmallVector::one(i.map(|TraitItem {id, name, attrs, node, span}| TraitItem {\n         id: folder.new_id(id),\n-        ident: folder.fold_ident(ident),\n+        name: folder.fold_name(name),\n         attrs: fold_attrs(attrs, folder),\n         node: match node {\n             ConstTraitItem(ty, default) => {\n@@ -857,9 +865,9 @@ pub fn noop_fold_trait_item<T: Folder>(i: P<TraitItem>, folder: &mut T)\n \n pub fn noop_fold_impl_item<T: Folder>(i: P<ImplItem>, folder: &mut T)\n                                       -> SmallVector<P<ImplItem>> {\n-    SmallVector::one(i.map(|ImplItem {id, ident, attrs, node, vis, span}| ImplItem {\n+    SmallVector::one(i.map(|ImplItem {id, name, attrs, node, vis, span}| ImplItem {\n         id: folder.new_id(id),\n-        ident: folder.fold_ident(ident),\n+        name: folder.fold_name(name),\n         attrs: fold_attrs(attrs, folder),\n         vis: vis,\n         node: match node  {\n@@ -888,7 +896,7 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, span, exported_m\n     let config = folder.fold_meta_items(config);\n \n     let mut items = folder.fold_item(P(hir::Item {\n-        ident: token::special_idents::invalid,\n+        name: token::special_idents::invalid.name,\n         attrs: attrs,\n         id: DUMMY_NODE_ID,\n         vis: hir::Public,\n@@ -928,7 +936,7 @@ pub fn noop_fold_item<T: Folder>(i: P<Item>, folder: &mut T) -> SmallVector<P<It\n }\n \n // fold one item into exactly one item\n-pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span}: Item,\n+pub fn noop_fold_item_simple<T: Folder>(Item {id, name, attrs, node, vis, span}: Item,\n                                         folder: &mut T) -> Item {\n     let id = folder.new_id(id);\n     let node = folder.fold_item_underscore(node);\n@@ -943,7 +951,7 @@ pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span}\n \n     Item {\n         id: id,\n-        ident: folder.fold_ident(ident),\n+        name: folder.fold_name(name),\n         attrs: fold_attrs(attrs, folder),\n         node: node,\n         vis: vis,\n@@ -952,9 +960,9 @@ pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span}\n }\n \n pub fn noop_fold_foreign_item<T: Folder>(ni: P<ForeignItem>, folder: &mut T) -> P<ForeignItem> {\n-    ni.map(|ForeignItem {id, ident, attrs, node, span, vis}| ForeignItem {\n+    ni.map(|ForeignItem {id, name, attrs, node, span, vis}| ForeignItem {\n         id: folder.new_id(id),\n-        ident: folder.fold_ident(ident),\n+        name: folder.fold_name(name),\n         attrs: fold_attrs(attrs, folder),\n         node: match node {\n             ForeignItemFn(fdec, generics) => {\n@@ -1005,7 +1013,7 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n                 let fs = fields.move_map(|f| {\n                     Spanned { span: folder.new_span(f.span),\n                               node: hir::FieldPat {\n-                                  ident: f.node.ident,\n+                                  name: f.node.name,\n                                   pat: folder.fold_pat(f.node.pat),\n                                   is_shorthand: f.node.is_shorthand,\n                               }}\n@@ -1046,9 +1054,9 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n                 ExprCall(folder.fold_expr(f),\n                          args.move_map(|x| folder.fold_expr(x)))\n             }\n-            ExprMethodCall(i, tps, args) => {\n+            ExprMethodCall(name, tps, args) => {\n                 ExprMethodCall(\n-                    respan(folder.new_span(i.span), folder.fold_ident(i.node)),\n+                    respan(folder.new_span(name.span), folder.fold_name(name.node)),\n                     tps.move_map(|x| folder.fold_ty(x)),\n                     args.move_map(|x| folder.fold_expr(x)))\n             }\n@@ -1098,10 +1106,10 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n                             folder.fold_expr(el),\n                             folder.fold_expr(er))\n             }\n-            ExprField(el, ident) => {\n+            ExprField(el, name) => {\n                 ExprField(folder.fold_expr(el),\n-                          respan(folder.new_span(ident.span),\n-                                 folder.fold_ident(ident.node)))\n+                          respan(folder.new_span(name.span),\n+                                 folder.fold_name(name.node)))\n             }\n             ExprTupField(el, ident) => {\n                 ExprTupField(folder.fold_expr(el),"}, {"sha": "4dfb80cce6da63c6196ceef79d36ce4b4af92d60", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 28, "deletions": 41, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -52,10 +52,6 @@ use util;\n use std::fmt;\n use serialize::{Encodable, Encoder, Decoder};\n \n-\n-/// Function name (not all functions have names)\n-pub type FnIdent = Option<Ident>;\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,\n@@ -248,7 +244,7 @@ pub type TyParamBounds = OwnedSlice<TyParamBound>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TyParam {\n-    pub ident: Ident,\n+    pub name: Name,\n     pub id: NodeId,\n     pub bounds: TyParamBounds,\n     pub default: Option<P<Ty>>,\n@@ -337,11 +333,11 @@ pub struct Crate {\n /// Not parsed directly, but created on macro import or `macro_rules!` expansion.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct MacroDef {\n-    pub ident: Ident,\n+    pub name: Name,\n     pub attrs: Vec<Attribute>,\n     pub id: NodeId,\n     pub span: Span,\n-    pub imported_from: Option<Ident>,\n+    pub imported_from: Option<Name>,\n     pub export: bool,\n     pub use_locally: bool,\n     pub allow_internal_unstable: bool,\n@@ -382,7 +378,7 @@ impl fmt::Debug for Pat {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct FieldPat {\n     /// The identifier for the field\n-    pub ident: Ident,\n+    pub name: Name,\n     /// The pattern the field is destructured to\n     pub pat: P<Pat>,\n     pub is_shorthand: bool,\n@@ -416,7 +412,7 @@ pub enum Pat_ {\n     /// which it is. The resolver determines this, and\n     /// records this pattern's NodeId in an auxiliary\n     /// set (of \"PatIdents that refer to nullary enums\")\n-    PatIdent(BindingMode, SpannedIdent, Option<P<Pat>>),\n+    PatIdent(BindingMode, Spanned<Ident>, Option<P<Pat>>),\n \n     /// \"None\" means a * pattern where we don't bind the fields to names.\n     PatEnum(Path, Option<Vec<P<Pat>>>),\n@@ -564,13 +560,11 @@ pub struct Arm {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Field {\n-    pub ident: SpannedIdent,\n+    pub name: Spanned<Name>,\n     pub expr: P<Expr>,\n     pub span: Span,\n }\n \n-pub type SpannedIdent = Spanned<Ident>;\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum BlockCheckMode {\n     DefaultBlock,\n@@ -612,7 +606,7 @@ pub enum Expr_ {\n     ExprCall(P<Expr>, Vec<P<Expr>>),\n     /// A method call (`x.foo::<Bar, Baz>(a, b, c, d)`)\n     ///\n-    /// The `SpannedIdent` is the identifier for the method name.\n+    /// The `Spanned<Name>` is the identifier for the method name.\n     /// The vector of `Ty`s are the ascripted type parameters for the method\n     /// (within the angle brackets).\n     ///\n@@ -622,7 +616,7 @@ pub enum Expr_ {\n     ///\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n     /// `ExprMethodCall(foo, [Bar, Baz], [x, a, b, c, d])`.\n-    ExprMethodCall(SpannedIdent, Vec<P<Ty>>, Vec<P<Expr>>),\n+    ExprMethodCall(Spanned<Name>, Vec<P<Ty>>, Vec<P<Expr>>),\n     /// A tuple (`(a, b, c ,d)`)\n     ExprTup(Vec<P<Expr>>),\n     /// A binary operation (For example: `a + b`, `a * b`)\n@@ -662,7 +656,7 @@ pub enum Expr_ {\n     /// For example, `a += 1`.\n     ExprAssignOp(BinOp, P<Expr>, P<Expr>),\n     /// Access of a named struct field (`obj.foo`)\n-    ExprField(P<Expr>, SpannedIdent),\n+    ExprField(P<Expr>, Spanned<Name>),\n     /// Access of an unnamed field of a struct or tuple-struct\n     ///\n     /// For example, `foo.0`.\n@@ -682,9 +676,9 @@ pub enum Expr_ {\n     /// A referencing operation (`&a` or `&mut a`)\n     ExprAddrOf(Mutability, P<Expr>),\n     /// A `break`, with an optional label to break\n-    ExprBreak(Option<SpannedIdent>),\n+    ExprBreak(Option<Spanned<Ident>>),\n     /// A `continue`, with an optional label\n-    ExprAgain(Option<SpannedIdent>),\n+    ExprAgain(Option<Spanned<Ident>>),\n     /// A `return`, with an optional value to be returned\n     ExprRet(Option<P<Expr>>),\n \n@@ -744,13 +738,6 @@ pub struct MutTy {\n     pub mutbl: Mutability,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct TypeField {\n-    pub ident: Ident,\n-    pub mt: MutTy,\n-    pub span: Span,\n-}\n-\n /// Represents a method's signature in a trait declaration,\n /// or in an implementation.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -770,7 +757,7 @@ pub struct MethodSig {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TraitItem {\n     pub id: NodeId,\n-    pub ident: Ident,\n+    pub name: Name,\n     pub attrs: Vec<Attribute>,\n     pub node: TraitItem_,\n     pub span: Span,\n@@ -786,7 +773,7 @@ pub enum TraitItem_ {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ImplItem {\n     pub id: NodeId,\n-    pub ident: Ident,\n+    pub name: Name,\n     pub vis: Visibility,\n     pub attrs: Vec<Attribute>,\n     pub node: ImplItem_,\n@@ -804,7 +791,7 @@ pub enum ImplItem_ {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TypeBinding {\n     pub id: NodeId,\n-    pub ident: Ident,\n+    pub name: Name,\n     pub ty: P<Ty>,\n     pub span: Span,\n }\n@@ -994,11 +981,11 @@ pub enum ExplicitSelf_ {\n     /// No self\n     SelfStatic,\n     /// `self`\n-    SelfValue(Ident),\n+    SelfValue(Name),\n     /// `&'lt self`, `&'lt mut self`\n-    SelfRegion(Option<Lifetime>, Mutability, Ident),\n+    SelfRegion(Option<Lifetime>, Mutability, Name),\n     /// `self: TYPE`\n-    SelfExplicit(P<Ty>, Ident),\n+    SelfExplicit(P<Ty>, Name),\n }\n \n pub type ExplicitSelf = Spanned<ExplicitSelf_>;\n@@ -1039,7 +1026,7 @@ pub struct EnumDef {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Variant_ {\n-    pub name: Ident,\n+    pub name: Name,\n     pub attrs: Vec<Attribute>,\n     pub kind: VariantKind,\n     pub id: NodeId,\n@@ -1052,14 +1039,14 @@ pub type Variant = Spanned<Variant_>;\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum PathListItem_ {\n     PathListIdent {\n-        name: Ident,\n+        name: Name,\n         /// renamed in list, eg `use foo::{bar as baz};`\n-        rename: Option<Ident>,\n+        rename: Option<Name>,\n         id: NodeId\n     },\n     PathListMod {\n         /// renamed in list, eg `use foo::{self as baz};`\n-        rename: Option<Ident>,\n+        rename: Option<Name>,\n         id: NodeId\n     }\n }\n@@ -1071,7 +1058,7 @@ impl PathListItem_ {\n         }\n     }\n \n-    pub fn rename(&self) -> Option<Ident> {\n+    pub fn rename(&self) -> Option<Name> {\n         match *self {\n             PathListIdent { rename, .. } | PathListMod { rename, .. } => rename\n         }\n@@ -1090,7 +1077,7 @@ pub enum ViewPath_ {\n     /// or just\n     ///\n     /// `foo::bar::baz` (with `as baz` implicitly on the right)\n-    ViewPathSimple(Ident, Path),\n+    ViewPathSimple(Name, Path),\n \n     /// `foo::bar::*`\n     ViewPathGlob(Path),\n@@ -1146,9 +1133,9 @@ pub struct StructField_ {\n }\n \n impl StructField_ {\n-    pub fn ident(&self) -> Option<Ident> {\n+    pub fn name(&self) -> Option<Name> {\n         match self.kind {\n-            NamedField(ref ident, _) => Some(ident.clone()),\n+            NamedField(name, _) => Some(name),\n             UnnamedField(_) => None\n         }\n     }\n@@ -1158,7 +1145,7 @@ pub type StructField = Spanned<StructField_>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum StructFieldKind {\n-    NamedField(Ident, Visibility),\n+    NamedField(Name, Visibility),\n     /// Element of a tuple-like struct\n     UnnamedField(Visibility),\n }\n@@ -1190,7 +1177,7 @@ pub struct StructDef {\n /// The name might be a dummy name in case of anonymous items\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Item {\n-    pub ident: Ident,\n+    pub name: Name,\n     pub attrs: Vec<Attribute>,\n     pub id: NodeId,\n     pub node: Item_,\n@@ -1264,7 +1251,7 @@ impl Item_ {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ForeignItem {\n-    pub ident: Ident,\n+    pub name: Name,\n     pub attrs: Vec<Attribute>,\n     pub node: ForeignItem_,\n     pub id: NodeId,"}, {"sha": "4888ff93c997b1b0789964e5fdb93f380a1535ba", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -14,15 +14,15 @@ use hir;\n \n use syntax::ast::*;\n use syntax::ptr::P;\n-use syntax::codemap::Spanned;\n+use syntax::codemap::{respan, Spanned};\n use syntax::owned_slice::OwnedSlice;\n \n \n pub fn lower_view_path(view_path: &ViewPath) -> P<hir::ViewPath> {\n     P(Spanned {\n         node: match view_path.node {\n             ViewPathSimple(ident, ref path) => {\n-                hir::ViewPathSimple(ident, lower_path(path))\n+                hir::ViewPathSimple(ident.name, lower_path(path))\n             }\n             ViewPathGlob(ref path) => {\n                 hir::ViewPathGlob(lower_path(path))\n@@ -35,11 +35,14 @@ pub fn lower_view_path(view_path: &ViewPath) -> P<hir::ViewPath> {\n                                         PathListIdent { id, name, rename } =>\n                                             hir::PathListIdent {\n                                                 id: id,\n-                                                name: name,\n-                                                rename: rename.clone(),\n+                                                name: name.name,\n+                                                rename: rename.map(|x| x.name),\n                                             },\n                                         PathListMod { id, rename } =>\n-                                            hir::PathListMod { id: id, rename: rename.clone() }\n+                                            hir::PathListMod {\n+                                                id: id,\n+                                                rename: rename.map(|x| x.name)\n+                                            }\n                                     },\n                                     span: path_list_ident.span\n                                 }\n@@ -73,7 +76,7 @@ pub fn lower_decl(d: &Decl) -> P<hir::Decl> {\n }\n \n pub fn lower_ty_binding(b: &TypeBinding) -> P<hir::TypeBinding> {\n-    P(hir::TypeBinding { id: b.id, ident: b.ident, ty: lower_ty(&b.ty), span: b.span })\n+    P(hir::TypeBinding { id: b.id, name: b.ident.name, ty: lower_ty(&b.ty), span: b.span })\n }\n \n pub fn lower_ty(t: &Ty) -> P<hir::Ty> {\n@@ -135,7 +138,7 @@ pub fn lower_variant(v: &Variant) -> P<hir::Variant> {\n     P(Spanned {\n         node: hir::Variant_ {\n             id: v.node.id,\n-            name: v.node.name,\n+            name: v.node.name.name,\n             attrs: v.node.attrs.clone(),\n             kind: match v.node.kind {\n                 TupleVariantKind(ref variant_args) => {\n@@ -206,12 +209,12 @@ pub fn lower_local(l: &Local) -> P<hir::Local> {\n pub fn lower_explicit_self_underscore(es: &ExplicitSelf_) -> hir::ExplicitSelf_ {\n     match *es {\n         SelfStatic => hir::SelfStatic,\n-        SelfValue(v) => hir::SelfValue(v),\n+        SelfValue(v) => hir::SelfValue(v.name),\n         SelfRegion(ref lifetime, m, ident) => {\n-            hir::SelfRegion(lower_opt_lifetime(lifetime), lower_mutability(m), ident)\n+            hir::SelfRegion(lower_opt_lifetime(lifetime), lower_mutability(m), ident.name)\n         }\n         SelfExplicit(ref typ, ident) => {\n-            hir::SelfExplicit(lower_ty(typ), ident)\n+            hir::SelfExplicit(lower_ty(typ), ident.name)\n         }\n     }\n }\n@@ -255,7 +258,7 @@ pub fn lower_ty_param_bound(tpb: &TyParamBound) -> hir::TyParamBound {\n pub fn lower_ty_param(tp: &TyParam) -> hir::TyParam {\n     hir::TyParam {\n         id: tp.id,\n-        ident: tp.ident,\n+        name: tp.ident.name,\n         bounds: lower_bounds(&tp.bounds),\n         default: tp.default.as_ref().map(|x| lower_ty(x)),\n         span: tp.span,\n@@ -370,7 +373,10 @@ pub fn lower_struct_field(f: &StructField) -> hir::StructField {\n }\n \n pub fn lower_field(f: &Field) -> hir::Field {\n-    hir::Field { ident: f.ident, expr: lower_expr(&f.expr), span: f.span }\n+    hir::Field {\n+        name: respan(f.ident.span, f.ident.node.name),\n+        expr: lower_expr(&f.expr), span: f.span\n+    }\n }\n \n pub fn lower_mt(mt: &MutTy) -> hir::MutTy {\n@@ -466,7 +472,7 @@ pub fn lower_item_underscore(i: &Item_) -> hir::Item_ {\n pub fn lower_trait_item(i: &TraitItem) -> P<hir::TraitItem> {\n     P(hir::TraitItem {\n             id: i.id,\n-            ident: i.ident,\n+            name: i.ident.name,\n             attrs: i.attrs.clone(),\n             node: match i.node {\n             ConstTraitItem(ref ty, ref default) => {\n@@ -489,7 +495,7 @@ pub fn lower_trait_item(i: &TraitItem) -> P<hir::TraitItem> {\n pub fn lower_impl_item(i: &ImplItem) -> P<hir::ImplItem> {\n     P(hir::ImplItem {\n             id: i.id,\n-            ident: i.ident,\n+            name: i.ident.name,\n             attrs: i.attrs.clone(),\n             vis: lower_visibility(i.vis),\n             node: match i.node  {\n@@ -523,11 +529,11 @@ pub fn lower_crate(c: &Crate) -> hir::Crate {\n \n pub fn lower_macro_def(m: &MacroDef) -> hir::MacroDef {\n     hir::MacroDef {\n-        ident: m.ident,\n+        name: m.ident.name,\n         attrs: m.attrs.clone(),\n         id: m.id,\n         span: m.span,\n-        imported_from: m.imported_from,\n+        imported_from: m.imported_from.map(|x| x.name),\n         export: m.export,\n         use_locally: m.use_locally,\n         allow_internal_unstable: m.allow_internal_unstable,\n@@ -546,7 +552,7 @@ pub fn lower_item_simple(i: &Item) -> hir::Item {\n \n     hir::Item {\n         id: i.id,\n-        ident: i.ident,\n+        name: i.ident.name,\n         attrs: i.attrs.clone(),\n         node: node,\n         vis: lower_visibility(i.vis),\n@@ -557,7 +563,7 @@ pub fn lower_item_simple(i: &Item) -> hir::Item {\n pub fn lower_foreign_item(i: &ForeignItem) -> P<hir::ForeignItem> {\n     P(hir::ForeignItem {\n             id: i.id,\n-            ident: i.ident,\n+            name: i.ident.name,\n             attrs: i.attrs.clone(),\n             node: match i.node {\n             ForeignItemFn(ref fdec, ref generics) => {\n@@ -659,7 +665,7 @@ pub fn lower_pat(p: &Pat) -> P<hir::Pat> {\n                 let fs = fields.iter().map(|f| {\n                     Spanned { span: f.span,\n                               node: hir::FieldPat {\n-                                  ident: f.node.ident,\n+                                  name: f.node.ident.name,\n                                   pat: lower_pat(&f.node.pat),\n                                   is_shorthand: f.node.is_shorthand,\n                               }}\n@@ -704,7 +710,7 @@ pub fn lower_expr(e: &Expr) -> P<hir::Expr> {\n                 }\n                 ExprMethodCall(i, ref tps, ref args) => {\n                     hir::ExprMethodCall(\n-                        i,\n+                        respan(i.span, i.node.name),\n                         tps.iter().map(|x| lower_ty(x)).collect(),\n                         args.iter().map(|x| lower_expr(x)).collect())\n                 }\n@@ -755,7 +761,7 @@ pub fn lower_expr(e: &Expr) -> P<hir::Expr> {\n                                 lower_expr(er))\n                 }\n                 ExprField(ref el, ident) => {\n-                    hir::ExprField(lower_expr(el), ident)\n+                    hir::ExprField(lower_expr(el), respan(ident.span, ident.node.name))\n                 }\n                 ExprTupField(ref el, ident) => {\n                     hir::ExprTupField(lower_expr(el), ident)\n@@ -895,7 +901,7 @@ pub fn lower_binding_mode(b: &BindingMode) -> hir::BindingMode {\n \n pub fn lower_struct_field_kind(s: &StructFieldKind) -> hir::StructFieldKind {\n     match *s {\n-        NamedField(ident, vis) => hir::NamedField(ident, lower_visibility(vis)),\n+        NamedField(ident, vis) => hir::NamedField(ident.name, lower_visibility(vis)),\n         UnnamedField(vis) => hir::UnnamedField(lower_visibility(vis)),\n     }\n }"}, {"sha": "6f2ef8e8cbc48c8b71fad8e40b8a6a5205f609c0", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 49, "deletions": 50, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -13,7 +13,7 @@ pub use self::AnnNode::*;\n use syntax::abi;\n use syntax::ast;\n use syntax::owned_slice::OwnedSlice;\n-use syntax::codemap::{self, CodeMap, BytePos};\n+use syntax::codemap::{self, CodeMap, BytePos, Spanned};\n use syntax::diagnostic;\n use syntax::parse::token::{self, BinOpToken};\n use syntax::parse::lexer::comments;\n@@ -271,7 +271,7 @@ pub fn ident_to_string(id: &ast::Ident) -> String {\n pub fn fun_to_string(decl: &hir::FnDecl,\n                      unsafety: hir::Unsafety,\n                      constness: hir::Constness,\n-                     name: ast::Ident,\n+                     name: ast::Name,\n                      opt_explicit_self: Option<&hir::ExplicitSelf_>,\n                      generics: &hir::Generics)\n                      -> String {\n@@ -557,7 +557,7 @@ impl<'a> State<'a> {\n                 try!(self.head(\"\"));\n                 try!(self.print_fn(decl, hir::Unsafety::Normal,\n                                    hir::Constness::NotConst,\n-                                   abi::Rust, Some(item.ident),\n+                                   abi::Rust, Some(item.name),\n                                    generics, None, item.vis));\n                 try!(self.end()); // end head-ibox\n                 try!(word(&mut self.s, \";\"));\n@@ -569,7 +569,7 @@ impl<'a> State<'a> {\n                 if m {\n                     try!(self.word_space(\"mut\"));\n                 }\n-                try!(self.print_ident(item.ident));\n+                try!(self.print_name(item.name));\n                 try!(self.word_space(\":\"));\n                 try!(self.print_type(&**t));\n                 try!(word(&mut self.s, \";\"));\n@@ -580,15 +580,15 @@ impl<'a> State<'a> {\n     }\n \n     fn print_associated_const(&mut self,\n-                              ident: ast::Ident,\n+                              name: ast::Name,\n                               ty: &hir::Ty,\n                               default: Option<&hir::Expr>,\n                               vis: hir::Visibility)\n                               -> io::Result<()>\n     {\n         try!(word(&mut self.s, &visibility_qualified(vis, \"\")));\n         try!(self.word_space(\"const\"));\n-        try!(self.print_ident(ident));\n+        try!(self.print_name(name));\n         try!(self.word_space(\":\"));\n         try!(self.print_type(ty));\n         if let Some(expr) = default {\n@@ -600,12 +600,12 @@ impl<'a> State<'a> {\n     }\n \n     fn print_associated_type(&mut self,\n-                             ident: ast::Ident,\n+                             name: ast::Name,\n                              bounds: Option<&hir::TyParamBounds>,\n                              ty: Option<&hir::Ty>)\n                              -> io::Result<()> {\n         try!(self.word_space(\"type\"));\n-        try!(self.print_ident(ident));\n+        try!(self.print_name(name));\n         if let Some(bounds) = bounds {\n             try!(self.print_bounds(\":\", bounds));\n         }\n@@ -638,7 +638,7 @@ impl<'a> State<'a> {\n                     try!(word(&mut self.s, \"as\"));\n                     try!(space(&mut self.s));\n                 }\n-                try!(self.print_ident(item.ident));\n+                try!(self.print_name(item.name));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end inner head-block\n                 try!(self.end()); // end outer head-block\n@@ -657,7 +657,7 @@ impl<'a> State<'a> {\n                 if m == hir::MutMutable {\n                     try!(self.word_space(\"mut\"));\n                 }\n-                try!(self.print_ident(item.ident));\n+                try!(self.print_name(item.name));\n                 try!(self.word_space(\":\"));\n                 try!(self.print_type(&**ty));\n                 try!(space(&mut self.s));\n@@ -671,7 +671,7 @@ impl<'a> State<'a> {\n             hir::ItemConst(ref ty, ref expr) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n                                                     \"const\")));\n-                try!(self.print_ident(item.ident));\n+                try!(self.print_name(item.name));\n                 try!(self.word_space(\":\"));\n                 try!(self.print_type(&**ty));\n                 try!(space(&mut self.s));\n@@ -689,7 +689,7 @@ impl<'a> State<'a> {\n                     unsafety,\n                     constness,\n                     abi,\n-                    Some(item.ident),\n+                    Some(item.name),\n                     typarams,\n                     None,\n                     item.vis\n@@ -700,7 +700,7 @@ impl<'a> State<'a> {\n             hir::ItemMod(ref _mod) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n                                                     \"mod\")));\n-                try!(self.print_ident(item.ident));\n+                try!(self.print_name(item.name));\n                 try!(self.nbsp());\n                 try!(self.bopen());\n                 try!(self.print_mod(_mod, &item.attrs));\n@@ -717,7 +717,7 @@ impl<'a> State<'a> {\n                 try!(self.ibox(indent_unit));\n                 try!(self.ibox(0));\n                 try!(self.word_nbsp(&visibility_qualified(item.vis, \"type\")));\n-                try!(self.print_ident(item.ident));\n+                try!(self.print_name(item.name));\n                 try!(self.print_generics(params));\n                 try!(self.end()); // end the inner ibox\n \n@@ -732,14 +732,14 @@ impl<'a> State<'a> {\n                 try!(self.print_enum_def(\n                     enum_definition,\n                     params,\n-                    item.ident,\n+                    item.name,\n                     item.span,\n                     item.vis\n                 ));\n             }\n             hir::ItemStruct(ref struct_def, ref generics) => {\n                 try!(self.head(&visibility_qualified(item.vis,\"struct\")));\n-                try!(self.print_struct(&**struct_def, generics, item.ident, item.span));\n+                try!(self.print_struct(&**struct_def, generics, item.name, item.span));\n             }\n \n             hir::ItemDefaultImpl(unsafety, ref trait_ref) => {\n@@ -802,7 +802,7 @@ impl<'a> State<'a> {\n                 try!(self.print_visibility(item.vis));\n                 try!(self.print_unsafety(unsafety));\n                 try!(self.word_nbsp(\"trait\"));\n-                try!(self.print_ident(item.ident));\n+                try!(self.print_name(item.name));\n                 try!(self.print_generics(generics));\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 for b in bounds.iter() {\n@@ -853,11 +853,11 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_enum_def(&mut self, enum_definition: &hir::EnumDef,\n-                          generics: &hir::Generics, ident: ast::Ident,\n+                          generics: &hir::Generics, name: ast::Name,\n                           span: codemap::Span,\n                           visibility: hir::Visibility) -> io::Result<()> {\n         try!(self.head(&visibility_qualified(visibility, \"enum\")));\n-        try!(self.print_ident(ident));\n+        try!(self.print_name(name));\n         try!(self.print_generics(generics));\n         try!(self.print_where_clause(&generics.where_clause));\n         try!(space(&mut self.s));\n@@ -891,9 +891,9 @@ impl<'a> State<'a> {\n     pub fn print_struct(&mut self,\n                         struct_def: &hir::StructDef,\n                         generics: &hir::Generics,\n-                        ident: ast::Ident,\n+                        name: ast::Name,\n                         span: codemap::Span) -> io::Result<()> {\n-        try!(self.print_ident(ident));\n+        try!(self.print_name(name));\n         try!(self.print_generics(generics));\n         if ::util::struct_def_is_tuple_like(struct_def) {\n             if !struct_def.fields.is_empty() {\n@@ -926,12 +926,12 @@ impl<'a> State<'a> {\n             for field in &struct_def.fields {\n                 match field.node.kind {\n                     hir::UnnamedField(..) => panic!(\"unexpected unnamed field\"),\n-                    hir::NamedField(ident, visibility) => {\n+                    hir::NamedField(name, visibility) => {\n                         try!(self.hardbreak_if_not_bol());\n                         try!(self.maybe_print_comment(field.span.lo));\n                         try!(self.print_outer_attributes(&field.node.attrs));\n                         try!(self.print_visibility(visibility));\n-                        try!(self.print_ident(ident));\n+                        try!(self.print_name(name));\n                         try!(self.word_nbsp(\":\"));\n                         try!(self.print_type(&*field.node.ty));\n                         try!(word(&mut self.s, \",\"));\n@@ -946,7 +946,7 @@ impl<'a> State<'a> {\n     pub fn print_variant(&mut self, v: &hir::Variant) -> io::Result<()> {\n         match v.node.kind {\n             hir::TupleVariantKind(ref args) => {\n-                try!(self.print_ident(v.node.name));\n+                try!(self.print_name(v.node.name));\n                 if !args.is_empty() {\n                     try!(self.popen());\n                     try!(self.commasep(Consistent,\n@@ -972,15 +972,15 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_method_sig(&mut self,\n-                            ident: ast::Ident,\n+                            name: ast::Name,\n                             m: &hir::MethodSig,\n                             vis: hir::Visibility)\n                             -> io::Result<()> {\n         self.print_fn(&m.decl,\n                       m.unsafety,\n                       m.constness,\n                       m.abi,\n-                      Some(ident),\n+                      Some(name),\n                       &m.generics,\n                       Some(&m.explicit_self.node),\n                       vis)\n@@ -994,15 +994,15 @@ impl<'a> State<'a> {\n         try!(self.print_outer_attributes(&ti.attrs));\n         match ti.node {\n             hir::ConstTraitItem(ref ty, ref default) => {\n-                try!(self.print_associated_const(ti.ident, &ty,\n+                try!(self.print_associated_const(ti.name, &ty,\n                                                  default.as_ref().map(|expr| &**expr),\n                                                  hir::Inherited));\n             }\n             hir::MethodTraitItem(ref sig, ref body) => {\n                 if body.is_some() {\n                     try!(self.head(\"\"));\n                 }\n-                try!(self.print_method_sig(ti.ident, sig, hir::Inherited));\n+                try!(self.print_method_sig(ti.name, sig, hir::Inherited));\n                 if let Some(ref body) = *body {\n                     try!(self.nbsp());\n                     try!(self.print_block_with_attrs(body, &ti.attrs));\n@@ -1011,7 +1011,7 @@ impl<'a> State<'a> {\n                 }\n             }\n             hir::TypeTraitItem(ref bounds, ref default) => {\n-                try!(self.print_associated_type(ti.ident, Some(bounds),\n+                try!(self.print_associated_type(ti.name, Some(bounds),\n                                                 default.as_ref().map(|ty| &**ty)));\n             }\n         }\n@@ -1025,16 +1025,16 @@ impl<'a> State<'a> {\n         try!(self.print_outer_attributes(&ii.attrs));\n         match ii.node {\n             hir::ConstImplItem(ref ty, ref expr) => {\n-                try!(self.print_associated_const(ii.ident, &ty, Some(&expr), ii.vis));\n+                try!(self.print_associated_const(ii.name, &ty, Some(&expr), ii.vis));\n             }\n             hir::MethodImplItem(ref sig, ref body) => {\n                 try!(self.head(\"\"));\n-                try!(self.print_method_sig(ii.ident, sig, ii.vis));\n+                try!(self.print_method_sig(ii.name, sig, ii.vis));\n                 try!(self.nbsp());\n                 try!(self.print_block_with_attrs(body, &ii.attrs));\n             }\n             hir::TypeImplItem(ref ty) => {\n-                try!(self.print_associated_type(ii.ident, None, Some(ty)));\n+                try!(self.print_associated_type(ii.name, None, Some(ty)));\n             }\n         }\n         self.ann.post(self, NodeSubItem(ii.id))\n@@ -1223,7 +1223,7 @@ impl<'a> State<'a> {\n             &fields[..],\n             |s, field| {\n                 try!(s.ibox(indent_unit));\n-                try!(s.print_ident(field.ident.node));\n+                try!(s.print_name(field.name.node));\n                 try!(s.word_space(\":\"));\n                 try!(s.print_expr(&*field.expr));\n                 s.end()\n@@ -1265,13 +1265,13 @@ impl<'a> State<'a> {\n     }\n \n     fn print_expr_method_call(&mut self,\n-                              ident: hir::SpannedIdent,\n+                              name: Spanned<ast::Name>,\n                               tys: &[P<hir::Ty>],\n                               args: &[P<hir::Expr>]) -> io::Result<()> {\n         let base_args = &args[1..];\n         try!(self.print_expr(&*args[0]));\n         try!(word(&mut self.s, \".\"));\n-        try!(self.print_ident(ident.node));\n+        try!(self.print_name(name.node));\n         if !tys.is_empty() {\n             try!(word(&mut self.s, \"::<\"));\n             try!(self.commasep(Inconsistent, tys,\n@@ -1329,8 +1329,8 @@ impl<'a> State<'a> {\n             hir::ExprCall(ref func, ref args) => {\n                 try!(self.print_expr_call(&**func, &args[..]));\n             }\n-            hir::ExprMethodCall(ident, ref tys, ref args) => {\n-                try!(self.print_expr_method_call(ident, &tys[..], &args[..]));\n+            hir::ExprMethodCall(name, ref tys, ref args) => {\n+                try!(self.print_expr_method_call(name, &tys[..], &args[..]));\n             }\n             hir::ExprBinary(op, ref lhs, ref rhs) => {\n                 try!(self.print_expr_binary(op, &**lhs, &**rhs));\n@@ -1435,10 +1435,10 @@ impl<'a> State<'a> {\n                 try!(self.word_space(\"=\"));\n                 try!(self.print_expr(&**rhs));\n             }\n-            hir::ExprField(ref expr, id) => {\n+            hir::ExprField(ref expr, name) => {\n                 try!(self.print_expr(&**expr));\n                 try!(word(&mut self.s, \".\"));\n-                try!(self.print_ident(id.node));\n+                try!(self.print_name(name.node));\n             }\n             hir::ExprTupField(ref expr, id) => {\n                 try!(self.print_expr(&**expr));\n@@ -1699,7 +1699,7 @@ impl<'a> State<'a> {\n                     if comma {\n                         try!(self.word_space(\",\"))\n                     }\n-                    try!(self.print_ident(binding.ident));\n+                    try!(self.print_name(binding.name));\n                     try!(space(&mut self.s));\n                     try!(self.word_space(\"=\"));\n                     try!(self.print_type(&*binding.ty));\n@@ -1785,7 +1785,7 @@ impl<'a> State<'a> {\n                     |s, f| {\n                         try!(s.cbox(indent_unit));\n                         if !f.node.is_shorthand {\n-                            try!(s.print_ident(f.node.ident));\n+                            try!(s.print_name(f.node.name));\n                             try!(s.word_nbsp(\":\"));\n                         }\n                         try!(s.print_pat(&*f.node.pat));\n@@ -1928,15 +1928,15 @@ impl<'a> State<'a> {\n                     unsafety: hir::Unsafety,\n                     constness: hir::Constness,\n                     abi: abi::Abi,\n-                    name: Option<ast::Ident>,\n+                    name: Option<ast::Name>,\n                     generics: &hir::Generics,\n                     opt_explicit_self: Option<&hir::ExplicitSelf_>,\n                     vis: hir::Visibility) -> io::Result<()> {\n         try!(self.print_fn_header_info(unsafety, constness, abi, vis));\n \n         if let Some(name) = name {\n             try!(self.nbsp());\n-            try!(self.print_ident(name));\n+            try!(self.print_name(name));\n         }\n         try!(self.print_generics(generics));\n         try!(self.print_fn_args_and_ret(decl, opt_explicit_self));\n@@ -2111,7 +2111,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_ty_param(&mut self, param: &hir::TyParam) -> io::Result<()> {\n-        try!(self.print_ident(param.ident));\n+        try!(self.print_name(param.name));\n         try!(self.print_bounds(\":\", &param.bounds));\n         match param.default {\n             Some(ref default) => {\n@@ -2174,15 +2174,14 @@ impl<'a> State<'a> {\n \n     pub fn print_view_path(&mut self, vp: &hir::ViewPath) -> io::Result<()> {\n         match vp.node {\n-            hir::ViewPathSimple(ident, ref path) => {\n+            hir::ViewPathSimple(name, ref path) => {\n                 try!(self.print_path(path, false, 0));\n \n                 // FIXME(#6993) can't compare identifiers directly here\n-                if path.segments.last().unwrap().identifier.name !=\n-                        ident.name {\n+                if path.segments.last().unwrap().identifier.name != name {\n                     try!(space(&mut self.s));\n                     try!(self.word_space(\"as\"));\n-                    try!(self.print_ident(ident));\n+                    try!(self.print_name(name));\n                 }\n \n                 Ok(())\n@@ -2203,7 +2202,7 @@ impl<'a> State<'a> {\n                 try!(self.commasep(Inconsistent, &idents[..], |s, w| {\n                     match w.node {\n                         hir::PathListIdent { name, .. } => {\n-                            s.print_ident(name)\n+                            s.print_name(name)\n                         },\n                         hir::PathListMod { .. } => {\n                             word(&mut s.s, \"self\")\n@@ -2299,7 +2298,7 @@ impl<'a> State<'a> {\n                            unsafety,\n                            hir::Constness::NotConst,\n                            abi,\n-                           name,\n+                           name.map(|x| x.name),\n                            &generics,\n                            opt_explicit_self,\n                            hir::Inherited));"}, {"sha": "00abb14d40ff83f9bcd2b454098881aa2af9b1be", "filename": "src/librustc_front/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_front%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_front%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Futil.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -12,7 +12,7 @@ use hir;\n use hir::*;\n use visit::{self, Visitor, FnKind};\n use syntax::ast_util;\n-use syntax::ast::{Ident, NodeId, DUMMY_NODE_ID};\n+use syntax::ast::{Ident, Name, NodeId, DUMMY_NODE_ID};\n use syntax::codemap::Span;\n use syntax::ptr::P;\n use syntax::owned_slice::OwnedSlice;\n@@ -286,7 +286,7 @@ impl<'a, 'v, O: ast_util::IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O>\n \n     fn visit_struct_def(&mut self,\n                         struct_def: &StructDef,\n-                        _: Ident,\n+                        _: Name,\n                         _: &hir::Generics,\n                         id: NodeId) {\n         self.operation.visit_id(id);"}, {"sha": "f2a756ed3902147facb45a3f766c4a7f03ba8189", "filename": "src/librustc_front/visit.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_front%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_front%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fvisit.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -34,10 +34,10 @@ use syntax::owned_slice::OwnedSlice;\n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum FnKind<'a> {\n     /// fn foo() or extern \"Abi\" fn foo()\n-    ItemFn(Ident, &'a Generics, Unsafety, Constness, Abi, Visibility),\n+    ItemFn(Name, &'a Generics, Unsafety, Constness, Abi, Visibility),\n \n     /// fn foo(&self)\n-    Method(Ident, &'a MethodSig, Option<Visibility>),\n+    Method(Name, &'a MethodSig, Option<Visibility>),\n \n     /// |x, y| ...\n     /// proc(x, y) ...\n@@ -57,9 +57,7 @@ pub trait Visitor<'v> : Sized {\n     fn visit_name(&mut self, _span: Span, _name: Name) {\n         // Nothing to do.\n     }\n-    fn visit_ident(&mut self, span: Span, ident: Ident) {\n-        self.visit_name(span, ident.name);\n-    }\n+    fn visit_ident(&mut self, span: Span, ident: Ident) { walk_ident(self, span, ident) }\n     fn visit_mod(&mut self, m: &'v Mod, _s: Span, _n: NodeId) { walk_mod(self, m) }\n     fn visit_foreign_item(&mut self, i: &'v ForeignItem) { walk_foreign_item(self, i) }\n     fn visit_item(&mut self, i: &'v Item) { walk_item(self, i) }\n@@ -85,7 +83,7 @@ pub trait Visitor<'v> : Sized {\n     fn visit_poly_trait_ref(&mut self, t: &'v PolyTraitRef, m: &'v TraitBoundModifier) {\n         walk_poly_trait_ref(self, t, m)\n     }\n-    fn visit_struct_def(&mut self, s: &'v StructDef, _: Ident, _: &'v Generics, _: NodeId) {\n+    fn visit_struct_def(&mut self, s: &'v StructDef, _: Name, _: &'v Generics, _: NodeId) {\n         walk_struct_def(self, s)\n     }\n     fn visit_struct_field(&mut self, s: &'v StructField) { walk_struct_field(self, s) }\n@@ -136,6 +134,10 @@ pub trait Visitor<'v> : Sized {\n     fn visit_attribute(&mut self, _attr: &'v Attribute) {}\n }\n \n+pub fn walk_ident<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, ident: Ident) {\n+    visitor.visit_name(span, ident.name);\n+}\n+\n pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate) {\n     visitor.visit_mod(&krate.module, krate.span, CRATE_NODE_ID);\n     for attr in &krate.attrs {\n@@ -201,12 +203,13 @@ pub fn walk_trait_ref<'v,V>(visitor: &mut V,\n }\n \n pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n-    visitor.visit_ident(item.span, item.ident);\n+    visitor.visit_name(item.span, item.name);\n     match item.node {\n         ItemExternCrate(..) => {}\n         ItemUse(ref vp) => {\n             match vp.node {\n-                ViewPathSimple(_ident, ref path) => {\n+                ViewPathSimple(name, ref path) => {\n+                    visitor.visit_name(vp.span, name);\n                     visitor.visit_path(path, item.id);\n                 }\n                 ViewPathGlob(ref path) => {\n@@ -229,7 +232,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_expr(&**expr);\n         }\n         ItemFn(ref declaration, unsafety, constness, abi, ref generics, ref body) => {\n-            visitor.visit_fn(FnKind::ItemFn(item.ident, generics, unsafety,\n+            visitor.visit_fn(FnKind::ItemFn(item.name, generics, unsafety,\n                                             constness, abi, item.vis),\n                              &**declaration,\n                              &**body,\n@@ -273,7 +276,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n         ItemStruct(ref struct_definition, ref generics) => {\n             visitor.visit_generics(generics);\n             visitor.visit_struct_def(&**struct_definition,\n-                                     item.ident,\n+                                     item.name,\n                                      generics,\n                                      item.id)\n         }\n@@ -301,7 +304,7 @@ pub fn walk_enum_def<'v, V: Visitor<'v>>(visitor: &mut V,\n pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n                                         variant: &'v Variant,\n                                         generics: &'v Generics) {\n-    visitor.visit_ident(variant.span, variant.node.name);\n+    visitor.visit_name(variant.span, variant.node.name);\n \n     match variant.node.kind {\n         TupleVariantKind(ref variant_arguments) => {\n@@ -404,7 +407,7 @@ pub fn walk_path_list_item<'v, V: Visitor<'v>>(visitor: &mut V, prefix: &'v Path\n     }\n \n     if let PathListIdent { name, .. } = item.node {\n-        visitor.visit_ident(item.span, name);\n+        visitor.visit_name(item.span, name);\n     }\n }\n \n@@ -443,7 +446,7 @@ pub fn walk_path_parameters<'v, V: Visitor<'v>>(visitor: &mut V,\n \n pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n                                                    type_binding: &'v TypeBinding) {\n-    visitor.visit_ident(type_binding.span, type_binding.ident);\n+    visitor.visit_name(type_binding.span, type_binding.name);\n     visitor.visit_ty(&*type_binding.ty);\n }\n \n@@ -505,7 +508,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n \n pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V,\n                                              foreign_item: &'v ForeignItem) {\n-    visitor.visit_ident(foreign_item.span, foreign_item.ident);\n+    visitor.visit_name(foreign_item.span, foreign_item.name);\n \n     match foreign_item.node {\n         ForeignItemFn(ref function_declaration, ref generics) => {\n@@ -541,7 +544,7 @@ pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n \n pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics) {\n     for param in generics.ty_params.iter() {\n-        visitor.visit_ident(param.span, param.ident);\n+        visitor.visit_name(param.span, param.name);\n         walk_ty_param_bounds_helper(visitor, &param.bounds);\n         walk_ty_opt(visitor, &param.default);\n     }\n@@ -613,7 +616,7 @@ pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n }\n \n pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem) {\n-    visitor.visit_ident(trait_item.span, trait_item.ident);\n+    visitor.visit_name(trait_item.span, trait_item.name);\n     for attr in &trait_item.attrs {\n         visitor.visit_attribute(attr);\n     }\n@@ -630,7 +633,7 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n             walk_fn_decl(visitor, &sig.decl);\n         }\n         MethodTraitItem(ref sig, Some(ref body)) => {\n-            visitor.visit_fn(FnKind::Method(trait_item.ident, sig, None), &sig.decl,\n+            visitor.visit_fn(FnKind::Method(trait_item.name, sig, None), &sig.decl,\n                              body, trait_item.span, trait_item.id);\n         }\n         TypeTraitItem(ref bounds, ref default) => {\n@@ -641,7 +644,7 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n }\n \n pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem) {\n-    visitor.visit_ident(impl_item.span, impl_item.ident);\n+    visitor.visit_name(impl_item.span, impl_item.name);\n     for attr in &impl_item.attrs {\n         visitor.visit_attribute(attr);\n     }\n@@ -651,7 +654,7 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n             visitor.visit_expr(expr);\n         }\n         MethodImplItem(ref sig, ref body) => {\n-            visitor.visit_fn(FnKind::Method(impl_item.ident, sig, Some(impl_item.vis)), &sig.decl,\n+            visitor.visit_fn(FnKind::Method(impl_item.name, sig, Some(impl_item.vis)), &sig.decl,\n                              body, impl_item.span, impl_item.id);\n         }\n         TypeImplItem(ref ty) => {\n@@ -670,7 +673,7 @@ pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V,\n pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V,\n                                              struct_field: &'v StructField) {\n     if let NamedField(name, _) = struct_field.node.kind {\n-        visitor.visit_ident(struct_field.span, name);\n+        visitor.visit_name(struct_field.span, name);\n     }\n \n     visitor.visit_ty(&*struct_field.node.ty);"}, {"sha": "51b2d58a58139acace2a59da8da6ac4629ab60c7", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -53,17 +53,17 @@ declare_lint! {\n pub struct NonCamelCaseTypes;\n \n impl NonCamelCaseTypes {\n-    fn check_case(&self, cx: &LateContext, sort: &str, ident: ast::Ident, span: Span) {\n-        fn is_camel_case(ident: ast::Ident) -> bool {\n-            let ident = ident.name.as_str();\n-            if ident.is_empty() {\n+    fn check_case(&self, cx: &LateContext, sort: &str, name: ast::Name, span: Span) {\n+        fn is_camel_case(name: ast::Name) -> bool {\n+            let name = name.as_str();\n+            if name.is_empty() {\n                 return true;\n             }\n-            let ident = ident.trim_matches('_');\n+            let name = name.trim_matches('_');\n \n             // start with a non-lowercase letter rather than non-uppercase\n             // ones (some scripts don't have a concept of upper/lowercase)\n-            !ident.is_empty() && !ident.char_at(0).is_lowercase() && !ident.contains('_')\n+            !name.is_empty() && !name.char_at(0).is_lowercase() && !name.contains('_')\n         }\n \n         fn to_camel_case(s: &str) -> String {\n@@ -76,9 +76,9 @@ impl NonCamelCaseTypes {\n             )).collect::<Vec<_>>().concat()\n         }\n \n-        let s = ident.name.as_str();\n+        let s = name.as_str();\n \n-        if !is_camel_case(ident) {\n+        if !is_camel_case(name) {\n             let c = to_camel_case(&s);\n             let m = if c.is_empty() {\n                 format!(\"{} `{}` should have a camel case name such as `CamelCase`\", sort, s)\n@@ -110,16 +110,16 @@ impl LateLintPass for NonCamelCaseTypes {\n \n         match it.node {\n             hir::ItemTy(..) | hir::ItemStruct(..) => {\n-                self.check_case(cx, \"type\", it.ident, it.span)\n+                self.check_case(cx, \"type\", it.name, it.span)\n             }\n             hir::ItemTrait(..) => {\n-                self.check_case(cx, \"trait\", it.ident, it.span)\n+                self.check_case(cx, \"trait\", it.name, it.span)\n             }\n             hir::ItemEnum(ref enum_definition, _) => {\n                 if has_extern_repr {\n                     return;\n                 }\n-                self.check_case(cx, \"type\", it.ident, it.span);\n+                self.check_case(cx, \"type\", it.name, it.span);\n                 for variant in &enum_definition.variants {\n                     self.check_case(cx, \"variant\", variant.node.name, variant.span);\n                 }\n@@ -130,7 +130,7 @@ impl LateLintPass for NonCamelCaseTypes {\n \n     fn check_generics(&mut self, cx: &LateContext, it: &hir::Generics) {\n         for gen in it.ty_params.iter() {\n-            self.check_case(cx, \"type parameter\", gen.ident, gen.span);\n+            self.check_case(cx, \"type parameter\", gen.name, gen.span);\n         }\n     }\n }\n@@ -237,31 +237,31 @@ impl LateLintPass for NonSnakeCase {\n                 fk: FnKind, _: &hir::FnDecl,\n                 _: &hir::Block, span: Span, id: ast::NodeId) {\n         match fk {\n-            FnKind::Method(ident, _, _) => match method_context(cx, id, span) {\n+            FnKind::Method(name, _, _) => match method_context(cx, id, span) {\n                 MethodLateContext::PlainImpl => {\n-                    self.check_snake_case(cx, \"method\", &ident.name.as_str(), Some(span))\n+                    self.check_snake_case(cx, \"method\", &name.as_str(), Some(span))\n                 },\n                 MethodLateContext::TraitDefaultImpl => {\n-                    self.check_snake_case(cx, \"trait method\", &ident.name.as_str(), Some(span))\n+                    self.check_snake_case(cx, \"trait method\", &name.as_str(), Some(span))\n                 },\n                 _ => (),\n             },\n-            FnKind::ItemFn(ident, _, _, _, _, _) => {\n-                self.check_snake_case(cx, \"function\", &ident.name.as_str(), Some(span))\n+            FnKind::ItemFn(name, _, _, _, _, _) => {\n+                self.check_snake_case(cx, \"function\", &name.as_str(), Some(span))\n             },\n             _ => (),\n         }\n     }\n \n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         if let hir::ItemMod(_) = it.node {\n-            self.check_snake_case(cx, \"module\", &it.ident.name.as_str(), Some(it.span));\n+            self.check_snake_case(cx, \"module\", &it.name.as_str(), Some(it.span));\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n         if let hir::MethodTraitItem(_, None) = trait_item.node {\n-            self.check_snake_case(cx, \"trait method\", &trait_item.ident.name.as_str(),\n+            self.check_snake_case(cx, \"trait method\", &trait_item.name.as_str(),\n                                   Some(trait_item.span));\n         }\n     }\n@@ -281,10 +281,10 @@ impl LateLintPass for NonSnakeCase {\n     }\n \n     fn check_struct_def(&mut self, cx: &LateContext, s: &hir::StructDef,\n-                        _: ast::Ident, _: &hir::Generics, _: ast::NodeId) {\n+                        _: ast::Name, _: &hir::Generics, _: ast::NodeId) {\n         for sf in &s.fields {\n-            if let hir::StructField_ { kind: hir::NamedField(ident, _), .. } = sf.node {\n-                self.check_snake_case(cx, \"structure field\", &ident.name.as_str(),\n+            if let hir::StructField_ { kind: hir::NamedField(name, _), .. } = sf.node {\n+                self.check_snake_case(cx, \"structure field\", &name.as_str(),\n                                       Some(sf.span));\n             }\n         }\n@@ -301,8 +301,8 @@ declare_lint! {\n pub struct NonUpperCaseGlobals;\n \n impl NonUpperCaseGlobals {\n-    fn check_upper_case(cx: &LateContext, sort: &str, ident: ast::Ident, span: Span) {\n-        let s = ident.name.as_str();\n+    fn check_upper_case(cx: &LateContext, sort: &str, name: ast::Name, span: Span) {\n+        let s = name.as_str();\n \n         if s.chars().any(|c| c.is_lowercase()) {\n             let uc = NonSnakeCase::to_snake_case(&s).to_uppercase();\n@@ -330,10 +330,10 @@ impl LateLintPass for NonUpperCaseGlobals {\n         match it.node {\n             // only check static constants\n             hir::ItemStatic(_, hir::MutImmutable, _) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"static constant\", it.ident, it.span);\n+                NonUpperCaseGlobals::check_upper_case(cx, \"static constant\", it.name, it.span);\n             }\n             hir::ItemConst(..) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"constant\", it.ident, it.span);\n+                NonUpperCaseGlobals::check_upper_case(cx, \"constant\", it.name, it.span);\n             }\n             _ => {}\n         }\n@@ -343,7 +343,7 @@ impl LateLintPass for NonUpperCaseGlobals {\n         match ti.node {\n             hir::ConstTraitItem(..) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n-                                                      ti.ident, ti.span);\n+                                                      ti.name, ti.span);\n             }\n             _ => {}\n         }\n@@ -353,7 +353,7 @@ impl LateLintPass for NonUpperCaseGlobals {\n         match ii.node {\n             hir::ConstImplItem(..) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n-                                                      ii.ident, ii.span);\n+                                                      ii.name, ii.span);\n             }\n             _ => {}\n         }\n@@ -364,7 +364,7 @@ impl LateLintPass for NonUpperCaseGlobals {\n         match (&p.node, cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def())) {\n             (&hir::PatIdent(_, ref path1, _), Some(def::DefConst(..))) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\",\n-                                                      path1.node, p.span);\n+                                                      path1.node.name, p.span);\n             }\n             _ => {}\n         }"}, {"sha": "d115c60f33cf4632ff628b77c1ce58b04f6a4a1f", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -909,7 +909,7 @@ impl LateLintPass for NonShorthandFieldPatterns {\n             });\n             for fieldpat in field_pats {\n                 if let hir::PatIdent(_, ident, None) = fieldpat.node.pat.node {\n-                    if ident.node.name == fieldpat.node.ident.name {\n+                    if ident.node.name == fieldpat.node.name {\n                         // FIXME: should this comparison really be done on the name?\n                         // doing it on the ident will fail during compilation of libcore\n                         cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span,\n@@ -1081,12 +1081,12 @@ impl LateLintPass for MissingDoc {\n     }\n \n     fn check_struct_def(&mut self, _: &LateContext, _: &hir::StructDef,\n-                        _: ast::Ident, _: &hir::Generics, id: ast::NodeId) {\n+                        _: ast::Name, _: &hir::Generics, id: ast::NodeId) {\n         self.struct_def_stack.push(id);\n     }\n \n     fn check_struct_def_post(&mut self, _: &LateContext, _: &hir::StructDef,\n-                             _: ast::Ident, _: &hir::Generics, id: ast::NodeId) {\n+                             _: ast::Name, _: &hir::Generics, id: ast::NodeId) {\n         let popped = self.struct_def_stack.pop().expect(\"empty struct_def_stack\");\n         assert!(popped == id);\n     }\n@@ -1731,15 +1731,15 @@ impl LateLintPass for InvalidNoMangleItems {\n                 if attr::contains_name(&it.attrs, \"no_mangle\") &&\n                        !cx.exported_items.contains(&it.id) {\n                     let msg = format!(\"function {} is marked #[no_mangle], but not exported\",\n-                                      it.ident);\n+                                      it.name);\n                     cx.span_lint(PRIVATE_NO_MANGLE_FNS, it.span, &msg);\n                 }\n             },\n             hir::ItemStatic(..) => {\n                 if attr::contains_name(&it.attrs, \"no_mangle\") &&\n                        !cx.exported_items.contains(&it.id) {\n                     let msg = format!(\"static {} is marked #[no_mangle], but not exported\",\n-                                      it.ident);\n+                                      it.name);\n                     cx.span_lint(PRIVATE_NO_MANGLE_STATICS, it.span, &msg);\n                 }\n             },"}, {"sha": "78f23fcd71ceb4326995cb7034f15e58f7d631d4", "filename": "src/librustc_mir/tcx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -288,9 +288,9 @@ impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for &'tcx hir::Expr {\n             hir::ExprLoop(ref body, _) =>\n                 ExprKind::Loop { condition: None,\n                                  body: block::to_expr_ref(cx, body) },\n-            hir::ExprField(ref source, ident) =>\n+            hir::ExprField(ref source, name) =>\n                 ExprKind::Field { lhs: source.to_ref(),\n-                                  name: Field::Named(ident.node.name) },\n+                                  name: Field::Named(name.node) },\n             hir::ExprTupField(ref source, ident) =>\n                 ExprKind::Field { lhs: source.to_ref(),\n                                   name: Field::Indexed(ident.node) },"}, {"sha": "aeca15cb43c36392ed746f5676a4d2d6f8a18f44", "filename": "src/librustc_mir/tcx/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_mir%2Ftcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_mir%2Ftcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fpattern.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -268,7 +268,7 @@ impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for PatNode<'tcx> {\n                 let subpatterns =\n                     fields.iter()\n                           .map(|field| FieldPatternRef {\n-                              field: Field::Named(field.node.ident.name),\n+                              field: Field::Named(field.node.name),\n                               pattern: self.pat_ref(&field.node.pat),\n                           })\n                           .collect();"}, {"sha": "3c8a5534e1ade4b0fb57854232f46e7844625fa9", "filename": "src/librustc_mir/tcx/to_ref.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_mir%2Ftcx%2Fto_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_mir%2Ftcx%2Fto_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fto_ref.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -86,9 +86,8 @@ impl<'a,'tcx:'a> ToRef<Cx<'a,'tcx>> for &'tcx hir::Field {\n \n     fn to_ref(self) -> FieldExprRef<Cx<'a,'tcx>> {\n         FieldExprRef {\n-            name: Field::Named(self.ident.node.name),\n+            name: Field::Named(self.name.node),\n             expr: self.expr.to_ref()\n         }\n     }\n }\n-"}, {"sha": "ce1b9663520fc31301d416b065ddd6201a684251", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -128,7 +128,7 @@ impl<'v> Visitor<'v> for ParentVisitor {\n         visit::walk_impl_item(self, ii);\n     }\n \n-    fn visit_struct_def(&mut self, s: &hir::StructDef, _: ast::Ident,\n+    fn visit_struct_def(&mut self, s: &hir::StructDef, _: ast::Name,\n                         _: &'v hir::Generics, n: ast::NodeId) {\n         // Struct constructors are parented to their struct definitions because\n         // they essentially are the struct definitions.\n@@ -683,7 +683,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             hir::ItemEnum(..) => \"enum\",\n             _ => return Some((err_span, err_msg, None))\n         };\n-        let msg = format!(\"{} `{}` is private\", desc, item.ident);\n+        let msg = format!(\"{} `{}` is private\", desc, item.name);\n         Some((err_span, err_msg, Some((span, msg))))\n     }\n \n@@ -862,12 +862,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n-            hir::ExprField(ref base, ident) => {\n+            hir::ExprField(ref base, name) => {\n                 if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(&**base).sty {\n                     self.check_field(expr.span,\n                                      def,\n                                      def.struct_variant(),\n-                                     NamedField(ident.node.name));\n+                                     NamedField(name.node));\n                 }\n             }\n             hir::ExprTupField(ref base, idx) => {\n@@ -878,11 +878,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                                      UnnamedField(idx.node));\n                 }\n             }\n-            hir::ExprMethodCall(ident, _, _) => {\n+            hir::ExprMethodCall(name, _, _) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n                 let method = self.tcx.tables.borrow().method_map[&method_call];\n                 debug!(\"(privacy checking) checking impl method\");\n-                self.check_method(expr.span, method.def_id, ident.node.name);\n+                self.check_method(expr.span, method.def_id, name.node);\n             }\n             hir::ExprStruct(..) => {\n                 let adt = self.tcx.expr_ty(expr).ty_adt_def().unwrap();\n@@ -937,7 +937,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                 let variant = adt.variant_of_def(def);\n                 for field in fields {\n                     self.check_field(pattern.span, adt, variant,\n-                                     NamedField(field.node.ident.name));\n+                                     NamedField(field.node.name));\n                 }\n             }\n \n@@ -984,7 +984,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n \n     fn visit_path_list_item(&mut self, prefix: &hir::Path, item: &hir::PathListItem) {\n         let name = if let hir::PathListIdent { name, .. } = item.node {\n-            name.name\n+            name\n         } else if !prefix.segments.is_empty() {\n             prefix.segments.last().unwrap().identifier.name\n         } else {"}, {"sha": "e3e1a26a6f6ebf9b55050967fc1b857c77c31eb9", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -263,7 +263,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n     /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(&mut self, item: &Item, parent: &Rc<Module>) -> Rc<Module> {\n-        let name = item.ident.name;\n+        let name = item.name;\n         let sp = item.span;\n         let is_public = item.vis == hir::Public;\n         let modifiers = if is_public {\n@@ -312,8 +312,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                           ResolutionError::SelfImportsOnlyAllowedWithin);\n                         }\n \n-                        let subclass = SingleImport(binding.name,\n-                                                    source_name);\n+                        let subclass = SingleImport(binding, source_name);\n                         self.build_import_directive(&**parent,\n                                                     module_path,\n                                                     subclass,\n@@ -343,7 +342,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                         for source_item in source_items {\n                             let (module_path, name, rename) = match source_item.node {\n                                 PathListIdent { name, rename, .. } =>\n-                                    (module_path.clone(), name.name, rename.unwrap_or(name).name),\n+                                    (module_path.clone(), name, rename.unwrap_or(name)),\n                                 PathListMod { rename, .. } => {\n                                     let name = match module_path.last() {\n                                         Some(name) => *name,\n@@ -358,7 +357,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                         }\n                                     };\n                                     let module_path = module_path.split_last().unwrap().1;\n-                                    let rename = rename.map(|n| n.name).unwrap_or(name);\n+                                    let rename = rename.unwrap_or(name);\n                                     (module_path.to_vec(), name, rename)\n                                 }\n                             };\n@@ -509,7 +508,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 // Record the def ID and fields of this struct.\n                 let named_fields = struct_def.fields.iter().filter_map(|f| {\n                     match f.node.kind {\n-                        NamedField(ident, _) => Some(ident.name),\n+                        NamedField(name, _) => Some(name),\n                         UnnamedField(_) => None\n                     }\n                 }).collect();\n@@ -539,7 +538,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                 // Add the names of all the items to the trait info.\n                 for trait_item in items {\n-                    let name_bindings = self.add_child(trait_item.ident.name,\n+                    let name_bindings = self.add_child(trait_item.name,\n                                         &module_parent,\n                                         ForbidDuplicateTypesAndValues,\n                                         trait_item.span);\n@@ -563,7 +562,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                         }\n                     }\n \n-                    self.trait_item_map.insert((trait_item.ident.name, def_id),\n+                    self.trait_item_map.insert((trait_item.name, def_id),\n                                                DefId::local(trait_item.id));\n                 }\n \n@@ -579,7 +578,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                        variant: &Variant,\n                                        item_id: DefId,\n                                        parent: &Rc<Module>) {\n-        let name = variant.node.name.name;\n+        let name = variant.node.name;\n         let is_exported = match variant.node.kind {\n             TupleVariantKind(_) => false,\n             StructVariantKind(_) => {\n@@ -606,7 +605,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     fn build_reduced_graph_for_foreign_item(&mut self,\n                                             foreign_item: &ForeignItem,\n                                             parent: &Rc<Module>) {\n-        let name = foreign_item.ident.name;\n+        let name = foreign_item.name;\n         let is_public = foreign_item.vis == hir::Public;\n         let modifiers = if is_public {\n             DefModifiers::PUBLIC"}, {"sha": "f3789c773fb2d01153b9489d701c6f70e8df8405", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -1258,7 +1258,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn get_trait_name(&self, did: DefId) -> Name {\n         if did.is_local() {\n-            self.ast_map.expect_item(did.node).ident.name\n+            self.ast_map.expect_item(did.node).name\n         } else {\n             csearch::get_trait_name(&self.session.cstore, did)\n         }\n@@ -2109,7 +2109,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn resolve_item(&mut self, item: &Item) {\n-        let name = item.ident.name;\n+        let name = item.name;\n \n         debug!(\"(resolving item) resolving {}\",\n                name);\n@@ -2184,7 +2184,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     });\n                                 }\n                                 hir::TypeTraitItem(..) => {\n-                                    this.check_if_primitive_type_name(trait_item.ident.name,\n+                                    this.check_if_primitive_type_name(trait_item.name,\n                                                                       trait_item.span);\n                                     this.with_type_parameter_rib(NoTypeParameters, |this| {\n                                         visit::walk_trait_item(this, trait_item)\n@@ -2210,23 +2210,23 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             ItemUse(ref view_path) => {\n                 // check for imports shadowing primitive types\n-                let check_rename = |this: &Self, id, ident: Ident| {\n+                let check_rename = |this: &Self, id, name| {\n                     match this.def_map.borrow().get(&id).map(|d| d.full_def()) {\n                         Some(DefTy(..)) | Some(DefStruct(..)) | Some(DefTrait(..)) | None => {\n-                            this.check_if_primitive_type_name(ident.name, item.span);\n+                            this.check_if_primitive_type_name(name, item.span);\n                         }\n                         _ => {}\n                     }\n                 };\n \n                 match view_path.node {\n-                    hir::ViewPathSimple(ident, _) => {\n-                        check_rename(self, item.id, ident);\n+                    hir::ViewPathSimple(name, _) => {\n+                        check_rename(self, item.id, name);\n                     }\n                     hir::ViewPathList(ref prefix, ref items) => {\n                         for item in items {\n-                            if let Some(ident) = item.node.rename() {\n-                                check_rename(self, item.node.id(), ident);\n+                            if let Some(name) = item.node.rename() {\n+                                check_rename(self, item.node.id(), name);\n                             }\n                         }\n \n@@ -2264,7 +2264,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 let mut function_type_rib = Rib::new(rib_kind);\n                 let mut seen_bindings = HashSet::new();\n                 for (index, type_parameter) in generics.ty_params.iter().enumerate() {\n-                    let name = type_parameter.ident.name;\n+                    let name = type_parameter.name;\n                     debug!(\"with_type_parameter_rib: {}\", type_parameter.id);\n \n                     if seen_bindings.contains(&name) {\n@@ -2390,7 +2390,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn resolve_generics(&mut self, generics: &Generics) {\n         for type_parameter in generics.ty_params.iter() {\n-            self.check_if_primitive_type_name(type_parameter.ident.name, type_parameter.span);\n+            self.check_if_primitive_type_name(type_parameter.name, type_parameter.span);\n         }\n         for predicate in &generics.where_clause.predicates {\n             match predicate {\n@@ -2486,7 +2486,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 ConstImplItem(..) => {\n                                     // If this is a trait impl, ensure the const\n                                     // exists in trait\n-                                    this.check_trait_item(impl_item.ident.name,\n+                                    this.check_trait_item(impl_item.name,\n                                                           impl_item.span,\n                                         |n, s| ResolutionError::ConstNotMemberOfTrait(n, s));\n                                     this.with_constant_rib(|this| {\n@@ -2496,7 +2496,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 MethodImplItem(ref sig, _) => {\n                                     // If this is a trait impl, ensure the method\n                                     // exists in trait\n-                                    this.check_trait_item(impl_item.ident.name,\n+                                    this.check_trait_item(impl_item.name,\n                                                           impl_item.span,\n                                         |n, s| ResolutionError::MethodNotMemberOfTrait(n, s));\n \n@@ -2513,7 +2513,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 TypeImplItem(ref ty) => {\n                                     // If this is a trait impl, ensure the type\n                                     // exists in trait\n-                                    this.check_trait_item(impl_item.ident.name,\n+                                    this.check_trait_item(impl_item.name,\n                                                           impl_item.span,\n                                         |n, s| ResolutionError::TypeNotMemberOfTrait(n, s));\n \n@@ -3817,19 +3817,19 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn record_candidate_traits_for_expr_if_necessary(&mut self, expr: &Expr) {\n         match expr.node {\n-            ExprField(_, ident) => {\n+            ExprField(_, name) => {\n                 // FIXME(#6890): Even though you can't treat a method like a\n                 // field, we need to add any trait methods we find that match\n                 // the field name so that we can do some nice error reporting\n                 // later on in typeck.\n-                let traits = self.get_traits_containing_item(ident.node.name);\n+                let traits = self.get_traits_containing_item(name.node);\n                 self.trait_map.insert(expr.id, traits);\n             }\n-            ExprMethodCall(ident, _, _) => {\n+            ExprMethodCall(name, _, _) => {\n                 debug!(\"(recording candidate traits for expr) recording \\\n                         traits for {}\",\n                        expr.id);\n-                let traits = self.get_traits_containing_item(ident.node.name);\n+                let traits = self.get_traits_containing_item(name.node);\n                 self.trait_map.insert(expr.id, traits);\n             }\n             _ => {"}, {"sha": "af0780587e8b0ec9dba6c8898218dc37074b0c18", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -1436,7 +1436,7 @@ fn is_discr_reassigned(bcx: Block, discr: &hir::Expr, body: &hir::Expr) -> bool\n                 Some(def::DefLocal(vid)) | Some(def::DefUpvar(vid, _, _)) => vid,\n                 _ => return false\n             };\n-            (vid, Some(mc::NamedField(field.node.name)))\n+            (vid, Some(mc::NamedField(field.node)))\n         },\n         hir::ExprTupField(ref base, field) => {\n             let vid = match bcx.tcx().def_map.borrow().get(&base.id).map(|d| d.full_def()) {\n@@ -1872,7 +1872,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n             let pat_v = VariantInfo::of_node(tcx, pat_ty, pat.id);\n             for f in fields {\n-                let name = f.node.ident.name;\n+                let name = f.node.name;\n                 let fldptr = adt::trans_field_ptr(\n                     bcx,\n                     &*pat_repr,"}, {"sha": "dd0c06c9142e60b62af197a1626dc032e21c294d", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -2099,7 +2099,7 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n       }\n       hir::ItemImpl(_, _, ref generics, _, _, ref impl_items) => {\n         meth::trans_impl(ccx,\n-                         item.ident,\n+                         item.name,\n                          &impl_items[..],\n                          generics,\n                          item.id);"}, {"sha": "ccf602126eb2c72defbd19f333cb7c5bef95c343", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -574,7 +574,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let (bv, bt) = const_expr(cx, &**base, param_substs, fn_args);\n             let brepr = adt::represent_type(cx, bt);\n             let vinfo = VariantInfo::from_ty(cx.tcx(), bt, None);\n-            let ix = vinfo.field_index(field.node.name);\n+            let ix = vinfo.field_index(field.node);\n             adt::const_get_field(cx, &*brepr, bv, vinfo.discr, ix)\n         },\n         hir::ExprTupField(ref base, idx) => {\n@@ -742,7 +742,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             let VariantInfo { discr, fields } = VariantInfo::of_node(cx.tcx(), ety, e.id);\n             let cs = fields.iter().enumerate().map(|(ix, &Field(f_name, _))| {\n-                match (fs.iter().find(|f| f_name == f.ident.node.name), base_val) {\n+                match (fs.iter().find(|f| f_name == f.name.node), base_val) {\n                     (Some(ref f), _) => const_expr(cx, &*f.expr, param_substs, fn_args).0,\n                     (_, Some((bv, _))) => adt::const_get_field(cx, &*repr, bv, discr, ix),\n                     (_, None) => cx.sess().span_bug(e.span, \"missing struct field\"),"}, {"sha": "fa2c476f6133b120f94c9c96b94bd01eca8533c2", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -1858,8 +1858,8 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     let (name, span) = match var_item {\n         hir_map::NodeItem(item) => {\n             match item.node {\n-                hir::ItemStatic(..) => (item.ident.name, item.span),\n-                hir::ItemConst(..) => (item.ident.name, item.span),\n+                hir::ItemStatic(..) => (item.name, item.span),\n+                hir::ItemConst(..) => (item.name, item.span),\n                 _ => {\n                     cx.sess()\n                       .span_bug(item.span,"}, {"sha": "ebd2b7ea41811cca722009cb569708412d3446e3", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -242,7 +242,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             match item.node {\n                 hir::ItemFn(ref fn_decl, _, _, _, ref generics, ref top_level_block) => {\n-                    (item.ident.name, fn_decl, generics, top_level_block, item.span, true)\n+                    (item.name, fn_decl, generics, top_level_block, item.span, true)\n                 }\n                 _ => {\n                     cx.sess().span_bug(item.span,\n@@ -257,7 +257,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         return FunctionDebugContext::FunctionWithoutDebugInfo;\n                     }\n \n-                    (impl_item.ident.name,\n+                    (impl_item.name,\n                      &sig.decl,\n                      &sig.generics,\n                      body,\n@@ -296,7 +296,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         return FunctionDebugContext::FunctionWithoutDebugInfo;\n                     }\n \n-                    (trait_item.ident.name,\n+                    (trait_item.name,\n                      &sig.decl,\n                      &sig.generics,\n                      body,\n@@ -520,7 +520,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n         // Handle other generic parameters\n         let actual_types = param_substs.types.get_slice(subst::FnSpace);\n-        for (index, &hir::TyParam{ ident, .. }) in generics.ty_params.iter().enumerate() {\n+        for (index, &hir::TyParam{ name, .. }) in generics.ty_params.iter().enumerate() {\n             let actual_type = actual_types[index];\n             // Add actual type name to <...> clause of function name\n             let actual_type_name = compute_debuginfo_type_name(cx,\n@@ -535,7 +535,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // Again, only create type information if full debuginfo is enabled\n             if cx.sess().opts.debuginfo == FullDebugInfo {\n                 let actual_type_metadata = type_metadata(cx, actual_type, codemap::DUMMY_SP);\n-                let name = CString::new(ident.name.as_str().as_bytes()).unwrap();\n+                let name = CString::new(name.as_str().as_bytes()).unwrap();\n                 let param_metadata = unsafe {\n                     llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n                         DIB(cx),"}, {"sha": "f2dcf84d41920448498fae36ed2b641711f0817f", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -664,8 +664,8 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         hir::ExprPath(..) => {\n             trans_def(bcx, expr, bcx.def(expr.id))\n         }\n-        hir::ExprField(ref base, ident) => {\n-            trans_rec_field(bcx, &**base, ident.node.name)\n+        hir::ExprField(ref base, name) => {\n+            trans_rec_field(bcx, &**base, name.node)\n         }\n         hir::ExprTupField(ref base, idx) => {\n             trans_rec_tup_field(bcx, &**base, idx.node)\n@@ -1114,7 +1114,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // trans. Shudder.\n             fn make_field(field_name: &str, expr: P<hir::Expr>) -> hir::Field {\n                 hir::Field {\n-                    ident: codemap::dummy_spanned(token::str_to_ident(field_name)),\n+                    name: codemap::dummy_spanned(token::str_to_ident(field_name).name),\n                     expr: expr,\n                     span: codemap::DUMMY_SP,\n                 }\n@@ -1408,7 +1408,7 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let mut need_base = vec![true; vinfo.fields.len()];\n \n     let numbered_fields = fields.iter().map(|field| {\n-        let pos = vinfo.field_index(field.ident.node.name);\n+        let pos = vinfo.field_index(field.name.node);\n         need_base[pos] = false;\n         (pos, &*field.expr)\n     }).collect::<Vec<_>>();"}, {"sha": "0310a8a6041065c8676465f6455c52119d9065ab", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -908,7 +908,7 @@ pub fn link_name(i: &hir::ForeignItem) -> InternedString {\n         Some(ln) => ln.clone(),\n         None => match weak_lang_items::link_name(&i.attrs) {\n             Some(name) => name,\n-            None => i.ident.name.as_str(),\n+            None => i.name.as_str(),\n         }\n     }\n }"}, {"sha": "605c27e0caa33644e624d333d0b892a1c23ef5fe", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -50,7 +50,7 @@ use syntax::codemap::Span;\n use std::cmp::Ordering;\n \n pub fn get_simple_intrinsic(ccx: &CrateContext, item: &hir::ForeignItem) -> Option<ValueRef> {\n-    let name = match &*item.ident.name.as_str() {\n+    let name = match &*item.name.as_str() {\n         \"sqrtf32\" => \"llvm.sqrt.f32\",\n         \"sqrtf64\" => \"llvm.sqrt.f64\",\n         \"powif32\" => \"llvm.powi.f32\",\n@@ -185,7 +185,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         _ => panic!(\"expected bare_fn in trans_intrinsic_call\")\n     };\n     let foreign_item = tcx.map.expect_foreign_item(node);\n-    let name = foreign_item.ident.name.as_str();\n+    let name = foreign_item.name.as_str();\n \n     // For `transmute` we can just trans the input expr directly into dest\n     if name == \"transmute\" {\n@@ -931,7 +931,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, _) => {\n             let intr = match Intrinsic::find(tcx, &name) {\n                 Some(intr) => intr,\n-                None => ccx.sess().span_bug(foreign_item.span, \"unknown intrinsic\"),\n+                None => ccx.sess().span_bug(foreign_item.span,\n+                                            &format!(\"unknown intrinsic '{}'\", name)),\n             };\n             fn one<T>(x: Vec<T>) -> T {\n                 assert_eq!(x.len(), 1);"}, {"sha": "6dcc60dc96276b90431cb4c63a25aaad9f5df048", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -53,7 +53,7 @@ const VTABLE_OFFSET: usize = 3;\n /// be generated once they are invoked with specific type parameters,\n /// see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n pub fn trans_impl(ccx: &CrateContext,\n-                  name: ast::Ident,\n+                  name: ast::Name,\n                   impl_items: &[P<hir::ImplItem>],\n                   generics: &hir::Generics,\n                   id: ast::NodeId) {"}, {"sha": "df0323350fdee81b45a2401d7ee6185774bf53a3", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -194,7 +194,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n         hir_map::NodeVariant(v) => {\n             let variant = inlined_variant_def(ccx, fn_id.node);\n-            assert_eq!(v.node.name.name, variant.name);\n+            assert_eq!(v.node.name, variant.name);\n             let d = mk_lldecl(abi::Rust);\n             attributes::inline(d, attributes::InlineAttr::Hint);\n             trans_enum_variant(ccx, fn_id.node, variant.disr_val, psubsts, d);"}, {"sha": "5be450ea27832586ff460775821178d076ae5352", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -545,7 +545,7 @@ fn convert_angle_bracketed_parameters<'tcx>(this: &AstConv<'tcx>,\n \n     let assoc_bindings: Vec<_> =\n         data.bindings.iter()\n-                     .map(|b| ConvertedBinding { item_name: b.ident.name,\n+                     .map(|b| ConvertedBinding { item_name: b.name,\n                                                  ty: ast_ty_to_ty(this, rscope, &*b.ty),\n                                                  span: b.span })\n                      .collect();\n@@ -1313,7 +1313,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         match tcx.map.expect_item(trait_did.node).node {\n             hir::ItemTrait(_, _, _, ref trait_items) => {\n                 let item = trait_items.iter()\n-                                      .find(|i| i.ident.name == assoc_name)\n+                                      .find(|i| i.name == assoc_name)\n                                       .expect(\"missing associated type\");\n                 DefId::local(item.id)\n             }"}, {"sha": "136b3c4405d5b989e9221ba06e5129d6203ec156", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -706,25 +706,25 @@ pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n     // Typecheck each field.\n     for &Spanned { node: ref field, span } in fields {\n-        let field_ty = match used_fields.entry(field.ident.name) {\n+        let field_ty = match used_fields.entry(field.name) {\n             Occupied(occupied) => {\n                 span_err!(tcx.sess, span, E0025,\n                     \"field `{}` bound multiple times in the pattern\",\n-                    field.ident);\n+                    field.name);\n                 span_note!(tcx.sess, *occupied.get(),\n                     \"field `{}` previously bound here\",\n-                    field.ident);\n+                    field.name);\n                 tcx.types.err\n             }\n             Vacant(vacant) => {\n                 vacant.insert(span);\n-                field_map.get(&field.ident.name)\n+                field_map.get(&field.name)\n                     .map(|f| pcx.fcx.field_ty(span, f, substs))\n                     .unwrap_or_else(|| {\n                         span_err!(tcx.sess, span, E0026,\n                             \"struct `{}` does not have a field named `{}`\",\n                             tcx.item_path_str(variant.did),\n-                            field.ident);\n+                            field.name);\n                         tcx.types.err\n                     })\n             }"}, {"sha": "8a114473e3c620e328131c31bf767879c98c6d37", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -73,7 +73,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n     }\n \n     let tcx = ccx.tcx;\n-    let name = it.ident.name.as_str();\n+    let name = it.name.as_str();\n     let (n_tps, inputs, output) = if name.starts_with(\"atomic_\") {\n         let split : Vec<&str> = name.split('_').collect();\n         assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n@@ -367,7 +367,7 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n     let tcx = ccx.tcx;\n     let i_ty = tcx.lookup_item_type(DefId::local(it.id));\n     let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n-    let name = it.ident.name.as_str();\n+    let name = it.name.as_str();\n \n     let (n_tps, inputs, output) = match &*name {\n         \"simd_eq\" | \"simd_ne\" | \"simd_lt\" | \"simd_le\" | \"simd_gt\" | \"simd_ge\" => {"}, {"sha": "47ddbfdb8cc3c34d9267c54bdf7865eb45db9068", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -119,7 +119,7 @@ use syntax::abi;\n use syntax::ast;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n-use syntax::codemap::{self, Span};\n+use syntax::codemap::{self, Span, Spanned};\n use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::{self, InternedString};\n use syntax::ptr::P;\n@@ -698,7 +698,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n       }\n       hir::ItemFn(..) => {} // entirely within check_item_body\n       hir::ItemImpl(_, _, _, _, _, ref impl_items) => {\n-          debug!(\"ItemImpl {} with id {}\", it.ident, it.id);\n+          debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n           match ccx.tcx.impl_trait_ref(DefId::local(it.id)) {\n               Some(impl_trait_ref) => {\n                 check_impl_items_against_trait(ccx,\n@@ -761,7 +761,7 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n         check_bare_fn(ccx, &**decl, &**body, it.id, it.span, fn_pty.ty, param_env);\n       }\n       hir::ItemImpl(_, _, _, _, _, ref impl_items) => {\n-        debug!(\"ItemImpl {} with id {}\", it.ident, it.id);\n+        debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n \n         let impl_pty = ccx.tcx.lookup_item_type(DefId::local(it.id));\n \n@@ -838,14 +838,14 @@ fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         Position::ArgumentNamed(s) if s == \"Self\" => (),\n                         // So is `{A}` if A is a type parameter\n                         Position::ArgumentNamed(s) => match types.iter().find(|t| {\n-                            t.ident.name == s\n+                            t.name == s\n                         }) {\n                             Some(_) => (),\n                             None => {\n                                 span_err!(ccx.tcx.sess, attr.span, E0230,\n                                                  \"there is no type parameter \\\n                                                           {} on trait {}\",\n-                                                           s, item.ident);\n+                                                           s, item.name);\n                             }\n                         },\n                         // `{:1}` and `{}` are not to be used\n@@ -988,7 +988,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 let is_implemented = impl_items.iter().any(|ii| {\n                     match ii.node {\n                         hir::ConstImplItem(..) => {\n-                            ii.ident.name == associated_const.name\n+                            ii.name == associated_const.name\n                         }\n                         _ => false,\n                     }\n@@ -1009,7 +1009,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     impl_items.iter().any(|ii| {\n                         match ii.node {\n                             hir::MethodImplItem(..) => {\n-                                ii.ident.name == trait_method.name\n+                                ii.name == trait_method.name\n                             }\n                             _ => false,\n                         }\n@@ -1028,7 +1028,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 let is_implemented = impl_items.iter().any(|ii| {\n                     match ii.node {\n                         hir::TypeImplItem(_) => {\n-                            ii.ident.name == associated_type.name\n+                            ii.name == associated_type.name\n                         }\n                         _ => false,\n                     }\n@@ -1058,7 +1058,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         span_err!(tcx.sess, invalidator.span, E0399,\n                   \"the following trait items need to be reimplemented \\\n                    as `{}` was overridden: `{}`\",\n-                  invalidator.ident,\n+                  invalidator.name,\n                   invalidated_items.iter()\n                                    .map(|name| name.to_string())\n                                    .collect::<Vec<_>>().join(\"`, `\"))\n@@ -2820,7 +2820,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     // Checks a method call.\n     fn check_method_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                    expr: &'tcx hir::Expr,\n-                                   method_name: hir::SpannedIdent,\n+                                   method_name: Spanned<ast::Name>,\n                                    args: &'tcx [P<hir::Expr>],\n                                    tps: &[P<hir::Ty>],\n                                    expected: Expectation<'tcx>,\n@@ -2836,7 +2836,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let tps = tps.iter().map(|ast_ty| fcx.to_ty(&**ast_ty)).collect::<Vec<_>>();\n         let fn_ty = match method::lookup(fcx,\n                                          method_name.span,\n-                                         method_name.node.name,\n+                                         method_name.node,\n                                          expr_t,\n                                          tps,\n                                          expr,\n@@ -2849,7 +2849,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n             Err(error) => {\n                 method::report_error(fcx, method_name.span, expr_t,\n-                                     method_name.node.name, Some(rcvr), error);\n+                                     method_name.node, Some(rcvr), error);\n                 fcx.write_error(expr.id);\n                 fcx.tcx().types.err\n             }\n@@ -2916,7 +2916,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                             expr: &'tcx hir::Expr,\n                             lvalue_pref: LvaluePreference,\n                             base: &'tcx hir::Expr,\n-                            field: &hir::SpannedIdent) {\n+                            field: &Spanned<ast::Name>) {\n         let tcx = fcx.ccx.tcx;\n         check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n@@ -2933,7 +2933,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     ty::TyStruct(base_def, substs) => {\n                         debug!(\"struct named {:?}\",  base_t);\n                         base_def.struct_variant()\n-                                .find_field_named(field.node.name)\n+                                .find_field_named(field.node)\n                                 .map(|f| fcx.field_ty(expr.span, f, substs))\n                     }\n                     _ => None\n@@ -2948,7 +2948,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             None => {}\n         }\n \n-        if method::exists(fcx, field.span, field.node.name, expr_t, expr.id) {\n+        if method::exists(fcx, field.span, field.node, expr_t, expr.id) {\n             fcx.type_error_message(\n                 field.span,\n                 |actual| {\n@@ -2981,10 +2981,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // displays hints about the closest matches in field names\n     fn suggest_field_names<'tcx>(variant: ty::VariantDef<'tcx>,\n-                                 field: &hir::SpannedIdent,\n+                                 field: &Spanned<ast::Name>,\n                                  tcx: &ty::ctxt<'tcx>,\n                                  skip : Vec<InternedString>) {\n-        let name = field.node.name.as_str();\n+        let name = field.node.as_str();\n         // only find fits with at least one matching letter\n         let mut best_dist = name.len();\n         let mut best = None;\n@@ -3082,22 +3082,21 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                       field: &hir::Field,\n                                       skip_fields: &[hir::Field]) {\n         fcx.type_error_message(\n-            field.ident.span,\n+            field.name.span,\n             |actual| if let ty::TyEnum(..) = ty.sty {\n                 format!(\"struct variant `{}::{}` has no field named `{}`\",\n-                        actual, variant.name.as_str(), field.ident.node)\n+                        actual, variant.name.as_str(), field.name.node)\n             } else {\n                 format!(\"structure `{}` has no field named `{}`\",\n-                        actual, field.ident.node)\n+                        actual, field.name.node)\n             },\n             ty,\n             None);\n         // prevent all specified fields from being suggested\n-        let skip_fields = skip_fields.iter().map(|ref x| x.ident.node.name.as_str());\n-        suggest_field_names(variant, &field.ident, fcx.tcx(), skip_fields.collect());\n+        let skip_fields = skip_fields.iter().map(|ref x| x.name.node.as_str());\n+        suggest_field_names(variant, &field.name, fcx.tcx(), skip_fields.collect());\n     }\n \n-\n     fn check_expr_struct_fields<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                           adt_ty: Ty<'tcx>,\n                                           span: Span,\n@@ -3121,15 +3120,15 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         for field in ast_fields {\n             let expected_field_type;\n \n-            if let Some(v_field) = remaining_fields.remove(&field.ident.node.name) {\n+            if let Some(v_field) = remaining_fields.remove(&field.name.node) {\n                 expected_field_type = fcx.field_ty(field.span, v_field, substs);\n             } else {\n                 error_happened = true;\n                 expected_field_type = tcx.types.err;\n-                if let Some(_) = variant.find_field_named(field.ident.node.name) {\n-                    span_err!(fcx.tcx().sess, field.ident.span, E0062,\n+                if let Some(_) = variant.find_field_named(field.name.node) {\n+                    span_err!(fcx.tcx().sess, field.name.span, E0062,\n                         \"field `{}` specified more than once\",\n-                        field.ident.node);\n+                        field.name.node);\n                 } else {\n                     report_unknown_field(fcx, adt_ty, variant, field, ast_fields);\n                 }\n@@ -3506,8 +3505,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           let ret_ty = fcx.expr_ty(expr);\n           fcx.register_wf_obligation(ret_ty, expr.span, traits::MiscObligation);\n       }\n-      hir::ExprMethodCall(ident, ref tps, ref args) => {\n-          check_method_call(fcx, expr, ident, &args[..], &tps[..], expected, lvalue_pref);\n+      hir::ExprMethodCall(name, ref tps, ref args) => {\n+          check_method_call(fcx, expr, name, &args[..], &tps[..], expected, lvalue_pref);\n           let arg_tys = args.iter().map(|a| fcx.expr_ty(&**a));\n           let args_err = arg_tys.fold(false, |rest_err, a| rest_err || a.references_error());\n           if args_err {\n@@ -4939,7 +4938,7 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         if !*b {\n             span_err!(ccx.tcx.sess, span, E0091,\n                 \"type parameter `{}` is unused\",\n-                tps[i].ident);\n+                tps[i].name);\n         }\n     }\n }"}, {"sha": "902ebcc3da87b7a1e77603fee4ee9fcf9bcdfc78", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -324,7 +324,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 -> ty::ParamTy\n     {\n         let name = match space {\n-            TypeSpace => ast_generics.ty_params[index].ident.name,\n+            TypeSpace => ast_generics.ty_params[index].name,\n             SelfSpace => special_idents::type_self.name,\n             FnSpace => self.tcx().sess.bug(\"Fn space occupied?\"),\n         };"}, {"sha": "0e462b2a8525d8915ece80ae7c772f350154f47d", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -431,7 +431,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 -> ty::ParamTy\n     {\n         let name = match space {\n-            TypeSpace => ast_generics.ty_params[index].ident.name,\n+            TypeSpace => ast_generics.ty_params[index].name,\n             SelfSpace => special_idents::type_self.name,\n             FnSpace => self.tcx().sess.bug(\"Fn space occupied?\"),\n         };"}, {"sha": "228f1f0fe445b287e96a2d70bbe80947984a3fb2", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -149,7 +149,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         if let Some(trait_ref) = self.crate_context.tcx.impl_trait_ref(impl_did) {\n             debug!(\"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n                    trait_ref,\n-                   item.ident);\n+                   item.name);\n \n             enforce_trait_manually_implementable(self.crate_context.tcx,\n                                                  item.span,"}, {"sha": "cd3c630c7abb5d579b753b81ec6d8dd1760d4aaf", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -577,7 +577,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             container: ImplOrTraitItemContainer,\n                             sig: &hir::MethodSig,\n                             id: ast::NodeId,\n-                            ident: ast::Ident,\n+                            name: ast::Name,\n                             vis: hir::Visibility,\n                             untransformed_rcvr_ty: Ty<'tcx>,\n                             rcvr_ty_generics: &ty::Generics<'tcx>,\n@@ -592,7 +592,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                               sig, untransformed_rcvr_ty);\n \n     let def_id = DefId::local(id);\n-    let ty_method = ty::Method::new(ident.name,\n+    let ty_method = ty::Method::new(name,\n                                     ty_generics,\n                                     ty_generic_predicates,\n                                     fty,\n@@ -605,7 +605,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let fty = ccx.tcx.mk_fn(Some(def_id),\n                             ccx.tcx.mk_bare_fn(ty_method.fty.clone()));\n     debug!(\"method {} (id {}) has type {:?}\",\n-            ident, id, fty);\n+            name, id, fty);\n     ccx.tcx.register_item_type(def_id, TypeScheme {\n         generics: ty_method.generics.clone(),\n         ty: fty\n@@ -643,7 +643,7 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                       container: ImplOrTraitItemContainer,\n-                                      ident: ast::Ident,\n+                                      name: ast::Name,\n                                       id: ast::NodeId,\n                                       vis: hir::Visibility,\n                                       ty: ty::Ty<'tcx>,\n@@ -656,7 +656,7 @@ fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let default_id = default.map(|expr| DefId::local(expr.id));\n \n     let associated_const = Rc::new(ty::AssociatedConst {\n-        name: ident.name,\n+        name: name,\n         vis: vis,\n         def_id: DefId::local(id),\n         container: container,\n@@ -669,13 +669,13 @@ fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                      container: ImplOrTraitItemContainer,\n-                                     ident: ast::Ident,\n+                                     name: ast::Name,\n                                      id: ast::NodeId,\n                                      vis: hir::Visibility,\n                                      ty: Option<Ty<'tcx>>)\n {\n     let associated_type = Rc::new(ty::AssociatedType {\n-        name: ident.name,\n+        name: name,\n         vis: vis,\n         ty: ty,\n         def_id: DefId::local(id),\n@@ -691,7 +691,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n                                  untransformed_rcvr_ty: Ty<'tcx>,\n                                  rcvr_ty_generics: &ty::Generics<'tcx>,\n                                  rcvr_ty_predicates: &ty::GenericPredicates<'tcx>)\n-    where I: Iterator<Item=(&'i hir::MethodSig, ast::NodeId, ast::Ident, hir::Visibility, Span)>\n+    where I: Iterator<Item=(&'i hir::MethodSig, ast::NodeId, ast::Name, hir::Visibility, Span)>\n {\n     debug!(\"convert_methods(untransformed_rcvr_ty={:?}, rcvr_ty_generics={:?}, \\\n                             rcvr_ty_predicates={:?})\",\n@@ -743,7 +743,7 @@ fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n \n fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n     let tcx = ccx.tcx;\n-    debug!(\"convert: item {} with id {}\", it.ident, it.id);\n+    debug!(\"convert: item {} with id {}\", it.name, it.id);\n     match it.node {\n         // These don't define types.\n         hir::ItemExternCrate(_) | hir::ItemUse(_) |\n@@ -823,7 +823,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                     hir::TypeImplItem(_) => &mut seen_type_items,\n                     _                    => &mut seen_value_items,\n                 };\n-                if !seen_items.insert(impl_item.ident.name) {\n+                if !seen_items.insert(impl_item.name) {\n                     let desc = match impl_item.node {\n                         hir::ConstImplItem(_, _) => \"associated constant\",\n                         hir::TypeImplItem(_) => \"associated type\",\n@@ -846,7 +846,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                                ty: ty,\n                                            });\n                     convert_associated_const(ccx, ImplContainer(DefId::local(it.id)),\n-                                             impl_item.ident, impl_item.id,\n+                                             impl_item.name, impl_item.id,\n                                              impl_item.vis.inherit_from(parent_visibility),\n                                              ty, Some(&*expr));\n                 }\n@@ -863,7 +863,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                     let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, ty);\n \n                     convert_associated_type(ccx, ImplContainer(DefId::local(it.id)),\n-                                            impl_item.ident, impl_item.id, impl_item.vis,\n+                                            impl_item.name, impl_item.id, impl_item.vis,\n                                             Some(typ));\n                 }\n             }\n@@ -875,7 +875,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                     // { fn foo(); }` is public, but private in `impl { fn\n                     // foo(); }`).\n                     let method_vis = ii.vis.inherit_from(parent_visibility);\n-                    Some((sig, ii.id, ii.ident, method_vis, ii.span))\n+                    Some((sig, ii.id, ii.name, method_vis, ii.span))\n                 } else {\n                     None\n                 }\n@@ -925,7 +925,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                                    ty: ty,\n                                                });\n                         convert_associated_const(ccx, TraitContainer(DefId::local(it.id)),\n-                                                 trait_item.ident, trait_item.id,\n+                                                 trait_item.name, trait_item.id,\n                                                  hir::Public, ty, default.as_ref().map(|d| &**d));\n                     }\n                     _ => {}\n@@ -941,7 +941,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                         });\n \n                         convert_associated_type(ccx, TraitContainer(DefId::local(it.id)),\n-                                                trait_item.ident, trait_item.id, hir::Public,\n+                                                trait_item.name, trait_item.id, hir::Public,\n                                                 typ);\n                     }\n                     _ => {}\n@@ -953,7 +953,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                     hir::MethodTraitItem(ref sig, _) => sig,\n                     _ => return None,\n                 };\n-                Some((sig, ti.id, ti.ident, hir::Inherited, ti.span))\n+                Some((sig, ti.id, ti.name, hir::Inherited, ti.span))\n             });\n \n             // Run convert_methods on the trait methods.\n@@ -1099,18 +1099,18 @@ fn convert_struct_variant<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let fields = def.fields.iter().map(|f| {\n         let fid = DefId::local(f.node.id);\n         match f.node.kind {\n-            hir::NamedField(ident, vis) => {\n-                let dup_span = seen_fields.get(&ident.name).cloned();\n+            hir::NamedField(name, vis) => {\n+                let dup_span = seen_fields.get(&name).cloned();\n                 if let Some(prev_span) = dup_span {\n                     span_err!(tcx.sess, f.span, E0124,\n                               \"field `{}` is already declared\",\n-                              ident.name);\n+                              name);\n                     span_note!(tcx.sess, prev_span, \"previously declared here\");\n                 } else {\n-                    seen_fields.insert(ident.name, f.span);\n+                    seen_fields.insert(name, f.span);\n                 }\n \n-                ty::FieldDefData::new(fid, ident.name, vis)\n+                ty::FieldDefData::new(fid, name, vis)\n             },\n             hir::UnnamedField(vis) => {\n                 ty::FieldDefData::new(fid, special_idents::unnamed_field.name, vis)\n@@ -1135,7 +1135,7 @@ fn convert_struct_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n     tcx.intern_adt_def(\n         did,\n         ty::AdtKind::Struct,\n-        vec![convert_struct_variant(tcx, did, it.ident.name, 0, def)]\n+        vec![convert_struct_variant(tcx, did, it.name, 0, def)]\n     )\n }\n \n@@ -1195,7 +1195,7 @@ fn convert_enum_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n         if let Some(prev_disr_val) = prev_disr_val {\n             let result = repr_type.disr_incr(prev_disr_val);\n             if let None = result {\n-                report_discrim_overflow(tcx, v.span, &v.node.name.name.as_str(),\n+                report_discrim_overflow(tcx, v.span, &v.node.name.as_str(),\n                                              repr_type, prev_disr_val);\n             }\n             result\n@@ -1209,7 +1209,7 @@ fn convert_enum_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                   -> ty::VariantDefData<'tcx, 'tcx>\n     {\n         let did = DefId::local(v.node.id);\n-        let name = v.node.name.name;\n+        let name = v.node.name;\n         match v.node.kind {\n             hir::TupleVariantKind(ref va) => {\n                 ty::VariantDefData {\n@@ -1369,7 +1369,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let associated_type_names: Vec<_> = items.iter().filter_map(|trait_item| {\n         match trait_item.node {\n-            hir::TypeTraitItem(..) => Some(trait_item.ident.name),\n+            hir::TypeTraitItem(..) => Some(trait_item.name),\n             _ => None,\n         }\n     }).collect();\n@@ -1417,7 +1417,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     .iter()\n                     .enumerate()\n                     .map(|(i, def)| tcx.mk_param(TypeSpace,\n-                                                 i as u32, def.ident.name))\n+                                                 i as u32, def.name))\n                     .collect();\n \n         // ...and also create the `Self` parameter.\n@@ -1444,7 +1444,7 @@ fn trait_defines_associated_type_named(ccx: &CrateCtxt,\n \n     trait_items.iter().any(|trait_item| {\n         match trait_item.node {\n-            hir::TypeTraitItem(..) => trait_item.ident.name == assoc_name,\n+            hir::TypeTraitItem(..) => trait_item.name == assoc_name,\n             _ => false,\n         }\n     })\n@@ -1511,7 +1511,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n             };\n \n             let assoc_ty = ccx.tcx.mk_projection(self_trait_ref,\n-                                                 trait_item.ident.name);\n+                                                 trait_item.name);\n \n             let bounds = compute_bounds(&ccx.icx(&(ast_generics, trait_predicates)),\n                                         assoc_ty,\n@@ -1862,7 +1862,7 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     // type parameter (e.g., `<T:Foo>`).\n     for (index, param) in ast_generics.ty_params.iter().enumerate() {\n         let index = index as u32;\n-        let param_ty = ty::ParamTy::new(space, index, param.ident.name).to_ty(ccx.tcx);\n+        let param_ty = ty::ParamTy::new(space, index, param.name).to_ty(ccx.tcx);\n         let bounds = compute_bounds(&ccx.icx(&(base_predicates, ast_generics)),\n                                     param_ty,\n                                     &param.bounds,\n@@ -2033,7 +2033,7 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     let def = ty::TypeParameterDef {\n         space: space,\n         index: index,\n-        name: param.ident.name,\n+        name: param.name,\n         def_id: DefId::local(param.id),\n         default_def_id: DefId::local(parent),\n         default: default,\n@@ -2415,7 +2415,7 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n     for (index, ty_param) in ast_generics.ty_params.iter().enumerate() {\n         let param_ty = ty::ParamTy { space: TypeSpace,\n                                      idx: index as u32,\n-                                     name: ty_param.ident.name };\n+                                     name: ty_param.name };\n         if !input_parameters.contains(&ctp::Parameter::Type(param_ty)) {\n             report_unused_parameter(tcx, ty_param.span, \"type\", &param_ty.to_string());\n         }"}, {"sha": "21895301a6ce8d8902f4dfa746c623f45c6cf0ee", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -43,7 +43,7 @@ use super::{Clean, ToSource};\n ///\n /// The returned value is `None` if the `id` could not be inlined, and `Some`\n /// of a vector of items if it was successfully expanded.\n-pub fn try_inline(cx: &DocContext, id: ast::NodeId, into: Option<ast::Ident>)\n+pub fn try_inline(cx: &DocContext, id: ast::NodeId, into: Option<ast::Name>)\n                   -> Option<Vec<clean::Item>> {\n     let tcx = match cx.tcx_opt() {\n         Some(tcx) => tcx,"}, {"sha": "14d5ed2eb507de4b17df948358aeb9d1400bfffc", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -494,7 +494,7 @@ pub struct TyParam {\n impl Clean<TyParam> for hir::TyParam {\n     fn clean(&self, cx: &DocContext) -> TyParam {\n         TyParam {\n-            name: self.ident.clean(cx),\n+            name: self.name.clean(cx),\n             did: DefId { krate: LOCAL_CRATE, node: self.id },\n             bounds: self.bounds.clean(cx),\n             default: self.default.clean(cx),\n@@ -1257,7 +1257,7 @@ impl Clean<Item> for hir::TraitItem {\n             }\n         };\n         Item {\n-            name: Some(self.ident.clean(cx)),\n+            name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n             def_id: DefId::local(self.id),\n@@ -1290,7 +1290,7 @@ impl Clean<Item> for hir::ImplItem {\n             }, true),\n         };\n         Item {\n-            name: Some(self.ident.clean(cx)),\n+            name: Some(self.name.clean(cx)),\n             source: self.span.clean(cx),\n             attrs: self.attrs.clean(cx),\n             def_id: DefId::local(self.id),\n@@ -2386,14 +2386,14 @@ impl Clean<Vec<Item>> for doctree::Import {\n                 (ret, ImportList(resolve_use_source(cx, p.clean(cx), self.id),\n                                  remaining))\n             }\n-            hir::ViewPathSimple(i, ref p) => {\n+            hir::ViewPathSimple(name, ref p) => {\n                 if !denied {\n-                    match inline::try_inline(cx, self.id, Some(i)) {\n+                    match inline::try_inline(cx, self.id, Some(name)) {\n                         Some(items) => return items,\n                         None => {}\n                     }\n                 }\n-                (vec![], SimpleImport(i.clean(cx),\n+                (vec![], SimpleImport(name.clean(cx),\n                                       resolve_use_source(cx, p.clean(cx), self.id)))\n             }\n         };\n@@ -2484,7 +2484,7 @@ impl Clean<Item> for hir::ForeignItem {\n             }\n         };\n         Item {\n-            name: Some(self.ident.clean(cx)),\n+            name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n             def_id: DefId::local(self.id),\n@@ -2547,7 +2547,7 @@ fn name_from_pat(p: &hir::Pat) -> String {\n         PatStruct(ref name, ref fields, etc) => {\n             format!(\"{} {{ {}{} }}\", path_to_string(name),\n                 fields.iter().map(|&Spanned { node: ref fp, .. }|\n-                                  format!(\"{}: {}\", fp.ident, name_from_pat(&*fp.pat)))\n+                                  format!(\"{}: {}\", fp.name, name_from_pat(&*fp.pat)))\n                              .collect::<Vec<String>>().join(\", \"),\n                 if etc { \", ...\" } else { \"\" }\n             )\n@@ -2840,7 +2840,7 @@ pub struct TypeBinding {\n impl Clean<TypeBinding> for hir::TypeBinding {\n     fn clean(&self, cx: &DocContext) -> TypeBinding {\n         TypeBinding {\n-            name: self.ident.clean(cx),\n+            name: self.name.clean(cx),\n             ty: self.ty.clean(cx)\n         }\n     }"}, {"sha": "c234ec01b88698d37dac2a510ff72241c5894d19", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -17,13 +17,13 @@ use syntax;\n use syntax::codemap::Span;\n use syntax::abi;\n use syntax::ast;\n-use syntax::ast::{Ident, NodeId};\n+use syntax::ast::{Name, NodeId};\n use syntax::attr;\n use syntax::ptr::P;\n use rustc_front::hir;\n \n pub struct Module {\n-    pub name: Option<Ident>,\n+    pub name: Option<Name>,\n     pub attrs: Vec<ast::Attribute>,\n     pub where_outer: Span,\n     pub where_inner: Span,\n@@ -48,7 +48,7 @@ pub struct Module {\n }\n \n impl Module {\n-    pub fn new(name: Option<Ident>) -> Module {\n+    pub fn new(name: Option<Name>) -> Module {\n         Module {\n             name       : name,\n             id: 0,\n@@ -98,7 +98,7 @@ pub struct Struct {\n     pub stab: Option<attr::Stability>,\n     pub id: NodeId,\n     pub struct_type: StructType,\n-    pub name: Ident,\n+    pub name: Name,\n     pub generics: hir::Generics,\n     pub attrs: Vec<ast::Attribute>,\n     pub fields: Vec<hir::StructField>,\n@@ -113,11 +113,11 @@ pub struct Enum {\n     pub attrs: Vec<ast::Attribute>,\n     pub id: NodeId,\n     pub whence: Span,\n-    pub name: Ident,\n+    pub name: Name,\n }\n \n pub struct Variant {\n-    pub name: Ident,\n+    pub name: Name,\n     pub attrs: Vec<ast::Attribute>,\n     pub kind: hir::VariantKind,\n     pub id: ast::NodeId,\n@@ -129,7 +129,7 @@ pub struct Function {\n     pub decl: hir::FnDecl,\n     pub attrs: Vec<ast::Attribute>,\n     pub id: NodeId,\n-    pub name: Ident,\n+    pub name: Name,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub unsafety: hir::Unsafety,\n@@ -142,7 +142,7 @@ pub struct Function {\n pub struct Typedef {\n     pub ty: P<hir::Ty>,\n     pub gen: hir::Generics,\n-    pub name: Ident,\n+    pub name: Name,\n     pub id: ast::NodeId,\n     pub attrs: Vec<ast::Attribute>,\n     pub whence: Span,\n@@ -155,7 +155,7 @@ pub struct Static {\n     pub type_: P<hir::Ty>,\n     pub mutability: hir::Mutability,\n     pub expr: P<hir::Expr>,\n-    pub name: Ident,\n+    pub name: Name,\n     pub attrs: Vec<ast::Attribute>,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n@@ -166,7 +166,7 @@ pub struct Static {\n pub struct Constant {\n     pub type_: P<hir::Ty>,\n     pub expr: P<hir::Expr>,\n-    pub name: Ident,\n+    pub name: Name,\n     pub attrs: Vec<ast::Attribute>,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n@@ -176,7 +176,7 @@ pub struct Constant {\n \n pub struct Trait {\n     pub unsafety: hir::Unsafety,\n-    pub name: Ident,\n+    pub name: Name,\n     pub items: Vec<P<hir::TraitItem>>, //should be TraitItem\n     pub generics: hir::Generics,\n     pub bounds: Vec<hir::TyParamBound>,\n@@ -210,16 +210,16 @@ pub struct DefaultImpl {\n }\n \n pub struct Macro {\n-    pub name: Ident,\n+    pub name: Name,\n     pub id: ast::NodeId,\n     pub attrs: Vec<ast::Attribute>,\n     pub whence: Span,\n     pub stab: Option<attr::Stability>,\n-    pub imported_from: Option<Ident>,\n+    pub imported_from: Option<Name>,\n }\n \n pub struct ExternCrate {\n-    pub name: Ident,\n+    pub name: Name,\n     pub path: Option<String>,\n     pub vis: hir::Visibility,\n     pub attrs: Vec<ast::Attribute>,"}, {"sha": "d818115567770aadec18d876de92e667bce65354", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -83,7 +83,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     pub fn visit_struct_def(&mut self, item: &hir::Item,\n-                            name: ast::Ident, sd: &hir::StructDef,\n+                            name: ast::Name, sd: &hir::StructDef,\n                             generics: &hir::Generics) -> Struct {\n         debug!(\"Visiting struct\");\n         let struct_type = struct_type_from_def(&*sd);\n@@ -101,7 +101,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     pub fn visit_enum_def(&mut self, it: &hir::Item,\n-                          name: ast::Ident, def: &hir::EnumDef,\n+                          name: ast::Name, def: &hir::EnumDef,\n                           params: &hir::Generics) -> Enum {\n         debug!(\"Visiting enum\");\n         Enum {\n@@ -124,7 +124,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     pub fn visit_fn(&mut self, item: &hir::Item,\n-                    name: ast::Ident, fd: &hir::FnDecl,\n+                    name: ast::Name, fd: &hir::FnDecl,\n                     unsafety: &hir::Unsafety,\n                     constness: hir::Constness,\n                     abi: &abi::Abi,\n@@ -148,7 +148,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     pub fn visit_mod_contents(&mut self, span: Span, attrs: Vec<ast::Attribute> ,\n                               vis: hir::Visibility, id: ast::NodeId,\n                               m: &hir::Mod,\n-                              name: Option<ast::Ident>) -> Module {\n+                              name: Option<ast::Name>) -> Module {\n         let mut om = Module::new(name);\n         om.where_outer = span;\n         om.where_inner = m.inner;\n@@ -199,7 +199,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n     }\n \n-    fn resolve_id(&mut self, id: ast::NodeId, renamed: Option<ast::Ident>,\n+    fn resolve_id(&mut self, id: ast::NodeId, renamed: Option<ast::Name>,\n                   glob: bool, om: &mut Module, please_inline: bool) -> bool {\n         let tcx = match self.cx.tcx_opt() {\n             Some(tcx) => tcx,\n@@ -241,9 +241,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     pub fn visit_item(&mut self, item: &hir::Item,\n-                      renamed: Option<ast::Ident>, om: &mut Module) {\n+                      renamed: Option<ast::Name>, om: &mut Module) {\n         debug!(\"Visiting item {:?}\", item);\n-        let name = renamed.unwrap_or(item.ident);\n+        let name = renamed.unwrap_or(item.name);\n         match item.node {\n             hir::ItemExternCrate(ref p) => {\n                 let path = match *p {\n@@ -398,7 +398,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         Macro {\n             id: def.id,\n             attrs: def.attrs.clone(),\n-            name: def.ident,\n+            name: def.name,\n             whence: def.span,\n             stab: self.stability(def.id),\n             imported_from: def.imported_from,"}, {"sha": "62eb6022d0c22c8045ca4f0b0321efbf5ae15873", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -151,8 +151,7 @@ pub const ILLEGAL_CTXT : SyntaxContext = 1;\n \n /// A name is a part of an identifier, representing a string or gensym. It's\n /// the result of interning.\n-#[derive(Eq, Ord, PartialEq, PartialOrd, Hash,\n-           RustcEncodable, RustcDecodable, Clone, Copy)]\n+#[derive(Eq, Ord, PartialEq, PartialOrd, Hash, Clone, Copy)]\n pub struct Name(pub u32);\n \n impl<T: AsRef<str>> PartialEq<T> for Name {\n@@ -179,6 +178,18 @@ impl Name {\n /// A mark represents a unique id associated with a macro expansion\n pub type Mrk = u32;\n \n+impl Encodable for Name {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_str(&self.as_str())\n+    }\n+}\n+\n+impl Decodable for Name {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Name, D::Error> {\n+        Ok(token::intern(&try!(d.read_str())[..]))\n+    }\n+}\n+\n impl Encodable for Ident {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_str(&self.name.as_str())"}, {"sha": "81bd76211c3f854b8f8de5ef70e25ede3863f603", "filename": "src/test/auxiliary/lint_group_plugin_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs?ref=b2f379cdc23aec5c5d0d62acfcc5a4a18ebf0e30", "patch": "@@ -37,7 +37,7 @@ impl LintPass for Pass {\n \n impl LateLintPass for Pass {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n-        match &*it.ident.name.as_str() {\n+        match &*it.name.as_str() {\n             \"lintme\" => cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\"),\n             \"pleaselintme\" => cx.span_lint(PLEASE_LINT, it.span, \"item is named 'pleaselintme'\"),\n             _ => {}"}]}