{"sha": "40199f68d909cc15c67de61389328c005062502d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwMTk5ZjY4ZDkwOWNjMTVjNjdkZTYxMzg5MzI4YzAwNTA2MjUwMmQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-05-02T19:32:42Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-05-03T02:35:26Z"}, "message": "Rollup merge of #32756 - nikomatsakis:borrowck-snippet, r=nrc\n\nOverhaul borrowck error messages and compiler error formatting generally\n\nThis is a major overhaul of how the compiler reports errors. The primary goal is to be able to give many spans within the same overall context, such as this:\n\n```\n./borrow-errors.rs:73:17: 73:20: error: cannot borrow `*vec` as immutable because previous closure requires unique access [E0501]\n70     let append = |e| {\n                    ~~~ closure construction occurs here\n71         vec.push(e)\n           ~~~ previous borrow occurs due to use of `vec` in closure\n72     };\n73     let data = &vec[3];\n                   ~~~ borrow occurs here\n74 }\n   ~ borrow from closure ends here\n```\n\nHowever, in the process we made a number of other changes:\n\n- Removed the repetitive filenames from snippets and just give the line number.\n- Color the line numbers blue so they \"fade away\"\n- Remove the file name and line number from the error code suggestions since they don't seem to fit anymore. (This should probably happen in more places, like existing notes.)\n- Newlines in between errors to help group them better.\n\nThis PR is not quite ready to land, but we thought it made sense to stop here and get some feedback from people at large. It'd be great if people can check out the branch and play with it. We'd be especially interested in hearing about cases that don't look good with the new formatting (I suspect they exist).\n\nHere is a checklist of some pending work items for this PR. Some of them may be best left for follow-up PRs:\n\n- [x] Accommodate multiple files in a `MultiSpan` (this should be easy)\n  - In this case, we want to print filenames though.\n- [x] Remove duplicate E0500 code.\n- [x] Make the header message bold, rather than current hack that makes all errors/warnings bold\n- [x] Update warning text color (yellow is hard to read w/ a white background)\n\nMoved numerous follow-ups to: https://github.com/rust-lang/rust/issues/33240\n\nJoint work with @jonathandturner.\n\nFixes https://github.com/rust-lang/rust/issues/3533", "tree": {"sha": "6aa10d7d581418a88280f8ae84291958af7eb5cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6aa10d7d581418a88280f8ae84291958af7eb5cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40199f68d909cc15c67de61389328c005062502d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXKA5uAAoJEDu/TT4u95+YJwYQAKBTxcJXSoZmFxuNx++Il5S0\n13XXQpKeESgbcX1Fnvnp5uUDW6dz1GxtiwlmUzPcS+2OLc3mUEMBRi9kJIuq02cW\n+KQd9R3fzC5EXricPxep0Duc6inWmObU/K2mnlGAEBr0JCJxF+HRaIR8EqwkPDCb\nVYBW2ozZwND54A57csQdZUPFTbatm0OVfmGSWHf+hZnqqLBUGASNh+W95rOHupP8\n/62ImFX5lhZ1ZJL8g+SVPScddOF3QCiigU1qW6MbOi6989GuJrIioIyRQOCckJel\ntdvna/YGWw8U4THmvmFSdmGjgZvnio759eGBdsallGb4qMuXzAZIigrMcg9DGXy9\nurIS4S63pTyiSYz1e7r0kFy9KziOv9s41oWpBQuRstw5F0BcNBMhIa4CRKkn/fHp\noF0xo8+ZMTER8U+CjlH2CpPZFHbJREW0PAFrf/5G9pjqZ9CCcp4e+UPy97/ZqGhZ\nsiZn2e3muK+a6fx0KnPO+A7+TN3M12aDeohxlVQ11CnKy9BxmzOfWZAY1aip6puL\nWMt1+JtDANhDKBU0+MEJo6KLgvkBUV0GOSxHb0Fi3lJGnMRWJ2OoDdu1lIog5Az2\n+iBPGRyXSFu/93Ea4H7vdb1eBscRdZMg20wr9NMNQF0+oXB/SrPZZtyA36vOhU6j\n95itET3PC56upXvO5qoW\n=5wwb\n-----END PGP SIGNATURE-----", "payload": "tree 6aa10d7d581418a88280f8ae84291958af7eb5cc\nparent d80497e628945c3f11ff351030b4c62a8533e01e\nparent 9355a91224a6f715b94342c074e5bac1f9e820f3\nauthor Manish Goregaokar <manishsmail@gmail.com> 1462217562 +0530\ncommitter Manish Goregaokar <manishsmail@gmail.com> 1462242926 +0530\n\nRollup merge of #32756 - nikomatsakis:borrowck-snippet, r=nrc\n\nOverhaul borrowck error messages and compiler error formatting generally\n\nThis is a major overhaul of how the compiler reports errors. The primary goal is to be able to give many spans within the same overall context, such as this:\n\n```\n./borrow-errors.rs:73:17: 73:20: error: cannot borrow `*vec` as immutable because previous closure requires unique access [E0501]\n70     let append = |e| {\n                    ~~~ closure construction occurs here\n71         vec.push(e)\n           ~~~ previous borrow occurs due to use of `vec` in closure\n72     };\n73     let data = &vec[3];\n                   ~~~ borrow occurs here\n74 }\n   ~ borrow from closure ends here\n```\n\nHowever, in the process we made a number of other changes:\n\n- Removed the repetitive filenames from snippets and just give the line number.\n- Color the line numbers blue so they \"fade away\"\n- Remove the file name and line number from the error code suggestions since they don't seem to fit anymore. (This should probably happen in more places, like existing notes.)\n- Newlines in between errors to help group them better.\n\nThis PR is not quite ready to land, but we thought it made sense to stop here and get some feedback from people at large. It'd be great if people can check out the branch and play with it. We'd be especially interested in hearing about cases that don't look good with the new formatting (I suspect they exist).\n\nHere is a checklist of some pending work items for this PR. Some of them may be best left for follow-up PRs:\n\n- [x] Accommodate multiple files in a `MultiSpan` (this should be easy)\n  - In this case, we want to print filenames though.\n- [x] Remove duplicate E0500 code.\n- [x] Make the header message bold, rather than current hack that makes all errors/warnings bold\n- [x] Update warning text color (yellow is hard to read w/ a white background)\n\nMoved numerous follow-ups to: https://github.com/rust-lang/rust/issues/33240\n\nJoint work with @jonathandturner.\n\nFixes https://github.com/rust-lang/rust/issues/3533\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40199f68d909cc15c67de61389328c005062502d", "html_url": "https://github.com/rust-lang/rust/commit/40199f68d909cc15c67de61389328c005062502d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40199f68d909cc15c67de61389328c005062502d/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d80497e628945c3f11ff351030b4c62a8533e01e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d80497e628945c3f11ff351030b4c62a8533e01e", "html_url": "https://github.com/rust-lang/rust/commit/d80497e628945c3f11ff351030b4c62a8533e01e"}, {"sha": "9355a91224a6f715b94342c074e5bac1f9e820f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/9355a91224a6f715b94342c074e5bac1f9e820f3", "html_url": "https://github.com/rust-lang/rust/commit/9355a91224a6f715b94342c074e5bac1f9e820f3"}], "stats": {"total": 5157, "additions": 2956, "deletions": 2201}, "files": [{"sha": "efef259dcad9b5fef94d20c2b61781a2df7eb1d6", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -1569,5 +1569,5 @@ register_diagnostics! {\n     E0490, // a value of type `..` is borrowed for too long\n     E0491, // in type `..`, reference has a longer lifetime than the data it...\n     E0495, // cannot infer an appropriate lifetime due to conflicting requirements\n-    E0524, // expected a closure that implements `..` but this closure only implements `..`\n+    E0525, // expected a closure that implements `..` but this closure only implements `..`\n }"}, {"sha": "11d92f8585489e868e457ac214a80c683e43f9ab", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 26, "deletions": 31, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -249,12 +249,12 @@ pub trait ErrorReporting<'tcx> {\n                                      terr: &TypeError<'tcx>)\n                                      -> DiagnosticBuilder<'tcx>;\n \n-    fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<String>;\n+    fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<(String, String)>;\n \n     fn expected_found_str<T: fmt::Display + Resolvable<'tcx> + TypeFoldable<'tcx>>(\n         &self,\n         exp_found: &ty::error::ExpectedFound<T>)\n-        -> Option<String>;\n+        -> Option<(String, String)>;\n \n     fn report_concrete_failure(&self,\n                                origin: SubregionOrigin<'tcx>,\n@@ -535,7 +535,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                          trace: TypeTrace<'tcx>,\n                          terr: &TypeError<'tcx>)\n                          -> DiagnosticBuilder<'tcx> {\n-        let expected_found_str = match self.values_str(&trace.values) {\n+        let (expected, found) = match self.values_str(&trace.values) {\n             Some(v) => v,\n             None => {\n                 return self.tcx.sess.diagnostic().struct_dummy(); /* derived error */\n@@ -548,18 +548,17 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             false\n         };\n \n-        let expected_found_str = if is_simple_error {\n-            expected_found_str\n-        } else {\n-            format!(\"{} ({})\", expected_found_str, terr)\n-        };\n-\n         let mut err = struct_span_err!(self.tcx.sess,\n                                        trace.origin.span(),\n                                        E0308,\n-                                       \"{}: {}\",\n-                                       trace.origin,\n-                                       expected_found_str);\n+                                       \"{}\",\n+                                       trace.origin);\n+\n+        if !is_simple_error {\n+            err = err.note_expected_found(&\"type\", &expected, &found);\n+        }\n+\n+        err = err.span_label(trace.origin.span(), &terr);\n \n         self.check_and_note_conflicting_crates(&mut err, terr, trace.origin.span());\n \n@@ -574,6 +573,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             },\n             _ => ()\n         }\n+\n         err\n     }\n \n@@ -631,7 +631,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n     /// Returns a string of the form \"expected `{}`, found `{}`\", or None if this is a derived\n     /// error.\n-    fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<String> {\n+    fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<(String, String)> {\n         match *values {\n             infer::Types(ref exp_found) => self.expected_found_str(exp_found),\n             infer::TraitRefs(ref exp_found) => self.expected_found_str(exp_found),\n@@ -642,7 +642,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n     fn expected_found_str<T: fmt::Display + Resolvable<'tcx> + TypeFoldable<'tcx>>(\n         &self,\n         exp_found: &ty::error::ExpectedFound<T>)\n-        -> Option<String>\n+        -> Option<(String, String)>\n     {\n         let expected = exp_found.expected.resolve(self);\n         if expected.references_error() {\n@@ -654,9 +654,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             return None;\n         }\n \n-        Some(format!(\"expected `{}`, found `{}`\",\n-                     expected,\n-                     found))\n+        Some((format!(\"{}\", expected), format!(\"{}\", found)))\n     }\n \n     fn report_generic_bound_failure(&self,\n@@ -684,10 +682,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                                E0309,\n                                                \"{} may not live long enough\",\n                                                labeled_user_string);\n-                err.fileline_help(origin.span(),\n-                                  &format!(\"consider adding an explicit lifetime bound `{}: {}`...\",\n-                                           bound_kind,\n-                                           sub));\n+                err.help(&format!(\"consider adding an explicit lifetime bound `{}: {}`...\",\n+                         bound_kind,\n+                         sub));\n                 err\n             }\n \n@@ -698,10 +695,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                                E0310,\n                                                \"{} may not live long enough\",\n                                                labeled_user_string);\n-                err.fileline_help(origin.span(),\n-                                  &format!(\"consider adding an explicit lifetime \\\n-                                            bound `{}: 'static`...\",\n-                                           bound_kind));\n+                err.help(&format!(\"consider adding an explicit lifetime \\\n+                                   bound `{}: 'static`...\",\n+                                  bound_kind));\n                 err\n             }\n \n@@ -712,9 +708,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                                E0311,\n                                                \"{} may not live long enough\",\n                                                labeled_user_string);\n-                err.fileline_help(origin.span(),\n-                                  &format!(\"consider adding an explicit lifetime bound for `{}`\",\n-                                           bound_kind));\n+                err.help(&format!(\"consider adding an explicit lifetime bound for `{}`\",\n+                                  bound_kind));\n                 self.tcx.note_and_explain_region(\n                     &mut err,\n                     &format!(\"{} must be valid for \", labeled_user_string),\n@@ -1751,11 +1746,11 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                 };\n \n                 match self.values_str(&trace.values) {\n-                    Some(values_str) => {\n+                    Some((expected, found)) => {\n                         err.span_note(\n                             trace.origin.span(),\n-                            &format!(\"...so that {} ({})\",\n-                                    desc, values_str));\n+                            &format!(\"...so that {} (expected {}, found {})\",\n+                                    desc, expected, found));\n                     }\n                     None => {\n                         // Really should avoid printing this error at"}, {"sha": "43c0e197e16bc12a3bf09610f06aefa002aee269", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -456,17 +456,13 @@ pub fn raw_struct_lint<'a>(sess: &'a Session,\n                                    it will become a hard error in a future release!\");\n         let citation = format!(\"for more information, see {}\",\n                                future_incompatible.reference);\n-        if let Some(sp) = span {\n-            err.fileline_warn(sp, &explanation);\n-            err.fileline_note(sp, &citation);\n-        } else {\n-            err.warn(&explanation);\n-            err.note(&citation);\n-        }\n+        err.warn(&explanation);\n+        err.note(&citation);\n     }\n \n     if let Some(span) = def {\n-        err.span_note(span, \"lint level defined here\");\n+        let explanation = \"lint level defined here\";\n+        err.span_note(span, &explanation);\n     }\n \n     err\n@@ -542,7 +538,7 @@ pub trait LintContext: Sized {\n         let mut err = self.lookup(lint, Some(span), msg);\n         if self.current_level(lint) != Level::Allow {\n             if note_span == span {\n-                err.fileline_note(note_span, note);\n+                err.note(note);\n             } else {\n                 err.span_note(note_span, note);\n             }"}, {"sha": "edb1c4530c240a979a8dd682d95a5ed7792de732", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -567,7 +567,7 @@ pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n         }\n         config::ErrorOutputType::Json => Box::new(JsonEmitter::basic()),\n     };\n-    emitter.emit(None, msg, None, errors::Level::Fatal);\n+    emitter.emit(&MultiSpan::new(), msg, None, errors::Level::Fatal);\n     panic!(errors::FatalError);\n }\n \n@@ -578,7 +578,7 @@ pub fn early_warn(output: config::ErrorOutputType, msg: &str) {\n         }\n         config::ErrorOutputType::Json => Box::new(JsonEmitter::basic()),\n     };\n-    emitter.emit(None, msg, None, errors::Level::Warning);\n+    emitter.emit(&MultiSpan::new(), msg, None, errors::Level::Warning);\n }\n \n // Err(0) means compilation was stopped, but no errors were found."}, {"sha": "531a4fbf8beba07aa009ffa2dc04930a08c20647", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 56, "deletions": 109, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -206,18 +206,17 @@ fn find_similar_impl_candidates<'a, 'tcx>(\n     impl_candidates\n }\n \n-fn report_similar_impl_candidates(span: Span,\n-                                  err: &mut DiagnosticBuilder,\n+fn report_similar_impl_candidates(err: &mut DiagnosticBuilder,\n                                   impl_candidates: &[ty::TraitRef])\n {\n-    err.fileline_help(span, &format!(\"the following implementations were found:\"));\n+    err.help(&format!(\"the following implementations were found:\"));\n \n     let end = cmp::min(4, impl_candidates.len());\n     for candidate in &impl_candidates[0..end] {\n-        err.fileline_help(span, &format!(\"  {:?}\", candidate));\n+        err.help(&format!(\"  {:?}\", candidate));\n     }\n     if impl_candidates.len() > 4 {\n-        err.fileline_help(span, &format!(\"and {} others\", impl_candidates.len()-4));\n+        err.help(&format!(\"and {} others\", impl_candidates.len()-4));\n     }\n }\n \n@@ -240,7 +239,7 @@ pub fn report_overflow_error<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n                                    predicate);\n \n     if suggest_increasing_limit {\n-        suggest_new_overflow_limit(infcx.tcx, &mut err, obligation.cause.span);\n+        suggest_new_overflow_limit(infcx.tcx, &mut err);\n     }\n \n     note_obligation_cause(infcx, &mut err, obligation);\n@@ -353,19 +352,15 @@ pub fn try_report_overflow_error_type_of_infinite_size<'a, 'tcx>(\n     let mut err = recursive_type_with_infinite_size_error(tcx, main_def_id);\n     let len = struct_enum_tys.len();\n     if len > 2 {\n-        let span = tcx.map.span_if_local(main_def_id).unwrap();\n-        err.fileline_note(span,\n-                          &format!(\"type `{}` is embedded within `{}`...\",\n-                                   struct_enum_tys[0],\n-                                   struct_enum_tys[1]));\n+        err.note(&format!(\"type `{}` is embedded within `{}`...\",\n+                 struct_enum_tys[0],\n+                 struct_enum_tys[1]));\n         for &next_ty in &struct_enum_tys[1..len-1] {\n-            err.fileline_note(span,\n-                              &format!(\"...which in turn is embedded within `{}`...\", next_ty));\n+            err.note(&format!(\"...which in turn is embedded within `{}`...\", next_ty));\n         }\n-        err.fileline_note(span,\n-                          &format!(\"...which in turn is embedded within `{}`, \\\n-                                    completing the cycle.\",\n-                                   struct_enum_tys[len-1]));\n+        err.note(&format!(\"...which in turn is embedded within `{}`, \\\n+                           completing the cycle.\",\n+                          struct_enum_tys[len-1]));\n     }\n     err.emit();\n     infcx.tcx.sess.abort_if_errors();\n@@ -380,9 +375,9 @@ pub fn recursive_type_with_infinite_size_error<'tcx>(tcx: &TyCtxt<'tcx>,\n     let span = tcx.map.span_if_local(type_def_id).unwrap();\n     let mut err = struct_span_err!(tcx.sess, span, E0072, \"recursive type `{}` has infinite size\",\n                                    tcx.item_path_str(type_def_id));\n-    err.fileline_help(span, &format!(\"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n-                                      at some point to make `{}` representable\",\n-                                     tcx.item_path_str(type_def_id)));\n+    err.help(&format!(\"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n+                       at some point to make `{}` representable\",\n+                      tcx.item_path_str(type_def_id)));\n     err\n }\n \n@@ -423,24 +418,22 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                 // these notes will often be of the form\n                                 //     \"the type `T` can't be frobnicated\"\n                                 // which is somewhat confusing.\n-                                err.fileline_help(obligation.cause.span, &format!(\n-                                    \"consider adding a `where {}` bound\",\n+                                err.help(&format!(\"consider adding a `where {}` bound\",\n                                     trait_ref.to_predicate()\n                                     ));\n                             } else if let Some(s) = on_unimplemented_note(infcx, trait_ref,\n                                                                           obligation.cause.span) {\n                                 // Otherwise, if there is an on-unimplemented note,\n                                 // display it.\n-                                err.fileline_note(obligation.cause.span, &s);\n+                                err.note(&s);\n                             } else {\n                                 // If we can't show anything useful, try to find\n                                 // similar impls.\n \n                                 let impl_candidates =\n                                     find_similar_impl_candidates(infcx, trait_ref);\n                                 if impl_candidates.len() > 0 {\n-                                    report_similar_impl_candidates(obligation.cause.span,\n-                                                                   &mut err, &impl_candidates);\n+                                    report_similar_impl_candidates(&mut err, &impl_candidates);\n                                 }\n                             }\n                             note_obligation_cause(infcx, &mut err, obligation);\n@@ -499,7 +492,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         let found_kind = infcx.closure_kind(closure_def_id).unwrap();\n                         let closure_span = infcx.tcx.map.span_if_local(closure_def_id).unwrap();\n                         let mut err = struct_span_err!(\n-                            infcx.tcx.sess, closure_span, E0524,\n+                            infcx.tcx.sess, closure_span, E0525,\n                             \"expected a closure that implements the `{}` trait, but this closure \\\n                              only implements `{}`\",\n                             kind,\n@@ -570,41 +563,31 @@ pub fn report_object_safety_error<'tcx>(tcx: &TyCtxt<'tcx>,\n         }\n         match violation {\n             ObjectSafetyViolation::SizedSelf => {\n-                err.fileline_note(\n-                    span,\n-                    \"the trait cannot require that `Self : Sized`\");\n+                err.note(\"the trait cannot require that `Self : Sized`\");\n             }\n \n             ObjectSafetyViolation::SupertraitSelf => {\n-                err.fileline_note(\n-                    span,\n-                    \"the trait cannot use `Self` as a type parameter \\\n-                     in the supertrait listing\");\n+                err.note(\"the trait cannot use `Self` as a type parameter \\\n+                          in the supertrait listing\");\n             }\n \n             ObjectSafetyViolation::Method(method,\n                                           MethodViolationCode::StaticMethod) => {\n-                err.fileline_note(\n-                    span,\n-                    &format!(\"method `{}` has no receiver\",\n-                             method.name));\n+                err.note(&format!(\"method `{}` has no receiver\",\n+                         method.name));\n             }\n \n             ObjectSafetyViolation::Method(method,\n                                           MethodViolationCode::ReferencesSelf) => {\n-                err.fileline_note(\n-                    span,\n-                    &format!(\"method `{}` references the `Self` type \\\n-                              in its arguments or return type\",\n-                             method.name));\n+                err.note(&format!(\"method `{}` references the `Self` type \\\n+                                   in its arguments or return type\",\n+                                  method.name));\n             }\n \n             ObjectSafetyViolation::Method(method,\n                                           MethodViolationCode::Generic) => {\n-                err.fileline_note(\n-                    span,\n-                    &format!(\"method `{}` has generic type parameters\",\n-                             method.name));\n+                err.note(&format!(\"method `{}` has generic type parameters\",\n+                                  method.name));\n             }\n         }\n     }\n@@ -766,142 +749,106 @@ fn note_obligation_cause<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n     note_obligation_cause_code(infcx,\n                                err,\n                                &obligation.predicate,\n-                               obligation.cause.span,\n                                &obligation.cause.code);\n }\n \n fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n                                            err: &mut DiagnosticBuilder,\n                                            predicate: &T,\n-                                           cause_span: Span,\n                                            cause_code: &ObligationCauseCode<'tcx>)\n     where T: fmt::Display\n {\n     let tcx = infcx.tcx;\n     match *cause_code {\n         ObligationCauseCode::MiscObligation => { }\n         ObligationCauseCode::SliceOrArrayElem => {\n-            err.fileline_note(\n-                cause_span,\n-                \"slice and array elements must have `Sized` type\");\n+            err.note(\"slice and array elements must have `Sized` type\");\n         }\n         ObligationCauseCode::ProjectionWf(data) => {\n-            err.fileline_note(\n-                cause_span,\n-                &format!(\"required so that the projection `{}` is well-formed\",\n-                         data));\n+            err.note(&format!(\"required so that the projection `{}` is well-formed\",\n+                              data));\n         }\n         ObligationCauseCode::ReferenceOutlivesReferent(ref_ty) => {\n-            err.fileline_note(\n-                cause_span,\n-                &format!(\"required so that reference `{}` does not outlive its referent\",\n-                         ref_ty));\n+            err.note(&format!(\"required so that reference `{}` does not outlive its referent\",\n+                              ref_ty));\n         }\n         ObligationCauseCode::ItemObligation(item_def_id) => {\n             let item_name = tcx.item_path_str(item_def_id);\n-            err.fileline_note(\n-                cause_span,\n-                &format!(\"required by `{}`\", item_name));\n+            err.note(&format!(\"required by `{}`\", item_name));\n         }\n         ObligationCauseCode::ObjectCastObligation(object_ty) => {\n-            err.fileline_note(\n-                cause_span,\n-                &format!(\n-                    \"required for the cast to the object type `{}`\",\n-                    infcx.ty_to_string(object_ty)));\n+            err.note(&format!(\"required for the cast to the object type `{}`\",\n+                              infcx.ty_to_string(object_ty)));\n         }\n         ObligationCauseCode::RepeatVec => {\n-            err.fileline_note(\n-                cause_span,\n-                \"the `Copy` trait is required because the \\\n-                 repeated element will be copied\");\n+            err.note(\"the `Copy` trait is required because the \\\n+                      repeated element will be copied\");\n         }\n         ObligationCauseCode::VariableType(_) => {\n-            err.fileline_note(\n-                cause_span,\n-                \"all local variables must have a statically known size\");\n+            err.note(\"all local variables must have a statically known size\");\n         }\n         ObligationCauseCode::ReturnType => {\n-            err.fileline_note(\n-                cause_span,\n-                \"the return type of a function must have a \\\n-                 statically known size\");\n+            err.note(\"the return type of a function must have a \\\n+                      statically known size\");\n         }\n         ObligationCauseCode::AssignmentLhsSized => {\n-            err.fileline_note(\n-                cause_span,\n-                \"the left-hand-side of an assignment must have a statically known size\");\n+            err.note(\"the left-hand-side of an assignment must have a statically known size\");\n         }\n         ObligationCauseCode::StructInitializerSized => {\n-            err.fileline_note(\n-                cause_span,\n-                \"structs must have a statically known size to be initialized\");\n+            err.note(\"structs must have a statically known size to be initialized\");\n         }\n         ObligationCauseCode::ClosureCapture(var_id, _, builtin_bound) => {\n             let def_id = tcx.lang_items.from_builtin_kind(builtin_bound).unwrap();\n             let trait_name = tcx.item_path_str(def_id);\n             let name = tcx.local_var_name_str(var_id);\n-            err.fileline_note(\n-                cause_span,\n+            err.note(\n                 &format!(\"the closure that captures `{}` requires that all captured variables \\\n                           implement the trait `{}`\",\n                          name,\n                          trait_name));\n         }\n         ObligationCauseCode::FieldSized => {\n-            err.fileline_note(\n-                cause_span,\n-                \"only the last field of a struct or enum variant \\\n-                 may have a dynamically sized type\");\n+            err.note(\"only the last field of a struct or enum variant \\\n+                      may have a dynamically sized type\");\n         }\n         ObligationCauseCode::SharedStatic => {\n-            err.fileline_note(\n-                cause_span,\n-                \"shared static variables must have a type that implements `Sync`\");\n+            err.note(\"shared static variables must have a type that implements `Sync`\");\n         }\n         ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n             let parent_trait_ref = infcx.resolve_type_vars_if_possible(&data.parent_trait_ref);\n-            err.fileline_note(\n-                cause_span,\n-                &format!(\"required because it appears within the type `{}`\",\n-                         parent_trait_ref.0.self_ty()));\n+            err.note(&format!(\"required because it appears within the type `{}`\",\n+                              parent_trait_ref.0.self_ty()));\n             let parent_predicate = parent_trait_ref.to_predicate();\n             note_obligation_cause_code(infcx,\n                                        err,\n                                        &parent_predicate,\n-                                       cause_span,\n                                        &data.parent_code);\n         }\n         ObligationCauseCode::ImplDerivedObligation(ref data) => {\n             let parent_trait_ref = infcx.resolve_type_vars_if_possible(&data.parent_trait_ref);\n-            err.fileline_note(\n-                cause_span,\n+            err.note(\n                 &format!(\"required because of the requirements on the impl of `{}` for `{}`\",\n                          parent_trait_ref,\n                          parent_trait_ref.0.self_ty()));\n             let parent_predicate = parent_trait_ref.to_predicate();\n             note_obligation_cause_code(infcx,\n                                        err,\n                                        &parent_predicate,\n-                                       cause_span,\n                                        &data.parent_code);\n         }\n         ObligationCauseCode::CompareImplMethodObligation => {\n-            err.fileline_note(\n-                cause_span,\n+            err.note(\n                 &format!(\"the requirement `{}` appears on the impl method \\\n                           but not on the corresponding trait method\",\n                          predicate));\n         }\n     }\n }\n \n-fn suggest_new_overflow_limit(tcx: &TyCtxt, err:&mut DiagnosticBuilder, span: Span) {\n+fn suggest_new_overflow_limit(tcx: &TyCtxt, err:&mut DiagnosticBuilder) {\n     let current_limit = tcx.sess.recursion_limit.get();\n     let suggested_limit = current_limit * 2;\n-    err.fileline_note(\n-        span,\n-        &format!(\n-            \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n-            suggested_limit));\n+    err.note(&format!(\n+                      \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n+                      suggested_limit));\n }"}, {"sha": "bbd9cd4526d95a840ecc7a93b2616fcc741b0cf0", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 85, "deletions": 57, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -447,49 +447,105 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             //     borrow ends\n \n             let common = new_loan.loan_path.common(&old_loan.loan_path);\n-            let (nl, ol, new_loan_msg, old_loan_msg) =\n+            let (nl, ol, new_loan_msg, old_loan_msg) = {\n                 if new_loan.loan_path.has_fork(&old_loan.loan_path) && common.is_some() {\n                     let nl = self.bccx.loan_path_to_string(&common.unwrap());\n                     let ol = nl.clone();\n-                    let new_loan_msg = format!(\" (here through borrowing `{}`)\",\n+                    let new_loan_msg = format!(\" (via `{}`)\",\n                                                self.bccx.loan_path_to_string(\n                                                    &new_loan.loan_path));\n-                    let old_loan_msg = format!(\" (through borrowing `{}`)\",\n+                    let old_loan_msg = format!(\" (via `{}`)\",\n                                                self.bccx.loan_path_to_string(\n                                                    &old_loan.loan_path));\n                     (nl, ol, new_loan_msg, old_loan_msg)\n                 } else {\n                     (self.bccx.loan_path_to_string(&new_loan.loan_path),\n                      self.bccx.loan_path_to_string(&old_loan.loan_path),\n-                     String::new(), String::new())\n-                };\n+                     String::new(),\n+                     String::new())\n+                }\n+            };\n \n             let ol_pronoun = if new_loan.loan_path == old_loan.loan_path {\n                 \"it\".to_string()\n             } else {\n                 format!(\"`{}`\", ol)\n             };\n \n+            // We want to assemble all the relevant locations for the error.\n+            //\n+            // 1. Where did the new loan occur.\n+            //    - if due to closure creation, where was the variable used in closure?\n+            // 2. Where did old loan occur.\n+            // 3. Where does old loan expire.\n+\n+            let previous_end_span =\n+                self.tcx().map.span(old_loan.kill_scope.node_id(&self.tcx().region_maps))\n+                              .end_point();\n+\n             let mut err = match (new_loan.kind, old_loan.kind) {\n                 (ty::MutBorrow, ty::MutBorrow) => {\n                     struct_span_err!(self.bccx, new_loan.span, E0499,\n                                      \"cannot borrow `{}`{} as mutable \\\n                                       more than once at a time\",\n                                      nl, new_loan_msg)\n+                        .span_label(\n+                            old_loan.span,\n+                            &format!(\"first mutable borrow occurs here{}\", old_loan_msg))\n+                        .span_label(\n+                            new_loan.span,\n+                            &format!(\"second mutable borrow occurs here{}\", new_loan_msg))\n+                        .span_label(\n+                            previous_end_span,\n+                            &format!(\"first borrow ends here\"))\n+                }\n+\n+                (ty::UniqueImmBorrow, ty::UniqueImmBorrow) => {\n+                    struct_span_err!(self.bccx, new_loan.span, E0524,\n+                                     \"two closures require unique access to `{}` \\\n+                                      at the same time\",\n+                                     nl)\n+                        .span_label(\n+                            old_loan.span,\n+                            &format!(\"first closure is constructed here\"))\n+                        .span_label(\n+                            new_loan.span,\n+                            &format!(\"second closure is constructed here\"))\n+                        .span_label(\n+                            previous_end_span,\n+                            &format!(\"borrow from first closure ends here\"))\n                 }\n \n                 (ty::UniqueImmBorrow, _) => {\n                     struct_span_err!(self.bccx, new_loan.span, E0500,\n                                      \"closure requires unique access to `{}` \\\n                                       but {} is already borrowed{}\",\n                                      nl, ol_pronoun, old_loan_msg)\n+                        .span_label(\n+                            new_loan.span,\n+                            &format!(\"closure construction occurs here{}\", new_loan_msg))\n+                        .span_label(\n+                            old_loan.span,\n+                            &format!(\"borrow occurs here{}\", old_loan_msg))\n+                        .span_label(\n+                            previous_end_span,\n+                            &format!(\"borrow ends here\"))\n                 }\n \n                 (_, ty::UniqueImmBorrow) => {\n                     struct_span_err!(self.bccx, new_loan.span, E0501,\n                                      \"cannot borrow `{}`{} as {} because \\\n                                       previous closure requires unique access\",\n                                      nl, new_loan_msg, new_loan.kind.to_user_str())\n+                        .span_label(\n+                            new_loan.span,\n+                            &format!(\"borrow occurs here{}\", new_loan_msg))\n+                        .span_label(\n+                            old_loan.span,\n+                            &format!(\"closure construction occurs here{}\", old_loan_msg))\n+                        .span_label(\n+                            previous_end_span,\n+                            &format!(\"borrow from closure ends here\"))\n                 }\n \n                 (_, _) => {\n@@ -502,70 +558,42 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                      ol_pronoun,\n                                      old_loan.kind.to_user_str(),\n                                      old_loan_msg)\n+                        .span_label(\n+                            new_loan.span,\n+                            &format!(\"{} borrow occurs here{}\",\n+                                     new_loan.kind.to_user_str(),\n+                                     new_loan_msg))\n+                        .span_label(\n+                            old_loan.span,\n+                            &format!(\"{} borrow occurs here{}\",\n+                                     old_loan.kind.to_user_str(),\n+                                     old_loan_msg))\n+                        .span_label(\n+                            previous_end_span,\n+                            &format!(\"{} borrow ends here\",\n+                                     old_loan.kind.to_user_str()))\n                 }\n             };\n \n             match new_loan.cause {\n                 euv::ClosureCapture(span) => {\n-                    err.span_note(\n+                    err = err.span_label(\n                         span,\n-                        &format!(\"borrow occurs due to use of `{}` in closure\",\n-                                nl));\n+                        &format!(\"borrow occurs due to use of `{}` in closure\", nl));\n                 }\n                 _ => { }\n             }\n \n-            let rule_summary = match old_loan.kind {\n-                ty::MutBorrow => {\n-                    format!(\"the mutable borrow prevents subsequent \\\n-                            moves, borrows, or modification of `{0}` \\\n-                            until the borrow ends\",\n-                            ol)\n-                }\n-\n-                ty::ImmBorrow => {\n-                    format!(\"the immutable borrow prevents subsequent \\\n-                            moves or mutable borrows of `{0}` \\\n-                            until the borrow ends\",\n-                            ol)\n-                }\n-\n-                ty::UniqueImmBorrow => {\n-                    format!(\"the unique capture prevents subsequent \\\n-                            moves or borrows of `{0}` \\\n-                            until the borrow ends\",\n-                            ol)\n-                }\n-            };\n-\n-            let borrow_summary = match old_loan.cause {\n-                euv::ClosureCapture(_) => {\n-                    format!(\"previous borrow of `{}` occurs here{} due to \\\n-                            use in closure\",\n-                            ol, old_loan_msg)\n-                }\n-\n-                euv::OverloadedOperator |\n-                euv::AddrOf |\n-                euv::AutoRef |\n-                euv::AutoUnsafe |\n-                euv::ClosureInvocation |\n-                euv::ForLoop |\n-                euv::RefBinding |\n-                euv::MatchDiscriminant => {\n-                    format!(\"previous borrow of `{}` occurs here{}\",\n-                            ol, old_loan_msg)\n+            match old_loan.cause {\n+                euv::ClosureCapture(span) => {\n+                    err = err.span_label(\n+                        span,\n+                        &format!(\"previous borrow occurs due to use of `{}` in closure\",\n+                                 ol));\n                 }\n-            };\n-\n-            err.span_note(\n-                old_loan.span,\n-                &format!(\"{}; {}\", borrow_summary, rule_summary));\n+                _ => { }\n+            }\n \n-            let old_loan_span = self.tcx().map.span(\n-                old_loan.kill_scope.node_id(&self.tcx().region_maps));\n-            err.span_end_note(old_loan_span,\n-                              \"previous borrow ends here\");\n             err.emit();\n             return false;\n         }"}, {"sha": "5768a441c51b7af62b65cc8b2b7cfb32f0460faa", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -167,8 +167,7 @@ fn note_move_destination(err: &mut DiagnosticBuilder,\n         err.span_note(\n             move_to_span,\n             \"attempting to move value to here\");\n-        err.fileline_help(\n-            move_to_span,\n+        err.help(\n             &format!(\"to prevent the move, \\\n                       use `ref {0}` or `ref mut {0}` to capture value by \\\n                       reference\","}, {"sha": "f65e694939bfc62ffae4f56541e65f709b961443", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 60, "deletions": 131, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -34,14 +34,14 @@ use rustc::middle::free_region::FreeRegionMap;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::region;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, TyCtxt};\n \n use std::fmt;\n use std::mem;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::attr::AttrMetaMethods;\n-use syntax::codemap::Span;\n+use syntax::codemap::{MultiSpan, Span};\n use syntax::errors::DiagnosticBuilder;\n \n use rustc::hir;\n@@ -633,23 +633,22 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                          lp: &LoanPath<'tcx>,\n                                          the_move: &move_data::Move,\n                                          moved_lp: &LoanPath<'tcx>,\n-                                         param_env: &ty::ParameterEnvironment<'b,'tcx>) {\n-        let verb = match use_kind {\n-            MovedInUse => \"use\",\n-            MovedInCapture => \"capture\",\n+                                         _param_env: &ty::ParameterEnvironment<'b,'tcx>) {\n+        let (verb, verb_participle) = match use_kind {\n+            MovedInUse => (\"use\", \"used\"),\n+            MovedInCapture => (\"capture\", \"captured\"),\n         };\n \n-        let (ol, moved_lp_msg, mut err) = match the_move.kind {\n+        let (_ol, _moved_lp_msg, mut err) = match the_move.kind {\n             move_data::Declared => {\n-                let err = struct_span_err!(\n+                // If this is an uninitialized variable, just emit a simple warning\n+                // and return.\n+                struct_span_err!(\n                     self.tcx.sess, use_span, E0381,\n                     \"{} of possibly uninitialized variable: `{}`\",\n                     verb,\n-                    self.loan_path_to_string(lp));\n-\n-                (self.loan_path_to_string(moved_lp),\n-                 String::new(),\n-                 err)\n+                    self.loan_path_to_string(lp)).emit();\n+                return;\n             }\n             _ => {\n                 // If moved_lp is something like `x.a`, and lp is something like `x.b`, we would\n@@ -688,122 +687,52 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     self.tcx.sess, use_span, E0382,\n                     \"{} of {}moved value: `{}`\",\n                     verb, msg, nl);\n-                (ol, moved_lp_msg, err)\n+                (ol, moved_lp_msg, err)}\n+        };\n+\n+        // Get type of value and span where it was previously\n+        // moved.\n+        let (move_span, move_note) = match the_move.kind {\n+            move_data::Declared => {\n+                unreachable!();\n             }\n+\n+            move_data::MoveExpr |\n+            move_data::MovePat =>\n+                (self.tcx.map.span(the_move.id), \"\"),\n+\n+            move_data::Captured =>\n+                (match self.tcx.map.expect_expr(the_move.id).node {\n+                    hir::ExprClosure(_, _, _, fn_decl_span) => fn_decl_span,\n+                    ref r => bug!(\"Captured({}) maps to non-closure: {:?}\",\n+                                  the_move.id, r),\n+                }, \" (into closure)\"),\n         };\n \n-        match the_move.kind {\n-            move_data::Declared => {}\n+        // Annotate the use and the move in the span. Watch out for\n+        // the case where the use and the move are the same. This\n+        // means the use is in a loop.\n+        err = if use_span == move_span {\n+            err.span_label(\n+                use_span,\n+                &format!(\"value moved{} here in previous iteration of loop\",\n+                         move_note))\n+        } else {\n+            err.span_label(use_span, &format!(\"value {} here after move\", verb_participle))\n+               .span_label(move_span, &format!(\"value moved{} here\", move_note))\n+        };\n \n-            move_data::MoveExpr => {\n-                let (expr_ty, expr_span) = match self.tcx\n-                                                     .map\n-                                                     .find(the_move.id) {\n-                    Some(hir_map::NodeExpr(expr)) => {\n-                        (self.tcx.expr_ty_adjusted(&expr), expr.span)\n-                    }\n-                    r => {\n-                        bug!(\"MoveExpr({}) maps to {:?}, not Expr\",\n-                             the_move.id,\n-                             r)\n-                    }\n-                };\n-                let (suggestion, _) =\n-                    move_suggestion(param_env, expr_span, expr_ty, (\"moved by default\", \"\"));\n-                // If the two spans are the same, it's because the expression will be evaluated\n-                // multiple times. Avoid printing the same span and adjust the wording so it makes\n-                // more sense that it's from multiple evalutations.\n-                if expr_span == use_span {\n-                    err.note(\n-                        &format!(\"`{}` was previously moved here{} because it has type `{}`, \\\n-                                  which is {}\",\n-                                 ol,\n-                                 moved_lp_msg,\n-                                 expr_ty,\n-                                 suggestion));\n-                } else {\n-                    err.span_note(\n-                        expr_span,\n-                        &format!(\"`{}` moved here{} because it has type `{}`, which is {}\",\n-                                 ol,\n-                                 moved_lp_msg,\n-                                 expr_ty,\n-                                 suggestion));\n-                }\n-            }\n+        err.note(&format!(\"move occurs because `{}` has type `{}`, \\\n+                           which does not implement the `Copy` trait\",\n+                          self.loan_path_to_string(moved_lp),\n+                          moved_lp.ty));\n \n-            move_data::MovePat => {\n-                let pat_ty = self.tcx.node_id_to_type(the_move.id);\n-                let span = self.tcx.map.span(the_move.id);\n-                err.span_note(span,\n-                    &format!(\"`{}` moved here{} because it has type `{}`, \\\n-                             which is moved by default\",\n-                            ol,\n-                            moved_lp_msg,\n-                            pat_ty));\n-                match self.tcx.sess.codemap().span_to_snippet(span) {\n-                    Ok(string) => {\n-                        err.span_suggestion(\n-                            span,\n-                            &format!(\"if you would like to borrow the value instead, \\\n-                                      use a `ref` binding as shown:\"),\n-                            format!(\"ref {}\", string));\n-                    },\n-                    Err(_) => {\n-                        err.fileline_help(span,\n-                            \"use `ref` to override\");\n-                    },\n-                }\n-            }\n+        // Note: we used to suggest adding a `ref binding` or calling\n+        // `clone` but those suggestions have been removed because\n+        // they are often not what you actually want to do, and were\n+        // not considered particularly helpful.\n \n-            move_data::Captured => {\n-                let (expr_ty, expr_span) = match self.tcx\n-                                                     .map\n-                                                     .find(the_move.id) {\n-                    Some(hir_map::NodeExpr(expr)) => {\n-                        (self.tcx.expr_ty_adjusted(&expr), expr.span)\n-                    }\n-                    r => {\n-                        bug!(\"Captured({}) maps to {:?}, not Expr\",\n-                             the_move.id,\n-                             r)\n-                    }\n-                };\n-                let (suggestion, help) =\n-                    move_suggestion(param_env,\n-                                    expr_span,\n-                                    expr_ty,\n-                                    (\"moved by default\",\n-                                     \"make a copy and capture that instead to override\"));\n-                err.span_note(\n-                    expr_span,\n-                    &format!(\"`{}` moved into closure environment here{} because it \\\n-                            has type `{}`, which is {}\",\n-                            ol,\n-                            moved_lp_msg,\n-                            moved_lp.ty,\n-                            suggestion));\n-                err.fileline_help(expr_span, help);\n-            }\n-        }\n         err.emit();\n-\n-        fn move_suggestion<'a,'tcx>(param_env: &ty::ParameterEnvironment<'a,'tcx>,\n-                                    span: Span,\n-                                    ty: Ty<'tcx>,\n-                                    default_msgs: (&'static str, &'static str))\n-                                    -> (&'static str, &'static str) {\n-            match ty.sty {\n-                _ => {\n-                    if ty.moves_by_default(param_env, span) {\n-                        (\"non-copyable\",\n-                         \"perhaps you meant to use `clone()`?\")\n-                    } else {\n-                        default_msgs\n-                    }\n-                }\n-            }\n-        }\n     }\n \n     pub fn report_partial_reinitialization_of_uninitialized_structure(\n@@ -833,19 +762,20 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.sess.span_err(s, m);\n     }\n \n-    pub fn struct_span_err(&self, s: Span, m: &str) -> DiagnosticBuilder<'a> {\n+    pub fn struct_span_err<S: Into<MultiSpan>>(&self, s: S, m: &str)\n+                                              -> DiagnosticBuilder<'a> {\n         self.tcx.sess.struct_span_err(s, m)\n     }\n \n-    pub fn struct_span_err_with_code(&self,\n-                                     s: Span,\n-                                     msg: &str,\n-                                     code: &str)\n-                                     -> DiagnosticBuilder<'a> {\n+    pub fn struct_span_err_with_code<S: Into<MultiSpan>>(&self,\n+                                                         s: S,\n+                                                         msg: &str,\n+                                                         code: &str)\n+                                                         -> DiagnosticBuilder<'a> {\n         self.tcx.sess.struct_span_err_with_code(s, msg, code)\n     }\n \n-    pub fn span_err_with_code(&self, s: Span, msg: &str, code: &str) {\n+    pub fn span_err_with_code<S: Into<MultiSpan>>(&self, s: S, msg: &str, code: &str) {\n         self.tcx.sess.span_err_with_code(s, msg, code);\n     }\n \n@@ -982,8 +912,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         };\n \n         if is_closure {\n-            err.fileline_help(span,\n-                              \"closures behind references must be called via `&mut`\");\n+            err.help(\"closures behind references must be called via `&mut`\");\n         }\n         err.emit();\n     }"}, {"sha": "c7ad0b6a6c60640a1464bc503954004d206bed94", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -444,4 +444,5 @@ register_diagnostics! {\n     E0506, // cannot assign to `..` because it is borrowed\n     E0508, // cannot move out of type `..`, a non-copy fixed-size array\n     E0509, // cannot move out of type `..`, which defines the `Drop` trait\n+    E0524, // two closures require unique access to `..` at the same time\n }"}, {"sha": "ead6ab099a88ba5d33037204b39b12065c5cb700", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -255,7 +255,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n                                 \"pattern binding `{}` is named the same as one \\\n                                  of the variants of the type `{}`\",\n                                 ident.node, ty_path);\n-                            fileline_help!(err, p.span,\n+                            help!(err,\n                                 \"if you meant to match on a variant, \\\n                                  consider making the path in the pattern qualified: `{}::{}`\",\n                                 ty_path, ident.node);"}, {"sha": "d03ae45e83fe8a7b5b210eb81cc5af35918ac23c", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -92,7 +92,7 @@ use std::thread;\n use rustc::session::early_error;\n \n use syntax::{ast, errors, diagnostics};\n-use syntax::codemap::{CodeMap, FileLoader, RealFileLoader};\n+use syntax::codemap::{CodeMap, FileLoader, RealFileLoader, MultiSpan};\n use syntax::errors::emitter::Emitter;\n use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n use syntax::parse::{self, PResult, token};\n@@ -136,7 +136,8 @@ pub fn run(args: Vec<String>) -> isize {\n                     None => {\n                         let mut emitter =\n                             errors::emitter::BasicEmitter::stderr(errors::ColorConfig::Auto);\n-                        emitter.emit(None, &abort_msg(err_count), None, errors::Level::Fatal);\n+                        emitter.emit(&MultiSpan::new(), &abort_msg(err_count), None,\n+                            errors::Level::Fatal);\n                         exit_on_err();\n                     }\n                 }\n@@ -379,7 +380,7 @@ fn check_cfg(sopts: &config::Options,\n         match item.node {\n             ast::MetaItemKind::List(ref pred, _) => {\n                 saw_invalid_predicate = true;\n-                emitter.emit(None,\n+                emitter.emit(&MultiSpan::new(),\n                              &format!(\"invalid predicate in --cfg command line argument: `{}`\",\n                                       pred),\n                              None,\n@@ -1028,19 +1029,19 @@ pub fn monitor<F: FnOnce() + Send + 'static>(f: F) {\n             // a .span_bug or .bug call has already printed what\n             // it wants to print.\n             if !value.is::<errors::ExplicitBug>() {\n-                emitter.emit(None, \"unexpected panic\", None, errors::Level::Bug);\n+                emitter.emit(&MultiSpan::new(), \"unexpected panic\", None, errors::Level::Bug);\n             }\n \n             let xs = [\"the compiler unexpectedly panicked. this is a bug.\".to_string(),\n                       format!(\"we would appreciate a bug report: {}\", BUG_REPORT_URL)];\n             for note in &xs {\n-                emitter.emit(None, &note[..], None, errors::Level::Note)\n+                emitter.emit(&MultiSpan::new(), &note[..], None, errors::Level::Note)\n             }\n             if match env::var_os(\"RUST_BACKTRACE\") {\n                 Some(val) => &val != \"0\",\n                 None => false,\n             } {\n-                emitter.emit(None,\n+                emitter.emit(&MultiSpan::new(),\n                              \"run with `RUST_BACKTRACE=1` for a backtrace\",\n                              None,\n                              errors::Level::Note);"}, {"sha": "37f7b31b69cf2a484ef5f75bb03a8acd7ae0740c", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -34,9 +34,9 @@ use std::cell::RefCell;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::abi::Abi;\n-use syntax::codemap::{MultiSpan, CodeMap, DUMMY_SP};\n+use syntax::codemap::{CodeMap, DUMMY_SP};\n use syntax::errors;\n-use syntax::errors::emitter::Emitter;\n+use syntax::errors::emitter::{CoreEmitter, Emitter};\n use syntax::errors::{Level, RenderSpan};\n use syntax::parse::token;\n use syntax::feature_gate::UnstableFeatures;\n@@ -73,21 +73,20 @@ fn remove_message(e: &mut ExpectErrorEmitter, msg: &str, lvl: Level) {\n             e.messages.remove(i);\n         }\n         None => {\n+            debug!(\"Unexpected error: {} Expected: {:?}\", msg, e.messages);\n             panic!(\"Unexpected error: {} Expected: {:?}\", msg, e.messages);\n         }\n     }\n }\n \n-impl Emitter for ExpectErrorEmitter {\n-    fn emit(&mut self,\n-            _sp: Option<&MultiSpan>,\n-            msg: &str,\n-            _: Option<&str>,\n-            lvl: Level) {\n-        remove_message(self, msg, lvl);\n-    }\n-\n-    fn custom_emit(&mut self, _sp: &RenderSpan, msg: &str, lvl: Level) {\n+impl CoreEmitter for ExpectErrorEmitter {\n+    fn emit_message(&mut self,\n+                    _sp: &RenderSpan,\n+                    msg: &str,\n+                    _: Option<&str>,\n+                    lvl: Level,\n+                    _is_header: bool,\n+                    _show_snippet: bool) {\n         remove_message(self, msg, lvl);\n     }\n }\n@@ -449,7 +448,7 @@ fn contravariant_region_ptr_ok() {\n \n #[test]\n fn contravariant_region_ptr_err() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[\"lifetime mismatch\"]), |env| {\n+    test_env(EMPTY_SOURCE_STR, errors(&[\"mismatched types\"]), |env| {\n         env.create_simple_region_hierarchy();\n         let t_rptr1 = env.t_rptr_scope(1);\n         let t_rptr10 = env.t_rptr_scope(10);"}, {"sha": "4bdd926869a5a55f2d655031a713c8037367e884", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -764,8 +764,8 @@ impl LateLintPass for UnconditionalRecursion {\n                 for call in &self_call_spans {\n                     db.span_note(*call, \"recursive call site\");\n                 }\n-                db.fileline_help(sp, \"a `loop` may express intention \\\n-                                      better if this is on purpose\");\n+                db.help(\"a `loop` may express intention \\\n+                         better if this is on purpose\");\n             }\n             db.emit();\n         }"}, {"sha": "de0de219db2f13f45dec8b1c82a1cfeb56754368", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -241,8 +241,8 @@ impl<'a> CrateReader<'a> {\n                                               crate_rustc_version\n                                               .as_ref().map(|s| &**s)\n                                               .unwrap_or(\"an old version of rustc\"));\n-            err.fileline_help(span, \"consider removing the compiled binaries and recompiling \\\n-                                     with your current version of rustc\");\n+            err.help(\"consider removing the compiled binaries and recompiling \\\n+                      with your current version of rustc\");\n             err.emit();\n         }\n     }"}, {"sha": "2316a67d9d3e3c752b02d89dd55ae582ddeb4411", "filename": "src/librustc_metadata/loader.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_metadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_metadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Floader.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -346,39 +346,33 @@ impl<'a> Context<'a> {\n         if !self.rejected_via_triple.is_empty() {\n             let mismatches = self.rejected_via_triple.iter();\n             for (i, &CrateMismatch{ ref path, ref got }) in mismatches.enumerate() {\n-                err.fileline_note(self.span,\n-                    &format!(\"crate `{}`, path #{}, triple {}: {}\",\n-                            self.ident, i+1, got, path.display()));\n+                err.note(&format!(\"crate `{}`, path #{}, triple {}: {}\",\n+                                  self.ident, i+1, got, path.display()));\n             }\n         }\n         if !self.rejected_via_hash.is_empty() {\n-            err.span_note(self.span, \"perhaps this crate needs \\\n-                                            to be recompiled?\");\n+            err.note(\"perhaps this crate needs to be recompiled?\");\n             let mismatches = self.rejected_via_hash.iter();\n             for (i, &CrateMismatch{ ref path, .. }) in mismatches.enumerate() {\n-                err.fileline_note(self.span,\n-                    &format!(\"crate `{}` path #{}: {}\",\n-                            self.ident, i+1, path.display()));\n+                err.note(&format!(\"crate `{}` path #{}: {}\",\n+                                  self.ident, i+1, path.display()));\n             }\n             match self.root {\n                 &None => {}\n                 &Some(ref r) => {\n                     for (i, path) in r.paths().iter().enumerate() {\n-                        err.fileline_note(self.span,\n-                            &format!(\"crate `{}` path #{}: {}\",\n-                                    r.ident, i+1, path.display()));\n+                        err.note(&format!(\"crate `{}` path #{}: {}\",\n+                                          r.ident, i+1, path.display()));\n                     }\n                 }\n             }\n         }\n         if !self.rejected_via_kind.is_empty() {\n-            err.fileline_help(self.span, \"please recompile this crate using \\\n-                                          --crate-type lib\");\n+            err.help(\"please recompile this crate using --crate-type lib\");\n             let mismatches = self.rejected_via_kind.iter();\n             for (i, &CrateMismatch { ref path, .. }) in mismatches.enumerate() {\n-                err.fileline_note(self.span,\n-                                  &format!(\"crate `{}` path #{}: {}\",\n-                                           self.ident, i+1, path.display()));\n+                err.note(&format!(\"crate `{}` path #{}: {}\",\n+                                  self.ident, i+1, path.display()));\n             }\n         }\n "}, {"sha": "dede4d2a42a53f2349f8e2ec62b4f9658e32bceb", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -198,9 +198,8 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n                 let mut err = self.tcx.sess.struct_span_err(\n                     expr.span,\n                     \"const fns are an unstable feature\");\n-                fileline_help!(\n+                help!(\n                     &mut err,\n-                    expr.span,\n                     \"in Nightly builds, add `#![feature(const_fn)]` to the crate \\\n                      attributes to enable\");\n                 err.emit();"}, {"sha": "e747ed15260613fe104d5119dbd2c12b624f4d11", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -244,7 +244,7 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n                                            E0405,\n                                            \"trait `{}` is not in scope\",\n                                            name);\n-            show_candidates(&mut err, span, &candidates);\n+            show_candidates(&mut err, &candidates);\n             err\n         }\n         ResolutionError::UndeclaredAssociatedType => {\n@@ -312,7 +312,7 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n                                            \"{} `{}` is undefined or not in scope\",\n                                            kind,\n                                            name);\n-            show_candidates(&mut err, span, &candidates);\n+            show_candidates(&mut err, &candidates);\n             err\n         }\n         ResolutionError::DeclarationShadowsEnumVariantOrUnitLikeStruct(name) => {\n@@ -420,7 +420,7 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n             match context {\n                 UnresolvedNameContext::Other => { } // no help available\n                 UnresolvedNameContext::PathIsMod(parent) => {\n-                    err.fileline_help(span, &match parent.map(|parent| &parent.node) {\n+                    err.help(&match parent.map(|parent| &parent.node) {\n                         Some(&ExprField(_, ident)) => {\n                             format!(\"To reference an item from the `{module}` module, \\\n                                      use `{module}::{ident}`\",\n@@ -1784,8 +1784,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 // If it's a typedef, give a note\n                 if let Def::TyAlias(..) = path_res.base_def {\n-                    err.fileline_note(trait_path.span,\n-                                  \"`type` aliases cannot be used for traits\");\n+                    err.note(\"`type` aliases cannot be used for traits\");\n \n                     let definition_site = {\n                         let segments = &trait_path.segments;\n@@ -2880,7 +2879,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         let msg = format!(\"did you mean to write: `{} {{ /* fields */ }}`?\",\n                                           path_name);\n                         if self.emit_errors {\n-                            err.fileline_help(expr.span, &msg);\n+                            err.help(&msg);\n                         } else {\n                             err.span_help(expr.span, &msg);\n                         }\n@@ -2922,7 +2921,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                           path_name);\n \n                         if self.emit_errors {\n-                            err.fileline_help(expr.span, &msg);\n+                            err.help(&msg);\n                         } else {\n                             err.span_help(expr.span, &msg);\n                         }\n@@ -3420,7 +3419,6 @@ fn path_names_to_string(path: &Path, depth: usize) -> String {\n /// entities with that name in all crates. This method allows outputting the\n /// results of this search in a programmer-friendly way\n fn show_candidates(session: &mut DiagnosticBuilder,\n-                   span: syntax::codemap::Span,\n                    candidates: &SuggestedCandidates) {\n \n     let paths = &candidates.candidates;\n@@ -3440,26 +3438,23 @@ fn show_candidates(session: &mut DiagnosticBuilder,\n         // behave differently based on how many candidates we have:\n         if !paths.is_empty() {\n             if paths.len() == 1 {\n-                session.fileline_help(\n-                    span,\n+                session.help(\n                     &format!(\"you can import it into scope: `use {};`.\",\n                         &path_strings[0]),\n                 );\n             } else {\n-                session.fileline_help(span, \"you can import several candidates \\\n+                session.help(\"you can import several candidates \\\n                     into scope (`use ...;`):\");\n                 let count = path_strings.len() as isize - MAX_CANDIDATES as isize + 1;\n \n                 for (idx, path_string) in path_strings.iter().enumerate() {\n                     if idx == MAX_CANDIDATES - 1 && count > 1 {\n-                        session.fileline_help(\n-                            span,\n+                        session.help(\n                             &format!(\"  and {} other candidates\", count).to_string(),\n                         );\n                         break;\n                     } else {\n-                        session.fileline_help(\n-                            span,\n+                        session.help(\n                             &format!(\"  `{}`\", path_string).to_string(),\n                         );\n                     }\n@@ -3468,8 +3463,7 @@ fn show_candidates(session: &mut DiagnosticBuilder,\n         }\n     } else {\n         // nothing found:\n-        session.fileline_help(\n-            span,\n+        session.help(\n             &format!(\"no candidates by the name of `{}` found in your \\\n             project; maybe you misspelled the name or forgot to import \\\n             an external crate?\", candidates.name.to_string()),"}, {"sha": "10bcf83d7556f2aba52006cc6375bb5b1d976ec7", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -19,9 +19,9 @@ use llvm::SMDiagnosticRef;\n use {CrateTranslation, ModuleTranslation};\n use util::common::time;\n use util::common::path2cstr;\n-use syntax::codemap;\n-use syntax::errors::{self, Handler, Level};\n-use syntax::errors::emitter::Emitter;\n+use syntax::codemap::MultiSpan;\n+use syntax::errors::{self, Handler, Level, RenderSpan};\n+use syntax::errors::emitter::CoreEmitter;\n \n use std::collections::HashMap;\n use std::ffi::{CStr, CString};\n@@ -84,13 +84,13 @@ impl SharedEmitter {\n         for diag in &*buffer {\n             match diag.code {\n                 Some(ref code) => {\n-                    handler.emit_with_code(None,\n+                    handler.emit_with_code(&MultiSpan::new(),\n                                            &diag.msg,\n                                            &code[..],\n                                            diag.lvl);\n                 },\n                 None => {\n-                    handler.emit(None,\n+                    handler.emit(&MultiSpan::new(),\n                                  &diag.msg,\n                                  diag.lvl);\n                 },\n@@ -100,21 +100,20 @@ impl SharedEmitter {\n     }\n }\n \n-impl Emitter for SharedEmitter {\n-    fn emit(&mut self, sp: Option<&codemap::MultiSpan>,\n-            msg: &str, code: Option<&str>, lvl: Level) {\n-        assert!(sp.is_none(), \"SharedEmitter doesn't support spans\");\n-\n+impl CoreEmitter for SharedEmitter {\n+    fn emit_message(&mut self,\n+                    _rsp: &RenderSpan,\n+                    msg: &str,\n+                    code: Option<&str>,\n+                    lvl: Level,\n+                    _is_header: bool,\n+                    _show_snippet: bool) {\n         self.buffer.lock().unwrap().push(Diagnostic {\n             msg: msg.to_string(),\n             code: code.map(|s| s.to_string()),\n             lvl: lvl,\n         });\n     }\n-\n-    fn custom_emit(&mut self, _sp: &errors::RenderSpan, _msg: &str, _lvl: Level) {\n-        bug!(\"SharedEmitter doesn't support custom_emit\");\n-    }\n }\n \n "}, {"sha": "ac7745985e6af4f2e40069dd6275d034d3cf86e9", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -206,7 +206,6 @@ pub fn ast_region_to_region(tcx: &TyCtxt, lifetime: &hir::Lifetime)\n \n fn report_elision_failure(\n     db: &mut DiagnosticBuilder,\n-    default_span: Span,\n     params: Vec<ElisionFailureInfo>)\n {\n     let mut m = String::new();\n@@ -243,29 +242,29 @@ fn report_elision_failure(\n     }\n \n     if len == 0 {\n-        fileline_help!(db, default_span,\n-                       \"this function's return type contains a borrowed value, but \\\n-                        there is no value for it to be borrowed from\");\n-        fileline_help!(db, default_span,\n-                       \"consider giving it a 'static lifetime\");\n+        help!(db,\n+                   \"this function's return type contains a borrowed value, but \\\n+                    there is no value for it to be borrowed from\");\n+        help!(db,\n+                   \"consider giving it a 'static lifetime\");\n     } else if !any_lifetimes {\n-        fileline_help!(db, default_span,\n-                       \"this function's return type contains a borrowed value with \\\n-                        an elided lifetime, but the lifetime cannot be derived from \\\n-                        the arguments\");\n-        fileline_help!(db, default_span,\n-                       \"consider giving it an explicit bounded or 'static \\\n-                        lifetime\");\n+        help!(db,\n+                   \"this function's return type contains a borrowed value with \\\n+                    an elided lifetime, but the lifetime cannot be derived from \\\n+                    the arguments\");\n+        help!(db,\n+                   \"consider giving it an explicit bounded or 'static \\\n+                    lifetime\");\n     } else if len == 1 {\n-        fileline_help!(db, default_span,\n-                       \"this function's return type contains a borrowed value, but \\\n-                        the signature does not say which {} it is borrowed from\",\n-                       m);\n+        help!(db,\n+                   \"this function's return type contains a borrowed value, but \\\n+                    the signature does not say which {} it is borrowed from\",\n+                   m);\n     } else {\n-        fileline_help!(db, default_span,\n-                       \"this function's return type contains a borrowed value, but \\\n-                        the signature does not say whether it is borrowed from {}\",\n-                       m);\n+        help!(db,\n+                   \"this function's return type contains a borrowed value, but \\\n+                    the signature does not say whether it is borrowed from {}\",\n+                   m);\n     }\n }\n \n@@ -286,7 +285,7 @@ pub fn opt_ast_region_to_region<'tcx>(\n                 let mut err = struct_span_err!(this.tcx().sess, default_span, E0106,\n                                                \"missing lifetime specifier\");\n                 if let Some(params) = params {\n-                    report_elision_failure(&mut err, default_span, params);\n+                    report_elision_failure(&mut err, params);\n                 }\n                 err.emit();\n                 ty::ReStatic\n@@ -1087,7 +1086,7 @@ fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,\n                 }\n \n                 _ => {\n-                    fileline_help!(&mut err, ty.span,\n+                    help!(&mut err,\n                                \"perhaps you forgot parentheses? (per RFC 438)\");\n                 }\n             }"}, {"sha": "544fb117f361411fea223be475809b5594607680", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -116,8 +116,8 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n             // Check that the types of the end-points can be unified.\n             let types_unify = require_same_types(\n-                    tcx, Some(fcx.infcx()), false, pat.span, rhs_ty, lhs_ty,\n-                    || \"mismatched types in range\".to_string()\n+                tcx, Some(fcx.infcx()), false, pat.span, rhs_ty, lhs_ty,\n+                \"mismatched types in range\",\n             );\n \n             // It's ok to return without a message as `require_same_types` prints an error."}, {"sha": "a96b739ebcf9963647ded9a328938a07ebfc9d7f", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -64,8 +64,8 @@ pub fn check_legal_trait_for_method_call(ccx: &CrateCtxt, span: Span, trait_id:\n         struct_span_err!(tcx.sess, span, E0174,\n                          \"explicit use of unboxed closure method `{}` is experimental\",\n                          method)\n-            .fileline_help(span, \"add `#![feature(unboxed_closures)]` to the crate \\\n-                                  attributes to enable\")\n+            .help(\"add `#![feature(unboxed_closures)]` to the crate \\\n+                  attributes to enable\")\n             .emit();\n     }\n }"}, {"sha": "249ab27ec5956e889f7523b7b522cdf8edcfcabc", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -155,8 +155,7 @@ impl<'tcx> CastCheck<'tcx> {\n                             actual,\n                             fcx.infcx().ty_to_string(self.cast_ty))\n                 }, self.expr_ty, None)\n-                    .fileline_help(self.span,\n-                        &format!(\"cast through {} first\", match e {\n+                    .help(&format!(\"cast through {} first\", match e {\n                             CastError::NeedViaPtr => \"a raw pointer\",\n                             CastError::NeedViaThinPtr => \"a thin pointer\",\n                             CastError::NeedViaInt => \"an integer\",\n@@ -167,7 +166,7 @@ impl<'tcx> CastCheck<'tcx> {\n             }\n             CastError::CastToBool => {\n                 struct_span_err!(fcx.tcx().sess, self.span, E0054, \"cannot cast as `bool`\")\n-                    .fileline_help(self.span, \"compare with zero instead\")\n+                    .help(\"compare with zero instead\")\n                     .emit();\n             }\n             CastError::CastToChar => {\n@@ -202,7 +201,7 @@ impl<'tcx> CastCheck<'tcx> {\n                             actual,\n                             fcx.infcx().ty_to_string(self.cast_ty))\n                 }, self.expr_ty, None)\n-                    .fileline_note(self.span, \"vtable kinds may not match\")\n+                    .note(\"vtable kinds may not match\")\n                     .emit();\n             }\n         }"}, {"sha": "b71ee8722ab607be5111f6b6d35dd3e39788ae6a", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -61,10 +61,7 @@ fn equate_intrinsic_type<'a, 'tcx>(tcx: &TyCtxt<'tcx>, it: &hir::ForeignItem,\n                            it.span,\n                            i_ty.ty,\n                            fty,\n-                           || {\n-                format!(\"intrinsic has wrong type: expected `{}`\",\n-                         fty)\n-            });\n+                           \"intrinsic has wrong type\");\n     }\n }\n "}, {"sha": "b541ca151c85630633ff40a504d6c01ec8f23607", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -148,9 +148,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             if is_fn_ty(&rcvr_ty, &fcx, span) {\n                 macro_rules! report_function {\n                     ($span:expr, $name:expr) => {\n-                        err.fileline_note(\n-                            $span,\n-                            &format!(\"{} is a function, perhaps you wish to call it\",\n+                        err.note(&format!(\"{} is a function, perhaps you wish to call it\",\n                                      $name));\n                     }\n                 }\n@@ -172,8 +170,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n \n             if !static_sources.is_empty() {\n-                err.fileline_note(\n-                    span,\n+                err.note(\n                     \"found the following associated functions; to be used as \\\n                      methods, functions must have a `self` parameter\");\n \n@@ -187,8 +184,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                      p))\n                     .collect::<Vec<_>>()\n                     .join(\", \");\n-                err.fileline_note(\n-                    span,\n+                err.note(\n                     &format!(\"the method `{}` exists but the \\\n                              following trait bounds were not satisfied: {}\",\n                              item_name,\n@@ -306,13 +302,12 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             traits_are = if candidates.len() == 1 {\"trait is\"} else {\"traits are\"},\n             one_of_them = if candidates.len() == 1 {\"it\"} else {\"one of them\"});\n \n-        err.fileline_help(span, &msg[..]);\n+        err.help(&msg[..]);\n \n         for (i, trait_did) in candidates.iter().enumerate() {\n-            err.fileline_help(span,\n-                              &format!(\"candidate #{}: `use {}`\",\n-                                        i + 1,\n-                                        fcx.tcx().item_path_str(*trait_did)));\n+            err.help(&format!(\"candidate #{}: `use {}`\",\n+                              i + 1,\n+                              fcx.tcx().item_path_str(*trait_did)));\n         }\n         return\n     }\n@@ -351,13 +346,12 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             one_of_them = if candidates.len() == 1 {\"it\"} else {\"one of them\"},\n             name = item_name);\n \n-        err.fileline_help(span, &msg[..]);\n+        err.help(&msg[..]);\n \n         for (i, trait_info) in candidates.iter().enumerate() {\n-            err.fileline_help(span,\n-                              &format!(\"candidate #{}: `{}`\",\n-                                        i + 1,\n-                                        fcx.tcx().item_path_str(trait_info.def_id)));\n+            err.help(&format!(\"candidate #{}: `{}`\",\n+                              i + 1,\n+                              fcx.tcx().item_path_str(trait_info.def_id)));\n         }\n     }\n }"}, {"sha": "385f04b8564f5c9883ec3c5002b801fb034a5409", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -2955,9 +2955,9 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                `{}`\", field.node, actual)\n                                    },\n                                    expr_t, None)\n-                .fileline_help(field.span,\n-                               \"maybe a `()` to call it is missing? \\\n-                               If not, try an anonymous function\")\n+                .help(\n+                       \"maybe a `()` to call it is missing? \\\n+                       If not, try an anonymous function\")\n                 .emit();\n             fcx.write_error(expr.id);\n         } else {"}, {"sha": "25a37b6810e4434ec652bab5deb25dfe19d93196", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -418,8 +418,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let _ = ::require_same_types(\n             fcx.tcx(), Some(fcx.infcx()), false, span,\n             sig.inputs[0], rcvr_ty,\n-            || \"mismatched method receiver\".to_owned()\n-        );\n+            \"mismatched method receiver\");\n     }\n \n     fn check_variances_for_type_defn(&self,\n@@ -502,8 +501,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let suggested_marker_id = self.tcx().lang_items.phantom_data();\n         match suggested_marker_id {\n             Some(def_id) => {\n-                err.fileline_help(\n-                    span,\n+                err.help(\n                     &format!(\"consider removing `{}` or using a marker such as `{}`\",\n                              param_name,\n                              self.tcx().item_path_str(def_id)));"}, {"sha": "bfb371be663b5af054e70e01c545e87eaef7146d", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -510,8 +510,7 @@ fn enforce_trait_manually_implementable(tcx: &TyCtxt, sp: Span, trait_def_id: De\n                                    E0183,\n                                    \"manual implementations of `{}` are experimental\",\n                                    trait_name);\n-    fileline_help!(&mut err, sp,\n-                   \"add `#![feature(unboxed_closures)]` to the crate attributes to enable\");\n+    help!(&mut err, \"add `#![feature(unboxed_closures)]` to the crate attributes to enable\");\n     err.emit();\n }\n "}, {"sha": "c10488a03ef68a977e08b768f2e4b70f35e5d9a2", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -1044,8 +1044,9 @@ fn convert_enum_def<'tcx>(tcx: &TyCtxt<'tcx>,\n                           -> ty::AdtDefMaster<'tcx>\n {\n     fn print_err(tcx: &TyCtxt, span: Span, ty: ty::Ty, cv: ConstVal) {\n-        span_err!(tcx.sess, span, E0079, \"mismatched types: expected `{}` got `{}`\",\n-                  ty, cv.description());\n+        struct_span_err!(tcx.sess, span, E0079, \"mismatched types\")\n+            .note_expected_found(&\"type\", &ty, &format!(\"{}\", cv.description()))\n+            .emit();\n     }\n     fn evaluate_disr_expr<'tcx>(tcx: &TyCtxt<'tcx>,\n                                 repr_ty: attr::IntType,\n@@ -1257,9 +1258,9 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             it.span,\n             \"the `#[rustc_paren_sugar]` attribute is a temporary means of controlling \\\n              which traits can use parenthetical notation\");\n-        fileline_help!(&mut err, it.span,\n-                   \"add `#![feature(unboxed_closures)]` to \\\n-                    the crate attributes to use it\");\n+        help!(&mut err,\n+            \"add `#![feature(unboxed_closures)]` to \\\n+             the crate attributes to use it\");\n         err.emit();\n     }\n \n@@ -2195,8 +2196,7 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n                               &format!(\"use of SIMD type `{}` in FFI is highly experimental and \\\n                                         may result in invalid code\",\n                                        pprust::ty_to_string(ast_ty)))\n-                    .fileline_help(ast_ty.span,\n-                                   \"add #![feature(simd_ffi)] to the crate attributes to enable\")\n+                    .help(\"add #![feature(simd_ffi)] to the crate attributes to enable\")\n                     .emit();\n             }\n         };"}, {"sha": "c51304120a89c61abebc8315c7bc70ea38e77c4e", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -185,15 +185,14 @@ fn require_c_abi_if_variadic(tcx: &TyCtxt,\n     }\n }\n \n-fn require_same_types<'a, 'tcx, M>(tcx: &TyCtxt<'tcx>,\n-                                   maybe_infcx: Option<&infer::InferCtxt<'a, 'tcx>>,\n-                                   t1_is_expected: bool,\n-                                   span: Span,\n-                                   t1: Ty<'tcx>,\n-                                   t2: Ty<'tcx>,\n-                                   msg: M)\n-                                   -> bool where\n-    M: FnOnce() -> String,\n+fn require_same_types<'a, 'tcx>(tcx: &TyCtxt<'tcx>,\n+                                maybe_infcx: Option<&infer::InferCtxt<'a, 'tcx>>,\n+                                t1_is_expected: bool,\n+                                span: Span,\n+                                t1: Ty<'tcx>,\n+                                t2: Ty<'tcx>,\n+                                msg: &str)\n+                                -> bool\n {\n     let result = match maybe_infcx {\n         None => {\n@@ -208,7 +207,17 @@ fn require_same_types<'a, 'tcx, M>(tcx: &TyCtxt<'tcx>,\n     match result {\n         Ok(_) => true,\n         Err(ref terr) => {\n-            let mut err = struct_span_err!(tcx.sess, span, E0211, \"{}: {}\", msg(), terr);\n+            let mut err = struct_span_err!(tcx.sess, span, E0211, \"{}\", msg);\n+            err = err.span_label(span, &terr);\n+            let (mut expected_ty, mut found_ty) =\n+                if t1_is_expected {(t1, t2)} else {(t2, t1)};\n+            if let Some(infcx) = maybe_infcx {\n+                expected_ty = infcx.resolve_type_vars_if_possible(&expected_ty);\n+                found_ty = infcx.resolve_type_vars_if_possible(&found_ty);\n+            }\n+            err = err.note_expected_found(&\"type\",\n+                                          &expected_ty,\n+                                          &found_ty);\n             tcx.note_and_explain_type_err(&mut err, terr, span);\n             err.emit();\n             false\n@@ -250,10 +259,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n             });\n \n             require_same_types(tcx, None, false, main_span, main_t, se_ty,\n-                || {\n-                    format!(\"main function expects type: `{}`\",\n-                             se_ty)\n-                });\n+                               \"main function has wrong type\");\n         }\n         _ => {\n             span_bug!(main_span,\n@@ -301,11 +307,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n             });\n \n             require_same_types(tcx, None, false, start_span, start_t, se_ty,\n-                || {\n-                    format!(\"start function expects type: `{}`\",\n-                             se_ty)\n-                });\n-\n+                               \"start function has wrong type\");\n         }\n         _ => {\n             span_bug!(start_span,"}, {"sha": "ca8708fdc8326c480761a8d3d35daffc791e0052", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 94, "deletions": 209, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -32,8 +32,6 @@ use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n use ast::Name;\n \n-use errors::emitter::MAX_HIGHLIGHT_LINES;\n-\n // _____________________________________________________________________________\n // Pos, BytePos, CharPos\n //\n@@ -51,7 +49,7 @@ pub struct BytePos(pub u32);\n /// A character offset. Because of multibyte utf8 characters, a byte offset\n /// is not equivalent to a character offset. The CodeMap will convert BytePos\n /// values to CharPos values as necessary.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Debug)]\n pub struct CharPos(pub usize);\n \n // FIXME: Lots of boilerplate in these impls, but so far my attempts to fix\n@@ -132,13 +130,29 @@ pub struct Span {\n     pub expn_id: ExpnId\n }\n \n-/// Spans are converted to MultiSpans just before error reporting, either automatically,\n-/// generated by line grouping, or manually constructed.\n-/// In the latter case care should be taken to ensure that spans are ordered, disjoint,\n-/// and point into the same FileMap.\n+/// A collection of spans. Spans have two orthogonal attributes:\n+///\n+/// - they can be *primary spans*. In this case they are the locus of\n+///   the error, and would be rendered with `^^^`.\n+/// - they can have a *label*. In this case, the label is written next\n+///   to the mark in the snippet when we render.\n #[derive(Clone)]\n pub struct MultiSpan {\n-    pub spans: Vec<Span>\n+    primary_spans: Vec<Span>,\n+    span_labels: Vec<(Span, String)>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct SpanLabel {\n+    /// The span we are going to include in the final snippet.\n+    pub span: Span,\n+\n+    /// Is this a primary span? This is the \"locus\" of the message,\n+    /// and is indicated with a `^^^^` underline, versus `----`.\n+    pub is_primary: bool,\n+\n+    /// What label should we attach to this span (if any)?\n+    pub label: Option<String>,\n }\n \n pub const DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), expn_id: NO_EXPANSION };\n@@ -149,6 +163,12 @@ pub const COMMAND_LINE_SP: Span = Span { lo: BytePos(0),\n                                          expn_id: COMMAND_LINE_EXPN };\n \n impl Span {\n+    /// Returns a new span representing just the end-point of this span\n+    pub fn end_point(self) -> Span {\n+        let lo = cmp::max(self.hi.0 - 1, self.lo.0);\n+        Span { lo: BytePos(lo), hi: self.hi, expn_id: self.expn_id}\n+    }\n+\n     /// Returns `self` if `self` is not the dummy span, and `other` otherwise.\n     pub fn substitute_dummy(self, other: Span) -> Span {\n         if self.source_equal(&DUMMY_SP) { other } else { self }\n@@ -276,97 +296,74 @@ pub fn original_sp(cm: &CodeMap, sp: Span, enclosing_sp: Span) -> Span {\n \n impl MultiSpan {\n     pub fn new() -> MultiSpan {\n-        MultiSpan { spans: Vec::new() }\n+        MultiSpan {\n+            primary_spans: vec![],\n+            span_labels: vec![]\n+        }\n     }\n \n-    pub fn to_span_bounds(&self) -> Span {\n-        assert!(!self.spans.is_empty());\n-        let Span { lo, expn_id, .. } = *self.spans.first().unwrap();\n-        let Span { hi, .. } = *self.spans.last().unwrap();\n-        Span { lo: lo, hi: hi, expn_id: expn_id }\n+    pub fn from_span(primary_span: Span) -> MultiSpan {\n+        MultiSpan {\n+            primary_spans: vec![primary_span],\n+            span_labels: vec![]\n+        }\n     }\n \n-    /// Merges or inserts the given span into itself.\n-    pub fn push_merge(&mut self, mut sp: Span) {\n-        let mut idx_merged = None;\n-\n-        for idx in 0.. {\n-            let cur = match self.spans.get(idx) {\n-                Some(s) => *s,\n-                None => break,\n-            };\n-            // Try to merge with a contained Span\n-            if let Some(union) = cur.merge(sp) {\n-                self.spans[idx] = union;\n-                sp = union;\n-                idx_merged = Some(idx);\n-                break;\n-            }\n-            // Or insert into the first sorted position\n-            if sp.hi <= cur.lo {\n-                self.spans.insert(idx, sp);\n-                idx_merged = Some(idx);\n-                break;\n-            }\n-        }\n-        if let Some(idx) = idx_merged {\n-            // Merge with spans trailing the insertion/merging position\n-            while (idx + 1) < self.spans.len() {\n-                if let Some(union) = self.spans[idx + 1].merge(sp) {\n-                    self.spans[idx] = union;\n-                    self.spans.remove(idx + 1);\n-                } else {\n-                    break;\n-                }\n-            }\n-        } else {\n-            self.spans.push(sp);\n+    pub fn from_spans(vec: Vec<Span>) -> MultiSpan {\n+        MultiSpan {\n+            primary_spans: vec,\n+            span_labels: vec![]\n         }\n     }\n \n-    /// Inserts the given span into itself, for use with `end_highlight_lines`.\n-    pub fn push_trim(&mut self, mut sp: Span) {\n-        let mut prev = mk_sp(BytePos(0), BytePos(0));\n+    pub fn push_span_label(&mut self, span: Span, label: String) {\n+        self.span_labels.push((span, label));\n+    }\n \n-        if let Some(first) = self.spans.get_mut(0) {\n-            if first.lo > sp.lo {\n-                // Prevent us here from spanning fewer lines\n-                // because of trimming the start of the span\n-                // (this should not be visible, because this method ought\n-                // to not be used in conjunction with `highlight_lines`)\n-                first.lo = sp.lo;\n-            }\n+    /// Selects the first primary span (if any)\n+    pub fn primary_span(&self) -> Option<Span> {\n+        self.primary_spans.first().cloned()\n+    }\n+\n+    /// Returns all primary spans.\n+    pub fn primary_spans(&self) -> &[Span] {\n+        &self.primary_spans\n+    }\n+\n+    /// Returns the strings to highlight. We always ensure that there\n+    /// is an entry for each of the primary spans -- for each primary\n+    /// span P, if there is at least one label with span P, we return\n+    /// those labels (marked as primary). But otherwise we return\n+    /// `SpanLabel` instances with empty labels.\n+    pub fn span_labels(&self) -> Vec<SpanLabel> {\n+        let is_primary = |span| self.primary_spans.contains(&span);\n+        let mut span_labels = vec![];\n+\n+        for &(span, ref label) in &self.span_labels {\n+            span_labels.push(SpanLabel {\n+                span: span,\n+                is_primary: is_primary(span),\n+                label: Some(label.clone())\n+            });\n         }\n \n-        for idx in 0.. {\n-            if let Some(sp_trim) = sp.trim_start(prev) {\n-                // Implies `sp.hi > prev.hi`\n-                let cur = match self.spans.get(idx) {\n-                    Some(s) => *s,\n-                    None => {\n-                        sp = sp_trim;\n-                        break;\n-                    }\n-                };\n-                // `cur` may overlap with `sp_trim`\n-                if let Some(cur_trim) = cur.trim_start(sp_trim) {\n-                    // Implies `sp.hi < cur.hi`\n-                    self.spans.insert(idx, sp_trim);\n-                    self.spans[idx + 1] = cur_trim;\n-                    return;\n-                } else if sp.hi == cur.hi {\n-                    return;\n-                }\n-                prev = cur;\n+        for &span in &self.primary_spans {\n+            if !span_labels.iter().any(|sl| sl.span == span) {\n+                span_labels.push(SpanLabel {\n+                    span: span,\n+                    is_primary: true,\n+                    label: None\n+                });\n             }\n         }\n-        self.spans.push(sp);\n+\n+        span_labels\n     }\n }\n \n impl From<Span> for MultiSpan {\n     fn from(span: Span) -> MultiSpan {\n-        MultiSpan { spans: vec![span] }\n+        MultiSpan::from_span(span)\n     }\n }\n \n@@ -801,7 +798,7 @@ impl CodeMap {\n     /// Creates a new filemap and sets its line information.\n     pub fn new_filemap_and_lines(&self, filename: &str, src: &str) -> Rc<FileMap> {\n         let fm = self.new_filemap(filename.to_string(), src.to_owned());\n-        let mut byte_pos: u32 = 0;\n+        let mut byte_pos: u32 = fm.start_pos.0;\n         for line in src.lines() {\n             // register the start of this line\n             fm.next_line(BytePos(byte_pos));\n@@ -929,6 +926,10 @@ impl CodeMap {\n     }\n \n     pub fn span_to_string(&self, sp: Span) -> String {\n+        if sp == COMMAND_LINE_SP {\n+            return \"<command line option>\".to_string();\n+        }\n+\n         if self.files.borrow().is_empty() && sp.source_equal(&DUMMY_SP) {\n             return \"no-location\".to_string();\n         }\n@@ -1099,12 +1100,16 @@ impl CodeMap {\n     }\n \n     pub fn span_to_lines(&self, sp: Span) -> FileLinesResult {\n+        debug!(\"span_to_lines(sp={:?})\", sp);\n+\n         if sp.lo > sp.hi {\n             return Err(SpanLinesError::IllFormedSpan(sp));\n         }\n \n         let lo = self.lookup_char_pos(sp.lo);\n+        debug!(\"span_to_lines: lo={:?}\", lo);\n         let hi = self.lookup_char_pos(sp.hi);\n+        debug!(\"span_to_lines: hi={:?}\", hi);\n \n         if lo.file.start_pos != hi.file.start_pos {\n             return Err(SpanLinesError::DistinctSources(DistinctSources {\n@@ -1125,7 +1130,9 @@ impl CodeMap {\n         // numbers in Loc are 1-based, so we subtract 1 to get 0-based\n         // lines.\n         for line_index in lo.line-1 .. hi.line-1 {\n-            let line_len = lo.file.get_line(line_index).map(|s| s.len()).unwrap_or(0);\n+            let line_len = lo.file.get_line(line_index)\n+                                  .map(|s| s.chars().count())\n+                                  .unwrap_or(0);\n             lines.push(LineInfo { line_index: line_index,\n                                   start_col: start_col,\n                                   end_col: CharPos::from_usize(line_len) });\n@@ -1184,59 +1191,6 @@ impl CodeMap {\n         }\n     }\n \n-    /// Groups and sorts spans by lines into `MultiSpan`s, where `push` adds them to their group,\n-    /// specifying the unification behaviour for overlapping spans.\n-    /// Spans overflowing a line are put into their own one-element-group.\n-    pub fn custom_group_spans<F>(&self, mut spans: Vec<Span>, push: F) -> Vec<MultiSpan>\n-        where F: Fn(&mut MultiSpan, Span)\n-    {\n-        spans.sort_by(|a, b| a.lo.cmp(&b.lo));\n-        let mut groups = Vec::<MultiSpan>::new();\n-        let mut overflowing = vec![];\n-        let mut prev_expn = ExpnId(!2u32);\n-        let mut prev_file = !0usize;\n-        let mut prev_line = !0usize;\n-        let mut err_size = 0;\n-\n-        for sp in spans {\n-            let line = self.lookup_char_pos(sp.lo).line;\n-            let line_hi = self.lookup_char_pos(sp.hi).line;\n-            if line != line_hi {\n-                overflowing.push(sp.into());\n-                continue\n-            }\n-            let file = self.lookup_filemap_idx(sp.lo);\n-\n-            if err_size < MAX_HIGHLIGHT_LINES && sp.expn_id == prev_expn && file == prev_file {\n-                // `push` takes care of sorting, trimming, and merging\n-                push(&mut groups.last_mut().unwrap(), sp);\n-                if line != prev_line {\n-                    err_size += 1;\n-                }\n-            } else {\n-                groups.push(sp.into());\n-                err_size = 1;\n-            }\n-            prev_expn = sp.expn_id;\n-            prev_file = file;\n-            prev_line = line;\n-        }\n-        groups.extend(overflowing);\n-        groups\n-    }\n-\n-    /// Groups and sorts spans by lines into `MultiSpan`s, merging overlapping spans.\n-    /// Spans overflowing a line are put into their own one-element-group.\n-    pub fn group_spans(&self, spans: Vec<Span>) -> Vec<MultiSpan> {\n-        self.custom_group_spans(spans, |msp, sp| msp.push_merge(sp))\n-    }\n-\n-    /// Like `group_spans`, but trims overlapping spans instead of\n-    /// merging them (for use with `end_highlight_lines`)\n-    pub fn end_group_spans(&self, spans: Vec<Span>) -> Vec<MultiSpan> {\n-        self.custom_group_spans(spans, |msp, sp| msp.push_trim(sp))\n-    }\n-\n     pub fn get_filemap(&self, filename: &str) -> Rc<FileMap> {\n         for fm in self.files.borrow().iter() {\n             if filename == fm.name {\n@@ -1636,13 +1590,13 @@ mod tests {\n         assert_eq!(file_lines.lines[0].line_index, 1);\n     }\n \n-    /// Given a string like \" ^~~~~~~~~~~~ \", produces a span\n+    /// Given a string like \" ~~~~~~~~~~~~ \", produces a span\n     /// coverting that range. The idea is that the string has the same\n     /// length as the input, and we uncover the byte positions.  Note\n     /// that this can span lines and so on.\n     fn span_from_selection(input: &str, selection: &str) -> Span {\n         assert_eq!(input.len(), selection.len());\n-        let left_index = selection.find('^').unwrap() as u32;\n+        let left_index = selection.find('~').unwrap() as u32;\n         let right_index = selection.rfind('~').map(|x|x as u32).unwrap_or(left_index);\n         Span { lo: BytePos(left_index), hi: BytePos(right_index + 1), expn_id: NO_EXPANSION }\n     }\n@@ -1653,7 +1607,7 @@ mod tests {\n     fn span_to_snippet_and_lines_spanning_multiple_lines() {\n         let cm = CodeMap::new();\n         let inputtext = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n-        let selection = \"     \\n    ^~\\n~~~\\n~~~~~     \\n   \\n\";\n+        let selection = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n         cm.new_filemap_and_lines(\"blork.rs\", inputtext);\n         let span = span_from_selection(inputtext, selection);\n \n@@ -1803,73 +1757,4 @@ r\"blork2.rs:2:1: 2:12\n \";\n         assert_eq!(sstr, res_str);\n     }\n-\n-    #[test]\n-    fn t13() {\n-        // Test that collecting multiple spans into line-groups works correctly\n-        let cm = CodeMap::new();\n-        let inp  =      \"_aaaaa__bbb\\nvv\\nw\\nx\\ny\\nz\\ncccccc__ddddee__\";\n-        let sp1  =      \" ^~~~~     \\n  \\n \\n \\n \\n \\n                \";\n-        let sp2  =      \"           \\n  \\n \\n \\n \\n^\\n                \";\n-        let sp3  =      \"        ^~~\\n~~\\n \\n \\n \\n \\n                \";\n-        let sp4  =      \"           \\n  \\n \\n \\n \\n \\n^~~~~~          \";\n-        let sp5  =      \"           \\n  \\n \\n \\n \\n \\n        ^~~~    \";\n-        let sp6  =      \"           \\n  \\n \\n \\n \\n \\n          ^~~~  \";\n-        let sp_trim =   \"           \\n  \\n \\n \\n \\n \\n            ^~  \";\n-        let sp_merge =  \"           \\n  \\n \\n \\n \\n \\n        ^~~~~~  \";\n-        let sp7  =      \"           \\n ^\\n \\n \\n \\n \\n                \";\n-        let sp8  =      \"           \\n  \\n^\\n \\n \\n \\n                \";\n-        let sp9  =      \"           \\n  \\n \\n^\\n \\n \\n                \";\n-        let sp10 =      \"           \\n  \\n \\n \\n^\\n \\n                \";\n-\n-        let span = |sp, expected| {\n-            let sp = span_from_selection(inp, sp);\n-            assert_eq!(&cm.span_to_snippet(sp).unwrap(), expected);\n-            sp\n-        };\n-\n-        cm.new_filemap_and_lines(\"blork.rs\", inp);\n-        let sp1 = span(sp1, \"aaaaa\");\n-        let sp2 = span(sp2, \"z\");\n-        let sp3 = span(sp3, \"bbb\\nvv\");\n-        let sp4 = span(sp4, \"cccccc\");\n-        let sp5 = span(sp5, \"dddd\");\n-        let sp6 = span(sp6, \"ddee\");\n-        let sp7 = span(sp7, \"v\");\n-        let sp8 = span(sp8, \"w\");\n-        let sp9 = span(sp9, \"x\");\n-        let sp10 = span(sp10, \"y\");\n-        let sp_trim = span(sp_trim, \"ee\");\n-        let sp_merge = span(sp_merge, \"ddddee\");\n-\n-        let spans = vec![sp5, sp2, sp4, sp9, sp10, sp7, sp3, sp8, sp1, sp6];\n-\n-        macro_rules! check_next {\n-            ($groups: expr, $expected: expr) => ({\n-                let actual = $groups.next().map(|g|&g.spans[..]);\n-                let expected = $expected;\n-                println!(\"actual:\\n{:?}\\n\", actual);\n-                println!(\"expected:\\n{:?}\\n\", expected);\n-                assert_eq!(actual, expected.as_ref().map(|x|&x[..]));\n-            });\n-        }\n-\n-        let _groups = cm.group_spans(spans.clone());\n-        let it = &mut _groups.iter();\n-\n-        check_next!(it, Some([sp1, sp7, sp8, sp9, sp10, sp2]));\n-        // New group because we're exceeding MAX_HIGHLIGHT_LINES\n-        check_next!(it, Some([sp4, sp_merge]));\n-        check_next!(it, Some([sp3]));\n-        check_next!(it, None::<[Span; 0]>);\n-\n-        let _groups = cm.end_group_spans(spans);\n-        let it = &mut _groups.iter();\n-\n-        check_next!(it, Some([sp1, sp7, sp8, sp9, sp10, sp2]));\n-        // New group because we're exceeding MAX_HIGHLIGHT_LINES\n-        check_next!(it, Some([sp4, sp5, sp_trim]));\n-        check_next!(it, Some([sp3]));\n-        check_next!(it, None::<[Span; 0]>);\n-    }\n }"}, {"sha": "25e0428248df4f7a9a6d03ad9ff75babb52582f5", "filename": "src/libsyntax/diagnostics/macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -101,9 +101,9 @@ macro_rules! span_help {\n }\n \n #[macro_export]\n-macro_rules! fileline_help {\n-    ($err:expr, $span:expr, $($message:tt)*) => ({\n-        ($err).fileline_help($span, &format!($($message)*));\n+macro_rules! help {\n+    ($err:expr, $($message:tt)*) => ({\n+        ($err).help(&format!($($message)*));\n     })\n }\n "}, {"sha": "486e2ace0876a1b9196c5f409b814e3e710a9c65", "filename": "src/libsyntax/errors/emitter.rs", "status": "modified", "additions": 359, "deletions": 570, "changes": 929, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Ferrors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Ferrors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Femitter.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -13,27 +13,85 @@ use self::Destination::*;\n use codemap::{self, COMMAND_LINE_SP, DUMMY_SP, Pos, Span, MultiSpan};\n use diagnostics;\n \n+use errors::check_old_skool;\n use errors::{Level, RenderSpan, CodeSuggestion, DiagnosticBuilder};\n use errors::RenderSpan::*;\n use errors::Level::*;\n+use errors::snippet::{RenderedLineKind, SnippetData, Style};\n \n use std::{cmp, fmt};\n use std::io::prelude::*;\n use std::io;\n use std::rc::Rc;\n use term;\n \n+/// Emitter trait for emitting errors. Do not implement this directly:\n+/// implement `CoreEmitter` instead.\n pub trait Emitter {\n-    fn emit(&mut self, span: Option<&MultiSpan>, msg: &str, code: Option<&str>, lvl: Level);\n-    fn custom_emit(&mut self, sp: &RenderSpan, msg: &str, lvl: Level);\n+    /// Emit a standalone diagnostic message.\n+    fn emit(&mut self, span: &MultiSpan, msg: &str, code: Option<&str>, lvl: Level);\n \n     /// Emit a structured diagnostic.\n+    fn emit_struct(&mut self, db: &DiagnosticBuilder);\n+}\n+\n+pub trait CoreEmitter {\n+    fn emit_message(&mut self,\n+                    rsp: &RenderSpan,\n+                    msg: &str,\n+                    code: Option<&str>,\n+                    lvl: Level,\n+                    is_header: bool,\n+                    show_snippet: bool);\n+}\n+\n+impl<T: CoreEmitter> Emitter for T {\n+    fn emit(&mut self,\n+            msp: &MultiSpan,\n+            msg: &str,\n+            code: Option<&str>,\n+            lvl: Level) {\n+        self.emit_message(&FullSpan(msp.clone()),\n+                          msg,\n+                          code,\n+                          lvl,\n+                          true,\n+                          true);\n+    }\n+\n     fn emit_struct(&mut self, db: &DiagnosticBuilder) {\n-        self.emit(db.span.as_ref(), &db.message, db.code.as_ref().map(|s| &**s), db.level);\n+        let old_school = check_old_skool();\n+        let db_span = FullSpan(db.span.clone());\n+        self.emit_message(&FullSpan(db.span.clone()),\n+                          &db.message,\n+                          db.code.as_ref().map(|s| &**s),\n+                          db.level,\n+                          true,\n+                          true);\n         for child in &db.children {\n-            match child.render_span {\n-                Some(ref sp) => self.custom_emit(sp, &child.message, child.level),\n-                None => self.emit(child.span.as_ref(), &child.message, None, child.level),\n+            let render_span = child.render_span\n+                                   .clone()\n+                                   .unwrap_or_else(\n+                                       || FullSpan(child.span.clone()));\n+\n+            if !old_school {\n+                self.emit_message(&render_span,\n+                                    &child.message,\n+                                    None,\n+                                    child.level,\n+                                    false,\n+                                    true);\n+            } else {\n+                let (render_span, show_snippet) = match render_span.span().primary_span() {\n+                    None => (db_span.clone(), false),\n+                    _ => (render_span, true)\n+                };\n+                self.emit_message(&render_span,\n+                                    &child.message,\n+                                    None,\n+                                    child.level,\n+                                    false,\n+                                    show_snippet);\n             }\n         }\n     }\n@@ -42,9 +100,6 @@ pub trait Emitter {\n /// maximum number of lines we will print for each error; arbitrary.\n pub const MAX_HIGHLIGHT_LINES: usize = 6;\n \n-/// maximum number of lines we will print for each span; arbitrary.\n-const MAX_SP_LINES: usize = 6;\n-\n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n pub enum ColorConfig {\n     Auto,\n@@ -68,21 +123,18 @@ pub struct BasicEmitter {\n     dst: Destination,\n }\n \n-impl Emitter for BasicEmitter {\n-    fn emit(&mut self,\n-            msp: Option<&MultiSpan>,\n-            msg: &str,\n-            code: Option<&str>,\n-            lvl: Level) {\n-        assert!(msp.is_none(), \"BasicEmitter can't handle spans\");\n+impl CoreEmitter for BasicEmitter {\n+    fn emit_message(&mut self,\n+                    _rsp: &RenderSpan,\n+                    msg: &str,\n+                    code: Option<&str>,\n+                    lvl: Level,\n+                    _is_header: bool,\n+                    _show_snippet: bool) {\n+        // we ignore the span as we have no access to a codemap at this point\n         if let Err(e) = print_diagnostic(&mut self.dst, \"\", lvl, msg, code) {\n             panic!(\"failed to print diagnostics: {:?}\", e);\n         }\n-\n-    }\n-\n-    fn custom_emit(&mut self, _: &RenderSpan, _: &str, _: Level) {\n-        panic!(\"BasicEmitter can't handle custom_emit\");\n     }\n }\n \n@@ -101,33 +153,26 @@ pub struct EmitterWriter {\n     dst: Destination,\n     registry: Option<diagnostics::registry::Registry>,\n     cm: Rc<codemap::CodeMap>,\n-}\n \n-impl Emitter for EmitterWriter {\n-    fn emit(&mut self,\n-            msp: Option<&MultiSpan>,\n-            msg: &str,\n-            code: Option<&str>,\n-            lvl: Level) {\n-        let error = match msp.map(|s|(s.to_span_bounds(), s)) {\n-            Some((COMMAND_LINE_SP, msp)) => {\n-                self.emit_(&FileLine(msp.clone()), msg, code, lvl)\n-            },\n-            Some((DUMMY_SP, _)) | None => print_diagnostic(&mut self.dst, \"\", lvl, msg, code),\n-            Some((_, msp)) => self.emit_(&FullSpan(msp.clone()), msg, code, lvl),\n-        };\n+    /// Is this the first error emitted thus far? If not, we emit a\n+    /// `\\n` before the top-level errors.\n+    first: bool,\n \n-        if let Err(e) = error {\n-            panic!(\"failed to print diagnostics: {:?}\", e);\n-        }\n-    }\n+    // For now, allow an old-school mode while we transition\n+    old_school: bool,\n+}\n \n-    fn custom_emit(&mut self,\n-                   rsp: &RenderSpan,\n-                   msg: &str,\n-                   lvl: Level) {\n-        if let Err(e) = self.emit_(rsp, msg, None, lvl) {\n-            panic!(\"failed to print diagnostics: {:?}\", e);\n+impl CoreEmitter for EmitterWriter {\n+    fn emit_message(&mut self,\n+                    rsp: &RenderSpan,\n+                    msg: &str,\n+                    code: Option<&str>,\n+                    lvl: Level,\n+                    is_header: bool,\n+                    show_snippet: bool) {\n+        match self.emit_message_(rsp, msg, code, lvl, is_header, show_snippet) {\n+            Ok(()) => { }\n+            Err(e) => panic!(\"failed to emit error: {}\", e)\n         }\n     }\n }\n@@ -151,73 +196,138 @@ impl EmitterWriter {\n                   registry: Option<diagnostics::registry::Registry>,\n                   code_map: Rc<codemap::CodeMap>)\n                   -> EmitterWriter {\n+        let old_school = check_old_skool();\n         if color_config.use_color() {\n             let dst = Destination::from_stderr();\n-            EmitterWriter { dst: dst, registry: registry, cm: code_map }\n+            EmitterWriter { dst: dst,\n+                            registry: registry,\n+                            cm: code_map,\n+                            first: true,\n+                            old_school: old_school }\n         } else {\n-            EmitterWriter { dst: Raw(Box::new(io::stderr())), registry: registry, cm: code_map }\n+            EmitterWriter { dst: Raw(Box::new(io::stderr())),\n+                            registry: registry,\n+                            cm: code_map,\n+                            first: true,\n+                            old_school: old_school }\n         }\n     }\n \n     pub fn new(dst: Box<Write + Send>,\n                registry: Option<diagnostics::registry::Registry>,\n                code_map: Rc<codemap::CodeMap>)\n                -> EmitterWriter {\n-        EmitterWriter { dst: Raw(dst), registry: registry, cm: code_map }\n-    }\n+        let old_school = check_old_skool();\n+        EmitterWriter { dst: Raw(dst),\n+                        registry: registry,\n+                        cm: code_map,\n+                        first: true,\n+                        old_school: old_school }\n+    }\n+\n+    fn emit_message_(&mut self,\n+                     rsp: &RenderSpan,\n+                     msg: &str,\n+                     code: Option<&str>,\n+                     lvl: Level,\n+                     is_header: bool,\n+                     show_snippet: bool)\n+                     -> io::Result<()> {\n+        if is_header {\n+            if self.first {\n+                self.first = false;\n+            } else {\n+                if !self.old_school {\n+                    write!(self.dst, \"\\n\")?;\n+                }\n+            }\n+        }\n \n-    fn emit_(&mut self,\n-             rsp: &RenderSpan,\n-             msg: &str,\n-             code: Option<&str>,\n-             lvl: Level)\n-             -> io::Result<()> {\n-        let msp = rsp.span();\n-        let bounds = msp.to_span_bounds();\n-\n-        let ss = if bounds == COMMAND_LINE_SP {\n-            \"<command line option>\".to_string()\n-        } else if let EndSpan(_) = *rsp {\n-            let span_end = Span { lo: bounds.hi, hi: bounds.hi, expn_id: bounds.expn_id};\n-            self.cm.span_to_string(span_end)\n-        } else {\n-            self.cm.span_to_string(bounds)\n-        };\n+        match code {\n+            Some(code) if self.registry.as_ref()\n+                                       .and_then(|registry| registry.find_description(code))\n+                                       .is_some() => {\n+                let code_with_explain = String::from(\"--explain \") + code;\n+                if self.old_school {\n+                    let loc = match rsp.span().primary_span() {\n+                        Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => \"\".to_string(),\n+                        Some(ps) => self.cm.span_to_string(ps),\n+                        None => \"\".to_string()\n+                    };\n+                    print_diagnostic(&mut self.dst, &loc, lvl, msg, Some(code))?\n+                }\n+                else {\n+                    print_diagnostic(&mut self.dst, \"\", lvl, msg, Some(&code_with_explain))?\n+                }\n+            }\n+            _ => {\n+                if self.old_school {\n+                    let loc = match rsp.span().primary_span() {\n+                        Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => \"\".to_string(),\n+                        Some(ps) => self.cm.span_to_string(ps),\n+                        None => \"\".to_string()\n+                    };\n+                    print_diagnostic(&mut self.dst, &loc, lvl, msg, code)?\n+                }\n+                else {\n+                    print_diagnostic(&mut self.dst, \"\", lvl, msg, code)?\n+                }\n+            }\n+        }\n \n-        print_diagnostic(&mut self.dst, &ss[..], lvl, msg, code)?;\n+        if !show_snippet {\n+            return Ok(());\n+        }\n \n+        // Watch out for various nasty special spans; don't try to\n+        // print any filename or anything for those.\n+        match rsp.span().primary_span() {\n+            Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => {\n+                return Ok(());\n+            }\n+            _ => { }\n+        }\n+\n+        // Otherwise, print out the snippet etc as needed.\n         match *rsp {\n-            FullSpan(_) => {\n+            FullSpan(ref msp) => {\n                 self.highlight_lines(msp, lvl)?;\n-                self.print_macro_backtrace(bounds)?;\n-            }\n-            EndSpan(_) => {\n-                self.end_highlight_lines(msp, lvl)?;\n-                self.print_macro_backtrace(bounds)?;\n+                if let Some(primary_span) = msp.primary_span() {\n+                    self.print_macro_backtrace(primary_span)?;\n+                }\n             }\n             Suggestion(ref suggestion) => {\n                 self.highlight_suggestion(suggestion)?;\n-                self.print_macro_backtrace(bounds)?;\n-            }\n-            FileLine(..) => {\n-                // no source text in this case!\n+                if let Some(primary_span) = rsp.span().primary_span() {\n+                    self.print_macro_backtrace(primary_span)?;\n+                }\n             }\n         }\n-\n-        if let Some(code) = code {\n-            if let Some(_) = self.registry.as_ref()\n-                                          .and_then(|registry| registry.find_description(code)) {\n-                print_diagnostic(&mut self.dst, &ss[..], Help,\n-                                 &format!(\"run `rustc --explain {}` to see a \\\n-                                           detailed explanation\", code), None)?;\n+        if self.old_school {\n+            match code {\n+                Some(code) if self.registry.as_ref()\n+                                        .and_then(|registry| registry.find_description(code))\n+                                        .is_some() => {\n+                    let loc = match rsp.span().primary_span() {\n+                        Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => \"\".to_string(),\n+                        Some(ps) => self.cm.span_to_string(ps),\n+                        None => \"\".to_string()\n+                    };\n+                    let msg = \"run `rustc --explain \".to_string() + &code.to_string() +\n+                        \"` to see a detailed explanation\";\n+                    print_diagnostic(&mut self.dst, &loc, Level::Help, &msg,\n+                        None)?\n+                }\n+                _ => ()\n             }\n         }\n         Ok(())\n     }\n \n     fn highlight_suggestion(&mut self, suggestion: &CodeSuggestion) -> io::Result<()>\n     {\n-        let lines = self.cm.span_to_lines(suggestion.msp.to_span_bounds()).unwrap();\n+        let primary_span = suggestion.msp.primary_span().unwrap();\n+        let lines = self.cm.span_to_lines(primary_span).unwrap();\n         assert!(!lines.lines.is_empty());\n \n         let complete = suggestion.splice_lines(&self.cm);\n@@ -251,325 +361,52 @@ impl EmitterWriter {\n                        lvl: Level)\n                        -> io::Result<()>\n     {\n-        let lines = match self.cm.span_to_lines(msp.to_span_bounds()) {\n-            Ok(lines) => lines,\n-            Err(_) => {\n-                write!(&mut self.dst, \"(internal compiler error: unprintable span)\\n\")?;\n-                return Ok(());\n-            }\n-        };\n-\n-        let fm = &*lines.file;\n-        if let None = fm.src {\n-            return Ok(());\n-        }\n-\n-        let display_line_infos = &lines.lines[..];\n-        assert!(display_line_infos.len() > 0);\n-\n-        // Calculate the widest number to format evenly and fix #11715\n-        let digits = line_num_max_digits(display_line_infos.last().unwrap());\n-        let first_line_index = display_line_infos.first().unwrap().line_index;\n-\n-        let skip = fm.name.chars().count() + digits + 2;\n-\n-        let mut spans = msp.spans.iter().peekable();\n-        let mut lines = display_line_infos.iter();\n-        let mut prev_line_index = first_line_index.wrapping_sub(1);\n-\n-        // Display at most MAX_HIGHLIGHT_LINES lines.\n-        let mut remaining_err_lines = MAX_HIGHLIGHT_LINES;\n-\n-        // To emit a overflowed spans code-lines *AFTER* the rendered spans\n-        let mut overflowed_buf = String::new();\n-        let mut overflowed = false;\n-\n-        // FIXME (#8706)\n-        'l: loop {\n-            if remaining_err_lines <= 0 {\n-                break;\n-            }\n-            let line = match lines.next() {\n-                Some(l) => l,\n-                None => break,\n-            };\n-\n-            // Skip is the number of characters we need to skip because they are\n-            // part of the 'filename:line ' part of the code line.\n-            let mut s: String = ::std::iter::repeat(' ').take(skip).collect();\n-            let mut col = skip;\n-            let mut lastc = ' ';\n-\n-            let cur_line_str = fm.get_line(line.line_index).unwrap();\n-            let mut line_chars = cur_line_str.chars().enumerate().peekable();\n-            let mut line_spans = 0;\n-\n-            // Assemble spans for this line\n-            loop {\n-                // Peek here to preserve the span if it doesn't belong to this line\n-                let sp = match spans.peek() {\n-                    Some(sp) => **sp,\n-                    None => break,\n-                };\n-                let lo = self.cm.lookup_char_pos(sp.lo);\n-                let hi = self.cm.lookup_char_pos(sp.hi);\n-                let line_num = line.line_index + 1;\n-\n-                if !(lo.line <= line_num && hi.line >= line_num) {\n-                    // This line is not contained in the span\n-                    if overflowed {\n-                        // Never elide the final line of an overflowed span\n-                        prev_line_index = line.line_index - 1;\n-                        overflowed = false;\n-                        break;\n-                    }\n-\n-                    if line_spans == 0 {\n-                        continue 'l;\n-                    } else {\n-                        // This line is finished, now render the spans we've assembled\n-                        break;\n-                    }\n+        let mut snippet_data = SnippetData::new(self.cm.clone(),\n+                                                msp.primary_span());\n+        if self.old_school {\n+            let mut output_vec = vec![];\n+\n+            for span_label in msp.span_labels() {\n+                let mut snippet_data = snippet_data.clone();\n+\n+                snippet_data.push(span_label.span,\n+                                  span_label.is_primary,\n+                                  span_label.label);\n+                if span_label.is_primary {\n+                    output_vec.insert(0, snippet_data);\n                 }\n-                spans.next();\n-                line_spans += 1;\n-\n-                if lo.line != hi.line {\n-                    // Assemble extra code lines to be emitted after this lines spans\n-                    // (substract `2` because the first and last line are rendered normally)\n-                    let max_lines = cmp::min(remaining_err_lines, MAX_SP_LINES) - 2;\n-                    prev_line_index = line.line_index;\n-                    let count = cmp::min((hi.line - lo.line - 1), max_lines);\n-                    for _ in 0..count {\n-                        let line = match lines.next() {\n-                            Some(l) => l,\n-                            None => break,\n-                        };\n-                        let line_str = fm.get_line(line.line_index).unwrap();\n-                        overflowed_buf.push_str(&format!(\"{}:{:>width$} {}\\n\",\n-                                                       fm.name,\n-                                                       line.line_index + 1,\n-                                                       line_str,\n-                                                       width=digits));\n-                        remaining_err_lines -= 1;\n-                        prev_line_index += 1\n-                    }\n-                    // Remember that the span overflowed to ensure\n-                    // that we emit its last line exactly once\n-                    // (other spans may, or may not, start on it)\n-                    overflowed = true;\n-                    break;\n-                }\n-\n-                for (pos, ch) in line_chars.by_ref() {\n-                    lastc = ch;\n-                    if pos >= lo.col.to_usize() { break; }\n-                    // Whenever a tab occurs on the code line, we insert one on\n-                    // the error-point-squiggly-line as well (instead of a space).\n-                    // That way the squiggly line will usually appear in the correct\n-                    // position.\n-                    match ch {\n-                        '\\t' => {\n-                            col += 8 - col%8;\n-                            s.push('\\t');\n-                        },\n-                        _ => {\n-                            col += 1;\n-                            s.push(' ');\n-                        },\n-                    }\n+                else {\n+                    output_vec.push(snippet_data);\n                 }\n+            }\n \n-                s.push('^');\n-                let col_ptr = col;\n-                let count = match lastc {\n-                    // Most terminals have a tab stop every eight columns by default\n-                    '\\t' => 8 - col%8,\n-                    _ => 1,\n-                };\n-                col += count;\n-                s.extend(::std::iter::repeat('~').take(count));\n-\n-                let hi = self.cm.lookup_char_pos(sp.hi);\n-                if hi.col != lo.col {\n-                    let mut chars = line_chars.by_ref();\n-                    loop {\n-                        // We peek here to preserve the value for the next span\n-                        let (pos, ch) = match chars.peek() {\n-                            Some(elem) => *elem,\n-                            None => break,\n-                        };\n-                        if pos >= hi.col.to_usize() { break; }\n-                        let count = match ch {\n-                            '\\t' => 8 - col%8,\n-                            _ => 1,\n-                        };\n-                        col += count;\n-                        s.extend(::std::iter::repeat('~').take(count));\n-\n-                        chars.next();\n+            for snippet_data in output_vec.iter() {\n+                let rendered_lines = snippet_data.render_lines();\n+                for rendered_line in &rendered_lines {\n+                    for styled_string in &rendered_line.text {\n+                        self.dst.apply_style(lvl, &rendered_line.kind, styled_string.style)?;\n+                        write!(&mut self.dst, \"{}\", styled_string.text)?;\n+                        self.dst.reset_attrs()?;\n                     }\n+                    write!(&mut self.dst, \"\\n\")?;\n                 }\n-                if (col - col_ptr) > 0 {\n-                    // One extra squiggly is replaced by a \"^\"\n-                    s.pop();\n-                }\n-            }\n-\n-            // If we elided something put an ellipsis.\n-            if prev_line_index != line.line_index.wrapping_sub(1) && !overflowed {\n-                write!(&mut self.dst, \"{0:1$}...\\n\", \"\", skip)?;\n-            }\n-\n-            // Print offending code-line\n-            remaining_err_lines -= 1;\n-            write!(&mut self.dst, \"{}:{:>width$} {}\\n\",\n-                   fm.name,\n-                   line.line_index + 1,\n-                   cur_line_str,\n-                   width=digits)?;\n-\n-            if s.len() > skip {\n-                // Render the spans we assembled previously (if any).\n-                println_maybe_styled!(&mut self.dst, term::Attr::ForegroundColor(lvl.color()),\n-                                      \"{}\", s)?;\n-            }\n-\n-            if !overflowed_buf.is_empty() {\n-                // Print code-lines trailing the rendered spans (when a span overflows)\n-                write!(&mut self.dst, \"{}\", &overflowed_buf)?;\n-                overflowed_buf.clear();\n-            } else {\n-                prev_line_index = line.line_index;\n             }\n         }\n-\n-        // If we elided something, put an ellipsis.\n-        if lines.next().is_some() {\n-            write!(&mut self.dst, \"{0:1$}...\\n\", \"\", skip)?;\n-        }\n-        Ok(())\n-    }\n-\n-    /// Here are the differences between this and the normal `highlight_lines`:\n-    /// `end_highlight_lines` will always put arrow on the last byte of each\n-    /// span (instead of the first byte). Also, when a span is too long (more\n-    /// than 6 lines), `end_highlight_lines` will print the first line, then\n-    /// dot dot dot, then last line, whereas `highlight_lines` prints the first\n-    /// six lines.\n-    #[allow(deprecated)]\n-    fn end_highlight_lines(&mut self,\n-                           msp: &MultiSpan,\n-                           lvl: Level)\n-                          -> io::Result<()> {\n-        let lines = match self.cm.span_to_lines(msp.to_span_bounds()) {\n-            Ok(lines) => lines,\n-            Err(_) => {\n-                write!(&mut self.dst, \"(internal compiler error: unprintable span)\\n\")?;\n-                return Ok(());\n+        else {\n+            for span_label in msp.span_labels() {\n+                snippet_data.push(span_label.span,\n+                                  span_label.is_primary,\n+                                  span_label.label);\n             }\n-        };\n-\n-        let fm = &*lines.file;\n-        if let None = fm.src {\n-            return Ok(());\n-        }\n-\n-        let lines = &lines.lines[..];\n-\n-        // Calculate the widest number to format evenly\n-        let first_line = lines.first().unwrap();\n-        let last_line = lines.last().unwrap();\n-        let digits = line_num_max_digits(last_line);\n-\n-        let skip = fm.name.chars().count() + digits + 2;\n-\n-        let mut spans = msp.spans.iter().peekable();\n-        let mut lines = lines.iter();\n-        let mut prev_line_index = first_line.line_index.wrapping_sub(1);\n-\n-        // Display at most MAX_HIGHLIGHT_LINES lines.\n-        let mut remaining_err_lines = MAX_HIGHLIGHT_LINES;\n-\n-        'l: loop {\n-            if remaining_err_lines <= 0 {\n-                break;\n-            }\n-            let line = match lines.next() {\n-                Some(line) => line,\n-                None => break,\n-            };\n-\n-            // Skip is the number of characters we need to skip because they are\n-            // part of the 'filename:line ' part of the previous line.\n-            let mut s: String = ::std::iter::repeat(' ').take(skip).collect();\n-\n-            let line_str = fm.get_line(line.line_index).unwrap();\n-            let mut line_chars = line_str.chars().enumerate();\n-            let mut line_spans = 0;\n-\n-            loop {\n-                // Peek here to preserve the span if it doesn't belong to this line\n-                let sp = match spans.peek() {\n-                    Some(sp) => **sp,\n-                    None => break,\n-                };\n-                let lo = self.cm.lookup_char_pos(sp.lo);\n-                let hi = self.cm.lookup_char_pos(sp.hi);\n-                let elide_sp = (hi.line - lo.line) >= MAX_SP_LINES;\n-\n-                let line_num = line.line_index + 1;\n-                if !(lo.line <= line_num && hi.line >= line_num) {\n-                    // This line is not contained in the span\n-                    if line_spans == 0 {\n-                        continue 'l;\n-                    } else {\n-                        // This line is finished, now render the spans we've assembled\n-                        break\n-                    }\n-                } else if hi.line > line_num {\n-                    if elide_sp && lo.line < line_num {\n-                        // This line is inbetween the first and last line of the span,\n-                        // so we may want to elide it.\n-                        continue 'l;\n-                    } else {\n-                        break\n-                    }\n-                }\n-                line_spans += 1;\n-                spans.next();\n-\n-                for (pos, ch) in line_chars.by_ref() {\n-                    // Span seems to use half-opened interval, so subtract 1\n-                    if pos >= hi.col.to_usize() - 1 { break; }\n-                    // Whenever a tab occurs on the previous line, we insert one on\n-                    // the error-point-squiggly-line as well (instead of a space).\n-                    // That way the squiggly line will usually appear in the correct\n-                    // position.\n-                    match ch {\n-                        '\\t' => s.push('\\t'),\n-                        _ => s.push(' '),\n-                    }\n+            let rendered_lines = snippet_data.render_lines();\n+            for rendered_line in &rendered_lines {\n+                for styled_string in &rendered_line.text {\n+                    self.dst.apply_style(lvl, &rendered_line.kind, styled_string.style)?;\n+                    write!(&mut self.dst, \"{}\", styled_string.text)?;\n+                    self.dst.reset_attrs()?;\n                 }\n-                s.push('^');\n-            }\n-\n-            if prev_line_index != line.line_index.wrapping_sub(1) {\n-                // If we elided something, put an ellipsis.\n-                write!(&mut self.dst, \"{0:1$}...\\n\", \"\", skip)?;\n+                write!(&mut self.dst, \"\\n\")?;\n             }\n-\n-            // Print offending code-lines\n-            write!(&mut self.dst, \"{}:{:>width$} {}\\n\", fm.name,\n-                   line.line_index + 1, line_str, width=digits)?;\n-            remaining_err_lines -= 1;\n-\n-            if s.len() > skip {\n-                // Render the spans we assembled previously (if any)\n-                println_maybe_styled!(&mut self.dst, term::Attr::ForegroundColor(lvl.color()),\n-                                      \"{}\", s)?;\n-            }\n-            prev_line_index = line.line_index;\n         }\n         Ok(())\n     }\n@@ -609,17 +446,29 @@ fn print_diagnostic(dst: &mut Destination,\n                     code: Option<&str>)\n                     -> io::Result<()> {\n     if !topic.is_empty() {\n-        write!(dst, \"{} \", topic)?;\n+        let old_school = check_old_skool();\n+        if !old_school {\n+            write!(dst, \"{}: \", topic)?;\n+        }\n+        else {\n+            write!(dst, \"{} \", topic)?;\n+        }\n+        dst.reset_attrs()?;\n     }\n-\n-    print_maybe_styled!(dst, term::Attr::ForegroundColor(lvl.color()),\n-                        \"{}: \", lvl.to_string())?;\n-    print_maybe_styled!(dst, term::Attr::Bold, \"{}\", msg)?;\n+    dst.start_attr(term::Attr::Bold)?;\n+    dst.start_attr(term::Attr::ForegroundColor(lvl.color()))?;\n+    write!(dst, \"{}\", lvl.to_string())?;\n+    dst.reset_attrs()?;\n+    write!(dst, \": \")?;\n+    dst.start_attr(term::Attr::Bold)?;\n+    write!(dst, \"{}\", msg)?;\n \n     if let Some(code) = code {\n         let style = term::Attr::ForegroundColor(term::color::BRIGHT_MAGENTA);\n         print_maybe_styled!(dst, style, \" [{}]\", code.clone())?;\n     }\n+\n+    dst.reset_attrs()?;\n     write!(dst, \"\\n\")?;\n     Ok(())\n }\n@@ -660,6 +509,51 @@ impl Destination {\n         }\n     }\n \n+    fn apply_style(&mut self,\n+                   lvl: Level,\n+                   _kind: &RenderedLineKind,\n+                   style: Style)\n+                   -> io::Result<()> {\n+        match style {\n+            Style::FileNameStyle |\n+            Style::LineAndColumn => {\n+            }\n+            Style::LineNumber => {\n+                self.start_attr(term::Attr::Bold)?;\n+                self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_BLUE))?;\n+            }\n+            Style::Quotation => {\n+            }\n+            Style::UnderlinePrimary | Style::LabelPrimary => {\n+                self.start_attr(term::Attr::Bold)?;\n+                self.start_attr(term::Attr::ForegroundColor(lvl.color()))?;\n+            }\n+            Style::UnderlineSecondary | Style::LabelSecondary => {\n+                self.start_attr(term::Attr::Bold)?;\n+                self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_BLUE))?;\n+            }\n+            Style::NoStyle => {\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    fn start_attr(&mut self, attr: term::Attr) -> io::Result<()> {\n+        match *self {\n+            Terminal(ref mut t) => { t.attr(attr)?; }\n+            Raw(_) => { }\n+        }\n+        Ok(())\n+    }\n+\n+    fn reset_attrs(&mut self) -> io::Result<()> {\n+        match *self {\n+            Terminal(ref mut t) => { t.reset()?; }\n+            Raw(_) => { }\n+        }\n+        Ok(())\n+    }\n+\n     fn print_maybe_styled(&mut self,\n                           args: fmt::Arguments,\n                           color: term::Attr,\n@@ -741,7 +635,7 @@ mod test {\n     /// that this can span lines and so on.\n     fn span_from_selection(input: &str, selection: &str) -> Span {\n         assert_eq!(input.len(), selection.len());\n-        let left_index = selection.find('^').unwrap() as u32;\n+        let left_index = selection.find('~').unwrap() as u32;\n         let right_index = selection.rfind('~').map(|x|x as u32).unwrap_or(left_index);\n         Span { lo: BytePos(left_index), hi: BytePos(right_index + 1), expn_id: NO_EXPANSION }\n     }\n@@ -767,7 +661,7 @@ mod test {\n         dreizehn\n         \";\n         let file = cm.new_filemap_and_lines(\"dummy.txt\", content);\n-        let start = file.lines.borrow()[7];\n+        let start = file.lines.borrow()[10];\n         let end = file.lines.borrow()[11];\n         let sp = mk_sp(start, end);\n         let lvl = Level::Error;\n@@ -777,20 +671,20 @@ mod test {\n         let vec = data.lock().unwrap().clone();\n         let vec: &[u8] = &vec;\n         let str = from_utf8(vec).unwrap();\n-        println!(\"{}\", str);\n-        assert_eq!(str, \"dummy.txt: 8         line8\\n\\\n-                         dummy.txt: 9         line9\\n\\\n-                         dummy.txt:10         line10\\n\\\n-                         dummy.txt:11         e-l\u00e4-v\u00e4n\\n\\\n-                         dummy.txt:12         tolv\\n\");\n+        println!(\"r#\\\"\\n{}\\\"#\", str);\n+        assert_eq!(str, &r#\"\n+  --> dummy.txt:11:1\n+11 |>         e-l\u00e4-v\u00e4n\n+   |> ^\n+\"#[1..]);\n     }\n \n     #[test]\n     fn test_single_span_splice() {\n         // Test that a `MultiSpan` containing a single span splices a substition correctly\n         let cm = CodeMap::new();\n         let inputtext = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n-        let selection = \"     \\n    ^~\\n~~~\\n~~~~~     \\n   \\n\";\n+        let selection = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n         cm.new_filemap_and_lines(\"blork.rs\", inputtext);\n         let sp = span_from_selection(inputtext, selection);\n         let msp: MultiSpan = sp.into();\n@@ -808,51 +702,25 @@ mod test {\n     }\n \n     #[test]\n-    fn test_multiple_span_splice() {\n-        // Test that a `MultiSpan` containing multiple spans splices substitions on\n-        // several lines correctly\n+    fn test_multi_span_splice() {\n+        // Test that a `MultiSpan` containing multiple spans splices a substition correctly\n         let cm = CodeMap::new();\n-        let inp = \"aaaaabbbbBB\\nZZ\\nZZ\\nCCCDDDDDdddddeee\";\n-        let sp1 = \"     ^~~~~~\\n  \\n  \\n                \";\n-        let sp2 = \"           \\n  \\n  \\n^~~~~~          \";\n-        let sp3 = \"           \\n  \\n  \\n        ^~~     \";\n-        let sp4 = \"           \\n  \\n  \\n           ^~~~ \";\n-\n-        let span_eq = |sp, eq| assert_eq!(&cm.span_to_snippet(sp).unwrap(), eq);\n-\n-        cm.new_filemap_and_lines(\"blork.rs\", inp);\n-        let sp1 = span_from_selection(inp, sp1);\n-        let sp2 = span_from_selection(inp, sp2);\n-        let sp3 = span_from_selection(inp, sp3);\n-        let sp4 = span_from_selection(inp, sp4);\n-        span_eq(sp1, \"bbbbBB\");\n-        span_eq(sp2, \"CCCDDD\");\n-        span_eq(sp3, \"ddd\");\n-        span_eq(sp4, \"ddee\");\n-\n-        let substitutes: Vec<String> = [\"1\", \"2\", \"3\", \"4\"].iter().map(|x|x.to_string()).collect();\n-        let expected = \"aaaaa1\\nZZ\\nZZ\\n2DD34e\";\n-\n-        let test = |msp| {\n-            let suggest = CodeSuggestion {\n-                msp: msp,\n-                substitutes: substitutes.clone(),\n-            };\n-            let actual = suggest.splice_lines(&cm);\n-            assert_eq!(actual, expected);\n+        let inputtext  = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n+        let selection1 = \"     \\n      \\n   \\n          \\n ~ \\n\"; // intentionally out of order\n+        let selection2 = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n+        cm.new_filemap_and_lines(\"blork.rs\", inputtext);\n+        let sp1 = span_from_selection(inputtext, selection1);\n+        let sp2 = span_from_selection(inputtext, selection2);\n+        let msp: MultiSpan = MultiSpan::from_spans(vec![sp1, sp2]);\n+\n+        let expected = \"bbbbZZZZZZddddd\\neXYZe\";\n+        let suggest = CodeSuggestion {\n+            msp: msp,\n+            substitutes: vec![\"ZZZZZZ\".to_owned(),\n+                              \"XYZ\".to_owned()]\n         };\n-        test(MultiSpan { spans: vec![sp1, sp2, sp3, sp4] });\n-\n-        // Test ordering and merging by `MultiSpan::push`\n-        let mut msp = MultiSpan::new();\n-        msp.push_merge(sp2);\n-        msp.push_merge(sp1);\n-        assert_eq!(&msp.spans, &[sp1, sp2]);\n-        msp.push_merge(sp4);\n-        assert_eq!(&msp.spans, &[sp1, sp2, sp4]);\n-        msp.push_merge(sp3);\n-        assert_eq!(&msp.spans, &[sp1, sp2, sp3, sp4]);\n-        test(msp);\n+\n+        assert_eq!(suggest.splice_lines(&cm), expected);\n     }\n \n     #[test]\n@@ -862,17 +730,17 @@ mod test {\n         let mut diag = EmitterWriter::new(Box::new(Sink(data.clone())), None, cm.clone());\n \n         let inp =       \"_____aaaaaa____bbbbbb__cccccdd_\";\n-        let sp1 =       \"     ^~~~~~                    \";\n-        let sp2 =       \"               ^~~~~~          \";\n-        let sp3 =       \"                       ^~~~~   \";\n-        let sp4 =       \"                          ^~~~ \";\n-        let sp34 =      \"                       ^~~~~~~ \";\n-        let sp4_end =   \"                            ^~ \";\n-\n-        let expect_start = \"dummy.txt:1 _____aaaaaa____bbbbbb__cccccdd_\\n\\\n-                         \\x20                ^~~~~~    ^~~~~~  ^~~~~~~\\n\";\n-        let expect_end =   \"dummy.txt:1 _____aaaaaa____bbbbbb__cccccdd_\\n\\\n-                         \\x20                     ^         ^      ^ ^\\n\";\n+        let sp1 =       \"     ~~~~~~                    \";\n+        let sp2 =       \"               ~~~~~~          \";\n+        let sp3 =       \"                       ~~~~~   \";\n+        let sp4 =       \"                          ~~~~ \";\n+        let sp34 =      \"                       ~~~~~~~ \";\n+\n+        let expect_start = &r#\"\n+ --> dummy.txt:1:6\n+1 |> _____aaaaaa____bbbbbb__cccccdd_\n+  |>      ^^^^^^    ^^^^^^  ^^^^^^^\n+\"#[1..];\n \n         let span = |sp, expected| {\n             let sp = span_from_selection(inp, sp);\n@@ -885,7 +753,6 @@ mod test {\n         let sp3 = span(sp3, \"ccccc\");\n         let sp4 = span(sp4, \"ccdd\");\n         let sp34 = span(sp34, \"cccccdd\");\n-        let sp4_end = span(sp4_end, \"dd\");\n \n         let spans = vec![sp1, sp2, sp3, sp4];\n \n@@ -894,26 +761,17 @@ mod test {\n             highlight();\n             let vec = data.lock().unwrap().clone();\n             let actual = from_utf8(&vec[..]).unwrap();\n+            println!(\"actual=\\n{}\", actual);\n             assert_eq!(actual, expected);\n         };\n \n-        let msp = MultiSpan { spans: vec![sp1, sp2, sp34] };\n-        let msp_end = MultiSpan { spans: vec![sp1, sp2, sp3, sp4_end] };\n+        let msp = MultiSpan::from_spans(vec![sp1, sp2, sp34]);\n         test(expect_start, &mut || {\n             diag.highlight_lines(&msp, Level::Error).unwrap();\n         });\n-        test(expect_end, &mut || {\n-            diag.end_highlight_lines(&msp_end, Level::Error).unwrap();\n-        });\n         test(expect_start, &mut || {\n-            for msp in cm.group_spans(spans.clone()) {\n-                diag.highlight_lines(&msp, Level::Error).unwrap();\n-            }\n-        });\n-        test(expect_end, &mut || {\n-            for msp in cm.end_group_spans(spans.clone()) {\n-                diag.end_highlight_lines(&msp, Level::Error).unwrap();\n-            }\n+            let msp = MultiSpan::from_spans(spans.clone());\n+            diag.highlight_lines(&msp, Level::Error).unwrap();\n         });\n     }\n \n@@ -950,75 +808,29 @@ mod test {\n         let sp4 = span(10, 10, (2, 3));\n         let sp5 = span(10, 10, (4, 6));\n \n-        let expect0 = \"dummy.txt: 5 ccccc\\n\\\n-                       dummy.txt: 6 xxxxx\\n\\\n-                       dummy.txt: 7 yyyyy\\n\\\n-                    \\x20            ...\\n\\\n-                       dummy.txt: 9 ddd__eee_\\n\\\n-                    \\x20            ^~~  ^~~\\n\\\n-                    \\x20            ...\\n\\\n-                       dummy.txt:11 __f_gg\\n\\\n-                    \\x20              ^ ^~\\n\";\n-\n-        let expect = \"dummy.txt: 1 aaaaa\\n\\\n-                      dummy.txt: 2 aaaaa\\n\\\n-                      dummy.txt: 3 aaaaa\\n\\\n-                      dummy.txt: 4 bbbbb\\n\\\n-                      dummy.txt: 5 ccccc\\n\\\n-                      dummy.txt: 6 xxxxx\\n\\\n-                   \\x20            ...\\n\";\n-\n-        let expect_g1 = \"dummy.txt:1 aaaaa\\n\\\n-                         dummy.txt:2 aaaaa\\n\\\n-                         dummy.txt:3 aaaaa\\n\\\n-                         dummy.txt:4 bbbbb\\n\\\n-                         dummy.txt:5 ccccc\\n\\\n-                         dummy.txt:6 xxxxx\\n\\\n-                      \\x20           ...\\n\";\n-\n-        let expect2 = \"dummy.txt: 9 ddd__eee_\\n\\\n-                    \\x20            ^~~  ^~~\\n\\\n-                    \\x20            ...\\n\\\n-                       dummy.txt:11 __f_gg\\n\\\n-                    \\x20              ^ ^~\\n\";\n-\n-\n-        let expect_end = \"dummy.txt: 1 aaaaa\\n\\\n-                       \\x20            ...\\n\\\n-                          dummy.txt: 7 yyyyy\\n\\\n-                       \\x20                ^\\n\\\n-                       \\x20            ...\\n\\\n-                          dummy.txt: 9 ddd__eee_\\n\\\n-                       \\x20              ^    ^\\n\\\n-                       \\x20            ...\\n\\\n-                          dummy.txt:11 __f_gg\\n\\\n-                       \\x20              ^  ^\\n\";\n-\n-        let expect0_end = \"dummy.txt: 5 ccccc\\n\\\n-                           dummy.txt: 6 xxxxx\\n\\\n-                           dummy.txt: 7 yyyyy\\n\\\n-                        \\x20                ^\\n\\\n-                        \\x20            ...\\n\\\n-                           dummy.txt: 9 ddd__eee_\\n\\\n-                        \\x20              ^    ^\\n\\\n-                        \\x20            ...\\n\\\n-                           dummy.txt:11 __f_gg\\n\\\n-                        \\x20              ^  ^\\n\";\n-\n-        let expect_end_g1 = \"dummy.txt:1 aaaaa\\n\\\n-                          \\x20           ...\\n\\\n-                             dummy.txt:7 yyyyy\\n\\\n-                          \\x20               ^\\n\";\n-\n-        let expect2_end = \"dummy.txt: 9 ddd__eee_\\n\\\n-                        \\x20              ^    ^\\n\\\n-                        \\x20            ...\\n\\\n-                           dummy.txt:11 __f_gg\\n\\\n-                        \\x20              ^  ^\\n\";\n-\n-        let expect_groups = [expect2, expect_g1];\n-        let expect_end_groups = [expect2_end, expect_end_g1];\n-        let spans = vec![sp3, sp1, sp4, sp2, sp5];\n+        let expect0 = &r#\"\n+   --> dummy.txt:5:1\n+5   |> ccccc\n+    |> ^\n+...\n+9   |> ddd__eee_\n+    |> ^^^  ^^^\n+10  |> elided\n+11  |> __f_gg\n+    |>   ^ ^^\n+\"#[1..];\n+\n+        let expect = &r#\"\n+   --> dummy.txt:1:1\n+1   |> aaaaa\n+    |> ^\n+...\n+9   |> ddd__eee_\n+    |> ^^^  ^^^\n+10  |> elided\n+11  |> __f_gg\n+    |>   ^ ^^\n+\"#[1..];\n \n         macro_rules! test {\n             ($expected: expr, $highlight: expr) => ({\n@@ -1034,37 +846,14 @@ mod test {\n             });\n         }\n \n-        let msp0 = MultiSpan { spans: vec![sp0, sp2, sp3, sp4, sp5] };\n-        let msp = MultiSpan { spans: vec![sp1, sp2, sp3, sp4, sp5] };\n-        let msp2 = MultiSpan { spans: vec![sp2, sp3, sp4, sp5] };\n+        let msp0 = MultiSpan::from_spans(vec![sp0, sp2, sp3, sp4, sp5]);\n+        let msp = MultiSpan::from_spans(vec![sp1, sp2, sp3, sp4, sp5]);\n \n         test!(expect0, || {\n             diag.highlight_lines(&msp0, Level::Error).unwrap();\n         });\n-        test!(expect0_end, || {\n-            diag.end_highlight_lines(&msp0, Level::Error).unwrap();\n-        });\n         test!(expect, || {\n             diag.highlight_lines(&msp, Level::Error).unwrap();\n         });\n-        test!(expect_end, || {\n-            diag.end_highlight_lines(&msp, Level::Error).unwrap();\n-        });\n-        test!(expect2, || {\n-            diag.highlight_lines(&msp2, Level::Error).unwrap();\n-        });\n-        test!(expect2_end, || {\n-            diag.end_highlight_lines(&msp2, Level::Error).unwrap();\n-        });\n-        for (msp, expect) in cm.group_spans(spans.clone()).iter().zip(expect_groups.iter()) {\n-            test!(expect, || {\n-                diag.highlight_lines(&msp, Level::Error).unwrap();\n-            });\n-        }\n-        for (msp, expect) in cm.group_spans(spans.clone()).iter().zip(expect_end_groups.iter()) {\n-            test!(expect, || {\n-                diag.end_highlight_lines(&msp, Level::Error).unwrap();\n-            });\n-        }\n     }\n }"}, {"sha": "93c6268ccaea15ecc35661c747b1bfa6aa126258", "filename": "src/libsyntax/errors/json.rs", "status": "modified", "additions": 83, "deletions": 121, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Ferrors%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Ferrors%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fjson.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -20,7 +20,7 @@\n // FIXME spec the JSON output properly.\n \n \n-use codemap::{self, Span, MacroBacktrace, MultiSpan, CodeMap};\n+use codemap::{self, MacroBacktrace, Span, SpanLabel, MultiSpan, CodeMap};\n use diagnostics::registry::Registry;\n use errors::{Level, DiagnosticBuilder, SubDiagnostic, RenderSpan, CodeSuggestion};\n use errors::emitter::Emitter;\n@@ -53,20 +53,13 @@ impl JsonEmitter {\n }\n \n impl Emitter for JsonEmitter {\n-    fn emit(&mut self, span: Option<&MultiSpan>, msg: &str, code: Option<&str>, level: Level) {\n+    fn emit(&mut self, span: &MultiSpan, msg: &str, code: Option<&str>, level: Level) {\n         let data = Diagnostic::new(span, msg, code, level, self);\n         if let Err(e) = writeln!(&mut self.dst, \"{}\", as_json(&data)) {\n             panic!(\"failed to print diagnostics: {:?}\", e);\n         }\n     }\n \n-    fn custom_emit(&mut self, sp: &RenderSpan, msg: &str, level: Level) {\n-        let data = Diagnostic::from_render_span(sp, msg, level, self);\n-        if let Err(e) = writeln!(&mut self.dst, \"{}\", as_json(&data)) {\n-            panic!(\"failed to print diagnostics: {:?}\", e);\n-        }\n-    }\n-\n     fn emit_struct(&mut self, db: &DiagnosticBuilder) {\n         let data = Diagnostic::from_diagnostic_builder(db, self);\n         if let Err(e) = writeln!(&mut self.dst, \"{}\", as_json(&data)) {\n@@ -104,8 +97,13 @@ struct DiagnosticSpan {\n     /// 1-based, character offset.\n     column_start: usize,\n     column_end: usize,\n+    /// Is this a \"primary\" span -- meaning the point, or one of the points,\n+    /// where the error occurred?\n+    is_primary: bool,\n     /// Source text from the start of line_start to the end of line_end.\n     text: Vec<DiagnosticSpanLine>,\n+    /// Label that should be placed at this location (if any)\n+    label: Option<String>,\n     /// If we are suggesting a replacement, this will contain text\n     /// that should be sliced in atop this span. You may prefer to\n     /// load the fully rendered version from the parent `Diagnostic`,\n@@ -148,7 +146,7 @@ struct DiagnosticCode {\n }\n \n impl<'a> Diagnostic<'a> {\n-    fn new(msp: Option<&MultiSpan>,\n+    fn new(msp: &MultiSpan,\n            msg: &'a str,\n            code: Option<&str>,\n            level: Level,\n@@ -158,35 +156,20 @@ impl<'a> Diagnostic<'a> {\n             message: msg,\n             code: DiagnosticCode::map_opt_string(code.map(|c| c.to_owned()), je),\n             level: level.to_str(),\n-            spans: msp.map_or(vec![], |msp| DiagnosticSpan::from_multispan(msp, je)),\n+            spans: DiagnosticSpan::from_multispan(msp, je),\n             children: vec![],\n             rendered: None,\n         }\n     }\n \n-    fn from_render_span(span: &RenderSpan,\n-                        msg: &'a str,\n-                        level: Level,\n-                        je: &JsonEmitter)\n-                        -> Diagnostic<'a> {\n-        Diagnostic {\n-            message: msg,\n-            code: None,\n-            level: level.to_str(),\n-            spans: DiagnosticSpan::from_render_span(span, je),\n-            children: vec![],\n-            rendered: je.render(span),\n-        }\n-    }\n-\n     fn from_diagnostic_builder<'c>(db: &'c DiagnosticBuilder,\n                                    je: &JsonEmitter)\n                                    -> Diagnostic<'c> {\n         Diagnostic {\n             message: &db.message,\n             code: DiagnosticCode::map_opt_string(db.code.clone(), je),\n             level: db.level.to_str(),\n-            spans: db.span.as_ref().map_or(vec![], |sp| DiagnosticSpan::from_multispan(sp, je)),\n+            spans: DiagnosticSpan::from_multispan(&db.span, je),\n             children: db.children.iter().map(|c| {\n                 Diagnostic::from_sub_diagnostic(c, je)\n             }).collect(),\n@@ -201,8 +184,7 @@ impl<'a> Diagnostic<'a> {\n             level: db.level.to_str(),\n             spans: db.render_span.as_ref()\n                      .map(|sp| DiagnosticSpan::from_render_span(sp, je))\n-                     .or_else(|| db.span.as_ref().map(|s| DiagnosticSpan::from_multispan(s, je)))\n-                     .unwrap_or(vec![]),\n+                     .unwrap_or_else(|| DiagnosticSpan::from_multispan(&db.span, je)),\n             children: vec![],\n             rendered: db.render_span.as_ref()\n                                     .and_then(|rsp| je.render(rsp)),\n@@ -211,44 +193,68 @@ impl<'a> Diagnostic<'a> {\n }\n \n impl DiagnosticSpan {\n-    fn from_span(span: Span, suggestion: Option<&String>, je: &JsonEmitter)\n-                 -> DiagnosticSpan {\n+    fn from_span_label(span: SpanLabel,\n+                       suggestion: Option<&String>,\n+                       je: &JsonEmitter)\n+                       -> DiagnosticSpan {\n+        Self::from_span_etc(span.span,\n+                            span.is_primary,\n+                            span.label,\n+                            suggestion,\n+                            je)\n+    }\n+\n+    fn from_span_etc(span: Span,\n+                     is_primary: bool,\n+                     label: Option<String>,\n+                     suggestion: Option<&String>,\n+                     je: &JsonEmitter)\n+                     -> DiagnosticSpan {\n         // obtain the full backtrace from the `macro_backtrace`\n         // helper; in some ways, it'd be better to expand the\n         // backtrace ourselves, but the `macro_backtrace` helper makes\n         // some decision, such as dropping some frames, and I don't\n         // want to duplicate that logic here.\n         let backtrace = je.cm.macro_backtrace(span).into_iter();\n-        DiagnosticSpan::from_span_and_backtrace(span, suggestion, backtrace, je)\n+        DiagnosticSpan::from_span_full(span,\n+                                       is_primary,\n+                                       label,\n+                                       suggestion,\n+                                       backtrace,\n+                                       je)\n     }\n \n-    fn from_span_and_backtrace(span: Span,\n-                               suggestion: Option<&String>,\n-                               mut backtrace: vec::IntoIter<MacroBacktrace>,\n-                               je: &JsonEmitter)\n-                               -> DiagnosticSpan {\n+    fn from_span_full(span: Span,\n+                      is_primary: bool,\n+                      label: Option<String>,\n+                      suggestion: Option<&String>,\n+                      mut backtrace: vec::IntoIter<MacroBacktrace>,\n+                      je: &JsonEmitter)\n+                      -> DiagnosticSpan {\n         let start = je.cm.lookup_char_pos(span.lo);\n         let end = je.cm.lookup_char_pos(span.hi);\n-        let backtrace_step =\n-            backtrace.next()\n-                     .map(|bt| {\n-                         let call_site =\n-                             Self::from_span_and_backtrace(bt.call_site,\n-                                                           None,\n-                                                           backtrace,\n-                                                           je);\n-                         let def_site_span = bt.def_site_span.map(|sp| {\n-                             Self::from_span_and_backtrace(sp,\n-                                                           None,\n-                                                           vec![].into_iter(),\n-                                                           je)\n-                         });\n-                         Box::new(DiagnosticSpanMacroExpansion {\n-                             span: call_site,\n-                             macro_decl_name: bt.macro_decl_name,\n-                             def_site_span: def_site_span,\n-                         })\n-                     });\n+        let backtrace_step = backtrace.next().map(|bt| {\n+            let call_site =\n+                Self::from_span_full(bt.call_site,\n+                                     false,\n+                                     None,\n+                                     None,\n+                                     backtrace,\n+                                     je);\n+            let def_site_span = bt.def_site_span.map(|sp| {\n+                Self::from_span_full(sp,\n+                                     false,\n+                                     None,\n+                                     None,\n+                                     vec![].into_iter(),\n+                                     je)\n+            });\n+            Box::new(DiagnosticSpanMacroExpansion {\n+                span: call_site,\n+                macro_decl_name: bt.macro_decl_name,\n+                def_site_span: def_site_span,\n+            })\n+        });\n         DiagnosticSpan {\n             file_name: start.file.name.clone(),\n             byte_start: span.lo.0,\n@@ -257,53 +263,41 @@ impl DiagnosticSpan {\n             line_end: end.line,\n             column_start: start.col.0 + 1,\n             column_end: end.col.0 + 1,\n+            is_primary: is_primary,\n             text: DiagnosticSpanLine::from_span(span, je),\n             suggested_replacement: suggestion.cloned(),\n             expansion: backtrace_step,\n+            label: label,\n         }\n     }\n \n     fn from_multispan(msp: &MultiSpan, je: &JsonEmitter) -> Vec<DiagnosticSpan> {\n-        msp.spans.iter().map(|&span| Self::from_span(span, None, je)).collect()\n+        msp.span_labels()\n+           .into_iter()\n+           .map(|span_str| Self::from_span_label(span_str, None, je))\n+           .collect()\n     }\n \n     fn from_suggestion(suggestion: &CodeSuggestion, je: &JsonEmitter)\n                        -> Vec<DiagnosticSpan> {\n-        assert_eq!(suggestion.msp.spans.len(), suggestion.substitutes.len());\n-        suggestion.msp.spans.iter()\n-                            .zip(&suggestion.substitutes)\n-                            .map(|(&span, suggestion)| {\n-                                DiagnosticSpan::from_span(span, Some(suggestion), je)\n-                            })\n-                            .collect()\n+        assert_eq!(suggestion.msp.span_labels().len(), suggestion.substitutes.len());\n+        suggestion.msp.span_labels()\n+                      .into_iter()\n+                      .zip(&suggestion.substitutes)\n+                      .map(|(span_label, suggestion)| {\n+                          DiagnosticSpan::from_span_label(span_label,\n+                                                          Some(suggestion),\n+                                                          je)\n+                      })\n+                      .collect()\n     }\n \n     fn from_render_span(rsp: &RenderSpan, je: &JsonEmitter) -> Vec<DiagnosticSpan> {\n         match *rsp {\n-            RenderSpan::FileLine(ref msp) |\n-            RenderSpan::FullSpan(ref msp) => {\n-                DiagnosticSpan::from_multispan(msp, je)\n-            }\n-            RenderSpan::Suggestion(ref suggestion) => {\n-                DiagnosticSpan::from_suggestion(suggestion, je)\n-            }\n-            RenderSpan::EndSpan(ref msp) => {\n-                msp.spans.iter().map(|&span| {\n-                    let end = je.cm.lookup_char_pos(span.hi);\n-                    DiagnosticSpan {\n-                        file_name: end.file.name.clone(),\n-                        byte_start: span.hi.0,\n-                        byte_end: span.hi.0,\n-                        line_start: end.line,\n-                        line_end: end.line,\n-                        column_start: end.col.0 + 1,\n-                        column_end: end.col.0 + 1,\n-                        text: DiagnosticSpanLine::from_span_end(span, je),\n-                        suggested_replacement: None,\n-                        expansion: None,\n-                    }\n-                }).collect()\n-            }\n+            RenderSpan::FullSpan(ref msp) =>\n+                DiagnosticSpan::from_multispan(msp, je),\n+            RenderSpan::Suggestion(ref suggestion) =>\n+                DiagnosticSpan::from_suggestion(suggestion, je),\n         }\n     }\n }\n@@ -340,34 +334,6 @@ impl DiagnosticSpanLine {\n              })\n             .unwrap_or(vec![])\n     }\n-\n-    /// Create a list of DiagnosticSpanLines from span - the result covers all\n-    /// of `span`, but the highlight is zero-length and at the end of `span`.\n-    fn from_span_end(span: Span, je: &JsonEmitter) -> Vec<DiagnosticSpanLine> {\n-        je.cm.span_to_lines(span)\n-             .map(|lines| {\n-                 let fm = &*lines.file;\n-                 lines.lines.iter()\n-                            .enumerate()\n-                            .map(|(i, line)| {\n-                                // Invariant - CodeMap::span_to_lines\n-                                // will not return extra context lines\n-                                // - the last line returned is the last\n-                                // line of `span`.\n-                                let highlight = if i == lines.lines.len() - 1 {\n-                                    (line.end_col.0 + 1, line.end_col.0 + 1)\n-                                } else {\n-                                    (0, 0)\n-                                };\n-                                DiagnosticSpanLine::line_from_filemap(fm,\n-                                                                      line.line_index,\n-                                                                      highlight.0,\n-                                                                      highlight.1)\n-                            })\n-                            .collect()\n-             })\n-            .unwrap_or(vec![])\n-    }\n }\n \n impl DiagnosticCode {\n@@ -389,16 +355,12 @@ impl DiagnosticCode {\n impl JsonEmitter {\n     fn render(&self, render_span: &RenderSpan) -> Option<String> {\n         match *render_span {\n-            RenderSpan::FileLine(_) |\n             RenderSpan::FullSpan(_) => {\n                 None\n             }\n             RenderSpan::Suggestion(ref suggestion) => {\n                 Some(suggestion.splice_lines(&self.cm))\n             }\n-            RenderSpan::EndSpan(_) => {\n-                None\n-            }\n         }\n     }\n }"}, {"sha": "f0c665bcb3cdb2bf3aca5dc05d6de66ba295329d", "filename": "src/libsyntax/errors/mod.rs", "status": "modified", "additions": 108, "deletions": 96, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fmod.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -13,17 +13,19 @@ pub use errors::emitter::ColorConfig;\n use self::Level::*;\n use self::RenderSpan::*;\n \n-use codemap::{self, CodeMap, MultiSpan};\n+use codemap::{self, CodeMap, MultiSpan, NO_EXPANSION, Span};\n use diagnostics;\n use errors::emitter::{Emitter, EmitterWriter};\n \n use std::cell::{RefCell, Cell};\n use std::{error, fmt};\n use std::rc::Rc;\n+use std::thread::panicking;\n use term;\n \n pub mod emitter;\n pub mod json;\n+pub mod snippet;\n \n #[derive(Clone)]\n pub enum RenderSpan {\n@@ -32,22 +34,11 @@ pub enum RenderSpan {\n     /// the source code covered by the span.\n     FullSpan(MultiSpan),\n \n-    /// Similar to a FullSpan, but the cited position is the end of\n-    /// the span, instead of the start. Used, at least, for telling\n-    /// compiletest/runtest to look at the last line of the span\n-    /// (since `end_highlight_lines` displays an arrow to the end\n-    /// of the span).\n-    EndSpan(MultiSpan),\n-\n     /// A suggestion renders with both with an initial line for the\n     /// message, prefixed by file:linenum, followed by a summary\n     /// of hypothetical source code, where each `String` is spliced\n     /// into the lines in place of the code covered by each span.\n     Suggestion(CodeSuggestion),\n-\n-    /// A FileLine renders with just a line for the message prefixed\n-    /// by file:linenum.\n-    FileLine(MultiSpan),\n }\n \n #[derive(Clone)]\n@@ -60,9 +51,7 @@ impl RenderSpan {\n     fn span(&self) -> &MultiSpan {\n         match *self {\n             FullSpan(ref msp) |\n-            Suggestion(CodeSuggestion { ref msp, .. }) |\n-            EndSpan(ref msp) |\n-            FileLine(ref msp) =>\n+            Suggestion(CodeSuggestion { ref msp, .. }) =>\n                 msp\n         }\n     }\n@@ -88,12 +77,24 @@ impl CodeSuggestion {\n                 }\n             }\n         }\n-        let bounds = self.msp.to_span_bounds();\n-        let lines = cm.span_to_lines(bounds).unwrap();\n-        assert!(!lines.lines.is_empty());\n \n-        // This isn't strictly necessary, but would in all likelyhood be an error\n-        assert_eq!(self.msp.spans.len(), self.substitutes.len());\n+        let mut primary_spans = self.msp.primary_spans().to_owned();\n+\n+        assert_eq!(primary_spans.len(), self.substitutes.len());\n+        if primary_spans.is_empty() {\n+            return format!(\"\");\n+        }\n+\n+        // Assumption: all spans are in the same file, and all spans\n+        // are disjoint. Sort in ascending order.\n+        primary_spans.sort_by_key(|sp| sp.lo);\n+\n+        // Find the bounding span.\n+        let lo = primary_spans.iter().map(|sp| sp.lo).min().unwrap();\n+        let hi = primary_spans.iter().map(|sp| sp.hi).min().unwrap();\n+        let bounding_span = Span { lo: lo, hi: hi, expn_id: NO_EXPANSION };\n+        let lines = cm.span_to_lines(bounding_span).unwrap();\n+        assert!(!lines.lines.is_empty());\n \n         // To build up the result, we do this for each span:\n         // - push the line segment trailing the previous span\n@@ -105,13 +106,13 @@ impl CodeSuggestion {\n         //\n         // Finally push the trailing line segment of the last span\n         let fm = &lines.file;\n-        let mut prev_hi = cm.lookup_char_pos(bounds.lo);\n+        let mut prev_hi = cm.lookup_char_pos(bounding_span.lo);\n         prev_hi.col = CharPos::from_usize(0);\n \n         let mut prev_line = fm.get_line(lines.lines[0].line_index);\n         let mut buf = String::new();\n \n-        for (sp, substitute) in self.msp.spans.iter().zip(self.substitutes.iter()) {\n+        for (sp, substitute) in primary_spans.iter().zip(self.substitutes.iter()) {\n             let cur_lo = cm.lookup_char_pos(sp.lo);\n             if prev_hi.line == cur_lo.line {\n                 push_trailing(&mut buf, prev_line, &prev_hi, Some(&cur_lo));\n@@ -183,7 +184,7 @@ pub struct DiagnosticBuilder<'a> {\n     level: Level,\n     message: String,\n     code: Option<String>,\n-    span: Option<MultiSpan>,\n+    span: MultiSpan,\n     children: Vec<SubDiagnostic>,\n }\n \n@@ -192,7 +193,7 @@ pub struct DiagnosticBuilder<'a> {\n struct SubDiagnostic {\n     level: Level,\n     message: String,\n-    span: Option<MultiSpan>,\n+    span: MultiSpan,\n     render_span: Option<RenderSpan>,\n }\n \n@@ -228,37 +229,61 @@ impl<'a> DiagnosticBuilder<'a> {\n         self.level == Level::Fatal\n     }\n \n-    pub fn note(&mut self , msg: &str) -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Note, msg, None, None);\n+    /// Add a span/label to be included in the resulting snippet.\n+    /// This is pushed onto the `MultiSpan` that was created when the\n+    /// diagnostic was first built. If you don't call this function at\n+    /// all, and you just supplied a `Span` to create the diagnostic,\n+    /// then the snippet will just include that `Span`, which is\n+    /// called the primary span.\n+    pub fn span_label(mut self, span: Span, label: &fmt::Display)\n+                      -> DiagnosticBuilder<'a> {\n+        self.span.push_span_label(span, format!(\"{}\", label));\n+        self\n+    }\n+\n+    pub fn note_expected_found(mut self,\n+                               label: &fmt::Display,\n+                               expected: &fmt::Display,\n+                               found: &fmt::Display)\n+                               -> DiagnosticBuilder<'a>\n+    {\n+        // For now, just attach these as notes\n+        self.note(&format!(\"expected {} `{}`\", label, expected));\n+        self.note(&format!(\"   found {} `{}`\", label, found));\n+        self\n+    }\n+\n+    pub fn note(&mut self, msg: &str) -> &mut DiagnosticBuilder<'a> {\n+        self.sub(Level::Note, msg, MultiSpan::new(), None);\n         self\n     }\n     pub fn span_note<S: Into<MultiSpan>>(&mut self,\n                                          sp: S,\n                                          msg: &str)\n                                          -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Note, msg, Some(sp.into()), None);\n+        self.sub(Level::Note, msg, sp.into(), None);\n         self\n     }\n     pub fn warn(&mut self, msg: &str) -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Warning, msg, None, None);\n+        self.sub(Level::Warning, msg, MultiSpan::new(), None);\n         self\n     }\n     pub fn span_warn<S: Into<MultiSpan>>(&mut self,\n                                          sp: S,\n                                          msg: &str)\n                                          -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Warning, msg, Some(sp.into()), None);\n+        self.sub(Level::Warning, msg, sp.into(), None);\n         self\n     }\n     pub fn help(&mut self , msg: &str) -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Help, msg, None, None);\n+        self.sub(Level::Help, msg, MultiSpan::new(), None);\n         self\n     }\n     pub fn span_help<S: Into<MultiSpan>>(&mut self,\n                                          sp: S,\n                                          msg: &str)\n                                          -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Help, msg, Some(sp.into()), None);\n+        self.sub(Level::Help, msg, sp.into(), None);\n         self\n     }\n     /// Prints out a message with a suggested edit of the code.\n@@ -269,43 +294,15 @@ impl<'a> DiagnosticBuilder<'a> {\n                                                msg: &str,\n                                                suggestion: String)\n                                                -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Help, msg, None, Some(Suggestion(CodeSuggestion {\n+        self.sub(Level::Help, msg, MultiSpan::new(), Some(Suggestion(CodeSuggestion {\n             msp: sp.into(),\n             substitutes: vec![suggestion],\n         })));\n         self\n     }\n-    pub fn span_end_note<S: Into<MultiSpan>>(&mut self,\n-                                             sp: S,\n-                                             msg: &str)\n-                                             -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Note, msg, None, Some(EndSpan(sp.into())));\n-        self\n-    }\n-    pub fn fileline_warn<S: Into<MultiSpan>>(&mut self,\n-                                             sp: S,\n-                                             msg: &str)\n-                                             -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Warning, msg, None, Some(FileLine(sp.into())));\n-        self\n-    }\n-    pub fn fileline_note<S: Into<MultiSpan>>(&mut self,\n-                                             sp: S,\n-                                             msg: &str)\n-                                             -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Note, msg, None, Some(FileLine(sp.into())));\n-        self\n-    }\n-    pub fn fileline_help<S: Into<MultiSpan>>(&mut self,\n-                                             sp: S,\n-                                             msg: &str)\n-                                             -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Help, msg, None, Some(FileLine(sp.into())));\n-        self\n-    }\n \n-    pub fn span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self {\n-        self.span = Some(sp.into());\n+    pub fn set_span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self {\n+        self.span = sp.into();\n         self\n     }\n \n@@ -324,7 +321,7 @@ impl<'a> DiagnosticBuilder<'a> {\n             level: level,\n             message: message.to_owned(),\n             code: None,\n-            span: None,\n+            span: MultiSpan::new(),\n             children: vec![],\n         }\n     }\n@@ -334,7 +331,7 @@ impl<'a> DiagnosticBuilder<'a> {\n     fn sub(&mut self,\n            level: Level,\n            message: &str,\n-           span: Option<MultiSpan>,\n+           span: MultiSpan,\n            render_span: Option<RenderSpan>) {\n         let sub = SubDiagnostic {\n             level: level,\n@@ -356,8 +353,11 @@ impl<'a> fmt::Debug for DiagnosticBuilder<'a> {\n /// we emit a bug.\n impl<'a> Drop for DiagnosticBuilder<'a> {\n     fn drop(&mut self) {\n-        if !self.cancelled() {\n-            self.emitter.borrow_mut().emit(None, \"Error constructed but not emitted\", None, Bug);\n+        if !panicking() && !self.cancelled() {\n+            self.emitter.borrow_mut().emit(&MultiSpan::new(),\n+                                           \"Error constructed but not emitted\",\n+                                           None,\n+                                           Bug);\n             panic!();\n         }\n     }\n@@ -412,7 +412,7 @@ impl Handler {\n                                                     msg: &str)\n                                                     -> DiagnosticBuilder<'a> {\n         let mut result = DiagnosticBuilder::new(&self.emit, Level::Warning, msg);\n-        result.span(sp);\n+        result.set_span(sp);\n         if !self.can_emit_warnings {\n             result.cancel();\n         }\n@@ -424,7 +424,7 @@ impl Handler {\n                                                               code: &str)\n                                                               -> DiagnosticBuilder<'a> {\n         let mut result = DiagnosticBuilder::new(&self.emit, Level::Warning, msg);\n-        result.span(sp);\n+        result.set_span(sp);\n         result.code(code.to_owned());\n         if !self.can_emit_warnings {\n             result.cancel();\n@@ -444,7 +444,7 @@ impl Handler {\n                                                    -> DiagnosticBuilder<'a> {\n         self.bump_err_count();\n         let mut result = DiagnosticBuilder::new(&self.emit, Level::Error, msg);\n-        result.span(sp);\n+        result.set_span(sp);\n         result\n     }\n     pub fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(&'a self,\n@@ -454,7 +454,7 @@ impl Handler {\n                                                              -> DiagnosticBuilder<'a> {\n         self.bump_err_count();\n         let mut result = DiagnosticBuilder::new(&self.emit, Level::Error, msg);\n-        result.span(sp);\n+        result.set_span(sp);\n         result.code(code.to_owned());\n         result\n     }\n@@ -468,7 +468,7 @@ impl Handler {\n                                                      -> DiagnosticBuilder<'a> {\n         self.bump_err_count();\n         let mut result = DiagnosticBuilder::new(&self.emit, Level::Fatal, msg);\n-        result.span(sp);\n+        result.set_span(sp);\n         result\n     }\n     pub fn struct_span_fatal_with_code<'a, S: Into<MultiSpan>>(&'a self,\n@@ -478,7 +478,7 @@ impl Handler {\n                                                                -> DiagnosticBuilder<'a> {\n         self.bump_err_count();\n         let mut result = DiagnosticBuilder::new(&self.emit, Level::Fatal, msg);\n-        result.span(sp);\n+        result.set_span(sp);\n         result.code(code.to_owned());\n         result\n     }\n@@ -499,7 +499,7 @@ impl Handler {\n         if self.treat_err_as_bug {\n             self.span_bug(sp, msg);\n         }\n-        self.emit(Some(&sp.into()), msg, Fatal);\n+        self.emit(&sp.into(), msg, Fatal);\n         self.bump_err_count();\n         return FatalError;\n     }\n@@ -508,44 +508,44 @@ impl Handler {\n         if self.treat_err_as_bug {\n             self.span_bug(sp, msg);\n         }\n-        self.emit_with_code(Some(&sp.into()), msg, code, Fatal);\n+        self.emit_with_code(&sp.into(), msg, code, Fatal);\n         self.bump_err_count();\n         return FatalError;\n     }\n     pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         if self.treat_err_as_bug {\n             self.span_bug(sp, msg);\n         }\n-        self.emit(Some(&sp.into()), msg, Error);\n+        self.emit(&sp.into(), msg, Error);\n         self.bump_err_count();\n     }\n     pub fn span_err_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: &str) {\n         if self.treat_err_as_bug {\n             self.span_bug(sp, msg);\n         }\n-        self.emit_with_code(Some(&sp.into()), msg, code, Error);\n+        self.emit_with_code(&sp.into(), msg, code, Error);\n         self.bump_err_count();\n     }\n     pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.emit(Some(&sp.into()), msg, Warning);\n+        self.emit(&sp.into(), msg, Warning);\n     }\n     pub fn span_warn_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: &str) {\n-        self.emit_with_code(Some(&sp.into()), msg, code, Warning);\n+        self.emit_with_code(&sp.into(), msg, code, Warning);\n     }\n     pub fn span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n-        self.emit(Some(&sp.into()), msg, Bug);\n+        self.emit(&sp.into(), msg, Bug);\n         panic!(ExplicitBug);\n     }\n     pub fn delay_span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         let mut delayed = self.delayed_span_bug.borrow_mut();\n         *delayed = Some((sp.into(), msg.to_string()));\n     }\n     pub fn span_bug_no_panic<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.emit(Some(&sp.into()), msg, Bug);\n+        self.emit(&sp.into(), msg, Bug);\n         self.bump_err_count();\n     }\n     pub fn span_note_without_error<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.emit.borrow_mut().emit(Some(&sp.into()), msg, None, Note);\n+        self.emit.borrow_mut().emit(&sp.into(), msg, None, Note);\n     }\n     pub fn span_unimpl<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n         self.span_bug(sp, &format!(\"unimplemented {}\", msg));\n@@ -554,25 +554,25 @@ impl Handler {\n         if self.treat_err_as_bug {\n             self.bug(msg);\n         }\n-        self.emit.borrow_mut().emit(None, msg, None, Fatal);\n+        self.emit.borrow_mut().emit(&MultiSpan::new(), msg, None, Fatal);\n         self.bump_err_count();\n         FatalError\n     }\n     pub fn err(&self, msg: &str) {\n         if self.treat_err_as_bug {\n             self.bug(msg);\n         }\n-        self.emit.borrow_mut().emit(None, msg, None, Error);\n+        self.emit.borrow_mut().emit(&MultiSpan::new(), msg, None, Error);\n         self.bump_err_count();\n     }\n     pub fn warn(&self, msg: &str) {\n-        self.emit.borrow_mut().emit(None, msg, None, Warning);\n+        self.emit.borrow_mut().emit(&MultiSpan::new(), msg, None, Warning);\n     }\n     pub fn note_without_error(&self, msg: &str) {\n-        self.emit.borrow_mut().emit(None, msg, None, Note);\n+        self.emit.borrow_mut().emit(&MultiSpan::new(), msg, None, Note);\n     }\n     pub fn bug(&self, msg: &str) -> ! {\n-        self.emit.borrow_mut().emit(None, msg, None, Bug);\n+        self.emit.borrow_mut().emit(&MultiSpan::new(), msg, None, Bug);\n         panic!(ExplicitBug);\n     }\n     pub fn unimpl(&self, msg: &str) -> ! {\n@@ -614,25 +614,20 @@ impl Handler {\n         panic!(self.fatal(&s));\n     }\n     pub fn emit(&self,\n-                msp: Option<&MultiSpan>,\n+                msp: &MultiSpan,\n                 msg: &str,\n                 lvl: Level) {\n         if lvl == Warning && !self.can_emit_warnings { return }\n-        self.emit.borrow_mut().emit(msp, msg, None, lvl);\n+        self.emit.borrow_mut().emit(&msp, msg, None, lvl);\n         if !self.continue_after_error.get() { self.abort_if_errors(); }\n     }\n     pub fn emit_with_code(&self,\n-                          msp: Option<&MultiSpan>,\n+                          msp: &MultiSpan,\n                           msg: &str,\n                           code: &str,\n                           lvl: Level) {\n         if lvl == Warning && !self.can_emit_warnings { return }\n-        self.emit.borrow_mut().emit(msp, msg, Some(code), lvl);\n-        if !self.continue_after_error.get() { self.abort_if_errors(); }\n-    }\n-    pub fn custom_emit(&self, rsp: RenderSpan, msg: &str, lvl: Level) {\n-        if lvl == Warning && !self.can_emit_warnings { return }\n-        self.emit.borrow_mut().custom_emit(&rsp, msg, lvl);\n+        self.emit.borrow_mut().emit(&msp, msg, Some(code), lvl);\n         if !self.continue_after_error.get() { self.abort_if_errors(); }\n     }\n }\n@@ -662,7 +657,7 @@ impl Level {\n     fn color(self) -> term::color::Color {\n         match self {\n             Bug | Fatal | PhaseFatal | Error => term::color::BRIGHT_RED,\n-            Warning => term::color::BRIGHT_YELLOW,\n+            Warning => term::color::YELLOW,\n             Note => term::color::BRIGHT_GREEN,\n             Help => term::color::BRIGHT_CYAN,\n             Cancelled => unreachable!(),\n@@ -689,3 +684,20 @@ pub fn expect<T, M>(diag: &Handler, opt: Option<T>, msg: M) -> T where\n         None => diag.bug(&msg()),\n     }\n }\n+\n+/// True if we should use the old-skool error format style. This is\n+/// the default setting until the new errors are deemed stable enough\n+/// for general use.\n+///\n+/// FIXME(#33240)\n+#[cfg(not(test))]\n+fn check_old_skool() -> bool {\n+    use std::env;\n+    env::var(\"RUST_NEW_ERROR_FORMAT\").is_err()\n+}\n+\n+/// For unit tests, use the new format.\n+#[cfg(test)]\n+fn check_old_skool() -> bool {\n+    false\n+}"}, {"sha": "e213f623ab85dac2e40fe4c49536fc0938f74b0e", "filename": "src/libsyntax/errors/snippet/mod.rs", "status": "added", "additions": 821, "deletions": 0, "changes": 821, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Ferrors%2Fsnippet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Ferrors%2Fsnippet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fsnippet%2Fmod.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -0,0 +1,821 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Code for annotating snippets.\n+\n+use codemap::{CharPos, CodeMap, FileMap, LineInfo, Span};\n+use errors::check_old_skool;\n+use std::cmp;\n+use std::rc::Rc;\n+use std::mem;\n+\n+mod test;\n+\n+#[derive(Clone)]\n+pub struct SnippetData {\n+    codemap: Rc<CodeMap>,\n+    files: Vec<FileInfo>,\n+}\n+\n+#[derive(Clone)]\n+pub struct FileInfo {\n+    file: Rc<FileMap>,\n+\n+    /// The \"primary file\", if any, gets a `-->` marker instead of\n+    /// `>>>`, and has a line-number/column printed and not just a\n+    /// filename.  It appears first in the listing. It is known to\n+    /// contain at least one primary span, though primary spans (which\n+    /// are designated with `^^^`) may also occur in other files.\n+    primary_span: Option<Span>,\n+\n+    lines: Vec<Line>,\n+}\n+\n+#[derive(Clone, Debug)]\n+struct Line {\n+    line_index: usize,\n+    annotations: Vec<Annotation>,\n+}\n+\n+#[derive(Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n+struct Annotation {\n+    /// Start column, 0-based indexing -- counting *characters*, not\n+    /// utf-8 bytes. Note that it is important that this field goes\n+    /// first, so that when we sort, we sort orderings by start\n+    /// column.\n+    start_col: usize,\n+\n+    /// End column within the line (exclusive)\n+    end_col: usize,\n+\n+    /// Is this annotation derived from primary span\n+    is_primary: bool,\n+\n+    /// Optional label to display adjacent to the annotation.\n+    label: Option<String>,\n+}\n+\n+#[derive(Debug)]\n+pub struct RenderedLine {\n+    pub text: Vec<StyledString>,\n+    pub kind: RenderedLineKind,\n+}\n+\n+#[derive(Debug)]\n+pub struct StyledString {\n+    pub text: String,\n+    pub style: Style,\n+}\n+\n+#[derive(Debug)]\n+pub struct StyledBuffer {\n+    text: Vec<Vec<char>>,\n+    styles: Vec<Vec<Style>>\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub enum Style {\n+    FileNameStyle,\n+    LineAndColumn,\n+    LineNumber,\n+    Quotation,\n+    UnderlinePrimary,\n+    UnderlineSecondary,\n+    LabelPrimary,\n+    LabelSecondary,\n+    NoStyle,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub enum RenderedLineKind {\n+    PrimaryFileName,\n+    OtherFileName,\n+    SourceText {\n+        file: Rc<FileMap>,\n+        line_index: usize,\n+    },\n+    Annotations,\n+    Elision,\n+}\n+\n+impl SnippetData {\n+    pub fn new(codemap: Rc<CodeMap>,\n+               primary_span: Option<Span>) // (*)\n+               -> Self {\n+        // (*) The primary span indicates the file that must appear\n+        // first, and which will have a line number etc in its\n+        // name. Outside of tests, this is always `Some`, but for many\n+        // tests it's not relevant to test this portion of the logic,\n+        // and it's tedious to pick a primary span (read: tedious to\n+        // port older tests that predate the existence of a primary\n+        // span).\n+\n+        debug!(\"SnippetData::new(primary_span={:?})\", primary_span);\n+\n+        let mut data = SnippetData {\n+            codemap: codemap.clone(),\n+            files: vec![]\n+        };\n+        if let Some(primary_span) = primary_span {\n+            let lo = codemap.lookup_char_pos(primary_span.lo);\n+            data.files.push(\n+                FileInfo {\n+                    file: lo.file,\n+                    primary_span: Some(primary_span),\n+                    lines: vec![],\n+                });\n+        }\n+        data\n+    }\n+\n+    pub fn push(&mut self, span: Span, is_primary: bool, label: Option<String>) {\n+        debug!(\"SnippetData::push(span={:?}, is_primary={}, label={:?})\",\n+               span, is_primary, label);\n+\n+        let file_lines = match self.codemap.span_to_lines(span) {\n+            Ok(file_lines) => file_lines,\n+            Err(_) => {\n+                // ignore unprintable spans completely.\n+                return;\n+            }\n+        };\n+\n+        self.file(&file_lines.file)\n+            .push_lines(&file_lines.lines, is_primary, label);\n+    }\n+\n+    fn file(&mut self, file_map: &Rc<FileMap>) -> &mut FileInfo {\n+        let index = self.files.iter().position(|f| f.file.name == file_map.name);\n+        if let Some(index) = index {\n+            return &mut self.files[index];\n+        }\n+\n+        self.files.push(\n+            FileInfo {\n+                file: file_map.clone(),\n+                lines: vec![],\n+                primary_span: None,\n+            });\n+        self.files.last_mut().unwrap()\n+    }\n+\n+    pub fn render_lines(&self) -> Vec<RenderedLine> {\n+        debug!(\"SnippetData::render_lines()\");\n+\n+        let mut rendered_lines: Vec<_> =\n+            self.files.iter()\n+                      .flat_map(|f| f.render_file_lines(&self.codemap))\n+                      .collect();\n+        prepend_prefixes(&mut rendered_lines);\n+        trim_lines(&mut rendered_lines);\n+        rendered_lines\n+    }\n+}\n+\n+pub trait StringSource {\n+    fn make_string(self) -> String;\n+}\n+\n+impl StringSource for String {\n+    fn make_string(self) -> String {\n+        self\n+    }\n+}\n+\n+impl StringSource for Vec<char> {\n+    fn make_string(self) -> String {\n+        self.into_iter().collect()\n+    }\n+}\n+\n+impl<S> From<(S, Style, RenderedLineKind)> for RenderedLine\n+    where S: StringSource\n+{\n+    fn from((text, style, kind): (S, Style, RenderedLineKind)) -> Self {\n+        RenderedLine {\n+            text: vec![StyledString {\n+                text: text.make_string(),\n+                style: style,\n+            }],\n+            kind: kind,\n+        }\n+    }\n+}\n+\n+impl<S1,S2> From<(S1, Style, S2, Style, RenderedLineKind)> for RenderedLine\n+    where S1: StringSource, S2: StringSource\n+{\n+    fn from(tuple: (S1, Style, S2, Style, RenderedLineKind)) -> Self {\n+        let (text1, style1, text2, style2, kind) = tuple;\n+        RenderedLine {\n+            text: vec![\n+                StyledString {\n+                    text: text1.make_string(),\n+                    style: style1,\n+                },\n+                StyledString {\n+                    text: text2.make_string(),\n+                    style: style2,\n+                }\n+            ],\n+            kind: kind,\n+        }\n+    }\n+}\n+\n+impl RenderedLine {\n+    fn trim_last(&mut self) {\n+        if let Some(last_text) = self.text.last_mut() {\n+            let len = last_text.text.trim_right().len();\n+            last_text.text.truncate(len);\n+        }\n+    }\n+}\n+\n+impl RenderedLineKind {\n+    fn prefix(&self) -> StyledString {\n+        match *self {\n+            RenderedLineKind::SourceText { file: _, line_index } =>\n+                StyledString {\n+                    text: format!(\"{}\", line_index + 1),\n+                    style: Style::LineNumber,\n+                },\n+            RenderedLineKind::Elision =>\n+                StyledString {\n+                    text: String::from(\"...\"),\n+                    style: Style::LineNumber,\n+                },\n+            RenderedLineKind::PrimaryFileName |\n+            RenderedLineKind::OtherFileName |\n+            RenderedLineKind::Annotations =>\n+                StyledString {\n+                    text: String::from(\"\"),\n+                    style: Style::LineNumber,\n+                },\n+        }\n+    }\n+}\n+\n+impl StyledBuffer {\n+    fn new() -> StyledBuffer {\n+        StyledBuffer { text: vec![], styles: vec![] }\n+    }\n+\n+    fn render(&self, source_kind: RenderedLineKind) -> Vec<RenderedLine> {\n+        let mut output: Vec<RenderedLine> = vec![];\n+        let mut styled_vec: Vec<StyledString> = vec![];\n+\n+        for (row, row_style) in self.text.iter().zip(&self.styles) {\n+            let mut current_style = Style::NoStyle;\n+            let mut current_text = String::new();\n+\n+            for (&c, &s) in row.iter().zip(row_style) {\n+                if s != current_style {\n+                    if !current_text.is_empty() {\n+                        styled_vec.push(StyledString { text: current_text, style: current_style });\n+                    }\n+                    current_style = s;\n+                    current_text = String::new();\n+                }\n+                current_text.push(c);\n+            }\n+            if !current_text.is_empty() {\n+                styled_vec.push(StyledString { text: current_text, style: current_style });\n+            }\n+\n+            if output.is_empty() {\n+                //We know our first output line is source and the rest are highlights and labels\n+                output.push(RenderedLine { text: styled_vec, kind: source_kind.clone() });\n+            } else {\n+                output.push(RenderedLine { text: styled_vec, kind: RenderedLineKind::Annotations });\n+            }\n+            styled_vec = vec![];\n+        }\n+\n+        output\n+    }\n+\n+    fn putc(&mut self, line: usize, col: usize, chr: char, style: Style) {\n+        while line >= self.text.len() {\n+            self.text.push(vec![]);\n+            self.styles.push(vec![]);\n+        }\n+\n+        if col < self.text[line].len() {\n+            self.text[line][col] = chr;\n+            self.styles[line][col] = style;\n+        } else {\n+            while self.text[line].len() < col {\n+                self.text[line].push(' ');\n+                self.styles[line].push(Style::NoStyle);\n+            }\n+            self.text[line].push(chr);\n+            self.styles[line].push(style);\n+        }\n+    }\n+\n+    fn puts(&mut self, line: usize, col: usize, string: &str, style: Style) {\n+        let mut n = col;\n+        for c in string.chars() {\n+            self.putc(line, n, c, style);\n+            n += 1;\n+        }\n+    }\n+\n+    fn set_style(&mut self, line: usize, col: usize, style: Style) {\n+        if self.styles.len() > line && self.styles[line].len() > col {\n+            self.styles[line][col] = style;\n+        }\n+    }\n+\n+    fn append(&mut self, line: usize, string: &str, style: Style) {\n+        if line >= self.text.len() {\n+            self.puts(line, 0, string, style);\n+        } else {\n+            let col = self.text[line].len();\n+            self.puts(line, col, string, style);\n+        }\n+    }\n+}\n+\n+impl FileInfo {\n+    fn push_lines(&mut self,\n+                  lines: &[LineInfo],\n+                  is_primary: bool,\n+                  label: Option<String>) {\n+        assert!(lines.len() > 0);\n+\n+        // If a span covers multiple lines, we reduce it to a single\n+        // point at the start of the span. This means that instead\n+        // of producing output like this:\n+        //\n+        // ```\n+        // --> foo.rs:2:1\n+        // 2   |> fn conflicting_items<'grammar>(state: &LR0State<'grammar>)\n+        //     |> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+        // 3   |>                               -> Set<LR0Item<'grammar>>\n+        //     |> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+        // (and so on)\n+        // ```\n+        //\n+        // we produce:\n+        //\n+        // ```\n+        // --> foo.rs:2:1\n+        // 2   |> fn conflicting_items<'grammar>(state: &LR0State<'grammar>)\n+        //        ^\n+        // ```\n+        //\n+        // Basically, although this loses information, multi-line spans just\n+        // never look good.\n+\n+        let (line, start_col, end_col) = if lines.len() == 1 {\n+            (lines[0].line_index, lines[0].start_col, lines[0].end_col)\n+        } else {\n+            (lines[0].line_index, lines[0].start_col, CharPos(lines[0].start_col.0 + 1))\n+        };\n+        let index = self.ensure_source_line(line);\n+        self.lines[index].push_annotation(start_col,\n+                                          end_col,\n+                                          is_primary,\n+                                          label);\n+    }\n+\n+    /// Ensure that we have a `Line` struct corresponding to\n+    /// `line_index` in the file. If we already have some other lines,\n+    /// then this will add the intervening lines to ensure that we\n+    /// have a complete snippet. (Note that when we finally display,\n+    /// some of those lines may be elided.)\n+    fn ensure_source_line(&mut self, line_index: usize) -> usize {\n+        if self.lines.is_empty() {\n+            self.lines.push(Line::new(line_index));\n+            return 0;\n+        }\n+\n+        // Find the range of lines we have thus far.\n+        let first_line_index = self.lines.first().unwrap().line_index;\n+        let last_line_index = self.lines.last().unwrap().line_index;\n+        assert!(first_line_index <= last_line_index);\n+\n+        // If the new line is lower than all the lines we have thus\n+        // far, then insert the new line and any intervening lines at\n+        // the front. In a silly attempt at micro-optimization, we\n+        // don't just call `insert` repeatedly, but instead make a new\n+        // (empty) vector, pushing the new lines onto it, and then\n+        // appending the old vector.\n+        if line_index < first_line_index {\n+            let lines = mem::replace(&mut self.lines, vec![]);\n+            self.lines.extend(\n+                (line_index .. first_line_index)\n+                    .map(|line| Line::new(line))\n+                    .chain(lines));\n+            return 0;\n+        }\n+\n+        // If the new line comes after the ones we have so far, insert\n+        // lines for it.\n+        if line_index > last_line_index {\n+            self.lines.extend(\n+                (last_line_index+1 .. line_index+1)\n+                    .map(|line| Line::new(line)));\n+            return self.lines.len() - 1;\n+        }\n+\n+        // Otherwise it should already exist.\n+        return line_index - first_line_index;\n+    }\n+\n+    fn render_file_lines(&self, codemap: &Rc<CodeMap>) -> Vec<RenderedLine> {\n+        let old_school = check_old_skool();\n+\n+        // As a first step, we elide any instance of more than one\n+        // continuous unannotated line.\n+\n+        let mut lines_iter = self.lines.iter();\n+        let mut output = vec![];\n+\n+        // First insert the name of the file.\n+        if !old_school {\n+            match self.primary_span {\n+                Some(span) => {\n+                    let lo = codemap.lookup_char_pos(span.lo);\n+                    output.push(RenderedLine {\n+                        text: vec![StyledString {\n+                            text: lo.file.name.clone(),\n+                            style: Style::FileNameStyle,\n+                        }, StyledString {\n+                            text: format!(\":{}:{}\", lo.line, lo.col.0 + 1),\n+                            style: Style::LineAndColumn,\n+                        }],\n+                        kind: RenderedLineKind::PrimaryFileName,\n+                    });\n+                }\n+                None => {\n+                    output.push(RenderedLine {\n+                        text: vec![StyledString {\n+                            text: self.file.name.clone(),\n+                            style: Style::FileNameStyle,\n+                        }],\n+                        kind: RenderedLineKind::OtherFileName,\n+                    });\n+                }\n+            }\n+        }\n+\n+        let mut next_line = lines_iter.next();\n+        while next_line.is_some() {\n+            // Consume lines with annotations.\n+            while let Some(line) = next_line {\n+                if line.annotations.is_empty() { break; }\n+\n+                let mut rendered_lines = self.render_line(line);\n+                assert!(!rendered_lines.is_empty());\n+                if old_school {\n+                    match self.primary_span {\n+                        Some(span) => {\n+                            let lo = codemap.lookup_char_pos(span.lo);\n+                            rendered_lines[0].text.insert(0, StyledString {\n+                                text: format!(\":{} \", lo.line),\n+                                style: Style::LineAndColumn,\n+                            });\n+                            rendered_lines[0].text.insert(0, StyledString {\n+                                text: lo.file.name.clone(),\n+                                style: Style::FileNameStyle,\n+                            });\n+                            let gap_amount =\n+                                rendered_lines[0].text[0].text.len() +\n+                                rendered_lines[0].text[1].text.len();\n+                            assert!(rendered_lines.len() >= 2,\n+                                    \"no annotations resulted from: {:?}\",\n+                                    line);\n+                            for i in 1..rendered_lines.len() {\n+                                rendered_lines[i].text.insert(0, StyledString {\n+                                    text: vec![\" \"; gap_amount].join(\"\"),\n+                                    style: Style::NoStyle\n+                                });\n+                            }\n+                        }\n+                        _ =>()\n+                    }\n+                }\n+                output.append(&mut rendered_lines);\n+                next_line = lines_iter.next();\n+            }\n+\n+            // Emit lines without annotations, but only if they are\n+            // followed by a line with an annotation.\n+            let unannotated_line = next_line;\n+            let mut unannotated_lines = 0;\n+            while let Some(line) = next_line {\n+                if !line.annotations.is_empty() { break; }\n+                unannotated_lines += 1;\n+                next_line = lines_iter.next();\n+            }\n+            if unannotated_lines > 1 {\n+                output.push(RenderedLine::from((String::new(),\n+                                                Style::NoStyle,\n+                                                RenderedLineKind::Elision)));\n+            } else if let Some(line) = unannotated_line {\n+                output.append(&mut self.render_line(line));\n+            }\n+        }\n+\n+        output\n+    }\n+\n+    fn render_line(&self, line: &Line) -> Vec<RenderedLine> {\n+        let old_school = check_old_skool();\n+        let source_string = self.file.get_line(line.line_index)\n+                                     .unwrap_or(\"\");\n+        let source_kind = RenderedLineKind::SourceText {\n+            file: self.file.clone(),\n+            line_index: line.line_index,\n+        };\n+\n+        let mut styled_buffer = StyledBuffer::new();\n+\n+        // First create the source line we will highlight.\n+        styled_buffer.append(0, &source_string, Style::Quotation);\n+\n+        if line.annotations.is_empty() {\n+            return styled_buffer.render(source_kind);\n+        }\n+\n+        // We want to display like this:\n+        //\n+        //      vec.push(vec.pop().unwrap());\n+        //      ---      ^^^               _ previous borrow ends here\n+        //      |        |\n+        //      |        error occurs here\n+        //      previous borrow of `vec` occurs here\n+        //\n+        // But there are some weird edge cases to be aware of:\n+        //\n+        //      vec.push(vec.pop().unwrap());\n+        //      --------                    - previous borrow ends here\n+        //      ||\n+        //      |this makes no sense\n+        //      previous borrow of `vec` occurs here\n+        //\n+        // For this reason, we group the lines into \"highlight lines\"\n+        // and \"annotations lines\", where the highlight lines have the `~`.\n+\n+        //let mut highlight_line = Self::whitespace(&source_string);\n+\n+        // Sort the annotations by (start, end col)\n+        let mut annotations = line.annotations.clone();\n+        annotations.sort();\n+\n+        // Next, create the highlight line.\n+        for annotation in &annotations {\n+            if old_school {\n+                for p in annotation.start_col .. annotation.end_col {\n+                    if p == annotation.start_col {\n+                        styled_buffer.putc(1, p, '^',\n+                            if annotation.is_primary {\n+                                Style::UnderlinePrimary\n+                            } else {\n+                                Style::UnderlineSecondary\n+                            });\n+                    }\n+                    else {\n+                        styled_buffer.putc(1, p, '~',\n+                            if annotation.is_primary {\n+                                Style::UnderlinePrimary\n+                            } else {\n+                                Style::UnderlineSecondary\n+                            });\n+                    }\n+                }\n+            }\n+            else {\n+                for p in annotation.start_col .. annotation.end_col {\n+                    if annotation.is_primary {\n+                        styled_buffer.putc(1, p, '^', Style::UnderlinePrimary);\n+                        styled_buffer.set_style(0, p, Style::UnderlinePrimary);\n+                    } else {\n+                        styled_buffer.putc(1, p, '-', Style::UnderlineSecondary);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Now we are going to write labels in. To start, we'll exclude\n+        // the annotations with no labels.\n+        let (labeled_annotations, unlabeled_annotations): (Vec<_>, _) =\n+            annotations.into_iter()\n+                       .partition(|a| a.label.is_some());\n+\n+        // If there are no annotations that need text, we're done.\n+        if labeled_annotations.is_empty() {\n+            return styled_buffer.render(source_kind);\n+        }\n+        if old_school {\n+            return styled_buffer.render(source_kind);\n+        }\n+\n+        // Now add the text labels. We try, when possible, to stick the rightmost\n+        // annotation at the end of the highlight line:\n+        //\n+        //      vec.push(vec.pop().unwrap());\n+        //      ---      ---               - previous borrow ends here\n+        //\n+        // But sometimes that's not possible because one of the other\n+        // annotations overlaps it. For example, from the test\n+        // `span_overlap_label`, we have the following annotations\n+        // (written on distinct lines for clarity):\n+        //\n+        //      fn foo(x: u32) {\n+        //      --------------\n+        //             -\n+        //\n+        // In this case, we can't stick the rightmost-most label on\n+        // the highlight line, or we would get:\n+        //\n+        //      fn foo(x: u32) {\n+        //      -------- x_span\n+        //      |\n+        //      fn_span\n+        //\n+        // which is totally weird. Instead we want:\n+        //\n+        //      fn foo(x: u32) {\n+        //      --------------\n+        //      |      |\n+        //      |      x_span\n+        //      fn_span\n+        //\n+        // which is...less weird, at least. In fact, in general, if\n+        // the rightmost span overlaps with any other span, we should\n+        // use the \"hang below\" version, so we can at least make it\n+        // clear where the span *starts*.\n+        let mut labeled_annotations = &labeled_annotations[..];\n+        match labeled_annotations.split_last().unwrap() {\n+            (last, previous) => {\n+                if previous.iter()\n+                           .chain(&unlabeled_annotations)\n+                           .all(|a| !overlaps(a, last))\n+                {\n+                    // append the label afterwards; we keep it in a separate\n+                    // string\n+                    let highlight_label: String = format!(\" {}\", last.label.as_ref().unwrap());\n+                    if last.is_primary {\n+                        styled_buffer.append(1, &highlight_label, Style::LabelPrimary);\n+                    } else {\n+                        styled_buffer.append(1, &highlight_label, Style::LabelSecondary);\n+                    }\n+                    labeled_annotations = previous;\n+                }\n+            }\n+        }\n+\n+        // If that's the last annotation, we're done\n+        if labeled_annotations.is_empty() {\n+            return styled_buffer.render(source_kind);\n+        }\n+\n+        for (index, annotation) in labeled_annotations.iter().enumerate() {\n+            // Leave:\n+            // - 1 extra line\n+            // - One line for each thing that comes after\n+            let comes_after = labeled_annotations.len() - index - 1;\n+            let blank_lines = 3 + comes_after;\n+\n+            // For each blank line, draw a `|` at our column. The\n+            // text ought to be long enough for this.\n+            for index in 2..blank_lines {\n+                if annotation.is_primary {\n+                    styled_buffer.putc(index, annotation.start_col, '|', Style::UnderlinePrimary);\n+                } else {\n+                    styled_buffer.putc(index, annotation.start_col, '|', Style::UnderlineSecondary);\n+                }\n+            }\n+\n+            if annotation.is_primary {\n+                styled_buffer.puts(blank_lines, annotation.start_col,\n+                    annotation.label.as_ref().unwrap(), Style::LabelPrimary);\n+            } else {\n+                styled_buffer.puts(blank_lines, annotation.start_col,\n+                    annotation.label.as_ref().unwrap(), Style::LabelSecondary);\n+            }\n+        }\n+\n+        styled_buffer.render(source_kind)\n+    }\n+}\n+\n+fn prepend_prefixes(rendered_lines: &mut [RenderedLine]) {\n+    let old_school = check_old_skool();\n+    if old_school {\n+        return;\n+    }\n+\n+    let prefixes: Vec<_> =\n+        rendered_lines.iter()\n+                      .map(|rl| rl.kind.prefix())\n+                      .collect();\n+\n+    // find the max amount of spacing we need; add 1 to\n+    // p.text.len() to leave space between the prefix and the\n+    // source text\n+    let padding_len =\n+        prefixes.iter()\n+                .map(|p| if p.text.len() == 0 { 0 } else { p.text.len() + 1 })\n+                .max()\n+                .unwrap_or(0);\n+\n+    // Ensure we insert at least one character of padding, so that the\n+    // `-->` arrows can fit etc.\n+    let padding_len = cmp::max(padding_len, 1);\n+\n+    for (mut prefix, line) in prefixes.into_iter().zip(rendered_lines) {\n+        let extra_spaces = (prefix.text.len() .. padding_len).map(|_| ' ');\n+        prefix.text.extend(extra_spaces);\n+        match line.kind {\n+            RenderedLineKind::Elision => {\n+                line.text.insert(0, prefix);\n+            }\n+            RenderedLineKind::PrimaryFileName => {\n+                //   --> filename\n+                // 22 |>\n+                //   ^\n+                //   padding_len\n+                let dashes = (0..padding_len - 1).map(|_| ' ')\n+                                                 .chain(Some('-'))\n+                                                 .chain(Some('-'))\n+                                                 .chain(Some('>'))\n+                                                 .chain(Some(' '));\n+                line.text.insert(0, StyledString {text: dashes.collect(),\n+                                                  style: Style::LineNumber})\n+            }\n+            RenderedLineKind::OtherFileName => {\n+                //   ::: filename\n+                // 22 |>\n+                //   ^\n+                //   padding_len\n+                let dashes = (0..padding_len - 1).map(|_| ' ')\n+                                                 .chain(Some(':'))\n+                                                 .chain(Some(':'))\n+                                                 .chain(Some(':'))\n+                                                 .chain(Some(' '));\n+                line.text.insert(0, StyledString {text: dashes.collect(),\n+                                                  style: Style::LineNumber})\n+            }\n+            _ => {\n+                line.text.insert(0, prefix);\n+                line.text.insert(1, StyledString {text: String::from(\"|> \"),\n+                                                  style: Style::LineNumber})\n+            }\n+        }\n+    }\n+}\n+\n+fn trim_lines(rendered_lines: &mut [RenderedLine]) {\n+    for line in rendered_lines {\n+        while !line.text.is_empty() {\n+            line.trim_last();\n+            if line.text.last().unwrap().text.is_empty() {\n+                line.text.pop();\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+}\n+\n+impl Line {\n+    fn new(line_index: usize) -> Line {\n+        Line {\n+            line_index: line_index,\n+            annotations: vec![]\n+        }\n+    }\n+\n+    fn push_annotation(&mut self,\n+                       start: CharPos,\n+                       end: CharPos,\n+                       is_primary: bool,\n+                       label: Option<String>) {\n+        self.annotations.push(Annotation {\n+            start_col: start.0,\n+            end_col: end.0,\n+            is_primary: is_primary,\n+            label: label,\n+        });\n+    }\n+}\n+\n+fn overlaps(a1: &Annotation,\n+            a2: &Annotation)\n+            -> bool\n+{\n+    (a2.start_col .. a2.end_col).contains(a1.start_col) ||\n+        (a1.start_col .. a1.end_col).contains(a2.start_col)\n+}"}, {"sha": "569d11199190c42ea28db9ac891b8bacbb5b65ef", "filename": "src/libsyntax/errors/snippet/test.rs", "status": "added", "additions": 521, "deletions": 0, "changes": 521, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Ferrors%2Fsnippet%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Ferrors%2Fsnippet%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fsnippet%2Ftest.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -0,0 +1,521 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Code for testing annotated snippets.\n+\n+#![cfg(test)]\n+\n+use codemap::{BytePos, CodeMap, FileMap, NO_EXPANSION, Span};\n+use std::rc::Rc;\n+use super::{RenderedLine, SnippetData};\n+\n+/// Returns the span corresponding to the `n`th occurrence of\n+/// `substring` in `source_text`.\n+trait CodeMapExtension {\n+    fn span_substr(&self,\n+                   file: &Rc<FileMap>,\n+                   source_text: &str,\n+                   substring: &str,\n+                   n: usize)\n+                   -> Span;\n+}\n+\n+impl CodeMapExtension for CodeMap {\n+    fn span_substr(&self,\n+                   file: &Rc<FileMap>,\n+                   source_text: &str,\n+                   substring: &str,\n+                   n: usize)\n+                   -> Span\n+    {\n+        println!(\"span_substr(file={:?}/{:?}, substring={:?}, n={})\",\n+                 file.name, file.start_pos, substring, n);\n+        let mut i = 0;\n+        let mut hi = 0;\n+        loop {\n+            let offset = source_text[hi..].find(substring).unwrap_or_else(|| {\n+                panic!(\"source_text `{}` does not have {} occurrences of `{}`, only {}\",\n+                       source_text, n, substring, i);\n+            });\n+            let lo = hi + offset;\n+            hi = lo + substring.len();\n+            if i == n {\n+                let span = Span {\n+                    lo: BytePos(lo as u32 + file.start_pos.0),\n+                    hi: BytePos(hi as u32 + file.start_pos.0),\n+                    expn_id: NO_EXPANSION,\n+                };\n+                assert_eq!(&self.span_to_snippet(span).unwrap()[..],\n+                           substring);\n+                return span;\n+            }\n+            i += 1;\n+        }\n+    }\n+}\n+\n+fn splice(start: Span, end: Span) -> Span {\n+    Span {\n+        lo: start.lo,\n+        hi: end.hi,\n+        expn_id: NO_EXPANSION,\n+    }\n+}\n+\n+fn make_string(lines: &[RenderedLine]) -> String {\n+    lines.iter()\n+         .flat_map(|rl| {\n+             rl.text.iter()\n+                    .map(|s| &s.text[..])\n+                    .chain(Some(\"\\n\"))\n+         })\n+         .collect()\n+}\n+\n+#[test]\n+fn one_line() {\n+    let file_text = r#\"\n+fn foo() {\n+    vec.push(vec.pop().unwrap());\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+    let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 0);\n+    let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 1);\n+    let span_semi = cm.span_substr(&foo, file_text, \";\", 0);\n+\n+    let mut snippet = SnippetData::new(cm, None);\n+    snippet.push(span_vec0, false, Some(format!(\"previous borrow of `vec` occurs here\")));\n+    snippet.push(span_vec1, false, Some(format!(\"error occurs here\")));\n+    snippet.push(span_semi, false, Some(format!(\"previous borrow ends here\")));\n+\n+    let lines = snippet.render_lines();\n+    println!(\"{:#?}\", lines);\n+\n+    let text: String = make_string(&lines);\n+\n+    println!(\"text=\\n{}\", text);\n+    assert_eq!(&text[..], &r#\"\n+ ::: foo.rs\n+3 |>     vec.push(vec.pop().unwrap());\n+  |>     ---      ---                - previous borrow ends here\n+  |>     |        |\n+  |>     |        error occurs here\n+  |>     previous borrow of `vec` occurs here\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn two_files() {\n+    let file_text_foo = r#\"\n+fn foo() {\n+    vec.push(vec.pop().unwrap());\n+}\n+\"#;\n+\n+    let file_text_bar = r#\"\n+fn bar() {\n+    // these blank links here\n+    // serve to ensure that the line numbers\n+    // from bar.rs\n+    // require more digits\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    vec.push();\n+\n+    // this line will get elided\n+\n+    vec.pop().unwrap());\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo_map = cm.new_filemap_and_lines(\"foo.rs\", file_text_foo);\n+    let span_foo_vec0 = cm.span_substr(&foo_map, file_text_foo, \"vec\", 0);\n+    let span_foo_vec1 = cm.span_substr(&foo_map, file_text_foo, \"vec\", 1);\n+    let span_foo_semi = cm.span_substr(&foo_map, file_text_foo, \";\", 0);\n+\n+    let bar_map = cm.new_filemap_and_lines(\"bar.rs\", file_text_bar);\n+    let span_bar_vec0 = cm.span_substr(&bar_map, file_text_bar, \"vec\", 0);\n+    let span_bar_vec1 = cm.span_substr(&bar_map, file_text_bar, \"vec\", 1);\n+    let span_bar_semi = cm.span_substr(&bar_map, file_text_bar, \";\", 0);\n+\n+    let mut snippet = SnippetData::new(cm, Some(span_foo_vec1));\n+    snippet.push(span_foo_vec0, false, Some(format!(\"a\")));\n+    snippet.push(span_foo_vec1, true, Some(format!(\"b\")));\n+    snippet.push(span_foo_semi, false, Some(format!(\"c\")));\n+    snippet.push(span_bar_vec0, false, Some(format!(\"d\")));\n+    snippet.push(span_bar_vec1, false, Some(format!(\"e\")));\n+    snippet.push(span_bar_semi, false, Some(format!(\"f\")));\n+\n+    let lines = snippet.render_lines();\n+    println!(\"{:#?}\", lines);\n+\n+    let text: String = make_string(&lines);\n+\n+    println!(\"text=\\n{}\", text);\n+\n+    // Note that the `|>` remain aligned across both files:\n+    assert_eq!(&text[..], &r#\"\n+   --> foo.rs:3:14\n+3   |>     vec.push(vec.pop().unwrap());\n+    |>     ---      ^^^                - c\n+    |>     |        |\n+    |>     |        b\n+    |>     a\n+   ::: bar.rs\n+17  |>     vec.push();\n+    |>     ---       - f\n+    |>     |\n+    |>     d\n+...\n+21  |>     vec.pop().unwrap());\n+    |>     --- e\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn multi_line() {\n+    let file_text = r#\"\n+fn foo() {\n+    let name = find_id(&data, 22).unwrap();\n+\n+    // Add one more item we forgot to the vector. Silly us.\n+    data.push(Data { name: format!(\"Hera\"), id: 66 });\n+\n+    // Print everything out.\n+    println!(\"Name: {:?}\", name);\n+    println!(\"Data: {:?}\", data);\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+    let span_data0 = cm.span_substr(&foo, file_text, \"data\", 0);\n+    let span_data1 = cm.span_substr(&foo, file_text, \"data\", 1);\n+    let span_rbrace = cm.span_substr(&foo, file_text, \"}\", 3);\n+\n+    let mut snippet = SnippetData::new(cm, None);\n+    snippet.push(span_data0, false, Some(format!(\"immutable borrow begins here\")));\n+    snippet.push(span_data1, false, Some(format!(\"mutable borrow occurs here\")));\n+    snippet.push(span_rbrace, false, Some(format!(\"immutable borrow ends here\")));\n+\n+    let lines = snippet.render_lines();\n+    println!(\"{:#?}\", lines);\n+\n+    let text: String = make_string(&lines);\n+\n+    println!(\"text=\\n{}\", text);\n+    assert_eq!(&text[..], &r#\"\n+   ::: foo.rs\n+3   |>     let name = find_id(&data, 22).unwrap();\n+    |>                         ---- immutable borrow begins here\n+...\n+6   |>     data.push(Data { name: format!(\"Hera\"), id: 66 });\n+    |>     ---- mutable borrow occurs here\n+...\n+11  |> }\n+    |> - immutable borrow ends here\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn overlapping() {\n+    let file_text = r#\"\n+fn foo() {\n+    vec.push(vec.pop().unwrap());\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+    let span0 = cm.span_substr(&foo, file_text, \"vec.push\", 0);\n+    let span1 = cm.span_substr(&foo, file_text, \"vec\", 0);\n+    let span2 = cm.span_substr(&foo, file_text, \"ec.push\", 0);\n+    let span3 = cm.span_substr(&foo, file_text, \"unwrap\", 0);\n+\n+    let mut snippet = SnippetData::new(cm, None);\n+    snippet.push(span0, false, Some(format!(\"A\")));\n+    snippet.push(span1, false, Some(format!(\"B\")));\n+    snippet.push(span2, false, Some(format!(\"C\")));\n+    snippet.push(span3, false, Some(format!(\"D\")));\n+\n+    let lines = snippet.render_lines();\n+    println!(\"{:#?}\", lines);\n+    let text: String = make_string(&lines);\n+\n+    println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n+    assert_eq!(&text[..], &r#\"\n+ ::: foo.rs\n+3 |>     vec.push(vec.pop().unwrap());\n+  |>     --------           ------ D\n+  |>     ||\n+  |>     |C\n+  |>     A\n+  |>     B\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn one_line_out_of_order() {\n+    let file_text = r#\"\n+fn foo() {\n+    vec.push(vec.pop().unwrap());\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+    let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 0);\n+    let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 1);\n+    let span_semi = cm.span_substr(&foo, file_text, \";\", 0);\n+\n+    // intentionally don't push the snippets left to right\n+    let mut snippet = SnippetData::new(cm, None);\n+    snippet.push(span_vec1, false, Some(format!(\"error occurs here\")));\n+    snippet.push(span_vec0, false, Some(format!(\"previous borrow of `vec` occurs here\")));\n+    snippet.push(span_semi, false, Some(format!(\"previous borrow ends here\")));\n+\n+    let lines = snippet.render_lines();\n+    println!(\"{:#?}\", lines);\n+    let text: String = make_string(&lines);\n+\n+    println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n+    assert_eq!(&text[..], &r#\"\n+ ::: foo.rs\n+3 |>     vec.push(vec.pop().unwrap());\n+  |>     ---      ---                - previous borrow ends here\n+  |>     |        |\n+  |>     |        error occurs here\n+  |>     previous borrow of `vec` occurs here\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn elide_unnecessary_lines() {\n+    let file_text = r#\"\n+fn foo() {\n+    let mut vec = vec![0, 1, 2];\n+    let mut vec2 = vec;\n+    vec2.push(3);\n+    vec2.push(4);\n+    vec2.push(5);\n+    vec2.push(6);\n+    vec.push(7);\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+    let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 3);\n+    let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 8);\n+\n+    let mut snippet = SnippetData::new(cm, None);\n+    snippet.push(span_vec0, false, Some(format!(\"`vec` moved here because it \\\n+        has type `collections::vec::Vec<i32>`\")));\n+    snippet.push(span_vec1, false, Some(format!(\"use of moved value: `vec`\")));\n+\n+    let lines = snippet.render_lines();\n+    println!(\"{:#?}\", lines);\n+    let text: String = make_string(&lines);\n+    println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n+    assert_eq!(&text[..], &r#\"\n+   ::: foo.rs\n+4   |>     let mut vec2 = vec;\n+    |>                    --- `vec` moved here because it has type `collections::vec::Vec<i32>`\n+...\n+9   |>     vec.push(7);\n+    |>     --- use of moved value: `vec`\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn spans_without_labels() {\n+    let file_text = r#\"\n+fn foo() {\n+    let mut vec = vec![0, 1, 2];\n+    let mut vec2 = vec;\n+    vec2.push(3);\n+    vec2.push(4);\n+    vec2.push(5);\n+    vec2.push(6);\n+    vec.push(7);\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+\n+    let mut snippet = SnippetData::new(cm.clone(), None);\n+    for i in 0..4 {\n+        let span_veci = cm.span_substr(&foo, file_text, \"vec\", i);\n+        snippet.push(span_veci, false, None);\n+    }\n+\n+    let lines = snippet.render_lines();\n+    let text: String = make_string(&lines);\n+    println!(\"text=&r#\\\"\\n{}\\n\\\"#[1..]\", text);\n+    assert_eq!(text, &r#\"\n+ ::: foo.rs\n+3 |>     let mut vec = vec![0, 1, 2];\n+  |>             ---   ---\n+4 |>     let mut vec2 = vec;\n+  |>             ---    ---\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn span_long_selection() {\n+    let file_text = r#\"\n+impl SomeTrait for () {\n+    fn foo(x: u32) {\n+        // impl 1\n+        // impl 2\n+        // impl 3\n+    }\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+\n+    let mut snippet = SnippetData::new(cm.clone(), None);\n+    let fn_span = cm.span_substr(&foo, file_text, \"fn\", 0);\n+    let rbrace_span = cm.span_substr(&foo, file_text, \"}\", 0);\n+    snippet.push(splice(fn_span, rbrace_span), false, None);\n+    let lines = snippet.render_lines();\n+    let text: String = make_string(&lines);\n+    println!(\"r#\\\"\\n{}\\\"\", text);\n+    assert_eq!(text, &r#\"\n+ ::: foo.rs\n+3 |>     fn foo(x: u32) {\n+  |>     -\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn span_overlap_label() {\n+    // Test that we don't put `x_span` to the right of its highlight,\n+    // since there is another highlight that overlaps it.\n+\n+    let file_text = r#\"\n+    fn foo(x: u32) {\n+    }\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+\n+    let mut snippet = SnippetData::new(cm.clone(), None);\n+    let fn_span = cm.span_substr(&foo, file_text, \"fn foo(x: u32)\", 0);\n+    let x_span = cm.span_substr(&foo, file_text, \"x\", 0);\n+    snippet.push(fn_span, false, Some(format!(\"fn_span\")));\n+    snippet.push(x_span, false, Some(format!(\"x_span\")));\n+    let lines = snippet.render_lines();\n+    let text: String = make_string(&lines);\n+    println!(\"r#\\\"\\n{}\\\"\", text);\n+    assert_eq!(text, &r#\"\n+ ::: foo.rs\n+2 |>     fn foo(x: u32) {\n+  |>     --------------\n+  |>     |      |\n+  |>     |      x_span\n+  |>     fn_span\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn span_overlap_label2() {\n+    // Test that we don't put `x_span` to the right of its highlight,\n+    // since there is another highlight that overlaps it. In this\n+    // case, the overlap is only at the beginning, but it's still\n+    // better to show the beginning more clearly.\n+\n+    let file_text = r#\"\n+    fn foo(x: u32) {\n+    }\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+\n+    let mut snippet = SnippetData::new(cm.clone(), None);\n+    let fn_span = cm.span_substr(&foo, file_text, \"fn foo(x\", 0);\n+    let x_span = cm.span_substr(&foo, file_text, \"x: u32)\", 0);\n+    snippet.push(fn_span, false, Some(format!(\"fn_span\")));\n+    snippet.push(x_span, false, Some(format!(\"x_span\")));\n+    let lines = snippet.render_lines();\n+    let text: String = make_string(&lines);\n+    println!(\"r#\\\"\\n{}\\\"\", text);\n+    assert_eq!(text, &r#\"\n+ ::: foo.rs\n+2 |>     fn foo(x: u32) {\n+  |>     --------------\n+  |>     |      |\n+  |>     |      x_span\n+  |>     fn_span\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn span_overlap_label3() {\n+    // Test that we don't put `x_span` to the right of its highlight,\n+    // since there is another highlight that overlaps it. In this\n+    // case, the overlap is only at the beginning, but it's still\n+    // better to show the beginning more clearly.\n+\n+    let file_text = r#\"\n+    fn foo() {\n+       let closure = || {\n+           inner\n+       };\n+    }\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+\n+    let mut snippet = SnippetData::new(cm.clone(), None);\n+\n+    let closure_span = {\n+        let closure_start_span = cm.span_substr(&foo, file_text, \"||\", 0);\n+        let closure_end_span = cm.span_substr(&foo, file_text, \"}\", 0);\n+        splice(closure_start_span, closure_end_span)\n+    };\n+\n+    let inner_span = cm.span_substr(&foo, file_text, \"inner\", 0);\n+\n+    snippet.push(closure_span, false, Some(format!(\"foo\")));\n+    snippet.push(inner_span, false, Some(format!(\"bar\")));\n+\n+    let lines = snippet.render_lines();\n+    let text: String = make_string(&lines);\n+    println!(\"r#\\\"\\n{}\\\"\", text);\n+    assert_eq!(text, &r#\"\n+ ::: foo.rs\n+3 |>        let closure = || {\n+  |>                      - foo\n+4 |>            inner\n+  |>            ----- bar\n+\"#[1..]);\n+}"}, {"sha": "303187aeba87dda35452dd5491d01e4abf334c4c", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -764,15 +764,14 @@ impl<'a> ExtCtxt<'a> {\n \n     pub fn suggest_macro_name(&mut self,\n                               name: &str,\n-                              span: Span,\n                               err: &mut DiagnosticBuilder<'a>) {\n         let names = &self.syntax_env.names;\n         if let Some(suggestion) = find_best_match_for_name(names.iter(), name, None) {\n             if suggestion != name {\n-                err.fileline_help(span, &format!(\"did you mean `{}!`?\", suggestion));\n+                err.help(&format!(\"did you mean `{}!`?\", suggestion));\n             } else {\n-                err.fileline_help(span, &format!(\"have you added the `#[macro_use]` on the \\\n-                                                  module/import?\"));\n+                err.help(&format!(\"have you added the `#[macro_use]` on the \\\n+                                   module/import?\"));\n             }\n         }\n     }"}, {"sha": "65df379781ecd4047eb4e7e29a38b0d6fc16b8a8", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -222,7 +222,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac,\n                 pth.span,\n                 &format!(\"macro undefined: '{}!'\",\n                         &extname));\n-            fld.cx.suggest_macro_name(&extname.as_str(), pth.span, &mut err);\n+            fld.cx.suggest_macro_name(&extname.as_str(), &mut err);\n             err.emit();\n \n             // let compilation continue\n@@ -355,8 +355,8 @@ fn contains_macro_use(fld: &mut MacroExpander, attrs: &[ast::Attribute]) -> bool\n                                         \"macro_escape is a deprecated synonym for macro_use\");\n             is_use = true;\n             if let ast::AttrStyle::Inner = attr.node.style {\n-                err.fileline_help(attr.span, \"consider an outer attribute, \\\n-                                              #[macro_use] mod ...\").emit();\n+                err.help(\"consider an outer attribute, \\\n+                          #[macro_use] mod ...\").emit();\n             } else {\n                 err.emit();\n             }"}, {"sha": "e269475d1e2c53688b0709fee8a9c3cb967bfb80", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -770,9 +770,9 @@ pub fn emit_feature_err(diag: &Handler, feature: &str, span: Span, issue: GateIs\n         err.emit();\n         return;\n     }\n-    err.fileline_help(span, &format!(\"add #![feature({})] to the \\\n-                                      crate attributes to enable\",\n-                                     feature));\n+    err.help(&format!(\"add #![feature({})] to the \\\n+                       crate attributes to enable\",\n+                      feature));\n     err.emit();\n }\n "}, {"sha": "420a41e03b9142c06b2382f0c3e1707026b817b4", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -33,6 +33,7 @@\n #![feature(str_escape)]\n #![feature(unicode)]\n #![feature(question_mark)]\n+#![feature(range_contains)]\n \n extern crate serialize;\n extern crate term;"}, {"sha": "3aac12d76ffdf46fa7958dc46c5e94cc082a1fd2", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -69,9 +69,8 @@ impl<'a> Parser<'a> {\n                         self.diagnostic()\n                             .struct_span_err(span,\n                                              \"an inner attribute is not permitted in this context\")\n-                            .fileline_help(span,\n-                                           \"place inner attribute at the top of the module or \\\n-                                            block\")\n+                            .help(\"place inner attribute at the top of the module or \\\n+                                   block\")\n                             .emit()\n                     }\n                     ast::AttrStyle::Inner"}, {"sha": "2a9bcfd658c18a8925e1c6b1308602968549e7fe", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -445,11 +445,11 @@ fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n             if suf.len() >= 2 && looks_like_width_suffix(&['f'], suf) {\n                 // if it looks like a width, lets try to be helpful.\n                 sd.struct_span_err(sp, &format!(\"invalid width `{}` for float literal\", &suf[1..]))\n-                 .fileline_help(sp, \"valid widths are 32 and 64\")\n+                 .help(\"valid widths are 32 and 64\")\n                  .emit();\n             } else {\n                 sd.struct_span_err(sp, &format!(\"invalid suffix `{}` for float literal\", suf))\n-                  .fileline_help(sp, \"valid suffixes are `f32` and `f64`\")\n+                  .help(\"valid suffixes are `f32` and `f64`\")\n                   .emit();\n             }\n \n@@ -621,12 +621,12 @@ pub fn integer_lit(s: &str,\n                 if looks_like_width_suffix(&['i', 'u'], suf) {\n                     sd.struct_span_err(sp, &format!(\"invalid width `{}` for integer literal\",\n                                              &suf[1..]))\n-                      .fileline_help(sp, \"valid widths are 8, 16, 32 and 64\")\n+                      .help(\"valid widths are 8, 16, 32 and 64\")\n                       .emit();\n                 } else {\n                     sd.struct_span_err(sp, &format!(\"invalid suffix `{}` for numeric literal\", suf))\n-                      .fileline_help(sp, \"the suffix must be one of the integral types \\\n-                                      (`u32`, `isize`, etc)\")\n+                      .help(\"the suffix must be one of the integral types \\\n+                             (`u32`, `isize`, etc)\")\n                       .emit();\n                 }\n "}, {"sha": "b9188f5101d3fd71502b0a76c4cd9f3632c0d640", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -583,7 +583,7 @@ impl<'a> Parser<'a> {\n                 let mut err = self.fatal(&format!(\"expected identifier, found `{}`\",\n                                                   self.this_token_to_string()));\n                 if self.token == token::Underscore {\n-                    err.fileline_note(self.span, \"`_` is a wildcard pattern, not an identifier\");\n+                    err.note(\"`_` is a wildcard pattern, not an identifier\");\n                 }\n                 Err(err)\n             }\n@@ -1082,7 +1082,7 @@ impl<'a> Parser<'a> {\n     }\n     pub fn span_fatal_help(&self, sp: Span, m: &str, help: &str) -> DiagnosticBuilder<'a> {\n         let mut err = self.sess.span_diagnostic.struct_span_fatal(sp, m);\n-        err.fileline_help(sp, help);\n+        err.help(help);\n         err\n     }\n     pub fn bug(&self, m: &str) -> ! {\n@@ -2622,10 +2622,9 @@ impl<'a> Parser<'a> {\n                             Some(f) => f,\n                             None => continue,\n                         };\n-                        err.fileline_help(last_span,\n-                            &format!(\"try parenthesizing the first index; e.g., `(foo.{}){}`\",\n-                                    float.trunc() as usize,\n-                                    format!(\".{}\", fstr.splitn(2, \".\").last().unwrap())));\n+                        err.help(&format!(\"try parenthesizing the first index; e.g., `(foo.{}){}`\",\n+                                 float.trunc() as usize,\n+                                 format!(\".{}\", fstr.splitn(2, \".\").last().unwrap())));\n                     }\n                     return Err(err);\n \n@@ -3134,7 +3133,7 @@ impl<'a> Parser<'a> {\n                 let mut err = self.diagnostic().struct_span_err(op_span,\n                     \"chained comparison operators require parentheses\");\n                 if op.node == BinOpKind::Lt && *outer_op == AssocOp::Greater {\n-                    err.fileline_help(op_span,\n+                    err.help(\n                         \"use `::<...>` instead of `<...>` if you meant to specify type arguments\");\n                 }\n                 err.emit();\n@@ -4951,13 +4950,13 @@ impl<'a> Parser<'a> {\n                 if is_macro_rules {\n                     self.diagnostic().struct_span_err(span, \"can't qualify macro_rules \\\n                                                              invocation with `pub`\")\n-                                     .fileline_help(span, \"did you mean #[macro_export]?\")\n+                                     .help(\"did you mean #[macro_export]?\")\n                                      .emit();\n                 } else {\n                     self.diagnostic().struct_span_err(span, \"can't qualify macro \\\n                                                              invocation with `pub`\")\n-                                     .fileline_help(span, \"try adjusting the macro to put `pub` \\\n-                                                           inside the invocation\")\n+                                     .help(\"try adjusting the macro to put `pub` \\\n+                                            inside the invocation\")\n                                      .emit();\n                 }\n             }\n@@ -5857,7 +5856,7 @@ impl<'a> Parser<'a> {\n             if self.eat_keyword(keywords::Mut) {\n                 let last_span = self.last_span;\n                 self.diagnostic().struct_span_err(last_span, \"const globals cannot be mutable\")\n-                                 .fileline_help(last_span, \"did you mean to declare a static?\")\n+                                 .help(\"did you mean to declare a static?\")\n                                  .emit();\n             }\n             let (ident, item_, extra_attrs) = self.parse_item_const(None)?;"}, {"sha": "91c272c59c4a68ecbc40bba92e6ebc747a17ad10", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -204,9 +204,9 @@ macro_rules! derive_traits {\n                                         sp, feature_gate::EXPLAIN_DERIVE_UNDERSCORE,\n                                     );\n                                     if option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_none() {\n-                                        w.fileline_help(\n-                                            sp, &format!(\"add #![feature(custom_derive)] to \\\n-                                                          the crate attributes to enable\")\n+                                        w.help(\n+                                            &format!(\"add #![feature(custom_derive)] to \\\n+                                                      the crate attributes to enable\")\n                                         );\n                                     }\n                                     w.emit();"}, {"sha": "1bbccae53a44d6f755804790fe9d8b787025028f", "filename": "src/test/compile-fail/array-not-vector.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Farray-not-vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Farray-not-vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farray-not-vector.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -11,16 +11,14 @@\n fn main() {\n     let _x: i32 = [1, 2, 3];\n     //~^ ERROR mismatched types\n-    //~| expected `i32`\n-    //~| found `[_; 3]`\n-    //~| expected i32\n-    //~| found array of 3 elements\n+    //~| expected type `i32`\n+    //~| found type `[_; 3]`\n+    //~| expected i32, found array of 3 elements\n \n     let x: &[i32] = &[1, 2, 3];\n     let _y: &i32 = x;\n     //~^ ERROR mismatched types\n-    //~| expected `&i32`\n-    //~| found `&[i32]`\n-    //~| expected i32\n-    //~| found slice\n+    //~| expected type `&i32`\n+    //~| found type `&[i32]`\n+    //~| expected i32, found slice\n }"}, {"sha": "8c66160e8a36f723c0a16c017d2956a83814f8fe", "filename": "src/test/compile-fail/associated-types-eq-3.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-3.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -32,10 +32,9 @@ fn foo1<I: Foo<A=Bar>>(x: I) {\n fn foo2<I: Foo>(x: I) {\n     let _: Bar = x.boo();\n     //~^ ERROR mismatched types\n-    //~| expected `Bar`\n-    //~| found `<I as Foo>::A`\n-    //~| expected struct `Bar`\n-    //~| found associated type\n+    //~| expected type `Bar`\n+    //~| found type `<I as Foo>::A`\n+    //~| expected struct `Bar`, found associated type\n }\n \n "}, {"sha": "cdb7dff692c146dd6fb762c4c1cdcba8b970946b", "filename": "src/test/compile-fail/associated-types-path-2.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -28,8 +28,7 @@ pub fn f2<T: Foo>(a: T) -> T::A {\n pub fn f1_int_int() {\n     f1(2i32, 4i32);\n     //~^ ERROR mismatched types\n-    //~| expected `u32`\n-    //~| found `i32`\n+    //~| expected u32, found i32\n }\n \n pub fn f1_int_uint() {\n@@ -49,8 +48,7 @@ pub fn f1_uint_int() {\n pub fn f2_int() {\n     let _: i32 = f2(2i32);\n     //~^ ERROR mismatched types\n-    //~| expected `i32`\n-    //~| found `u32`\n+    //~| expected i32, found u32\n }\n \n pub fn main() { }"}, {"sha": "8ac6b419295ee851fb838b30801c06f3d4b0b4db", "filename": "src/test/compile-fail/augmented-assignments.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Faugmented-assignments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Faugmented-assignments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Faugmented-assignments.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -21,8 +21,10 @@ impl AddAssign for Int {\n fn main() {\n     let mut x = Int(1);\n     x   //~ error: use of moved value: `x`\n+    //~^ value used here after move\n+    //~| note: move occurs because `x` has type `Int`\n     +=\n-    x;  //~ note: `x` moved here because it has type `Int`, which is non-copyable\n+    x;  //~ value moved here\n \n     let y = Int(2);\n     y   //~ error: cannot borrow immutable local variable `y` as mutable"}, {"sha": "ee6ac33072792a722202d7a1b82f7bbbcad19f6b", "filename": "src/test/compile-fail/bad-const-type.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fbad-const-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fbad-const-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-const-type.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -10,8 +10,7 @@\n \n static i: String = 10;\n //~^ ERROR mismatched types\n-//~| expected `std::string::String`\n-//~| found `_`\n-//~| expected struct `std::string::String`\n-//~| found integral variable\n+//~| expected type `std::string::String`\n+//~| found type `_`\n+//~| expected struct `std::string::String`, found integral variable\n fn main() { println!(\"{}\", i); }"}, {"sha": "1253f7569e7e8e48ec2f9e315838d05b5c6940fa", "filename": "src/test/compile-fail/bad-main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fbad-main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fbad-main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-main.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn main(x: isize) { } //~ ERROR: main function expects type\n+fn main(x: isize) { } //~ ERROR: main function has wrong type"}, {"sha": "0cc6ea3e984d95c9f2c4e365608b0917c9ad5755", "filename": "src/test/compile-fail/binop-move-semantics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fbinop-move-semantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fbinop-move-semantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-move-semantics.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -62,6 +62,7 @@ fn mut_plus_immut() {\n     &mut f\n     +\n     &f;  //~ ERROR: cannot borrow `f` as immutable because it is also borrowed as mutable\n+    //~^ cannot borrow `f` as immutable because it is also borrowed as mutable\n }\n \n fn immut_plus_mut() {\n@@ -70,6 +71,7 @@ fn immut_plus_mut() {\n     &f\n     +\n     &mut f;  //~ ERROR: cannot borrow `f` as mutable because it is also borrowed as immutable\n+    //~^ cannot borrow `f` as mutable because it is also borrowed as immutable\n }\n \n fn main() {}"}, {"sha": "a0fb470e1e4d0f1887a13e7b9967184102455dc2", "filename": "src/test/compile-fail/block-must-not-have-result-while.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-while.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -11,9 +11,8 @@\n fn main() {\n     while true {\n         true //~  ERROR mismatched types\n-             //~| expected `()`\n-             //~| found `bool`\n-             //~| expected ()\n-             //~| found bool\n+             //~| expected type `()`\n+             //~| found type `bool`\n+             //~| expected (), found bool\n     }\n }"}, {"sha": "bde3212c5bc6301536b036d27e790910d6f2d359", "filename": "src/test/compile-fail/borrowck/borrowck-box-insensitivity.rs", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-box-insensitivity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-box-insensitivity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-box-insensitivity.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -33,22 +33,28 @@ struct D {\n fn copy_after_move() {\n     let a: Box<_> = box A { x: box 0, y: 1 };\n     let _x = a.x;\n+    //~^ value moved here\n     let _y = a.y; //~ ERROR use of moved\n-    //~^^ NOTE `a` moved here (through moving `a.x`)\n+    //~^ move occurs because `a.x` has type `Box<isize>`\n+    //~| value used here after move\n }\n \n fn move_after_move() {\n     let a: Box<_> = box B { x: box 0, y: box 1 };\n     let _x = a.x;\n+    //~^ value moved here\n     let _y = a.y; //~ ERROR use of moved\n-    //~^^ NOTE `a` moved here (through moving `a.x`)\n+    //~^ move occurs because `a.x` has type `Box<isize>`\n+    //~| value used here after move\n }\n \n fn borrow_after_move() {\n     let a: Box<_> = box A { x: box 0, y: 1 };\n     let _x = a.x;\n+    //~^ value moved here\n     let _y = &a.y; //~ ERROR use of moved\n-    //~^^ NOTE `a` moved here (through moving `a.x`)\n+    //~^ move occurs because `a.x` has type `Box<isize>`\n+    //~| value used here after move\n }\n \n fn move_after_borrow() {\n@@ -75,44 +81,52 @@ fn move_after_mut_borrow() {\n fn borrow_after_mut_borrow() {\n     let mut a: Box<_> = box A { x: box 0, y: 1 };\n     let _x = &mut a.x;\n-    //~^ NOTE previous borrow of `a` occurs here (through borrowing `a.x`);\n+    //~^ NOTE mutable borrow occurs here (via `a.x`)\n     let _y = &a.y; //~ ERROR cannot borrow\n+    //~^ immutable borrow occurs here (via `a.y`)\n }\n-//~^ NOTE previous borrow ends here\n+//~^ NOTE mutable borrow ends here\n \n fn mut_borrow_after_borrow() {\n     let mut a: Box<_> = box A { x: box 0, y: 1 };\n     let _x = &a.x;\n-    //~^ NOTE previous borrow of `a` occurs here (through borrowing `a.x`)\n+    //~^ NOTE immutable borrow occurs here (via `a.x`)\n     let _y = &mut a.y; //~ ERROR cannot borrow\n+    //~^ mutable borrow occurs here (via `a.y`)\n }\n-//~^ NOTE previous borrow ends here\n+//~^ NOTE immutable borrow ends here\n \n fn copy_after_move_nested() {\n     let a: Box<_> = box C { x: box A { x: box 0, y: 1 }, y: 2 };\n     let _x = a.x.x;\n-    //~^ NOTE `a.x.x` moved here because it has type `Box<isize>`, which is moved by default\n+    //~^ value moved here\n     let _y = a.y; //~ ERROR use of collaterally moved\n+    //~^ NOTE move occurs because `a.x.x` has type `Box<isize>`\n+    //~| value used here after move\n }\n \n fn move_after_move_nested() {\n     let a: Box<_> = box D { x: box A { x: box 0, y: 1 }, y: box 2 };\n     let _x = a.x.x;\n-    //~^ NOTE `a.x.x` moved here because it has type `Box<isize>`, which is moved by default\n+    //~^ value moved here\n     let _y = a.y; //~ ERROR use of collaterally moved\n+    //~^ NOTE move occurs because `a.x.x` has type `Box<isize>`\n+    //~| value used here after move\n }\n \n fn borrow_after_move_nested() {\n     let a: Box<_> = box C { x: box A { x: box 0, y: 1 }, y: 2 };\n     let _x = a.x.x;\n-    //~^ NOTE `a.x.x` moved here because it has type `Box<isize>`, which is moved by default\n+    //~^ value moved here\n     let _y = &a.y; //~ ERROR use of collaterally moved\n+    //~^ NOTE move occurs because `a.x.x` has type `Box<isize>`\n+    //~| value used here after move\n }\n \n fn move_after_borrow_nested() {\n     let a: Box<_> = box D { x: box A { x: box 0, y: 1 }, y: box 2 };\n     let _x = &a.x.x;\n-    //~^ NOTE borrow of `a.x.x` occurs here\n+    //~^ borrow of `a.x.x` occurs here\n     let _y = a.y; //~ ERROR cannot move\n }\n \n@@ -133,18 +147,20 @@ fn move_after_mut_borrow_nested() {\n fn borrow_after_mut_borrow_nested() {\n     let mut a: Box<_> = box C { x: box A { x: box 0, y: 1 }, y: 2 };\n     let _x = &mut a.x.x;\n-    //~^ NOTE previous borrow of `a.x.x` occurs here; the mutable borrow prevents\n+    //~^ mutable borrow occurs here\n     let _y = &a.y; //~ ERROR cannot borrow\n+    //~^ immutable borrow occurs here\n }\n-//~^ NOTE previous borrow ends here\n+//~^ NOTE mutable borrow ends here\n \n fn mut_borrow_after_borrow_nested() {\n     let mut a: Box<_> = box C { x: box A { x: box 0, y: 1 }, y: 2 };\n     let _x = &a.x.x;\n-    //~^ NOTE previous borrow of `a.x.x` occurs here; the immutable borrow prevents\n+    //~^ immutable borrow occurs here\n     let _y = &mut a.y; //~ ERROR cannot borrow\n+    //~^ mutable borrow occurs here\n }\n-//~^ NOTE previous borrow ends here\n+//~^ NOTE immutable borrow ends here\n \n fn main() {\n     copy_after_move();"}, {"sha": "dc2f0e8395f08154172853662d3d83f97d12ac09", "filename": "src/test/compile-fail/borrowck/borrowck-closures-mut-of-imm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-closures-mut-of-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-closures-mut-of-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-closures-mut-of-imm.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -24,7 +24,7 @@ fn a(x: &isize) {\n     //~^ ERROR cannot borrow\n     let c2 = || set(&mut *x);\n     //~^ ERROR cannot borrow\n-    //~| ERROR closure requires unique access\n+    //~| ERROR two closures require unique access to `x` at the same time\n }\n \n fn main() {"}, {"sha": "1b22dc4d2c6af585c7a7f3b608efb650a475b24d", "filename": "src/test/compile-fail/borrowck/borrowck-closures-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-closures-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-closures-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-closures-unique.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -39,7 +39,7 @@ fn c(x: &mut isize) {\n \n fn d(x: &mut isize) {\n     let c1 = || set(x);\n-    let c2 = || set(x); //~ ERROR closure requires unique access to `x`\n+    let c2 = || set(x); //~ ERROR two closures require unique access to `x` at the same time\n }\n \n fn e(x: &mut isize) {"}, {"sha": "56cbe0b1878675314087ea02137e368721b1448a", "filename": "src/test/compile-fail/borrowck/borrowck-lend-flow-loop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-lend-flow-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-lend-flow-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-lend-flow-loop.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -109,6 +109,7 @@ fn while_aliased_mut_cond(cond: bool, cond2: bool) {\n         borrow(&*v); //~ ERROR cannot borrow\n         if cond2 {\n             x = &mut v; //~ ERROR cannot borrow\n+            //~^ ERROR cannot borrow\n         }\n     }\n }"}, {"sha": "f789d44016eb177850ec2dd3cf35b6ae421c3b11", "filename": "src/test/compile-fail/borrowck/borrowck-mut-borrow-linear-errors.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -19,6 +19,7 @@ fn main() {\n         match 1 {\n             1 => { addr = &mut x; }\n             //~^ ERROR cannot borrow `x` as mutable more than once at a time\n+            //~| ERROR cannot borrow `x` as mutable more than once at a time\n             2 => { addr = &mut x; }\n             //~^ ERROR cannot borrow `x` as mutable more than once at a time\n             _ => { addr = &mut x; }"}, {"sha": "3ca8cc431e0983ce8f5a9365420ae7b3f7d45f02", "filename": "src/test/compile-fail/borrowck/borrowck-report-with-custom-diagnostic.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-report-with-custom-diagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-report-with-custom-diagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-report-with-custom-diagnostic.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -13,21 +13,23 @@ fn main() {\n     // Original borrow ends at end of function\n     let mut x = 1;\n     let y = &mut x;\n-    //~^ previous borrow of `x` occurs here; the mutable borrow prevents\n+    //~^ mutable borrow occurs here\n     let z = &x; //~ ERROR cannot borrow\n+    //~^ immutable borrow occurs here\n }\n-//~^ NOTE previous borrow ends here\n+//~^ NOTE mutable borrow ends here\n \n fn foo() {\n     match true {\n         true => {\n             // Original borrow ends at end of match arm\n             let mut x = 1;\n             let y = &x;\n-            //~^ previous borrow of `x` occurs here; the immutable borrow prevents\n+            //~^ immutable borrow occurs here\n             let z = &mut x; //~ ERROR cannot borrow\n+            //~^ mutable borrow occurs here\n         }\n-     //~^ NOTE previous borrow ends here\n+     //~^ NOTE immutable borrow ends here\n         false => ()\n     }\n }\n@@ -37,8 +39,9 @@ fn bar() {\n     || {\n         let mut x = 1;\n         let y = &mut x;\n-        //~^ previous borrow of `x` occurs here; the mutable borrow prevents\n+        //~^ first mutable borrow occurs here\n         let z = &mut x; //~ ERROR cannot borrow\n+        //~^ second mutable borrow occurs here\n     };\n- //~^ NOTE previous borrow ends here\n+ //~^ NOTE first borrow ends here\n }"}, {"sha": "a387e4c5ece11467527a39ad57b4a9d7eb1a5db6", "filename": "src/test/compile-fail/closure-wrong-kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fclosure-wrong-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fclosure-wrong-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-wrong-kind.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -17,6 +17,6 @@ fn bar<T: Fn(u32)>(_: T) {}\n \n fn main() {\n     let x = X;\n-    let closure = |_| foo(x);  //~ ERROR E0524\n+    let closure = |_| foo(x);  //~ ERROR E0525\n     bar(closure);\n }"}, {"sha": "634d12441a12077c73bf3c5b62f63ff126d4d21b", "filename": "src/test/compile-fail/coerce-mut.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fcoerce-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fcoerce-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoerce-mut.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -14,7 +14,7 @@ fn main() {\n     let x = 0;\n     f(&x);\n     //~^ ERROR mismatched types\n-    //~| expected `&mut i32`\n-    //~| found `&_`\n+    //~| expected type `&mut i32`\n+    //~| found type `&_`\n     //~| values differ in mutability\n }"}, {"sha": "bd7e6c2a2131d36d0eb104be0864caabe72b9c40", "filename": "src/test/compile-fail/coercion-slice.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fcoercion-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fcoercion-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoercion-slice.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -13,8 +13,7 @@\n fn main() {\n     let _: &[i32] = [0];\n     //~^ ERROR mismatched types\n-    //~| expected `&[i32]`\n-    //~| found `[_; 1]`\n-    //~| expected &-ptr\n-    //~| found array of 1 elements\n+    //~| expected type `&[i32]`\n+    //~| found type `[_; 1]`\n+    //~| expected &-ptr, found array of 1 elements\n }"}, {"sha": "ea9a29c0e2ae5e9aaf1080fc10427e9e37a7dce6", "filename": "src/test/compile-fail/cross-borrow-trait.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fcross-borrow-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fcross-borrow-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcross-borrow-trait.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -19,8 +19,7 @@ pub fn main() {\n     // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     let x: Box<Trait> = Box::new(Foo);\n     let _y: &Trait = x; //~  ERROR mismatched types\n-                        //~| expected `&Trait`\n-                        //~| found `Box<Trait>`\n-                        //~| expected &-ptr\n-                        //~| found box\n+                        //~| expected type `&Trait`\n+                        //~| found type `Box<Trait>`\n+                        //~| expected &-ptr, found box\n }"}, {"sha": "4702b504f157d9e4ad6c2745c6d53ffd6b792ee3", "filename": "src/test/compile-fail/default_ty_param_conflict.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_conflict.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -23,6 +23,9 @@ fn main() {\n     // Here, F is instantiated with $0=uint\n     let x = foo();\n     //~^ ERROR: mismatched types\n+    //~| expected type `usize`\n+    //~| found type `isize`\n+    //~| NOTE: conflicting type parameter defaults `usize` and `isize`\n     //~| NOTE: conflicting type parameter defaults `usize` and `isize`\n     //~| NOTE: ...that was applied to an unconstrained type variable here\n "}, {"sha": "b608c6c99be89a5754760dde87272bb94ac54945", "filename": "src/test/compile-fail/default_ty_param_conflict_cross_crate.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_conflict_cross_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_conflict_cross_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_conflict_cross_crate.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -24,7 +24,11 @@ fn main() {\n     //~^ NOTE: ...that also applies to the same type variable here\n \n     meh(foo);\n-    //~^ ERROR: mismatched types:\n+    //~^ ERROR: mismatched types\n     //~| NOTE: conflicting type parameter defaults `bool` and `char`\n+    //~| NOTE: conflicting type parameter defaults `bool` and `char`\n+    //~| a second default is defined on `default_param_test::bleh`\n     //~| NOTE:  ...that was applied to an unconstrained type variable here\n+    //~| expected type `bool`\n+    //~| found type `char`\n }"}, {"sha": "d0a31fbce91ed38475c42f7a1b1c23c20eaafac3", "filename": "src/test/compile-fail/destructure-trait-ref.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -40,20 +40,17 @@ fn main() {\n     // n > m\n     let &&x = &1isize as &T;\n     //~^ ERROR mismatched types\n-    //~| expected `T`\n-    //~| found `&_`\n-    //~| expected trait T\n-    //~| found &-ptr\n+    //~| expected type `T`\n+    //~| found type `&_`\n+    //~| expected trait T, found &-ptr\n     let &&&x = &(&1isize as &T);\n     //~^ ERROR mismatched types\n-    //~| expected `T`\n-    //~| found `&_`\n-    //~| expected trait T\n-    //~| found &-ptr\n+    //~| expected type `T`\n+    //~| found type `&_`\n+    //~| expected trait T, found &-ptr\n     let box box x = box 1isize as Box<T>;\n     //~^ ERROR mismatched types\n-    //~| expected `T`\n-    //~| found `Box<_>`\n-    //~| expected trait T\n-    //~| found box\n+    //~| expected type `T`\n+    //~| found type `Box<_>`\n+    //~| expected trait T, found box\n }"}, {"sha": "9e71ad2417792801b1eb88c5efe44ddb4abfcb81", "filename": "src/test/compile-fail/dst-bad-assign.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -45,9 +45,8 @@ pub fn main() {\n     let z: Box<ToBar> = Box::new(Bar1 {f: 36});\n     f5.ptr = Bar1 {f: 36};\n     //~^ ERROR mismatched types\n-    //~| expected `ToBar`\n-    //~| found `Bar1`\n-    //~| expected trait ToBar\n-    //~| found struct `Bar1`\n+    //~| expected type `ToBar`\n+    //~| found type `Bar1`\n+    //~| expected trait ToBar, found struct `Bar1`\n     //~| ERROR `ToBar: std::marker::Sized` is not satisfied\n }"}, {"sha": "9d4d56cf79190a78b12d9852d89c287bcbe8d21a", "filename": "src/test/compile-fail/dst-bad-coerce4.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -19,8 +19,7 @@ pub fn main() {\n     let f1: &Fat<[isize]> = &Fat { ptr: [1, 2, 3] };\n     let f2: &Fat<[isize; 3]> = f1;\n     //~^ ERROR mismatched types\n-    //~| expected `&Fat<[isize; 3]>`\n-    //~| found `&Fat<[isize]>`\n-    //~| expected array of 3 elements\n-    //~| found slice\n+    //~| expected type `&Fat<[isize; 3]>`\n+    //~| found type `&Fat<[isize]>`\n+    //~| expected array of 3 elements, found slice\n }"}, {"sha": "b5432fafb1b855f0b09cb6a1a2634b847673acc8", "filename": "src/test/compile-fail/explicit-self-lifetime-mismatch.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fexplicit-self-lifetime-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fexplicit-self-lifetime-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexplicit-self-lifetime-mismatch.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -16,12 +16,12 @@ struct Foo<'a,'b> {\n impl<'a,'b> Foo<'a,'b> {\n     fn bar(self: Foo<'b,'a>) {}\n     //~^ ERROR mismatched types\n-    //~| expected `Foo<'a, 'b>`\n-    //~| found `Foo<'b, 'a>`\n+    //~| expected type `Foo<'a, 'b>`\n+    //~| found type `Foo<'b, 'a>`\n     //~| lifetime mismatch\n     //~| ERROR mismatched types\n-    //~| expected `Foo<'a, 'b>`\n-    //~| found `Foo<'b, 'a>`\n+    //~| expected type `Foo<'a, 'b>`\n+    //~| found type `Foo<'b, 'a>`\n     //~| lifetime mismatch\n }\n "}, {"sha": "11f299acefa874e55b5efa49b81eb345fd9350be", "filename": "src/test/compile-fail/extern-main-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fextern-main-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fextern-main-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextern-main-fn.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern fn main() {} //~ ERROR: main function expects type\n+extern fn main() {} //~ ERROR: main function has wrong type"}, {"sha": "6217a9f16b93523d868139299feddf0716e556a1", "filename": "src/test/compile-fail/fn-item-type.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ffn-item-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ffn-item-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-item-type.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -22,26 +22,22 @@ impl<T> Foo for T { /* `foo` is still default here */ }\n fn main() {\n     eq(foo::<u8>, bar::<u8>);\n     //~^ ERROR mismatched types\n-    //~|  expected `fn(isize) -> isize {foo::<u8>}`\n-    //~|  found `fn(isize) -> isize {bar::<u8>}`\n-    //~|  expected fn item\n-    //~|  found a different fn item\n+    //~|  expected type `fn(isize) -> isize {foo::<u8>}`\n+    //~|  found type `fn(isize) -> isize {bar::<u8>}`\n+    //~|  expected fn item, found a different fn item\n \n     eq(foo::<u8>, foo::<i8>);\n     //~^ ERROR mismatched types\n-    //~|  expected `fn(isize) -> isize {foo::<u8>}`\n-    //~|  found `fn(isize) -> isize {foo::<i8>}`\n+    //~| expected u8, found i8\n \n     eq(bar::<String>, bar::<Vec<u8>>);\n     //~^ ERROR mismatched types\n-    //~|  expected `fn(isize) -> isize {bar::<std::string::String>}`\n-    //~|  found `fn(isize) -> isize {bar::<std::vec::Vec<u8>>}`\n-    //~|  expected struct `std::string::String`\n-    //~|  found struct `std::vec::Vec`\n+    //~|  expected type `fn(isize) -> isize {bar::<std::string::String>}`\n+    //~|  found type `fn(isize) -> isize {bar::<std::vec::Vec<u8>>}`\n+    //~|  expected struct `std::string::String`, found struct `std::vec::Vec`\n \n     // Make sure we distinguish between trait methods correctly.\n     eq(<u8 as Foo>::foo, <u16 as Foo>::foo);\n     //~^ ERROR mismatched types\n-    //~|  expected `fn() {<u8 as Foo>::foo}`\n-    //~|  found `fn() {<u16 as Foo>::foo}`\n+    //~| expected u8, found u16\n }"}, {"sha": "fd140cd1d391a6bf1ca7105bb94cabfbe87a10dd", "filename": "src/test/compile-fail/fn-trait-formatting.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -16,22 +16,19 @@ fn needs_fn<F>(x: F) where F: Fn(isize) -> isize {}\n fn main() {\n     let _: () = (box |_: isize| {}) as Box<FnOnce(isize)>;\n     //~^ ERROR mismatched types\n-    //~| expected `()`\n-    //~| found `Box<std::ops::FnOnce(isize)>`\n-    //~| expected ()\n-    //~| found box\n+    //~| expected type `()`\n+    //~| found type `Box<std::ops::FnOnce(isize)>`\n+    //~| expected (), found box\n     let _: () = (box |_: isize, isize| {}) as Box<Fn(isize, isize)>;\n     //~^ ERROR mismatched types\n-    //~| expected `()`\n-    //~| found `Box<std::ops::Fn(isize, isize)>`\n-    //~| expected ()\n-    //~| found box\n+    //~| expected type `()`\n+    //~| found type `Box<std::ops::Fn(isize, isize)>`\n+    //~| expected (), found box\n     let _: () = (box || -> isize { unimplemented!() }) as Box<FnMut() -> isize>;\n     //~^ ERROR mismatched types\n-    //~| expected `()`\n-    //~| found `Box<std::ops::FnMut() -> isize>`\n-    //~| expected ()\n-    //~| found box\n+    //~| expected type `()`\n+    //~| found type `Box<std::ops::FnMut() -> isize>`\n+    //~| expected (), found box\n \n     needs_fn(1);\n     //~^ ERROR : std::ops::Fn<(isize,)>`"}, {"sha": "5ea8ce226443836889e06866c287577af8a95f3a", "filename": "src/test/compile-fail/fully-qualified-type-name1.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name1.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -14,8 +14,7 @@ fn main() {\n     let x: Option<usize>;\n     x = 5;\n     //~^ ERROR mismatched types\n-    //~| expected `std::option::Option<usize>`\n-    //~| found `_`\n-    //~| expected enum `std::option::Option`\n-    //~| found integral variable\n+    //~| expected type `std::option::Option<usize>`\n+    //~| found type `_`\n+    //~| expected enum `std::option::Option`, found integral variable\n }"}, {"sha": "9ba8a11d536bede788c8f3d9a4ec2bf6e60c9224", "filename": "src/test/compile-fail/fully-qualified-type-name2.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name2.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -21,10 +21,9 @@ mod y {\n fn bar(x: x::foo) -> y::foo {\n     return x;\n     //~^ ERROR mismatched types\n-    //~| expected `y::foo`\n-    //~| found `x::foo`\n-    //~| expected enum `y::foo`\n-    //~| found enum `x::foo`\n+    //~| expected type `y::foo`\n+    //~| found type `x::foo`\n+    //~| expected enum `y::foo`, found enum `x::foo`\n }\n \n fn main() {"}, {"sha": "3c8fde751f123cec50b3b59d6829dd0a9d41e97d", "filename": "src/test/compile-fail/fully-qualified-type-name4.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name4.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -15,10 +15,9 @@ use std::option::Option;\n fn bar(x: usize) -> Option<usize> {\n     return x;\n     //~^ ERROR mismatched types\n-    //~| expected `std::option::Option<usize>`\n-    //~| found `usize`\n-    //~| expected enum `std::option::Option`\n-    //~| found usize\n+    //~| expected type `std::option::Option<usize>`\n+    //~| found type `usize`\n+    //~| expected enum `std::option::Option`, found usize\n }\n \n fn main() {"}, {"sha": "71d7cf792e4754d3b19397808b99c16fa655b6be", "filename": "src/test/compile-fail/generic-type-params-name-repr.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fgeneric-type-params-name-repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fgeneric-type-params-name-repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgeneric-type-params-name-repr.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -22,46 +22,40 @@ fn main() {\n     // Ensure that the printed type doesn't include the default type params...\n     let _: Foo<isize> = ();\n     //~^ ERROR mismatched types\n-    //~| expected `Foo<isize>`\n-    //~| found `()`\n-    //~| expected struct `Foo`\n-    //~| found ()\n+    //~| expected type `Foo<isize>`\n+    //~| found type `()`\n+    //~| expected struct `Foo`, found ()\n \n     // ...even when they're present, but the same types as the defaults.\n     let _: Foo<isize, B, C> = ();\n     //~^ ERROR mismatched types\n-    //~| expected `Foo<isize>`\n-    //~| found `()`\n-    //~| expected struct `Foo`\n-    //~| found ()\n+    //~| expected type `Foo<isize>`\n+    //~| found type `()`\n+    //~| expected struct `Foo`, found ()\n \n     // Including cases where the default is using previous type params.\n     let _: HashMap<String, isize> = ();\n     //~^ ERROR mismatched types\n-    //~| expected `HashMap<std::string::String, isize>`\n-    //~| found `()`\n-    //~| expected struct `HashMap`\n-    //~| found ()\n+    //~| expected type `HashMap<std::string::String, isize>`\n+    //~| found type `()`\n+    //~| expected struct `HashMap`, found ()\n     let _: HashMap<String, isize, Hash<String>> = ();\n     //~^ ERROR mismatched types\n-    //~| expected `HashMap<std::string::String, isize>`\n-    //~| found `()`\n-    //~| expected struct `HashMap`\n-    //~| found ()\n+    //~| expected type `HashMap<std::string::String, isize>`\n+    //~| found type `()`\n+    //~| expected struct `HashMap`, found ()\n \n     // But not when there's a different type in between.\n     let _: Foo<A, isize, C> = ();\n     //~^ ERROR mismatched types\n-    //~| expected `Foo<A, isize>`\n-    //~| found `()`\n-    //~| expected struct `Foo`\n-    //~| found ()\n+    //~| expected type `Foo<A, isize>`\n+    //~| found type `()`\n+    //~| expected struct `Foo`, found ()\n \n     // And don't print <> at all when there's just defaults.\n     let _: Foo<A, B, C> = ();\n     //~^ ERROR mismatched types\n-    //~| expected `Foo`\n-    //~| found `()`\n-    //~| expected struct `Foo`\n-    //~| found ()\n+    //~| expected type `Foo`\n+    //~| found type `()`\n+    //~| expected struct `Foo`, found ()\n }"}, {"sha": "ca9803f66b20d4e35502fa197d428d7e35409be4", "filename": "src/test/compile-fail/if-branch-types.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fif-branch-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fif-branch-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fif-branch-types.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -11,6 +11,5 @@\n fn main() {\n     let x = if true { 10i32 } else { 10u32 };\n     //~^ ERROR if and else have incompatible types\n-    //~| expected `i32`\n-    //~| found `u32`\n+    //~| expected i32, found u32\n }"}, {"sha": "c7b1e1a62c2097c4e87fdcbdec210f5aa8b7f9a3", "filename": "src/test/compile-fail/if-let-arm-types.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fif-let-arm-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fif-let-arm-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fif-let-arm-types.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -10,6 +10,9 @@\n \n fn main() {\n     if let Some(b) = None { //~ ERROR: `if let` arms have incompatible types\n+        //~^ expected (), found integral variable\n+        //~| expected type `()`\n+        //~| found type `_`\n         ()\n     } else {                //~ NOTE: `if let` arm with an incompatible type\n         1"}, {"sha": "e8aa1f70ea1dcd85f6aa7fe6b37d9f3c404bda18", "filename": "src/test/compile-fail/if-without-else-result.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fif-without-else-result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fif-without-else-result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fif-without-else-result.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -11,9 +11,8 @@\n fn main() {\n     let a = if true { true };\n     //~^ ERROR if may be missing an else clause\n-    //~| expected `()`\n-    //~| found `bool`\n-    //~| expected ()\n-    //~| found bool\n+    //~| expected type `()`\n+    //~| found type `bool`\n+    //~| expected (), found bool\n     println!(\"{}\", a);\n }"}, {"sha": "7a850d90a87477f76ebdc3d2cc02a88be1ba0cd7", "filename": "src/test/compile-fail/integer-literal-suffix-inference.rs", "status": "modified", "additions": 36, "deletions": 72, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Finteger-literal-suffix-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Finteger-literal-suffix-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finteger-literal-suffix-inference.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -41,168 +41,132 @@ fn main() {\n     id_i8(a8); // ok\n     id_i8(a16);\n     //~^ ERROR mismatched types\n-    //~| expected `i8`\n-    //~| found `i16`\n+    //~| expected i8, found i16\n     id_i8(a32);\n     //~^ ERROR mismatched types\n-    //~| expected `i8`\n-    //~| found `i32`\n+    //~| expected i8, found i32\n     id_i8(a64);\n     //~^ ERROR mismatched types\n-    //~| expected `i8`\n-    //~| found `i64`\n+    //~| expected i8, found i64\n \n     id_i16(a8);\n     //~^ ERROR mismatched types\n-    //~| expected `i16`\n-    //~| found `i8`\n+    //~| expected i16, found i8\n     id_i16(a16); // ok\n     id_i16(a32);\n     //~^ ERROR mismatched types\n-    //~| expected `i16`\n-    //~| found `i32`\n+    //~| expected i16, found i32\n     id_i16(a64);\n     //~^ ERROR mismatched types\n-    //~| expected `i16`\n-    //~| found `i64`\n+    //~| expected i16, found i64\n \n     id_i32(a8);\n     //~^ ERROR mismatched types\n-    //~| expected `i32`\n-    //~| found `i8`\n+    //~| expected i32, found i8\n     id_i32(a16);\n     //~^ ERROR mismatched types\n-    //~| expected `i32`\n-    //~| found `i16`\n+    //~| expected i32, found i16\n     id_i32(a32); // ok\n     id_i32(a64);\n     //~^ ERROR mismatched types\n-    //~| expected `i32`\n-    //~| found `i64`\n+    //~| expected i32, found i64\n \n     id_i64(a8);\n     //~^ ERROR mismatched types\n-    //~| expected `i64`\n-    //~| found `i8`\n+    //~| expected i64, found i8\n     id_i64(a16);\n     //~^ ERROR mismatched types\n-    //~| expected `i64`\n-    //~| found `i16`\n+    //~| expected i64, found i16\n     id_i64(a32);\n     //~^ ERROR mismatched types\n-    //~| expected `i64`\n-    //~| found `i32`\n+    //~| expected i64, found i32\n     id_i64(a64); // ok\n \n     id_i8(c8); // ok\n     id_i8(c16);\n     //~^ ERROR mismatched types\n-    //~| expected `i8`\n-    //~| found `i16`\n+    //~| expected i8, found i16\n     id_i8(c32);\n     //~^ ERROR mismatched types\n-    //~| expected `i8`\n-    //~| found `i32`\n+    //~| expected i8, found i32\n     id_i8(c64);\n     //~^ ERROR mismatched types\n-    //~| expected `i8`\n-    //~| found `i64`\n+    //~| expected i8, found i64\n \n     id_i16(c8);\n     //~^ ERROR mismatched types\n-    //~| expected `i16`\n-    //~| found `i8`\n+    //~| expected i16, found i8\n     id_i16(c16); // ok\n     id_i16(c32);\n     //~^ ERROR mismatched types\n-    //~| expected `i16`\n-    //~| found `i32`\n+    //~| expected i16, found i32\n     id_i16(c64);\n     //~^ ERROR mismatched types\n-    //~| expected `i16`\n-    //~| found `i64`\n+    //~| expected i16, found i64\n \n     id_i32(c8);\n     //~^ ERROR mismatched types\n-    //~| expected `i32`\n-    //~| found `i8`\n+    //~| expected i32, found i8\n     id_i32(c16);\n     //~^ ERROR mismatched types\n-    //~| expected `i32`\n-    //~| found `i16`\n+    //~| expected i32, found i16\n     id_i32(c32); // ok\n     id_i32(c64);\n     //~^ ERROR mismatched types\n-    //~| expected `i32`\n-    //~| found `i64`\n+    //~| expected i32, found i64\n \n     id_i64(a8);\n     //~^ ERROR mismatched types\n-    //~| expected `i64`\n-    //~| found `i8`\n+    //~| expected i64, found i8\n     id_i64(a16);\n     //~^ ERROR mismatched types\n-    //~| expected `i64`\n-    //~| found `i16`\n+    //~| expected i64, found i16\n     id_i64(a32);\n     //~^ ERROR mismatched types\n-    //~| expected `i64`\n-    //~| found `i32`\n+    //~| expected i64, found i32\n     id_i64(a64); // ok\n \n     id_u8(b8); // ok\n     id_u8(b16);\n     //~^ ERROR mismatched types\n-    //~| expected `u8`\n-    //~| found `u16`\n+    //~| expected u8, found u16\n     id_u8(b32);\n     //~^ ERROR mismatched types\n-    //~| expected `u8`\n-    //~| found `u32`\n+    //~| expected u8, found u32\n     id_u8(b64);\n     //~^ ERROR mismatched types\n-    //~| expected `u8`\n-    //~| found `u64`\n+    //~| expected u8, found u64\n \n     id_u16(b8);\n     //~^ ERROR mismatched types\n-    //~| expected `u16`\n-    //~| found `u8`\n+    //~| expected u16, found u8\n     id_u16(b16); // ok\n     id_u16(b32);\n     //~^ ERROR mismatched types\n-    //~| expected `u16`\n-    //~| found `u32`\n+    //~| expected u16, found u32\n     id_u16(b64);\n     //~^ ERROR mismatched types\n-    //~| expected `u16`\n-    //~| found `u64`\n+    //~| expected u16, found u64\n \n     id_u32(b8);\n     //~^ ERROR mismatched types\n-    //~| expected `u32`\n-    //~| found `u8`\n+    //~| expected u32, found u8\n     id_u32(b16);\n     //~^ ERROR mismatched types\n-    //~| expected `u32`\n-    //~| found `u16`\n+    //~| expected u32, found u16\n     id_u32(b32); // ok\n     id_u32(b64);\n     //~^ ERROR mismatched types\n-    //~| expected `u32`\n-    //~| found `u64`\n+    //~| expected u32, found u64\n \n     id_u64(b8);\n     //~^ ERROR mismatched types\n-    //~| expected `u64`\n-    //~| found `u8`\n+    //~| expected u64, found u8\n     id_u64(b16);\n     //~^ ERROR mismatched types\n-    //~| expected `u64`\n-    //~| found `u16`\n+    //~| expected u64, found u16\n     id_u64(b32);\n     //~^ ERROR mismatched types\n-    //~| expected `u64`\n-    //~| found `u32`\n+    //~| expected u64, found u32\n     id_u64(b64); // ok\n }"}, {"sha": "99f2d25166891b1a785f03c1e8098edf9c113d63", "filename": "src/test/compile-fail/integral-variable-unification-error.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fintegral-variable-unification-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fintegral-variable-unification-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fintegral-variable-unification-error.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -12,8 +12,7 @@ fn main() {\n     let mut x = 2;\n     x = 5.0;\n     //~^ ERROR mismatched types\n-    //~| expected `_`\n-    //~| found `_`\n-    //~| expected integral variable\n-    //~| found floating-point variable\n+    //~| expected type `_`\n+    //~| found type `_`\n+    //~| expected integral variable, found floating-point variable\n }"}, {"sha": "434b795ff31f54404c489ae3491aaaf4a81d4ead", "filename": "src/test/compile-fail/issue-10176.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-10176.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-10176.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10176.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -11,10 +11,9 @@\n fn f() -> isize {\n     (return 1, return 2)\n //~^ ERROR mismatched types\n-//~| expected `isize`\n-//~| found `(_, _)`\n-//~| expected isize\n-//~| found tuple\n+//~| expected type `isize`\n+//~| found type `(_, _)`\n+//~| expected isize, found tuple\n }\n \n fn main() {}"}, {"sha": "8242fa1c2e9794eb8c92f61b1f81710ad910e3c4", "filename": "src/test/compile-fail/issue-11319.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-11319.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-11319.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11319.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -10,11 +10,10 @@\n \n fn main() {\n     match Some(10) {\n-    //~^ ERROR match arms have incompatible types:\n-    //~| expected `bool`\n-    //~| found `()`\n-    //~| expected bool\n-    //~| found ()\n+    //~^ ERROR match arms have incompatible types\n+    //~| expected type `bool`\n+    //~| found type `()`\n+    //~| expected bool, found ()\n         Some(5) => false,\n         Some(2) => true,\n         None    => (), //~ NOTE match arm with an incompatible type"}, {"sha": "436d9e91dc72f2ff4935e486780a05ab47e0feae", "filename": "src/test/compile-fail/issue-12997-2.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-12997-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-12997-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12997-2.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -15,7 +15,6 @@\n #[bench]\n fn bar(x: isize) { }\n //~^ ERROR mismatched types\n-//~| expected `fn(&mut __test::test::Bencher)`\n-//~| found `fn(isize) {bar}`\n-//~| expected &-ptr\n-//~| found isize\n+//~| expected type `fn(&mut __test::test::Bencher)`\n+//~| found type `fn(isize) {bar}`\n+//~| expected &-ptr, found isize"}, {"sha": "e33859e8c19a38479ee260f2579c00b8dd66068b", "filename": "src/test/compile-fail/issue-13359.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-13359.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-13359.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13359.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -15,11 +15,9 @@ fn bar(_s: u32) { }\n fn main() {\n     foo(1*(1 as isize));\n     //~^ ERROR mismatched types\n-    //~| expected `i16`\n-    //~| found `isize`\n+    //~| expected i16, found isize\n \n     bar(1*(1 as usize));\n     //~^ ERROR mismatched types\n-    //~| expected `u32`\n-    //~| found `usize`\n+    //~| expected u32, found usize\n }"}, {"sha": "17b96411603ef3e3ce6ffd4981728f34fd98e686", "filename": "src/test/compile-fail/issue-13466.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-13466.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-13466.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13466.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -17,16 +17,14 @@ pub fn main() {\n     let _x: usize = match Some(1) {\n         Ok(u) => u,\n         //~^ ERROR mismatched types\n-        //~| expected `std::option::Option<_>`\n-        //~| found `std::result::Result<_, _>`\n-        //~| expected enum `std::option::Option`\n-        //~| found enum `std::result::Result`\n+        //~| expected type `std::option::Option<_>`\n+        //~| found type `std::result::Result<_, _>`\n+        //~| expected enum `std::option::Option`, found enum `std::result::Result`\n \n         Err(e) => panic!(e)\n         //~^ ERROR mismatched types\n-        //~| expected `std::option::Option<_>`\n-        //~| found `std::result::Result<_, _>`\n-        //~| expected enum `std::option::Option`\n-        //~| found enum `std::result::Result`\n+        //~| expected type `std::option::Option<_>`\n+        //~| found type `std::result::Result<_, _>`\n+        //~| expected enum `std::option::Option`, found enum `std::result::Result`\n     };\n }"}, {"sha": "fe03373a45d9fd6b08ab2488febec50aea53e3d5", "filename": "src/test/compile-fail/issue-13482-2.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-13482-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-13482-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13482-2.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -17,10 +17,9 @@ fn main() {\n     let y = match x {\n         [] => None,\n //~^ ERROR mismatched types\n-//~| expected `[_#1i; 2]`\n-//~| found `[_#7t; 0]`\n-//~| expected an array with a fixed size of 2 elements\n-//~| found one with 0 elements\n+//~| expected type `[_#1i; 2]`\n+//~| found type `[_#7t; 0]`\n+//~| expected an array with a fixed size of 2 elements, found one with 0 elements\n         [a,_] => Some(a)\n     };\n }"}, {"sha": "7ed7f5898b1b7411f4b49e713b8f2203db2eb5f5", "filename": "src/test/compile-fail/issue-13482.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -15,8 +15,8 @@ fn main() {\n   let y = match x {\n     [] => None,\n     //~^ ERROR mismatched types\n-    //~| expected `[_; 2]`\n-    //~| found `[_; 0]`\n+    //~| expected type `[_; 2]`\n+    //~| found type `[_; 0]`\n     //~| expected an array with a fixed size of 2 elements\n     [a,_] => Some(a)\n   };"}, {"sha": "e4ed87c3cb0cd5baac0a663c3af4a76006e38c9f", "filename": "src/test/compile-fail/issue-13624.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-13624.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-13624.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13624.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -16,10 +16,9 @@ mod a {\n   pub fn get_enum_struct_variant() -> () {\n     Enum::EnumStructVariant { x: 1, y: 2, z: 3 }\n     //~^ ERROR mismatched types\n-    //~| expected `()`\n-    //~| found `a::Enum`\n-    //~| expected ()\n-    //~| found enum `a::Enum`\n+    //~| expected type `()`\n+    //~| found type `a::Enum`\n+    //~| expected (), found enum `a::Enum`\n   }\n }\n \n@@ -32,10 +31,9 @@ mod b {\n       match enum_struct_variant {\n         a::Enum::EnumStructVariant { x, y, z } => {\n         //~^ ERROR mismatched types\n-        //~| expected `()`\n-        //~| found `a::Enum`\n-        //~| expected ()\n-        // found enum `a::Enum`\n+        //~| expected type `()`\n+        //~| found type `a::Enum`\n+        //~| expected (), found enum `a::Enum`\n         }\n       }\n     }"}, {"sha": "9c594ef485fd769f4629dc0ec06d061b2b224779", "filename": "src/test/compile-fail/issue-14091.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-14091.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-14091.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14091.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -9,9 +9,5 @@\n // except according to those terms.\n \n // error-pattern:mismatched types\n-// error-pattern:expected `bool`\n-// error-pattern:found `_`\n-// error-pattern:expected bool\n-// error-pattern:found integral variable\n \n fn main(){assert!(1,1);}"}, {"sha": "84c600d2201e324b378566a0e3d9e9083ecc2271", "filename": "src/test/compile-fail/issue-14541.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-14541.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-14541.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14541.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -14,10 +14,9 @@ struct vec3 { y: f32, z: f32 }\n fn make(v: vec2) {\n     let vec3 { y: _, z: _ } = v;\n     //~^ ERROR mismatched types\n-    //~| expected `vec2`\n-    //~| found `vec3`\n-    //~| expected struct `vec2`\n-    //~| found struct `vec3`\n+    //~| expected type `vec2`\n+    //~| found type `vec3`\n+    //~| expected struct `vec2`, found struct `vec3`\n }\n \n fn main() { }"}, {"sha": "37a2f1582bf08124fd4a152783a9f29c80be6623", "filename": "src/test/compile-fail/issue-15783.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-15783.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-15783.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15783.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -17,9 +17,8 @@ fn main() {\n     let x = Some(&[name]);\n     let msg = foo(x);\n //~^ ERROR mismatched types\n-//~| expected `std::option::Option<&[&str]>`\n-//~| found `std::option::Option<&[&str; 1]>`\n-//~| expected slice\n-//~| found array of 1 elements\n+//~| expected type `std::option::Option<&[&str]>`\n+//~| found type `std::option::Option<&[&str; 1]>`\n+//~| expected slice, found array of 1 elements\n     assert_eq!(msg, 3);\n }"}, {"sha": "35ef9ba2b4beacc244b90cd3e623a206241cd6ed", "filename": "src/test/compile-fail/issue-15896.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-15896.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-15896.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15896.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -20,10 +20,9 @@ fn main() {\n         E::B(\n           Tau{t: x},\n           //~^ ERROR mismatched types\n-          //~| expected `main::R`\n-          //~| found `main::Tau`\n-          //~| expected enum `main::R`\n-          //~| found struct `main::Tau`\n+          //~| expected type `main::R`\n+          //~| found type `main::Tau`\n+          //~| expected enum `main::R`, found struct `main::Tau`\n           _) => x,\n     };\n }"}, {"sha": "da6d081a7acb57e654e2fdadd9862246db842b2e", "filename": "src/test/compile-fail/issue-16338.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-16338.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-16338.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16338.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -13,8 +13,7 @@ use std::raw::Slice;\n fn main() {\n     let Slice { data: data, len: len } = \"foo\";\n     //~^ ERROR mismatched types\n-    //~| expected `&str`\n-    //~| found `std::raw::Slice<_>`\n-    //~| expected &-ptr\n-    //~| found struct `std::raw::Slice`\n+    //~| expected type `&str`\n+    //~| found type `std::raw::Slice<_>`\n+    //~| expected &-ptr, found struct `std::raw::Slice`\n }"}, {"sha": "df272a71cee4f70af8daf73c6cb9475e79c76cd6", "filename": "src/test/compile-fail/issue-16401.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-16401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-16401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16401.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -14,10 +14,9 @@ fn main() {\n     match () {\n         Slice { data: data, len: len } => (),\n         //~^ ERROR mismatched types\n-        //~| expected `()`\n-        //~| found `std::raw::Slice<_>`\n-        //~| expected ()\n-        //~| found struct `std::raw::Slice`\n+        //~| expected type `()`\n+        //~| found type `std::raw::Slice<_>`\n+        //~| expected (), found struct `std::raw::Slice`\n         _ => unreachable!()\n     }\n }"}, {"sha": "f0fe01b4159706b1281474395a81a477d0be0e47", "filename": "src/test/compile-fail/issue-17033.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-17033.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-17033.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17033.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -12,10 +12,9 @@\n \n fn f<'r>(p: &'r mut fn(p: &mut ())) {\n     (*p)(()) //~  ERROR mismatched types\n-             //~| expected `&mut ()`\n-             //~| found `()`\n-             //~| expected &-ptr\n-             //~| found ()\n+             //~| expected type `&mut ()`\n+             //~| found type `()`\n+             //~| expected &-ptr, found ()\n }\n \n fn main() {}"}, {"sha": "063afe285fad3cb75d367c7be1eee5c4f243ac8b", "filename": "src/test/compile-fail/issue-17263.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-17263.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-17263.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17263.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -15,13 +15,15 @@ struct Foo { a: isize, b: isize }\n fn main() {\n     let mut x: Box<_> = box Foo { a: 1, b: 2 };\n     let (a, b) = (&mut x.a, &mut x.b);\n-    //~^ ERROR cannot borrow `x` (here through borrowing `x.b`) as mutable more than once at a time\n-    //~^^ NOTE previous borrow of `x` occurs here (through borrowing `x.a`)\n+    //~^ ERROR cannot borrow `x` (via `x.b`) as mutable more than once at a time\n+    //~| NOTE first mutable borrow occurs here (via `x.a`)\n+    //~| NOTE second mutable borrow occurs here (via `x.b`)\n \n     let mut foo: Box<_> = box Foo { a: 1, b: 2 };\n     let (c, d) = (&mut foo.a, &foo.b);\n-    //~^ ERROR cannot borrow `foo` (here through borrowing `foo.b`) as immutable\n-    //~^^ NOTE previous borrow of `foo` occurs here (through borrowing `foo.a`)\n+    //~^ ERROR cannot borrow `foo` (via `foo.b`) as immutable\n+    //~| NOTE mutable borrow occurs here (via `foo.a`)\n+    //~| NOTE immutable borrow occurs here (via `foo.b`)\n }\n-//~^ NOTE previous borrow ends here\n-//~^^ NOTE previous borrow ends here\n+//~^ NOTE first borrow ends here\n+//~^^ NOTE mutable borrow ends here"}, {"sha": "98208bcfdbdee1e7f0cf1556ec51a4c8c3dded62", "filename": "src/test/compile-fail/issue-17283.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-17283.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-17283.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17283.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -24,28 +24,25 @@ fn main() {\n     // `x { ... }` should not be interpreted as a struct literal here\n     if x = x {\n         //~^ ERROR mismatched types\n-        //~| expected `bool`\n-        //~| found `()`\n-        //~| expected bool\n-        //~| found ()\n+        //~| expected type `bool`\n+        //~| found type `()`\n+        //~| expected bool, found ()\n         println!(\"{}\", x);\n     }\n     // Explicit parentheses on the left should match behavior of above\n     if (x = x) {\n         //~^ ERROR mismatched types\n-        //~| expected `bool`\n-        //~| found `()`\n-        //~| expected bool\n-        //~| found ()\n+        //~| expected type `bool`\n+        //~| found type `()`\n+        //~| expected bool, found ()\n         println!(\"{}\", x);\n     }\n     // The struct literal interpretation is fine with explicit parentheses on the right\n     if y = (Foo { foo: x }) {\n         //~^ ERROR mismatched types\n-        //~| expected `bool`\n-        //~| found `()`\n-        //~| expected bool\n-        //~| found ()\n+        //~| expected type `bool`\n+        //~| found type `()`\n+        //~| expected bool, found ()\n         println!(\"{}\", x);\n     }\n }"}, {"sha": "f508d7123d88f6ce4d2b7a36eedfffc46b18a0f5", "filename": "src/test/compile-fail/issue-17728.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -108,6 +108,9 @@ impl Debug for Player {\n \n fn str_to_direction(to_parse: &str) -> RoomDirection {\n     match to_parse { //~ ERROR match arms have incompatible types\n+    //~^ expected enum `RoomDirection`, found enum `std::option::Option`\n+    //~| expected type `RoomDirection`\n+    //~| found type `std::option::Option<_>`\n         \"w\" | \"west\" => RoomDirection::West,\n         \"e\" | \"east\" => RoomDirection::East,\n         \"n\" | \"north\" => RoomDirection::North,"}, {"sha": "6b9294b2038f18fff4070765df96e8d574a31605", "filename": "src/test/compile-fail/issue-17740.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-17740.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-17740.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17740.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -15,12 +15,12 @@ struct Foo<'a> {\n impl <'a> Foo<'a>{\n     fn bar(self: &mut Foo) {\n     //~^ mismatched types\n-    //~| expected `&mut Foo<'a>`\n-    //~| found `&mut Foo<'_>`\n+    //~| expected type `&mut Foo<'a>`\n+    //~| found type `&mut Foo<'_>`\n     //~| lifetime mismatch\n     //~| mismatched types\n-    //~| expected `&mut Foo<'a>`\n-    //~| found `&mut Foo<'_>`\n+    //~| expected type `&mut Foo<'a>`\n+    //~| found type `&mut Foo<'_>`\n     //~| lifetime mismatch\n     }\n }"}, {"sha": "580684e2e140bf3b49e5ec946dcfef0a680eac6e", "filename": "src/test/compile-fail/issue-19109.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-19109.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-19109.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19109.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -12,11 +12,10 @@ trait Trait { }\n \n fn function(t: &mut Trait) {\n     t as *mut Trait\n- //~^ ERROR: mismatched types:\n- //~| expected `()`,\n- //~|    found `*mut Trait`\n- //~| (expected (),\n- //~|    found *-ptr) [E0308]\n+ //~^ ERROR: mismatched types\n+ //~| NOTE: expected type `()`\n+ //~| NOTE:    found type `*mut Trait`\n+ //~| NOTE: expected (), found *-ptr\n }\n \n fn main() { }"}, {"sha": "b368daaaf587c15cf874979d1a2ce9ec93c5d161", "filename": "src/test/compile-fail/issue-19991.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-19991.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-19991.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19991.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -13,10 +13,9 @@\n \n fn main() {\n     if let Some(homura) = Some(\"madoka\") { //~  ERROR missing an else clause\n-                                           //~| expected `()`\n-                                           //~| found `_`\n-                                           //~| expected ()\n-                                           //~| found integral variable\n+                                           //~| expected type `()`\n+                                           //~| found type `_`\n+                                           //~| expected (), found integral variable\n         765\n     };\n }"}, {"sha": "ac7e0f2e9a8678b1ee2f0ee9d60a963249f44f8b", "filename": "src/test/compile-fail/issue-24036.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-24036.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-24036.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-24036.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -14,6 +14,9 @@ fn closure_to_loc() {\n     //~^ ERROR mismatched types\n     //~| NOTE no two closures, even if identical, have the same type\n     //~| HELP consider boxing your closure and/or using it as a trait object\n+    //~| expected closure, found a different closure\n+    //~| expected type `[closure\n+    //~| found type `[closure\n }\n \n fn closure_from_match() {\n@@ -26,6 +29,9 @@ fn closure_from_match() {\n     //~^^^^^^ ERROR match arms have incompatible types\n     //~| NOTE no two closures, even if identical, have the same type\n     //~| HELP consider boxing your closure and/or using it as a trait object\n+    //~| expected closure, found a different closure\n+    //~| expected type `[closure\n+    //~| found type `[closure\n }\n \n fn main() { }"}, {"sha": "5d6b989fc968ac8c818b96d70eb5041716a878e1", "filename": "src/test/compile-fail/issue-24357.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-24357.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-24357.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-24357.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -12,7 +12,9 @@ struct NoCopy;\n fn main() {\n    let x = NoCopy;\n    let f = move || { let y = x; };\n-   //~^ NOTE `x` moved into closure environment here because it has type `NoCopy`\n+   //~^ value moved (into closure) here\n    let z = x;\n    //~^ ERROR use of moved value: `x`\n+   //~| value used here after move\n+   //~| move occurs because `x` has type `NoCopy`\n }"}, {"sha": "cbeac77479811fc8d37096d842f4df40473ae24f", "filename": "src/test/compile-fail/issue-24446.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-24446.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-24446.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-24446.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -10,7 +10,7 @@\n \n fn main() {\n     static foo: Fn() -> u32 = || -> u32 {\n-        //~^ ERROR: mismatched types:\n+        //~^ ERROR: mismatched types\n         0\n     };\n }"}, {"sha": "adcf8484f78285b4dbe67b59fa17120bd87ec2a9", "filename": "src/test/compile-fail/issue-26480.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-26480.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-26480.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26480.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -25,6 +25,7 @@ macro_rules! write {\n             write(stdout, $arr.as_ptr() as *const i8,\n                   $arr.len() * size_of($arr[0]));\n             //~^ ERROR mismatched types\n+            //~| expected u64, found usize\n         }\n     }}\n }"}, {"sha": "bdcbaf09177fe8c2e53c0aeb82262de6890e0a98", "filename": "src/test/compile-fail/issue-27008.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-27008.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-27008.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27008.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -13,9 +13,8 @@ struct S;\n fn main() {\n     let b = [0; S];\n     //~^ ERROR mismatched types\n-    //~| expected `usize`\n-    //~| found `S`\n-    //~| expected usize\n-    //~| found struct `S`\n+    //~| expected type `usize`\n+    //~| found type `S`\n+    //~| expected usize, found struct `S`\n     //~| ERROR expected positive integer for repeat count, found struct\n }"}, {"sha": "00d2969a0f67d153ed10b9b1ef60995eea921019", "filename": "src/test/compile-fail/issue-29084.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-29084.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-29084.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-29084.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -13,10 +13,13 @@ macro_rules! foo {\n         fn bar(d: u8) { }\n         bar(&mut $d);\n         //~^ ERROR mismatched types\n+        //~| expected u8, found &-ptr\n+        //~| expected type `u8`\n+        //~| found type `&mut u8`\n     }}\n }\n \n fn main() {\n     foo!(0u8);\n-    //~^ NOTE in this expansion of foo!\n+    //~^ in this expansion of foo!\n }"}, {"sha": "11ff7ab2476b9475f3fbf897875cdddb7e1f96cd", "filename": "src/test/compile-fail/issue-2951.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-2951.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-2951.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2951.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -12,10 +12,9 @@ fn foo<T, U>(x: T, y: U) {\n     let mut xx = x;\n     xx = y;\n     //~^  ERROR mismatched types\n-    //~| expected `T`\n-    //~| found `U`\n-    //~| expected type parameter\n-    //~| found a different type parameter\n+    //~| expected type `T`\n+    //~| found type `U`\n+    //~| expected type parameter, found a different type parameter\n }\n \n fn main() {"}, {"sha": "0bad7372a12d993ce9020ddd06dc2edd9ce94fc0", "filename": "src/test/compile-fail/issue-3477.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-3477.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-3477.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3477.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -11,6 +11,5 @@\n fn main() {\n     let _p: char = 100;\n     //~^ ERROR mismatched types\n-    //~| expected `char`\n-    //~| found `u8`\n+    //~| expected char, found u8\n }"}, {"sha": "e698e6da5294efd113c48e459e9caa0e3d931635", "filename": "src/test/compile-fail/issue-3680.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-3680.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-3680.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3680.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -12,9 +12,8 @@ fn main() {\n     match None {\n         Err(_) => ()\n         //~^ ERROR mismatched types\n-        //~| expected `std::option::Option<_>`\n-        //~| found `std::result::Result<_, _>`\n-        //~| expected enum `std::option::Option`\n-        //~| found enum `std::result::Result`\n+        //~| expected type `std::option::Option<_>`\n+        //~| found type `std::result::Result<_, _>`\n+        //~| expected enum `std::option::Option`, found enum `std::result::Result`\n     }\n }"}, {"sha": "58423341cc6f0e88e283a338f69e8e8d367e1905", "filename": "src/test/compile-fail/issue-4201.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-4201.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-4201.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4201.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -13,10 +13,9 @@ fn main() {\n         0\n     } else if false {\n //~^ ERROR if may be missing an else clause\n-//~| expected `()`\n-//~| found `_`\n-//~| expected ()\n-//~| found integral variable\n+//~| expected type `()`\n+//~| found type `_`\n+//~| expected (), found integral variable\n         1\n     };\n }"}, {"sha": "fbd8972cbfaa6afa79505f8497ce4f8a3d5cd66a", "filename": "src/test/compile-fail/issue-4517.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-4517.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-4517.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4517.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -14,8 +14,7 @@ fn main() {\n     let foo: [u8; 4] = [1; 4];\n     bar(foo);\n     //~^ ERROR mismatched types\n-    //~| expected `usize`\n-    //~| found `[u8; 4]`\n-    //~| expected usize\n-    //~| found array of 4 elements\n+    //~| expected type `usize`\n+    //~| found type `[u8; 4]`\n+    //~| expected usize, found array of 4 elements\n }"}, {"sha": "7c0905873df8900f961438f2cc49cb9a841a77e3", "filename": "src/test/compile-fail/issue-4968.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-4968.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-4968.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4968.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -14,8 +14,7 @@ const A: (isize,isize) = (4,2);\n fn main() {\n     match 42 { A => () }\n     //~^ ERROR mismatched types\n-    //~| expected `_`\n-    //~| found `(isize, isize)`\n-    //~| expected integral variable\n-    //~| found tuple\n+    //~| expected type `_`\n+    //~| found type `(isize, isize)`\n+    //~| expected integral variable, found tuple\n }"}, {"sha": "9e78b7b947f98e9c3e6681074e8a71556dcc8eda", "filename": "src/test/compile-fail/issue-5100.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -16,48 +16,43 @@ enum A { B, C }\n fn main() {\n     match (true, false) {\n         A::B => (),\n-//~^ ERROR mismatched types:\n-//~| expected `(bool, bool)`\n-//~| found `A`\n-//~| expected tuple\n-//~| found enum `A`\n+//~^ ERROR mismatched types\n+//~| expected type `(bool, bool)`\n+//~| found type `A`\n+//~| expected tuple, found enum `A`\n         _ => ()\n     }\n \n     match (true, false) {\n         (true, false, false) => ()\n //~^ ERROR mismatched types\n-//~| expected `(bool, bool)`\n-//~| found `(_, _, _)`\n-//~| expected a tuple with 2 elements\n-//~| found one with 3 elements\n+//~| expected type `(bool, bool)`\n+//~| found type `(_, _, _)`\n+//~| expected a tuple with 2 elements, found one with 3 elements\n     }\n \n     match (true, false) {\n         (true, false, false) => ()\n //~^ ERROR mismatched types\n-//~| expected `(bool, bool)`\n-//~| found `(_, _, _)`\n-//~| expected a tuple with 2 elements\n-//~| found one with 3 elements\n+//~| expected type `(bool, bool)`\n+//~| found type `(_, _, _)`\n+//~| expected a tuple with 2 elements, found one with 3 elements\n     }\n \n     match (true, false) {\n         box (true, false) => ()\n //~^ ERROR mismatched types\n-//~| expected `(bool, bool)`\n-//~| found `Box<_>`\n-//~| expected tuple\n-//~| found box\n+//~| expected type `(bool, bool)`\n+//~| found type `Box<_>`\n+//~| expected tuple, found box\n     }\n \n     match (true, false) {\n         &(true, false) => ()\n //~^ ERROR mismatched types\n-//~| expected `(bool, bool)`\n-//~| found `&_`\n-//~| expected tuple\n-//~| found &-ptr\n+//~| expected type `(bool, bool)`\n+//~| found type `&_`\n+//~| expected tuple, found &-ptr\n     }\n \n \n@@ -69,6 +64,5 @@ fn main() {\n \n     // Make sure none of the errors above were fatal\n     let x: char = true; //~  ERROR mismatched types\n-                        //~| expected `char`\n-                        //~| found `bool`\n+                        //~| expected char, found bool\n }"}, {"sha": "d8aad54fd3ee9f8ecc4d84f4ff24ae265dd63e36", "filename": "src/test/compile-fail/issue-5358-1.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-5358-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-5358-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5358-1.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -15,10 +15,9 @@ fn main() {\n     match S(Either::Left(5)) {\n         Either::Right(_) => {}\n         //~^ ERROR mismatched types\n-        //~| expected `S`\n-        //~| found `Either<_, _>`\n-        //~| expected struct `S`\n-        //~| found enum `Either`\n+        //~| expected type `S`\n+        //~| found type `Either<_, _>`\n+        //~| expected struct `S`, found enum `Either`\n         _ => {}\n     }\n }"}, {"sha": "cacbf7656def2f4bf5d27cfbd558280663889c9f", "filename": "src/test/compile-fail/issue-5500.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-5500.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-5500.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5500.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -11,8 +11,7 @@\n fn main() {\n     &panic!()\n     //~^ ERROR mismatched types\n-    //~| expected `()`\n-    //~| found `&_`\n-    //~| expected ()\n-    //~| found &-ptr\n+    //~| expected type `()`\n+    //~| found type `&_`\n+    //~| expected (), found &-ptr\n }"}, {"sha": "1519d71dd3be26e92a1110bd6b183eb9e3dd200a", "filename": "src/test/compile-fail/issue-7061.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-7061.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-7061.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7061.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -13,10 +13,9 @@ struct BarStruct;\n impl<'a> BarStruct {\n     fn foo(&'a mut self) -> Box<BarStruct> { self }\n     //~^ ERROR mismatched types\n-    //~| expected `Box<BarStruct>`\n-    //~| found `&'a mut BarStruct`\n-    //~| expected box\n-    //~| found &-ptr\n+    //~| expected type `Box<BarStruct>`\n+    //~| found type `&'a mut BarStruct`\n+    //~| expected box, found &-ptr\n }\n \n fn main() {}"}, {"sha": "26e1597b1db4b3fae82dd1d95616b42adef83c58", "filename": "src/test/compile-fail/issue-7092.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-7092.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-7092.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7092.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -15,10 +15,9 @@ fn foo(x: Whatever) {\n     match x {\n         Some(field) =>\n //~^ ERROR mismatched types\n-//~| expected `Whatever`\n-//~| found `std::option::Option<_>`\n-//~| expected enum `Whatever`\n-//~| found enum `std::option::Option`\n+//~| expected type `Whatever`\n+//~| found type `std::option::Option<_>`\n+//~| expected enum `Whatever`, found enum `std::option::Option`\n             field.access(),\n     }\n }"}, {"sha": "e0de860b0eac30ef260b9bf75f1d3c678e27c813", "filename": "src/test/compile-fail/issue-7867.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-7867.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-7867.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7867.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -16,25 +16,22 @@ fn main() {\n     match (true, false) {\n         A::B => (),\n         //~^ ERROR mismatched types\n-        //~| expected `(bool, bool)`\n-        //~| found `A`\n-        //~| expected tuple\n-        //~| found enum `A`\n+        //~| expected type `(bool, bool)`\n+        //~| found type `A`\n+        //~| expected tuple, found enum `A`\n         _ => ()\n     }\n \n     match &Some(42) {\n         Some(x) => (),\n         //~^ ERROR mismatched types\n-        //~| expected `&std::option::Option<_>`\n-        //~| found `std::option::Option<_>`\n-        //~| expected &-ptr\n-        //~| found enum `std::option::Option`\n+        //~| expected type `&std::option::Option<_>`\n+        //~| found type `std::option::Option<_>`\n+        //~| expected &-ptr, found enum `std::option::Option`\n         None => ()\n         //~^ ERROR mismatched types\n-        //~| expected `&std::option::Option<_>`\n-        //~| found `std::option::Option<_>`\n-        //~| expected &-ptr\n-        //~| found enum `std::option::Option`\n+        //~| expected type `&std::option::Option<_>`\n+        //~| found type `std::option::Option<_>`\n+        //~| expected &-ptr, found enum `std::option::Option`\n     }\n }"}, {"sha": "9295eeb1779b09f522c1870457e47299038acb49", "filename": "src/test/compile-fail/issue-9575.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-9575.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fissue-9575.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-9575.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -12,6 +12,6 @@\n \n #[start]\n fn start(argc: isize, argv: *const *const u8, crate_map: *const u8) -> isize {\n-    //~^ ERROR incorrect number of function parameters\n+    //~^ start function has wrong type\n    0\n }"}, {"sha": "7434a6c960b2db6261936416c9e6261b0e9e35f3", "filename": "src/test/compile-fail/main-wrong-type-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type-2.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() -> char {\n-//~^ ERROR: main function expects type\n+//~^ ERROR: main function has wrong type\n }"}, {"sha": "431b855d5177373cfcabd13a747e6f90dbe86e48", "filename": "src/test/compile-fail/main-wrong-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -14,5 +14,5 @@ struct S {\n }\n \n fn main(foo: S) {\n-//~^ ERROR: main function expects type\n+//~^ ERROR: main function has wrong type\n }"}, {"sha": "526aa83dec7fd2410b4539818b2265c5cbf91256", "filename": "src/test/compile-fail/match-range-fail.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fmatch-range-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fmatch-range-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-range-fail.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -28,6 +28,5 @@ fn main() {\n         _ => { }\n     };\n     //~^^^ ERROR mismatched types in range\n-    //~| expected char\n-    //~| found integral variable\n+    //~| expected char, found integral variable\n }"}, {"sha": "0dbdda1f9ba1e120f7d227b7142d8b9151c91112", "filename": "src/test/compile-fail/match-struct.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fmatch-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fmatch-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-struct.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -16,10 +16,9 @@ fn main() {\n     match (S { a: 1 }) {\n         E::C(_) => (),\n         //~^ ERROR mismatched types\n-        //~| expected `S`\n-        //~| found `E`\n-        //~| expected struct `S`\n-        //~| found enum `E`\n+        //~| expected type `S`\n+        //~| found type `E`\n+        //~| expected struct `S`, found enum `E`\n         _ => ()\n     }\n }"}, {"sha": "2831499c73d8732e5dd676ca3360631524e4f145", "filename": "src/test/compile-fail/match-vec-mismatch-2.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch-2.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -14,9 +14,8 @@ fn main() {\n     match () {\n         [()] => { }\n         //~^ ERROR mismatched types\n-        //~| expected `()`\n-        //~| found `&[_]`\n-        //~| expected ()\n-        //~| found &-ptr\n+        //~| expected type `()`\n+        //~| found type `&[_]`\n+        //~| expected (), found &-ptr\n     }\n }"}, {"sha": "ffa5287d4b2c34d5ae5a770642ed2650ece23a4a", "filename": "src/test/compile-fail/method-self-arg-1.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fmethod-self-arg-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fmethod-self-arg-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-self-arg-1.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -19,13 +19,11 @@ impl Foo {\n fn main() {\n     let x = Foo;\n     Foo::bar(x); //~  ERROR mismatched types\n-                 //~| expected `&Foo`\n-                 //~| found `Foo`\n-                 //~| expected &-ptr\n-                 //~| found struct `Foo`\n+                 //~| expected type `&Foo`\n+                 //~| found type `Foo`\n+                 //~| expected &-ptr, found struct `Foo`\n     Foo::bar(&42); //~  ERROR mismatched types\n-                      //~| expected `&Foo`\n-                      //~| found `&_`\n-                      //~| expected struct `Foo`\n-                      //~| found integral variable\n+                      //~| expected type `&Foo`\n+                      //~| found type `&_`\n+                      //~| expected struct `Foo`, found integral variable\n }"}, {"sha": "02c09aa7d69a261e1f36a03d12318ff2a5cccf7e", "filename": "src/test/compile-fail/moves-based-on-type-distribute-copy-over-paren.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-distribute-copy-over-paren.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-distribute-copy-over-paren.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-distribute-copy-over-paren.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -16,13 +16,17 @@ fn touch<A>(_a: &A) {}\n \n fn f00() {\n     let x = \"hi\".to_string();\n-    let _y = Foo { f:x }; //~ NOTE `x` moved here\n+    let _y = Foo { f:x };\n+    //~^ value moved here\n     touch(&x); //~ ERROR use of moved value: `x`\n+    //~^ value used here after move\n+    //~| move occurs because `x` has type `std::string::String`\n }\n \n fn f05() {\n     let x = \"hi\".to_string();\n-    let _y = Foo { f:(((x))) }; //~ NOTE `x` moved here\n+    let _y = Foo { f:(((x))) };\n+    //~^ value moved here\n     touch(&x); //~ ERROR use of moved value: `x`\n }\n "}, {"sha": "bcbb8dbfad121889f68dd449358d3e49882c6382", "filename": "src/test/compile-fail/moves-based-on-type-match-bindings.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-match-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-match-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-match-bindings.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -24,6 +24,8 @@ fn f10() {\n     };\n \n     touch(&x); //~ ERROR use of partially moved value: `x`\n+    //~^ value used here after move\n+    //~| move occurs because `x.f` has type `std::string::String`\n }\n \n fn main() {}"}, {"sha": "63e7dbd30def2fcf96fe647e0f55dc314646b4e7", "filename": "src/test/compile-fail/mut-pattern-mismatched.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fmut-pattern-mismatched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fmut-pattern-mismatched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmut-pattern-mismatched.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -14,17 +14,17 @@ fn main() {\n     // (separate lines to ensure the spans are accurate)\n \n      let &_ //~  ERROR mismatched types\n-            //~| expected `&mut _`\n-            //~| found `&_`\n+            //~| expected type `&mut _`\n+            //~| found type `&_`\n             //~| values differ in mutability\n         = foo;\n     let &mut _ = foo;\n \n     let bar = &1;\n     let &_ = bar;\n     let &mut _ //~  ERROR mismatched types\n-               //~| expected `&_`\n-               //~| found `&mut _`\n+               //~| expected type `&_`\n+               //~| found type `&mut _`\n                //~| values differ in mutability\n          = bar;\n }"}, {"sha": "c950ef5b680022d3ba8d001258f82cc565c92ae4", "filename": "src/test/compile-fail/noexporttypeexe.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fnoexporttypeexe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fnoexporttypeexe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnoexporttypeexe.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -19,8 +19,7 @@ fn main() {\n     // not convertible to a path.\n   let x: isize = noexporttypelib::foo();\n     //~^ ERROR mismatched types\n-    //~| expected `isize`\n-    //~| found `std::option::Option<isize>`\n-    //~| expected isize\n-    //~| found enum `std::option::Option`\n+    //~| expected type `isize`\n+    //~| found type `std::option::Option<isize>`\n+    //~| expected isize, found enum `std::option::Option`\n }"}, {"sha": "5cb60079fa4b8e8fb272346010c88ed3352f1298", "filename": "src/test/compile-fail/occurs-check-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Foccurs-check-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Foccurs-check-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foccurs-check-2.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -16,7 +16,7 @@ fn main() {\n     g = f;\n     f = box g;\n     //~^  ERROR mismatched types\n-    //~| expected `_`\n-    //~| found `Box<_>`\n+    //~| expected type `_`\n+    //~| found type `Box<_>`\n     //~| cyclic type of infinite size\n }"}, {"sha": "499124cb0573b85ebf734717aa8e14098078ebcf", "filename": "src/test/compile-fail/occurs-check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -14,7 +14,7 @@ fn main() {\n     let f;\n     f = box f;\n     //~^ ERROR mismatched types\n-    //~| expected `_`\n-    //~| found `Box<_>`\n+    //~| expected type `_`\n+    //~| found type `Box<_>`\n     //~| cyclic type of infinite size\n }"}, {"sha": "d9f3bb3c40f8d0d18a2b137ad81dfb6aec75cbf5", "filename": "src/test/compile-fail/pattern-error-continue.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fpattern-error-continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fpattern-error-continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-error-continue.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -31,17 +31,15 @@ fn main() {\n     match 'c' {\n         S { .. } => (),\n         //~^ ERROR mismatched types\n-        //~| expected `char`\n-        //~| found `S`\n-        //~| expected char\n-        //~| found struct `S`\n+        //~| expected type `char`\n+        //~| found type `S`\n+        //~| expected char, found struct `S`\n \n         _ => ()\n     }\n     f(true);\n     //~^ ERROR mismatched types\n-    //~| expected `char`\n-    //~| found `bool`\n+    //~| expected char, found bool\n \n     match () {\n         E::V => {} //~ ERROR failed to resolve. Use of undeclared type or module `E`"}, {"sha": "7ece52e75378603813be2d02710378e23dcefac5", "filename": "src/test/compile-fail/pptypedef.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fpptypedef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fpptypedef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpptypedef.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -13,11 +13,9 @@ fn let_in<T, F>(x: T, f: F) where F: FnOnce(T) {}\n fn main() {\n     let_in(3u32, |i| { assert!(i == 3i32); });\n     //~^ ERROR mismatched types\n-    //~| expected `u32`\n-    //~| found `i32`\n+    //~| expected u32, found i32\n \n     let_in(3i32, |i| { assert!(i == 3u32); });\n     //~^ ERROR mismatched types\n-    //~| expected `i32`\n-    //~| found `u32`\n+    //~| expected i32, found u32\n }"}, {"sha": "ff627e69d4c58f6d4d521a25030f895329ec2a59", "filename": "src/test/compile-fail/ptr-coercion.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fptr-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fptr-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fptr-coercion.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -15,19 +15,19 @@ pub fn main() {\n     // *const -> *mut\n     let x: *const isize = &42;\n     let x: *mut isize = x; //~  ERROR mismatched types\n-                           //~| expected `*mut isize`\n-                           //~| found `*const isize`\n+                           //~| expected type `*mut isize`\n+                           //~| found type `*const isize`\n                            //~| values differ in mutability\n \n     // & -> *mut\n     let x: *mut isize = &42; //~  ERROR mismatched types\n-                             //~| expected `*mut isize`\n-                             //~| found `&isize`\n+                             //~| expected type `*mut isize`\n+                             //~| found type `&isize`\n                              //~| values differ in mutability\n \n     let x: *const isize = &42;\n     let x: *mut isize = x; //~  ERROR mismatched types\n-                           //~| expected `*mut isize`\n-                           //~| found `*const isize`\n+                           //~| expected type `*mut isize`\n+                           //~| found type `*const isize`\n                            //~| values differ in mutability\n }"}, {"sha": "0a0867195d97600def9d4e8984cd52ea871abe93", "filename": "src/test/compile-fail/ref-suggestion.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fref-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fref-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fref-suggestion.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -11,22 +11,16 @@\n fn main() {\n     let x = vec![1];\n     let y = x;\n-    //~^ HELP use a `ref` binding as shown\n-    //~| SUGGESTION let ref y = x;\n     x; //~ ERROR use of moved value\n \n     let x = vec![1];\n     let mut y = x;\n-    //~^ HELP use a `ref` binding as shown\n-    //~| SUGGESTION let ref mut y = x;\n     x; //~ ERROR use of moved value\n \n     let x = (Some(vec![1]), ());\n \n     match x {\n         (Some(y), ()) => {},\n-        //~^ HELP use a `ref` binding as shown\n-        //~| SUGGESTION (Some(ref y), ()) => {},\n         _ => {},\n     }\n     x; //~ ERROR use of partially moved value"}, {"sha": "64dbf27b78e48141457dd4e565c0434c28e1b8d2", "filename": "src/test/compile-fail/regions-bounds.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -17,15 +17,15 @@ struct a_class<'a> { x:&'a isize }\n \n fn a_fn1<'a,'b>(e: an_enum<'a>) -> an_enum<'b> {\n     return e; //~  ERROR mismatched types\n-              //~| expected `an_enum<'b>`\n-              //~| found `an_enum<'a>`\n+              //~| expected type `an_enum<'b>`\n+              //~| found type `an_enum<'a>`\n               //~| lifetime mismatch\n }\n \n fn a_fn3<'a,'b>(e: a_class<'a>) -> a_class<'b> {\n     return e; //~  ERROR mismatched types\n-              //~| expected `a_class<'b>`\n-              //~| found `a_class<'a>`\n+              //~| expected type `a_class<'b>`\n+              //~| found type `a_class<'a>`\n               //~| lifetime mismatch\n }\n "}, {"sha": "f6a0c86de6626ec01f16d39d37ad13d375acdb07", "filename": "src/test/compile-fail/regions-early-bound-error-method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error-method.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -29,8 +29,8 @@ impl<'a> Box<'a> {\n     fn or<'b,G:GetRef<'b>>(&self, g2: G) -> &'a isize {\n         g2.get()\n         //~^ ERROR mismatched types\n-        //~| expected `&'a isize`\n-        //~| found `&'b isize`\n+        //~| expected type `&'a isize`\n+        //~| found type `&'b isize`\n         //~| lifetime mismatch\n \n     }"}, {"sha": "c0116b21166e0350429cc6063306b82bf5b22fac", "filename": "src/test/compile-fail/regions-fn-subtyping-return-static.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping-return-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping-return-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping-return-static.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -55,10 +55,9 @@ fn supply_G() {\n     want_G(bar);\n     want_G(baz);\n     //~^ ERROR mismatched types\n-    //~| expected `fn(&'cx S) -> &'static S`\n-    //~| found `fn(&S) -> &S {baz}`\n-    //~| expected concrete lifetime\n-    //~| found bound lifetime parameter 'cx\n+    //~| expected type `fn(&'cx S) -> &'static S`\n+    //~| found type `fn(&S) -> &S {baz}`\n+    //~| expected concrete lifetime, found bound lifetime parameter 'cx\n }\n \n pub fn main() {"}, {"sha": "131b7170951f6360fea97ebed9adfb6ac9eb6875", "filename": "src/test/compile-fail/regions-infer-not-param.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -27,10 +27,10 @@ fn take_direct<'a,'b>(p: direct<'a>) -> direct<'b> { p } //~ ERROR mismatched ty\n fn take_indirect1(p: indirect1) -> indirect1 { p }\n \n fn take_indirect2<'a,'b>(p: indirect2<'a>) -> indirect2<'b> { p } //~ ERROR mismatched types\n-//~| expected `indirect2<'b>`\n-//~| found `indirect2<'a>`\n+//~| expected type `indirect2<'b>`\n+//~| found type `indirect2<'a>`\n //~| ERROR mismatched types\n-//~| expected `indirect2<'b>`\n-//~| found `indirect2<'a>`\n+//~| expected type `indirect2<'b>`\n+//~| found type `indirect2<'a>`\n \n fn main() {}"}, {"sha": "fad115c2aedf83a3d4515a37c4721b5c96d137dc", "filename": "src/test/compile-fail/regions-infer-paramd-indirect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -32,8 +32,8 @@ impl<'a> set_f<'a> for c<'a> {\n     fn set_f_bad(&mut self, b: Box<b>) {\n         self.f = b;\n         //~^ ERROR mismatched types\n-        //~| expected `Box<Box<&'a isize>>`\n-        //~| found `Box<Box<&isize>>`\n+        //~| expected type `Box<Box<&'a isize>>`\n+        //~| found type `Box<Box<&isize>>`\n         //~| lifetime mismatch\n     }\n }"}, {"sha": "1ea956bbd54891f06c8899f784941e49fe897fef", "filename": "src/test/compile-fail/reject-specialized-drops-8142.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Freject-specialized-drops-8142.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Freject-specialized-drops-8142.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Freject-specialized-drops-8142.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -38,8 +38,8 @@ impl<'ml>               Drop for M<'ml>         { fn drop(&mut self) { } } // AC\n \n impl                    Drop for N<'static>     { fn drop(&mut self) { } } // REJECT\n //~^ ERROR mismatched types\n-//~| expected `N<'n>`\n-//~|    found `N<'static>`\n+//~| expected type `N<'n>`\n+//~|    found type `N<'static>`\n \n impl<Cok_nobound> Drop for O<Cok_nobound> { fn drop(&mut self) { } } // ACCEPT\n "}, {"sha": "ab5af64d95c1352d215b1757f29227c17360e458", "filename": "src/test/compile-fail/repeat_count.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -16,52 +16,45 @@ fn main() {\n     //~^ ERROR expected constant integer for repeat count, found variable [E0307]\n     let b = [0; ()];\n     //~^ ERROR mismatched types\n-    //~| expected `usize`\n-    //~| found `()`\n-    //~| expected usize\n-    //~| found ()) [E0308]\n+    //~| expected type `usize`\n+    //~| found type `()`\n+    //~| expected usize, found ()\n     //~| ERROR expected positive integer for repeat count, found tuple [E0306]\n     let c = [0; true];\n     //~^ ERROR mismatched types\n-    //~| expected `usize`\n-    //~| found `bool`\n+    //~| expected usize, found bool\n     //~| ERROR expected positive integer for repeat count, found boolean [E0306]\n     let d = [0; 0.5];\n     //~^ ERROR mismatched types\n-    //~| expected `usize`\n-    //~| found `_`\n-    //~| expected usize\n-    //~| found floating-point variable) [E0308]\n+    //~| expected type `usize`\n+    //~| found type `_`\n+    //~| expected usize, found floating-point variable\n     //~| ERROR expected positive integer for repeat count, found float [E0306]\n     let e = [0; \"foo\"];\n     //~^ ERROR mismatched types\n-    //~| expected `usize`\n-    //~| found `&'static str`\n-    //~| expected usize\n-    //~| found &-ptr) [E0308]\n+    //~| expected type `usize`\n+    //~| found type `&'static str`\n+    //~| expected usize, found &-ptr\n     //~| ERROR expected positive integer for repeat count, found string literal [E0306]\n     let f = [0; -4_isize];\n     //~^ ERROR mismatched types\n     //~| expected `usize`\n-    //~| found `isize` [E0308]\n+    //~| found `isize`\n     //~| ERROR mismatched types:\n-    //~| expected `usize`,\n-    //~| found `isize` [E0307]\n+    //~| expected usize, found isize\n     let f = [0_usize; -1_isize];\n     //~^ ERROR mismatched types\n     //~| expected `usize`\n-    //~| found `isize` [E0308]\n+    //~| found `isize`\n     //~| ERROR mismatched types\n-    //~| expected `usize`\n-    //~| found `isize` [E0307]\n+    //~| expected usize, found isize\n     struct G {\n         g: (),\n     }\n     let g = [0; G { g: () }];\n     //~^ ERROR mismatched types\n-    //~| expected `usize`\n-    //~| found `main::G`\n-    //~| expected usize\n-    //~| found struct `main::G`) [E0308]\n+    //~| expected type `usize`\n+    //~| found type `main::G`\n+    //~| expected usize, found struct `main::G`\n     //~| ERROR expected positive integer for repeat count, found struct [E0306]\n }"}, {"sha": "2d06161111ef1f867ea0bbda303b47793391a771", "filename": "src/test/compile-fail/shift-various-bad-types.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fshift-various-bad-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fshift-various-bad-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fshift-various-bad-types.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -34,8 +34,7 @@ fn foo(p: &Panolpy) {\n     // Type of the result follows the LHS, not the RHS:\n     let _: i32 = 22_i64 >> 1_i32;\n     //~^ ERROR mismatched types\n-    //~| expected `i32`\n-    //~| found `i64`\n+    //~| expected i32, found i64\n }\n \n fn main() {"}, {"sha": "874cca8cb3fd03c709282a7712e8a29fe1c6b650", "filename": "src/test/compile-fail/slice-mut.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -16,7 +16,7 @@ fn main() {\n \n     let y: &mut[_] = &x[2..4];\n     //~^ ERROR mismatched types\n-    //~| expected `&mut [_]`\n-    //~| found `&[isize]`\n+    //~| expected type `&mut [_]`\n+    //~| found type `&[isize]`\n     //~| values differ in mutability\n }"}, {"sha": "3140bb6e5731d04d5822800e32fd00eb06dceb09", "filename": "src/test/compile-fail/slightly-nice-generic-literal-messages.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fslightly-nice-generic-literal-messages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fslightly-nice-generic-literal-messages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslightly-nice-generic-literal-messages.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -16,10 +16,9 @@ fn main() {\n     match Foo(1.1, marker::PhantomData) {\n         1 => {}\n     //~^ ERROR mismatched types\n-    //~| expected `Foo<_, _>`\n-    //~| found `_`\n-    //~| expected struct `Foo`\n-    //~| found integral variable\n+    //~| expected type `Foo<_, _>`\n+    //~| found type `_`\n+    //~| expected struct `Foo`, found integral variable\n     }\n \n }"}, {"sha": "1250d0dabcd9a561e87db5a136d2cf65c6e89c76", "filename": "src/test/compile-fail/struct-base-wrong-type-2.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fstruct-base-wrong-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fstruct-base-wrong-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-base-wrong-type-2.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -19,13 +19,11 @@ struct Bar { x: isize }\n fn main() {\n     let b = Bar { x: 5 };\n     let f = Foo { a: 2, ..b }; //~  ERROR mismatched types\n-                               //~| expected `Foo`\n-                               //~| found `Bar`\n-                               //~| expected struct `Foo`\n-                               //~| found struct `Bar`\n+                               //~| expected type `Foo`\n+                               //~| found type `Bar`\n+                               //~| expected struct `Foo`, found struct `Bar`\n     let f__isize = Foo { a: 2, ..4 }; //~  ERROR mismatched types\n-                                 //~| expected `Foo`\n-                                 //~| found `_`\n-                                 //~| expected struct `Foo`\n-                                 //~| found integral variable\n+                                 //~| expected type `Foo`\n+                                 //~| found type `_`\n+                                 //~| expected struct `Foo`, found integral variable\n }"}, {"sha": "4503e465840fe73bfb6f5b0364f52e0f72f82fb7", "filename": "src/test/compile-fail/struct-base-wrong-type.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fstruct-base-wrong-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fstruct-base-wrong-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-base-wrong-type.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -18,15 +18,13 @@ struct Bar { x: isize }\n \n static bar: Bar = Bar { x: 5 };\n static foo: Foo = Foo { a: 2, ..bar }; //~  ERROR mismatched types\n-                                       //~| expected `Foo`\n-                                       //~| found `Bar`\n-                                       //~| expected struct `Foo`\n-                                       //~| found struct `Bar`\n+                                       //~| expected type `Foo`\n+                                       //~| found type `Bar`\n+                                       //~| expected struct `Foo`, found struct `Bar`\n static foo_i: Foo = Foo { a: 2, ..4 }; //~  ERROR mismatched types\n-                                       //~| expected `Foo`\n-                                       //~| found `_`\n-                                       //~| expected struct `Foo`\n-                                       //~| found integral variable\n+                                       //~| expected type `Foo`\n+                                       //~| found type `_`\n+                                       //~| expected struct `Foo`, found integral variable\n \n fn main() {\n     let b = Bar { x: 5 };"}, {"sha": "87fc5ba93aeb3c384e926263c24f8a93dd5d1b78", "filename": "src/test/compile-fail/structure-constructor-type-mismatch.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fstructure-constructor-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fstructure-constructor-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstructure-constructor-type-mismatch.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -26,38 +26,32 @@ fn main() {\n     let pt = PointF {\n         x: 1,\n         //~^ ERROR mismatched types\n-        //~| expected f32\n-        //~| found integral variable\n+        //~| expected f32, found integral variable\n         y: 2,\n         //~^ ERROR mismatched types\n-        //~| expected f32\n-        //~| found integral variable\n+        //~| expected f32, found integral variable\n     };\n \n     let pt2 = Point::<f32> {\n         x: 3,\n         //~^ ERROR mismatched types\n-        //~| expected f32\n-        //~| found integral variable\n+        //~| expected f32, found integral variable\n         y: 4,\n         //~^ ERROR mismatched types\n-        //~| expected f32\n-        //~| found integral variable\n+        //~| expected f32, found integral variable\n     };\n \n     let pair = PairF {\n         x: 5,\n         //~^ ERROR mismatched types\n-        //~| expected f32\n-        //~| found integral variable\n+        //~| expected f32, found integral variable\n         y: 6,\n     };\n \n     let pair2 = PairF::<i32> {\n         x: 7,\n         //~^ ERROR mismatched types\n-        //~| expected f32\n-        //~| found integral variable\n+        //~| expected f32, found integral variable\n         y: 8,\n     };\n "}, {"sha": "c857790e342d0270921b9028c0b0329c2a5b22ae", "filename": "src/test/compile-fail/substs-ppaux.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fsubsts-ppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fsubsts-ppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsubsts-ppaux.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -24,36 +24,36 @@ fn main() {}\n fn foo<'z>() where &'z (): Sized {\n     let x: () = <i8 as Foo<'static, 'static,  u8>>::bar::<'static, char>;\n     //[verbose]~^ ERROR mismatched types\n-    //[verbose]~| expected `()`\n-    //[verbose]~| found `fn() {<i8 as Foo<ReStatic, ReStatic, u8>>::bar::<ReStatic, char>}`\n+    //[verbose]~| expected type `()`\n+    //[verbose]~| found type `fn() {<i8 as Foo<ReStatic, ReStatic, u8>>::bar::<ReStatic, char>}`\n     //[normal]~^^^^ ERROR mismatched types\n-    //[normal]~| expected `()`\n-    //[normal]~| found `fn() {<i8 as Foo<'static, 'static, u8>>::bar::<'static, char>}`\n+    //[normal]~| expected type `()`\n+    //[normal]~| found type `fn() {<i8 as Foo<'static, 'static, u8>>::bar::<'static, char>}`\n \n \n     let x: () = <i8 as Foo<'static, 'static,  u32>>::bar::<'static, char>;\n     //[verbose]~^ ERROR mismatched types\n-    //[verbose]~| expected `()`\n-    //[verbose]~| found `fn() {<i8 as Foo<ReStatic, ReStatic, u32>>::bar::<ReStatic, char>}`\n+    //[verbose]~| expected type `()`\n+    //[verbose]~| found type `fn() {<i8 as Foo<ReStatic, ReStatic, u32>>::bar::<ReStatic, char>}`\n     //[normal]~^^^^ ERROR mismatched types\n-    //[normal]~| expected `()`\n-    //[normal]~| found `fn() {<i8 as Foo<'static, 'static>>::bar::<'static, char>}`\n+    //[normal]~| expected type `()`\n+    //[normal]~| found type `fn() {<i8 as Foo<'static, 'static>>::bar::<'static, char>}`\n \n     let x: () = <i8 as Foo<'static, 'static,  u8>>::baz;\n     //[verbose]~^ ERROR mismatched types\n-    //[verbose]~| expected `()`\n-    //[verbose]~| found `fn() {<i8 as Foo<ReStatic, ReStatic, u8>>::baz}`\n+    //[verbose]~| expected type `()`\n+    //[verbose]~| found type `fn() {<i8 as Foo<ReStatic, ReStatic, u8>>::baz}`\n     //[normal]~^^^^ ERROR mismatched types\n-    //[normal]~| expected `()`\n-    //[normal]~| found `fn() {<i8 as Foo<'static, 'static, u8>>::baz}`\n+    //[normal]~| expected type `()`\n+    //[normal]~| found type `fn() {<i8 as Foo<'static, 'static, u8>>::baz}`\n \n     let x: () = foo::<'static>;\n     //[verbose]~^ ERROR mismatched types\n-    //[verbose]~| expected `()`\n-    //[verbose]~| found `fn() {foo::<ReStatic>}`\n+    //[verbose]~| expected type `()`\n+    //[verbose]~| found type `fn() {foo::<ReStatic>}`\n     //[normal]~^^^^ ERROR mismatched types\n-    //[normal]~| expected `()`\n-    //[normal]~| found `fn() {foo::<'static>}`\n+    //[normal]~| expected type `()`\n+    //[normal]~| found type `fn() {foo::<'static>}`\n \n     <str as Foo<u8>>::bar;\n     //[verbose]~^ ERROR `str: std::marker::Sized` is not satisfied"}, {"sha": "9a4a52ced2008d44cb6346e4c7f0aeda0e41a2b6", "filename": "src/test/compile-fail/suppressed-error.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fsuppressed-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fsuppressed-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsuppressed-error.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -11,9 +11,8 @@\n fn main() {\n     let (x, y) = ();\n //~^ ERROR mismatched types\n-//~| expected `()`\n-//~| found `(_, _)`\n-//~| expected ()\n-//~| found tuple\n+//~| expected type `()`\n+//~| found type `(_, _)`\n+//~| expected (), found tuple\n     return x;\n }"}, {"sha": "8f420f1ce4b0d1d592fd6fa30937a9ebc3e4e52a", "filename": "src/test/compile-fail/tag-that-dare-not-speak-its-name.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -21,8 +21,7 @@ fn main() {\n     let y;\n     let x : char = last(y);\n     //~^ ERROR mismatched types\n-    //~| expected `char`\n-    //~| found `std::option::Option<_>`\n-    //~| expected char\n-    //~| found enum `std::option::Option`\n+    //~| expected type `char`\n+    //~| found type `std::option::Option<_>`\n+    //~| expected char, found enum `std::option::Option`\n }"}, {"sha": "4a21e1339811e748e26c6aef79f1d9b87b896abb", "filename": "src/test/compile-fail/terr-in-field.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fterr-in-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fterr-in-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fterr-in-field.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -21,10 +21,9 @@ struct bar {\n fn want_foo(f: foo) {}\n fn have_bar(b: bar) {\n     want_foo(b); //~  ERROR mismatched types\n-                 //~| expected `foo`\n-                 //~| found `bar`\n-                 //~| expected struct `foo`\n-                 //~| found struct `bar`\n+                 //~| expected type `foo`\n+                 //~| found type `bar`\n+                 //~| expected struct `foo`, found struct `bar`\n }\n \n fn main() {}"}, {"sha": "592d7b3929bfc09129a07f294eec2a744f0a5ecf", "filename": "src/test/compile-fail/terr-sorts.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fterr-sorts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fterr-sorts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fterr-sorts.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -19,10 +19,9 @@ type bar = Box<foo>;\n fn want_foo(f: foo) {}\n fn have_bar(b: bar) {\n     want_foo(b); //~  ERROR mismatched types\n-                 //~| expected `foo`\n-                 //~| found `Box<foo>`\n-                 //~| expected struct `foo`\n-                 //~| found box\n+                 //~| expected type `foo`\n+                 //~| found type `Box<foo>`\n+                 //~| expected struct `foo`, found box\n }\n \n fn main() {}"}, {"sha": "24627e94208748651be95d740ba13fda68e7c7f1", "filename": "src/test/compile-fail/token-error-correct-3.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ftoken-error-correct-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ftoken-error-correct-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftoken-error-correct-3.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -22,6 +22,9 @@ pub mod raw {\n             callback(path.as_ref();  //~ NOTE: unclosed delimiter\n                      //~^ ERROR: expected one of\n             fs::create_dir_all(path.as_ref()).map(|()| true) //~ ERROR: mismatched types\n+            //~^ expected (), found enum `std::result::Result`\n+            //~| expected type `()`\n+            //~| found type `std::result::Result<bool, std::io::Error>`\n         } else { //~ ERROR: incorrect close delimiter: `}`\n             //~^ ERROR: expected one of\n             Ok(false);"}, {"sha": "1fff812af5b8d9f1e00f7941720b870555890ef6", "filename": "src/test/compile-fail/trait-bounds-cant-coerce.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -22,10 +22,9 @@ fn c(x: Box<Foo+Sync+Send>) {\n \n fn d(x: Box<Foo>) {\n     a(x); //~  ERROR mismatched types\n-          //~| expected `Box<Foo + Send + 'static>`\n-          //~| found `Box<Foo + 'static>`\n-          //~| expected bounds `Send`\n-          //~| found no bounds\n+          //~| expected type `Box<Foo + Send + 'static>`\n+          //~| found type `Box<Foo + 'static>`\n+          //~| expected bounds `Send`, found no bounds\n }\n \n fn main() { }"}, {"sha": "e62255a4e77d4301756320a6cd13c25f5f5c69fa", "filename": "src/test/compile-fail/tuple-arity-mismatch.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ftuple-arity-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ftuple-arity-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftuple-arity-mismatch.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -15,15 +15,13 @@ fn first((value, _): (isize, f64)) -> isize { value }\n fn main() {\n     let y = first ((1,2.0,3));\n     //~^ ERROR mismatched types\n-    //~| expected `(isize, f64)`\n-    //~| found `(isize, f64, _)`\n-    //~| expected a tuple with 2 elements\n-    //~| found one with 3 elements\n+    //~| expected type `(isize, f64)`\n+    //~| found type `(isize, f64, _)`\n+    //~| expected a tuple with 2 elements, found one with 3 elements\n \n     let y = first ((1,));\n     //~^ ERROR mismatched types\n-    //~| expected `(isize, f64)`\n-    //~| found `(isize,)`\n-    //~| expected a tuple with 2 elements\n-    //~| found one with 1 elements\n+    //~| expected type `(isize, f64)`\n+    //~| found type `(isize,)`\n+    //~| expected a tuple with 2 elements, found one with 1 elements\n }"}, {"sha": "dadf7eb91d8f46f0b5d74d947a096382a7689dd1", "filename": "src/test/compile-fail/tutorial-suffix-inference-test.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ftutorial-suffix-inference-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ftutorial-suffix-inference-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftutorial-suffix-inference-test.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -18,12 +18,10 @@ fn main() {\n     identity_u8(x);  // after this, `x` is assumed to have type `u8`\n     identity_u16(x);\n     //~^ ERROR mismatched types\n-    //~| expected `u16`\n-    //~| found `u8`\n+    //~| expected u16, found u8\n     identity_u16(y);\n     //~^ ERROR mismatched types\n-    //~| expected `u16`\n-    //~| found `i32`\n+    //~| expected u16, found i32\n \n     let a = 3;\n \n@@ -32,6 +30,5 @@ fn main() {\n     identity_i(a); // ok\n     identity_u16(a);\n     //~^ ERROR mismatched types\n-    //~| expected `u16`\n-    //~| found `isize`\n+    //~| expected u16, found isize\n }"}, {"sha": "0f174d99fefcbe4b5d952776a7ec7d906dc7179a", "filename": "src/test/compile-fail/type-mismatch-multiple.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ftype-mismatch-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ftype-mismatch-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-mismatch-multiple.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -12,11 +12,9 @@\n \n fn main() { let a: bool = 1; let b: i32 = true; }\n //~^ ERROR mismatched types\n-//~| expected `bool`\n-//~| found `_`\n-//~| expected bool\n-//~| found integral variable\n+//~| expected type `bool`\n+//~| found type `_`\n+//~| expected bool, found integral variable\n //~| ERROR mismatched types\n-//~| expected `i32`\n-//~| found `bool`\n+//~| expected i32, found bool\n "}, {"sha": "e74acaa71b0f3d5f347955f5c75d93a3b5089ca3", "filename": "src/test/compile-fail/type-mismatch-same-crate-name.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ftype-mismatch-same-crate-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ftype-mismatch-same-crate-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-mismatch-same-crate-name.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -23,9 +23,17 @@ fn main() {\n     let bar2 = {extern crate crate_a2 as a; a::bar()};\n     {\n         extern crate crate_a1 as a;\n-        a::try_foo(foo2); //~ ERROR mismatched types\n-                          //~^ NOTE Perhaps two different versions of crate `crate_a1`\n-        a::try_bar(bar2); //~ ERROR mismatched types\n-                          //~^ NOTE Perhaps two different versions of crate `crate_a1`\n+        a::try_foo(foo2);\n+        //~^ ERROR mismatched types\n+        //~| Perhaps two different versions of crate `crate_a1`\n+        //~| expected struct `main::a::Foo`\n+        //~| expected type `main::a::Foo`\n+        //~| found type `main::a::Foo`\n+        a::try_bar(bar2);\n+        //~^ ERROR mismatched types\n+        //~| Perhaps two different versions of crate `crate_a1`\n+        //~| expected trait `main::a::Bar`\n+        //~| expected type `Box<main::a::Bar + 'static>`\n+        //~| found type `Box<main::a::Bar>`\n     }\n }"}, {"sha": "11a2fc2665ca46ff56c9731fbe25a123251f1e78", "filename": "src/test/compile-fail/type-parameter-names.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ftype-parameter-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ftype-parameter-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-parameter-names.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -14,10 +14,9 @@\n fn foo<Foo, Bar>(x: Foo) -> Bar {\n     x\n //~^ ERROR mismatched types\n-//~| expected `Bar`\n-//~| found `Foo`\n-//~| expected type parameter\n-//~| found a different type parameter\n+//~| expected type `Bar`\n+//~| found type `Foo`\n+//~| expected type parameter, found a different type parameter\n }\n \n fn main() {}"}, {"sha": "26eac6adde221b296b0804388b6ed4f67e06e6f0", "filename": "src/test/compile-fail/type-params-in-different-spaces-1.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-1.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -13,10 +13,9 @@ use std::ops::Add;\n trait BrokenAdd: Copy + Add<Output=Self> {\n     fn broken_add<T>(&self, rhs: T) -> Self {\n         *self + rhs //~  ERROR mismatched types\n-                    //~| expected `Self`\n-                    //~| found `T`\n-                    //~| expected Self\n-                    //~| found type parameter\n+                    //~| expected type `Self`\n+                    //~| found type `T`\n+                    //~| expected Self, found type parameter\n     }\n }\n "}, {"sha": "91e3c38322e4725ac0e224df5b0c81497b092405", "filename": "src/test/compile-fail/typeck_type_placeholder_mismatch.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ftypeck_type_placeholder_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Ftypeck_type_placeholder_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck_type_placeholder_mismatch.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -22,18 +22,16 @@ pub fn main() {\n fn test1() {\n     let x: Foo<_> = Bar::<usize>(PhantomData);\n     //~^ ERROR mismatched types\n-    //~| expected `Foo<_>`\n-    //~| found `Bar<usize>`\n-    //~| expected struct `Foo`\n-    //~| found struct `Bar`\n+    //~| expected type `Foo<_>`\n+    //~| found type `Bar<usize>`\n+    //~| expected struct `Foo`, found struct `Bar`\n     let y: Foo<usize> = x;\n }\n \n fn test2() {\n     let x: Foo<_> = Bar::<usize>(PhantomData);\n     //~^ ERROR mismatched types\n-    //~| expected `Foo<_>`\n-    //~| found `Bar<usize>`\n-    //~| expected struct `Foo`\n-    //~| found struct `Bar`\n+    //~| expected type `Foo<_>`\n+    //~| found type `Bar<usize>`\n+    //~| expected struct `Foo`, found struct `Bar`\n }"}, {"sha": "f14a3505cdeb486510da18e7f6dd72d2184f8d58", "filename": "src/test/compile-fail/ufcs-explicit-self-bad.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -45,12 +45,12 @@ impl<'a, T> SomeTrait for &'a Bar<T> {\n     //~^ ERROR mismatched types\n     fn dummy3(self: &&Bar<T>) {}\n     //~^ ERROR mismatched types\n-    //~| expected `&&'a Bar<T>`\n-    //~| found `&&Bar<T>`\n+    //~| expected type `&&'a Bar<T>`\n+    //~| found type `&&Bar<T>`\n     //~| lifetime mismatch\n     //~| ERROR mismatched types\n-    //~| expected `&&'a Bar<T>`\n-    //~| found `&&Bar<T>`\n+    //~| expected type `&&'a Bar<T>`\n+    //~| found type `&&Bar<T>`\n     //~| lifetime mismatch\n }\n "}, {"sha": "b43159b0d96b042fbd51c2494632730897602223", "filename": "src/test/compile-fail/variadic-ffi-3.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-3.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -21,17 +21,15 @@ fn main() {\n \n         let x: unsafe extern \"C\" fn(f: isize, x: u8) = foo;\n         //~^ ERROR: mismatched types\n-        //~| expected `unsafe extern \"C\" fn(isize, u8)`\n-        //~| found `unsafe extern \"C\" fn(isize, u8, ...) {foo}`\n-        //~| expected non-variadic fn\n-        //~| found variadic function\n+        //~| expected type `unsafe extern \"C\" fn(isize, u8)`\n+        //~| found type `unsafe extern \"C\" fn(isize, u8, ...) {foo}`\n+        //~| NOTE: expected non-variadic fn, found variadic function\n \n         let y: extern \"C\" fn(f: isize, x: u8, ...) = bar;\n         //~^ ERROR: mismatched types\n-        //~| expected `extern \"C\" fn(isize, u8, ...)`\n-        //~| found `extern \"C\" fn(isize, u8) {bar}`\n-        //~| expected variadic fn\n-        //~| found non-variadic function\n+        //~| expected type `extern \"C\" fn(isize, u8, ...)`\n+        //~| found type `extern \"C\" fn(isize, u8) {bar}`\n+        //~| NOTE: expected variadic fn, found non-variadic function\n \n         foo(1, 2, 3f32); //~ ERROR: can't pass an `f32` to variadic function, cast to `c_double`\n         foo(1, 2, true); //~ ERROR: can't pass `bool` to variadic function, cast to `c_int`"}, {"sha": "30bcafd104945cfa5e775fe59a56aef81665b215", "filename": "src/test/run-make/json-errors/Makefile", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d80497e628945c3f11ff351030b4c62a8533e01e/src%2Ftest%2Frun-make%2Fjson-errors%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d80497e628945c3f11ff351030b4c62a8533e01e/src%2Ftest%2Frun-make%2Fjson-errors%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fjson-errors%2FMakefile?ref=d80497e628945c3f11ff351030b4c62a8533e01e", "patch": "@@ -1,9 +0,0 @@\n--include ../tools.mk\n-\n-LOG := $(TMPDIR)/foo.log\n-\n-all:\n-\tcp foo.rs $(TMPDIR)\n-\tcd $(TMPDIR)\n-\t-$(RUSTC) -Z unstable-options --error-format=json foo.rs 2>$(LOG)\n-\tdiff foo.json $(LOG)"}, {"sha": "bde669ab0f7f99b6f19076013da9def608a54098", "filename": "src/test/run-make/json-errors/foo.json", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d80497e628945c3f11ff351030b4c62a8533e01e/src%2Ftest%2Frun-make%2Fjson-errors%2Ffoo.json", "raw_url": "https://github.com/rust-lang/rust/raw/d80497e628945c3f11ff351030b4c62a8533e01e/src%2Ftest%2Frun-make%2Fjson-errors%2Ffoo.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fjson-errors%2Ffoo.json?ref=d80497e628945c3f11ff351030b4c62a8533e01e", "patch": "@@ -1,4 +0,0 @@\n-{\"message\":\"unresolved name `y`\",\"code\":{\"code\":\"E0425\",\"explanation\":\"\\nAn unresolved name was used. Example of erroneous codes:\\n\\n```compile_fail\\nsomething_that_doesnt_exist::foo;\\n// error: unresolved name `something_that_doesnt_exist::foo`\\n\\n// or:\\n\\ntrait Foo {\\n    fn bar() {\\n        Self; // error: unresolved name `Self`\\n    }\\n}\\n\\n// or:\\n\\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\\n```\\n\\nPlease verify that the name wasn't misspelled and ensure that the\\nidentifier being referred to is valid for the given situation. Example:\\n\\n```\\nenum something_that_does_exist {\\n    Foo,\\n}\\n```\\n\\nOr:\\n\\n```\\nmod something_that_does_exist {\\n    pub static foo : i32 = 0i32;\\n}\\n\\nsomething_that_does_exist::foo; // ok!\\n```\\n\\nOr:\\n\\n```\\nlet unknown_variable = 12u32;\\nlet x = unknown_variable; // ok!\\n```\\n\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"foo.rs\",\"byte_start\":496,\"byte_end\":497,\"line_start\":12,\"line_end\":12,\"column_start\":18,\"column_end\":19,\"text\":[{\"text\":\"    let x = 42 + y;\",\"highlight_start\":18,\"highlight_end\":19}],\"suggested_replacement\":null,\"expansion\":null}],\"children\":[],\"rendered\":null}\n-{\"message\":\"mismatched types:\\n expected `u8`,\\n    found `i32`\",\"code\":{\"code\":\"E0308\",\"explanation\":\"\\nThis error occurs when the compiler was unable to infer the concrete type of a\\nvariable. It can occur for several cases, the most common of which is a\\nmismatch in the expected type that the compiler inferred for a variable's\\ninitializing expression, and the actual type explicitly assigned to the\\nvariable.\\n\\nFor example:\\n\\n```compile_fail\\nlet x: i32 = \\\"I am not a number!\\\";\\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\\n//      |             |\\n//      |    initializing expression;\\n//      |    compiler infers type `&str`\\n//      |\\n//    type `i32` assigned to variable `x`\\n```\\n\\nAnother situation in which this occurs is when you attempt to use the `try!`\\nmacro inside a function that does not return a `Result<T, E>`:\\n\\n```compile_fail\\nuse std::fs::File;\\n\\nfn main() {\\n    let mut f = try!(File::create(\\\"foo.txt\\\"));\\n}\\n```\\n\\nThis code gives an error like this:\\n\\n```text\\n<std macros>:5:8: 6:42 error: mismatched types:\\n expected `()`,\\n     found `core::result::Result<_, _>`\\n (expected (),\\n     found enum `core::result::Result`) [E0308]\\n```\\n\\n`try!` returns a `Result<T, E>`, and so the function must. But `main()` has\\n`()` as its return type, hence the error.\\n\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"foo.rs\",\"byte_start\":511,\"byte_end\":516,\"line_start\":14,\"line_end\":14,\"column_start\":12,\"column_end\":17,\"text\":[{\"text\":\"    42u8 + 42i32;\",\"highlight_start\":12,\"highlight_end\":17}],\"suggested_replacement\":null,\"expansion\":null}],\"children\":[],\"rendered\":null}\n-{\"message\":\"the trait bound `u8: std::ops::Add<i32>` is not satisfied\",\"code\":{\"code\":\"E0277\",\"explanation\":\"\\nYou tried to use a type which doesn't implement some trait in a place which\\nexpected that trait. Erroneous code example:\\n\\n```compile_fail\\n// here we declare the Foo trait with a bar method\\ntrait Foo {\\n    fn bar(&self);\\n}\\n\\n// we now declare a function which takes an object implementing the Foo trait\\nfn some_func<T: Foo>(foo: T) {\\n    foo.bar();\\n}\\n\\nfn main() {\\n    // we now call the method with the i32 type, which doesn't implement\\n    // the Foo trait\\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\\n}\\n```\\n\\nIn order to fix this error, verify that the type you're using does implement\\nthe trait. Example:\\n\\n```\\ntrait Foo {\\n    fn bar(&self);\\n}\\n\\nfn some_func<T: Foo>(foo: T) {\\n    foo.bar(); // we can now use this method since i32 implements the\\n               // Foo trait\\n}\\n\\n// we implement the trait on the i32 type\\nimpl Foo for i32 {\\n    fn bar(&self) {}\\n}\\n\\nfn main() {\\n    some_func(5i32); // ok!\\n}\\n```\\n\\nOr in a generic context, an erroneous code example would look like:\\n```compile_fail\\nfn some_func<T>(foo: T) {\\n    println!(\\\"{:?}\\\", foo); // error: the trait `core::fmt::Debug` is not\\n                           //        implemented for the type `T`\\n}\\n\\nfn main() {\\n    // We now call the method with the i32 type,\\n    // which *does* implement the Debug trait.\\n    some_func(5i32);\\n}\\n```\\n\\nNote that the error here is in the definition of the generic function: Although\\nwe only call it with a parameter that does implement `Debug`, the compiler\\nstill rejects the function: It must work with all possible input types. In\\norder to make this example compile, we need to restrict the generic type we're\\naccepting:\\n```\\nuse std::fmt;\\n\\n// Restrict the input type to types that implement Debug.\\nfn some_func<T: fmt::Debug>(foo: T) {\\n    println!(\\\"{:?}\\\", foo);\\n}\\n\\nfn main() {\\n    // Calling the method is still fine, as i32 implements Debug.\\n    some_func(5i32);\\n\\n    // This would fail to compile now:\\n    // struct WithoutDebug;\\n    // some_func(WithoutDebug);\\n}\\n\\nRust only looks at the signature of the called function, as such it must\\nalready specify all requirements that will be used for every type parameter.\\n```\\n\\n\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"foo.rs\",\"byte_start\":504,\"byte_end\":516,\"line_start\":14,\"line_end\":14,\"column_start\":5,\"column_end\":17,\"text\":[{\"text\":\"    42u8 + 42i32;\",\"highlight_start\":5,\"highlight_end\":17}],\"suggested_replacement\":null,\"expansion\":null}],\"children\":[{\"message\":\"the following implementations were found:\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"foo.rs\",\"byte_start\":504,\"byte_end\":516,\"line_start\":14,\"line_end\":14,\"column_start\":5,\"column_end\":17,\"text\":[{\"text\":\"    42u8 + 42i32;\",\"highlight_start\":5,\"highlight_end\":17}],\"suggested_replacement\":null,\"expansion\":null}],\"children\":[],\"rendered\":null},{\"message\":\"  <u8 as std::ops::Add>\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"foo.rs\",\"byte_start\":504,\"byte_end\":516,\"line_start\":14,\"line_end\":14,\"column_start\":5,\"column_end\":17,\"text\":[{\"text\":\"    42u8 + 42i32;\",\"highlight_start\":5,\"highlight_end\":17}],\"suggested_replacement\":null,\"expansion\":null}],\"children\":[],\"rendered\":null},{\"message\":\"  <&'a u8 as std::ops::Add<u8>>\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"foo.rs\",\"byte_start\":504,\"byte_end\":516,\"line_start\":14,\"line_end\":14,\"column_start\":5,\"column_end\":17,\"text\":[{\"text\":\"    42u8 + 42i32;\",\"highlight_start\":5,\"highlight_end\":17}],\"suggested_replacement\":null,\"expansion\":null}],\"children\":[],\"rendered\":null},{\"message\":\"  <u8 as std::ops::Add<&'a u8>>\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"foo.rs\",\"byte_start\":504,\"byte_end\":516,\"line_start\":14,\"line_end\":14,\"column_start\":5,\"column_end\":17,\"text\":[{\"text\":\"    42u8 + 42i32;\",\"highlight_start\":5,\"highlight_end\":17}],\"suggested_replacement\":null,\"expansion\":null}],\"children\":[],\"rendered\":null},{\"message\":\"  <&'b u8 as std::ops::Add<&'a u8>>\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"foo.rs\",\"byte_start\":504,\"byte_end\":516,\"line_start\":14,\"line_end\":14,\"column_start\":5,\"column_end\":17,\"text\":[{\"text\":\"    42u8 + 42i32;\",\"highlight_start\":5,\"highlight_end\":17}],\"suggested_replacement\":null,\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":null}\n-{\"message\":\"aborting due to 2 previous errors\",\"code\":null,\"level\":\"error\",\"spans\":[],\"children\":[],\"rendered\":null}"}, {"sha": "4db33940d88434011d5e36c85c96ff74689ada4f", "filename": "src/test/run-make/json-errors/foo.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d80497e628945c3f11ff351030b4c62a8533e01e/src%2Ftest%2Frun-make%2Fjson-errors%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80497e628945c3f11ff351030b4c62a8533e01e/src%2Ftest%2Frun-make%2Fjson-errors%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fjson-errors%2Ffoo.rs?ref=d80497e628945c3f11ff351030b4c62a8533e01e", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    let x = 42 + y;\n-\n-    42u8 + 42i32;\n-}"}, {"sha": "3501b335205ed495f105fb1fc7b1f8bd24b8f3aa", "filename": "src/tools/compiletest/src/json.rs", "status": "modified", "additions": 36, "deletions": 11, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/40199f68d909cc15c67de61389328c005062502d/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40199f68d909cc15c67de61389328c005062502d/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs?ref=40199f68d909cc15c67de61389328c005062502d", "patch": "@@ -33,6 +33,8 @@ struct DiagnosticSpan {\n     line_end: usize,\n     column_start: usize,\n     column_end: usize,\n+    is_primary: bool,\n+    label: Option<String>,\n     expansion: Option<Box<DiagnosticSpanMacroExpansion>>,\n }\n \n@@ -66,7 +68,7 @@ fn parse_line(file_name: &str, line: &str) -> Vec<Error> {\n         match json::decode::<Diagnostic>(line) {\n             Ok(diagnostic) => {\n                 let mut expected_errors = vec![];\n-                push_expected_errors(&mut expected_errors, &diagnostic, file_name);\n+                push_expected_errors(&mut expected_errors, &diagnostic, &[], file_name);\n                 expected_errors\n             }\n             Err(error) => {\n@@ -80,12 +82,24 @@ fn parse_line(file_name: &str, line: &str) -> Vec<Error> {\n \n fn push_expected_errors(expected_errors: &mut Vec<Error>,\n                         diagnostic: &Diagnostic,\n+                        default_spans: &[&DiagnosticSpan],\n                         file_name: &str) {\n-    // We only consider messages pertaining to the current file.\n-    let matching_spans = || {\n-        diagnostic.spans.iter().filter(|span| {\n-            Path::new(&span.file_name) == Path::new(&file_name)\n-        })\n+    let spans_in_this_file: Vec<_> =\n+        diagnostic.spans.iter()\n+                        .filter(|span| Path::new(&span.file_name) == Path::new(&file_name))\n+                        .collect();\n+\n+    let primary_spans: Vec<_> =\n+        spans_in_this_file.iter()\n+                          .cloned()\n+                          .filter(|span| span.is_primary)\n+                          .collect();\n+    let primary_spans = if primary_spans.is_empty() {\n+        // subdiagnostics often don't have a span of their own;\n+        // inherit the span from the parent in that case\n+        default_spans\n+    } else {\n+        &primary_spans\n     };\n \n     // We break the output into multiple lines, and then append the\n@@ -124,7 +138,7 @@ fn push_expected_errors(expected_errors: &mut Vec<Error>,\n     // more structured shortly anyhow.\n     let mut message_lines = diagnostic.message.lines();\n     if let Some(first_line) = message_lines.next() {\n-        for span in matching_spans() {\n+        for span in primary_spans {\n             let msg = with_code(span, first_line);\n             let kind = ErrorKind::from_str(&diagnostic.level).ok();\n             expected_errors.push(\n@@ -137,7 +151,7 @@ fn push_expected_errors(expected_errors: &mut Vec<Error>,\n         }\n     }\n     for next_line in message_lines {\n-        for span in matching_spans() {\n+        for span in primary_spans {\n             expected_errors.push(\n                 Error {\n                     line_num: span.line_start,\n@@ -150,7 +164,7 @@ fn push_expected_errors(expected_errors: &mut Vec<Error>,\n \n     // If the message has a suggestion, register that.\n     if let Some(ref rendered) = diagnostic.rendered {\n-        let start_line = matching_spans().map(|s| s.line_start).min().expect(\"\\\n+        let start_line = primary_spans.iter().map(|s| s.line_start).min().expect(\"\\\n             every suggestion should have at least one span\");\n         for (index, line) in rendered.lines().enumerate() {\n             expected_errors.push(\n@@ -164,17 +178,28 @@ fn push_expected_errors(expected_errors: &mut Vec<Error>,\n     }\n \n     // Add notes for the backtrace\n-    for span in matching_spans() {\n+    for span in primary_spans {\n         for frame in &span.expansion {\n             push_backtrace(expected_errors,\n                            frame,\n                            file_name);\n         }\n     }\n \n+    // Add notes for any labels that appear in the message.\n+    for span in spans_in_this_file.iter()\n+                                  .filter(|span| span.label.is_some())\n+    {\n+        expected_errors.push(Error {\n+            line_num: span.line_start,\n+            kind: Some(ErrorKind::Note),\n+            msg: span.label.clone().unwrap()\n+        });\n+    }\n+\n     // Flatten out the children.\n     for child in &diagnostic.children {\n-        push_expected_errors(expected_errors, child, file_name);\n+        push_expected_errors(expected_errors, child, primary_spans, file_name);\n     }\n }\n "}]}