{"sha": "721d53a54f73ebb023624625fe5f357478636694", "node_id": "C_kwDOAAsO6NoAKDcyMWQ1M2E1NGY3M2ViYjAyMzYyNDYyNWZlNWYzNTc0Nzg2MzY2OTQ", "commit": {"author": {"name": "Philipp Krones", "email": "hello@philkrones.com", "date": "2022-06-30T08:50:09Z"}, "committer": {"name": "Philipp Krones", "email": "hello@philkrones.com", "date": "2022-06-30T08:50:09Z"}, "message": "Merge commit '0cb0f7636851f9fcc57085cf80197a2ef6db098f' into clippyup", "tree": {"sha": "090042d90ea539a25fdabe41b3267bfb4ac1d263", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/090042d90ea539a25fdabe41b3267bfb4ac1d263"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/721d53a54f73ebb023624625fe5f357478636694", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmK9Y8QACgkQHKDfKvWd\naKUplRAA0+H9wR6sJMJq/uOnJGiSJBccdwcx/5tWnXkIaelWlvV5KLBcWa+mQjTP\nKF3skP3ZD/HEYAF7ltQHUIrYvaU2tCmxoWBOVNSn9IsvIRTuTgg3wubYHMfZh03o\nBpv+Kkh01vZf8Ykkka53bO7sk6ch8nFOIMKPEtOoCHSGDpeGXn1AsA/0rPqxAiym\nXiJ/Y9onqp6F+o5jx9v+CvtLfPE1Gvfm1xb198oDVoomR1th4K9137icq7pcLkx8\nNUC2GVdGem3FsHLN6OlPI7QNruqQdsLdkc/WMgKfpPAOMzKHmZ6sPFi5q9hS/uvt\n3FKOBjMmwhe+PNzYgket8w2cl6R87NW5oI4cHp6nJwkpMArEcB9BXigH85xbZWEv\nKK4gPdG41uKGSxP6KeqSTMtIeFC26TPwM3K6zE9VWGU+5LAQEELdYUNJdoMdvBdM\nXOAHledOraYKHi6vcwW89KUr6Zt2JRtjvBhyr69ZrdgoNdxYtcNcEbjEHEgCSH6h\n5GSrnrUAljVW8tgv8YGN5F/POmAJfnAq8vEpb3xCsTPp/r8sCUyjy+G6tzkfMUlD\nkg7qjp0cJDBU0UJYyZCJJ57f6vnBRKSdaid+U080XAUU0+gzR+px+TDC1/UJWp6z\nCk0Q5N64uF59+QhGSf/X1PICxvgmJg7ddpo5orki+VmreR5MY9I=\n=Uih+\n-----END PGP SIGNATURE-----", "payload": "tree 090042d90ea539a25fdabe41b3267bfb4ac1d263\nparent a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58\nparent 0cb0f7636851f9fcc57085cf80197a2ef6db098f\nauthor Philipp Krones <hello@philkrones.com> 1656579009 +0200\ncommitter Philipp Krones <hello@philkrones.com> 1656579009 +0200\n\nMerge commit '0cb0f7636851f9fcc57085cf80197a2ef6db098f' into clippyup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/721d53a54f73ebb023624625fe5f357478636694", "html_url": "https://github.com/rust-lang/rust/commit/721d53a54f73ebb023624625fe5f357478636694", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/721d53a54f73ebb023624625fe5f357478636694/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58", "html_url": "https://github.com/rust-lang/rust/commit/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58"}, {"sha": "0cb0f7636851f9fcc57085cf80197a2ef6db098f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cb0f7636851f9fcc57085cf80197a2ef6db098f", "html_url": "https://github.com/rust-lang/rust/commit/0cb0f7636851f9fcc57085cf80197a2ef6db098f"}], "stats": {"total": 12535, "additions": 9047, "deletions": 3488}, "files": [{"sha": "81ef072bbb07fcfa7287ccbfd2e921d111dc5775", "filename": "src/tools/clippy/.github/workflows/remark.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fremark.yml", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fremark.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fremark.yml?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -21,7 +21,7 @@ jobs:\n     - name: Setup Node.js\n       uses: actions/setup-node@v1.4.4\n       with:\n-        node-version: '12.x'\n+        node-version: '14.x'\n \n     - name: Install remark\n       run: npm install remark-cli remark-lint remark-lint-maximum-line-length remark-preset-lint-recommended remark-gfm"}, {"sha": "9bc93c1cb42c91ad045e77c9a5c88f83abdf095b", "filename": "src/tools/clippy/CHANGELOG.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCHANGELOG.md?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -3348,6 +3348,7 @@ Released 2018-09-13\n [`debug_assert_with_mut_call`]: https://rust-lang.github.io/rust-clippy/master/index.html#debug_assert_with_mut_call\n [`decimal_literal_representation`]: https://rust-lang.github.io/rust-clippy/master/index.html#decimal_literal_representation\n [`declare_interior_mutable_const`]: https://rust-lang.github.io/rust-clippy/master/index.html#declare_interior_mutable_const\n+[`default_instead_of_iter_empty`]: https://rust-lang.github.io/rust-clippy/master/index.html#default_instead_of_iter_empty\n [`default_numeric_fallback`]: https://rust-lang.github.io/rust-clippy/master/index.html#default_numeric_fallback\n [`default_trait_access`]: https://rust-lang.github.io/rust-clippy/master/index.html#default_trait_access\n [`default_union_representation`]: https://rust-lang.github.io/rust-clippy/master/index.html#default_union_representation\n@@ -3399,6 +3400,7 @@ Released 2018-09-13\n [`expect_fun_call`]: https://rust-lang.github.io/rust-clippy/master/index.html#expect_fun_call\n [`expect_used`]: https://rust-lang.github.io/rust-clippy/master/index.html#expect_used\n [`expl_impl_clone_on_copy`]: https://rust-lang.github.io/rust-clippy/master/index.html#expl_impl_clone_on_copy\n+[`explicit_auto_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#explicit_auto_deref\n [`explicit_counter_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#explicit_counter_loop\n [`explicit_deref_methods`]: https://rust-lang.github.io/rust-clippy/master/index.html#explicit_deref_methods\n [`explicit_into_iter_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#explicit_into_iter_loop\n@@ -3519,13 +3521,16 @@ Released 2018-09-13\n [`manual_async_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_async_fn\n [`manual_bits`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_bits\n [`manual_filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_filter_map\n+[`manual_find`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_find\n [`manual_find_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_find_map\n [`manual_flatten`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_flatten\n [`manual_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_map\n [`manual_memcpy`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_memcpy\n [`manual_non_exhaustive`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_non_exhaustive\n [`manual_ok_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_ok_or\n [`manual_range_contains`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_range_contains\n+[`manual_rem_euclid`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_rem_euclid\n+[`manual_retain`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_retain\n [`manual_saturating_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_saturating_arithmetic\n [`manual_split_once`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_split_once\n [`manual_str_repeat`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_str_repeat"}, {"sha": "644ca6318f625dd245032b8b4df2dcadf897c2e9", "filename": "src/tools/clippy/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCargo.toml?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.1.63\"\n+version = \"0.1.64\"\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\"\n@@ -31,6 +31,7 @@ termize = \"0.1\"\n compiletest_rs = { version = \"0.8\", features = [\"tmp\"] }\n tester = \"0.9\"\n regex = \"1.5\"\n+toml = \"0.5\"\n # This is used by the `collect-metadata` alias.\n filetime = \"0.2\"\n "}, {"sha": "2c3defeaa83078d2d124d62fbc1bb3cb6458d600", "filename": "src/tools/clippy/README.md", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FREADME.md?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -5,7 +5,7 @@\n \n A collection of lints to catch common mistakes and improve your [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are over 500 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n+[There are over 550 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n \n Lints are divided into categories, each with a default [lint level](https://doc.rust-lang.org/rustc/lints/levels.html).\n You can choose how much Clippy is supposed to ~~annoy~~ help you by changing the lint level by category.\n@@ -214,6 +214,14 @@ specifying the minimum supported Rust version (MSRV) in the clippy configuration\n msrv = \"1.30.0\"\n ```\n \n+Alternatively, the [`rust-version` field](https://doc.rust-lang.org/cargo/reference/manifest.html#the-rust-version-field)\n+in the `Cargo.toml` can be used.\n+\n+```toml\n+# Cargo.toml\n+rust-version = \"1.30\"\n+```\n+\n The MSRV can also be specified as an inner attribute, like below.\n \n ```rust"}, {"sha": "d941f8b65e8ee0cfba44334286379151a3797476", "filename": "src/tools/clippy/book/src/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fbook%2Fsrc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fbook%2Fsrc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fbook%2Fsrc%2FREADME.md?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -6,7 +6,7 @@\n A collection of lints to catch common mistakes and improve your\n [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are over 500 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n+[There are over 550 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n \n Lints are divided into categories, each with a default [lint\n level](https://doc.rust-lang.org/rustc/lints/levels.html). You can choose how"}, {"sha": "2ac3b4fe2ed4f456f91188385e6e4aa3638ccc2b", "filename": "src/tools/clippy/clippy_dev/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_dev%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_dev%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2FCargo.toml?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -5,7 +5,7 @@ edition = \"2021\"\n \n [dependencies]\n aho-corasick = \"0.7\"\n-clap = \"3.1\"\n+clap = \"3.2\"\n indoc = \"1.0\"\n itertools = \"0.10.1\"\n opener = \"0.5\""}, {"sha": "243a901503f160f617718e30e16b2242ab99ace6", "filename": "src/tools/clippy/clippy_dev/src/main.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fmain.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -5,6 +5,7 @@\n use clap::{Arg, ArgAction, ArgMatches, Command, PossibleValue};\n use clippy_dev::{bless, fmt, lint, new_lint, serve, setup, update_lints};\n use indoc::indoc;\n+\n fn main() {\n     let matches = get_clap_config();\n \n@@ -85,6 +86,11 @@ fn main() {\n             let uplift = matches.contains_id(\"uplift\");\n             update_lints::rename(old_name, new_name, uplift);\n         },\n+        Some((\"deprecate\", matches)) => {\n+            let name = matches.get_one::<String>(\"name\").unwrap();\n+            let reason = matches.get_one(\"reason\");\n+            update_lints::deprecate(name, reason);\n+        },\n         _ => {},\n     }\n }\n@@ -266,6 +272,18 @@ fn get_clap_config() -> ArgMatches {\n                     .long(\"uplift\")\n                     .help(\"This lint will be uplifted into rustc\"),\n             ]),\n+            Command::new(\"deprecate\").about(\"Deprecates the given lint\").args([\n+                Arg::new(\"name\")\n+                    .index(1)\n+                    .required(true)\n+                    .help(\"The name of the lint to deprecate\"),\n+                Arg::new(\"reason\")\n+                    .long(\"reason\")\n+                    .short('r')\n+                    .required(false)\n+                    .takes_value(true)\n+                    .help(\"The reason for deprecation\"),\n+            ]),\n         ])\n         .get_matches()\n }"}, {"sha": "7d7e760ef446c3b925b3f1eb47b1e1aaf9a50d71", "filename": "src/tools/clippy/clippy_dev/src/new_lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fnew_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fnew_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fnew_lint.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -138,7 +138,7 @@ fn to_camel_case(name: &str) -> String {\n         .collect()\n }\n \n-fn get_stabilization_version() -> String {\n+pub(crate) fn get_stabilization_version() -> String {\n     fn parse_manifest(contents: &str) -> Option<String> {\n         let version = contents\n             .lines()"}, {"sha": "2e0659f42d7b6b85ea248f4e45a91513c70ed2ca", "filename": "src/tools/clippy/clippy_dev/src/update_lints.rs", "status": "modified", "additions": 354, "deletions": 41, "changes": 395, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,16 +1,17 @@\n+use crate::clippy_project_root;\n use aho_corasick::AhoCorasickBuilder;\n-use core::fmt::Write as _;\n+use indoc::writedoc;\n use itertools::Itertools;\n use rustc_lexer::{tokenize, unescape, LiteralKind, TokenKind};\n use std::collections::{HashMap, HashSet};\n use std::ffi::OsStr;\n-use std::fs;\n-use std::io::{self, Read as _, Seek as _, Write as _};\n+use std::fmt::Write;\n+use std::fs::{self, OpenOptions};\n+use std::io::{self, Read, Seek, SeekFrom, Write as _};\n+use std::ops::Range;\n use std::path::{Path, PathBuf};\n use walkdir::{DirEntry, WalkDir};\n \n-use crate::clippy_project_root;\n-\n const GENERATED_FILE_COMMENT: &str = \"// This file was generated by `cargo dev update_lints`.\\n\\\n      // Use that command to update this file and do not edit by hand.\\n\\\n      // Manual edits will be overwritten.\\n\\n\";\n@@ -326,6 +327,200 @@ pub fn rename(old_name: &str, new_name: &str, uplift: bool) {\n     println!(\"note: `cargo uitest` still needs to be run to update the test results\");\n }\n \n+const DEFAULT_DEPRECATION_REASON: &str = \"default deprecation note\";\n+/// Runs the `deprecate` command\n+///\n+/// This does the following:\n+/// * Adds an entry to `deprecated_lints.rs`.\n+/// * Removes the lint declaration (and the entire file if applicable)\n+///\n+/// # Panics\n+///\n+/// If a file path could not read from or written to\n+pub fn deprecate(name: &str, reason: Option<&String>) {\n+    fn finish(\n+        (lints, mut deprecated_lints, renamed_lints): (Vec<Lint>, Vec<DeprecatedLint>, Vec<RenamedLint>),\n+        name: &str,\n+        reason: &str,\n+    ) {\n+        deprecated_lints.push(DeprecatedLint {\n+            name: name.to_string(),\n+            reason: reason.to_string(),\n+            declaration_range: Range::default(),\n+        });\n+\n+        generate_lint_files(UpdateMode::Change, &lints, &deprecated_lints, &renamed_lints);\n+        println!(\"info: `{}` has successfully been deprecated\", name);\n+\n+        if reason == DEFAULT_DEPRECATION_REASON {\n+            println!(\"note: the deprecation reason must be updated in `clippy_lints/src/deprecated_lints.rs`\");\n+        }\n+        println!(\"note: you must run `cargo uitest` to update the test results\");\n+    }\n+\n+    let reason = reason.map_or(DEFAULT_DEPRECATION_REASON, String::as_str);\n+    let name_lower = name.to_lowercase();\n+    let name_upper = name.to_uppercase();\n+\n+    let (mut lints, deprecated_lints, renamed_lints) = gather_all();\n+    let Some(lint) = lints.iter().find(|l| l.name == name_lower) else { eprintln!(\"error: failed to find lint `{}`\", name); return; };\n+\n+    let mod_path = {\n+        let mut mod_path = PathBuf::from(format!(\"clippy_lints/src/{}\", lint.module));\n+        if mod_path.is_dir() {\n+            mod_path = mod_path.join(\"mod\");\n+        }\n+\n+        mod_path.set_extension(\"rs\");\n+        mod_path\n+    };\n+\n+    let deprecated_lints_path = &*clippy_project_root().join(\"clippy_lints/src/deprecated_lints.rs\");\n+\n+    if remove_lint_declaration(&name_lower, &mod_path, &mut lints).unwrap_or(false) {\n+        declare_deprecated(&name_upper, deprecated_lints_path, reason).unwrap();\n+        finish((lints, deprecated_lints, renamed_lints), name, reason);\n+        return;\n+    }\n+\n+    eprintln!(\"error: lint not found\");\n+}\n+\n+fn remove_lint_declaration(name: &str, path: &Path, lints: &mut Vec<Lint>) -> io::Result<bool> {\n+    fn remove_lint(name: &str, lints: &mut Vec<Lint>) {\n+        lints.iter().position(|l| l.name == name).map(|pos| lints.remove(pos));\n+    }\n+\n+    fn remove_test_assets(name: &str) {\n+        let test_file_stem = format!(\"tests/ui/{}\", name);\n+        let path = Path::new(&test_file_stem);\n+\n+        // Some lints have their own directories, delete them\n+        if path.is_dir() {\n+            fs::remove_dir_all(path).ok();\n+            return;\n+        }\n+\n+        // Remove all related test files\n+        fs::remove_file(path.with_extension(\"rs\")).ok();\n+        fs::remove_file(path.with_extension(\"stderr\")).ok();\n+        fs::remove_file(path.with_extension(\"fixed\")).ok();\n+    }\n+\n+    fn remove_impl_lint_pass(lint_name_upper: &str, content: &mut String) {\n+        let impl_lint_pass_start = content.find(\"impl_lint_pass!\").unwrap_or_else(|| {\n+            content\n+                .find(\"declare_lint_pass!\")\n+                .unwrap_or_else(|| panic!(\"failed to find `impl_lint_pass`\"))\n+        });\n+        let mut impl_lint_pass_end = content[impl_lint_pass_start..]\n+            .find(']')\n+            .expect(\"failed to find `impl_lint_pass` terminator\");\n+\n+        impl_lint_pass_end += impl_lint_pass_start;\n+        if let Some(lint_name_pos) = content[impl_lint_pass_start..impl_lint_pass_end].find(&lint_name_upper) {\n+            let mut lint_name_end = impl_lint_pass_start + (lint_name_pos + lint_name_upper.len());\n+            for c in content[lint_name_end..impl_lint_pass_end].chars() {\n+                // Remove trailing whitespace\n+                if c == ',' || c.is_whitespace() {\n+                    lint_name_end += 1;\n+                } else {\n+                    break;\n+                }\n+            }\n+\n+            content.replace_range(impl_lint_pass_start + lint_name_pos..lint_name_end, \"\");\n+        }\n+    }\n+\n+    if path.exists() {\n+        if let Some(lint) = lints.iter().find(|l| l.name == name) {\n+            if lint.module == name {\n+                // The lint name is the same as the file, we can just delete the entire file\n+                fs::remove_file(path)?;\n+            } else {\n+                // We can't delete the entire file, just remove the declaration\n+\n+                if let Some(Some(\"mod.rs\")) = path.file_name().map(OsStr::to_str) {\n+                    // Remove clippy_lints/src/some_mod/some_lint.rs\n+                    let mut lint_mod_path = path.to_path_buf();\n+                    lint_mod_path.set_file_name(name);\n+                    lint_mod_path.set_extension(\"rs\");\n+\n+                    fs::remove_file(lint_mod_path).ok();\n+                }\n+\n+                let mut content =\n+                    fs::read_to_string(&path).unwrap_or_else(|_| panic!(\"failed to read `{}`\", path.to_string_lossy()));\n+\n+                eprintln!(\n+                    \"warn: you will have to manually remove any code related to `{}` from `{}`\",\n+                    name,\n+                    path.display()\n+                );\n+\n+                assert!(\n+                    content[lint.declaration_range.clone()].contains(&name.to_uppercase()),\n+                    \"error: `{}` does not contain lint `{}`'s declaration\",\n+                    path.display(),\n+                    lint.name\n+                );\n+\n+                // Remove lint declaration (declare_clippy_lint!)\n+                content.replace_range(lint.declaration_range.clone(), \"\");\n+\n+                // Remove the module declaration (mod xyz;)\n+                let mod_decl = format!(\"\\nmod {};\", name);\n+                content = content.replacen(&mod_decl, \"\", 1);\n+\n+                remove_impl_lint_pass(&lint.name.to_uppercase(), &mut content);\n+                fs::write(path, content).unwrap_or_else(|_| panic!(\"failed to write to `{}`\", path.to_string_lossy()));\n+            }\n+\n+            remove_test_assets(name);\n+            remove_lint(name, lints);\n+            return Ok(true);\n+        }\n+    }\n+\n+    Ok(false)\n+}\n+\n+fn declare_deprecated(name: &str, path: &Path, reason: &str) -> io::Result<()> {\n+    let mut file = OpenOptions::new().write(true).open(path)?;\n+\n+    file.seek(SeekFrom::End(0))?;\n+\n+    let version = crate::new_lint::get_stabilization_version();\n+    let deprecation_reason = if reason == DEFAULT_DEPRECATION_REASON {\n+        \"TODO\"\n+    } else {\n+        reason\n+    };\n+\n+    writedoc!(\n+        file,\n+        \"\n+\n+        declare_deprecated_lint! {{\n+            /// ### What it does\n+            /// Nothing. This lint has been deprecated.\n+            ///\n+            /// ### Deprecation reason\n+            /// {}\n+            #[clippy::version = \\\"{}\\\"]\n+            pub {},\n+            \\\"{}\\\"\n+        }}\n+\n+        \",\n+        deprecation_reason,\n+        version,\n+        name,\n+        reason,\n+    )\n+}\n+\n /// Replace substrings if they aren't bordered by identifier characters. Returns `None` if there\n /// were no replacements.\n fn replace_ident_like(contents: &str, replacements: &[(&str, &str)]) -> Option<String> {\n@@ -393,16 +588,18 @@ struct Lint {\n     group: String,\n     desc: String,\n     module: String,\n+    declaration_range: Range<usize>,\n }\n \n impl Lint {\n     #[must_use]\n-    fn new(name: &str, group: &str, desc: &str, module: &str) -> Self {\n+    fn new(name: &str, group: &str, desc: &str, module: &str, declaration_range: Range<usize>) -> Self {\n         Self {\n             name: name.to_lowercase(),\n             group: group.into(),\n             desc: remove_line_splices(desc),\n             module: module.into(),\n+            declaration_range,\n         }\n     }\n \n@@ -433,12 +630,14 @@ impl Lint {\n struct DeprecatedLint {\n     name: String,\n     reason: String,\n+    declaration_range: Range<usize>,\n }\n impl DeprecatedLint {\n-    fn new(name: &str, reason: &str) -> Self {\n+    fn new(name: &str, reason: &str, declaration_range: Range<usize>) -> Self {\n         Self {\n             name: name.to_lowercase(),\n             reason: remove_line_splices(reason),\n+            declaration_range,\n         }\n     }\n }\n@@ -610,7 +809,11 @@ fn clippy_lints_src_files() -> impl Iterator<Item = (PathBuf, DirEntry)> {\n macro_rules! match_tokens {\n     ($iter:ident, $($token:ident $({$($fields:tt)*})? $(($capture:ident))?)*) => {\n          {\n-            $($(let $capture =)? if let Some((TokenKind::$token $({$($fields)*})?, _x)) = $iter.next() {\n+            $($(let $capture =)? if let Some(LintDeclSearchResult {\n+                    token_kind: TokenKind::$token $({$($fields)*})?,\n+                    content: _x,\n+                    ..\n+            }) = $iter.next() {\n                 _x\n             } else {\n                 continue;\n@@ -621,40 +824,72 @@ macro_rules! match_tokens {\n     }\n }\n \n+struct LintDeclSearchResult<'a> {\n+    token_kind: TokenKind,\n+    content: &'a str,\n+    range: Range<usize>,\n+}\n+\n /// Parse a source file looking for `declare_clippy_lint` macro invocations.\n fn parse_contents(contents: &str, module: &str, lints: &mut Vec<Lint>) {\n     let mut offset = 0usize;\n     let mut iter = tokenize(contents).map(|t| {\n         let range = offset..offset + t.len;\n         offset = range.end;\n-        (t.kind, &contents[range])\n+\n+        LintDeclSearchResult {\n+            token_kind: t.kind,\n+            content: &contents[range.clone()],\n+            range,\n+        }\n     });\n \n-    while iter.any(|(kind, s)| kind == TokenKind::Ident && s == \"declare_clippy_lint\") {\n+    while let Some(LintDeclSearchResult { range, .. }) = iter.find(\n+        |LintDeclSearchResult {\n+             token_kind, content, ..\n+         }| token_kind == &TokenKind::Ident && *content == \"declare_clippy_lint\",\n+    ) {\n+        let start = range.start;\n+\n         let mut iter = iter\n             .by_ref()\n-            .filter(|&(kind, _)| !matches!(kind, TokenKind::Whitespace | TokenKind::LineComment { .. }));\n+            .filter(|t| !matches!(t.token_kind, TokenKind::Whitespace | TokenKind::LineComment { .. }));\n         // matches `!{`\n         match_tokens!(iter, Bang OpenBrace);\n         match iter.next() {\n             // #[clippy::version = \"version\"] pub\n-            Some((TokenKind::Pound, _)) => {\n+            Some(LintDeclSearchResult {\n+                token_kind: TokenKind::Pound,\n+                ..\n+            }) => {\n                 match_tokens!(iter, OpenBracket Ident Colon Colon Ident Eq Literal{..} CloseBracket Ident);\n             },\n             // pub\n-            Some((TokenKind::Ident, _)) => (),\n+            Some(LintDeclSearchResult {\n+                token_kind: TokenKind::Ident,\n+                ..\n+            }) => (),\n             _ => continue,\n         }\n+\n         let (name, group, desc) = match_tokens!(\n             iter,\n             // LINT_NAME\n             Ident(name) Comma\n             // group,\n             Ident(group) Comma\n-            // \"description\" }\n-            Literal{..}(desc) CloseBrace\n+            // \"description\"\n+            Literal{..}(desc)\n         );\n-        lints.push(Lint::new(name, group, desc, module));\n+\n+        if let Some(LintDeclSearchResult {\n+            token_kind: TokenKind::CloseBrace,\n+            range,\n+            ..\n+        }) = iter.next()\n+        {\n+            lints.push(Lint::new(name, group, desc, module, start..range.end));\n+        }\n     }\n }\n \n@@ -664,12 +899,24 @@ fn parse_deprecated_contents(contents: &str, lints: &mut Vec<DeprecatedLint>) {\n     let mut iter = tokenize(contents).map(|t| {\n         let range = offset..offset + t.len;\n         offset = range.end;\n-        (t.kind, &contents[range])\n+\n+        LintDeclSearchResult {\n+            token_kind: t.kind,\n+            content: &contents[range.clone()],\n+            range,\n+        }\n     });\n-    while iter.any(|(kind, s)| kind == TokenKind::Ident && s == \"declare_deprecated_lint\") {\n-        let mut iter = iter\n-            .by_ref()\n-            .filter(|&(kind, _)| !matches!(kind, TokenKind::Whitespace | TokenKind::LineComment { .. }));\n+\n+    while let Some(LintDeclSearchResult { range, .. }) = iter.find(\n+        |LintDeclSearchResult {\n+             token_kind, content, ..\n+         }| token_kind == &TokenKind::Ident && *content == \"declare_deprecated_lint\",\n+    ) {\n+        let start = range.start;\n+\n+        let mut iter = iter.by_ref().filter(|LintDeclSearchResult { ref token_kind, .. }| {\n+            !matches!(token_kind, TokenKind::Whitespace | TokenKind::LineComment { .. })\n+        });\n         let (name, reason) = match_tokens!(\n             iter,\n             // !{\n@@ -680,10 +927,16 @@ fn parse_deprecated_contents(contents: &str, lints: &mut Vec<DeprecatedLint>) {\n             Ident Ident(name) Comma\n             // \"description\"\n             Literal{kind: LiteralKind::Str{..},..}(reason)\n-            // }\n-            CloseBrace\n         );\n-        lints.push(DeprecatedLint::new(name, reason));\n+\n+        if let Some(LintDeclSearchResult {\n+            token_kind: TokenKind::CloseBrace,\n+            range,\n+            ..\n+        }) = iter.next()\n+        {\n+            lints.push(DeprecatedLint::new(name, reason, start..range.end));\n+        }\n     }\n }\n \n@@ -693,8 +946,14 @@ fn parse_renamed_contents(contents: &str, lints: &mut Vec<RenamedLint>) {\n         let mut iter = tokenize(line).map(|t| {\n             let range = offset..offset + t.len;\n             offset = range.end;\n-            (t.kind, &line[range])\n+\n+            LintDeclSearchResult {\n+                token_kind: t.kind,\n+                content: &line[range.clone()],\n+                range,\n+            }\n         });\n+\n         let (old_name, new_name) = match_tokens!(\n             iter,\n             // (\"old_name\",\n@@ -844,10 +1103,25 @@ mod tests {\n         \"#;\n         let mut result = Vec::new();\n         parse_contents(CONTENTS, \"module_name\", &mut result);\n+        for r in &mut result {\n+            r.declaration_range = Range::default();\n+        }\n \n         let expected = vec![\n-            Lint::new(\"ptr_arg\", \"style\", \"\\\"really long text\\\"\", \"module_name\"),\n-            Lint::new(\"doc_markdown\", \"pedantic\", \"\\\"single line\\\"\", \"module_name\"),\n+            Lint::new(\n+                \"ptr_arg\",\n+                \"style\",\n+                \"\\\"really long text\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+            ),\n+            Lint::new(\n+                \"doc_markdown\",\n+                \"pedantic\",\n+                \"\\\"single line\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+            ),\n         ];\n         assert_eq!(expected, result);\n     }\n@@ -865,57 +1139,96 @@ mod tests {\n \n         let mut result = Vec::new();\n         parse_deprecated_contents(DEPRECATED_CONTENTS, &mut result);\n+        for r in &mut result {\n+            r.declaration_range = Range::default();\n+        }\n \n         let expected = vec![DeprecatedLint::new(\n             \"should_assert_eq\",\n             \"\\\"`assert!()` will be more flexible with RFC 2011\\\"\",\n+            Range::default(),\n         )];\n         assert_eq!(expected, result);\n     }\n \n     #[test]\n     fn test_usable_lints() {\n         let lints = vec![\n-            Lint::new(\"should_assert_eq2\", \"Not Deprecated\", \"\\\"abc\\\"\", \"module_name\"),\n-            Lint::new(\"should_assert_eq2\", \"internal\", \"\\\"abc\\\"\", \"module_name\"),\n-            Lint::new(\"should_assert_eq2\", \"internal_style\", \"\\\"abc\\\"\", \"module_name\"),\n+            Lint::new(\n+                \"should_assert_eq2\",\n+                \"Not Deprecated\",\n+                \"\\\"abc\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+            ),\n+            Lint::new(\n+                \"should_assert_eq2\",\n+                \"internal\",\n+                \"\\\"abc\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+            ),\n+            Lint::new(\n+                \"should_assert_eq2\",\n+                \"internal_style\",\n+                \"\\\"abc\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+            ),\n         ];\n         let expected = vec![Lint::new(\n             \"should_assert_eq2\",\n             \"Not Deprecated\",\n             \"\\\"abc\\\"\",\n             \"module_name\",\n+            Range::default(),\n         )];\n         assert_eq!(expected, Lint::usable_lints(&lints));\n     }\n \n     #[test]\n     fn test_by_lint_group() {\n         let lints = vec![\n-            Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n-            Lint::new(\"should_assert_eq2\", \"group2\", \"\\\"abc\\\"\", \"module_name\"),\n-            Lint::new(\"incorrect_match\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n+            Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n+            Lint::new(\n+                \"should_assert_eq2\",\n+                \"group2\",\n+                \"\\\"abc\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+            ),\n+            Lint::new(\"incorrect_match\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n         ];\n         let mut expected: HashMap<String, Vec<Lint>> = HashMap::new();\n         expected.insert(\n             \"group1\".to_string(),\n             vec![\n-                Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n-                Lint::new(\"incorrect_match\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n+                Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n+                Lint::new(\"incorrect_match\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n             ],\n         );\n         expected.insert(\n             \"group2\".to_string(),\n-            vec![Lint::new(\"should_assert_eq2\", \"group2\", \"\\\"abc\\\"\", \"module_name\")],\n+            vec![Lint::new(\n+                \"should_assert_eq2\",\n+                \"group2\",\n+                \"\\\"abc\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+            )],\n         );\n         assert_eq!(expected, Lint::by_lint_group(lints.into_iter()));\n     }\n \n     #[test]\n     fn test_gen_deprecated() {\n         let lints = vec![\n-            DeprecatedLint::new(\"should_assert_eq\", \"\\\"has been superseded by should_assert_eq2\\\"\"),\n-            DeprecatedLint::new(\"another_deprecated\", \"\\\"will be removed\\\"\"),\n+            DeprecatedLint::new(\n+                \"should_assert_eq\",\n+                \"\\\"has been superseded by should_assert_eq2\\\"\",\n+                Range::default(),\n+            ),\n+            DeprecatedLint::new(\"another_deprecated\", \"\\\"will be removed\\\"\", Range::default()),\n         ];\n \n         let expected = GENERATED_FILE_COMMENT.to_string()\n@@ -940,9 +1253,9 @@ mod tests {\n     #[test]\n     fn test_gen_lint_group_list() {\n         let lints = vec![\n-            Lint::new(\"abc\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n-            Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n-            Lint::new(\"internal\", \"internal_style\", \"\\\"abc\\\"\", \"module_name\"),\n+            Lint::new(\"abc\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n+            Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n+            Lint::new(\"internal\", \"internal_style\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n         ];\n         let expected = GENERATED_FILE_COMMENT.to_string()\n             + &["}, {"sha": "79a56dc405d17a35fb53849002e34c2ae06cd16c", "filename": "src/tools/clippy/clippy_lints/Cargo.toml", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy_lints\"\n-version = \"0.1.63\"\n+version = \"0.1.64\"\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\"\n@@ -10,7 +10,6 @@ edition = \"2021\"\n \n [dependencies]\n cargo_metadata = \"0.14\"\n-clippy_dev = { path = \"../clippy_dev\", optional = true }\n clippy_utils = { path = \"../clippy_utils\" }\n if_chain = \"1.0\"\n itertools = \"0.10.1\"\n@@ -32,7 +31,7 @@ url = { version = \"2.2\", features = [\"serde\"] }\n [features]\n deny-warnings = [\"clippy_utils/deny-warnings\"]\n # build clippy with internal lints enabled, off by default\n-internal = [\"clippy_utils/internal\", \"serde_json\", \"tempfile\", \"clippy_dev\"]\n+internal = [\"clippy_utils/internal\", \"serde_json\", \"tempfile\"]\n \n [package.metadata.rust-analyzer]\n # This crate uses #[feature(rustc_private)]"}, {"sha": "f81da2d42233380e9bd5a633b8b13237dfcac68a", "filename": "src/tools/clippy/clippy_lints/src/assign_ops.rs", "status": "removed", "additions": 0, "deletions": 235, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassign_ops.rs?ref=a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58", "patch": "@@ -1,235 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::source::snippet_opt;\n-use clippy_utils::ty::implements_trait;\n-use clippy_utils::{binop_traits, sugg};\n-use clippy_utils::{eq_expr_value, trait_ref_of_method};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir as hir;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for `a = a op b` or `a = b commutative_op a`\n-    /// patterns.\n-    ///\n-    /// ### Why is this bad?\n-    /// These can be written as the shorter `a op= b`.\n-    ///\n-    /// ### Known problems\n-    /// While forbidden by the spec, `OpAssign` traits may have\n-    /// implementations that differ from the regular `Op` impl.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let mut a = 5;\n-    /// let b = 0;\n-    /// // ...\n-    ///\n-    /// a = a + b;\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// let mut a = 5;\n-    /// let b = 0;\n-    /// // ...\n-    ///\n-    /// a += b;\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub ASSIGN_OP_PATTERN,\n-    style,\n-    \"assigning the result of an operation on a variable to that same variable\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for `a op= a op b` or `a op= b op a` patterns.\n-    ///\n-    /// ### Why is this bad?\n-    /// Most likely these are bugs where one meant to write `a\n-    /// op= b`.\n-    ///\n-    /// ### Known problems\n-    /// Clippy cannot know for sure if `a op= a op b` should have\n-    /// been `a = a op a op b` or `a = a op b`/`a op= b`. Therefore, it suggests both.\n-    /// If `a op= a op b` is really the correct behavior it should be\n-    /// written as `a = a op a op b` as it's less confusing.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let mut a = 5;\n-    /// let b = 2;\n-    /// // ...\n-    /// a += a + b;\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MISREFACTORED_ASSIGN_OP,\n-    suspicious,\n-    \"having a variable on both sides of an assign op\"\n-}\n-\n-declare_lint_pass!(AssignOps => [ASSIGN_OP_PATTERN, MISREFACTORED_ASSIGN_OP]);\n-\n-impl<'tcx> LateLintPass<'tcx> for AssignOps {\n-    #[allow(clippy::too_many_lines)]\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        match &expr.kind {\n-            hir::ExprKind::AssignOp(op, lhs, rhs) => {\n-                if let hir::ExprKind::Binary(binop, l, r) = &rhs.kind {\n-                    if op.node != binop.node {\n-                        return;\n-                    }\n-                    // lhs op= l op r\n-                    if eq_expr_value(cx, lhs, l) {\n-                        lint_misrefactored_assign_op(cx, expr, *op, rhs, lhs, r);\n-                    }\n-                    // lhs op= l commutative_op r\n-                    if is_commutative(op.node) && eq_expr_value(cx, lhs, r) {\n-                        lint_misrefactored_assign_op(cx, expr, *op, rhs, lhs, l);\n-                    }\n-                }\n-            },\n-            hir::ExprKind::Assign(assignee, e, _) => {\n-                if let hir::ExprKind::Binary(op, l, r) = &e.kind {\n-                    let lint = |assignee: &hir::Expr<'_>, rhs: &hir::Expr<'_>| {\n-                        let ty = cx.typeck_results().expr_ty(assignee);\n-                        let rty = cx.typeck_results().expr_ty(rhs);\n-                        if_chain! {\n-                            if let Some((_, lang_item)) = binop_traits(op.node);\n-                            if let Ok(trait_id) = cx.tcx.lang_items().require(lang_item);\n-                            let parent_fn = cx.tcx.hir().get_parent_item(e.hir_id);\n-                            if trait_ref_of_method(cx, parent_fn)\n-                                .map_or(true, |t| t.path.res.def_id() != trait_id);\n-                            if implements_trait(cx, ty, trait_id, &[rty.into()]);\n-                            then {\n-                                span_lint_and_then(\n-                                    cx,\n-                                    ASSIGN_OP_PATTERN,\n-                                    expr.span,\n-                                    \"manual implementation of an assign operation\",\n-                                    |diag| {\n-                                        if let (Some(snip_a), Some(snip_r)) =\n-                                            (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs.span))\n-                                        {\n-                                            diag.span_suggestion(\n-                                                expr.span,\n-                                                \"replace it with\",\n-                                                format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r),\n-                                                Applicability::MachineApplicable,\n-                                            );\n-                                        }\n-                                    },\n-                                );\n-                            }\n-                        }\n-                    };\n-\n-                    let mut visitor = ExprVisitor {\n-                        assignee,\n-                        counter: 0,\n-                        cx,\n-                    };\n-\n-                    walk_expr(&mut visitor, e);\n-\n-                    if visitor.counter == 1 {\n-                        // a = a op b\n-                        if eq_expr_value(cx, assignee, l) {\n-                            lint(assignee, r);\n-                        }\n-                        // a = b commutative_op a\n-                        // Limited to primitive type as these ops are know to be commutative\n-                        if eq_expr_value(cx, assignee, r) && cx.typeck_results().expr_ty(assignee).is_primitive_ty() {\n-                            match op.node {\n-                                hir::BinOpKind::Add\n-                                | hir::BinOpKind::Mul\n-                                | hir::BinOpKind::And\n-                                | hir::BinOpKind::Or\n-                                | hir::BinOpKind::BitXor\n-                                | hir::BinOpKind::BitAnd\n-                                | hir::BinOpKind::BitOr => {\n-                                    lint(assignee, l);\n-                                },\n-                                _ => {},\n-                            }\n-                        }\n-                    }\n-                }\n-            },\n-            _ => {},\n-        }\n-    }\n-}\n-\n-fn lint_misrefactored_assign_op(\n-    cx: &LateContext<'_>,\n-    expr: &hir::Expr<'_>,\n-    op: hir::BinOp,\n-    rhs: &hir::Expr<'_>,\n-    assignee: &hir::Expr<'_>,\n-    rhs_other: &hir::Expr<'_>,\n-) {\n-    span_lint_and_then(\n-        cx,\n-        MISREFACTORED_ASSIGN_OP,\n-        expr.span,\n-        \"variable appears on both sides of an assignment operation\",\n-        |diag| {\n-            if let (Some(snip_a), Some(snip_r)) = (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs_other.span)) {\n-                let a = &sugg::Sugg::hir(cx, assignee, \"..\");\n-                let r = &sugg::Sugg::hir(cx, rhs, \"..\");\n-                let long = format!(\"{} = {}\", snip_a, sugg::make_binop(op.node.into(), a, r));\n-                diag.span_suggestion(\n-                    expr.span,\n-                    &format!(\n-                        \"did you mean `{} = {} {} {}` or `{}`? Consider replacing it with\",\n-                        snip_a,\n-                        snip_a,\n-                        op.node.as_str(),\n-                        snip_r,\n-                        long\n-                    ),\n-                    format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r),\n-                    Applicability::MaybeIncorrect,\n-                );\n-                diag.span_suggestion(\n-                    expr.span,\n-                    \"or\",\n-                    long,\n-                    Applicability::MaybeIncorrect, // snippet\n-                );\n-            }\n-        },\n-    );\n-}\n-\n-#[must_use]\n-fn is_commutative(op: hir::BinOpKind) -> bool {\n-    use rustc_hir::BinOpKind::{\n-        Add, And, BitAnd, BitOr, BitXor, Div, Eq, Ge, Gt, Le, Lt, Mul, Ne, Or, Rem, Shl, Shr, Sub,\n-    };\n-    match op {\n-        Add | Mul | And | Or | BitXor | BitAnd | BitOr | Eq | Ne => true,\n-        Sub | Div | Rem | Shl | Shr | Lt | Le | Ge | Gt => false,\n-    }\n-}\n-\n-struct ExprVisitor<'a, 'tcx> {\n-    assignee: &'a hir::Expr<'a>,\n-    counter: u8,\n-    cx: &'a LateContext<'tcx>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        if eq_expr_value(self.cx, self.assignee, expr) {\n-            self.counter += 1;\n-        }\n-\n-        walk_expr(self, expr);\n-    }\n-}"}, {"sha": "4bcbeacf9feb59abd13704dcfcaf163bb31a4628", "filename": "src/tools/clippy/clippy_lints/src/attrs.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -78,10 +78,17 @@ declare_clippy_lint! {\n     /// Checks for `extern crate` and `use` items annotated with\n     /// lint attributes.\n     ///\n-    /// This lint permits `#[allow(unused_imports)]`, `#[allow(deprecated)]`,\n-    /// `#[allow(unreachable_pub)]`, `#[allow(clippy::wildcard_imports)]` and\n-    /// `#[allow(clippy::enum_glob_use)]` on `use` items and `#[allow(unused_imports)]` on\n-    /// `extern crate` items with a `#[macro_use]` attribute.\n+    /// This lint permits lint attributes for lints emitted on the items themself.\n+    /// For `use` items these lints are:\n+    /// * deprecated\n+    /// * unreachable_pub\n+    /// * unused_imports\n+    /// * clippy::enum_glob_use\n+    /// * clippy::macro_use_imports\n+    /// * clippy::wildcard_imports\n+    ///\n+    /// For `extern crate` items these lints are:\n+    /// * `unused_imports` on items with `#[macro_use]`\n     ///\n     /// ### Why is this bad?\n     /// Lint attributes have no effect on crate imports. Most\n@@ -347,7 +354,10 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n                                             || extract_clippy_lint(lint).map_or(false, |s| {\n                                                 matches!(\n                                                     s.as_str(),\n-                                                    \"wildcard_imports\" | \"enum_glob_use\" | \"redundant_pub_crate\",\n+                                                    \"wildcard_imports\"\n+                                                        | \"enum_glob_use\"\n+                                                        | \"redundant_pub_crate\"\n+                                                        | \"macro_use_imports\",\n                                                 )\n                                             })\n                                         {"}, {"sha": "526ee2f891a16c79192d523edeaf0313f0db7133", "filename": "src/tools/clippy/clippy_lints/src/booleans.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n+use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_hir_and_then};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n use clippy_utils::{eq_expr_value, get_trait_def_id, paths};\n@@ -394,9 +394,10 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                         continue 'simplified;\n                     }\n                     if stats.terminals[i] != 0 && simplified_stats.terminals[i] == 0 {\n-                        span_lint_and_then(\n+                        span_lint_hir_and_then(\n                             self.cx,\n                             LOGIC_BUG,\n+                            e.hir_id,\n                             e.span,\n                             \"this boolean expression contains a logic bug\",\n                             |diag| {\n@@ -429,9 +430,10 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                 }\n             }\n             let nonminimal_bool_lint = |suggestions: Vec<_>| {\n-                span_lint_and_then(\n+                span_lint_hir_and_then(\n                     self.cx,\n                     NONMINIMAL_BOOL,\n+                    e.hir_id,\n                     e.span,\n                     \"this boolean expression can be simplified\",\n                     |diag| {"}, {"sha": "3c996d3d2aeeeed8340af9d1328d5ac8b5309ad3", "filename": "src/tools/clippy/clippy_lints/src/default_instead_of_iter_empty.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_instead_of_iter_empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_instead_of_iter_empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_instead_of_iter_empty.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,68 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::last_path_segment;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{match_def_path, paths};\n+use rustc_errors::Applicability;\n+use rustc_hir::{def, Expr, ExprKind, GenericArg, QPath, TyKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// It checks for `std::iter::Empty::default()` and suggests replacing it with\n+    /// `std::iter::empty()`.\n+    /// ### Why is this bad?\n+    /// `std::iter::empty()` is the more idiomatic way.\n+    /// ### Example\n+    /// ```rust\n+    /// let _ = std::iter::Empty::<usize>::default();\n+    /// let iter: std::iter::Empty<usize> = std::iter::Empty::default();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let _ = std::iter::empty::<usize>();\n+    /// let iter: std::iter::Empty<usize> = std::iter::empty();\n+    /// ```\n+    #[clippy::version = \"1.63.0\"]\n+    pub DEFAULT_INSTEAD_OF_ITER_EMPTY,\n+    style,\n+    \"check `std::iter::Empty::default()` and replace with `std::iter::empty()`\"\n+}\n+declare_lint_pass!(DefaultIterEmpty => [DEFAULT_INSTEAD_OF_ITER_EMPTY]);\n+\n+impl<'tcx> LateLintPass<'tcx> for DefaultIterEmpty {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if let ExprKind::Call(iter_expr, []) = &expr.kind\n+            && let ExprKind::Path(QPath::TypeRelative(ty, _)) = &iter_expr.kind\n+            && let TyKind::Path(ty_path) = &ty.kind\n+            && let QPath::Resolved(None, path) = ty_path\n+            && let def::Res::Def(_, def_id) = &path.res\n+            && match_def_path(cx, *def_id, &paths::ITER_EMPTY)\n+        {\n+            let mut applicability = Applicability::MachineApplicable;\n+            let sugg = make_sugg(cx, ty_path, &mut applicability);\n+            span_lint_and_sugg(\n+                cx,\n+                DEFAULT_INSTEAD_OF_ITER_EMPTY,\n+                expr.span,\n+                \"`std::iter::empty()` is the more idiomatic way\",\n+                \"try\",\n+                sugg,\n+                applicability,\n+            );\n+        }\n+    }\n+}\n+\n+fn make_sugg(cx: &LateContext<'_>, ty_path: &rustc_hir::QPath<'_>, applicability: &mut Applicability) -> String {\n+    if let Some(last) = last_path_segment(ty_path).args\n+        && let Some(iter_ty) = last.args.iter().find_map(|arg| match arg {\n+            GenericArg::Type(ty) => Some(ty),\n+            _ => None,\n+        })\n+    {\n+        format!(\"std::iter::empty::<{}>()\", snippet_with_applicability(cx, iter_ty.span, \"..\", applicability))\n+    } else {\n+        \"std::iter::empty()\".to_owned()\n+    }\n+}"}, {"sha": "9aa5af3190fb2bd240c3b8ae10e36f9e9e59ae55", "filename": "src/tools/clippy/clippy_lints/src/deprecated_lints.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeprecated_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeprecated_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeprecated_lints.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,16 +1,21 @@\n-// NOTE: if you add a deprecated lint in this file, please add a corresponding test in\n-// tests/ui/deprecated.rs\n+// NOTE: Entries should be created with `cargo dev deprecate`\n \n /// This struct fakes the `Lint` declaration that is usually created by `declare_lint!`. This\n /// enables the simple extraction of the metadata without changing the current deprecation\n /// declaration.\n-pub struct ClippyDeprecatedLint;\n+pub struct ClippyDeprecatedLint {\n+    #[allow(dead_code)]\n+    pub desc: &'static str,\n+}\n \n+#[macro_export]\n macro_rules! declare_deprecated_lint {\n-    { $(#[$attr:meta])* pub $name: ident, $_reason: expr} => {\n+    { $(#[$attr:meta])* pub $name: ident, $reason: literal} => {\n         $(#[$attr])*\n         #[allow(dead_code)]\n-        pub static $name: ClippyDeprecatedLint = ClippyDeprecatedLint {};\n+        pub static $name: ClippyDeprecatedLint = ClippyDeprecatedLint {\n+            desc: $reason\n+        };\n     }\n }\n "}, {"sha": "59dcc1ebf191f9a926ea8844f89fb8498300ae0b", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 547, "deletions": 150, "changes": 697, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,20 +1,24 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_hir_and_then};\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::sugg::has_enclosing_paren;\n-use clippy_utils::ty::peel_mid_ty_refs;\n-use clippy_utils::{get_parent_expr, get_parent_node, is_lint_allowed, path_to_local};\n+use clippy_utils::ty::{expr_sig, peel_mid_ty_refs, variant_of_res};\n+use clippy_utils::{get_parent_expr, is_lint_allowed, path_to_local, walk_to_expr_usage};\n use rustc_ast::util::parser::{PREC_POSTFIX, PREC_PREFIX};\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::Applicability;\n+use rustc_hir::intravisit::{walk_ty, Visitor};\n use rustc_hir::{\n-    BindingAnnotation, Body, BodyId, BorrowKind, Destination, Expr, ExprKind, HirId, MatchSource, Mutability, Node,\n-    Pat, PatKind, UnOp,\n+    self as hir, BindingAnnotation, Body, BodyId, BorrowKind, Expr, ExprKind, GenericArg, HirId, ImplItem,\n+    ImplItemKind, Item, ItemKind, Local, MatchSource, Mutability, Node, Pat, PatKind, Path, QPath, TraitItem,\n+    TraitItemKind, TyKind, UnOp,\n };\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeckResults};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeckResults};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{symbol::sym, Span};\n+use rustc_span::{symbol::sym, Span, Symbol};\n+use rustc_trait_selection::infer::InferCtxtExt;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -104,10 +108,34 @@ declare_clippy_lint! {\n     \"`ref` binding to a reference\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for dereferencing expressions which would be covered by auto-deref.\n+    ///\n+    /// ### Why is this bad?\n+    /// This unnecessarily complicates the code.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x = String::new();\n+    /// let y: &str = &*x;\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let x = String::new();\n+    /// let y: &str = &x;\n+    /// ```\n+    #[clippy::version = \"1.60.0\"]\n+    pub EXPLICIT_AUTO_DEREF,\n+    complexity,\n+    \"dereferencing when the compiler would automatically dereference\"\n+}\n+\n impl_lint_pass!(Dereferencing => [\n     EXPLICIT_DEREF_METHODS,\n     NEEDLESS_BORROW,\n     REF_BINDING_TO_REFERENCE,\n+    EXPLICIT_AUTO_DEREF,\n ]);\n \n #[derive(Default)]\n@@ -136,6 +164,12 @@ struct StateData {\n     /// Span of the top level expression\n     span: Span,\n     hir_id: HirId,\n+    position: Position,\n+}\n+\n+struct DerefedBorrow {\n+    count: usize,\n+    msg: &'static str,\n }\n \n enum State {\n@@ -147,11 +181,19 @@ enum State {\n         /// The required mutability\n         target_mut: Mutability,\n     },\n-    DerefedBorrow {\n-        count: usize,\n-        required_precedence: i8,\n-        msg: &'static str,\n+    DerefedBorrow(DerefedBorrow),\n+    ExplicitDeref {\n+        // Span and id of the top-level deref expression if the parent expression is a borrow.\n+        deref_span_id: Option<(Span, HirId)>,\n+    },\n+    ExplicitDerefField {\n+        name: Symbol,\n     },\n+    Reborrow {\n+        deref_span: Span,\n+        deref_hir_id: HirId,\n+    },\n+    Borrow,\n }\n \n // A reference operation considered by this lint pass\n@@ -207,13 +249,28 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n \n         match (self.state.take(), kind) {\n             (None, kind) => {\n-                let parent = get_parent_node(cx.tcx, expr.hir_id);\n                 let expr_ty = typeck.expr_ty(expr);\n+                let (position, adjustments) = walk_parents(cx, expr);\n \n                 match kind {\n+                    RefOp::Deref => {\n+                        if let Position::FieldAccess(name) = position\n+                            && !ty_contains_field(typeck.expr_ty(sub_expr), name)\n+                        {\n+                            self.state = Some((\n+                                State::ExplicitDerefField { name },\n+                                StateData { span: expr.span, hir_id: expr.hir_id, position },\n+                            ));\n+                        } else if position.is_deref_stable() {\n+                            self.state = Some((\n+                                State::ExplicitDeref { deref_span_id: None },\n+                                StateData { span: expr.span, hir_id: expr.hir_id, position },\n+                            ));\n+                        }\n+                    }\n                     RefOp::Method(target_mut)\n                         if !is_lint_allowed(cx, EXPLICIT_DEREF_METHODS, expr.hir_id)\n-                            && is_linted_explicit_deref_position(parent, expr.hir_id, expr.span) =>\n+                            && position.lint_explicit_deref() =>\n                     {\n                         self.state = Some((\n                             State::DerefMethod {\n@@ -228,12 +285,13 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                             StateData {\n                                 span: expr.span,\n                                 hir_id: expr.hir_id,\n+                                position\n                             },\n                         ));\n                     },\n                     RefOp::AddrOf => {\n                         // Find the number of times the borrow is auto-derefed.\n-                        let mut iter = find_adjustments(cx.tcx, typeck, expr).iter();\n+                        let mut iter = adjustments.iter();\n                         let mut deref_count = 0usize;\n                         let next_adjust = loop {\n                             match iter.next() {\n@@ -274,40 +332,43 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                             \"this expression creates a reference which is immediately dereferenced by the compiler\";\n                         let borrow_msg = \"this expression borrows a value the compiler would automatically borrow\";\n \n-                        let (required_refs, required_precedence, msg) = if is_auto_borrow_position(parent, expr.hir_id)\n-                        {\n-                            (1, PREC_POSTFIX, if deref_count == 1 { borrow_msg } else { deref_msg })\n+                        let (required_refs, msg) = if position.can_auto_borrow() {\n+                            (1, if deref_count == 1 { borrow_msg } else { deref_msg })\n                         } else if let Some(&Adjust::Borrow(AutoBorrow::Ref(_, mutability))) =\n                             next_adjust.map(|a| &a.kind)\n                         {\n-                            if matches!(mutability, AutoBorrowMutability::Mut { .. })\n-                                && !is_auto_reborrow_position(parent)\n+                            if matches!(mutability, AutoBorrowMutability::Mut { .. }) && !position.is_reborrow_stable()\n                             {\n-                                (3, 0, deref_msg)\n+                                (3, deref_msg)\n                             } else {\n-                                (2, 0, deref_msg)\n+                                (2, deref_msg)\n                             }\n                         } else {\n-                            (2, 0, deref_msg)\n+                            (2, deref_msg)\n                         };\n \n                         if deref_count >= required_refs {\n                             self.state = Some((\n-                                State::DerefedBorrow {\n+                                State::DerefedBorrow(DerefedBorrow {\n                                     // One of the required refs is for the current borrow expression, the remaining ones\n                                     // can't be removed without breaking the code. See earlier comment.\n                                     count: deref_count - required_refs,\n-                                    required_precedence,\n                                     msg,\n-                                },\n+                                }),\n+                                StateData { span: expr.span, hir_id: expr.hir_id, position },\n+                            ));\n+                        } else if position.is_deref_stable() {\n+                            self.state = Some((\n+                                State::Borrow,\n                                 StateData {\n                                     span: expr.span,\n                                     hir_id: expr.hir_id,\n+                                    position\n                                 },\n                             ));\n                         }\n                     },\n-                    _ => (),\n+                    RefOp::Method(..) => (),\n                 }\n             },\n             (\n@@ -334,26 +395,90 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                     data,\n                 ));\n             },\n+            (Some((State::DerefedBorrow(state), data)), RefOp::AddrOf) if state.count != 0 => {\n+                self.state = Some((\n+                    State::DerefedBorrow(DerefedBorrow {\n+                        count: state.count - 1,\n+                        ..state\n+                    }),\n+                    data,\n+                ));\n+            },\n+            (Some((State::DerefedBorrow(state), data)), RefOp::AddrOf) => {\n+                let position = data.position;\n+                report(cx, expr, State::DerefedBorrow(state), data);\n+                if position.is_deref_stable() {\n+                    self.state = Some((\n+                        State::Borrow,\n+                        StateData {\n+                            span: expr.span,\n+                            hir_id: expr.hir_id,\n+                            position,\n+                        },\n+                    ));\n+                }\n+            },\n+            (Some((State::DerefedBorrow(state), data)), RefOp::Deref) => {\n+                let position = data.position;\n+                report(cx, expr, State::DerefedBorrow(state), data);\n+                if let Position::FieldAccess(name) = position\n+                    && !ty_contains_field(typeck.expr_ty(sub_expr), name)\n+                {\n+                    self.state = Some((\n+                        State::ExplicitDerefField { name },\n+                        StateData { span: expr.span, hir_id: expr.hir_id, position },\n+                    ));\n+                } else if position.is_deref_stable() {\n+                    self.state = Some((\n+                        State::ExplicitDeref { deref_span_id: None },\n+                        StateData { span: expr.span, hir_id: expr.hir_id, position },\n+                    ));\n+                }\n+            },\n+\n+            (Some((State::Borrow, data)), RefOp::Deref) => {\n+                if typeck.expr_ty(sub_expr).is_ref() {\n+                    self.state = Some((\n+                        State::Reborrow {\n+                            deref_span: expr.span,\n+                            deref_hir_id: expr.hir_id,\n+                        },\n+                        data,\n+                    ));\n+                } else {\n+                    self.state = Some((\n+                        State::ExplicitDeref {\n+                            deref_span_id: Some((expr.span, expr.hir_id)),\n+                        },\n+                        data,\n+                    ));\n+                }\n+            },\n             (\n                 Some((\n-                    State::DerefedBorrow {\n-                        count,\n-                        required_precedence,\n-                        msg,\n+                    State::Reborrow {\n+                        deref_span,\n+                        deref_hir_id,\n                     },\n                     data,\n                 )),\n-                RefOp::AddrOf,\n-            ) if count != 0 => {\n+                RefOp::Deref,\n+            ) => {\n                 self.state = Some((\n-                    State::DerefedBorrow {\n-                        count: count - 1,\n-                        required_precedence,\n-                        msg,\n+                    State::ExplicitDeref {\n+                        deref_span_id: Some((deref_span, deref_hir_id)),\n                     },\n                     data,\n                 ));\n             },\n+            (state @ Some((State::ExplicitDeref { .. }, _)), RefOp::Deref) => {\n+                self.state = state;\n+            },\n+            (Some((State::ExplicitDerefField { name }, data)), RefOp::Deref)\n+                if !ty_contains_field(typeck.expr_ty(sub_expr), name) =>\n+            {\n+                self.state = Some((State::ExplicitDerefField { name }, data));\n+            },\n \n             (Some((state, data)), _) => report(cx, expr, state, data),\n         }\n@@ -473,131 +598,362 @@ fn deref_method_same_type<'tcx>(result_ty: Ty<'tcx>, arg_ty: Ty<'tcx>) -> bool {\n     }\n }\n \n-// Checks whether the parent node is a suitable context for switching from a deref method to the\n-// deref operator.\n-fn is_linted_explicit_deref_position(parent: Option<Node<'_>>, child_id: HirId, child_span: Span) -> bool {\n-    let parent = match parent {\n-        Some(Node::Expr(e)) if e.span.ctxt() == child_span.ctxt() => e,\n-        _ => return true,\n-    };\n-    match parent.kind {\n-        // Leave deref calls in the middle of a method chain.\n-        // e.g. x.deref().foo()\n-        ExprKind::MethodCall(_, [self_arg, ..], _) if self_arg.hir_id == child_id => false,\n-\n-        // Leave deref calls resulting in a called function\n-        // e.g. (x.deref())()\n-        ExprKind::Call(func_expr, _) if func_expr.hir_id == child_id => false,\n-\n-        // Makes an ugly suggestion\n-        // e.g. *x.deref() => *&*x\n-        ExprKind::Unary(UnOp::Deref, _)\n-        // Postfix expressions would require parens\n-        | ExprKind::Match(_, _, MatchSource::TryDesugar | MatchSource::AwaitDesugar)\n-        | ExprKind::Field(..)\n-        | ExprKind::Index(..)\n-        | ExprKind::Err => false,\n-\n-        ExprKind::Box(..)\n-        | ExprKind::ConstBlock(..)\n-        | ExprKind::Array(_)\n-        | ExprKind::Call(..)\n-        | ExprKind::MethodCall(..)\n-        | ExprKind::Tup(..)\n-        | ExprKind::Binary(..)\n-        | ExprKind::Unary(..)\n-        | ExprKind::Lit(..)\n-        | ExprKind::Cast(..)\n-        | ExprKind::Type(..)\n-        | ExprKind::DropTemps(..)\n-        | ExprKind::If(..)\n-        | ExprKind::Loop(..)\n-        | ExprKind::Match(..)\n-        | ExprKind::Let(..)\n-        | ExprKind::Closure{..}\n-        | ExprKind::Block(..)\n-        | ExprKind::Assign(..)\n-        | ExprKind::AssignOp(..)\n-        | ExprKind::Path(..)\n-        | ExprKind::AddrOf(..)\n-        | ExprKind::Break(..)\n-        | ExprKind::Continue(..)\n-        | ExprKind::Ret(..)\n-        | ExprKind::InlineAsm(..)\n-        | ExprKind::Struct(..)\n-        | ExprKind::Repeat(..)\n-        | ExprKind::Yield(..) => true,\n-    }\n+/// The position of an expression relative to it's parent.\n+#[derive(Clone, Copy)]\n+enum Position {\n+    MethodReceiver,\n+    /// The method is defined on a reference type. e.g. `impl Foo for &T`\n+    MethodReceiverRefImpl,\n+    Callee,\n+    FieldAccess(Symbol),\n+    Postfix,\n+    Deref,\n+    /// Any other location which will trigger auto-deref to a specific time.\n+    DerefStable(i8),\n+    /// Any other location which will trigger auto-reborrowing.\n+    ReborrowStable(i8),\n+    Other(i8),\n }\n+impl Position {\n+    fn is_deref_stable(self) -> bool {\n+        matches!(self, Self::DerefStable(_))\n+    }\n \n-/// Checks if the given expression is in a position which can be auto-reborrowed.\n-/// Note: This is only correct assuming auto-deref is already occurring.\n-fn is_auto_reborrow_position(parent: Option<Node<'_>>) -> bool {\n-    match parent {\n-        Some(Node::Expr(parent)) => matches!(parent.kind, ExprKind::MethodCall(..) | ExprKind::Call(..)),\n-        Some(Node::Local(_)) => true,\n-        _ => false,\n+    fn is_reborrow_stable(self) -> bool {\n+        matches!(self, Self::DerefStable(_) | Self::ReborrowStable(_))\n     }\n-}\n \n-/// Checks if the given expression is a position which can auto-borrow.\n-fn is_auto_borrow_position(parent: Option<Node<'_>>, child_id: HirId) -> bool {\n-    if let Some(Node::Expr(parent)) = parent {\n-        match parent.kind {\n-            // ExprKind::MethodCall(_, [self_arg, ..], _) => self_arg.hir_id == child_id,\n-            ExprKind::Field(..) => true,\n-            ExprKind::Call(f, _) => f.hir_id == child_id,\n-            _ => false,\n-        }\n-    } else {\n-        false\n+    fn can_auto_borrow(self) -> bool {\n+        matches!(self, Self::MethodReceiver | Self::FieldAccess(_) | Self::Callee)\n     }\n-}\n \n-/// Adjustments are sometimes made in the parent block rather than the expression itself.\n-fn find_adjustments<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    typeck: &'tcx TypeckResults<'tcx>,\n-    expr: &'tcx Expr<'tcx>,\n-) -> &'tcx [Adjustment<'tcx>] {\n-    let map = tcx.hir();\n-    let mut iter = map.parent_iter(expr.hir_id);\n-    let mut prev = expr;\n+    fn lint_explicit_deref(self) -> bool {\n+        matches!(self, Self::Other(_) | Self::DerefStable(_) | Self::ReborrowStable(_))\n+    }\n \n-    loop {\n-        match typeck.expr_adjustments(prev) {\n-            [] => (),\n-            a => break a,\n-        };\n+    fn precedence(self) -> i8 {\n+        match self {\n+            Self::MethodReceiver\n+            | Self::MethodReceiverRefImpl\n+            | Self::Callee\n+            | Self::FieldAccess(_)\n+            | Self::Postfix => PREC_POSTFIX,\n+            Self::Deref => PREC_PREFIX,\n+            Self::DerefStable(p) | Self::ReborrowStable(p) | Self::Other(p) => p,\n+        }\n+    }\n+}\n \n-        match iter.next().map(|(_, x)| x) {\n-            Some(Node::Block(_)) => {\n-                if let Some((_, Node::Expr(e))) = iter.next() {\n-                    prev = e;\n+/// Walks up the parent expressions attempting to determine both how stable the auto-deref result\n+/// is, and which adjustments will be applied to it. Note this will not consider auto-borrow\n+/// locations as those follow different rules.\n+#[allow(clippy::too_many_lines)]\n+fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &'tcx [Adjustment<'tcx>]) {\n+    let mut adjustments = [].as_slice();\n+    let mut precedence = 0i8;\n+    let ctxt = e.span.ctxt();\n+    let position = walk_to_expr_usage(cx, e, &mut |parent, child_id| {\n+        // LocalTableInContext returns the wrong lifetime, so go use `expr_adjustments` instead.\n+        if adjustments.is_empty() && let Node::Expr(e) = cx.tcx.hir().get(child_id) {\n+            adjustments = cx.typeck_results().expr_adjustments(e);\n+        }\n+        match parent {\n+            Node::Local(Local { ty: Some(ty), span, .. }) if span.ctxt() == ctxt => {\n+                Some(binding_ty_auto_deref_stability(ty, precedence))\n+            },\n+            Node::Item(&Item {\n+                kind: ItemKind::Static(..) | ItemKind::Const(..),\n+                def_id,\n+                span,\n+                ..\n+            })\n+            | Node::TraitItem(&TraitItem {\n+                kind: TraitItemKind::Const(..),\n+                def_id,\n+                span,\n+                ..\n+            })\n+            | Node::ImplItem(&ImplItem {\n+                kind: ImplItemKind::Const(..),\n+                def_id,\n+                span,\n+                ..\n+            }) if span.ctxt() == ctxt => {\n+                let ty = cx.tcx.type_of(def_id);\n+                Some(if ty.is_ref() {\n+                    Position::DerefStable(precedence)\n                 } else {\n-                    // This shouldn't happen. Blocks are always contained in an expression.\n-                    break &[];\n-                }\n+                    Position::Other(precedence)\n+                })\n             },\n-            Some(Node::Expr(&Expr {\n-                kind: ExprKind::Break(Destination { target_id: Ok(id), .. }, _),\n+\n+            Node::Item(&Item {\n+                kind: ItemKind::Fn(..),\n+                def_id,\n+                span,\n+                ..\n+            })\n+            | Node::TraitItem(&TraitItem {\n+                kind: TraitItemKind::Fn(..),\n+                def_id,\n+                span,\n+                ..\n+            })\n+            | Node::ImplItem(&ImplItem {\n+                kind: ImplItemKind::Fn(..),\n+                def_id,\n+                span,\n                 ..\n-            })) => {\n-                if let Some(Node::Expr(e)) = map.find(id) {\n-                    prev = e;\n-                    iter = map.parent_iter(id);\n+            }) if span.ctxt() == ctxt => {\n+                let output = cx.tcx.fn_sig(def_id.to_def_id()).skip_binder().output();\n+                Some(if !output.is_ref() {\n+                    Position::Other(precedence)\n+                } else if output.has_placeholders() || output.has_opaque_types() {\n+                    Position::ReborrowStable(precedence)\n+                } else {\n+                    Position::DerefStable(precedence)\n+                })\n+            },\n+\n+            Node::Expr(parent) if parent.span.ctxt() == ctxt => match parent.kind {\n+                ExprKind::Ret(_) => {\n+                    let output = cx\n+                        .tcx\n+                        .fn_sig(cx.tcx.hir().body_owner_def_id(cx.enclosing_body.unwrap()))\n+                        .skip_binder()\n+                        .output();\n+                    Some(if !output.is_ref() {\n+                        Position::Other(precedence)\n+                    } else if output.has_placeholders() || output.has_opaque_types() {\n+                        Position::ReborrowStable(precedence)\n+                    } else {\n+                        Position::DerefStable(precedence)\n+                    })\n+                },\n+                ExprKind::Call(func, _) if func.hir_id == child_id => (child_id == e.hir_id).then(|| Position::Callee),\n+                ExprKind::Call(func, args) => args\n+                    .iter()\n+                    .position(|arg| arg.hir_id == child_id)\n+                    .zip(expr_sig(cx, func))\n+                    .and_then(|(i, sig)| sig.input_with_hir(i))\n+                    .map(|(hir_ty, ty)| match hir_ty {\n+                        // Type inference for closures can depend on how they're called. Only go by the explicit\n+                        // types here.\n+                        Some(ty) => binding_ty_auto_deref_stability(ty, precedence),\n+                        None => param_auto_deref_stability(ty.skip_binder(), precedence),\n+                    }),\n+                ExprKind::MethodCall(_, args, _) => {\n+                    let id = cx.typeck_results().type_dependent_def_id(parent.hir_id).unwrap();\n+                    args.iter().position(|arg| arg.hir_id == child_id).map(|i| {\n+                        if i == 0 {\n+                            // Check for calls to trait methods where the trait is implemented on a reference.\n+                            // Two cases need to be handled:\n+                            // * `self` methods on `&T` will never have auto-borrow\n+                            // * `&self` methods on `&T` can have auto-borrow, but `&self` methods on `T` will take\n+                            //   priority.\n+                            if e.hir_id != child_id {\n+                                Position::ReborrowStable(precedence)\n+                            } else if let Some(trait_id) = cx.tcx.trait_of_item(id)\n+                                && let arg_ty = cx.tcx.erase_regions(cx.typeck_results().expr_ty_adjusted(e))\n+                                && let ty::Ref(_, sub_ty, _) = *arg_ty.kind()\n+                                && let subs = cx.typeck_results().node_substs_opt(child_id).unwrap_or_else(\n+                                    || cx.tcx.mk_substs([].iter())\n+                                ) && let impl_ty = if cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref() {\n+                                    // Trait methods taking `&self`\n+                                    sub_ty\n+                                } else {\n+                                    // Trait methods taking `self`\n+                                    arg_ty\n+                                } && impl_ty.is_ref()\n+                                && cx.tcx.infer_ctxt().enter(|infcx|\n+                                    infcx\n+                                        .type_implements_trait(trait_id, impl_ty, subs, cx.param_env)\n+                                        .must_apply_modulo_regions()\n+                                )\n+                            {\n+                                Position::MethodReceiverRefImpl\n+                            } else {\n+                                Position::MethodReceiver\n+                            }\n+                        } else {\n+                            param_auto_deref_stability(cx.tcx.fn_sig(id).skip_binder().inputs()[i], precedence)\n+                        }\n+                    })\n+                },\n+                ExprKind::Struct(path, fields, _) => {\n+                    let variant = variant_of_res(cx, cx.qpath_res(path, parent.hir_id));\n+                    fields\n+                        .iter()\n+                        .find(|f| f.expr.hir_id == child_id)\n+                        .zip(variant)\n+                        .and_then(|(field, variant)| variant.fields.iter().find(|f| f.name == field.ident.name))\n+                        .map(|field| param_auto_deref_stability(cx.tcx.type_of(field.did), precedence))\n+                },\n+                ExprKind::Field(child, name) if child.hir_id == e.hir_id => Some(Position::FieldAccess(name.name)),\n+                ExprKind::Unary(UnOp::Deref, child) if child.hir_id == e.hir_id => Some(Position::Deref),\n+                ExprKind::Match(child, _, MatchSource::TryDesugar | MatchSource::AwaitDesugar)\n+                | ExprKind::Index(child, _)\n+                    if child.hir_id == e.hir_id =>\n+                {\n+                    Some(Position::Postfix)\n+                },\n+                _ if child_id == e.hir_id => {\n+                    precedence = parent.precedence().order();\n+                    None\n+                },\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    })\n+    .unwrap_or(Position::Other(precedence));\n+    (position, adjustments)\n+}\n+\n+// Checks the stability of auto-deref when assigned to a binding with the given explicit type.\n+//\n+// e.g.\n+// let x = Box::new(Box::new(0u32));\n+// let y1: &Box<_> = x.deref();\n+// let y2: &Box<_> = &x;\n+//\n+// Here `y1` and `y2` would resolve to different types, so the type `&Box<_>` is not stable when\n+// switching to auto-dereferencing.\n+fn binding_ty_auto_deref_stability(ty: &hir::Ty<'_>, precedence: i8) -> Position {\n+    let TyKind::Rptr(_, ty) = &ty.kind else {\n+        return Position::Other(precedence);\n+    };\n+    let mut ty = ty;\n+\n+    loop {\n+        break match ty.ty.kind {\n+            TyKind::Rptr(_, ref ref_ty) => {\n+                ty = ref_ty;\n+                continue;\n+            },\n+            TyKind::Path(\n+                QPath::TypeRelative(_, path)\n+                | QPath::Resolved(\n+                    _,\n+                    Path {\n+                        segments: [.., path], ..\n+                    },\n+                ),\n+            ) => {\n+                if let Some(args) = path.args\n+                    && args.args.iter().any(|arg| match arg {\n+                        GenericArg::Infer(_) => true,\n+                        GenericArg::Type(ty) => ty_contains_infer(ty),\n+                        _ => false,\n+                    })\n+                {\n+                    Position::ReborrowStable(precedence)\n                 } else {\n-                    // This shouldn't happen. The destination should exist.\n-                    break &[];\n+                    Position::DerefStable(precedence)\n                 }\n             },\n-            _ => break &[],\n+            TyKind::Slice(_)\n+            | TyKind::Array(..)\n+            | TyKind::BareFn(_)\n+            | TyKind::Never\n+            | TyKind::Tup(_)\n+            | TyKind::Ptr(_)\n+            | TyKind::TraitObject(..)\n+            | TyKind::Path(_) => Position::DerefStable(precedence),\n+            TyKind::OpaqueDef(..)\n+            | TyKind::Infer\n+            | TyKind::Typeof(..)\n+            | TyKind::Err => Position::ReborrowStable(precedence),\n+        };\n+    }\n+}\n+\n+// Checks whether a type is inferred at some point.\n+// e.g. `_`, `Box<_>`, `[_]`\n+fn ty_contains_infer(ty: &hir::Ty<'_>) -> bool {\n+    struct V(bool);\n+    impl Visitor<'_> for V {\n+        fn visit_ty(&mut self, ty: &hir::Ty<'_>) {\n+            if self.0\n+                || matches!(\n+                    ty.kind,\n+                    TyKind::OpaqueDef(..) | TyKind::Infer | TyKind::Typeof(_) | TyKind::Err\n+                )\n+            {\n+                self.0 = true;\n+            } else {\n+                walk_ty(self, ty);\n+            }\n         }\n+\n+        fn visit_generic_arg(&mut self, arg: &GenericArg<'_>) {\n+            if self.0 || matches!(arg, GenericArg::Infer(_)) {\n+                self.0 = true;\n+            } else if let GenericArg::Type(ty) = arg {\n+                self.visit_ty(ty);\n+            }\n+        }\n+    }\n+    let mut v = V(false);\n+    v.visit_ty(ty);\n+    v.0\n+}\n+\n+// Checks whether a type is stable when switching to auto dereferencing,\n+fn param_auto_deref_stability(ty: Ty<'_>, precedence: i8) -> Position {\n+    let ty::Ref(_, mut ty, _) = *ty.kind() else {\n+        return Position::Other(precedence);\n+    };\n+\n+    loop {\n+        break match *ty.kind() {\n+            ty::Ref(_, ref_ty, _) => {\n+                ty = ref_ty;\n+                continue;\n+            },\n+            ty::Infer(_)\n+            | ty::Error(_)\n+            | ty::Param(_)\n+            | ty::Bound(..)\n+            | ty::Opaque(..)\n+            | ty::Placeholder(_)\n+            | ty::Dynamic(..) => Position::ReborrowStable(precedence),\n+            ty::Adt(..) if ty.has_placeholders() || ty.has_param_types_or_consts() => {\n+                Position::ReborrowStable(precedence)\n+            },\n+            ty::Adt(..)\n+            | ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Foreign(_)\n+            | ty::Str\n+            | ty::Array(..)\n+            | ty::Slice(..)\n+            | ty::RawPtr(..)\n+            | ty::FnDef(..)\n+            | ty::FnPtr(_)\n+            | ty::Closure(..)\n+            | ty::Generator(..)\n+            | ty::GeneratorWitness(..)\n+            | ty::Never\n+            | ty::Tuple(_)\n+            | ty::Projection(_) => Position::DerefStable(precedence),\n+        };\n+    }\n+}\n+\n+fn ty_contains_field(ty: Ty<'_>, name: Symbol) -> bool {\n+    if let ty::Adt(adt, _) = *ty.kind() {\n+        adt.is_struct() && adt.all_fields().any(|f| f.name == name)\n+    } else {\n+        false\n     }\n }\n \n-#[expect(clippy::needless_pass_by_value)]\n-fn report<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>, state: State, data: StateData) {\n+#[expect(clippy::needless_pass_by_value, clippy::too_many_lines)]\n+fn report<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data: StateData) {\n     match state {\n         State::DerefMethod {\n             ty_changed_count,\n@@ -647,22 +1003,63 @@ fn report<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>, state: State, data: S\n                 app,\n             );\n         },\n-        State::DerefedBorrow {\n-            required_precedence,\n-            msg,\n-            ..\n-        } => {\n+        State::DerefedBorrow(state) => {\n             let mut app = Applicability::MachineApplicable;\n-            let snip = snippet_with_context(cx, expr.span, data.span.ctxt(), \"..\", &mut app).0;\n-            span_lint_hir_and_then(cx, NEEDLESS_BORROW, data.hir_id, data.span, msg, |diag| {\n-                let sugg = if required_precedence > expr.precedence().order() && !has_enclosing_paren(&snip) {\n+            let (snip, snip_is_macro) = snippet_with_context(cx, expr.span, data.span.ctxt(), \"..\", &mut app);\n+            span_lint_hir_and_then(cx, NEEDLESS_BORROW, data.hir_id, data.span, state.msg, |diag| {\n+                let sugg = if !snip_is_macro\n+                    && expr.precedence().order() < data.position.precedence()\n+                    && !has_enclosing_paren(&snip)\n+                {\n                     format!(\"({})\", snip)\n                 } else {\n                     snip.into()\n                 };\n                 diag.span_suggestion(data.span, \"change this to\", sugg, app);\n             });\n         },\n+        State::ExplicitDeref { deref_span_id } => {\n+            let (span, hir_id, precedence) = if let Some((span, hir_id)) = deref_span_id\n+                && !cx.typeck_results().expr_ty(expr).is_ref()\n+            {\n+                (span, hir_id, PREC_PREFIX)\n+            } else {\n+                (data.span, data.hir_id, data.position.precedence())\n+            };\n+            span_lint_hir_and_then(\n+                cx,\n+                EXPLICIT_AUTO_DEREF,\n+                hir_id,\n+                span,\n+                \"deref which would be done by auto-deref\",\n+                |diag| {\n+                    let mut app = Applicability::MachineApplicable;\n+                    let (snip, snip_is_macro) = snippet_with_context(cx, expr.span, span.ctxt(), \"..\", &mut app);\n+                    let sugg =\n+                        if !snip_is_macro && expr.precedence().order() < precedence && !has_enclosing_paren(&snip) {\n+                            format!(\"({})\", snip)\n+                        } else {\n+                            snip.into()\n+                        };\n+                    diag.span_suggestion(span, \"try this\", sugg, app);\n+                },\n+            );\n+        },\n+        State::ExplicitDerefField { .. } => {\n+            span_lint_hir_and_then(\n+                cx,\n+                EXPLICIT_AUTO_DEREF,\n+                data.hir_id,\n+                data.span,\n+                \"deref which would be done by auto-deref\",\n+                |diag| {\n+                    let mut app = Applicability::MachineApplicable;\n+                    let snip = snippet_with_context(cx, expr.span, data.span.ctxt(), \"..\", &mut app).0;\n+                    diag.span_suggestion(data.span, \"try this\", snip.into_owned(), app);\n+                },\n+            );\n+        },\n+        State::Borrow | State::Reborrow { .. } => (),\n     }\n }\n "}, {"sha": "ee0440e52ff85a1ec3bb65d8c88d4801348fa2d3", "filename": "src/tools/clippy/clippy_lints/src/double_comparison.rs", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58", "patch": "@@ -1,96 +0,0 @@\n-//! Lint on unnecessary double comparisons. Some examples:\n-\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::eq_expr_value;\n-use clippy_utils::source::snippet_with_applicability;\n-use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Span;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for double comparisons that could be simplified to a single expression.\n-    ///\n-    ///\n-    /// ### Why is this bad?\n-    /// Readability.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let x = 1;\n-    /// # let y = 2;\n-    /// if x == y || x < y {}\n-    /// ```\n-    ///\n-    /// Use instead:\n-    ///\n-    /// ```rust\n-    /// # let x = 1;\n-    /// # let y = 2;\n-    /// if x <= y {}\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub DOUBLE_COMPARISONS,\n-    complexity,\n-    \"unnecessary double comparisons that can be simplified\"\n-}\n-\n-declare_lint_pass!(DoubleComparisons => [DOUBLE_COMPARISONS]);\n-\n-impl<'tcx> DoubleComparisons {\n-    #[expect(clippy::similar_names)]\n-    fn check_binop(cx: &LateContext<'tcx>, op: BinOpKind, lhs: &'tcx Expr<'_>, rhs: &'tcx Expr<'_>, span: Span) {\n-        let (lkind, llhs, lrhs, rkind, rlhs, rrhs) = match (&lhs.kind, &rhs.kind) {\n-            (ExprKind::Binary(lb, llhs, lrhs), ExprKind::Binary(rb, rlhs, rrhs)) => {\n-                (lb.node, llhs, lrhs, rb.node, rlhs, rrhs)\n-            },\n-            _ => return,\n-        };\n-        if !(eq_expr_value(cx, llhs, rlhs) && eq_expr_value(cx, lrhs, rrhs)) {\n-            return;\n-        }\n-        macro_rules! lint_double_comparison {\n-            ($op:tt) => {{\n-                let mut applicability = Applicability::MachineApplicable;\n-                let lhs_str = snippet_with_applicability(cx, llhs.span, \"\", &mut applicability);\n-                let rhs_str = snippet_with_applicability(cx, lrhs.span, \"\", &mut applicability);\n-                let sugg = format!(\"{} {} {}\", lhs_str, stringify!($op), rhs_str);\n-                span_lint_and_sugg(\n-                    cx,\n-                    DOUBLE_COMPARISONS,\n-                    span,\n-                    \"this binary expression can be simplified\",\n-                    \"try\",\n-                    sugg,\n-                    applicability,\n-                );\n-            }};\n-        }\n-        #[rustfmt::skip]\n-        match (op, lkind, rkind) {\n-            (BinOpKind::Or, BinOpKind::Eq, BinOpKind::Lt) | (BinOpKind::Or, BinOpKind::Lt, BinOpKind::Eq) => {\n-                lint_double_comparison!(<=);\n-            },\n-            (BinOpKind::Or, BinOpKind::Eq, BinOpKind::Gt) | (BinOpKind::Or, BinOpKind::Gt, BinOpKind::Eq) => {\n-                lint_double_comparison!(>=);\n-            },\n-            (BinOpKind::Or, BinOpKind::Lt, BinOpKind::Gt) | (BinOpKind::Or, BinOpKind::Gt, BinOpKind::Lt) => {\n-                lint_double_comparison!(!=);\n-            },\n-            (BinOpKind::And, BinOpKind::Le, BinOpKind::Ge) | (BinOpKind::And, BinOpKind::Ge, BinOpKind::Le) => {\n-                lint_double_comparison!(==);\n-            },\n-            _ => (),\n-        };\n-    }\n-}\n-\n-impl<'tcx> LateLintPass<'tcx> for DoubleComparisons {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Binary(ref kind, lhs, rhs) = expr.kind {\n-            Self::check_binop(cx, kind.node, lhs, rhs, expr.span);\n-        }\n-    }\n-}"}, {"sha": "d85ace3a279b3b8e4b9d586301c06c75222f5246", "filename": "src/tools/clippy/clippy_lints/src/duration_subsec.rs", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduration_subsec.rs?ref=a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58", "patch": "@@ -1,75 +0,0 @@\n-use clippy_utils::consts::{constant, Constant};\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Spanned;\n-use rustc_span::sym;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for calculation of subsecond microseconds or milliseconds\n-    /// from other `Duration` methods.\n-    ///\n-    /// ### Why is this bad?\n-    /// It's more concise to call `Duration::subsec_micros()` or\n-    /// `Duration::subsec_millis()` than to calculate them.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # use std::time::Duration;\n-    /// # let duration = Duration::new(5, 0);\n-    /// let micros = duration.subsec_nanos() / 1_000;\n-    /// let millis = duration.subsec_nanos() / 1_000_000;\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// # use std::time::Duration;\n-    /// # let duration = Duration::new(5, 0);\n-    /// let micros = duration.subsec_micros();\n-    /// let millis = duration.subsec_millis();\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub DURATION_SUBSEC,\n-    complexity,\n-    \"checks for calculation of subsecond microseconds or milliseconds\"\n-}\n-\n-declare_lint_pass!(DurationSubsec => [DURATION_SUBSEC]);\n-\n-impl<'tcx> LateLintPass<'tcx> for DurationSubsec {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::Binary(Spanned { node: BinOpKind::Div, .. }, left, right) = expr.kind;\n-            if let ExprKind::MethodCall(method_path, args, _) = left.kind;\n-            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]).peel_refs(), sym::Duration);\n-            if let Some((Constant::Int(divisor), _)) = constant(cx, cx.typeck_results(), right);\n-            then {\n-                let suggested_fn = match (method_path.ident.as_str(), divisor) {\n-                    (\"subsec_micros\", 1_000) | (\"subsec_nanos\", 1_000_000) => \"subsec_millis\",\n-                    (\"subsec_nanos\", 1_000) => \"subsec_micros\",\n-                    _ => return,\n-                };\n-                let mut applicability = Applicability::MachineApplicable;\n-                span_lint_and_sugg(\n-                    cx,\n-                    DURATION_SUBSEC,\n-                    expr.span,\n-                    &format!(\"calling `{}()` is more concise than this calculation\", suggested_fn),\n-                    \"try\",\n-                    format!(\n-                        \"{}.{}()\",\n-                        snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability),\n-                        suggested_fn\n-                    ),\n-                    applicability,\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "cd36f9fcd729e170868ecf5f12e7af30e1c16305", "filename": "src/tools/clippy/clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -190,7 +190,7 @@ fn check_variant(cx: &LateContext<'_>, threshold: u64, def: &EnumDef<'_>, item_n\n             .map(|e| *e.0)\n             .collect();\n     }\n-    let (what, value) = match (pre.is_empty(), post.is_empty()) {\n+    let (what, value) = match (have_no_extra_prefix(&pre), post.is_empty()) {\n         (true, true) => return,\n         (false, _) => (\"pre\", pre.join(\"\")),\n         (true, false) => {\n@@ -212,6 +212,11 @@ fn check_variant(cx: &LateContext<'_>, threshold: u64, def: &EnumDef<'_>, item_n\n     );\n }\n \n+#[must_use]\n+fn have_no_extra_prefix(prefixes: &[&str]) -> bool {\n+    prefixes.iter().all(|p| p == &\"\" || p == &\"_\")\n+}\n+\n #[must_use]\n fn to_camel_case(item_name: &str) -> String {\n     let mut s = String::new();"}, {"sha": "2f4c90d07cf666c9dede8ea2bbba5b1bddeaf5f2", "filename": "src/tools/clippy/clippy_lints/src/eq_op.rs", "status": "removed", "additions": 0, "deletions": 319, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs?ref=a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58", "patch": "@@ -1,319 +0,0 @@\n-use clippy_utils::diagnostics::{multispan_sugg, span_lint, span_lint_and_then};\n-use clippy_utils::get_enclosing_block;\n-use clippy_utils::macros::{find_assert_eq_args, first_node_macro_backtrace};\n-use clippy_utils::source::snippet;\n-use clippy_utils::ty::{implements_trait, is_copy};\n-use clippy_utils::{ast_utils::is_useless_with_eq_exprs, eq_expr_value, is_in_test_function};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::{def::Res, def_id::DefId, BinOpKind, BorrowKind, Expr, ExprKind, GenericArg, ItemKind, QPath, TyKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, Ty};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for equal operands to comparison, logical and\n-    /// bitwise, difference and division binary operators (`==`, `>`, etc., `&&`,\n-    /// `||`, `&`, `|`, `^`, `-` and `/`).\n-    ///\n-    /// ### Why is this bad?\n-    /// This is usually just a typo or a copy and paste error.\n-    ///\n-    /// ### Known problems\n-    /// False negatives: We had some false positives regarding\n-    /// calls (notably [racer](https://github.com/phildawes/racer) had one instance\n-    /// of `x.pop() && x.pop()`), so we removed matching any function or method\n-    /// calls. We may introduce a list of known pure functions in the future.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let x = 1;\n-    /// if x + 1 == x + 1 {}\n-    ///\n-    /// // or\n-    ///\n-    /// # let a = 3;\n-    /// # let b = 4;\n-    /// assert_eq!(a, a);\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub EQ_OP,\n-    correctness,\n-    \"equal operands on both sides of a comparison or bitwise combination (e.g., `x == x`)\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for arguments to `==` which have their address\n-    /// taken to satisfy a bound\n-    /// and suggests to dereference the other argument instead\n-    ///\n-    /// ### Why is this bad?\n-    /// It is more idiomatic to dereference the other argument.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// &x == y\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// x == *y\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub OP_REF,\n-    style,\n-    \"taking a reference to satisfy the type constraints on `==`\"\n-}\n-\n-declare_lint_pass!(EqOp => [EQ_OP, OP_REF]);\n-\n-impl<'tcx> LateLintPass<'tcx> for EqOp {\n-    #[expect(clippy::similar_names, clippy::too_many_lines)]\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let Some((macro_call, macro_name)) = first_node_macro_backtrace(cx, e).find_map(|macro_call| {\n-                let name = cx.tcx.item_name(macro_call.def_id);\n-                matches!(name.as_str(), \"assert_eq\" | \"assert_ne\" | \"debug_assert_eq\" | \"debug_assert_ne\")\n-                    .then(|| (macro_call, name))\n-            });\n-            if let Some((lhs, rhs, _)) = find_assert_eq_args(cx, e, macro_call.expn);\n-            if eq_expr_value(cx, lhs, rhs);\n-            if macro_call.is_local();\n-            if !is_in_test_function(cx.tcx, e.hir_id);\n-            then {\n-                span_lint(\n-                    cx,\n-                    EQ_OP,\n-                    lhs.span.to(rhs.span),\n-                    &format!(\"identical args used in this `{}!` macro call\", macro_name),\n-                );\n-            }\n-        }\n-        if let ExprKind::Binary(op, left, right) = e.kind {\n-            if e.span.from_expansion() {\n-                return;\n-            }\n-            let macro_with_not_op = |expr_kind: &ExprKind<'_>| {\n-                if let ExprKind::Unary(_, expr) = *expr_kind {\n-                    expr.span.from_expansion()\n-                } else {\n-                    false\n-                }\n-            };\n-            if macro_with_not_op(&left.kind) || macro_with_not_op(&right.kind) {\n-                return;\n-            }\n-            if is_useless_with_eq_exprs(op.node.into())\n-                && eq_expr_value(cx, left, right)\n-                && !is_in_test_function(cx.tcx, e.hir_id)\n-            {\n-                span_lint(\n-                    cx,\n-                    EQ_OP,\n-                    e.span,\n-                    &format!(\"equal expressions as operands to `{}`\", op.node.as_str()),\n-                );\n-                return;\n-            }\n-            let (trait_id, requires_ref) = match op.node {\n-                BinOpKind::Add => (cx.tcx.lang_items().add_trait(), false),\n-                BinOpKind::Sub => (cx.tcx.lang_items().sub_trait(), false),\n-                BinOpKind::Mul => (cx.tcx.lang_items().mul_trait(), false),\n-                BinOpKind::Div => (cx.tcx.lang_items().div_trait(), false),\n-                BinOpKind::Rem => (cx.tcx.lang_items().rem_trait(), false),\n-                // don't lint short circuiting ops\n-                BinOpKind::And | BinOpKind::Or => return,\n-                BinOpKind::BitXor => (cx.tcx.lang_items().bitxor_trait(), false),\n-                BinOpKind::BitAnd => (cx.tcx.lang_items().bitand_trait(), false),\n-                BinOpKind::BitOr => (cx.tcx.lang_items().bitor_trait(), false),\n-                BinOpKind::Shl => (cx.tcx.lang_items().shl_trait(), false),\n-                BinOpKind::Shr => (cx.tcx.lang_items().shr_trait(), false),\n-                BinOpKind::Ne | BinOpKind::Eq => (cx.tcx.lang_items().eq_trait(), true),\n-                BinOpKind::Lt | BinOpKind::Le | BinOpKind::Ge | BinOpKind::Gt => {\n-                    (cx.tcx.lang_items().partial_ord_trait(), true)\n-                },\n-            };\n-            if let Some(trait_id) = trait_id {\n-                match (&left.kind, &right.kind) {\n-                    // do not suggest to dereference literals\n-                    (&ExprKind::Lit(..), _) | (_, &ExprKind::Lit(..)) => {},\n-                    // &foo == &bar\n-                    (&ExprKind::AddrOf(BorrowKind::Ref, _, l), &ExprKind::AddrOf(BorrowKind::Ref, _, r)) => {\n-                        let lty = cx.typeck_results().expr_ty(l);\n-                        let rty = cx.typeck_results().expr_ty(r);\n-                        let lcpy = is_copy(cx, lty);\n-                        let rcpy = is_copy(cx, rty);\n-                        if let Some((self_ty, other_ty)) = in_impl(cx, e, trait_id) {\n-                            if (are_equal(cx, rty, self_ty) && are_equal(cx, lty, other_ty))\n-                                || (are_equal(cx, rty, other_ty) && are_equal(cx, lty, self_ty))\n-                            {\n-                                return; // Don't lint\n-                            }\n-                        }\n-                        // either operator autorefs or both args are copyable\n-                        if (requires_ref || (lcpy && rcpy)) && implements_trait(cx, lty, trait_id, &[rty.into()]) {\n-                            span_lint_and_then(\n-                                cx,\n-                                OP_REF,\n-                                e.span,\n-                                \"needlessly taken reference of both operands\",\n-                                |diag| {\n-                                    let lsnip = snippet(cx, l.span, \"...\").to_string();\n-                                    let rsnip = snippet(cx, r.span, \"...\").to_string();\n-                                    multispan_sugg(\n-                                        diag,\n-                                        \"use the values directly\",\n-                                        vec![(left.span, lsnip), (right.span, rsnip)],\n-                                    );\n-                                },\n-                            );\n-                        } else if lcpy\n-                            && !rcpy\n-                            && implements_trait(cx, lty, trait_id, &[cx.typeck_results().expr_ty(right).into()])\n-                        {\n-                            span_lint_and_then(\n-                                cx,\n-                                OP_REF,\n-                                e.span,\n-                                \"needlessly taken reference of left operand\",\n-                                |diag| {\n-                                    let lsnip = snippet(cx, l.span, \"...\").to_string();\n-                                    diag.span_suggestion(\n-                                        left.span,\n-                                        \"use the left value directly\",\n-                                        lsnip,\n-                                        Applicability::MaybeIncorrect, // FIXME #2597\n-                                    );\n-                                },\n-                            );\n-                        } else if !lcpy\n-                            && rcpy\n-                            && implements_trait(cx, cx.typeck_results().expr_ty(left), trait_id, &[rty.into()])\n-                        {\n-                            span_lint_and_then(\n-                                cx,\n-                                OP_REF,\n-                                e.span,\n-                                \"needlessly taken reference of right operand\",\n-                                |diag| {\n-                                    let rsnip = snippet(cx, r.span, \"...\").to_string();\n-                                    diag.span_suggestion(\n-                                        right.span,\n-                                        \"use the right value directly\",\n-                                        rsnip,\n-                                        Applicability::MaybeIncorrect, // FIXME #2597\n-                                    );\n-                                },\n-                            );\n-                        }\n-                    },\n-                    // &foo == bar\n-                    (&ExprKind::AddrOf(BorrowKind::Ref, _, l), _) => {\n-                        let lty = cx.typeck_results().expr_ty(l);\n-                        if let Some((self_ty, other_ty)) = in_impl(cx, e, trait_id) {\n-                            let rty = cx.typeck_results().expr_ty(right);\n-                            if (are_equal(cx, rty, self_ty) && are_equal(cx, lty, other_ty))\n-                                || (are_equal(cx, rty, other_ty) && are_equal(cx, lty, self_ty))\n-                            {\n-                                return; // Don't lint\n-                            }\n-                        }\n-                        let lcpy = is_copy(cx, lty);\n-                        if (requires_ref || lcpy)\n-                            && implements_trait(cx, lty, trait_id, &[cx.typeck_results().expr_ty(right).into()])\n-                        {\n-                            span_lint_and_then(\n-                                cx,\n-                                OP_REF,\n-                                e.span,\n-                                \"needlessly taken reference of left operand\",\n-                                |diag| {\n-                                    let lsnip = snippet(cx, l.span, \"...\").to_string();\n-                                    diag.span_suggestion(\n-                                        left.span,\n-                                        \"use the left value directly\",\n-                                        lsnip,\n-                                        Applicability::MaybeIncorrect, // FIXME #2597\n-                                    );\n-                                },\n-                            );\n-                        }\n-                    },\n-                    // foo == &bar\n-                    (_, &ExprKind::AddrOf(BorrowKind::Ref, _, r)) => {\n-                        let rty = cx.typeck_results().expr_ty(r);\n-                        if let Some((self_ty, other_ty)) = in_impl(cx, e, trait_id) {\n-                            let lty = cx.typeck_results().expr_ty(left);\n-                            if (are_equal(cx, rty, self_ty) && are_equal(cx, lty, other_ty))\n-                                || (are_equal(cx, rty, other_ty) && are_equal(cx, lty, self_ty))\n-                            {\n-                                return; // Don't lint\n-                            }\n-                        }\n-                        let rcpy = is_copy(cx, rty);\n-                        if (requires_ref || rcpy)\n-                            && implements_trait(cx, cx.typeck_results().expr_ty(left), trait_id, &[rty.into()])\n-                        {\n-                            span_lint_and_then(cx, OP_REF, e.span, \"taken reference of right operand\", |diag| {\n-                                let rsnip = snippet(cx, r.span, \"...\").to_string();\n-                                diag.span_suggestion(\n-                                    right.span,\n-                                    \"use the right value directly\",\n-                                    rsnip,\n-                                    Applicability::MaybeIncorrect, // FIXME #2597\n-                                );\n-                            });\n-                        }\n-                    },\n-                    _ => {},\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn in_impl<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    e: &'tcx Expr<'_>,\n-    bin_op: DefId,\n-) -> Option<(&'tcx rustc_hir::Ty<'tcx>, &'tcx rustc_hir::Ty<'tcx>)> {\n-    if_chain! {\n-        if let Some(block) = get_enclosing_block(cx, e.hir_id);\n-        if let Some(impl_def_id) = cx.tcx.impl_of_method(block.hir_id.owner.to_def_id());\n-        let item = cx.tcx.hir().expect_item(impl_def_id.expect_local());\n-        if let ItemKind::Impl(item) = &item.kind;\n-        if let Some(of_trait) = &item.of_trait;\n-        if let Some(seg) = of_trait.path.segments.last();\n-        if let Some(Res::Def(_, trait_id)) = seg.res;\n-        if trait_id == bin_op;\n-        if let Some(generic_args) = seg.args;\n-        if let Some(GenericArg::Type(other_ty)) = generic_args.args.last();\n-\n-        then {\n-            Some((item.self_ty, other_ty))\n-        }\n-        else {\n-            None\n-        }\n-    }\n-}\n-\n-fn are_equal<'tcx>(cx: &LateContext<'tcx>, middle_ty: Ty<'_>, hir_ty: &rustc_hir::Ty<'_>) -> bool {\n-    if_chain! {\n-        if let ty::Adt(adt_def, _) = middle_ty.kind();\n-        if let Some(local_did) = adt_def.did().as_local();\n-        let item = cx.tcx.hir().expect_item(local_did);\n-        let middle_ty_id = item.def_id.to_def_id();\n-        if let TyKind::Path(QPath::Resolved(_, path)) = hir_ty.kind;\n-        if let Res::Def(_, hir_ty_id) = path.res;\n-\n-        then {\n-            hir_ty_id == middle_ty_id\n-        }\n-        else {\n-            false\n-        }\n-    }\n-}"}, {"sha": "c1a84973c42114945130d4c5e9fbeeba75042efd", "filename": "src/tools/clippy/clippy_lints/src/erasing_op.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ferasing_op.rs?ref=a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58", "patch": "@@ -1,77 +0,0 @@\n-use clippy_utils::consts::{constant_simple, Constant};\n-use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::ty::same_type_and_consts;\n-\n-use rustc_hir::{BinOpKind, Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::TypeckResults;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for erasing operations, e.g., `x * 0`.\n-    ///\n-    /// ### Why is this bad?\n-    /// The whole expression can be replaced by zero.\n-    /// This is most likely not the intended outcome and should probably be\n-    /// corrected\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x = 1;\n-    /// 0 / x;\n-    /// 0 * x;\n-    /// x & 0;\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub ERASING_OP,\n-    correctness,\n-    \"using erasing operations, e.g., `x * 0` or `y & 0`\"\n-}\n-\n-declare_lint_pass!(ErasingOp => [ERASING_OP]);\n-\n-impl<'tcx> LateLintPass<'tcx> for ErasingOp {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if e.span.from_expansion() {\n-            return;\n-        }\n-        if let ExprKind::Binary(ref cmp, left, right) = e.kind {\n-            let tck = cx.typeck_results();\n-            match cmp.node {\n-                BinOpKind::Mul | BinOpKind::BitAnd => {\n-                    check(cx, tck, left, right, e);\n-                    check(cx, tck, right, left, e);\n-                },\n-                BinOpKind::Div => check(cx, tck, left, right, e),\n-                _ => (),\n-            }\n-        }\n-    }\n-}\n-\n-fn different_types(tck: &TypeckResults<'_>, input: &Expr<'_>, output: &Expr<'_>) -> bool {\n-    let input_ty = tck.expr_ty(input).peel_refs();\n-    let output_ty = tck.expr_ty(output).peel_refs();\n-    !same_type_and_consts(input_ty, output_ty)\n-}\n-\n-fn check<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    tck: &TypeckResults<'tcx>,\n-    op: &Expr<'tcx>,\n-    other: &Expr<'tcx>,\n-    parent: &Expr<'tcx>,\n-) {\n-    if constant_simple(cx, tck, op) == Some(Constant::Int(0)) {\n-        if different_types(tck, other, parent) {\n-            return;\n-        }\n-        span_lint(\n-            cx,\n-            ERASING_OP,\n-            parent.span,\n-            \"this operation will always return zero. This is likely not the intended outcome\",\n-        );\n-    }\n-}"}, {"sha": "7a65b849a6643e5d77d87f8e8661b91471edd6dc", "filename": "src/tools/clippy/clippy_lints/src/escape.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::diagnostics::span_lint_hir;\n use clippy_utils::ty::contains_ty;\n use rustc_hir::intravisit;\n use rustc_hir::{self, AssocItemKind, Body, FnDecl, HirId, HirIdSet, Impl, ItemKind, Node};\n@@ -118,9 +118,10 @@ impl<'tcx> LateLintPass<'tcx> for BoxedLocal {\n         });\n \n         for node in v.set {\n-            span_lint(\n+            span_lint_hir(\n                 cx,\n                 BOXED_LOCAL,\n+                node,\n                 cx.tcx.hir().span(node),\n                 \"local variable doesn't need to be boxed here\",\n             );"}, {"sha": "98aee7592ae80a496bde4da3e3f47327a7a547b3", "filename": "src/tools/clippy/clippy_lints/src/float_equality_without_abs.rs", "status": "removed", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs?ref=a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58", "patch": "@@ -1,116 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::{match_def_path, paths, sugg};\n-use if_chain::if_chain;\n-use rustc_ast::util::parser::AssocOp;\n-use rustc_errors::Applicability;\n-use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::{BinOpKind, Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Spanned;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for statements of the form `(a - b) < f32::EPSILON` or\n-    /// `(a - b) < f64::EPSILON`. Notes the missing `.abs()`.\n-    ///\n-    /// ### Why is this bad?\n-    /// The code without `.abs()` is more likely to have a bug.\n-    ///\n-    /// ### Known problems\n-    /// If the user can ensure that b is larger than a, the `.abs()` is\n-    /// technically unnecessary. However, it will make the code more robust and doesn't have any\n-    /// large performance implications. If the abs call was deliberately left out for performance\n-    /// reasons, it is probably better to state this explicitly in the code, which then can be done\n-    /// with an allow.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// pub fn is_roughly_equal(a: f32, b: f32) -> bool {\n-    ///     (a - b) < f32::EPSILON\n-    /// }\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// pub fn is_roughly_equal(a: f32, b: f32) -> bool {\n-    ///     (a - b).abs() < f32::EPSILON\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.48.0\"]\n-    pub FLOAT_EQUALITY_WITHOUT_ABS,\n-    suspicious,\n-    \"float equality check without `.abs()`\"\n-}\n-\n-declare_lint_pass!(FloatEqualityWithoutAbs => [FLOAT_EQUALITY_WITHOUT_ABS]);\n-\n-impl<'tcx> LateLintPass<'tcx> for FloatEqualityWithoutAbs {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        let lhs;\n-        let rhs;\n-\n-        // check if expr is a binary expression with a lt or gt operator\n-        if let ExprKind::Binary(op, left, right) = expr.kind {\n-            match op.node {\n-                BinOpKind::Lt => {\n-                    lhs = left;\n-                    rhs = right;\n-                },\n-                BinOpKind::Gt => {\n-                    lhs = right;\n-                    rhs = left;\n-                },\n-                _ => return,\n-            };\n-        } else {\n-            return;\n-        }\n-\n-        if_chain! {\n-\n-            // left hand side is a subtraction\n-            if let ExprKind::Binary(\n-                Spanned {\n-                    node: BinOpKind::Sub,\n-                    ..\n-                },\n-                val_l,\n-                val_r,\n-            ) = lhs.kind;\n-\n-            // right hand side matches either f32::EPSILON or f64::EPSILON\n-            if let ExprKind::Path(ref epsilon_path) = rhs.kind;\n-            if let Res::Def(DefKind::AssocConst, def_id) = cx.qpath_res(epsilon_path, rhs.hir_id);\n-            if match_def_path(cx, def_id, &paths::F32_EPSILON) || match_def_path(cx, def_id, &paths::F64_EPSILON);\n-\n-            // values of the subtractions on the left hand side are of the type float\n-            let t_val_l = cx.typeck_results().expr_ty(val_l);\n-            let t_val_r = cx.typeck_results().expr_ty(val_r);\n-            if let ty::Float(_) = t_val_l.kind();\n-            if let ty::Float(_) = t_val_r.kind();\n-\n-            then {\n-                let sug_l = sugg::Sugg::hir(cx, val_l, \"..\");\n-                let sug_r = sugg::Sugg::hir(cx, val_r, \"..\");\n-                // format the suggestion\n-                let suggestion = format!(\"{}.abs()\", sugg::make_assoc(AssocOp::Subtract, &sug_l, &sug_r).maybe_par());\n-                // spans the lint\n-                span_lint_and_then(\n-                    cx,\n-                    FLOAT_EQUALITY_WITHOUT_ABS,\n-                    expr.span,\n-                    \"float equality check without `.abs()`\",\n-                    | diag | {\n-                        diag.span_suggestion(\n-                            lhs.span,\n-                            \"add `.abs()`\",\n-                            suggestion,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "a6610ade37e56291400196d6ab02553ba11abe7f", "filename": "src/tools/clippy/clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_return.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::{\n-    diagnostics::span_lint_and_sugg,\n+    diagnostics::span_lint_hir_and_then,\n     get_async_fn_body, is_async_fn,\n     source::{snippet_with_applicability, snippet_with_context, walk_span_to_context},\n     visitors::expr_visitor_no_bodies,\n@@ -43,31 +43,38 @@ declare_clippy_lint! {\n \n declare_lint_pass!(ImplicitReturn => [IMPLICIT_RETURN]);\n \n-fn lint_return(cx: &LateContext<'_>, span: Span) {\n+fn lint_return(cx: &LateContext<'_>, emission_place: HirId, span: Span) {\n     let mut app = Applicability::MachineApplicable;\n     let snip = snippet_with_applicability(cx, span, \"..\", &mut app);\n-    span_lint_and_sugg(\n+    span_lint_hir_and_then(\n         cx,\n         IMPLICIT_RETURN,\n+        emission_place,\n         span,\n         \"missing `return` statement\",\n-        \"add `return` as shown\",\n-        format!(\"return {}\", snip),\n-        app,\n+        |diag| {\n+            diag.span_suggestion(span, \"add `return` as shown\", format!(\"return {}\", snip), app);\n+        },\n     );\n }\n \n-fn lint_break(cx: &LateContext<'_>, break_span: Span, expr_span: Span) {\n+fn lint_break(cx: &LateContext<'_>, emission_place: HirId, break_span: Span, expr_span: Span) {\n     let mut app = Applicability::MachineApplicable;\n     let snip = snippet_with_context(cx, expr_span, break_span.ctxt(), \"..\", &mut app).0;\n-    span_lint_and_sugg(\n+    span_lint_hir_and_then(\n         cx,\n         IMPLICIT_RETURN,\n+        emission_place,\n         break_span,\n         \"missing `return` statement\",\n-        \"change `break` to `return` as shown\",\n-        format!(\"return {}\", snip),\n-        app,\n+        |diag| {\n+            diag.span_suggestion(\n+                break_span,\n+                \"change `break` to `return` as shown\",\n+                format!(\"return {}\", snip),\n+                app,\n+            );\n+        },\n     );\n }\n \n@@ -152,7 +159,7 @@ fn lint_implicit_returns(\n                             // At this point sub_expr can be `None` in async functions which either diverge, or return\n                             // the unit type.\n                             if let Some(sub_expr) = sub_expr {\n-                                lint_break(cx, e.span, sub_expr.span);\n+                                lint_break(cx, e.hir_id, e.span, sub_expr.span);\n                             }\n                         } else {\n                             // the break expression is from a macro call, add a return to the loop\n@@ -166,10 +173,10 @@ fn lint_implicit_returns(\n             if add_return {\n                 #[expect(clippy::option_if_let_else)]\n                 if let Some(span) = call_site_span {\n-                    lint_return(cx, span);\n+                    lint_return(cx, expr.hir_id, span);\n                     LintLocation::Parent\n                 } else {\n-                    lint_return(cx, expr.span);\n+                    lint_return(cx, expr.hir_id, expr.span);\n                     LintLocation::Inner\n                 }\n             } else {\n@@ -198,10 +205,10 @@ fn lint_implicit_returns(\n         {\n             #[expect(clippy::option_if_let_else)]\n             if let Some(span) = call_site_span {\n-                lint_return(cx, span);\n+                lint_return(cx, expr.hir_id, span);\n                 LintLocation::Parent\n             } else {\n-                lint_return(cx, expr.span);\n+                lint_return(cx, expr.hir_id, expr.span);\n                 LintLocation::Inner\n             }\n         },"}, {"sha": "3effba5682607a241c208124760c2905a25c1997", "filename": "src/tools/clippy/clippy_lints/src/integer_division.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finteger_division.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finteger_division.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finteger_division.rs?ref=a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58", "patch": "@@ -1,61 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_help;\n-use if_chain::if_chain;\n-use rustc_hir as hir;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for division of integers\n-    ///\n-    /// ### Why is this bad?\n-    /// When outside of some very specific algorithms,\n-    /// integer division is very often a mistake because it discards the\n-    /// remainder.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x = 3 / 2;\n-    /// println!(\"{}\", x);\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// let x = 3f32 / 2f32;\n-    /// println!(\"{}\", x);\n-    /// ```\n-    #[clippy::version = \"1.37.0\"]\n-    pub INTEGER_DIVISION,\n-    restriction,\n-    \"integer division may cause loss of precision\"\n-}\n-\n-declare_lint_pass!(IntegerDivision => [INTEGER_DIVISION]);\n-\n-impl<'tcx> LateLintPass<'tcx> for IntegerDivision {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if is_integer_division(cx, expr) {\n-            span_lint_and_help(\n-                cx,\n-                INTEGER_DIVISION,\n-                expr.span,\n-                \"integer division\",\n-                None,\n-                \"division of integers may cause loss of precision. consider using floats\",\n-            );\n-        }\n-    }\n-}\n-\n-fn is_integer_division<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) -> bool {\n-    if_chain! {\n-        if let hir::ExprKind::Binary(binop, left, right) = &expr.kind;\n-        if binop.node == hir::BinOpKind::Div;\n-        then {\n-            let (left_ty, right_ty) = (cx.typeck_results().expr_ty(left), cx.typeck_results().expr_ty(right));\n-            return left_ty.is_integral() && right_ty.is_integral();\n-        }\n-    }\n-\n-    false\n-}"}, {"sha": "984c5cd4e37c26ff9ae249534651731f15d8928c", "filename": "src/tools/clippy/clippy_lints/src/large_const_arrays.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -24,7 +24,7 @@ declare_clippy_lint! {\n     /// ```\n     ///\n     /// Use instead:\n-    /// ```rust.ignore\n+    /// ```rust,ignore\n     /// pub static a = [0u32; 1_000_000];\n     /// ```\n     #[clippy::version = \"1.44.0\"]"}, {"sha": "176787497ebf2e655f93ba77b15e1c41436aa87a", "filename": "src/tools/clippy/clippy_lints/src/let_underscore.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -99,12 +99,13 @@ declare_clippy_lint! {\n \n declare_lint_pass!(LetUnderscore => [LET_UNDERSCORE_MUST_USE, LET_UNDERSCORE_LOCK, LET_UNDERSCORE_DROP]);\n \n-const SYNC_GUARD_PATHS: [&[&str]; 5] = [\n+const SYNC_GUARD_PATHS: [&[&str]; 6] = [\n     &paths::MUTEX_GUARD,\n     &paths::RWLOCK_READ_GUARD,\n     &paths::RWLOCK_WRITE_GUARD,\n-    &paths::PARKING_LOT_RAWMUTEX,\n-    &paths::PARKING_LOT_RAWRWLOCK,\n+    &paths::PARKING_LOT_MUTEX_GUARD,\n+    &paths::PARKING_LOT_RWLOCK_READ_GUARD,\n+    &paths::PARKING_LOT_RWLOCK_WRITE_GUARD,\n ];\n \n impl<'tcx> LateLintPass<'tcx> for LetUnderscore {"}, {"sha": "563ad891603a7b74882191c203f72da3fedf2c34", "filename": "src/tools/clippy/clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -3,12 +3,9 @@\n // Manual edits will be overwritten.\n \n store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n-    LintId::of(absurd_extreme_comparisons::ABSURD_EXTREME_COMPARISONS),\n     LintId::of(almost_complete_letter_range::ALMOST_COMPLETE_LETTER_RANGE),\n     LintId::of(approx_const::APPROX_CONSTANT),\n     LintId::of(assertions_on_constants::ASSERTIONS_ON_CONSTANTS),\n-    LintId::of(assign_ops::ASSIGN_OP_PATTERN),\n-    LintId::of(assign_ops::MISREFACTORED_ASSIGN_OP),\n     LintId::of(async_yields_async::ASYNC_YIELDS_ASYNC),\n     LintId::of(attrs::BLANKET_CLIPPY_RESTRICTION_LINTS),\n     LintId::of(attrs::DEPRECATED_CFG_ATTR),\n@@ -18,8 +15,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(await_holding_invalid::AWAIT_HOLDING_INVALID_TYPE),\n     LintId::of(await_holding_invalid::AWAIT_HOLDING_LOCK),\n     LintId::of(await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n-    LintId::of(bit_mask::BAD_BIT_MASK),\n-    LintId::of(bit_mask::INEFFECTIVE_BIT_MASK),\n     LintId::of(blacklisted_name::BLACKLISTED_NAME),\n     LintId::of(blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n     LintId::of(bool_assert_comparison::BOOL_ASSERT_COMPARISON),\n@@ -43,6 +38,8 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(copies::IF_SAME_THEN_ELSE),\n     LintId::of(crate_in_macro_def::CRATE_IN_MACRO_DEF),\n     LintId::of(default::FIELD_REASSIGN_WITH_DEFAULT),\n+    LintId::of(default_instead_of_iter_empty::DEFAULT_INSTEAD_OF_ITER_EMPTY),\n+    LintId::of(dereference::EXPLICIT_AUTO_DEREF),\n     LintId::of(dereference::NEEDLESS_BORROW),\n     LintId::of(derivable_impls::DERIVABLE_IMPLS),\n     LintId::of(derive::DERIVE_HASH_XOR_EQ),\n@@ -52,7 +49,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(disallowed_types::DISALLOWED_TYPES),\n     LintId::of(doc::MISSING_SAFETY_DOC),\n     LintId::of(doc::NEEDLESS_DOCTEST_MAIN),\n-    LintId::of(double_comparison::DOUBLE_COMPARISONS),\n     LintId::of(double_parens::DOUBLE_PARENS),\n     LintId::of(drop_forget_ref::DROP_COPY),\n     LintId::of(drop_forget_ref::DROP_NON_DROP),\n@@ -62,18 +58,13 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(drop_forget_ref::FORGET_REF),\n     LintId::of(drop_forget_ref::UNDROPPED_MANUALLY_DROPS),\n     LintId::of(duplicate_mod::DUPLICATE_MOD),\n-    LintId::of(duration_subsec::DURATION_SUBSEC),\n     LintId::of(entry::MAP_ENTRY),\n     LintId::of(enum_clike::ENUM_CLIKE_UNPORTABLE_VARIANT),\n     LintId::of(enum_variants::ENUM_VARIANT_NAMES),\n     LintId::of(enum_variants::MODULE_INCEPTION),\n-    LintId::of(eq_op::EQ_OP),\n-    LintId::of(eq_op::OP_REF),\n-    LintId::of(erasing_op::ERASING_OP),\n     LintId::of(escape::BOXED_LOCAL),\n     LintId::of(eta_reduction::REDUNDANT_CLOSURE),\n     LintId::of(explicit_write::EXPLICIT_WRITE),\n-    LintId::of(float_equality_without_abs::FLOAT_EQUALITY_WITHOUT_ABS),\n     LintId::of(float_literal::EXCESSIVE_PRECISION),\n     LintId::of(format::USELESS_FORMAT),\n     LintId::of(format_args::FORMAT_IN_FORMAT_ARGS),\n@@ -93,7 +84,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(functions::RESULT_UNIT_ERR),\n     LintId::of(functions::TOO_MANY_ARGUMENTS),\n     LintId::of(get_first::GET_FIRST),\n-    LintId::of(identity_op::IDENTITY_OP),\n     LintId::of(if_let_mutex::IF_LET_MUTEX),\n     LintId::of(indexing_slicing::OUT_OF_BOUNDS_INDEXING),\n     LintId::of(infinite_iter::INFINITE_ITER),\n@@ -118,6 +108,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(loops::FOR_KV_MAP),\n     LintId::of(loops::FOR_LOOPS_OVER_FALLIBLES),\n     LintId::of(loops::ITER_NEXT_LOOP),\n+    LintId::of(loops::MANUAL_FIND),\n     LintId::of(loops::MANUAL_FLATTEN),\n     LintId::of(loops::MANUAL_MEMCPY),\n     LintId::of(loops::MISSING_SPIN_LOOP),\n@@ -134,6 +125,8 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(manual_async_fn::MANUAL_ASYNC_FN),\n     LintId::of(manual_bits::MANUAL_BITS),\n     LintId::of(manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n+    LintId::of(manual_rem_euclid::MANUAL_REM_EUCLID),\n+    LintId::of(manual_retain::MANUAL_RETAIN),\n     LintId::of(manual_strip::MANUAL_STRIP),\n     LintId::of(map_clone::MAP_CLONE),\n     LintId::of(map_unit_fn::OPTION_MAP_UNIT_FN),\n@@ -220,9 +213,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(methods::WRONG_SELF_CONVENTION),\n     LintId::of(methods::ZST_OFFSET),\n     LintId::of(minmax::MIN_MAX),\n-    LintId::of(misc::CMP_NAN),\n-    LintId::of(misc::CMP_OWNED),\n-    LintId::of(misc::MODULO_ONE),\n     LintId::of(misc::SHORT_CIRCUIT_STATEMENT),\n     LintId::of(misc::TOPLEVEL_REF_ARG),\n     LintId::of(misc::ZERO_PTR),\n@@ -256,6 +246,23 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS),\n     LintId::of(octal_escapes::OCTAL_ESCAPES),\n     LintId::of(open_options::NONSENSICAL_OPEN_OPTIONS),\n+    LintId::of(operators::ABSURD_EXTREME_COMPARISONS),\n+    LintId::of(operators::ASSIGN_OP_PATTERN),\n+    LintId::of(operators::BAD_BIT_MASK),\n+    LintId::of(operators::CMP_NAN),\n+    LintId::of(operators::CMP_OWNED),\n+    LintId::of(operators::DOUBLE_COMPARISONS),\n+    LintId::of(operators::DURATION_SUBSEC),\n+    LintId::of(operators::EQ_OP),\n+    LintId::of(operators::ERASING_OP),\n+    LintId::of(operators::FLOAT_EQUALITY_WITHOUT_ABS),\n+    LintId::of(operators::IDENTITY_OP),\n+    LintId::of(operators::INEFFECTIVE_BIT_MASK),\n+    LintId::of(operators::MISREFACTORED_ASSIGN_OP),\n+    LintId::of(operators::MODULO_ONE),\n+    LintId::of(operators::OP_REF),\n+    LintId::of(operators::PTR_EQ),\n+    LintId::of(operators::SELF_ASSIGNMENT),\n     LintId::of(option_env_unwrap::OPTION_ENV_UNWRAP),\n     LintId::of(overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL),\n     LintId::of(partialeq_ne_impl::PARTIALEQ_NE_IMPL),\n@@ -264,7 +271,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(ptr::INVALID_NULL_PTR_USAGE),\n     LintId::of(ptr::MUT_FROM_REF),\n     LintId::of(ptr::PTR_ARG),\n-    LintId::of(ptr_eq::PTR_EQ),\n     LintId::of(ptr_offset_with_cast::PTR_OFFSET_WITH_CAST),\n     LintId::of(question_mark::QUESTION_MARK),\n     LintId::of(ranges::MANUAL_RANGE_CONTAINS),\n@@ -282,7 +288,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(repeat_once::REPEAT_ONCE),\n     LintId::of(returns::LET_AND_RETURN),\n     LintId::of(returns::NEEDLESS_RETURN),\n-    LintId::of(self_assignment::SELF_ASSIGNMENT),\n     LintId::of(self_named_constructors::SELF_NAMED_CONSTRUCTORS),\n     LintId::of(serde_api::SERDE_API_MISUSE),\n     LintId::of(single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),"}, {"sha": "3784d3c68dceef2046f01b4f2a0393004867e35a", "filename": "src/tools/clippy/clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -9,21 +9,21 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(bytes_count_to_len::BYTES_COUNT_TO_LEN),\n     LintId::of(casts::CHAR_LIT_AS_U8),\n     LintId::of(casts::UNNECESSARY_CAST),\n+    LintId::of(dereference::EXPLICIT_AUTO_DEREF),\n     LintId::of(derivable_impls::DERIVABLE_IMPLS),\n-    LintId::of(double_comparison::DOUBLE_COMPARISONS),\n     LintId::of(double_parens::DOUBLE_PARENS),\n-    LintId::of(duration_subsec::DURATION_SUBSEC),\n     LintId::of(explicit_write::EXPLICIT_WRITE),\n     LintId::of(format::USELESS_FORMAT),\n     LintId::of(functions::TOO_MANY_ARGUMENTS),\n-    LintId::of(identity_op::IDENTITY_OP),\n     LintId::of(int_plus_one::INT_PLUS_ONE),\n     LintId::of(lifetimes::EXTRA_UNUSED_LIFETIMES),\n     LintId::of(lifetimes::NEEDLESS_LIFETIMES),\n     LintId::of(loops::EXPLICIT_COUNTER_LOOP),\n+    LintId::of(loops::MANUAL_FIND),\n     LintId::of(loops::MANUAL_FLATTEN),\n     LintId::of(loops::SINGLE_ELEMENT_LOOP),\n     LintId::of(loops::WHILE_LET_LOOP),\n+    LintId::of(manual_rem_euclid::MANUAL_REM_EUCLID),\n     LintId::of(manual_strip::MANUAL_STRIP),\n     LintId::of(map_unit_fn::OPTION_MAP_UNIT_FN),\n     LintId::of(map_unit_fn::RESULT_MAP_UNIT_FN),\n@@ -69,6 +69,9 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD),\n     LintId::of(no_effect::NO_EFFECT),\n     LintId::of(no_effect::UNNECESSARY_OPERATION),\n+    LintId::of(operators::DOUBLE_COMPARISONS),\n+    LintId::of(operators::DURATION_SUBSEC),\n+    LintId::of(operators::IDENTITY_OP),\n     LintId::of(overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL),\n     LintId::of(partialeq_ne_impl::PARTIALEQ_NE_IMPL),\n     LintId::of(precedence::PRECEDENCE),"}, {"sha": "7d5e65cb27a1f709177d69e5b2105d16a69cb581", "filename": "src/tools/clippy/clippy_lints/src/lib.register_correctness.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_correctness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_correctness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_correctness.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -3,14 +3,11 @@\n // Manual edits will be overwritten.\n \n store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), vec![\n-    LintId::of(absurd_extreme_comparisons::ABSURD_EXTREME_COMPARISONS),\n     LintId::of(approx_const::APPROX_CONSTANT),\n     LintId::of(async_yields_async::ASYNC_YIELDS_ASYNC),\n     LintId::of(attrs::DEPRECATED_SEMVER),\n     LintId::of(attrs::MISMATCHED_TARGET_OS),\n     LintId::of(attrs::USELESS_ATTRIBUTE),\n-    LintId::of(bit_mask::BAD_BIT_MASK),\n-    LintId::of(bit_mask::INEFFECTIVE_BIT_MASK),\n     LintId::of(booleans::LOGIC_BUG),\n     LintId::of(casts::CAST_REF_TO_MUT),\n     LintId::of(casts::CAST_SLICE_DIFFERENT_SIZES),\n@@ -24,8 +21,6 @@ store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), ve\n     LintId::of(drop_forget_ref::FORGET_REF),\n     LintId::of(drop_forget_ref::UNDROPPED_MANUALLY_DROPS),\n     LintId::of(enum_clike::ENUM_CLIKE_UNPORTABLE_VARIANT),\n-    LintId::of(eq_op::EQ_OP),\n-    LintId::of(erasing_op::ERASING_OP),\n     LintId::of(format_impl::RECURSIVE_FORMAT_IMPL),\n     LintId::of(formatting::POSSIBLE_MISSING_COMMA),\n     LintId::of(functions::NOT_UNSAFE_PTR_ARG_DEREF),\n@@ -47,17 +42,22 @@ store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), ve\n     LintId::of(methods::UNINIT_ASSUMED_INIT),\n     LintId::of(methods::ZST_OFFSET),\n     LintId::of(minmax::MIN_MAX),\n-    LintId::of(misc::CMP_NAN),\n-    LintId::of(misc::MODULO_ONE),\n     LintId::of(non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS),\n     LintId::of(open_options::NONSENSICAL_OPEN_OPTIONS),\n+    LintId::of(operators::ABSURD_EXTREME_COMPARISONS),\n+    LintId::of(operators::BAD_BIT_MASK),\n+    LintId::of(operators::CMP_NAN),\n+    LintId::of(operators::EQ_OP),\n+    LintId::of(operators::ERASING_OP),\n+    LintId::of(operators::INEFFECTIVE_BIT_MASK),\n+    LintId::of(operators::MODULO_ONE),\n+    LintId::of(operators::SELF_ASSIGNMENT),\n     LintId::of(option_env_unwrap::OPTION_ENV_UNWRAP),\n     LintId::of(ptr::INVALID_NULL_PTR_USAGE),\n     LintId::of(ptr::MUT_FROM_REF),\n     LintId::of(ranges::REVERSED_EMPTY_RANGES),\n     LintId::of(read_zero_byte_vec::READ_ZERO_BYTE_VEC),\n     LintId::of(regex::INVALID_REGEX),\n-    LintId::of(self_assignment::SELF_ASSIGNMENT),\n     LintId::of(serde_api::SERDE_API_MISUSE),\n     LintId::of(size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT),\n     LintId::of(swap::ALMOST_SWAPPED),"}, {"sha": "be63646a12f51dca756146bb026884dea50b4cc8", "filename": "src/tools/clippy/clippy_lints/src/lib.register_internal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_internal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_internal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_internal.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -6,6 +6,7 @@ store.register_group(true, \"clippy::internal\", Some(\"clippy_internal\"), vec![\n     LintId::of(utils::internal_lints::CLIPPY_LINTS_INTERNAL),\n     LintId::of(utils::internal_lints::COLLAPSIBLE_SPAN_LINT_CALLS),\n     LintId::of(utils::internal_lints::COMPILER_LINT_FUNCTIONS),\n+    LintId::of(utils::internal_lints::DEFAULT_DEPRECATION_REASON),\n     LintId::of(utils::internal_lints::DEFAULT_LINT),\n     LintId::of(utils::internal_lints::IF_CHAIN_STYLE),\n     LintId::of(utils::internal_lints::INTERNING_DEFINED_SYMBOL),"}, {"sha": "d3c75f8b519107654df8d992bb677017deb594a1", "filename": "src/tools/clippy/clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -10,6 +10,8 @@ store.register_lints(&[\n     #[cfg(feature = \"internal\")]\n     utils::internal_lints::COMPILER_LINT_FUNCTIONS,\n     #[cfg(feature = \"internal\")]\n+    utils::internal_lints::DEFAULT_DEPRECATION_REASON,\n+    #[cfg(feature = \"internal\")]\n     utils::internal_lints::DEFAULT_LINT,\n     #[cfg(feature = \"internal\")]\n     utils::internal_lints::IF_CHAIN_STYLE,\n@@ -33,16 +35,13 @@ store.register_lints(&[\n     utils::internal_lints::PRODUCE_ICE,\n     #[cfg(feature = \"internal\")]\n     utils::internal_lints::UNNECESSARY_SYMBOL_STR,\n-    absurd_extreme_comparisons::ABSURD_EXTREME_COMPARISONS,\n     almost_complete_letter_range::ALMOST_COMPLETE_LETTER_RANGE,\n     approx_const::APPROX_CONSTANT,\n     as_conversions::AS_CONVERSIONS,\n     as_underscore::AS_UNDERSCORE,\n     asm_syntax::INLINE_ASM_X86_ATT_SYNTAX,\n     asm_syntax::INLINE_ASM_X86_INTEL_SYNTAX,\n     assertions_on_constants::ASSERTIONS_ON_CONSTANTS,\n-    assign_ops::ASSIGN_OP_PATTERN,\n-    assign_ops::MISREFACTORED_ASSIGN_OP,\n     async_yields_async::ASYNC_YIELDS_ASYNC,\n     attrs::ALLOW_ATTRIBUTES_WITHOUT_REASON,\n     attrs::BLANKET_CLIPPY_RESTRICTION_LINTS,\n@@ -55,9 +54,6 @@ store.register_lints(&[\n     await_holding_invalid::AWAIT_HOLDING_INVALID_TYPE,\n     await_holding_invalid::AWAIT_HOLDING_LOCK,\n     await_holding_invalid::AWAIT_HOLDING_REFCELL_REF,\n-    bit_mask::BAD_BIT_MASK,\n-    bit_mask::INEFFECTIVE_BIT_MASK,\n-    bit_mask::VERBOSE_BIT_MASK,\n     blacklisted_name::BLACKLISTED_NAME,\n     blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS,\n     bool_assert_comparison::BOOL_ASSERT_COMPARISON,\n@@ -105,8 +101,10 @@ store.register_lints(&[\n     dbg_macro::DBG_MACRO,\n     default::DEFAULT_TRAIT_ACCESS,\n     default::FIELD_REASSIGN_WITH_DEFAULT,\n+    default_instead_of_iter_empty::DEFAULT_INSTEAD_OF_ITER_EMPTY,\n     default_numeric_fallback::DEFAULT_NUMERIC_FALLBACK,\n     default_union_representation::DEFAULT_UNION_REPRESENTATION,\n+    dereference::EXPLICIT_AUTO_DEREF,\n     dereference::EXPLICIT_DEREF_METHODS,\n     dereference::NEEDLESS_BORROW,\n     dereference::REF_BINDING_TO_REFERENCE,\n@@ -125,7 +123,6 @@ store.register_lints(&[\n     doc::MISSING_SAFETY_DOC,\n     doc::NEEDLESS_DOCTEST_MAIN,\n     doc_link_with_quotes::DOC_LINK_WITH_QUOTES,\n-    double_comparison::DOUBLE_COMPARISONS,\n     double_parens::DOUBLE_PARENS,\n     drop_forget_ref::DROP_COPY,\n     drop_forget_ref::DROP_NON_DROP,\n@@ -135,7 +132,6 @@ store.register_lints(&[\n     drop_forget_ref::FORGET_REF,\n     drop_forget_ref::UNDROPPED_MANUALLY_DROPS,\n     duplicate_mod::DUPLICATE_MOD,\n-    duration_subsec::DURATION_SUBSEC,\n     else_if_without_else::ELSE_IF_WITHOUT_ELSE,\n     empty_drop::EMPTY_DROP,\n     empty_enum::EMPTY_ENUM,\n@@ -145,10 +141,7 @@ store.register_lints(&[\n     enum_variants::ENUM_VARIANT_NAMES,\n     enum_variants::MODULE_INCEPTION,\n     enum_variants::MODULE_NAME_REPETITIONS,\n-    eq_op::EQ_OP,\n-    eq_op::OP_REF,\n     equatable_if_let::EQUATABLE_IF_LET,\n-    erasing_op::ERASING_OP,\n     escape::BOXED_LOCAL,\n     eta_reduction::REDUNDANT_CLOSURE,\n     eta_reduction::REDUNDANT_CLOSURE_FOR_METHOD_CALLS,\n@@ -159,7 +152,6 @@ store.register_lints(&[\n     exit::EXIT,\n     explicit_write::EXPLICIT_WRITE,\n     fallible_impl_from::FALLIBLE_IMPL_FROM,\n-    float_equality_without_abs::FLOAT_EQUALITY_WITHOUT_ABS,\n     float_literal::EXCESSIVE_PRECISION,\n     float_literal::LOSSY_FLOAT_LITERAL,\n     floating_point_arithmetic::IMPRECISE_FLOPS,\n@@ -185,7 +177,6 @@ store.register_lints(&[\n     functions::TOO_MANY_LINES,\n     future_not_send::FUTURE_NOT_SEND,\n     get_first::GET_FIRST,\n-    identity_op::IDENTITY_OP,\n     if_let_mutex::IF_LET_MUTEX,\n     if_not_else::IF_NOT_ELSE,\n     if_then_some_else_none::IF_THEN_SOME_ELSE_NONE,\n@@ -204,7 +195,6 @@ store.register_lints(&[\n     init_numbered_fields::INIT_NUMBERED_FIELDS,\n     inline_fn_without_body::INLINE_FN_WITHOUT_BODY,\n     int_plus_one::INT_PLUS_ONE,\n-    integer_division::INTEGER_DIVISION,\n     invalid_upcast_comparisons::INVALID_UPCAST_COMPARISONS,\n     items_after_statements::ITEMS_AFTER_STATEMENTS,\n     iter_not_returning_iterator::ITER_NOT_RETURNING_ITERATOR,\n@@ -234,6 +224,7 @@ store.register_lints(&[\n     loops::FOR_KV_MAP,\n     loops::FOR_LOOPS_OVER_FALLIBLES,\n     loops::ITER_NEXT_LOOP,\n+    loops::MANUAL_FIND,\n     loops::MANUAL_FLATTEN,\n     loops::MANUAL_MEMCPY,\n     loops::MISSING_SPIN_LOOP,\n@@ -253,6 +244,8 @@ store.register_lints(&[\n     manual_bits::MANUAL_BITS,\n     manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE,\n     manual_ok_or::MANUAL_OK_OR,\n+    manual_rem_euclid::MANUAL_REM_EUCLID,\n+    manual_retain::MANUAL_RETAIN,\n     manual_strip::MANUAL_STRIP,\n     map_clone::MAP_CLONE,\n     map_err_ignore::MAP_ERR_IGNORE,\n@@ -364,11 +357,6 @@ store.register_lints(&[\n     methods::WRONG_SELF_CONVENTION,\n     methods::ZST_OFFSET,\n     minmax::MIN_MAX,\n-    misc::CMP_NAN,\n-    misc::CMP_OWNED,\n-    misc::FLOAT_CMP,\n-    misc::FLOAT_CMP_CONST,\n-    misc::MODULO_ONE,\n     misc::SHORT_CIRCUIT_STATEMENT,\n     misc::TOPLEVEL_REF_ARG,\n     misc::USED_UNDERSCORE_BINDING,\n@@ -392,7 +380,6 @@ store.register_lints(&[\n     mixed_read_write_in_expression::MIXED_READ_WRITE_IN_EXPRESSION,\n     module_style::MOD_MODULE_FILES,\n     module_style::SELF_NAMED_MODULE_FILES,\n-    modulo_arithmetic::MODULO_ARITHMETIC,\n     mut_key::MUTABLE_KEY_TYPE,\n     mut_mut::MUT_MUT,\n     mut_mutex_lock::MUT_MUTEX_LOCK,\n@@ -401,7 +388,6 @@ store.register_lints(&[\n     mutex_atomic::MUTEX_ATOMIC,\n     mutex_atomic::MUTEX_INTEGER,\n     needless_arbitrary_self_type::NEEDLESS_ARBITRARY_SELF_TYPE,\n-    needless_bitwise_bool::NEEDLESS_BITWISE_BOOL,\n     needless_bool::BOOL_COMPARISON,\n     needless_bool::NEEDLESS_BOOL,\n     needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE,\n@@ -426,11 +412,34 @@ store.register_lints(&[\n     non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS,\n     non_send_fields_in_send_ty::NON_SEND_FIELDS_IN_SEND_TY,\n     nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES,\n-    numeric_arithmetic::FLOAT_ARITHMETIC,\n-    numeric_arithmetic::INTEGER_ARITHMETIC,\n     octal_escapes::OCTAL_ESCAPES,\n     only_used_in_recursion::ONLY_USED_IN_RECURSION,\n     open_options::NONSENSICAL_OPEN_OPTIONS,\n+    operators::ABSURD_EXTREME_COMPARISONS,\n+    operators::ASSIGN_OP_PATTERN,\n+    operators::BAD_BIT_MASK,\n+    operators::CMP_NAN,\n+    operators::CMP_OWNED,\n+    operators::DOUBLE_COMPARISONS,\n+    operators::DURATION_SUBSEC,\n+    operators::EQ_OP,\n+    operators::ERASING_OP,\n+    operators::FLOAT_ARITHMETIC,\n+    operators::FLOAT_CMP,\n+    operators::FLOAT_CMP_CONST,\n+    operators::FLOAT_EQUALITY_WITHOUT_ABS,\n+    operators::IDENTITY_OP,\n+    operators::INEFFECTIVE_BIT_MASK,\n+    operators::INTEGER_ARITHMETIC,\n+    operators::INTEGER_DIVISION,\n+    operators::MISREFACTORED_ASSIGN_OP,\n+    operators::MODULO_ARITHMETIC,\n+    operators::MODULO_ONE,\n+    operators::NEEDLESS_BITWISE_BOOL,\n+    operators::OP_REF,\n+    operators::PTR_EQ,\n+    operators::SELF_ASSIGNMENT,\n+    operators::VERBOSE_BIT_MASK,\n     option_env_unwrap::OPTION_ENV_UNWRAP,\n     option_if_let_else::OPTION_IF_LET_ELSE,\n     overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL,\n@@ -449,7 +458,6 @@ store.register_lints(&[\n     ptr::INVALID_NULL_PTR_USAGE,\n     ptr::MUT_FROM_REF,\n     ptr::PTR_ARG,\n-    ptr_eq::PTR_EQ,\n     ptr_offset_with_cast::PTR_OFFSET_WITH_CAST,\n     pub_use::PUB_USE,\n     question_mark::QUESTION_MARK,\n@@ -477,7 +485,6 @@ store.register_lints(&[\n     returns::LET_AND_RETURN,\n     returns::NEEDLESS_RETURN,\n     same_name_method::SAME_NAME_METHOD,\n-    self_assignment::SELF_ASSIGNMENT,\n     self_named_constructors::SELF_NAMED_CONSTRUCTORS,\n     semicolon_if_nothing_returned::SEMICOLON_IF_NOTHING_RETURNED,\n     serde_api::SERDE_API_MISUSE,"}, {"sha": "a1b5466581491253448d7242ea16d6e2b4aa269d", "filename": "src/tools/clippy/clippy_lints/src/lib.register_pedantic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_pedantic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_pedantic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_pedantic.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -4,7 +4,6 @@\n \n store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(attrs::INLINE_ALWAYS),\n-    LintId::of(bit_mask::VERBOSE_BIT_MASK),\n     LintId::of(borrow_as_ptr::BORROW_AS_PTR),\n     LintId::of(bytecount::NAIVE_BYTECOUNT),\n     LintId::of(case_sensitive_file_extension_comparisons::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS),\n@@ -65,17 +64,18 @@ store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(methods::INEFFICIENT_TO_STRING),\n     LintId::of(methods::MAP_UNWRAP_OR),\n     LintId::of(methods::UNNECESSARY_JOIN),\n-    LintId::of(misc::FLOAT_CMP),\n     LintId::of(misc::USED_UNDERSCORE_BINDING),\n     LintId::of(mismatching_type_param_order::MISMATCHING_TYPE_PARAM_ORDER),\n     LintId::of(mut_mut::MUT_MUT),\n-    LintId::of(needless_bitwise_bool::NEEDLESS_BITWISE_BOOL),\n     LintId::of(needless_continue::NEEDLESS_CONTINUE),\n     LintId::of(needless_for_each::NEEDLESS_FOR_EACH),\n     LintId::of(needless_pass_by_value::NEEDLESS_PASS_BY_VALUE),\n     LintId::of(no_effect::NO_EFFECT_UNDERSCORE_BINDING),\n     LintId::of(non_expressive_names::MANY_SINGLE_CHAR_NAMES),\n     LintId::of(non_expressive_names::SIMILAR_NAMES),\n+    LintId::of(operators::FLOAT_CMP),\n+    LintId::of(operators::NEEDLESS_BITWISE_BOOL),\n+    LintId::of(operators::VERBOSE_BIT_MASK),\n     LintId::of(pass_by_ref_or_value::LARGE_TYPES_PASSED_BY_VALUE),\n     LintId::of(pass_by_ref_or_value::TRIVIALLY_COPY_PASS_BY_REF),\n     LintId::of(ranges::RANGE_MINUS_ONE),"}, {"sha": "6bf519c24e848ad2272d6f11e48b1e5166a32596", "filename": "src/tools/clippy/clippy_lints/src/lib.register_perf.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_perf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_perf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_perf.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -13,6 +13,7 @@ store.register_group(true, \"clippy::perf\", Some(\"clippy_perf\"), vec![\n     LintId::of(loops::MANUAL_MEMCPY),\n     LintId::of(loops::MISSING_SPIN_LOOP),\n     LintId::of(loops::NEEDLESS_COLLECT),\n+    LintId::of(manual_retain::MANUAL_RETAIN),\n     LintId::of(methods::EXPECT_FUN_CALL),\n     LintId::of(methods::EXTEND_WITH_DRAIN),\n     LintId::of(methods::ITER_NTH),\n@@ -21,7 +22,7 @@ store.register_group(true, \"clippy::perf\", Some(\"clippy_perf\"), vec![\n     LintId::of(methods::OR_FUN_CALL),\n     LintId::of(methods::SINGLE_CHAR_PATTERN),\n     LintId::of(methods::UNNECESSARY_TO_OWNED),\n-    LintId::of(misc::CMP_OWNED),\n+    LintId::of(operators::CMP_OWNED),\n     LintId::of(redundant_clone::REDUNDANT_CLONE),\n     LintId::of(slow_vector_initialization::SLOW_VECTOR_INITIALIZATION),\n     LintId::of(types::BOX_COLLECTION),"}, {"sha": "970e9db4772cb192eaf80ba336d213f92061f6e7", "filename": "src/tools/clippy/clippy_lints/src/lib.register_restriction.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_restriction.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -25,7 +25,6 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(implicit_return::IMPLICIT_RETURN),\n     LintId::of(indexing_slicing::INDEXING_SLICING),\n     LintId::of(inherent_impl::MULTIPLE_INHERENT_IMPL),\n-    LintId::of(integer_division::INTEGER_DIVISION),\n     LintId::of(large_include_file::LARGE_INCLUDE_FILE),\n     LintId::of(let_underscore::LET_UNDERSCORE_MUST_USE),\n     LintId::of(literal_representation::DECIMAL_LITERAL_REPRESENTATION),\n@@ -39,7 +38,6 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(methods::FILETYPE_IS_FILE),\n     LintId::of(methods::GET_UNWRAP),\n     LintId::of(methods::UNWRAP_USED),\n-    LintId::of(misc::FLOAT_CMP_CONST),\n     LintId::of(misc_early::SEPARATED_LITERAL_SUFFIX),\n     LintId::of(misc_early::UNNEEDED_FIELD_PATTERN),\n     LintId::of(misc_early::UNSEPARATED_LITERAL_SUFFIX),\n@@ -49,9 +47,11 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(mixed_read_write_in_expression::MIXED_READ_WRITE_IN_EXPRESSION),\n     LintId::of(module_style::MOD_MODULE_FILES),\n     LintId::of(module_style::SELF_NAMED_MODULE_FILES),\n-    LintId::of(modulo_arithmetic::MODULO_ARITHMETIC),\n-    LintId::of(numeric_arithmetic::FLOAT_ARITHMETIC),\n-    LintId::of(numeric_arithmetic::INTEGER_ARITHMETIC),\n+    LintId::of(operators::FLOAT_ARITHMETIC),\n+    LintId::of(operators::FLOAT_CMP_CONST),\n+    LintId::of(operators::INTEGER_ARITHMETIC),\n+    LintId::of(operators::INTEGER_DIVISION),\n+    LintId::of(operators::MODULO_ARITHMETIC),\n     LintId::of(panic_in_result_fn::PANIC_IN_RESULT_FN),\n     LintId::of(panic_unimplemented::PANIC),\n     LintId::of(panic_unimplemented::TODO),"}, {"sha": "15a1bc569af2332160e5ceac92fe3fa3f3e1d7ab", "filename": "src/tools/clippy/clippy_lints/src/lib.register_style.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_style.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -4,7 +4,6 @@\n \n store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(assertions_on_constants::ASSERTIONS_ON_CONSTANTS),\n-    LintId::of(assign_ops::ASSIGN_OP_PATTERN),\n     LintId::of(blacklisted_name::BLACKLISTED_NAME),\n     LintId::of(blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n     LintId::of(bool_assert_comparison::BOOL_ASSERT_COMPARISON),\n@@ -14,6 +13,7 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(collapsible_if::COLLAPSIBLE_IF),\n     LintId::of(comparison_chain::COMPARISON_CHAIN),\n     LintId::of(default::FIELD_REASSIGN_WITH_DEFAULT),\n+    LintId::of(default_instead_of_iter_empty::DEFAULT_INSTEAD_OF_ITER_EMPTY),\n     LintId::of(dereference::NEEDLESS_BORROW),\n     LintId::of(derive::DERIVE_PARTIAL_EQ_WITHOUT_EQ),\n     LintId::of(disallowed_methods::DISALLOWED_METHODS),\n@@ -22,7 +22,6 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(doc::NEEDLESS_DOCTEST_MAIN),\n     LintId::of(enum_variants::ENUM_VARIANT_NAMES),\n     LintId::of(enum_variants::MODULE_INCEPTION),\n-    LintId::of(eq_op::OP_REF),\n     LintId::of(eta_reduction::REDUNDANT_CLOSURE),\n     LintId::of(float_literal::EXCESSIVE_PRECISION),\n     LintId::of(from_over_into::FROM_OVER_INTO),\n@@ -97,9 +96,11 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(non_copy_const::BORROW_INTERIOR_MUTABLE_CONST),\n     LintId::of(non_copy_const::DECLARE_INTERIOR_MUTABLE_CONST),\n     LintId::of(non_expressive_names::JUST_UNDERSCORES_AND_DIGITS),\n+    LintId::of(operators::ASSIGN_OP_PATTERN),\n+    LintId::of(operators::OP_REF),\n+    LintId::of(operators::PTR_EQ),\n     LintId::of(ptr::CMP_NULL),\n     LintId::of(ptr::PTR_ARG),\n-    LintId::of(ptr_eq::PTR_EQ),\n     LintId::of(question_mark::QUESTION_MARK),\n     LintId::of(ranges::MANUAL_RANGE_CONTAINS),\n     LintId::of(redundant_field_names::REDUNDANT_FIELD_NAMES),"}, {"sha": "f7558f8709810fe51d3475758f954fa76fa7fece", "filename": "src/tools/clippy/clippy_lints/src/lib.register_suspicious.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_suspicious.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_suspicious.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_suspicious.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -4,7 +4,6 @@\n \n store.register_group(true, \"clippy::suspicious\", Some(\"clippy_suspicious\"), vec![\n     LintId::of(almost_complete_letter_range::ALMOST_COMPLETE_LETTER_RANGE),\n-    LintId::of(assign_ops::MISREFACTORED_ASSIGN_OP),\n     LintId::of(attrs::BLANKET_CLIPPY_RESTRICTION_LINTS),\n     LintId::of(await_holding_invalid::AWAIT_HOLDING_INVALID_TYPE),\n     LintId::of(await_holding_invalid::AWAIT_HOLDING_LOCK),\n@@ -16,7 +15,6 @@ store.register_group(true, \"clippy::suspicious\", Some(\"clippy_suspicious\"), vec!\n     LintId::of(drop_forget_ref::DROP_NON_DROP),\n     LintId::of(drop_forget_ref::FORGET_NON_DROP),\n     LintId::of(duplicate_mod::DUPLICATE_MOD),\n-    LintId::of(float_equality_without_abs::FLOAT_EQUALITY_WITHOUT_ABS),\n     LintId::of(format_impl::PRINT_IN_FORMAT_IMPL),\n     LintId::of(formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING),\n     LintId::of(formatting::SUSPICIOUS_ELSE_FORMATTING),\n@@ -29,6 +27,8 @@ store.register_group(true, \"clippy::suspicious\", Some(\"clippy_suspicious\"), vec!\n     LintId::of(methods::SUSPICIOUS_MAP),\n     LintId::of(mut_key::MUTABLE_KEY_TYPE),\n     LintId::of(octal_escapes::OCTAL_ESCAPES),\n+    LintId::of(operators::FLOAT_EQUALITY_WITHOUT_ABS),\n+    LintId::of(operators::MISREFACTORED_ASSIGN_OP),\n     LintId::of(rc_clone_in_vec_init::RC_CLONE_IN_VEC_INIT),\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),"}, {"sha": "172fdf8c85269c4944122c81f9e55ad7fcf905b1", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 49, "deletions": 46, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -7,6 +7,7 @@\n #![feature(let_chains)]\n #![feature(let_else)]\n #![feature(lint_reasons)]\n+#![feature(never_type)]\n #![feature(once_cell)]\n #![feature(rustc_private)]\n #![feature(stmt_expr_attributes)]\n@@ -52,6 +53,7 @@ extern crate clippy_utils;\n use clippy_utils::parse_msrv;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_lint::LintId;\n+use rustc_semver::RustcVersion;\n use rustc_session::Session;\n \n /// Macro used to declare a Clippy lint.\n@@ -159,25 +161,22 @@ macro_rules! declare_clippy_lint {\n }\n \n #[cfg(feature = \"internal\")]\n-mod deprecated_lints;\n+pub mod deprecated_lints;\n #[cfg_attr(feature = \"internal\", allow(clippy::missing_clippy_version_attribute))]\n mod utils;\n \n mod renamed_lints;\n \n // begin lints modules, do not remove this comment, it\u2019s used in `update_lints`\n-mod absurd_extreme_comparisons;\n mod almost_complete_letter_range;\n mod approx_const;\n mod as_conversions;\n mod as_underscore;\n mod asm_syntax;\n mod assertions_on_constants;\n-mod assign_ops;\n mod async_yields_async;\n mod attrs;\n mod await_holding_invalid;\n-mod bit_mask;\n mod blacklisted_name;\n mod blocks_in_if_conditions;\n mod bool_assert_comparison;\n@@ -199,6 +198,7 @@ mod crate_in_macro_def;\n mod create_dir;\n mod dbg_macro;\n mod default;\n+mod default_instead_of_iter_empty;\n mod default_numeric_fallback;\n mod default_union_representation;\n mod dereference;\n@@ -209,29 +209,24 @@ mod disallowed_script_idents;\n mod disallowed_types;\n mod doc;\n mod doc_link_with_quotes;\n-mod double_comparison;\n mod double_parens;\n mod drop_forget_ref;\n mod duplicate_mod;\n-mod duration_subsec;\n mod else_if_without_else;\n mod empty_drop;\n mod empty_enum;\n mod empty_structs_with_brackets;\n mod entry;\n mod enum_clike;\n mod enum_variants;\n-mod eq_op;\n mod equatable_if_let;\n-mod erasing_op;\n mod escape;\n mod eta_reduction;\n mod excessive_bools;\n mod exhaustive_items;\n mod exit;\n mod explicit_write;\n mod fallible_impl_from;\n-mod float_equality_without_abs;\n mod float_literal;\n mod floating_point_arithmetic;\n mod format;\n@@ -244,7 +239,6 @@ mod from_str_radix_10;\n mod functions;\n mod future_not_send;\n mod get_first;\n-mod identity_op;\n mod if_let_mutex;\n mod if_not_else;\n mod if_then_some_else_none;\n@@ -260,7 +254,6 @@ mod inherent_to_string;\n mod init_numbered_fields;\n mod inline_fn_without_body;\n mod int_plus_one;\n-mod integer_division;\n mod invalid_upcast_comparisons;\n mod items_after_statements;\n mod iter_not_returning_iterator;\n@@ -281,6 +274,8 @@ mod manual_async_fn;\n mod manual_bits;\n mod manual_non_exhaustive;\n mod manual_ok_or;\n+mod manual_rem_euclid;\n+mod manual_retain;\n mod manual_strip;\n mod map_clone;\n mod map_err_ignore;\n@@ -300,15 +295,13 @@ mod missing_enforced_import_rename;\n mod missing_inline;\n mod mixed_read_write_in_expression;\n mod module_style;\n-mod modulo_arithmetic;\n mod mut_key;\n mod mut_mut;\n mod mut_mutex_lock;\n mod mut_reference;\n mod mutable_debug_assertion;\n mod mutex_atomic;\n mod needless_arbitrary_self_type;\n-mod needless_bitwise_bool;\n mod needless_bool;\n mod needless_borrowed_ref;\n mod needless_continue;\n@@ -327,10 +320,10 @@ mod non_expressive_names;\n mod non_octal_unix_permissions;\n mod non_send_fields_in_send_ty;\n mod nonstandard_macro_braces;\n-mod numeric_arithmetic;\n mod octal_escapes;\n mod only_used_in_recursion;\n mod open_options;\n+mod operators;\n mod option_env_unwrap;\n mod option_if_let_else;\n mod overflow_check_conditional;\n@@ -342,7 +335,6 @@ mod path_buf_push_overwrite;\n mod pattern_type_mismatch;\n mod precedence;\n mod ptr;\n-mod ptr_eq;\n mod ptr_offset_with_cast;\n mod pub_use;\n mod question_mark;\n@@ -363,7 +355,6 @@ mod repeat_once;\n mod return_self_not_must_use;\n mod returns;\n mod same_name_method;\n-mod self_assignment;\n mod self_named_constructors;\n mod semicolon_if_nothing_returned;\n mod serde_api;\n@@ -448,6 +439,39 @@ pub fn register_pre_expansion_lints(store: &mut rustc_lint::LintStore, sess: &Se\n     store.register_pre_expansion_pass(move || Box::new(attrs::EarlyAttributes { msrv }));\n }\n \n+fn read_msrv(conf: &Conf, sess: &Session) -> Option<RustcVersion> {\n+    let cargo_msrv = std::env::var(\"CARGO_PKG_RUST_VERSION\")\n+        .ok()\n+        .and_then(|v| parse_msrv(&v, None, None));\n+    let clippy_msrv = conf.msrv.as_ref().and_then(|s| {\n+        parse_msrv(s, None, None).or_else(|| {\n+            sess.err(&format!(\n+                \"error reading Clippy's configuration file. `{}` is not a valid Rust version\",\n+                s\n+            ));\n+            None\n+        })\n+    });\n+\n+    if let Some(cargo_msrv) = cargo_msrv {\n+        if let Some(clippy_msrv) = clippy_msrv {\n+            // if both files have an msrv, let's compare them and emit a warning if they differ\n+            if clippy_msrv != cargo_msrv {\n+                sess.warn(&format!(\n+                    \"the MSRV in `clippy.toml` and `Cargo.toml` differ; using `{}` from `clippy.toml`\",\n+                    clippy_msrv\n+                ));\n+            }\n+\n+            Some(clippy_msrv)\n+        } else {\n+            Some(cargo_msrv)\n+        }\n+    } else {\n+        clippy_msrv\n+    }\n+}\n+\n #[doc(hidden)]\n pub fn read_conf(sess: &Session) -> Conf {\n     let file_name = match utils::conf::lookup_conf_file() {\n@@ -463,12 +487,11 @@ pub fn read_conf(sess: &Session) -> Conf {\n     let TryConf { conf, errors } = utils::conf::read(&file_name);\n     // all conf errors are non-fatal, we just use the default conf in case of error\n     for error in errors {\n-        sess.struct_err(&format!(\n+        sess.err(&format!(\n             \"error reading Clippy's configuration file `{}`: {}\",\n             file_name.display(),\n             format_error(error)\n-        ))\n-        .emit();\n+        ));\n     }\n \n     conf\n@@ -543,21 +566,14 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         ))\n     });\n     store.register_late_pass(|| Box::new(booleans::NonminimalBool));\n-    store.register_late_pass(|| Box::new(needless_bitwise_bool::NeedlessBitwiseBool));\n-    store.register_late_pass(|| Box::new(eq_op::EqOp));\n     store.register_late_pass(|| Box::new(enum_clike::UnportableVariant));\n     store.register_late_pass(|| Box::new(float_literal::FloatLiteral));\n-    let verbose_bit_mask_threshold = conf.verbose_bit_mask_threshold;\n-    store.register_late_pass(move || Box::new(bit_mask::BitMask::new(verbose_bit_mask_threshold)));\n     store.register_late_pass(|| Box::new(ptr::Ptr));\n-    store.register_late_pass(|| Box::new(ptr_eq::PtrEq));\n     store.register_late_pass(|| Box::new(needless_bool::NeedlessBool));\n     store.register_late_pass(|| Box::new(needless_bool::BoolComparison));\n     store.register_late_pass(|| Box::new(needless_for_each::NeedlessForEach));\n     store.register_late_pass(|| Box::new(misc::MiscLints));\n     store.register_late_pass(|| Box::new(eta_reduction::EtaReduction));\n-    store.register_late_pass(|| Box::new(identity_op::IdentityOp));\n-    store.register_late_pass(|| Box::new(erasing_op::ErasingOp));\n     store.register_late_pass(|| Box::new(mut_mut::MutMut));\n     store.register_late_pass(|| Box::new(mut_reference::UnnecessaryMutPassed));\n     store.register_late_pass(|| Box::new(len_zero::LenZero));\n@@ -575,16 +591,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(non_octal_unix_permissions::NonOctalUnixPermissions));\n     store.register_early_pass(|| Box::new(unnecessary_self_imports::UnnecessarySelfImports));\n \n-    let msrv = conf.msrv.as_ref().and_then(|s| {\n-        parse_msrv(s, None, None).or_else(|| {\n-            sess.err(&format!(\n-                \"error reading Clippy's configuration file. `{}` is not a valid Rust version\",\n-                s\n-            ));\n-            None\n-        })\n-    });\n-\n+    let msrv = read_msrv(conf, sess);\n     let avoid_breaking_exported_api = conf.avoid_breaking_exported_api;\n     let allow_expect_in_tests = conf.allow_expect_in_tests;\n     let allow_unwrap_in_tests = conf.allow_unwrap_in_tests;\n@@ -639,7 +646,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(borrow_deref_ref::BorrowDerefRef));\n     store.register_late_pass(|| Box::new(no_effect::NoEffect));\n     store.register_late_pass(|| Box::new(temporary_assignment::TemporaryAssignment));\n-    store.register_late_pass(|| Box::new(transmute::Transmute));\n+    store.register_late_pass(move || Box::new(transmute::Transmute::new(msrv)));\n     let cognitive_complexity_threshold = conf.cognitive_complexity_threshold;\n     store.register_late_pass(move || {\n         Box::new(cognitive_complexity::CognitiveComplexity::new(\n@@ -655,7 +662,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(derivable_impls::DerivableImpls));\n     store.register_late_pass(|| Box::new(drop_forget_ref::DropForgetRef));\n     store.register_late_pass(|| Box::new(empty_enum::EmptyEnum));\n-    store.register_late_pass(|| Box::new(absurd_extreme_comparisons::AbsurdExtremeComparisons));\n     store.register_late_pass(|| Box::new(invalid_upcast_comparisons::InvalidUpcastComparisons));\n     store.register_late_pass(|| Box::new(regex::Regex));\n     store.register_late_pass(|| Box::new(copies::CopyAndPaste));\n@@ -678,8 +684,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(doc::DocMarkdown::new(doc_valid_idents.clone())));\n     store.register_late_pass(|| Box::new(neg_multiply::NegMultiply));\n     store.register_late_pass(|| Box::new(mem_forget::MemForget));\n-    store.register_late_pass(|| Box::new(numeric_arithmetic::NumericArithmetic::default()));\n-    store.register_late_pass(|| Box::new(assign_ops::AssignOps));\n     store.register_late_pass(|| Box::new(let_if_seq::LetIfSeq));\n     store.register_late_pass(|| Box::new(mixed_read_write_in_expression::EvalOrderDependence));\n     store.register_late_pass(|| Box::new(missing_doc::MissingDoc::new()));\n@@ -706,15 +710,13 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(useless_conversion::UselessConversion::default()));\n     store.register_late_pass(|| Box::new(implicit_hasher::ImplicitHasher));\n     store.register_late_pass(|| Box::new(fallible_impl_from::FallibleImplFrom));\n-    store.register_late_pass(|| Box::new(double_comparison::DoubleComparisons));\n     store.register_late_pass(|| Box::new(question_mark::QuestionMark));\n     store.register_early_pass(|| Box::new(suspicious_operation_groupings::SuspiciousOperationGroupings));\n     store.register_late_pass(|| Box::new(suspicious_trait_impl::SuspiciousImpl));\n     store.register_late_pass(|| Box::new(map_unit_fn::MapUnit));\n     store.register_late_pass(|| Box::new(inherent_impl::MultipleInherentImpl));\n     store.register_late_pass(|| Box::new(neg_cmp_op_on_partial_ord::NoNegCompOpForPartialOrd));\n     store.register_late_pass(|| Box::new(unwrap::Unwrap));\n-    store.register_late_pass(|| Box::new(duration_subsec::DurationSubsec));\n     store.register_late_pass(|| Box::new(indexing_slicing::IndexingSlicing));\n     store.register_late_pass(|| Box::new(non_copy_const::NonCopyConst));\n     store.register_late_pass(|| Box::new(ptr_offset_with_cast::PtrOffsetWithCast));\n@@ -725,13 +727,11 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(assertions_on_constants::AssertionsOnConstants));\n     store.register_late_pass(|| Box::new(transmuting_null::TransmutingNull));\n     store.register_late_pass(|| Box::new(path_buf_push_overwrite::PathBufPushOverwrite));\n-    store.register_late_pass(|| Box::new(integer_division::IntegerDivision));\n     store.register_late_pass(|| Box::new(inherent_to_string::InherentToString));\n     let max_trait_bounds = conf.max_trait_bounds;\n     store.register_late_pass(move || Box::new(trait_bounds::TraitBounds::new(max_trait_bounds)));\n     store.register_late_pass(|| Box::new(comparison_chain::ComparisonChain));\n     store.register_late_pass(|| Box::new(mut_key::MutableKeyType));\n-    store.register_late_pass(|| Box::new(modulo_arithmetic::ModuloArithmetic));\n     store.register_early_pass(|| Box::new(reference::DerefAddrOf));\n     store.register_early_pass(|| Box::new(double_parens::DoubleParens));\n     store.register_late_pass(|| Box::new(format_impl::FormatImpl::new()));\n@@ -828,9 +828,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(stable_sort_primitive::StableSortPrimitive));\n     store.register_late_pass(|| Box::new(repeat_once::RepeatOnce));\n     store.register_late_pass(|| Box::new(unwrap_in_result::UnwrapInResult));\n-    store.register_late_pass(|| Box::new(self_assignment::SelfAssignment));\n     store.register_late_pass(|| Box::new(manual_ok_or::ManualOkOr));\n-    store.register_late_pass(|| Box::new(float_equality_without_abs::FloatEqualityWithoutAbs));\n     store.register_late_pass(|| Box::new(semicolon_if_nothing_returned::SemicolonIfNothingReturned));\n     store.register_late_pass(|| Box::new(async_yields_async::AsyncYieldsAsync));\n     let disallowed_methods = conf.disallowed_methods.clone();\n@@ -910,6 +908,11 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(mismatching_type_param_order::TypeParamMismatch));\n     store.register_late_pass(|| Box::new(as_underscore::AsUnderscore));\n     store.register_late_pass(|| Box::new(read_zero_byte_vec::ReadZeroByteVec));\n+    store.register_late_pass(|| Box::new(default_instead_of_iter_empty::DefaultIterEmpty));\n+    store.register_late_pass(move || Box::new(manual_rem_euclid::ManualRemEuclid::new(msrv)));\n+    store.register_late_pass(move || Box::new(manual_retain::ManualRetain::new(msrv)));\n+    let verbose_bit_mask_threshold = conf.verbose_bit_mask_threshold;\n+    store.register_late_pass(move || Box::new(operators::Operators::new(verbose_bit_mask_threshold)));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n "}, {"sha": "5c0bd57ac5097bc3137d154d38cb8c539b2738e0", "filename": "src/tools/clippy/clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -92,7 +92,9 @@ impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n         if let ItemKind::Fn(ref sig, generics, id) = item.kind {\n             check_fn_inner(cx, sig.decl, Some(id), None, generics, item.span, true);\n         } else if let ItemKind::Impl(impl_) = item.kind {\n-            report_extra_impl_lifetimes(cx, impl_);\n+            if !item.span.from_expansion() {\n+                report_extra_impl_lifetimes(cx, impl_);\n+            }\n         }\n     }\n "}, {"sha": "33736d6d4e650691e6f9a394b2d2f7b8def212e0", "filename": "src/tools/clippy/clippy_lints/src/loops/manual_find.rs", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_find.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_find.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_find.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,158 @@\n+use super::utils::make_iterator_snippet;\n+use super::MANUAL_FIND;\n+use clippy_utils::{\n+    diagnostics::span_lint_and_then, higher, is_lang_ctor, path_res, peel_blocks_with_stmt,\n+    source::snippet_with_applicability, ty::implements_trait,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{\n+    def::Res, lang_items::LangItem, BindingAnnotation, Block, Expr, ExprKind, HirId, Node, Pat, PatKind, Stmt, StmtKind,\n+};\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::Span;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    span: Span,\n+    expr: &'tcx Expr<'_>,\n+) {\n+    let inner_expr = peel_blocks_with_stmt(body);\n+    // Check for the specific case that the result is returned and optimize suggestion for that (more\n+    // cases can be added later)\n+    if_chain! {\n+        if let Some(higher::If { cond, then, r#else: None, }) = higher::If::hir(inner_expr);\n+        if let Some(binding_id) = get_binding(pat);\n+        if let ExprKind::Block(block, _) = then.kind;\n+        if let [stmt] = block.stmts;\n+        if let StmtKind::Semi(semi) = stmt.kind;\n+        if let ExprKind::Ret(Some(ret_value)) = semi.kind;\n+        if let ExprKind::Call(Expr { kind: ExprKind::Path(ctor), .. }, [inner_ret]) = ret_value.kind;\n+        if is_lang_ctor(cx, ctor, LangItem::OptionSome);\n+        if path_res(cx, inner_ret) == Res::Local(binding_id);\n+        if let Some((last_stmt, last_ret)) = last_stmt_and_ret(cx, expr);\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+            let mut snippet = make_iterator_snippet(cx, arg, &mut applicability);\n+            // Checks if `pat` is a single reference to a binding (`&x`)\n+            let is_ref_to_binding =\n+                matches!(pat.kind, PatKind::Ref(inner, _) if matches!(inner.kind, PatKind::Binding(..)));\n+            // If `pat` is not a binding or a reference to a binding (`x` or `&x`)\n+            // we need to map it to the binding returned by the function (i.e. `.map(|(x, _)| x)`)\n+            if !(matches!(pat.kind, PatKind::Binding(..)) || is_ref_to_binding) {\n+                snippet.push_str(\n+                    &format!(\n+                        \".map(|{}| {})\",\n+                        snippet_with_applicability(cx, pat.span, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, inner_ret.span, \"..\", &mut applicability),\n+                    )[..],\n+                );\n+            }\n+            let ty = cx.typeck_results().expr_ty(inner_ret);\n+            if cx.tcx.lang_items().copy_trait().map_or(false, |id| implements_trait(cx, ty, id, &[])) {\n+                snippet.push_str(\n+                    &format!(\n+                        \".find(|{}{}| {})\",\n+                        \"&\".repeat(1 + usize::from(is_ref_to_binding)),\n+                        snippet_with_applicability(cx, inner_ret.span, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, cond.span, \"..\", &mut applicability),\n+                    )[..],\n+                );\n+                if is_ref_to_binding {\n+                    snippet.push_str(\".copied()\");\n+                }\n+            } else {\n+                applicability = Applicability::MaybeIncorrect;\n+                snippet.push_str(\n+                    &format!(\n+                        \".find(|{}| {})\",\n+                        snippet_with_applicability(cx, inner_ret.span, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, cond.span, \"..\", &mut applicability),\n+                    )[..],\n+                );\n+            }\n+            // Extends to `last_stmt` to include semicolon in case of `return None;`\n+            let lint_span = span.to(last_stmt.span).to(last_ret.span);\n+            span_lint_and_then(\n+                cx,\n+                MANUAL_FIND,\n+                lint_span,\n+                \"manual implementation of `Iterator::find`\",\n+                |diag| {\n+                    if applicability == Applicability::MaybeIncorrect {\n+                        diag.note(\"you may need to dereference some variables\");\n+                    }\n+                    diag.span_suggestion(\n+                        lint_span,\n+                        \"replace with an iterator\",\n+                        snippet,\n+                        applicability,\n+                    );\n+                },\n+            );\n+        }\n+    }\n+}\n+\n+fn get_binding(pat: &Pat<'_>) -> Option<HirId> {\n+    let mut hir_id = None;\n+    let mut count = 0;\n+    pat.each_binding(|annotation, id, _, _| {\n+        count += 1;\n+        if count > 1 {\n+            hir_id = None;\n+            return;\n+        }\n+        if let BindingAnnotation::Unannotated = annotation {\n+            hir_id = Some(id);\n+        }\n+    });\n+    hir_id\n+}\n+\n+// Returns the last statement and last return if function fits format for lint\n+fn last_stmt_and_ret<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+) -> Option<(&'tcx Stmt<'tcx>, &'tcx Expr<'tcx>)> {\n+    // Returns last non-return statement and the last return\n+    fn extract<'tcx>(block: &Block<'tcx>) -> Option<(&'tcx Stmt<'tcx>, &'tcx Expr<'tcx>)> {\n+        if let [.., last_stmt] = block.stmts {\n+            if let Some(ret) = block.expr {\n+                return Some((last_stmt, ret));\n+            }\n+            if_chain! {\n+                if let [.., snd_last, _] = block.stmts;\n+                if let StmtKind::Semi(last_expr) = last_stmt.kind;\n+                if let ExprKind::Ret(Some(ret)) = last_expr.kind;\n+                then {\n+                    return Some((snd_last, ret));\n+                }\n+            }\n+        }\n+        None\n+    }\n+    let mut parent_iter = cx.tcx.hir().parent_iter(expr.hir_id);\n+    if_chain! {\n+        // This should be the loop\n+        if let Some((node_hir, Node::Stmt(..))) = parent_iter.next();\n+        // This should be the funciton body\n+        if let Some((_, Node::Block(block))) = parent_iter.next();\n+        if let Some((last_stmt, last_ret)) = extract(block);\n+        if last_stmt.hir_id == node_hir;\n+        if let ExprKind::Path(path) = &last_ret.kind;\n+        if is_lang_ctor(cx, path, LangItem::OptionNone);\n+        if let Some((_, Node::Expr(_block))) = parent_iter.next();\n+        // This includes the function header\n+        if let Some((_, func)) = parent_iter.next();\n+        if func.fn_kind().is_some();\n+        then {\n+            Some((block.stmts.last().unwrap(), last_ret))\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "ed270bd490d781803f4fffdae7f32331b4a044e4", "filename": "src/tools/clippy/clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -5,6 +5,7 @@ mod explicit_iter_loop;\n mod for_kv_map;\n mod for_loops_over_fallibles;\n mod iter_next_loop;\n+mod manual_find;\n mod manual_flatten;\n mod manual_memcpy;\n mod missing_spin_loop;\n@@ -346,7 +347,14 @@ declare_clippy_lint! {\n     ///\n     /// ### Example\n     /// ```ignore\n-    /// while let Some(val) = iter() {\n+    /// while let Some(val) = iter.next() {\n+    ///     ..\n+    /// }\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```ignore\n+    /// for val in &mut iter {\n     ///     ..\n     /// }\n     /// ```\n@@ -602,6 +610,37 @@ declare_clippy_lint! {\n     \"An empty busy waiting loop\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Check for manual implementations of Iterator::find\n+    ///\n+    /// ### Why is this bad?\n+    /// It doesn't affect performance, but using `find` is shorter and easier to read.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// fn example(arr: Vec<i32>) -> Option<i32> {\n+    ///     for el in arr {\n+    ///         if el == 1 {\n+    ///             return Some(el);\n+    ///         }\n+    ///     }\n+    ///     None\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn example(arr: Vec<i32>) -> Option<i32> {\n+    ///     arr.into_iter().find(|&el| el == 1)\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub MANUAL_FIND,\n+    complexity,\n+    \"manual implementation of `Iterator::find`\"\n+}\n+\n declare_lint_pass!(Loops => [\n     MANUAL_MEMCPY,\n     MANUAL_FLATTEN,\n@@ -622,6 +661,7 @@ declare_lint_pass!(Loops => [\n     SAME_ITEM_PUSH,\n     SINGLE_ELEMENT_LOOP,\n     MISSING_SPIN_LOOP,\n+    MANUAL_FIND,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Loops {\n@@ -696,6 +736,7 @@ fn check_for_loop<'tcx>(\n     single_element_loop::check(cx, pat, arg, body, expr);\n     same_item_push::check(cx, pat, arg, body, expr);\n     manual_flatten::check(cx, pat, arg, body, span);\n+    manual_find::check(cx, pat, arg, body, span, expr);\n }\n \n fn check_for_loop_arg(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>) {"}, {"sha": "45af6be2653f3d4478fb026d65392fc191cccf1a", "filename": "src/tools/clippy/clippy_lints/src/loops/while_let_loop.rs", "status": "modified", "additions": 50, "deletions": 56, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -2,71 +2,60 @@ use super::WHILE_LET_LOOP;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::higher;\n use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::needs_ordered_drop;\n+use clippy_utils::visitors::any_temporaries_need_ordered_drop;\n use rustc_errors::Applicability;\n-use rustc_hir::{Block, Expr, ExprKind, MatchSource, Pat, StmtKind};\n-use rustc_lint::{LateContext, LintContext};\n-use rustc_middle::lint::in_external_macro;\n+use rustc_hir::{Block, Expr, ExprKind, Local, MatchSource, Pat, StmtKind};\n+use rustc_lint::LateContext;\n \n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, loop_block: &'tcx Block<'_>) {\n-    // extract the expression from the first statement (if any) in a block\n-    let inner_stmt_expr = extract_expr_from_first_stmt(loop_block);\n-    // or extract the first expression (if any) from the block\n-    if let Some(inner) = inner_stmt_expr.or_else(|| extract_first_expr(loop_block)) {\n-        if let Some(higher::IfLet {\n-            let_pat,\n-            let_expr,\n-            if_else: Some(if_else),\n-            ..\n-        }) = higher::IfLet::hir(cx, inner)\n-        {\n-            if is_simple_break_expr(if_else) {\n-                could_be_while_let(cx, expr, let_pat, let_expr);\n+    let (init, has_trailing_exprs) = match (loop_block.stmts, loop_block.expr) {\n+        ([stmt, stmts @ ..], expr) => {\n+            if let StmtKind::Local(&Local { init: Some(e), .. }) | StmtKind::Semi(e) | StmtKind::Expr(e) = stmt.kind {\n+                (e, !stmts.is_empty() || expr.is_some())\n+            } else {\n+                return;\n             }\n-        }\n-\n-        if let ExprKind::Match(matchexpr, arms, MatchSource::Normal) = inner.kind {\n-            if arms.len() == 2\n-                && arms[0].guard.is_none()\n-                && arms[1].guard.is_none()\n-                && is_simple_break_expr(arms[1].body)\n-            {\n-                could_be_while_let(cx, expr, arms[0].pat, matchexpr);\n-            }\n-        }\n-    }\n-}\n+        },\n+        ([], Some(e)) => (e, false),\n+        _ => return,\n+    };\n \n-/// If a block begins with a statement (possibly a `let` binding) and has an\n-/// expression, return it.\n-fn extract_expr_from_first_stmt<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n-    if let Some(first_stmt) = block.stmts.get(0) {\n-        if let StmtKind::Local(local) = first_stmt.kind {\n-            return local.init;\n-        }\n+    if let Some(if_let) = higher::IfLet::hir(cx, init)\n+        && let Some(else_expr) = if_let.if_else\n+        && is_simple_break_expr(else_expr)\n+    {\n+        could_be_while_let(cx, expr, if_let.let_pat, if_let.let_expr, has_trailing_exprs);\n+    } else if let ExprKind::Match(scrutinee, [arm1, arm2], MatchSource::Normal) = init.kind\n+        && arm1.guard.is_none()\n+        && arm2.guard.is_none()\n+        && is_simple_break_expr(arm2.body)\n+    {\n+        could_be_while_let(cx, expr, arm1.pat, scrutinee, has_trailing_exprs);\n     }\n-    None\n }\n \n-/// If a block begins with an expression (with or without semicolon), return it.\n-fn extract_first_expr<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n-    match block.expr {\n-        Some(expr) if block.stmts.is_empty() => Some(expr),\n-        None if !block.stmts.is_empty() => match block.stmts[0].kind {\n-            StmtKind::Expr(expr) | StmtKind::Semi(expr) => Some(expr),\n-            StmtKind::Local(..) | StmtKind::Item(..) => None,\n-        },\n-        _ => None,\n-    }\n+/// Returns `true` if expr contains a single break expression without a label or eub-expression.\n+fn is_simple_break_expr(e: &Expr<'_>) -> bool {\n+    matches!(peel_blocks(e).kind, ExprKind::Break(dest, None) if dest.label.is_none())\n }\n \n-/// Returns `true` if expr contains a single break expr without destination label\n-/// and\n-/// passed expression. The expression may be within a block.\n-fn is_simple_break_expr(expr: &Expr<'_>) -> bool {\n-    match expr.kind {\n-        ExprKind::Break(dest, ref passed_expr) if dest.label.is_none() && passed_expr.is_none() => true,\n-        ExprKind::Block(b, _) => extract_first_expr(b).map_or(false, is_simple_break_expr),\n-        _ => false,\n+/// Removes any blocks containing only a single expression.\n+fn peel_blocks<'tcx>(e: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n+    if let ExprKind::Block(b, _) = e.kind {\n+        match (b.stmts, b.expr) {\n+            ([s], None) => {\n+                if let StmtKind::Expr(e) | StmtKind::Semi(e) = s.kind {\n+                    peel_blocks(e)\n+                } else {\n+                    e\n+                }\n+            },\n+            ([], Some(e)) => peel_blocks(e),\n+            _ => e,\n+        }\n+    } else {\n+        e\n     }\n }\n \n@@ -75,8 +64,13 @@ fn could_be_while_let<'tcx>(\n     expr: &'tcx Expr<'_>,\n     let_pat: &'tcx Pat<'_>,\n     let_expr: &'tcx Expr<'_>,\n+    has_trailing_exprs: bool,\n ) {\n-    if in_external_macro(cx.sess(), expr.span) {\n+    if has_trailing_exprs\n+        && (needs_ordered_drop(cx, cx.typeck_results().expr_ty(let_expr))\n+            || any_temporaries_need_ordered_drop(cx, let_expr))\n+    {\n+        // Switching to a `while let` loop will extend the lifetime of some values.\n         return;\n     }\n "}, {"sha": "d573a1b4fbb5d846afd49cdf6fe735eeb0fb2585", "filename": "src/tools/clippy/clippy_lints/src/macro_use.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmacro_use.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::diagnostics::span_lint_hir_and_then;\n use clippy_utils::source::snippet;\n use hir::def::{DefKind, Res};\n use if_chain::if_chain;\n@@ -50,8 +50,9 @@ impl MacroRefData {\n #[derive(Default)]\n #[expect(clippy::module_name_repetitions)]\n pub struct MacroUseImports {\n-    /// the actual import path used and the span of the attribute above it.\n-    imports: Vec<(String, Span)>,\n+    /// the actual import path used and the span of the attribute above it. The value is\n+    /// the location, where the lint should be emitted.\n+    imports: Vec<(String, Span, hir::HirId)>,\n     /// the span of the macro reference, kept to ensure only one reference is used per macro call.\n     collected: FxHashSet<Span>,\n     mac_refs: Vec<MacroRefData>,\n@@ -90,7 +91,8 @@ impl<'tcx> LateLintPass<'tcx> for MacroUseImports {\n         if_chain! {\n             if cx.sess().opts.edition >= Edition::Edition2018;\n             if let hir::ItemKind::Use(path, _kind) = &item.kind;\n-            let attrs = cx.tcx.hir().attrs(item.hir_id());\n+            let hir_id = item.hir_id();\n+            let attrs = cx.tcx.hir().attrs(hir_id);\n             if let Some(mac_attr) = attrs.iter().find(|attr| attr.has_name(sym::macro_use));\n             if let Res::Def(DefKind::Mod, id) = path.res;\n             if !id.is_local();\n@@ -99,7 +101,7 @@ impl<'tcx> LateLintPass<'tcx> for MacroUseImports {\n                     if let Res::Def(DefKind::Macro(_mac_type), mac_id) = kid.res {\n                         let span = mac_attr.span;\n                         let def_path = cx.tcx.def_path_str(mac_id);\n-                        self.imports.push((def_path, span));\n+                        self.imports.push((def_path, span, hir_id));\n                     }\n                 }\n             } else {\n@@ -137,7 +139,7 @@ impl<'tcx> LateLintPass<'tcx> for MacroUseImports {\n     fn check_crate_post(&mut self, cx: &LateContext<'_>) {\n         let mut used = FxHashMap::default();\n         let mut check_dup = vec![];\n-        for (import, span) in &self.imports {\n+        for (import, span, hir_id) in &self.imports {\n             let found_idx = self.mac_refs.iter().position(|mac| import.ends_with(&mac.name));\n \n             if let Some(idx) = found_idx {\n@@ -150,7 +152,7 @@ impl<'tcx> LateLintPass<'tcx> for MacroUseImports {\n                     [] | [_] => return,\n                     [root, item] => {\n                         if !check_dup.contains(&(*item).to_string()) {\n-                            used.entry(((*root).to_string(), span))\n+                            used.entry(((*root).to_string(), span, hir_id))\n                                 .or_insert_with(Vec::new)\n                                 .push((*item).to_string());\n                             check_dup.push((*item).to_string());\n@@ -168,13 +170,13 @@ impl<'tcx> LateLintPass<'tcx> for MacroUseImports {\n                                     }\n                                 })\n                                 .collect::<Vec<_>>();\n-                            used.entry(((*root).to_string(), span))\n+                            used.entry(((*root).to_string(), span, hir_id))\n                                 .or_insert_with(Vec::new)\n                                 .push(filtered.join(\"::\"));\n                             check_dup.extend(filtered);\n                         } else {\n                             let rest = rest.to_vec();\n-                            used.entry(((*root).to_string(), span))\n+                            used.entry(((*root).to_string(), span, hir_id))\n                                 .or_insert_with(Vec::new)\n                                 .push(rest.join(\"::\"));\n                             check_dup.extend(rest.iter().map(ToString::to_string));\n@@ -185,27 +187,33 @@ impl<'tcx> LateLintPass<'tcx> for MacroUseImports {\n         }\n \n         let mut suggestions = vec![];\n-        for ((root, span), path) in used {\n+        for ((root, span, hir_id), path) in used {\n             if path.len() == 1 {\n-                suggestions.push((span, format!(\"{}::{}\", root, path[0])));\n+                suggestions.push((span, format!(\"{}::{}\", root, path[0]), hir_id));\n             } else {\n-                suggestions.push((span, format!(\"{}::{{{}}}\", root, path.join(\", \"))));\n+                suggestions.push((span, format!(\"{}::{{{}}}\", root, path.join(\", \")), hir_id));\n             }\n         }\n \n         // If mac_refs is not empty we have encountered an import we could not handle\n         // such as `std::prelude::v1::foo` or some other macro that expands to an import.\n         if self.mac_refs.is_empty() {\n-            for (span, import) in suggestions {\n+            for (span, import, hir_id) in suggestions {\n                 let help = format!(\"use {};\", import);\n-                span_lint_and_sugg(\n+                span_lint_hir_and_then(\n                     cx,\n                     MACRO_USE_IMPORTS,\n+                    *hir_id,\n                     *span,\n                     \"`macro_use` attributes are no longer needed in the Rust 2018 edition\",\n-                    \"remove the attribute and import the macro directly, try\",\n-                    help,\n-                    Applicability::MaybeIncorrect,\n+                    |diag| {\n+                        diag.span_suggestion(\n+                            *span,\n+                            \"remove the attribute and import the macro directly, try\",\n+                            help,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    },\n                 );\n             }\n         }"}, {"sha": "4278e98dc91facd694f9ad7d64d01d12a639ad4a", "filename": "src/tools/clippy/clippy_lints/src/manual_non_exhaustive.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,6 +1,6 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::diagnostics::{span_lint_and_then, span_lint_hir_and_then};\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::{is_doc_hidden, is_lint_allowed, meets_msrv, msrvs};\n+use clippy_utils::{is_doc_hidden, meets_msrv, msrvs};\n use rustc_ast::ast::{self, VisibilityKind};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n@@ -190,12 +190,13 @@ impl<'tcx> LateLintPass<'tcx> for ManualNonExhaustiveEnum {\n                 !self\n                     .constructed_enum_variants\n                     .contains(&(enum_id.to_def_id(), variant_id.to_def_id()))\n-                    && !is_lint_allowed(cx, MANUAL_NON_EXHAUSTIVE, cx.tcx.hir().local_def_id_to_hir_id(enum_id))\n             })\n         {\n-            span_lint_and_then(\n+            let hir_id = cx.tcx.hir().local_def_id_to_hir_id(enum_id);\n+            span_lint_hir_and_then(\n                 cx,\n                 MANUAL_NON_EXHAUSTIVE,\n+                hir_id,\n                 enum_span,\n                 \"this seems like a manual implementation of the non-exhaustive pattern\",\n                 |diag| {"}, {"sha": "b5698965fc3ddf455bea45add3b5759877f9cff3", "filename": "src/tools/clippy/clippy_lints/src/manual_rem_euclid.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_rem_euclid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_rem_euclid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_rem_euclid.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,123 @@\n+use clippy_utils::consts::{constant_full_int, FullInt};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{in_constant, meets_msrv, msrvs, path_to_local};\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind, Node, TyKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for an expression like `((x % 4) + 4) % 4` which is a common manual reimplementation\n+    /// of `x.rem_euclid(4)`.\n+    ///\n+    /// ### Why is this bad?\n+    /// It's simpler and more readable.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x: i32 = 24;\n+    /// let rem = ((x % 4) + 4) % 4;\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let x: i32 = 24;\n+    /// let rem = x.rem_euclid(4);\n+    /// ```\n+    #[clippy::version = \"1.63.0\"]\n+    pub MANUAL_REM_EUCLID,\n+    complexity,\n+    \"manually reimplementing `rem_euclid`\"\n+}\n+\n+pub struct ManualRemEuclid {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl ManualRemEuclid {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n+impl_lint_pass!(ManualRemEuclid => [MANUAL_REM_EUCLID]);\n+\n+impl<'tcx> LateLintPass<'tcx> for ManualRemEuclid {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if !meets_msrv(self.msrv, msrvs::REM_EUCLID) {\n+            return;\n+        }\n+\n+        if in_constant(cx, expr.hir_id) && !meets_msrv(self.msrv, msrvs::REM_EUCLID_CONST) {\n+            return;\n+        }\n+\n+        if in_external_macro(cx.sess(), expr.span) {\n+            return;\n+        }\n+\n+        if let ExprKind::Binary(op1, expr1, right) = expr.kind\n+            && op1.node == BinOpKind::Rem\n+            && let Some(const1) = check_for_unsigned_int_constant(cx, right)\n+            && let ExprKind::Binary(op2, left, right) = expr1.kind\n+            && op2.node == BinOpKind::Add\n+            && let Some((const2, expr2)) = check_for_either_unsigned_int_constant(cx, left, right)\n+            && let ExprKind::Binary(op3, expr3, right) = expr2.kind\n+            && op3.node == BinOpKind::Rem\n+            && let Some(const3) = check_for_unsigned_int_constant(cx, right)\n+            // Also ensures the const is nonzero since zero can't be a divisor\n+            && const1 == const2 && const2 == const3\n+            && let Some(hir_id) = path_to_local(expr3)\n+            && let Some(Node::Binding(_)) = cx.tcx.hir().find(hir_id) {\n+                // Apply only to params or locals with annotated types\n+                match cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_id)) {\n+                    Some(Node::Param(..)) => (),\n+                    Some(Node::Local(local)) => {\n+                        let Some(ty) = local.ty else { return };\n+                        if matches!(ty.kind, TyKind::Infer) {\n+                            return;\n+                        }\n+                    }\n+                    _ => return,\n+                };\n+\n+                let mut app = Applicability::MachineApplicable;\n+                let rem_of = snippet_with_applicability(cx, expr3.span, \"_\", &mut app);\n+                span_lint_and_sugg(\n+                    cx,\n+                    MANUAL_REM_EUCLID,\n+                    expr.span,\n+                    \"manual `rem_euclid` implementation\",\n+                    \"consider using\",\n+                    format!(\"{rem_of}.rem_euclid({const1})\"),\n+                    app,\n+                );\n+        }\n+    }\n+\n+    extract_msrv_attr!(LateContext);\n+}\n+\n+// Checks if either the left or right expressions can be an unsigned int constant and returns that\n+// constant along with the other expression unchanged if so\n+fn check_for_either_unsigned_int_constant<'a>(\n+    cx: &'a LateContext<'_>,\n+    left: &'a Expr<'_>,\n+    right: &'a Expr<'_>,\n+) -> Option<(u128, &'a Expr<'a>)> {\n+    check_for_unsigned_int_constant(cx, left)\n+        .map(|int_const| (int_const, right))\n+        .or_else(|| check_for_unsigned_int_constant(cx, right).map(|int_const| (int_const, left)))\n+}\n+\n+fn check_for_unsigned_int_constant<'a>(cx: &'a LateContext<'_>, expr: &'a Expr<'_>) -> Option<u128> {\n+    let Some(int_const) = constant_full_int(cx, cx.typeck_results(), expr) else { return None };\n+    match int_const {\n+        FullInt::S(s) => s.try_into().ok(),\n+        FullInt::U(u) => Some(u),\n+    }\n+}"}, {"sha": "c35e1e021ef1ce4522248e2c79780c72691859b9", "filename": "src/tools/clippy/clippy_lints/src/manual_retain.rs", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_retain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_retain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_retain.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,228 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{get_parent_expr, match_def_path, paths, SpanlessEq};\n+use clippy_utils::{meets_msrv, msrvs};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::ExprKind::Assign;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::symbol::sym;\n+\n+const ACCEPTABLE_METHODS: [&[&str]; 4] = [\n+    &paths::HASHSET_ITER,\n+    &paths::BTREESET_ITER,\n+    &paths::SLICE_INTO,\n+    &paths::VEC_DEQUE_ITER,\n+];\n+const ACCEPTABLE_TYPES: [(rustc_span::Symbol, Option<RustcVersion>); 6] = [\n+    (sym::BTreeSet, Some(msrvs::BTREE_SET_RETAIN)),\n+    (sym::BTreeMap, Some(msrvs::BTREE_MAP_RETAIN)),\n+    (sym::HashSet, Some(msrvs::HASH_SET_RETAIN)),\n+    (sym::HashMap, Some(msrvs::HASH_MAP_RETAIN)),\n+    (sym::Vec, None),\n+    (sym::VecDeque, None),\n+];\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for code to be replaced by `.retain()`.\n+    /// ### Why is this bad?\n+    /// `.retain()` is simpler and avoids needless allocation.\n+    /// ### Example\n+    /// ```rust\n+    /// let mut vec = vec![0, 1, 2];\n+    /// vec = vec.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    /// vec = vec.into_iter().filter(|x| x % 2 == 0).collect();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let mut vec = vec![0, 1, 2];\n+    /// vec.retain(|x| x % 2 == 0);\n+    /// ```\n+    #[clippy::version = \"1.63.0\"]\n+    pub MANUAL_RETAIN,\n+    perf,\n+    \"`retain()` is simpler and the same functionalitys\"\n+}\n+\n+pub struct ManualRetain {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl ManualRetain {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n+impl_lint_pass!(ManualRetain => [MANUAL_RETAIN]);\n+\n+impl<'tcx> LateLintPass<'tcx> for ManualRetain {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if let Some(parent_expr) = get_parent_expr(cx, expr)\n+            && let Assign(left_expr, collect_expr, _) = &parent_expr.kind\n+            && let hir::ExprKind::MethodCall(seg, _, _) = &collect_expr.kind\n+            && seg.args.is_none()\n+            && let hir::ExprKind::MethodCall(_, [target_expr], _) = &collect_expr.kind\n+            && let Some(collect_def_id) = cx.typeck_results().type_dependent_def_id(collect_expr.hir_id)\n+            && match_def_path(cx, collect_def_id, &paths::CORE_ITER_COLLECT) {\n+            check_into_iter(cx, parent_expr, left_expr, target_expr, self.msrv);\n+            check_iter(cx, parent_expr, left_expr, target_expr, self.msrv);\n+            check_to_owned(cx, parent_expr, left_expr, target_expr, self.msrv);\n+        }\n+    }\n+\n+    extract_msrv_attr!(LateContext);\n+}\n+\n+fn check_into_iter(\n+    cx: &LateContext<'_>,\n+    parent_expr: &hir::Expr<'_>,\n+    left_expr: &hir::Expr<'_>,\n+    target_expr: &hir::Expr<'_>,\n+    msrv: Option<RustcVersion>,\n+) {\n+    if let hir::ExprKind::MethodCall(_, [into_iter_expr, _], _) = &target_expr.kind\n+        && let Some(filter_def_id) = cx.typeck_results().type_dependent_def_id(target_expr.hir_id)\n+        && match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER)\n+        && let hir::ExprKind::MethodCall(_, [struct_expr], _) = &into_iter_expr.kind\n+        && let Some(into_iter_def_id) = cx.typeck_results().type_dependent_def_id(into_iter_expr.hir_id)\n+        && match_def_path(cx, into_iter_def_id, &paths::CORE_ITER_INTO_ITER)\n+        && match_acceptable_type(cx, left_expr, msrv)\n+        && SpanlessEq::new(cx).eq_expr(left_expr, struct_expr) {\n+        suggest(cx, parent_expr, left_expr, target_expr);\n+    }\n+}\n+\n+fn check_iter(\n+    cx: &LateContext<'_>,\n+    parent_expr: &hir::Expr<'_>,\n+    left_expr: &hir::Expr<'_>,\n+    target_expr: &hir::Expr<'_>,\n+    msrv: Option<RustcVersion>,\n+) {\n+    if let hir::ExprKind::MethodCall(_, [filter_expr], _) = &target_expr.kind\n+        && let Some(copied_def_id) = cx.typeck_results().type_dependent_def_id(target_expr.hir_id)\n+        && (match_def_path(cx, copied_def_id, &paths::CORE_ITER_COPIED)\n+            || match_def_path(cx, copied_def_id, &paths::CORE_ITER_CLONED))\n+        && let hir::ExprKind::MethodCall(_, [iter_expr, _], _) = &filter_expr.kind\n+        && let Some(filter_def_id) = cx.typeck_results().type_dependent_def_id(filter_expr.hir_id)\n+        && match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER)\n+        && let hir::ExprKind::MethodCall(_, [struct_expr], _) = &iter_expr.kind\n+        && let Some(iter_expr_def_id) = cx.typeck_results().type_dependent_def_id(iter_expr.hir_id)\n+        && match_acceptable_def_path(cx, iter_expr_def_id)\n+        && match_acceptable_type(cx, left_expr, msrv)\n+        && SpanlessEq::new(cx).eq_expr(left_expr, struct_expr) {\n+        suggest(cx, parent_expr, left_expr, filter_expr);\n+    }\n+}\n+\n+fn check_to_owned(\n+    cx: &LateContext<'_>,\n+    parent_expr: &hir::Expr<'_>,\n+    left_expr: &hir::Expr<'_>,\n+    target_expr: &hir::Expr<'_>,\n+    msrv: Option<RustcVersion>,\n+) {\n+    if meets_msrv(msrv,  msrvs::STRING_RETAIN)\n+        && let hir::ExprKind::MethodCall(_, [filter_expr], _) = &target_expr.kind\n+        && let Some(to_owned_def_id) = cx.typeck_results().type_dependent_def_id(target_expr.hir_id)\n+        && match_def_path(cx, to_owned_def_id, &paths::TO_OWNED_METHOD)\n+        && let hir::ExprKind::MethodCall(_, [chars_expr, _], _) = &filter_expr.kind\n+        && let Some(filter_def_id) = cx.typeck_results().type_dependent_def_id(filter_expr.hir_id)\n+        && match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER)\n+        && let hir::ExprKind::MethodCall(_, [str_expr], _) = &chars_expr.kind\n+        && let Some(chars_expr_def_id) = cx.typeck_results().type_dependent_def_id(chars_expr.hir_id)\n+        && match_def_path(cx, chars_expr_def_id, &paths::STR_CHARS)\n+        && let ty = cx.typeck_results().expr_ty(str_expr).peel_refs()\n+        && is_type_diagnostic_item(cx, ty, sym::String)\n+        && SpanlessEq::new(cx).eq_expr(left_expr, str_expr) {\n+        suggest(cx, parent_expr, left_expr, filter_expr);\n+    }\n+}\n+\n+fn suggest(cx: &LateContext<'_>, parent_expr: &hir::Expr<'_>, left_expr: &hir::Expr<'_>, filter_expr: &hir::Expr<'_>) {\n+    if let hir::ExprKind::MethodCall(_, [_, closure], _) = filter_expr.kind\n+        && let hir::ExprKind::Closure{ body, ..} = closure.kind\n+        && let filter_body = cx.tcx.hir().body(body)\n+        && let [filter_params] = filter_body.params\n+        && let Some(sugg) = match filter_params.pat.kind {\n+            hir::PatKind::Binding(_, _, filter_param_ident, None) => {\n+                Some(format!(\"{}.retain(|{}| {})\", snippet(cx, left_expr.span, \"..\"), filter_param_ident, snippet(cx, filter_body.value.span, \"..\")))\n+            },\n+            hir::PatKind::Tuple([key_pat, value_pat], _) => {\n+                make_sugg(cx, key_pat, value_pat, left_expr, filter_body)\n+            },\n+            hir::PatKind::Ref(pat, _) => {\n+                match pat.kind {\n+                    hir::PatKind::Binding(_, _, filter_param_ident, None) => {\n+                        Some(format!(\"{}.retain(|{}| {})\", snippet(cx, left_expr.span, \"..\"), filter_param_ident, snippet(cx, filter_body.value.span, \"..\")))\n+                    },\n+                    _ => None\n+                }\n+            },\n+            _ => None\n+        } {\n+        span_lint_and_sugg(\n+            cx,\n+            MANUAL_RETAIN,\n+            parent_expr.span,\n+            \"this expression can be written more simply using `.retain()`\",\n+            \"consider calling `.retain()` instead\",\n+            sugg,\n+            Applicability::MachineApplicable\n+        );\n+    }\n+}\n+\n+fn make_sugg(\n+    cx: &LateContext<'_>,\n+    key_pat: &rustc_hir::Pat<'_>,\n+    value_pat: &rustc_hir::Pat<'_>,\n+    left_expr: &hir::Expr<'_>,\n+    filter_body: &hir::Body<'_>,\n+) -> Option<String> {\n+    match (&key_pat.kind, &value_pat.kind) {\n+        (hir::PatKind::Binding(_, _, key_param_ident, None), hir::PatKind::Binding(_, _, value_param_ident, None)) => {\n+            Some(format!(\n+                \"{}.retain(|{}, &mut {}| {})\",\n+                snippet(cx, left_expr.span, \"..\"),\n+                key_param_ident,\n+                value_param_ident,\n+                snippet(cx, filter_body.value.span, \"..\")\n+            ))\n+        },\n+        (hir::PatKind::Binding(_, _, key_param_ident, None), hir::PatKind::Wild) => Some(format!(\n+            \"{}.retain(|{}, _| {})\",\n+            snippet(cx, left_expr.span, \"..\"),\n+            key_param_ident,\n+            snippet(cx, filter_body.value.span, \"..\")\n+        )),\n+        (hir::PatKind::Wild, hir::PatKind::Binding(_, _, value_param_ident, None)) => Some(format!(\n+            \"{}.retain(|_, &mut {}| {})\",\n+            snippet(cx, left_expr.span, \"..\"),\n+            value_param_ident,\n+            snippet(cx, filter_body.value.span, \"..\")\n+        )),\n+        _ => None,\n+    }\n+}\n+\n+fn match_acceptable_def_path(cx: &LateContext<'_>, collect_def_id: DefId) -> bool {\n+    ACCEPTABLE_METHODS\n+        .iter()\n+        .any(|&method| match_def_path(cx, collect_def_id, method))\n+}\n+\n+fn match_acceptable_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>, msrv: Option<RustcVersion>) -> bool {\n+    let expr_ty = cx.typeck_results().expr_ty(expr).peel_refs();\n+    ACCEPTABLE_TYPES.iter().any(|(ty, acceptable_msrv)| {\n+        is_type_diagnostic_item(cx, expr_ty, *ty)\n+            && acceptable_msrv.map_or(true, |acceptable_msrv| meets_msrv(msrv, acceptable_msrv))\n+    })\n+}"}, {"sha": "15513de7d860d90dda22a8b7acaf4fcd5c8ec0be", "filename": "src/tools/clippy/clippy_lints/src/matches/match_same_arms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -285,7 +285,7 @@ impl<'a> NormalizedPat<'a> {\n                 // TODO: Handle negative integers. They're currently treated as a wild match.\n                 ExprKind::Lit(lit) => match lit.node {\n                     LitKind::Str(sym, _) => Self::LitStr(sym),\n-                    LitKind::ByteStr(ref bytes) => Self::LitBytes(&**bytes),\n+                    LitKind::ByteStr(ref bytes) => Self::LitBytes(bytes),\n                     LitKind::Byte(val) => Self::LitInt(val.into()),\n                     LitKind::Char(val) => Self::LitInt(val.into()),\n                     LitKind::Int(val, _) => Self::LitInt(val),"}, {"sha": "5ae4a65acaf33f9bb2dc94423b02579aa12ee39e", "filename": "src/tools/clippy/clippy_lints/src/matches/match_single_binding.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -55,7 +55,7 @@ pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], e\n                         cx,\n                         (ex, expr),\n                         (bind_names, matched_vars),\n-                        &*snippet_body,\n+                        &snippet_body,\n                         &mut applicability,\n                         Some(span),\n                     );\n@@ -88,7 +88,7 @@ pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], e\n                         cx,\n                         (ex, expr),\n                         (bind_names, matched_vars),\n-                        &*snippet_body,\n+                        &snippet_body,\n                         &mut applicability,\n                         None,\n                     );"}, {"sha": "fa3b8d1fceaaccb582e4c560ab4788d9828a26bc", "filename": "src/tools/clippy/clippy_lints/src/matches/match_str_case_mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_str_case_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_str_case_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_str_case_mismatch.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -118,7 +118,7 @@ fn lint(cx: &LateContext<'_>, case_method: &CaseMethod, bad_case_span: Span, bad\n         MATCH_STR_CASE_MISMATCH,\n         bad_case_span,\n         \"this `match` arm has a differing case than its expression\",\n-        &*format!(\"consider changing the case of this arm to respect `{}`\", method_str),\n+        &format!(\"consider changing the case of this arm to respect `{}`\", method_str),\n         format!(\"\\\"{}\\\"\", suggestion),\n         Applicability::MachineApplicable,\n     );"}, {"sha": "b2a873ef5823c7e20b6c9b74e5cb3a42c713480f", "filename": "src/tools/clippy/clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -791,7 +791,7 @@ declare_clippy_lint! {\n     /// the match block and thus will not unlock.\n     ///\n     /// ### Example\n-    /// ```rust.ignore\n+    /// ```rust,ignore\n     /// # use std::sync::Mutex;\n     ///\n     /// # struct State {}\n@@ -963,7 +963,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n                 return;\n             }\n             if matches!(source, MatchSource::Normal | MatchSource::ForLoopDesugar) {\n-                significant_drop_in_scrutinee::check(cx, expr, ex, source);\n+                significant_drop_in_scrutinee::check(cx, expr, ex, arms, source);\n             }\n \n             collapsible_match::check_match(cx, arms);"}, {"sha": "8499e050af2426898ede4a71210d0a4ef8451785", "filename": "src/tools/clippy/clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 6, "deletions": 82, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -3,16 +3,13 @@ use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::needs_ordered_drop;\n-use clippy_utils::{higher, match_def_path};\n-use clippy_utils::{is_lang_ctor, is_trait_method, paths};\n+use clippy_utils::visitors::any_temporaries_need_ordered_drop;\n+use clippy_utils::{higher, is_lang_ctor, is_trait_method, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, PollPending};\n-use rustc_hir::{\n-    intravisit::{walk_expr, Visitor},\n-    Arm, Block, Expr, ExprKind, Node, Pat, PatKind, QPath, UnOp,\n-};\n+use rustc_hir::{Arm, Expr, ExprKind, Node, Pat, PatKind, QPath, UnOp};\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, subst::GenericArgKind, DefIdTree, Ty};\n use rustc_span::sym;\n@@ -47,79 +44,6 @@ fn try_get_generic_ty(ty: Ty<'_>, index: usize) -> Option<Ty<'_>> {\n     }\n }\n \n-// Checks if there are any temporaries created in the given expression for which drop order\n-// matters.\n-fn temporaries_need_ordered_drop<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-    struct V<'a, 'tcx> {\n-        cx: &'a LateContext<'tcx>,\n-        res: bool,\n-    }\n-    impl<'a, 'tcx> Visitor<'tcx> for V<'a, 'tcx> {\n-        fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-            match expr.kind {\n-                // Taking the reference of a value leaves a temporary\n-                // e.g. In `&String::new()` the string is a temporary value.\n-                // Remaining fields are temporary values\n-                // e.g. In `(String::new(), 0).1` the string is a temporary value.\n-                ExprKind::AddrOf(_, _, expr) | ExprKind::Field(expr, _) => {\n-                    if !matches!(expr.kind, ExprKind::Path(_)) {\n-                        if needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(expr)) {\n-                            self.res = true;\n-                        } else {\n-                            self.visit_expr(expr);\n-                        }\n-                    }\n-                },\n-                // the base type is always taken by reference.\n-                // e.g. In `(vec![0])[0]` the vector is a temporary value.\n-                ExprKind::Index(base, index) => {\n-                    if !matches!(base.kind, ExprKind::Path(_)) {\n-                        if needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(base)) {\n-                            self.res = true;\n-                        } else {\n-                            self.visit_expr(base);\n-                        }\n-                    }\n-                    self.visit_expr(index);\n-                },\n-                // Method calls can take self by reference.\n-                // e.g. In `String::new().len()` the string is a temporary value.\n-                ExprKind::MethodCall(_, [self_arg, args @ ..], _) => {\n-                    if !matches!(self_arg.kind, ExprKind::Path(_)) {\n-                        let self_by_ref = self\n-                            .cx\n-                            .typeck_results()\n-                            .type_dependent_def_id(expr.hir_id)\n-                            .map_or(false, |id| self.cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref());\n-                        if self_by_ref && needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(self_arg)) {\n-                            self.res = true;\n-                        } else {\n-                            self.visit_expr(self_arg);\n-                        }\n-                    }\n-                    args.iter().for_each(|arg| self.visit_expr(arg));\n-                },\n-                // Either explicitly drops values, or changes control flow.\n-                ExprKind::DropTemps(_)\n-                | ExprKind::Ret(_)\n-                | ExprKind::Break(..)\n-                | ExprKind::Yield(..)\n-                | ExprKind::Block(Block { expr: None, .. }, _)\n-                | ExprKind::Loop(..) => (),\n-\n-                // Only consider the final expression.\n-                ExprKind::Block(Block { expr: Some(expr), .. }, _) => self.visit_expr(expr),\n-\n-                _ => walk_expr(self, expr),\n-            }\n-        }\n-    }\n-\n-    let mut v = V { cx, res: false };\n-    v.visit_expr(expr);\n-    v.res\n-}\n-\n fn find_sugg_for_if_let<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'_>,\n@@ -191,7 +115,7 @@ fn find_sugg_for_if_let<'tcx>(\n     // scrutinee would be, so they have to be considered as well.\n     // e.g. in `if let Some(x) = foo.lock().unwrap().baz.as_ref() { .. }` the lock will be held\n     // for the duration if body.\n-    let needs_drop = needs_ordered_drop(cx, check_ty) || temporaries_need_ordered_drop(cx, let_expr);\n+    let needs_drop = needs_ordered_drop(cx, check_ty) || any_temporaries_need_ordered_drop(cx, let_expr);\n \n     // check that `while_let_on_iterator` lint does not trigger\n     if_chain! {\n@@ -362,9 +286,9 @@ fn find_good_method_for_match<'a>(\n         .qpath_res(path_right, arms[1].pat.hir_id)\n         .opt_def_id()?;\n     let body_node_pair = if match_def_path(cx, left_id, expected_left) && match_def_path(cx, right_id, expected_right) {\n-        (&(*arms[0].body).kind, &(*arms[1].body).kind)\n+        (&arms[0].body.kind, &arms[1].body.kind)\n     } else if match_def_path(cx, right_id, expected_left) && match_def_path(cx, right_id, expected_right) {\n-        (&(*arms[1].body).kind, &(*arms[0].body).kind)\n+        (&arms[1].body.kind, &arms[0].body.kind)\n     } else {\n         return None;\n     };"}, {"sha": "0704a5af52595ce158e7760b7ec8975722de8d2c", "filename": "src/tools/clippy/clippy_lints/src/matches/significant_drop_in_scrutinee.rs", "status": "modified", "additions": 113, "deletions": 49, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsignificant_drop_in_scrutinee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsignificant_drop_in_scrutinee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsignificant_drop_in_scrutinee.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,10 +1,10 @@\n use crate::FxHashSet;\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::get_attr;\n use clippy_utils::source::{indent_of, snippet};\n+use clippy_utils::{get_attr, is_lint_allowed};\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir::intravisit::{walk_expr, Visitor};\n-use rustc_hir::{Expr, ExprKind, MatchSource};\n+use rustc_hir::{Arm, Expr, ExprKind, MatchSource};\n use rustc_lint::{LateContext, LintContext};\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{Ty, TypeAndMut};\n@@ -16,12 +16,23 @@ pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'tcx>,\n     scrutinee: &'tcx Expr<'_>,\n+    arms: &'tcx [Arm<'_>],\n     source: MatchSource,\n ) {\n+    if is_lint_allowed(cx, SIGNIFICANT_DROP_IN_SCRUTINEE, expr.hir_id) {\n+        return;\n+    }\n+\n     if let Some((suggestions, message)) = has_significant_drop_in_scrutinee(cx, scrutinee, source) {\n         for found in suggestions {\n             span_lint_and_then(cx, SIGNIFICANT_DROP_IN_SCRUTINEE, found.found_span, message, |diag| {\n                 set_diagnostic(diag, cx, expr, found);\n+                let s = Span::new(expr.span.hi(), expr.span.hi(), expr.span.ctxt(), None);\n+                diag.span_label(s, \"temporary lives until here\");\n+                for span in has_significant_drop_in_arms(cx, arms) {\n+                    diag.span_label(span, \"another value with significant `Drop` created here\");\n+                }\n+                diag.note(\"this might lead to deadlocks or other unexpected behavior\");\n             });\n         }\n     }\n@@ -80,22 +91,77 @@ fn has_significant_drop_in_scrutinee<'tcx, 'a>(\n     let mut helper = SigDropHelper::new(cx);\n     helper.find_sig_drop(scrutinee).map(|drops| {\n         let message = if source == MatchSource::Normal {\n-            \"temporary with significant drop in match scrutinee\"\n+            \"temporary with significant `Drop` in `match` scrutinee will live until the end of the `match` expression\"\n         } else {\n-            \"temporary with significant drop in for loop\"\n+            \"temporary with significant `Drop` in `for` loop condition will live until the end of the `for` expression\"\n         };\n         (drops, message)\n     })\n }\n \n+struct SigDropChecker<'a, 'tcx> {\n+    seen_types: FxHashSet<Ty<'tcx>>,\n+    cx: &'a LateContext<'tcx>,\n+}\n+\n+impl<'a, 'tcx> SigDropChecker<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'tcx>) -> SigDropChecker<'a, 'tcx> {\n+        SigDropChecker {\n+            seen_types: FxHashSet::default(),\n+            cx,\n+        }\n+    }\n+\n+    fn get_type(&self, ex: &'tcx Expr<'_>) -> Ty<'tcx> {\n+        self.cx.typeck_results().expr_ty(ex)\n+    }\n+\n+    fn has_seen_type(&mut self, ty: Ty<'tcx>) -> bool {\n+        !self.seen_types.insert(ty)\n+    }\n+\n+    fn has_sig_drop_attr(&mut self, cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+        if let Some(adt) = ty.ty_adt_def() {\n+            if get_attr(cx.sess(), cx.tcx.get_attrs_unchecked(adt.did()), \"has_significant_drop\").count() > 0 {\n+                return true;\n+            }\n+        }\n+\n+        match ty.kind() {\n+            rustc_middle::ty::Adt(a, b) => {\n+                for f in a.all_fields() {\n+                    let ty = f.ty(cx.tcx, b);\n+                    if !self.has_seen_type(ty) && self.has_sig_drop_attr(cx, ty) {\n+                        return true;\n+                    }\n+                }\n+\n+                for generic_arg in b.iter() {\n+                    if let GenericArgKind::Type(ty) = generic_arg.unpack() {\n+                        if self.has_sig_drop_attr(cx, ty) {\n+                            return true;\n+                        }\n+                    }\n+                }\n+                false\n+            },\n+            rustc_middle::ty::Array(ty, _)\n+            | rustc_middle::ty::RawPtr(TypeAndMut { ty, .. })\n+            | rustc_middle::ty::Ref(_, ty, _)\n+            | rustc_middle::ty::Slice(ty) => self.has_sig_drop_attr(cx, *ty),\n+            _ => false,\n+        }\n+    }\n+}\n+\n struct SigDropHelper<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n     is_chain_end: bool,\n-    seen_types: FxHashSet<Ty<'tcx>>,\n     has_significant_drop: bool,\n     current_sig_drop: Option<FoundSigDrop>,\n     sig_drop_spans: Option<Vec<FoundSigDrop>>,\n     special_handling_for_binary_op: bool,\n+    sig_drop_checker: SigDropChecker<'a, 'tcx>,\n }\n \n #[expect(clippy::enum_variant_names)]\n@@ -118,11 +184,11 @@ impl<'a, 'tcx> SigDropHelper<'a, 'tcx> {\n         SigDropHelper {\n             cx,\n             is_chain_end: true,\n-            seen_types: FxHashSet::default(),\n             has_significant_drop: false,\n             current_sig_drop: None,\n             sig_drop_spans: None,\n             special_handling_for_binary_op: false,\n+            sig_drop_checker: SigDropChecker::new(cx),\n         }\n     }\n \n@@ -163,7 +229,7 @@ impl<'a, 'tcx> SigDropHelper<'a, 'tcx> {\n         if self.current_sig_drop.is_some() {\n             return;\n         }\n-        let ty = self.get_type(expr);\n+        let ty = self.sig_drop_checker.get_type(expr);\n         if ty.is_ref() {\n             // We checked that the type was ref, so builtin_deref will return Some TypeAndMut,\n             // but let's avoid any chance of an ICE\n@@ -187,14 +253,6 @@ impl<'a, 'tcx> SigDropHelper<'a, 'tcx> {\n         }\n     }\n \n-    fn get_type(&self, ex: &'tcx Expr<'_>) -> Ty<'tcx> {\n-        self.cx.typeck_results().expr_ty(ex)\n-    }\n-\n-    fn has_seen_type(&mut self, ty: Ty<'tcx>) -> bool {\n-        !self.seen_types.insert(ty)\n-    }\n-\n     fn visit_exprs_for_binary_ops(\n         &mut self,\n         left: &'tcx Expr<'_>,\n@@ -214,44 +272,15 @@ impl<'a, 'tcx> SigDropHelper<'a, 'tcx> {\n \n         self.special_handling_for_binary_op = false;\n     }\n-\n-    fn has_sig_drop_attr(&mut self, cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-        if let Some(adt) = ty.ty_adt_def() {\n-            if get_attr(cx.sess(), cx.tcx.get_attrs_unchecked(adt.did()), \"has_significant_drop\").count() > 0 {\n-                return true;\n-            }\n-        }\n-\n-        match ty.kind() {\n-            rustc_middle::ty::Adt(a, b) => {\n-                for f in a.all_fields() {\n-                    let ty = f.ty(cx.tcx, b);\n-                    if !self.has_seen_type(ty) && self.has_sig_drop_attr(cx, ty) {\n-                        return true;\n-                    }\n-                }\n-\n-                for generic_arg in b.iter() {\n-                    if let GenericArgKind::Type(ty) = generic_arg.unpack() {\n-                        if self.has_sig_drop_attr(cx, ty) {\n-                            return true;\n-                        }\n-                    }\n-                }\n-                false\n-            },\n-            rustc_middle::ty::Array(ty, _)\n-            | rustc_middle::ty::RawPtr(TypeAndMut { ty, .. })\n-            | rustc_middle::ty::Ref(_, ty, _)\n-            | rustc_middle::ty::Slice(ty) => self.has_sig_drop_attr(cx, *ty),\n-            _ => false,\n-        }\n-    }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for SigDropHelper<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &'tcx Expr<'_>) {\n-        if !self.is_chain_end && self.has_sig_drop_attr(self.cx, self.get_type(ex)) {\n+        if !self.is_chain_end\n+            && self\n+                .sig_drop_checker\n+                .has_sig_drop_attr(self.cx, self.sig_drop_checker.get_type(ex))\n+        {\n             self.has_significant_drop = true;\n             return;\n         }\n@@ -330,3 +359,38 @@ impl<'a, 'tcx> Visitor<'tcx> for SigDropHelper<'a, 'tcx> {\n         }\n     }\n }\n+\n+struct ArmSigDropHelper<'a, 'tcx> {\n+    sig_drop_checker: SigDropChecker<'a, 'tcx>,\n+    found_sig_drop_spans: FxHashSet<Span>,\n+}\n+\n+impl<'a, 'tcx> ArmSigDropHelper<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'tcx>) -> ArmSigDropHelper<'a, 'tcx> {\n+        ArmSigDropHelper {\n+            sig_drop_checker: SigDropChecker::new(cx),\n+            found_sig_drop_spans: FxHashSet::<Span>::default(),\n+        }\n+    }\n+}\n+\n+fn has_significant_drop_in_arms<'tcx, 'a>(cx: &'a LateContext<'tcx>, arms: &'tcx [Arm<'_>]) -> FxHashSet<Span> {\n+    let mut helper = ArmSigDropHelper::new(cx);\n+    for arm in arms {\n+        helper.visit_expr(arm.body);\n+    }\n+    helper.found_sig_drop_spans\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for ArmSigDropHelper<'a, 'tcx> {\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n+        if self\n+            .sig_drop_checker\n+            .has_sig_drop_attr(self.sig_drop_checker.cx, self.sig_drop_checker.get_type(ex))\n+        {\n+            self.found_sig_drop_spans.insert(ex.span);\n+            return;\n+        }\n+        walk_expr(self, ex);\n+    }\n+}"}, {"sha": "92091a0c3395f7b4578bc9e26126b1c5daa72e7a", "filename": "src/tools/clippy/clippy_lints/src/matches/single_match.rs", "status": "modified", "additions": 32, "deletions": 53, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -140,70 +140,45 @@ fn check_opt_like<'a>(\n     ty: Ty<'a>,\n     els: Option<&Expr<'_>>,\n ) {\n-    // list of candidate `Enum`s we know will never get any more members\n-    let candidates = &[\n-        (&paths::COW, \"Borrowed\"),\n-        (&paths::COW, \"Cow::Borrowed\"),\n-        (&paths::COW, \"Cow::Owned\"),\n-        (&paths::COW, \"Owned\"),\n-        (&paths::OPTION, \"None\"),\n-        (&paths::RESULT, \"Err\"),\n-        (&paths::RESULT, \"Ok\"),\n-    ];\n-\n-    // We want to suggest to exclude an arm that contains only wildcards or forms the exhaustive\n-    // match with the second branch, without enum variants in matches.\n-    if !contains_only_wilds(arms[1].pat) && !form_exhaustive_matches(arms[0].pat, arms[1].pat) {\n-        return;\n+    // We don't want to lint if the second arm contains an enum which could\n+    // have more variants in the future.\n+    if form_exhaustive_matches(cx, ty, arms[0].pat, arms[1].pat) {\n+        report_single_pattern(cx, ex, arms, expr, els);\n     }\n+}\n \n+/// Returns `true` if all of the types in the pattern are enums which we know\n+/// won't be expanded in the future\n+fn pat_in_candidate_enum<'a>(cx: &LateContext<'a>, ty: Ty<'a>, pat: &Pat<'_>) -> bool {\n     let mut paths_and_types = Vec::new();\n-    if !collect_pat_paths(&mut paths_and_types, cx, arms[1].pat, ty) {\n-        return;\n-    }\n+    collect_pat_paths(&mut paths_and_types, cx, pat, ty);\n+    paths_and_types.iter().all(|ty| in_candidate_enum(cx, *ty))\n+}\n \n-    let in_candidate_enum = |path_info: &(String, Ty<'_>)| -> bool {\n-        let (path, ty) = path_info;\n-        for &(ty_path, pat_path) in candidates {\n-            if path == pat_path && match_type(cx, *ty, ty_path) {\n-                return true;\n-            }\n+/// Returns `true` if the given type is an enum we know won't be expanded in the future\n+fn in_candidate_enum<'a>(cx: &LateContext<'a>, ty: Ty<'_>) -> bool {\n+    // list of candidate `Enum`s we know will never get any more members\n+    let candidates = [&paths::COW, &paths::OPTION, &paths::RESULT];\n+\n+    for candidate_ty in candidates {\n+        if match_type(cx, ty, candidate_ty) {\n+            return true;\n         }\n-        false\n-    };\n-    if paths_and_types.iter().all(in_candidate_enum) {\n-        report_single_pattern(cx, ex, arms, expr, els);\n     }\n+    false\n }\n \n-/// Collects paths and their types from the given patterns. Returns true if the given pattern could\n-/// be simplified, false otherwise.\n-fn collect_pat_paths<'a>(acc: &mut Vec<(String, Ty<'a>)>, cx: &LateContext<'a>, pat: &Pat<'_>, ty: Ty<'a>) -> bool {\n+/// Collects types from the given pattern\n+fn collect_pat_paths<'a>(acc: &mut Vec<Ty<'a>>, cx: &LateContext<'a>, pat: &Pat<'_>, ty: Ty<'a>) {\n     match pat.kind {\n-        PatKind::Wild => true,\n-        PatKind::Tuple(inner, _) => inner.iter().all(|p| {\n+        PatKind::Tuple(inner, _) => inner.iter().for_each(|p| {\n             let p_ty = cx.typeck_results().pat_ty(p);\n-            collect_pat_paths(acc, cx, p, p_ty)\n+            collect_pat_paths(acc, cx, p, p_ty);\n         }),\n-        PatKind::TupleStruct(ref path, ..) => {\n-            let path = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n-                s.print_qpath(path, false);\n-            });\n-            acc.push((path, ty));\n-            true\n-        },\n-        PatKind::Binding(BindingAnnotation::Unannotated, .., ident, None) => {\n-            acc.push((ident.to_string(), ty));\n-            true\n+        PatKind::TupleStruct(..) | PatKind::Binding(BindingAnnotation::Unannotated, .., None) | PatKind::Path(_) => {\n+            acc.push(ty);\n         },\n-        PatKind::Path(ref path) => {\n-            let path = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n-                s.print_qpath(path, false);\n-            });\n-            acc.push((path, ty));\n-            true\n-        },\n-        _ => false,\n+        _ => {},\n     }\n }\n \n@@ -218,7 +193,7 @@ fn contains_only_wilds(pat: &Pat<'_>) -> bool {\n \n /// Returns true if the given patterns forms only exhaustive matches that don't contain enum\n /// patterns without a wildcard.\n-fn form_exhaustive_matches(left: &Pat<'_>, right: &Pat<'_>) -> bool {\n+fn form_exhaustive_matches<'a>(cx: &LateContext<'a>, ty: Ty<'a>, left: &Pat<'_>, right: &Pat<'_>) -> bool {\n     match (&left.kind, &right.kind) {\n         (PatKind::Wild, _) | (_, PatKind::Wild) => true,\n         (PatKind::Tuple(left_in, left_pos), PatKind::Tuple(right_in, right_pos)) => {\n@@ -264,6 +239,10 @@ fn form_exhaustive_matches(left: &Pat<'_>, right: &Pat<'_>) -> bool {\n             }\n             true\n         },\n+        (PatKind::TupleStruct(..), PatKind::Path(_)) => pat_in_candidate_enum(cx, ty, right),\n+        (PatKind::TupleStruct(..), PatKind::TupleStruct(_, inner, _)) => {\n+            pat_in_candidate_enum(cx, ty, right) && inner.iter().all(contains_only_wilds)\n+        },\n         _ => false,\n     }\n }"}, {"sha": "13853dec99de8970293790ffd481d030016bda51", "filename": "src/tools/clippy/clippy_lints/src/methods/map_flatten.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -14,14 +14,17 @@ use super::MAP_FLATTEN;\n pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, map_arg: &Expr<'_>, map_span: Span) {\n     if let Some((caller_ty_name, method_to_use)) = try_get_caller_ty_name_and_method_name(cx, expr, recv, map_arg) {\n         let mut applicability = Applicability::MachineApplicable;\n-        \n+\n         let closure_snippet = snippet_with_applicability(cx, map_arg.span, \"..\", &mut applicability);\n         span_lint_and_sugg(\n             cx,\n             MAP_FLATTEN,\n             expr.span.with_lo(map_span.lo()),\n             &format!(\"called `map(..).flatten()` on `{}`\", caller_ty_name),\n-            &format!(\"try replacing `map` with `{}` and remove the `.flatten()`\", method_to_use),\n+            &format!(\n+                \"try replacing `map` with `{}` and remove the `.flatten()`\",\n+                method_to_use\n+            ),\n             format!(\"{}({})\", method_to_use, closure_snippet),\n             applicability,\n         );"}, {"sha": "df2430ced6b621b11d7e442e83b1f9c1a6d16178", "filename": "src/tools/clippy/clippy_lints/src/misc.rs", "status": "modified", "additions": 6, "deletions": 477, "changes": 483, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,28 +1,21 @@\n-use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_and_then, span_lint_hir_and_then};\n+use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_hir_and_then};\n use clippy_utils::source::{snippet, snippet_opt};\n-use clippy_utils::ty::{implements_trait, is_copy};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{\n     self as hir, def, BinOpKind, BindingAnnotation, Body, Expr, ExprKind, FnDecl, HirId, Mutability, PatKind, Stmt,\n-    StmtKind, TyKind, UnOp,\n+    StmtKind, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::{ExpnKind, Span};\n-use rustc_span::symbol::sym;\n \n-use clippy_utils::consts::{constant, Constant};\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::{\n-    get_item_name, get_parent_expr, in_constant, is_integer_const, iter_input_pats, last_path_segment,\n-    match_any_def_paths, path_def_id, paths, unsext, SpanlessEq,\n-};\n+use clippy_utils::{get_parent_expr, in_constant, iter_input_pats, last_path_segment, SpanlessEq};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -58,122 +51,6 @@ declare_clippy_lint! {\n     style,\n     \"an entire binding declared as `ref`, in a function argument or a `let` statement\"\n }\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for comparisons to NaN.\n-    ///\n-    /// ### Why is this bad?\n-    /// NaN does not compare meaningfully to anything \u2013 not\n-    /// even itself \u2013 so those comparisons are simply wrong.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let x = 1.0;\n-    /// if x == f32::NAN { }\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// # let x = 1.0f32;\n-    /// if x.is_nan() { }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub CMP_NAN,\n-    correctness,\n-    \"comparisons to `NAN`, which will always return false, probably not intended\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for (in-)equality comparisons on floating-point\n-    /// values (apart from zero), except in functions called `*eq*` (which probably\n-    /// implement equality for a type involving floats).\n-    ///\n-    /// ### Why is this bad?\n-    /// Floating point calculations are usually imprecise, so\n-    /// asking if two values are *exactly* equal is asking for trouble. For a good\n-    /// guide on what to do, see [the floating point\n-    /// guide](http://www.floating-point-gui.de/errors/comparison).\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x = 1.2331f64;\n-    /// let y = 1.2332f64;\n-    ///\n-    /// if y == 1.23f64 { }\n-    /// if y != x {} // where both are floats\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// # let x = 1.2331f64;\n-    /// # let y = 1.2332f64;\n-    /// let error_margin = f64::EPSILON; // Use an epsilon for comparison\n-    /// // Or, if Rust <= 1.42, use `std::f64::EPSILON` constant instead.\n-    /// // let error_margin = std::f64::EPSILON;\n-    /// if (y - 1.23f64).abs() < error_margin { }\n-    /// if (y - x).abs() > error_margin { }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub FLOAT_CMP,\n-    pedantic,\n-    \"using `==` or `!=` on float values instead of comparing difference with an epsilon\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for conversions to owned values just for the sake\n-    /// of a comparison.\n-    ///\n-    /// ### Why is this bad?\n-    /// The comparison can operate on a reference, so creating\n-    /// an owned value effectively throws it away directly afterwards, which is\n-    /// needlessly consuming code and heap space.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let x = \"foo\";\n-    /// # let y = String::from(\"foo\");\n-    /// if x.to_owned() == y {}\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// # let x = \"foo\";\n-    /// # let y = String::from(\"foo\");\n-    /// if x == y {}\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub CMP_OWNED,\n-    perf,\n-    \"creating owned instances for comparing with others, e.g., `x == \\\"foo\\\".to_string()`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for getting the remainder of a division by one or minus\n-    /// one.\n-    ///\n-    /// ### Why is this bad?\n-    /// The result for a divisor of one can only ever be zero; for\n-    /// minus one it can cause panic/overflow (if the left operand is the minimal value of\n-    /// the respective integer type) or results in zero. No one will write such code\n-    /// deliberately, unless trying to win an Underhanded Rust Contest. Even for that\n-    /// contest, it's probably a bad idea. Use something more underhanded.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let x = 1;\n-    /// let a = x % 1;\n-    /// let a = x % -1;\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MODULO_ONE,\n-    correctness,\n-    \"taking a number modulo +/-1, which can either panic/overflow or always returns 0\"\n-}\n-\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for the use of bindings with a single leading\n@@ -244,51 +121,11 @@ declare_clippy_lint! {\n     \"using `0 as *{const, mut} T`\"\n }\n \n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for (in-)equality comparisons on floating-point\n-    /// value and constant, except in functions called `*eq*` (which probably\n-    /// implement equality for a type involving floats).\n-    ///\n-    /// ### Why is this bad?\n-    /// Floating point calculations are usually imprecise, so\n-    /// asking if two values are *exactly* equal is asking for trouble. For a good\n-    /// guide on what to do, see [the floating point\n-    /// guide](http://www.floating-point-gui.de/errors/comparison).\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x: f64 = 1.0;\n-    /// const ONE: f64 = 1.00;\n-    ///\n-    /// if x == ONE { } // where both are floats\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// # let x: f64 = 1.0;\n-    /// # const ONE: f64 = 1.00;\n-    /// let error_margin = f64::EPSILON; // Use an epsilon for comparison\n-    /// // Or, if Rust <= 1.42, use `std::f64::EPSILON` constant instead.\n-    /// // let error_margin = std::f64::EPSILON;\n-    /// if (x - ONE).abs() < error_margin { }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub FLOAT_CMP_CONST,\n-    restriction,\n-    \"using `==` or `!=` on float constants instead of comparing difference with an epsilon\"\n-}\n-\n declare_lint_pass!(MiscLints => [\n     TOPLEVEL_REF_ARG,\n-    CMP_NAN,\n-    FLOAT_CMP,\n-    CMP_OWNED,\n-    MODULO_ONE,\n     USED_UNDERSCORE_BINDING,\n     SHORT_CIRCUIT_STATEMENT,\n     ZERO_PTR,\n-    FLOAT_CMP_CONST\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for MiscLints {\n@@ -398,16 +235,9 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        match expr.kind {\n-            ExprKind::Cast(e, ty) => {\n-                check_cast(cx, expr.span, e, ty);\n-                return;\n-            },\n-            ExprKind::Binary(ref cmp, left, right) => {\n-                check_binary(cx, expr, cmp, left, right);\n-                return;\n-            },\n-            _ => {},\n+        if let ExprKind::Cast(e, ty) = expr.kind {\n+            check_cast(cx, expr.span, e, ty);\n+            return;\n         }\n         if in_attributes_expansion(expr) || expr.span.is_desugaring(DesugaringKind::Await) {\n             // Don't lint things expanded by #[derive(...)], etc or `await` desugaring\n@@ -455,236 +285,6 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n     }\n }\n \n-fn get_lint_and_message(\n-    is_comparing_constants: bool,\n-    is_comparing_arrays: bool,\n-) -> (&'static rustc_lint::Lint, &'static str) {\n-    if is_comparing_constants {\n-        (\n-            FLOAT_CMP_CONST,\n-            if is_comparing_arrays {\n-                \"strict comparison of `f32` or `f64` constant arrays\"\n-            } else {\n-                \"strict comparison of `f32` or `f64` constant\"\n-            },\n-        )\n-    } else {\n-        (\n-            FLOAT_CMP,\n-            if is_comparing_arrays {\n-                \"strict comparison of `f32` or `f64` arrays\"\n-            } else {\n-                \"strict comparison of `f32` or `f64`\"\n-            },\n-        )\n-    }\n-}\n-\n-fn check_nan(cx: &LateContext<'_>, expr: &Expr<'_>, cmp_expr: &Expr<'_>) {\n-    if_chain! {\n-        if !in_constant(cx, cmp_expr.hir_id);\n-        if let Some((value, _)) = constant(cx, cx.typeck_results(), expr);\n-        if match value {\n-            Constant::F32(num) => num.is_nan(),\n-            Constant::F64(num) => num.is_nan(),\n-            _ => false,\n-        };\n-        then {\n-            span_lint(\n-                cx,\n-                CMP_NAN,\n-                cmp_expr.span,\n-                \"doomed comparison with `NAN`, use `{f32,f64}::is_nan()` instead\",\n-            );\n-        }\n-    }\n-}\n-\n-fn is_named_constant<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    if let Some((_, res)) = constant(cx, cx.typeck_results(), expr) {\n-        res\n-    } else {\n-        false\n-    }\n-}\n-\n-fn is_allowed<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    match constant(cx, cx.typeck_results(), expr) {\n-        Some((Constant::F32(f), _)) => f == 0.0 || f.is_infinite(),\n-        Some((Constant::F64(f), _)) => f == 0.0 || f.is_infinite(),\n-        Some((Constant::Vec(vec), _)) => vec.iter().all(|f| match f {\n-            Constant::F32(f) => *f == 0.0 || (*f).is_infinite(),\n-            Constant::F64(f) => *f == 0.0 || (*f).is_infinite(),\n-            _ => false,\n-        }),\n-        _ => false,\n-    }\n-}\n-\n-// Return true if `expr` is the result of `signum()` invoked on a float value.\n-fn is_signum(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    // The negation of a signum is still a signum\n-    if let ExprKind::Unary(UnOp::Neg, child_expr) = expr.kind {\n-        return is_signum(cx, child_expr);\n-    }\n-\n-    if_chain! {\n-        if let ExprKind::MethodCall(method_name, [ref self_arg, ..], _) = expr.kind;\n-        if sym!(signum) == method_name.ident.name;\n-        // Check that the receiver of the signum() is a float (expressions[0] is the receiver of\n-        // the method call)\n-        then {\n-            return is_float(cx, self_arg);\n-        }\n-    }\n-    false\n-}\n-\n-fn is_float(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    let value = &cx.typeck_results().expr_ty(expr).peel_refs().kind();\n-\n-    if let ty::Array(arr_ty, _) = value {\n-        return matches!(arr_ty.kind(), ty::Float(_));\n-    };\n-\n-    matches!(value, ty::Float(_))\n-}\n-\n-fn is_array(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    matches!(&cx.typeck_results().expr_ty(expr).peel_refs().kind(), ty::Array(_, _))\n-}\n-\n-#[expect(clippy::too_many_lines)]\n-fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left: bool) {\n-    #[derive(Default)]\n-    struct EqImpl {\n-        ty_eq_other: bool,\n-        other_eq_ty: bool,\n-    }\n-\n-    impl EqImpl {\n-        fn is_implemented(&self) -> bool {\n-            self.ty_eq_other || self.other_eq_ty\n-        }\n-    }\n-\n-    fn symmetric_partial_eq<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, other: Ty<'tcx>) -> Option<EqImpl> {\n-        cx.tcx.lang_items().eq_trait().map(|def_id| EqImpl {\n-            ty_eq_other: implements_trait(cx, ty, def_id, &[other.into()]),\n-            other_eq_ty: implements_trait(cx, other, def_id, &[ty.into()]),\n-        })\n-    }\n-\n-    let typeck = cx.typeck_results();\n-    let (arg, arg_span) = match expr.kind {\n-        ExprKind::MethodCall(.., [arg], _)\n-            if typeck\n-                .type_dependent_def_id(expr.hir_id)\n-                .and_then(|id| cx.tcx.trait_of_item(id))\n-                .map_or(false, |id| {\n-                    matches!(cx.tcx.get_diagnostic_name(id), Some(sym::ToString | sym::ToOwned))\n-                }) =>\n-        {\n-            (arg, arg.span)\n-        },\n-        ExprKind::Call(path, [arg])\n-            if path_def_id(cx, path)\n-                .and_then(|id| match_any_def_paths(cx, id, &[&paths::FROM_STR_METHOD, &paths::FROM_FROM]))\n-                .map_or(false, |idx| match idx {\n-                    0 => true,\n-                    1 => !is_copy(cx, typeck.expr_ty(expr)),\n-                    _ => false,\n-                }) =>\n-        {\n-            (arg, arg.span)\n-        },\n-        _ => return,\n-    };\n-\n-    let arg_ty = typeck.expr_ty(arg);\n-    let other_ty = typeck.expr_ty(other);\n-\n-    let without_deref = symmetric_partial_eq(cx, arg_ty, other_ty).unwrap_or_default();\n-    let with_deref = arg_ty\n-        .builtin_deref(true)\n-        .and_then(|tam| symmetric_partial_eq(cx, tam.ty, other_ty))\n-        .unwrap_or_default();\n-\n-    if !with_deref.is_implemented() && !without_deref.is_implemented() {\n-        return;\n-    }\n-\n-    let other_gets_derefed = matches!(other.kind, ExprKind::Unary(UnOp::Deref, _));\n-\n-    let lint_span = if other_gets_derefed {\n-        expr.span.to(other.span)\n-    } else {\n-        expr.span\n-    };\n-\n-    span_lint_and_then(\n-        cx,\n-        CMP_OWNED,\n-        lint_span,\n-        \"this creates an owned instance just for comparison\",\n-        |diag| {\n-            // This also catches `PartialEq` implementations that call `to_owned`.\n-            if other_gets_derefed {\n-                diag.span_label(lint_span, \"try implementing the comparison without allocating\");\n-                return;\n-            }\n-\n-            let arg_snip = snippet(cx, arg_span, \"..\");\n-            let expr_snip;\n-            let eq_impl;\n-            if with_deref.is_implemented() {\n-                expr_snip = format!(\"*{}\", arg_snip);\n-                eq_impl = with_deref;\n-            } else {\n-                expr_snip = arg_snip.to_string();\n-                eq_impl = without_deref;\n-            };\n-\n-            let span;\n-            let hint;\n-            if (eq_impl.ty_eq_other && left) || (eq_impl.other_eq_ty && !left) {\n-                span = expr.span;\n-                hint = expr_snip;\n-            } else {\n-                span = expr.span.to(other.span);\n-\n-                let cmp_span = if other.span < expr.span {\n-                    other.span.between(expr.span)\n-                } else {\n-                    expr.span.between(other.span)\n-                };\n-                if eq_impl.ty_eq_other {\n-                    hint = format!(\n-                        \"{}{}{}\",\n-                        expr_snip,\n-                        snippet(cx, cmp_span, \"..\"),\n-                        snippet(cx, other.span, \"..\")\n-                    );\n-                } else {\n-                    hint = format!(\n-                        \"{}{}{}\",\n-                        snippet(cx, other.span, \"..\"),\n-                        snippet(cx, cmp_span, \"..\"),\n-                        expr_snip\n-                    );\n-                }\n-            }\n-\n-            diag.span_suggestion(\n-                span,\n-                \"try\",\n-                hint,\n-                Applicability::MachineApplicable, // snippet\n-            );\n-        },\n-    );\n-}\n-\n /// Heuristic to see if an expression is used. Should be compatible with\n /// `unused_variables`'s idea\n /// of what it means for an expression to be \"used\".\n@@ -740,74 +340,3 @@ fn check_cast(cx: &LateContext<'_>, span: Span, e: &Expr<'_>, ty: &hir::Ty<'_>)\n         }\n     }\n }\n-\n-fn check_binary<'a>(\n-    cx: &LateContext<'a>,\n-    expr: &Expr<'_>,\n-    cmp: &rustc_span::source_map::Spanned<rustc_hir::BinOpKind>,\n-    left: &'a Expr<'_>,\n-    right: &'a Expr<'_>,\n-) {\n-    let op = cmp.node;\n-    if op.is_comparison() {\n-        check_nan(cx, left, expr);\n-        check_nan(cx, right, expr);\n-        check_to_owned(cx, left, right, true);\n-        check_to_owned(cx, right, left, false);\n-    }\n-    if (op == BinOpKind::Eq || op == BinOpKind::Ne) && (is_float(cx, left) || is_float(cx, right)) {\n-        if is_allowed(cx, left) || is_allowed(cx, right) {\n-            return;\n-        }\n-\n-        // Allow comparing the results of signum()\n-        if is_signum(cx, left) && is_signum(cx, right) {\n-            return;\n-        }\n-\n-        if let Some(name) = get_item_name(cx, expr) {\n-            let name = name.as_str();\n-            if name == \"eq\" || name == \"ne\" || name == \"is_nan\" || name.starts_with(\"eq_\") || name.ends_with(\"_eq\") {\n-                return;\n-            }\n-        }\n-        let is_comparing_arrays = is_array(cx, left) || is_array(cx, right);\n-        let (lint, msg) = get_lint_and_message(\n-            is_named_constant(cx, left) || is_named_constant(cx, right),\n-            is_comparing_arrays,\n-        );\n-        span_lint_and_then(cx, lint, expr.span, msg, |diag| {\n-            let lhs = Sugg::hir(cx, left, \"..\");\n-            let rhs = Sugg::hir(cx, right, \"..\");\n-\n-            if !is_comparing_arrays {\n-                diag.span_suggestion(\n-                    expr.span,\n-                    \"consider comparing them within some margin of error\",\n-                    format!(\n-                        \"({}).abs() {} error_margin\",\n-                        lhs - rhs,\n-                        if op == BinOpKind::Eq { '<' } else { '>' }\n-                    ),\n-                    Applicability::HasPlaceholders, // snippet\n-                );\n-            }\n-            diag.note(\"`f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\");\n-        });\n-    } else if op == BinOpKind::Rem {\n-        if is_integer_const(cx, right, 1) {\n-            span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n-        }\n-\n-        if let ty::Int(ity) = cx.typeck_results().expr_ty(right).kind() {\n-            if is_integer_const(cx, right, unsext(cx.tcx, -1, *ity)) {\n-                span_lint(\n-                    cx,\n-                    MODULO_ONE,\n-                    expr.span,\n-                    \"any number modulo -1 will panic/overflow or result in 0\",\n-                );\n-            }\n-        };\n-    }\n-}"}, {"sha": "623d22bc9bdfe6a6a6c1c1ef674da4ff5946e64c", "filename": "src/tools/clippy/clippy_lints/src/needless_bitwise_bool.rs", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bitwise_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bitwise_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bitwise_bool.rs?ref=a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58", "patch": "@@ -1,85 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::source::snippet_opt;\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for uses of bitwise and/or operators between booleans, where performance may be improved by using\n-    /// a lazy and.\n-    ///\n-    /// ### Why is this bad?\n-    /// The bitwise operators do not support short-circuiting, so it may hinder code performance.\n-    /// Additionally, boolean logic \"masked\" as bitwise logic is not caught by lints like `unnecessary_fold`\n-    ///\n-    /// ### Known problems\n-    /// This lint evaluates only when the right side is determined to have no side effects. At this time, that\n-    /// determination is quite conservative.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let (x,y) = (true, false);\n-    /// if x & !y {} // where both x and y are booleans\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// let (x,y) = (true, false);\n-    /// if x && !y {}\n-    /// ```\n-    #[clippy::version = \"1.54.0\"]\n-    pub NEEDLESS_BITWISE_BOOL,\n-    pedantic,\n-    \"Boolean expressions that use bitwise rather than lazy operators\"\n-}\n-\n-declare_lint_pass!(NeedlessBitwiseBool => [NEEDLESS_BITWISE_BOOL]);\n-\n-fn is_bitwise_operation(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    let ty = cx.typeck_results().expr_ty(expr);\n-    if_chain! {\n-        if !expr.span.from_expansion();\n-        if let (&ExprKind::Binary(ref op, _, right), &ty::Bool) = (&expr.kind, &ty.kind());\n-        if op.node == BinOpKind::BitAnd || op.node == BinOpKind::BitOr;\n-        if let ExprKind::Call(..) | ExprKind::MethodCall(..) | ExprKind::Binary(..) | ExprKind::Unary(..) = right.kind;\n-        if !right.can_have_side_effects();\n-        then {\n-            return true;\n-        }\n-    }\n-    false\n-}\n-\n-fn suggestion_snippet(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n-    if let ExprKind::Binary(ref op, left, right) = expr.kind {\n-        if let (Some(l_snippet), Some(r_snippet)) = (snippet_opt(cx, left.span), snippet_opt(cx, right.span)) {\n-            let op_snippet = match op.node {\n-                BinOpKind::BitAnd => \"&&\",\n-                _ => \"||\",\n-            };\n-            return Some(format!(\"{} {} {}\", l_snippet, op_snippet, r_snippet));\n-        }\n-    }\n-    None\n-}\n-\n-impl LateLintPass<'_> for NeedlessBitwiseBool {\n-    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        if is_bitwise_operation(cx, expr) {\n-            span_lint_and_then(\n-                cx,\n-                NEEDLESS_BITWISE_BOOL,\n-                expr.span,\n-                \"use of bitwise operator instead of lazy operator between booleans\",\n-                |diag| {\n-                    if let Some(sugg) = suggestion_snippet(cx, expr) {\n-                        diag.span_suggestion(expr.span, \"try\", sugg, Applicability::MachineApplicable);\n-                    }\n-                },\n-            );\n-        }\n-    }\n-}"}, {"sha": "b087cfb36b1166968c1fde2c28b3e2bd42b872a4", "filename": "src/tools/clippy/clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneg_multiply.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,7 +1,9 @@\n use clippy_utils::consts::{self, Constant};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::sugg::has_enclosing_paren;\n use if_chain::if_chain;\n+use rustc_ast::util::parser::PREC_PREFIX;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -58,7 +60,12 @@ fn check_mul(cx: &LateContext<'_>, span: Span, lit: &Expr<'_>, exp: &Expr<'_>) {\n \n         then {\n             let mut applicability = Applicability::MachineApplicable;\n-            let suggestion = format!(\"-{}\", snippet_with_applicability(cx, exp.span, \"..\", &mut applicability));\n+            let snip = snippet_with_applicability(cx, exp.span, \"..\", &mut applicability);\n+            let suggestion = if exp.precedence().order() < PREC_PREFIX && !has_enclosing_paren(&snip) {\n+                format!(\"-({})\", snip)\n+            } else {\n+                format!(\"-{}\", snip)\n+            };\n             span_lint_and_sugg(\n                     cx,\n                     NEG_MULTIPLY,"}, {"sha": "a1ef32ae608055ab996a14fe40c84e1b1e87ff55", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -6,6 +6,7 @@ use std::ptr;\n \n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::in_constant;\n+use clippy_utils::macros::macro_backtrace;\n use if_chain::if_chain;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n@@ -18,7 +19,7 @@ use rustc_middle::mir::interpret::{ConstValue, ErrorHandled};\n use rustc_middle::ty::adjustment::Adjust;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{InnerSpan, Span, DUMMY_SP};\n+use rustc_span::{sym, InnerSpan, Span, DUMMY_SP};\n use rustc_typeck::hir_ty_to_ty;\n \n // FIXME: this is a correctness problem but there's no suitable\n@@ -250,8 +251,14 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, it: &'tcx Item<'_>) {\n         if let ItemKind::Const(hir_ty, body_id) = it.kind {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n-\n-            if is_unfrozen(cx, ty) && is_value_unfrozen_poly(cx, body_id, ty) {\n+            if !macro_backtrace(it.span).last().map_or(false, |macro_call| {\n+                matches!(\n+                    cx.tcx.get_diagnostic_name(macro_call.def_id),\n+                    Some(sym::thread_local_macro)\n+                )\n+            }) && is_unfrozen(cx, ty)\n+                && is_value_unfrozen_poly(cx, body_id, ty)\n+            {\n                 lint(cx, Source::Item { item: it.span });\n             }\n         }"}, {"sha": "b96af06b8d7c69a63c5c177970b322f6f98d01fa", "filename": "src/tools/clippy/clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -159,12 +159,10 @@ impl<'a, 'tcx, 'b> Visitor<'tcx> for SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n \n #[must_use]\n fn get_exemptions(interned_name: &str) -> Option<&'static [&'static str]> {\n-    for &list in ALLOWED_TO_BE_SIMILAR {\n-        if allowed_to_be_similar(interned_name, list) {\n-            return Some(list);\n-        }\n-    }\n-    None\n+    ALLOWED_TO_BE_SIMILAR\n+        .iter()\n+        .find(|&&list| allowed_to_be_similar(interned_name, list))\n+        .copied()\n }\n \n #[must_use]\n@@ -328,7 +326,7 @@ impl<'a, 'tcx> Visitor<'tcx> for SimilarNamesLocalVisitor<'a, 'tcx> {\n         // add the pattern after the expression because the bindings aren't available\n         // yet in the init\n         // expression\n-        SimilarNamesNameVisitor(self).visit_pat(&*local.pat);\n+        SimilarNamesNameVisitor(self).visit_pat(&local.pat);\n     }\n     fn visit_block(&mut self, blk: &'tcx Block) {\n         self.single_char_names.push(vec![]);"}, {"sha": "5c4de3381496cd839567ba17a5b2de1eef2e2b99", "filename": "src/tools/clippy/clippy_lints/src/numeric_arithmetic.rs", "status": "removed", "additions": 0, "deletions": 170, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnumeric_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnumeric_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnumeric_arithmetic.rs?ref=a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58", "patch": "@@ -1,170 +0,0 @@\n-use clippy_utils::consts::constant_simple;\n-use clippy_utils::diagnostics::span_lint;\n-use rustc_hir as hir;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::source_map::Span;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for integer arithmetic operations which could overflow or panic.\n-    ///\n-    /// Specifically, checks for any operators (`+`, `-`, `*`, `<<`, etc) which are capable\n-    /// of overflowing according to the [Rust\n-    /// Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow),\n-    /// or which can panic (`/`, `%`). No bounds analysis or sophisticated reasoning is\n-    /// attempted.\n-    ///\n-    /// ### Why is this bad?\n-    /// Integer overflow will trigger a panic in debug builds or will wrap in\n-    /// release mode. Division by zero will cause a panic in either mode. In some applications one\n-    /// wants explicitly checked, wrapping or saturating arithmetic.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let a = 0;\n-    /// a + 1;\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub INTEGER_ARITHMETIC,\n-    restriction,\n-    \"any integer arithmetic expression which could overflow or panic\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for float arithmetic.\n-    ///\n-    /// ### Why is this bad?\n-    /// For some embedded systems or kernel development, it\n-    /// can be useful to rule out floating-point numbers.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let a = 0.0;\n-    /// a + 1.0;\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub FLOAT_ARITHMETIC,\n-    restriction,\n-    \"any floating-point arithmetic statement\"\n-}\n-\n-#[derive(Copy, Clone, Default)]\n-pub struct NumericArithmetic {\n-    expr_span: Option<Span>,\n-    /// This field is used to check whether expressions are constants, such as in enum discriminants\n-    /// and consts\n-    const_span: Option<Span>,\n-}\n-\n-impl_lint_pass!(NumericArithmetic => [INTEGER_ARITHMETIC, FLOAT_ARITHMETIC]);\n-\n-impl<'tcx> LateLintPass<'tcx> for NumericArithmetic {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if self.expr_span.is_some() {\n-            return;\n-        }\n-\n-        if let Some(span) = self.const_span {\n-            if span.contains(expr.span) {\n-                return;\n-            }\n-        }\n-        match &expr.kind {\n-            hir::ExprKind::Binary(op, l, r) | hir::ExprKind::AssignOp(op, l, r) => {\n-                match op.node {\n-                    hir::BinOpKind::And\n-                    | hir::BinOpKind::Or\n-                    | hir::BinOpKind::BitAnd\n-                    | hir::BinOpKind::BitOr\n-                    | hir::BinOpKind::BitXor\n-                    | hir::BinOpKind::Eq\n-                    | hir::BinOpKind::Lt\n-                    | hir::BinOpKind::Le\n-                    | hir::BinOpKind::Ne\n-                    | hir::BinOpKind::Ge\n-                    | hir::BinOpKind::Gt => return,\n-                    _ => (),\n-                }\n-\n-                let (l_ty, r_ty) = (cx.typeck_results().expr_ty(l), cx.typeck_results().expr_ty(r));\n-                if l_ty.peel_refs().is_integral() && r_ty.peel_refs().is_integral() {\n-                    match op.node {\n-                        hir::BinOpKind::Div | hir::BinOpKind::Rem => match &r.kind {\n-                            hir::ExprKind::Lit(_lit) => (),\n-                            hir::ExprKind::Unary(hir::UnOp::Neg, expr) => {\n-                                if let hir::ExprKind::Lit(lit) = &expr.kind {\n-                                    if let rustc_ast::ast::LitKind::Int(1, _) = lit.node {\n-                                        span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n-                                        self.expr_span = Some(expr.span);\n-                                    }\n-                                }\n-                            },\n-                            _ => {\n-                                span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n-                                self.expr_span = Some(expr.span);\n-                            },\n-                        },\n-                        _ => {\n-                            span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n-                            self.expr_span = Some(expr.span);\n-                        },\n-                    }\n-                } else if r_ty.peel_refs().is_floating_point() && r_ty.peel_refs().is_floating_point() {\n-                    span_lint(cx, FLOAT_ARITHMETIC, expr.span, \"floating-point arithmetic detected\");\n-                    self.expr_span = Some(expr.span);\n-                }\n-            },\n-            hir::ExprKind::Unary(hir::UnOp::Neg, arg) => {\n-                let ty = cx.typeck_results().expr_ty(arg);\n-                if constant_simple(cx, cx.typeck_results(), expr).is_none() {\n-                    if ty.is_integral() {\n-                        span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n-                        self.expr_span = Some(expr.span);\n-                    } else if ty.is_floating_point() {\n-                        span_lint(cx, FLOAT_ARITHMETIC, expr.span, \"floating-point arithmetic detected\");\n-                        self.expr_span = Some(expr.span);\n-                    }\n-                }\n-            },\n-            _ => (),\n-        }\n-    }\n-\n-    fn check_expr_post(&mut self, _: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if Some(expr.span) == self.expr_span {\n-            self.expr_span = None;\n-        }\n-    }\n-\n-    fn check_body(&mut self, cx: &LateContext<'_>, body: &hir::Body<'_>) {\n-        let body_owner = cx.tcx.hir().body_owner_def_id(body.id());\n-\n-        match cx.tcx.hir().body_owner_kind(body_owner) {\n-            hir::BodyOwnerKind::Static(_) | hir::BodyOwnerKind::Const => {\n-                let body_span = cx.tcx.def_span(body_owner);\n-\n-                if let Some(span) = self.const_span {\n-                    if span.contains(body_span) {\n-                        return;\n-                    }\n-                }\n-                self.const_span = Some(body_span);\n-            },\n-            hir::BodyOwnerKind::Fn | hir::BodyOwnerKind::Closure => (),\n-        }\n-    }\n-\n-    fn check_body_post(&mut self, cx: &LateContext<'_>, body: &hir::Body<'_>) {\n-        let body_owner = cx.tcx.hir().body_owner(body.id());\n-        let body_span = cx.tcx.hir().span(body_owner);\n-\n-        if let Some(span) = self.const_span {\n-            if span.contains(body_span) {\n-                return;\n-            }\n-        }\n-        self.const_span = None;\n-    }\n-}"}, {"sha": "1ec4240afefe5c4939909735ef9d17c881d23efe", "filename": "src/tools/clippy/clippy_lints/src/operators/absurd_extreme_comparisons.rs", "status": "renamed", "additions": 35, "deletions": 68, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fabsurd_extreme_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fabsurd_extreme_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fabsurd_extreme_comparisons.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,7 +1,6 @@\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_lint::LateContext;\n use rustc_middle::ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n use clippy_utils::comparisons::{normalize_comparison, Rel};\n use clippy_utils::consts::{constant, Constant};\n@@ -10,73 +9,41 @@ use clippy_utils::source::snippet;\n use clippy_utils::ty::is_isize_or_usize;\n use clippy_utils::{clip, int_bits, unsext};\n \n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for comparisons where one side of the relation is\n-    /// either the minimum or maximum value for its type and warns if it involves a\n-    /// case that is always true or always false. Only integer and boolean types are\n-    /// checked.\n-    ///\n-    /// ### Why is this bad?\n-    /// An expression like `min <= x` may misleadingly imply\n-    /// that it is possible for `x` to be less than the minimum. Expressions like\n-    /// `max < x` are probably mistakes.\n-    ///\n-    /// ### Known problems\n-    /// For `usize` the size of the current compile target will\n-    /// be assumed (e.g., 64 bits on 64 bit systems). This means code that uses such\n-    /// a comparison to detect target pointer width will trigger this lint. One can\n-    /// use `mem::sizeof` and compare its value or conditional compilation\n-    /// attributes\n-    /// like `#[cfg(target_pointer_width = \"64\")] ..` instead.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let vec: Vec<isize> = Vec::new();\n-    /// if vec.len() <= 0 {}\n-    /// if 100 > i32::MAX {}\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub ABSURD_EXTREME_COMPARISONS,\n-    correctness,\n-    \"a comparison with a maximum or minimum value that is always true or false\"\n-}\n+use super::ABSURD_EXTREME_COMPARISONS;\n \n-declare_lint_pass!(AbsurdExtremeComparisons => [ABSURD_EXTREME_COMPARISONS]);\n-\n-impl<'tcx> LateLintPass<'tcx> for AbsurdExtremeComparisons {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Binary(ref cmp, lhs, rhs) = expr.kind {\n-            if let Some((culprit, result)) = detect_absurd_comparison(cx, cmp.node, lhs, rhs) {\n-                if !expr.span.from_expansion() {\n-                    let msg = \"this comparison involving the minimum or maximum element for this \\\n-                               type contains a case that is always true or always false\";\n-\n-                    let conclusion = match result {\n-                        AbsurdComparisonResult::AlwaysFalse => \"this comparison is always false\".to_owned(),\n-                        AbsurdComparisonResult::AlwaysTrue => \"this comparison is always true\".to_owned(),\n-                        AbsurdComparisonResult::InequalityImpossible => format!(\n-                            \"the case where the two sides are not equal never occurs, consider using `{} == {}` \\\n-                             instead\",\n-                            snippet(cx, lhs.span, \"lhs\"),\n-                            snippet(cx, rhs.span, \"rhs\")\n-                        ),\n-                    };\n-\n-                    let help = format!(\n-                        \"because `{}` is the {} value for this type, {}\",\n-                        snippet(cx, culprit.expr.span, \"x\"),\n-                        match culprit.which {\n-                            ExtremeType::Minimum => \"minimum\",\n-                            ExtremeType::Maximum => \"maximum\",\n-                        },\n-                        conclusion\n-                    );\n-\n-                    span_lint_and_help(cx, ABSURD_EXTREME_COMPARISONS, expr.span, msg, None, &help);\n-                }\n-            }\n-        }\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    op: BinOpKind,\n+    lhs: &'tcx Expr<'_>,\n+    rhs: &'tcx Expr<'_>,\n+) {\n+    if let Some((culprit, result)) = detect_absurd_comparison(cx, op, lhs, rhs) {\n+        let msg = \"this comparison involving the minimum or maximum element for this \\\n+                           type contains a case that is always true or always false\";\n+\n+        let conclusion = match result {\n+            AbsurdComparisonResult::AlwaysFalse => \"this comparison is always false\".to_owned(),\n+            AbsurdComparisonResult::AlwaysTrue => \"this comparison is always true\".to_owned(),\n+            AbsurdComparisonResult::InequalityImpossible => format!(\n+                \"the case where the two sides are not equal never occurs, consider using `{} == {}` \\\n+                         instead\",\n+                snippet(cx, lhs.span, \"lhs\"),\n+                snippet(cx, rhs.span, \"rhs\")\n+            ),\n+        };\n+\n+        let help = format!(\n+            \"because `{}` is the {} value for this type, {}\",\n+            snippet(cx, culprit.expr.span, \"x\"),\n+            match culprit.which {\n+                ExtremeType::Minimum => \"minimum\",\n+                ExtremeType::Maximum => \"maximum\",\n+            },\n+            conclusion\n+        );\n+\n+        span_lint_and_help(cx, ABSURD_EXTREME_COMPARISONS, expr.span, msg, None, &help);\n     }\n }\n ", "previous_filename": "src/tools/clippy/clippy_lints/src/absurd_extreme_comparisons.rs"}, {"sha": "979e0a66707dda33463259430cefe05e6c01df62", "filename": "src/tools/clippy/clippy_lints/src/operators/assign_op_pattern.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,101 @@\n+use clippy_utils::binop_traits;\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::source::snippet_opt;\n+use clippy_utils::ty::implements_trait;\n+use clippy_utils::{eq_expr_value, trait_ref_of_method};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::intravisit::{walk_expr, Visitor};\n+use rustc_lint::LateContext;\n+\n+use super::ASSIGN_OP_PATTERN;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    assignee: &'tcx hir::Expr<'_>,\n+    e: &'tcx hir::Expr<'_>,\n+) {\n+    if let hir::ExprKind::Binary(op, l, r) = &e.kind {\n+        let lint = |assignee: &hir::Expr<'_>, rhs: &hir::Expr<'_>| {\n+            let ty = cx.typeck_results().expr_ty(assignee);\n+            let rty = cx.typeck_results().expr_ty(rhs);\n+            if_chain! {\n+                if let Some((_, lang_item)) = binop_traits(op.node);\n+                if let Ok(trait_id) = cx.tcx.lang_items().require(lang_item);\n+                let parent_fn = cx.tcx.hir().get_parent_item(e.hir_id);\n+                if trait_ref_of_method(cx, parent_fn)\n+                    .map_or(true, |t| t.path.res.def_id() != trait_id);\n+                if implements_trait(cx, ty, trait_id, &[rty.into()]);\n+                then {\n+                    span_lint_and_then(\n+                        cx,\n+                        ASSIGN_OP_PATTERN,\n+                        expr.span,\n+                        \"manual implementation of an assign operation\",\n+                        |diag| {\n+                            if let (Some(snip_a), Some(snip_r)) =\n+                                (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs.span))\n+                            {\n+                                diag.span_suggestion(\n+                                    expr.span,\n+                                    \"replace it with\",\n+                                    format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r),\n+                                    Applicability::MachineApplicable,\n+                                );\n+                            }\n+                        },\n+                    );\n+                }\n+            }\n+        };\n+\n+        let mut visitor = ExprVisitor {\n+            assignee,\n+            counter: 0,\n+            cx,\n+        };\n+\n+        walk_expr(&mut visitor, e);\n+\n+        if visitor.counter == 1 {\n+            // a = a op b\n+            if eq_expr_value(cx, assignee, l) {\n+                lint(assignee, r);\n+            }\n+            // a = b commutative_op a\n+            // Limited to primitive type as these ops are know to be commutative\n+            if eq_expr_value(cx, assignee, r) && cx.typeck_results().expr_ty(assignee).is_primitive_ty() {\n+                match op.node {\n+                    hir::BinOpKind::Add\n+                    | hir::BinOpKind::Mul\n+                    | hir::BinOpKind::And\n+                    | hir::BinOpKind::Or\n+                    | hir::BinOpKind::BitXor\n+                    | hir::BinOpKind::BitAnd\n+                    | hir::BinOpKind::BitOr => {\n+                        lint(assignee, l);\n+                    },\n+                    _ => {},\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+struct ExprVisitor<'a, 'tcx> {\n+    assignee: &'a hir::Expr<'a>,\n+    counter: u8,\n+    cx: &'a LateContext<'tcx>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n+        if eq_expr_value(self.cx, self.assignee, expr) {\n+            self.counter += 1;\n+        }\n+\n+        walk_expr(self, expr);\n+    }\n+}"}, {"sha": "74387fbc87be06be2f3b5e9b370f2fdf6af642c4", "filename": "src/tools/clippy/clippy_lints/src/operators/bit_mask.rs", "status": "renamed", "additions": 15, "deletions": 153, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fbit_mask.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,161 +1,23 @@\n use clippy_utils::consts::{constant, Constant};\n-use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n-use clippy_utils::sugg::Sugg;\n-use rustc_ast::ast::LitKind;\n-use rustc_errors::Applicability;\n+use clippy_utils::diagnostics::span_lint;\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_lint::LateContext;\n use rustc_span::source_map::Span;\n \n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for incompatible bit masks in comparisons.\n-    ///\n-    /// The formula for detecting if an expression of the type `_ <bit_op> m\n-    /// <cmp_op> c` (where `<bit_op>` is one of {`&`, `|`} and `<cmp_op>` is one of\n-    /// {`!=`, `>=`, `>`, `!=`, `>=`, `>`}) can be determined from the following\n-    /// table:\n-    ///\n-    /// |Comparison  |Bit Op|Example      |is always|Formula               |\n-    /// |------------|------|-------------|---------|----------------------|\n-    /// |`==` or `!=`| `&`  |`x & 2 == 3` |`false`  |`c & m != c`          |\n-    /// |`<`  or `>=`| `&`  |`x & 2 < 3`  |`true`   |`m < c`               |\n-    /// |`>`  or `<=`| `&`  |`x & 1 > 1`  |`false`  |`m <= c`              |\n-    /// |`==` or `!=`| `\\|` |`x \\| 1 == 0`|`false`  |`c \\| m != c`         |\n-    /// |`<`  or `>=`| `\\|` |`x \\| 1 < 1` |`false`  |`m >= c`              |\n-    /// |`<=` or `>` | `\\|` |`x \\| 1 > 0` |`true`   |`m > c`               |\n-    ///\n-    /// ### Why is this bad?\n-    /// If the bits that the comparison cares about are always\n-    /// set to zero or one by the bit mask, the comparison is constant `true` or\n-    /// `false` (depending on mask, compared value, and operators).\n-    ///\n-    /// So the code is actively misleading, and the only reason someone would write\n-    /// this intentionally is to win an underhanded Rust contest or create a\n-    /// test-case for this lint.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let x = 1;\n-    /// if (x & 1 == 2) { }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub BAD_BIT_MASK,\n-    correctness,\n-    \"expressions of the form `_ & mask == select` that will only ever return `true` or `false`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for bit masks in comparisons which can be removed\n-    /// without changing the outcome. The basic structure can be seen in the\n-    /// following table:\n-    ///\n-    /// |Comparison| Bit Op   |Example     |equals |\n-    /// |----------|----------|------------|-------|\n-    /// |`>` / `<=`|`\\|` / `^`|`x \\| 2 > 3`|`x > 3`|\n-    /// |`<` / `>=`|`\\|` / `^`|`x ^ 1 < 4` |`x < 4`|\n-    ///\n-    /// ### Why is this bad?\n-    /// Not equally evil as [`bad_bit_mask`](#bad_bit_mask),\n-    /// but still a bit misleading, because the bit mask is ineffective.\n-    ///\n-    /// ### Known problems\n-    /// False negatives: This lint will only match instances\n-    /// where we have figured out the math (which is for a power-of-two compared\n-    /// value). This means things like `x | 1 >= 7` (which would be better written\n-    /// as `x >= 6`) will not be reported (but bit masks like this are fairly\n-    /// uncommon).\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let x = 1;\n-    /// if (x | 1 > 3) {  }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub INEFFECTIVE_BIT_MASK,\n-    correctness,\n-    \"expressions where a bit mask will be rendered useless by a comparison, e.g., `(x | 1) > 2`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for bit masks that can be replaced by a call\n-    /// to `trailing_zeros`\n-    ///\n-    /// ### Why is this bad?\n-    /// `x.trailing_zeros() > 4` is much clearer than `x & 15\n-    /// == 0`\n-    ///\n-    /// ### Known problems\n-    /// llvm generates better code for `x & 15 == 0` on x86\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let x = 1;\n-    /// if x & 0b1111 == 0 { }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub VERBOSE_BIT_MASK,\n-    pedantic,\n-    \"expressions where a bit mask is less readable than the corresponding method call\"\n-}\n+use super::{BAD_BIT_MASK, INEFFECTIVE_BIT_MASK};\n \n-#[derive(Copy, Clone)]\n-pub struct BitMask {\n-    verbose_bit_mask_threshold: u64,\n-}\n-\n-impl BitMask {\n-    #[must_use]\n-    pub fn new(verbose_bit_mask_threshold: u64) -> Self {\n-        Self {\n-            verbose_bit_mask_threshold,\n-        }\n-    }\n-}\n-\n-impl_lint_pass!(BitMask => [BAD_BIT_MASK, INEFFECTIVE_BIT_MASK, VERBOSE_BIT_MASK]);\n-\n-impl<'tcx> LateLintPass<'tcx> for BitMask {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if let ExprKind::Binary(cmp, left, right) = &e.kind {\n-            if cmp.node.is_comparison() {\n-                if let Some(cmp_opt) = fetch_int_literal(cx, right) {\n-                    check_compare(cx, left, cmp.node, cmp_opt, e.span);\n-                } else if let Some(cmp_val) = fetch_int_literal(cx, left) {\n-                    check_compare(cx, right, invert_cmp(cmp.node), cmp_val, e.span);\n-                }\n-            }\n-        }\n-\n-        if let ExprKind::Binary(op, left, right) = &e.kind\n-            && BinOpKind::Eq == op.node\n-            && let ExprKind::Binary(op1, left1, right1) = &left.kind\n-            && BinOpKind::BitAnd == op1.node\n-            && let ExprKind::Lit(lit) = &right1.kind\n-            && let LitKind::Int(n, _) = lit.node\n-            && let ExprKind::Lit(lit1) = &right.kind\n-            && let LitKind::Int(0, _) = lit1.node\n-            && n.leading_zeros() == n.count_zeros()\n-            && n > u128::from(self.verbose_bit_mask_threshold)\n-        {\n-            span_lint_and_then(\n-                cx,\n-                VERBOSE_BIT_MASK,\n-                e.span,\n-                \"bit mask could be simplified with a call to `trailing_zeros`\",\n-                |diag| {\n-                    let sugg = Sugg::hir(cx, left1, \"...\").maybe_par();\n-                    diag.span_suggestion(\n-                        e.span,\n-                        \"try\",\n-                        format!(\"{}.trailing_zeros() >= {}\", sugg, n.count_ones()),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                },\n-            );\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    op: BinOpKind,\n+    left: &'tcx Expr<'_>,\n+    right: &'tcx Expr<'_>,\n+) {\n+    if op.is_comparison() {\n+        if let Some(cmp_opt) = fetch_int_literal(cx, right) {\n+            check_compare(cx, left, op, cmp_opt, e.span);\n+        } else if let Some(cmp_val) = fetch_int_literal(cx, left) {\n+            check_compare(cx, right, invert_cmp(op), cmp_val, e.span);\n         }\n     }\n }", "previous_filename": "src/tools/clippy/clippy_lints/src/bit_mask.rs"}, {"sha": "786ae1552ad3d01283d3e6e33dd8665cbe480c87", "filename": "src/tools/clippy/clippy_lints/src/operators/cmp_nan.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fcmp_nan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fcmp_nan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fcmp_nan.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,30 @@\n+use clippy_utils::consts::{constant, Constant};\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::in_constant;\n+use rustc_hir::{BinOpKind, Expr};\n+use rustc_lint::LateContext;\n+\n+use super::CMP_NAN;\n+\n+pub(super) fn check(cx: &LateContext<'_>, e: &Expr<'_>, op: BinOpKind, lhs: &Expr<'_>, rhs: &Expr<'_>) {\n+    if op.is_comparison() && !in_constant(cx, e.hir_id) && (is_nan(cx, lhs) || is_nan(cx, rhs)) {\n+        span_lint(\n+            cx,\n+            CMP_NAN,\n+            e.span,\n+            \"doomed comparison with `NAN`, use `{f32,f64}::is_nan()` instead\",\n+        );\n+    }\n+}\n+\n+fn is_nan(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n+    if let Some((value, _)) = constant(cx, cx.typeck_results(), e) {\n+        match value {\n+            Constant::F32(num) => num.is_nan(),\n+            Constant::F64(num) => num.is_nan(),\n+            _ => false,\n+        }\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "e1f9b5906f667cdb8e62ae670ecba722bb13773f", "filename": "src/tools/clippy/clippy_lints/src/operators/cmp_owned.rs", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,147 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::source::snippet;\n+use clippy_utils::ty::{implements_trait, is_copy};\n+use clippy_utils::{match_any_def_paths, path_def_id, paths};\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind, UnOp};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::Ty;\n+use rustc_span::symbol::sym;\n+\n+use super::CMP_OWNED;\n+\n+pub(super) fn check(cx: &LateContext<'_>, op: BinOpKind, lhs: &Expr<'_>, rhs: &Expr<'_>) {\n+    if op.is_comparison() {\n+        check_op(cx, lhs, rhs, true);\n+        check_op(cx, rhs, lhs, false);\n+    }\n+}\n+\n+#[derive(Default)]\n+struct EqImpl {\n+    ty_eq_other: bool,\n+    other_eq_ty: bool,\n+}\n+impl EqImpl {\n+    fn is_implemented(&self) -> bool {\n+        self.ty_eq_other || self.other_eq_ty\n+    }\n+}\n+\n+fn symmetric_partial_eq<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, other: Ty<'tcx>) -> Option<EqImpl> {\n+    cx.tcx.lang_items().eq_trait().map(|def_id| EqImpl {\n+        ty_eq_other: implements_trait(cx, ty, def_id, &[other.into()]),\n+        other_eq_ty: implements_trait(cx, other, def_id, &[ty.into()]),\n+    })\n+}\n+\n+fn check_op(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left: bool) {\n+    let typeck = cx.typeck_results();\n+    let (arg, arg_span) = match expr.kind {\n+        ExprKind::MethodCall(.., [arg], _)\n+            if typeck\n+                .type_dependent_def_id(expr.hir_id)\n+                .and_then(|id| cx.tcx.trait_of_item(id))\n+                .map_or(false, |id| {\n+                    matches!(cx.tcx.get_diagnostic_name(id), Some(sym::ToString | sym::ToOwned))\n+                }) =>\n+        {\n+            (arg, arg.span)\n+        },\n+        ExprKind::Call(path, [arg])\n+            if path_def_id(cx, path)\n+                .and_then(|id| match_any_def_paths(cx, id, &[&paths::FROM_STR_METHOD, &paths::FROM_FROM]))\n+                .map_or(false, |idx| match idx {\n+                    0 => true,\n+                    1 => !is_copy(cx, typeck.expr_ty(expr)),\n+                    _ => false,\n+                }) =>\n+        {\n+            (arg, arg.span)\n+        },\n+        _ => return,\n+    };\n+\n+    let arg_ty = typeck.expr_ty(arg);\n+    let other_ty = typeck.expr_ty(other);\n+\n+    let without_deref = symmetric_partial_eq(cx, arg_ty, other_ty).unwrap_or_default();\n+    let with_deref = arg_ty\n+        .builtin_deref(true)\n+        .and_then(|tam| symmetric_partial_eq(cx, tam.ty, other_ty))\n+        .unwrap_or_default();\n+\n+    if !with_deref.is_implemented() && !without_deref.is_implemented() {\n+        return;\n+    }\n+\n+    let other_gets_derefed = matches!(other.kind, ExprKind::Unary(UnOp::Deref, _));\n+\n+    let lint_span = if other_gets_derefed {\n+        expr.span.to(other.span)\n+    } else {\n+        expr.span\n+    };\n+\n+    span_lint_and_then(\n+        cx,\n+        CMP_OWNED,\n+        lint_span,\n+        \"this creates an owned instance just for comparison\",\n+        |diag| {\n+            // This also catches `PartialEq` implementations that call `to_owned`.\n+            if other_gets_derefed {\n+                diag.span_label(lint_span, \"try implementing the comparison without allocating\");\n+                return;\n+            }\n+\n+            let arg_snip = snippet(cx, arg_span, \"..\");\n+            let expr_snip;\n+            let eq_impl;\n+            if with_deref.is_implemented() {\n+                expr_snip = format!(\"*{}\", arg_snip);\n+                eq_impl = with_deref;\n+            } else {\n+                expr_snip = arg_snip.to_string();\n+                eq_impl = without_deref;\n+            };\n+\n+            let span;\n+            let hint;\n+            if (eq_impl.ty_eq_other && left) || (eq_impl.other_eq_ty && !left) {\n+                span = expr.span;\n+                hint = expr_snip;\n+            } else {\n+                span = expr.span.to(other.span);\n+\n+                let cmp_span = if other.span < expr.span {\n+                    other.span.between(expr.span)\n+                } else {\n+                    expr.span.between(other.span)\n+                };\n+                if eq_impl.ty_eq_other {\n+                    hint = format!(\n+                        \"{}{}{}\",\n+                        expr_snip,\n+                        snippet(cx, cmp_span, \"..\"),\n+                        snippet(cx, other.span, \"..\")\n+                    );\n+                } else {\n+                    hint = format!(\n+                        \"{}{}{}\",\n+                        snippet(cx, other.span, \"..\"),\n+                        snippet(cx, cmp_span, \"..\"),\n+                        expr_snip\n+                    );\n+                }\n+            }\n+\n+            diag.span_suggestion(\n+                span,\n+                \"try\",\n+                hint,\n+                Applicability::MachineApplicable, // snippet\n+            );\n+        },\n+    );\n+}"}, {"sha": "56a86d0ffa212347bcf2b9ce12c554ad1cdabfe9", "filename": "src/tools/clippy/clippy_lints/src/operators/double_comparison.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fdouble_comparison.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,54 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::eq_expr_value;\n+use clippy_utils::source::snippet_with_applicability;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::Span;\n+\n+use super::DOUBLE_COMPARISONS;\n+\n+#[expect(clippy::similar_names)]\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, op: BinOpKind, lhs: &'tcx Expr<'_>, rhs: &'tcx Expr<'_>, span: Span) {\n+    let (lkind, llhs, lrhs, rkind, rlhs, rrhs) = match (&lhs.kind, &rhs.kind) {\n+        (ExprKind::Binary(lb, llhs, lrhs), ExprKind::Binary(rb, rlhs, rrhs)) => {\n+            (lb.node, llhs, lrhs, rb.node, rlhs, rrhs)\n+        },\n+        _ => return,\n+    };\n+    if !(eq_expr_value(cx, llhs, rlhs) && eq_expr_value(cx, lrhs, rrhs)) {\n+        return;\n+    }\n+    macro_rules! lint_double_comparison {\n+        ($op:tt) => {{\n+            let mut applicability = Applicability::MachineApplicable;\n+            let lhs_str = snippet_with_applicability(cx, llhs.span, \"\", &mut applicability);\n+            let rhs_str = snippet_with_applicability(cx, lrhs.span, \"\", &mut applicability);\n+            let sugg = format!(\"{} {} {}\", lhs_str, stringify!($op), rhs_str);\n+            span_lint_and_sugg(\n+                cx,\n+                DOUBLE_COMPARISONS,\n+                span,\n+                \"this binary expression can be simplified\",\n+                \"try\",\n+                sugg,\n+                applicability,\n+            );\n+        }};\n+    }\n+    match (op, lkind, rkind) {\n+        (BinOpKind::Or, BinOpKind::Eq, BinOpKind::Lt) | (BinOpKind::Or, BinOpKind::Lt, BinOpKind::Eq) => {\n+            lint_double_comparison!(<=);\n+        },\n+        (BinOpKind::Or, BinOpKind::Eq, BinOpKind::Gt) | (BinOpKind::Or, BinOpKind::Gt, BinOpKind::Eq) => {\n+            lint_double_comparison!(>=);\n+        },\n+        (BinOpKind::Or, BinOpKind::Lt, BinOpKind::Gt) | (BinOpKind::Or, BinOpKind::Gt, BinOpKind::Lt) => {\n+            lint_double_comparison!(!=);\n+        },\n+        (BinOpKind::And, BinOpKind::Le, BinOpKind::Ge) | (BinOpKind::And, BinOpKind::Ge, BinOpKind::Le) => {\n+            lint_double_comparison!(==);\n+        },\n+        _ => (),\n+    };\n+}"}, {"sha": "0d067d1e1968c4ec2d729e932c08f6cabf6e7577", "filename": "src/tools/clippy/clippy_lints/src/operators/duration_subsec.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fduration_subsec.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,44 @@\n+use clippy_utils::consts::{constant, Constant};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::DURATION_SUBSEC;\n+\n+pub(crate) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    op: BinOpKind,\n+    left: &'tcx Expr<'_>,\n+    right: &'tcx Expr<'_>,\n+) {\n+    if op == BinOpKind::Div\n+        && let ExprKind::MethodCall(method_path, [self_arg], _) = left.kind\n+        && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(self_arg).peel_refs(), sym::Duration)\n+        && let Some((Constant::Int(divisor), _)) = constant(cx, cx.typeck_results(), right)\n+    {\n+        let suggested_fn = match (method_path.ident.as_str(), divisor) {\n+            (\"subsec_micros\", 1_000) | (\"subsec_nanos\", 1_000_000) => \"subsec_millis\",\n+            (\"subsec_nanos\", 1_000) => \"subsec_micros\",\n+            _ => return,\n+        };\n+        let mut applicability = Applicability::MachineApplicable;\n+        span_lint_and_sugg(\n+            cx,\n+            DURATION_SUBSEC,\n+            expr.span,\n+            &format!(\"calling `{}()` is more concise than this calculation\", suggested_fn),\n+            \"try\",\n+            format!(\n+                \"{}.{}()\",\n+                snippet_with_applicability(cx, self_arg.span, \"_\", &mut applicability),\n+                suggested_fn\n+            ),\n+            applicability,\n+        );\n+    }\n+}"}, {"sha": "44cf0bb06120aba79134dba1ee969294fcdb1e58", "filename": "src/tools/clippy/clippy_lints/src/operators/eq_op.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Feq_op.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,45 @@\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::macros::{find_assert_eq_args, first_node_macro_backtrace};\n+use clippy_utils::{ast_utils::is_useless_with_eq_exprs, eq_expr_value, is_in_test_function};\n+use rustc_hir::{BinOpKind, Expr};\n+use rustc_lint::LateContext;\n+\n+use super::EQ_OP;\n+\n+pub(crate) fn check_assert<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n+    if let Some((macro_call, macro_name))\n+        = first_node_macro_backtrace(cx, e).find_map(|macro_call| {\n+            let name = cx.tcx.item_name(macro_call.def_id);\n+            matches!(name.as_str(), \"assert_eq\" | \"assert_ne\" | \"debug_assert_eq\" | \"debug_assert_ne\")\n+                .then(|| (macro_call, name))\n+        })\n+        && let Some((lhs, rhs, _)) = find_assert_eq_args(cx, e, macro_call.expn)\n+        && eq_expr_value(cx, lhs, rhs)\n+        && macro_call.is_local()\n+        && !is_in_test_function(cx.tcx, e.hir_id)\n+    {\n+        span_lint(\n+            cx,\n+            EQ_OP,\n+            lhs.span.to(rhs.span),\n+            &format!(\"identical args used in this `{}!` macro call\", macro_name),\n+        );\n+    }\n+}\n+\n+pub(crate) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    op: BinOpKind,\n+    left: &'tcx Expr<'_>,\n+    right: &'tcx Expr<'_>,\n+) {\n+    if is_useless_with_eq_exprs(op.into()) && eq_expr_value(cx, left, right) && !is_in_test_function(cx.tcx, e.hir_id) {\n+        span_lint(\n+            cx,\n+            EQ_OP,\n+            e.span,\n+            &format!(\"equal expressions as operands to `{}`\", op.as_str()),\n+        );\n+    }\n+}"}, {"sha": "066e08f3bd4cac6c34c672c0239262fd34536e36", "filename": "src/tools/clippy/clippy_lints/src/operators/erasing_op.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Ferasing_op.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,53 @@\n+use clippy_utils::consts::{constant_simple, Constant};\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::ty::same_type_and_consts;\n+\n+use rustc_hir::{BinOpKind, Expr};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::TypeckResults;\n+\n+use super::ERASING_OP;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    op: BinOpKind,\n+    left: &'tcx Expr<'_>,\n+    right: &'tcx Expr<'_>,\n+) {\n+    let tck = cx.typeck_results();\n+    match op {\n+        BinOpKind::Mul | BinOpKind::BitAnd => {\n+            check_op(cx, tck, left, right, e);\n+            check_op(cx, tck, right, left, e);\n+        },\n+        BinOpKind::Div => check_op(cx, tck, left, right, e),\n+        _ => (),\n+    }\n+}\n+\n+fn different_types(tck: &TypeckResults<'_>, input: &Expr<'_>, output: &Expr<'_>) -> bool {\n+    let input_ty = tck.expr_ty(input).peel_refs();\n+    let output_ty = tck.expr_ty(output).peel_refs();\n+    !same_type_and_consts(input_ty, output_ty)\n+}\n+\n+fn check_op<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    tck: &TypeckResults<'tcx>,\n+    op: &Expr<'tcx>,\n+    other: &Expr<'tcx>,\n+    parent: &Expr<'tcx>,\n+) {\n+    if constant_simple(cx, tck, op) == Some(Constant::Int(0)) {\n+        if different_types(tck, other, parent) {\n+            return;\n+        }\n+        span_lint(\n+            cx,\n+            ERASING_OP,\n+            parent.span,\n+            \"this operation will always return zero. This is likely not the intended outcome\",\n+        );\n+    }\n+}"}, {"sha": "0ef793443ff45ce618c7bfc2d32ae2363674c6d1", "filename": "src/tools/clippy/clippy_lints/src/operators/float_cmp.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Ffloat_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Ffloat_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Ffloat_cmp.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,139 @@\n+use clippy_utils::consts::{constant, Constant};\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::get_item_name;\n+use clippy_utils::sugg::Sugg;\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind, UnOp};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+\n+use super::{FLOAT_CMP, FLOAT_CMP_CONST};\n+\n+pub(crate) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    op: BinOpKind,\n+    left: &'tcx Expr<'_>,\n+    right: &'tcx Expr<'_>,\n+) {\n+    if (op == BinOpKind::Eq || op == BinOpKind::Ne) && (is_float(cx, left) || is_float(cx, right)) {\n+        if is_allowed(cx, left) || is_allowed(cx, right) {\n+            return;\n+        }\n+\n+        // Allow comparing the results of signum()\n+        if is_signum(cx, left) && is_signum(cx, right) {\n+            return;\n+        }\n+\n+        if let Some(name) = get_item_name(cx, expr) {\n+            let name = name.as_str();\n+            if name == \"eq\" || name == \"ne\" || name == \"is_nan\" || name.starts_with(\"eq_\") || name.ends_with(\"_eq\") {\n+                return;\n+            }\n+        }\n+        let is_comparing_arrays = is_array(cx, left) || is_array(cx, right);\n+        let (lint, msg) = get_lint_and_message(\n+            is_named_constant(cx, left) || is_named_constant(cx, right),\n+            is_comparing_arrays,\n+        );\n+        span_lint_and_then(cx, lint, expr.span, msg, |diag| {\n+            let lhs = Sugg::hir(cx, left, \"..\");\n+            let rhs = Sugg::hir(cx, right, \"..\");\n+\n+            if !is_comparing_arrays {\n+                diag.span_suggestion(\n+                    expr.span,\n+                    \"consider comparing them within some margin of error\",\n+                    format!(\n+                        \"({}).abs() {} error_margin\",\n+                        lhs - rhs,\n+                        if op == BinOpKind::Eq { '<' } else { '>' }\n+                    ),\n+                    Applicability::HasPlaceholders, // snippet\n+                );\n+            }\n+            diag.note(\"`f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\");\n+        });\n+    }\n+}\n+\n+fn get_lint_and_message(\n+    is_comparing_constants: bool,\n+    is_comparing_arrays: bool,\n+) -> (&'static rustc_lint::Lint, &'static str) {\n+    if is_comparing_constants {\n+        (\n+            FLOAT_CMP_CONST,\n+            if is_comparing_arrays {\n+                \"strict comparison of `f32` or `f64` constant arrays\"\n+            } else {\n+                \"strict comparison of `f32` or `f64` constant\"\n+            },\n+        )\n+    } else {\n+        (\n+            FLOAT_CMP,\n+            if is_comparing_arrays {\n+                \"strict comparison of `f32` or `f64` arrays\"\n+            } else {\n+                \"strict comparison of `f32` or `f64`\"\n+            },\n+        )\n+    }\n+}\n+\n+fn is_named_constant<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+    if let Some((_, res)) = constant(cx, cx.typeck_results(), expr) {\n+        res\n+    } else {\n+        false\n+    }\n+}\n+\n+fn is_allowed<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+    match constant(cx, cx.typeck_results(), expr) {\n+        Some((Constant::F32(f), _)) => f == 0.0 || f.is_infinite(),\n+        Some((Constant::F64(f), _)) => f == 0.0 || f.is_infinite(),\n+        Some((Constant::Vec(vec), _)) => vec.iter().all(|f| match f {\n+            Constant::F32(f) => *f == 0.0 || (*f).is_infinite(),\n+            Constant::F64(f) => *f == 0.0 || (*f).is_infinite(),\n+            _ => false,\n+        }),\n+        _ => false,\n+    }\n+}\n+\n+// Return true if `expr` is the result of `signum()` invoked on a float value.\n+fn is_signum(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    // The negation of a signum is still a signum\n+    if let ExprKind::Unary(UnOp::Neg, child_expr) = expr.kind {\n+        return is_signum(cx, child_expr);\n+    }\n+\n+    if_chain! {\n+        if let ExprKind::MethodCall(method_name, [ref self_arg, ..], _) = expr.kind;\n+        if sym!(signum) == method_name.ident.name;\n+        // Check that the receiver of the signum() is a float (expressions[0] is the receiver of\n+        // the method call)\n+        then {\n+            return is_float(cx, self_arg);\n+        }\n+    }\n+    false\n+}\n+\n+fn is_float(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    let value = &cx.typeck_results().expr_ty(expr).peel_refs().kind();\n+\n+    if let ty::Array(arr_ty, _) = value {\n+        return matches!(arr_ty.kind(), ty::Float(_));\n+    };\n+\n+    matches!(value, ty::Float(_))\n+}\n+\n+fn is_array(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    matches!(&cx.typeck_results().expr_ty(expr).peel_refs().kind(), ty::Array(_, _))\n+}"}, {"sha": "a0a8b6aabd9e37b0237aeed23a6c3cc278fa11ab", "filename": "src/tools/clippy/clippy_lints/src/operators/float_equality_without_abs.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Ffloat_equality_without_abs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Ffloat_equality_without_abs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Ffloat_equality_without_abs.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,71 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::{match_def_path, paths, sugg};\n+use if_chain::if_chain;\n+use rustc_ast::util::parser::AssocOp;\n+use rustc_errors::Applicability;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::source_map::Spanned;\n+\n+use super::FLOAT_EQUALITY_WITHOUT_ABS;\n+\n+pub(crate) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    op: BinOpKind,\n+    lhs: &'tcx Expr<'_>,\n+    rhs: &'tcx Expr<'_>,\n+) {\n+    let (lhs, rhs) = match op {\n+        BinOpKind::Lt => (lhs, rhs),\n+        BinOpKind::Gt => (rhs, lhs),\n+        _ => return,\n+    };\n+\n+    if_chain! {\n+        // left hand side is a subtraction\n+        if let ExprKind::Binary(\n+            Spanned {\n+                node: BinOpKind::Sub,\n+                ..\n+            },\n+            val_l,\n+            val_r,\n+        ) = lhs.kind;\n+\n+        // right hand side matches either f32::EPSILON or f64::EPSILON\n+        if let ExprKind::Path(ref epsilon_path) = rhs.kind;\n+        if let Res::Def(DefKind::AssocConst, def_id) = cx.qpath_res(epsilon_path, rhs.hir_id);\n+        if match_def_path(cx, def_id, &paths::F32_EPSILON) || match_def_path(cx, def_id, &paths::F64_EPSILON);\n+\n+        // values of the subtractions on the left hand side are of the type float\n+        let t_val_l = cx.typeck_results().expr_ty(val_l);\n+        let t_val_r = cx.typeck_results().expr_ty(val_r);\n+        if let ty::Float(_) = t_val_l.kind();\n+        if let ty::Float(_) = t_val_r.kind();\n+\n+        then {\n+            let sug_l = sugg::Sugg::hir(cx, val_l, \"..\");\n+            let sug_r = sugg::Sugg::hir(cx, val_r, \"..\");\n+            // format the suggestion\n+            let suggestion = format!(\"{}.abs()\", sugg::make_assoc(AssocOp::Subtract, &sug_l, &sug_r).maybe_par());\n+            // spans the lint\n+            span_lint_and_then(\n+                cx,\n+                FLOAT_EQUALITY_WITHOUT_ABS,\n+                expr.span,\n+                \"float equality check without `.abs()`\",\n+                | diag | {\n+                    diag.span_suggestion(\n+                        lhs.span,\n+                        \"add `.abs()`\",\n+                        suggestion,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+            );\n+        }\n+    }\n+}"}, {"sha": "b48d6c4e2e2af96318e38bdcb81ce5b2f3a548e9", "filename": "src/tools/clippy/clippy_lints/src/operators/identity_op.rs", "status": "renamed", "additions": 33, "deletions": 54, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fidentity_op.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -3,61 +3,40 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{clip, unsext};\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOp, BinOpKind, Expr, ExprKind, Node};\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_hir::{BinOpKind, Expr, ExprKind, Node};\n+use rustc_lint::LateContext;\n use rustc_middle::ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n \n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for identity operations, e.g., `x + 0`.\n-    ///\n-    /// ### Why is this bad?\n-    /// This code can be removed without changing the\n-    /// meaning. So it just obscures what's going on. Delete it mercilessly.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let x = 1;\n-    /// x / 1 + 0 * 1 - 0 | 0;\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub IDENTITY_OP,\n-    complexity,\n-    \"using identity operations, e.g., `x + 0` or `y / 1`\"\n-}\n-\n-declare_lint_pass!(IdentityOp => [IDENTITY_OP]);\n+use super::IDENTITY_OP;\n \n-impl<'tcx> LateLintPass<'tcx> for IdentityOp {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if expr.span.from_expansion() {\n-            return;\n-        }\n-        if let ExprKind::Binary(cmp, left, right) = &expr.kind {\n-            if !is_allowed(cx, *cmp, left, right) {\n-                match cmp.node {\n-                    BinOpKind::Add | BinOpKind::BitOr | BinOpKind::BitXor => {\n-                        check(cx, left, 0, expr.span, right.span, needs_parenthesis(cx, expr, right));\n-                        check(cx, right, 0, expr.span, left.span, Parens::Unneeded);\n-                    },\n-                    BinOpKind::Shl | BinOpKind::Shr | BinOpKind::Sub => {\n-                        check(cx, right, 0, expr.span, left.span, Parens::Unneeded);\n-                    },\n-                    BinOpKind::Mul => {\n-                        check(cx, left, 1, expr.span, right.span, needs_parenthesis(cx, expr, right));\n-                        check(cx, right, 1, expr.span, left.span, Parens::Unneeded);\n-                    },\n-                    BinOpKind::Div => check(cx, right, 1, expr.span, left.span, Parens::Unneeded),\n-                    BinOpKind::BitAnd => {\n-                        check(cx, left, -1, expr.span, right.span, needs_parenthesis(cx, expr, right));\n-                        check(cx, right, -1, expr.span, left.span, Parens::Unneeded);\n-                    },\n-                    BinOpKind::Rem => check_remainder(cx, left, right, expr.span, left.span),\n-                    _ => (),\n-                }\n-            }\n+pub(crate) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    op: BinOpKind,\n+    left: &'tcx Expr<'_>,\n+    right: &'tcx Expr<'_>,\n+) {\n+    if !is_allowed(cx, op, left, right) {\n+        match op {\n+            BinOpKind::Add | BinOpKind::BitOr | BinOpKind::BitXor => {\n+                check_op(cx, left, 0, expr.span, right.span, needs_parenthesis(cx, expr, right));\n+                check_op(cx, right, 0, expr.span, left.span, Parens::Unneeded);\n+            },\n+            BinOpKind::Shl | BinOpKind::Shr | BinOpKind::Sub => {\n+                check_op(cx, right, 0, expr.span, left.span, Parens::Unneeded);\n+            },\n+            BinOpKind::Mul => {\n+                check_op(cx, left, 1, expr.span, right.span, needs_parenthesis(cx, expr, right));\n+                check_op(cx, right, 1, expr.span, left.span, Parens::Unneeded);\n+            },\n+            BinOpKind::Div => check_op(cx, right, 1, expr.span, left.span, Parens::Unneeded),\n+            BinOpKind::BitAnd => {\n+                check_op(cx, left, -1, expr.span, right.span, needs_parenthesis(cx, expr, right));\n+                check_op(cx, right, -1, expr.span, left.span, Parens::Unneeded);\n+            },\n+            BinOpKind::Rem => check_remainder(cx, left, right, expr.span, left.span),\n+            _ => (),\n         }\n     }\n }\n@@ -108,12 +87,12 @@ fn needs_parenthesis(cx: &LateContext<'_>, binary: &Expr<'_>, right: &Expr<'_>)\n     Parens::Needed\n }\n \n-fn is_allowed(cx: &LateContext<'_>, cmp: BinOp, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n+fn is_allowed(cx: &LateContext<'_>, cmp: BinOpKind, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n     // This lint applies to integers\n     !cx.typeck_results().expr_ty(left).peel_refs().is_integral()\n         || !cx.typeck_results().expr_ty(right).peel_refs().is_integral()\n         // `1 << 0` is a common pattern in bit manipulation code\n-        || (cmp.node == BinOpKind::Shl\n+        || (cmp == BinOpKind::Shl\n             && constant_simple(cx, cx.typeck_results(), right) == Some(Constant::Int(0))\n             && constant_simple(cx, cx.typeck_results(), left) == Some(Constant::Int(1)))\n }\n@@ -130,7 +109,7 @@ fn check_remainder(cx: &LateContext<'_>, left: &Expr<'_>, right: &Expr<'_>, span\n     }\n }\n \n-fn check(cx: &LateContext<'_>, e: &Expr<'_>, m: i8, span: Span, arg: Span, parens: Parens) {\n+fn check_op(cx: &LateContext<'_>, e: &Expr<'_>, m: i8, span: Span, arg: Span, parens: Parens) {\n     if let Some(Constant::Int(v)) = constant_simple(cx, cx.typeck_results(), e).map(Constant::peel_refs) {\n         let check = match *cx.typeck_results().expr_ty(e).peel_refs().kind() {\n             ty::Int(ity) => unsext(cx.tcx, -1_i128, ity),", "previous_filename": "src/tools/clippy/clippy_lints/src/identity_op.rs"}, {"sha": "631d10f4a72e9b14710096f4508a7667e466682f", "filename": "src/tools/clippy/clippy_lints/src/operators/integer_division.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Finteger_division.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Finteger_division.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Finteger_division.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,27 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::INTEGER_DIVISION;\n+\n+pub(crate) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    op: hir::BinOpKind,\n+    left: &'tcx hir::Expr<'_>,\n+    right: &'tcx hir::Expr<'_>,\n+) {\n+    if op == hir::BinOpKind::Div\n+        && cx.typeck_results().expr_ty(left).is_integral()\n+        && cx.typeck_results().expr_ty(right).is_integral()\n+    {\n+        span_lint_and_help(\n+            cx,\n+            INTEGER_DIVISION,\n+            expr.span,\n+            \"integer division\",\n+            None,\n+            \"division of integers may cause loss of precision. consider using floats\",\n+        );\n+    }\n+}"}, {"sha": "0024384d9278daaaae0aba70a72c27013bad40de", "filename": "src/tools/clippy/clippy_lints/src/operators/misrefactored_assign_op.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fmisrefactored_assign_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fmisrefactored_assign_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fmisrefactored_assign_op.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,84 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::eq_expr_value;\n+use clippy_utils::source::snippet_opt;\n+use clippy_utils::sugg;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::MISREFACTORED_ASSIGN_OP;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    op: hir::BinOpKind,\n+    lhs: &'tcx hir::Expr<'_>,\n+    rhs: &'tcx hir::Expr<'_>,\n+) {\n+    if let hir::ExprKind::Binary(binop, l, r) = &rhs.kind {\n+        if op != binop.node {\n+            return;\n+        }\n+        // lhs op= l op r\n+        if eq_expr_value(cx, lhs, l) {\n+            lint_misrefactored_assign_op(cx, expr, op, rhs, lhs, r);\n+        }\n+        // lhs op= l commutative_op r\n+        if is_commutative(op) && eq_expr_value(cx, lhs, r) {\n+            lint_misrefactored_assign_op(cx, expr, op, rhs, lhs, l);\n+        }\n+    }\n+}\n+\n+fn lint_misrefactored_assign_op(\n+    cx: &LateContext<'_>,\n+    expr: &hir::Expr<'_>,\n+    op: hir::BinOpKind,\n+    rhs: &hir::Expr<'_>,\n+    assignee: &hir::Expr<'_>,\n+    rhs_other: &hir::Expr<'_>,\n+) {\n+    span_lint_and_then(\n+        cx,\n+        MISREFACTORED_ASSIGN_OP,\n+        expr.span,\n+        \"variable appears on both sides of an assignment operation\",\n+        |diag| {\n+            if let (Some(snip_a), Some(snip_r)) = (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs_other.span)) {\n+                let a = &sugg::Sugg::hir(cx, assignee, \"..\");\n+                let r = &sugg::Sugg::hir(cx, rhs, \"..\");\n+                let long = format!(\"{} = {}\", snip_a, sugg::make_binop(op.into(), a, r));\n+                diag.span_suggestion(\n+                    expr.span,\n+                    &format!(\n+                        \"did you mean `{} = {} {} {}` or `{}`? Consider replacing it with\",\n+                        snip_a,\n+                        snip_a,\n+                        op.as_str(),\n+                        snip_r,\n+                        long\n+                    ),\n+                    format!(\"{} {}= {}\", snip_a, op.as_str(), snip_r),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                diag.span_suggestion(\n+                    expr.span,\n+                    \"or\",\n+                    long,\n+                    Applicability::MaybeIncorrect, // snippet\n+                );\n+            }\n+        },\n+    );\n+}\n+\n+#[must_use]\n+fn is_commutative(op: hir::BinOpKind) -> bool {\n+    use rustc_hir::BinOpKind::{\n+        Add, And, BitAnd, BitOr, BitXor, Div, Eq, Ge, Gt, Le, Lt, Mul, Ne, Or, Rem, Shl, Shr, Sub,\n+    };\n+    match op {\n+        Add | Mul | And | Or | BitXor | BitAnd | BitOr | Eq | Ne => true,\n+        Sub | Div | Rem | Shl | Shr | Lt | Le | Ge | Gt => false,\n+    }\n+}"}, {"sha": "35fe405bcf14fa052fcb77949ce4f687b4d6ec13", "filename": "src/tools/clippy/clippy_lints/src/operators/mod.rs", "status": "added", "additions": 849, "deletions": 0, "changes": 849, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fmod.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,849 @@\n+use rustc_hir::{Body, Expr, ExprKind, UnOp};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+\n+mod absurd_extreme_comparisons;\n+mod assign_op_pattern;\n+mod bit_mask;\n+mod cmp_nan;\n+mod cmp_owned;\n+mod double_comparison;\n+mod duration_subsec;\n+mod eq_op;\n+mod erasing_op;\n+mod float_cmp;\n+mod float_equality_without_abs;\n+mod identity_op;\n+mod integer_division;\n+mod misrefactored_assign_op;\n+mod modulo_arithmetic;\n+mod modulo_one;\n+mod needless_bitwise_bool;\n+mod numeric_arithmetic;\n+mod op_ref;\n+mod ptr_eq;\n+mod self_assignment;\n+mod verbose_bit_mask;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for comparisons where one side of the relation is\n+    /// either the minimum or maximum value for its type and warns if it involves a\n+    /// case that is always true or always false. Only integer and boolean types are\n+    /// checked.\n+    ///\n+    /// ### Why is this bad?\n+    /// An expression like `min <= x` may misleadingly imply\n+    /// that it is possible for `x` to be less than the minimum. Expressions like\n+    /// `max < x` are probably mistakes.\n+    ///\n+    /// ### Known problems\n+    /// For `usize` the size of the current compile target will\n+    /// be assumed (e.g., 64 bits on 64 bit systems). This means code that uses such\n+    /// a comparison to detect target pointer width will trigger this lint. One can\n+    /// use `mem::sizeof` and compare its value or conditional compilation\n+    /// attributes\n+    /// like `#[cfg(target_pointer_width = \"64\")] ..` instead.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let vec: Vec<isize> = Vec::new();\n+    /// if vec.len() <= 0 {}\n+    /// if 100 > i32::MAX {}\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub ABSURD_EXTREME_COMPARISONS,\n+    correctness,\n+    \"a comparison with a maximum or minimum value that is always true or false\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for integer arithmetic operations which could overflow or panic.\n+    ///\n+    /// Specifically, checks for any operators (`+`, `-`, `*`, `<<`, etc) which are capable\n+    /// of overflowing according to the [Rust\n+    /// Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow),\n+    /// or which can panic (`/`, `%`). No bounds analysis or sophisticated reasoning is\n+    /// attempted.\n+    ///\n+    /// ### Why is this bad?\n+    /// Integer overflow will trigger a panic in debug builds or will wrap in\n+    /// release mode. Division by zero will cause a panic in either mode. In some applications one\n+    /// wants explicitly checked, wrapping or saturating arithmetic.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let a = 0;\n+    /// a + 1;\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub INTEGER_ARITHMETIC,\n+    restriction,\n+    \"any integer arithmetic expression which could overflow or panic\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for float arithmetic.\n+    ///\n+    /// ### Why is this bad?\n+    /// For some embedded systems or kernel development, it\n+    /// can be useful to rule out floating-point numbers.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let a = 0.0;\n+    /// a + 1.0;\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub FLOAT_ARITHMETIC,\n+    restriction,\n+    \"any floating-point arithmetic statement\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `a = a op b` or `a = b commutative_op a`\n+    /// patterns.\n+    ///\n+    /// ### Why is this bad?\n+    /// These can be written as the shorter `a op= b`.\n+    ///\n+    /// ### Known problems\n+    /// While forbidden by the spec, `OpAssign` traits may have\n+    /// implementations that differ from the regular `Op` impl.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let mut a = 5;\n+    /// let b = 0;\n+    /// // ...\n+    ///\n+    /// a = a + b;\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// let mut a = 5;\n+    /// let b = 0;\n+    /// // ...\n+    ///\n+    /// a += b;\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub ASSIGN_OP_PATTERN,\n+    style,\n+    \"assigning the result of an operation on a variable to that same variable\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `a op= a op b` or `a op= b op a` patterns.\n+    ///\n+    /// ### Why is this bad?\n+    /// Most likely these are bugs where one meant to write `a\n+    /// op= b`.\n+    ///\n+    /// ### Known problems\n+    /// Clippy cannot know for sure if `a op= a op b` should have\n+    /// been `a = a op a op b` or `a = a op b`/`a op= b`. Therefore, it suggests both.\n+    /// If `a op= a op b` is really the correct behavior it should be\n+    /// written as `a = a op a op b` as it's less confusing.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let mut a = 5;\n+    /// let b = 2;\n+    /// // ...\n+    /// a += a + b;\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MISREFACTORED_ASSIGN_OP,\n+    suspicious,\n+    \"having a variable on both sides of an assign op\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for incompatible bit masks in comparisons.\n+    ///\n+    /// The formula for detecting if an expression of the type `_ <bit_op> m\n+    /// <cmp_op> c` (where `<bit_op>` is one of {`&`, `|`} and `<cmp_op>` is one of\n+    /// {`!=`, `>=`, `>`, `!=`, `>=`, `>`}) can be determined from the following\n+    /// table:\n+    ///\n+    /// |Comparison  |Bit Op|Example      |is always|Formula               |\n+    /// |------------|------|-------------|---------|----------------------|\n+    /// |`==` or `!=`| `&`  |`x & 2 == 3` |`false`  |`c & m != c`          |\n+    /// |`<`  or `>=`| `&`  |`x & 2 < 3`  |`true`   |`m < c`               |\n+    /// |`>`  or `<=`| `&`  |`x & 1 > 1`  |`false`  |`m <= c`              |\n+    /// |`==` or `!=`| `\\|` |`x \\| 1 == 0`|`false`  |`c \\| m != c`         |\n+    /// |`<`  or `>=`| `\\|` |`x \\| 1 < 1` |`false`  |`m >= c`              |\n+    /// |`<=` or `>` | `\\|` |`x \\| 1 > 0` |`true`   |`m > c`               |\n+    ///\n+    /// ### Why is this bad?\n+    /// If the bits that the comparison cares about are always\n+    /// set to zero or one by the bit mask, the comparison is constant `true` or\n+    /// `false` (depending on mask, compared value, and operators).\n+    ///\n+    /// So the code is actively misleading, and the only reason someone would write\n+    /// this intentionally is to win an underhanded Rust contest or create a\n+    /// test-case for this lint.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let x = 1;\n+    /// if (x & 1 == 2) { }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub BAD_BIT_MASK,\n+    correctness,\n+    \"expressions of the form `_ & mask == select` that will only ever return `true` or `false`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for bit masks in comparisons which can be removed\n+    /// without changing the outcome. The basic structure can be seen in the\n+    /// following table:\n+    ///\n+    /// |Comparison| Bit Op   |Example     |equals |\n+    /// |----------|----------|------------|-------|\n+    /// |`>` / `<=`|`\\|` / `^`|`x \\| 2 > 3`|`x > 3`|\n+    /// |`<` / `>=`|`\\|` / `^`|`x ^ 1 < 4` |`x < 4`|\n+    ///\n+    /// ### Why is this bad?\n+    /// Not equally evil as [`bad_bit_mask`](#bad_bit_mask),\n+    /// but still a bit misleading, because the bit mask is ineffective.\n+    ///\n+    /// ### Known problems\n+    /// False negatives: This lint will only match instances\n+    /// where we have figured out the math (which is for a power-of-two compared\n+    /// value). This means things like `x | 1 >= 7` (which would be better written\n+    /// as `x >= 6`) will not be reported (but bit masks like this are fairly\n+    /// uncommon).\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let x = 1;\n+    /// if (x | 1 > 3) {  }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub INEFFECTIVE_BIT_MASK,\n+    correctness,\n+    \"expressions where a bit mask will be rendered useless by a comparison, e.g., `(x | 1) > 2`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for bit masks that can be replaced by a call\n+    /// to `trailing_zeros`\n+    ///\n+    /// ### Why is this bad?\n+    /// `x.trailing_zeros() > 4` is much clearer than `x & 15\n+    /// == 0`\n+    ///\n+    /// ### Known problems\n+    /// llvm generates better code for `x & 15 == 0` on x86\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let x = 1;\n+    /// if x & 0b1111 == 0 { }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub VERBOSE_BIT_MASK,\n+    pedantic,\n+    \"expressions where a bit mask is less readable than the corresponding method call\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for double comparisons that could be simplified to a single expression.\n+    ///\n+    ///\n+    /// ### Why is this bad?\n+    /// Readability.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let x = 1;\n+    /// # let y = 2;\n+    /// if x == y || x < y {}\n+    /// ```\n+    ///\n+    /// Use instead:\n+    ///\n+    /// ```rust\n+    /// # let x = 1;\n+    /// # let y = 2;\n+    /// if x <= y {}\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub DOUBLE_COMPARISONS,\n+    complexity,\n+    \"unnecessary double comparisons that can be simplified\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for calculation of subsecond microseconds or milliseconds\n+    /// from other `Duration` methods.\n+    ///\n+    /// ### Why is this bad?\n+    /// It's more concise to call `Duration::subsec_micros()` or\n+    /// `Duration::subsec_millis()` than to calculate them.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # use std::time::Duration;\n+    /// # let duration = Duration::new(5, 0);\n+    /// let micros = duration.subsec_nanos() / 1_000;\n+    /// let millis = duration.subsec_nanos() / 1_000_000;\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// # use std::time::Duration;\n+    /// # let duration = Duration::new(5, 0);\n+    /// let micros = duration.subsec_micros();\n+    /// let millis = duration.subsec_millis();\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub DURATION_SUBSEC,\n+    complexity,\n+    \"checks for calculation of subsecond microseconds or milliseconds\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for equal operands to comparison, logical and\n+    /// bitwise, difference and division binary operators (`==`, `>`, etc., `&&`,\n+    /// `||`, `&`, `|`, `^`, `-` and `/`).\n+    ///\n+    /// ### Why is this bad?\n+    /// This is usually just a typo or a copy and paste error.\n+    ///\n+    /// ### Known problems\n+    /// False negatives: We had some false positives regarding\n+    /// calls (notably [racer](https://github.com/phildawes/racer) had one instance\n+    /// of `x.pop() && x.pop()`), so we removed matching any function or method\n+    /// calls. We may introduce a list of known pure functions in the future.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let x = 1;\n+    /// if x + 1 == x + 1 {}\n+    ///\n+    /// // or\n+    ///\n+    /// # let a = 3;\n+    /// # let b = 4;\n+    /// assert_eq!(a, a);\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub EQ_OP,\n+    correctness,\n+    \"equal operands on both sides of a comparison or bitwise combination (e.g., `x == x`)\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for arguments to `==` which have their address\n+    /// taken to satisfy a bound\n+    /// and suggests to dereference the other argument instead\n+    ///\n+    /// ### Why is this bad?\n+    /// It is more idiomatic to dereference the other argument.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// &x == y\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// x == *y\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub OP_REF,\n+    style,\n+    \"taking a reference to satisfy the type constraints on `==`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for erasing operations, e.g., `x * 0`.\n+    ///\n+    /// ### Why is this bad?\n+    /// The whole expression can be replaced by zero.\n+    /// This is most likely not the intended outcome and should probably be\n+    /// corrected\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x = 1;\n+    /// 0 / x;\n+    /// 0 * x;\n+    /// x & 0;\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub ERASING_OP,\n+    correctness,\n+    \"using erasing operations, e.g., `x * 0` or `y & 0`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for statements of the form `(a - b) < f32::EPSILON` or\n+    /// `(a - b) < f64::EPSILON`. Notes the missing `.abs()`.\n+    ///\n+    /// ### Why is this bad?\n+    /// The code without `.abs()` is more likely to have a bug.\n+    ///\n+    /// ### Known problems\n+    /// If the user can ensure that b is larger than a, the `.abs()` is\n+    /// technically unnecessary. However, it will make the code more robust and doesn't have any\n+    /// large performance implications. If the abs call was deliberately left out for performance\n+    /// reasons, it is probably better to state this explicitly in the code, which then can be done\n+    /// with an allow.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// pub fn is_roughly_equal(a: f32, b: f32) -> bool {\n+    ///     (a - b) < f32::EPSILON\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// pub fn is_roughly_equal(a: f32, b: f32) -> bool {\n+    ///     (a - b).abs() < f32::EPSILON\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.48.0\"]\n+    pub FLOAT_EQUALITY_WITHOUT_ABS,\n+    suspicious,\n+    \"float equality check without `.abs()`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for identity operations, e.g., `x + 0`.\n+    ///\n+    /// ### Why is this bad?\n+    /// This code can be removed without changing the\n+    /// meaning. So it just obscures what's going on. Delete it mercilessly.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let x = 1;\n+    /// x / 1 + 0 * 1 - 0 | 0;\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub IDENTITY_OP,\n+    complexity,\n+    \"using identity operations, e.g., `x + 0` or `y / 1`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for division of integers\n+    ///\n+    /// ### Why is this bad?\n+    /// When outside of some very specific algorithms,\n+    /// integer division is very often a mistake because it discards the\n+    /// remainder.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x = 3 / 2;\n+    /// println!(\"{}\", x);\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// let x = 3f32 / 2f32;\n+    /// println!(\"{}\", x);\n+    /// ```\n+    #[clippy::version = \"1.37.0\"]\n+    pub INTEGER_DIVISION,\n+    restriction,\n+    \"integer division may cause loss of precision\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for comparisons to NaN.\n+    ///\n+    /// ### Why is this bad?\n+    /// NaN does not compare meaningfully to anything \u2013 not\n+    /// even itself \u2013 so those comparisons are simply wrong.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let x = 1.0;\n+    /// if x == f32::NAN { }\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// # let x = 1.0f32;\n+    /// if x.is_nan() { }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub CMP_NAN,\n+    correctness,\n+    \"comparisons to `NAN`, which will always return false, probably not intended\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for conversions to owned values just for the sake\n+    /// of a comparison.\n+    ///\n+    /// ### Why is this bad?\n+    /// The comparison can operate on a reference, so creating\n+    /// an owned value effectively throws it away directly afterwards, which is\n+    /// needlessly consuming code and heap space.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let x = \"foo\";\n+    /// # let y = String::from(\"foo\");\n+    /// if x.to_owned() == y {}\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// # let x = \"foo\";\n+    /// # let y = String::from(\"foo\");\n+    /// if x == y {}\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub CMP_OWNED,\n+    perf,\n+    \"creating owned instances for comparing with others, e.g., `x == \\\"foo\\\".to_string()`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for (in-)equality comparisons on floating-point\n+    /// values (apart from zero), except in functions called `*eq*` (which probably\n+    /// implement equality for a type involving floats).\n+    ///\n+    /// ### Why is this bad?\n+    /// Floating point calculations are usually imprecise, so\n+    /// asking if two values are *exactly* equal is asking for trouble. For a good\n+    /// guide on what to do, see [the floating point\n+    /// guide](http://www.floating-point-gui.de/errors/comparison).\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x = 1.2331f64;\n+    /// let y = 1.2332f64;\n+    ///\n+    /// if y == 1.23f64 { }\n+    /// if y != x {} // where both are floats\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// # let x = 1.2331f64;\n+    /// # let y = 1.2332f64;\n+    /// let error_margin = f64::EPSILON; // Use an epsilon for comparison\n+    /// // Or, if Rust <= 1.42, use `std::f64::EPSILON` constant instead.\n+    /// // let error_margin = std::f64::EPSILON;\n+    /// if (y - 1.23f64).abs() < error_margin { }\n+    /// if (y - x).abs() > error_margin { }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub FLOAT_CMP,\n+    pedantic,\n+    \"using `==` or `!=` on float values instead of comparing difference with an epsilon\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for (in-)equality comparisons on floating-point\n+    /// value and constant, except in functions called `*eq*` (which probably\n+    /// implement equality for a type involving floats).\n+    ///\n+    /// ### Why is this bad?\n+    /// Floating point calculations are usually imprecise, so\n+    /// asking if two values are *exactly* equal is asking for trouble. For a good\n+    /// guide on what to do, see [the floating point\n+    /// guide](http://www.floating-point-gui.de/errors/comparison).\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x: f64 = 1.0;\n+    /// const ONE: f64 = 1.00;\n+    ///\n+    /// if x == ONE { } // where both are floats\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// # let x: f64 = 1.0;\n+    /// # const ONE: f64 = 1.00;\n+    /// let error_margin = f64::EPSILON; // Use an epsilon for comparison\n+    /// // Or, if Rust <= 1.42, use `std::f64::EPSILON` constant instead.\n+    /// // let error_margin = std::f64::EPSILON;\n+    /// if (x - ONE).abs() < error_margin { }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub FLOAT_CMP_CONST,\n+    restriction,\n+    \"using `==` or `!=` on float constants instead of comparing difference with an epsilon\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for getting the remainder of a division by one or minus\n+    /// one.\n+    ///\n+    /// ### Why is this bad?\n+    /// The result for a divisor of one can only ever be zero; for\n+    /// minus one it can cause panic/overflow (if the left operand is the minimal value of\n+    /// the respective integer type) or results in zero. No one will write such code\n+    /// deliberately, unless trying to win an Underhanded Rust Contest. Even for that\n+    /// contest, it's probably a bad idea. Use something more underhanded.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let x = 1;\n+    /// let a = x % 1;\n+    /// let a = x % -1;\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MODULO_ONE,\n+    correctness,\n+    \"taking a number modulo +/-1, which can either panic/overflow or always returns 0\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for modulo arithmetic.\n+    ///\n+    /// ### Why is this bad?\n+    /// The results of modulo (%) operation might differ\n+    /// depending on the language, when negative numbers are involved.\n+    /// If you interop with different languages it might be beneficial\n+    /// to double check all places that use modulo arithmetic.\n+    ///\n+    /// For example, in Rust `17 % -3 = 2`, but in Python `17 % -3 = -1`.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x = -17 % 3;\n+    /// ```\n+    #[clippy::version = \"1.42.0\"]\n+    pub MODULO_ARITHMETIC,\n+    restriction,\n+    \"any modulo arithmetic statement\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for uses of bitwise and/or operators between booleans, where performance may be improved by using\n+    /// a lazy and.\n+    ///\n+    /// ### Why is this bad?\n+    /// The bitwise operators do not support short-circuiting, so it may hinder code performance.\n+    /// Additionally, boolean logic \"masked\" as bitwise logic is not caught by lints like `unnecessary_fold`\n+    ///\n+    /// ### Known problems\n+    /// This lint evaluates only when the right side is determined to have no side effects. At this time, that\n+    /// determination is quite conservative.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let (x,y) = (true, false);\n+    /// if x & !y {} // where both x and y are booleans\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let (x,y) = (true, false);\n+    /// if x && !y {}\n+    /// ```\n+    #[clippy::version = \"1.54.0\"]\n+    pub NEEDLESS_BITWISE_BOOL,\n+    pedantic,\n+    \"Boolean expressions that use bitwise rather than lazy operators\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Use `std::ptr::eq` when applicable\n+    ///\n+    /// ### Why is this bad?\n+    /// `ptr::eq` can be used to compare `&T` references\n+    /// (which coerce to `*const T` implicitly) by their address rather than\n+    /// comparing the values they point to.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let a = &[1, 2, 3];\n+    /// let b = &[1, 2, 3];\n+    ///\n+    /// assert!(a as *const _ as usize == b as *const _ as usize);\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let a = &[1, 2, 3];\n+    /// let b = &[1, 2, 3];\n+    ///\n+    /// assert!(std::ptr::eq(a, b));\n+    /// ```\n+    #[clippy::version = \"1.49.0\"]\n+    pub PTR_EQ,\n+    style,\n+    \"use `std::ptr::eq` when comparing raw pointers\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for explicit self-assignments.\n+    ///\n+    /// ### Why is this bad?\n+    /// Self-assignments are redundant and unlikely to be\n+    /// intentional.\n+    ///\n+    /// ### Known problems\n+    /// If expression contains any deref coercions or\n+    /// indexing operations they are assumed not to have any side effects.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// struct Event {\n+    ///     x: i32,\n+    /// }\n+    ///\n+    /// fn copy_position(a: &mut Event, b: &Event) {\n+    ///     a.x = a.x;\n+    /// }\n+    /// ```\n+    ///\n+    /// Should be:\n+    /// ```rust\n+    /// struct Event {\n+    ///     x: i32,\n+    /// }\n+    ///\n+    /// fn copy_position(a: &mut Event, b: &Event) {\n+    ///     a.x = b.x;\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.48.0\"]\n+    pub SELF_ASSIGNMENT,\n+    correctness,\n+    \"explicit self-assignment\"\n+}\n+\n+pub struct Operators {\n+    arithmetic_context: numeric_arithmetic::Context,\n+    verbose_bit_mask_threshold: u64,\n+}\n+impl_lint_pass!(Operators => [\n+    ABSURD_EXTREME_COMPARISONS,\n+    INTEGER_ARITHMETIC,\n+    FLOAT_ARITHMETIC,\n+    ASSIGN_OP_PATTERN,\n+    MISREFACTORED_ASSIGN_OP,\n+    BAD_BIT_MASK,\n+    INEFFECTIVE_BIT_MASK,\n+    VERBOSE_BIT_MASK,\n+    DOUBLE_COMPARISONS,\n+    DURATION_SUBSEC,\n+    EQ_OP,\n+    OP_REF,\n+    ERASING_OP,\n+    FLOAT_EQUALITY_WITHOUT_ABS,\n+    IDENTITY_OP,\n+    INTEGER_DIVISION,\n+    CMP_NAN,\n+    CMP_OWNED,\n+    FLOAT_CMP,\n+    FLOAT_CMP_CONST,\n+    MODULO_ONE,\n+    MODULO_ARITHMETIC,\n+    NEEDLESS_BITWISE_BOOL,\n+    PTR_EQ,\n+    SELF_ASSIGNMENT,\n+]);\n+impl Operators {\n+    pub fn new(verbose_bit_mask_threshold: u64) -> Self {\n+        Self {\n+            arithmetic_context: numeric_arithmetic::Context::default(),\n+            verbose_bit_mask_threshold,\n+        }\n+    }\n+}\n+impl<'tcx> LateLintPass<'tcx> for Operators {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n+        eq_op::check_assert(cx, e);\n+        match e.kind {\n+            ExprKind::Binary(op, lhs, rhs) => {\n+                if !e.span.from_expansion() {\n+                    absurd_extreme_comparisons::check(cx, e, op.node, lhs, rhs);\n+                    if !(macro_with_not_op(lhs) || macro_with_not_op(rhs)) {\n+                        eq_op::check(cx, e, op.node, lhs, rhs);\n+                        op_ref::check(cx, e, op.node, lhs, rhs);\n+                    }\n+                    erasing_op::check(cx, e, op.node, lhs, rhs);\n+                    identity_op::check(cx, e, op.node, lhs, rhs);\n+                    needless_bitwise_bool::check(cx, e, op.node, lhs, rhs);\n+                    ptr_eq::check(cx, e, op.node, lhs, rhs);\n+                }\n+                self.arithmetic_context.check_binary(cx, e, op.node, lhs, rhs);\n+                bit_mask::check(cx, e, op.node, lhs, rhs);\n+                verbose_bit_mask::check(cx, e, op.node, lhs, rhs, self.verbose_bit_mask_threshold);\n+                double_comparison::check(cx, op.node, lhs, rhs, e.span);\n+                duration_subsec::check(cx, e, op.node, lhs, rhs);\n+                float_equality_without_abs::check(cx, e, op.node, lhs, rhs);\n+                integer_division::check(cx, e, op.node, lhs, rhs);\n+                cmp_nan::check(cx, e, op.node, lhs, rhs);\n+                cmp_owned::check(cx, op.node, lhs, rhs);\n+                float_cmp::check(cx, e, op.node, lhs, rhs);\n+                modulo_one::check(cx, e, op.node, rhs);\n+                modulo_arithmetic::check(cx, e, op.node, lhs, rhs);\n+            },\n+            ExprKind::AssignOp(op, lhs, rhs) => {\n+                self.arithmetic_context.check_binary(cx, e, op.node, lhs, rhs);\n+                misrefactored_assign_op::check(cx, e, op.node, lhs, rhs);\n+                modulo_arithmetic::check(cx, e, op.node, lhs, rhs);\n+            },\n+            ExprKind::Assign(lhs, rhs, _) => {\n+                assign_op_pattern::check(cx, e, lhs, rhs);\n+                self_assignment::check(cx, e, lhs, rhs);\n+            },\n+            ExprKind::Unary(op, arg) => {\n+                if op == UnOp::Neg {\n+                    self.arithmetic_context.check_negate(cx, e, arg);\n+                }\n+            },\n+            _ => (),\n+        }\n+    }\n+\n+    fn check_expr_post(&mut self, _: &LateContext<'_>, e: &Expr<'_>) {\n+        self.arithmetic_context.expr_post(e.hir_id);\n+    }\n+\n+    fn check_body(&mut self, cx: &LateContext<'tcx>, b: &'tcx Body<'_>) {\n+        self.arithmetic_context.enter_body(cx, b);\n+    }\n+\n+    fn check_body_post(&mut self, cx: &LateContext<'tcx>, b: &'tcx Body<'_>) {\n+        self.arithmetic_context.body_post(cx, b);\n+    }\n+}\n+\n+fn macro_with_not_op(e: &Expr<'_>) -> bool {\n+    if let ExprKind::Unary(_, e) = e.kind {\n+        e.span.from_expansion()\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "af4e74947f41d60ceeaaeb6442852e08e8d36a1f", "filename": "src/tools/clippy/clippy_lints/src/operators/modulo_arithmetic.rs", "status": "renamed", "additions": 25, "deletions": 49, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fmodulo_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fmodulo_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fmodulo_arithmetic.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -2,35 +2,35 @@ use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::sext;\n use if_chain::if_chain;\n-use rustc_hir::{BinOpKind, Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_hir::{BinOpKind, Expr};\n+use rustc_lint::LateContext;\n use rustc_middle::ty::{self, Ty};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n use std::fmt::Display;\n \n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for modulo arithmetic.\n-    ///\n-    /// ### Why is this bad?\n-    /// The results of modulo (%) operation might differ\n-    /// depending on the language, when negative numbers are involved.\n-    /// If you interop with different languages it might be beneficial\n-    /// to double check all places that use modulo arithmetic.\n-    ///\n-    /// For example, in Rust `17 % -3 = 2`, but in Python `17 % -3 = -1`.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x = -17 % 3;\n-    /// ```\n-    #[clippy::version = \"1.42.0\"]\n-    pub MODULO_ARITHMETIC,\n-    restriction,\n-    \"any modulo arithmetic statement\"\n-}\n+use super::MODULO_ARITHMETIC;\n \n-declare_lint_pass!(ModuloArithmetic => [MODULO_ARITHMETIC]);\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    op: BinOpKind,\n+    lhs: &'tcx Expr<'_>,\n+    rhs: &'tcx Expr<'_>,\n+) {\n+    if op == BinOpKind::Rem {\n+        let lhs_operand = analyze_operand(lhs, cx, e);\n+        let rhs_operand = analyze_operand(rhs, cx, e);\n+        if_chain! {\n+            if let Some(lhs_operand) = lhs_operand;\n+            if let Some(rhs_operand) = rhs_operand;\n+            then {\n+                check_const_operands(cx, e, &lhs_operand, &rhs_operand);\n+            }\n+            else {\n+                check_non_const_operands(cx, e, lhs);\n+            }\n+        }\n+    };\n+}\n \n struct OperandInfo {\n     string_representation: Option<String>,\n@@ -124,27 +124,3 @@ fn check_non_const_operands<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>,\n         );\n     }\n }\n-\n-impl<'tcx> LateLintPass<'tcx> for ModuloArithmetic {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        match &expr.kind {\n-            ExprKind::Binary(op, lhs, rhs) | ExprKind::AssignOp(op, lhs, rhs) => {\n-                if op.node == BinOpKind::Rem {\n-                    let lhs_operand = analyze_operand(lhs, cx, expr);\n-                    let rhs_operand = analyze_operand(rhs, cx, expr);\n-                    if_chain! {\n-                        if let Some(lhs_operand) = lhs_operand;\n-                        if let Some(rhs_operand) = rhs_operand;\n-                        then {\n-                            check_const_operands(cx, expr, &lhs_operand, &rhs_operand);\n-                        }\n-                        else {\n-                            check_non_const_operands(cx, expr, lhs);\n-                        }\n-                    }\n-                };\n-            },\n-            _ => {},\n-        }\n-    }\n-}", "previous_filename": "src/tools/clippy/clippy_lints/src/modulo_arithmetic.rs"}, {"sha": "54eea14833ffe065c85c1584c516eeb39819afd9", "filename": "src/tools/clippy/clippy_lints/src/operators/modulo_one.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fmodulo_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fmodulo_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fmodulo_one.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,26 @@\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::{is_integer_const, unsext};\n+use rustc_hir::{BinOpKind, Expr};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+\n+use super::MODULO_ONE;\n+\n+pub(crate) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, op: BinOpKind, right: &Expr<'_>) {\n+    if op == BinOpKind::Rem {\n+        if is_integer_const(cx, right, 1) {\n+            span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n+        }\n+\n+        if let ty::Int(ity) = cx.typeck_results().expr_ty(right).kind() {\n+            if is_integer_const(cx, right, unsext(cx.tcx, -1, *ity)) {\n+                span_lint(\n+                    cx,\n+                    MODULO_ONE,\n+                    expr.span,\n+                    \"any number modulo -1 will panic/overflow or result in 0\",\n+                );\n+            }\n+        };\n+    }\n+}"}, {"sha": "e902235a014e865777976dd26029cf4d84ea7da3", "filename": "src/tools/clippy/clippy_lints/src/operators/needless_bitwise_bool.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fneedless_bitwise_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fneedless_bitwise_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fneedless_bitwise_bool.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,36 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::source::snippet_opt;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::LateContext;\n+\n+use super::NEEDLESS_BITWISE_BOOL;\n+\n+pub(super) fn check(cx: &LateContext<'_>, e: &Expr<'_>, op: BinOpKind, lhs: &Expr<'_>, rhs: &Expr<'_>) {\n+    let op_str = match op {\n+        BinOpKind::BitAnd => \"&&\",\n+        BinOpKind::BitOr => \"||\",\n+        _ => return,\n+    };\n+    if matches!(\n+        rhs.kind,\n+        ExprKind::Call(..) | ExprKind::MethodCall(..) | ExprKind::Binary(..) | ExprKind::Unary(..)\n+    ) && cx.typeck_results().expr_ty(e).is_bool()\n+        && !rhs.can_have_side_effects()\n+    {\n+        span_lint_and_then(\n+            cx,\n+            NEEDLESS_BITWISE_BOOL,\n+            e.span,\n+            \"use of bitwise operator instead of lazy operator between booleans\",\n+            |diag| {\n+                if let Some(lhs_snip) = snippet_opt(cx, lhs.span)\n+                    && let Some(rhs_snip) = snippet_opt(cx, rhs.span)\n+                {\n+                    let sugg = format!(\"{} {} {}\", lhs_snip, op_str, rhs_snip);\n+                    diag.span_suggestion(e.span, \"try\", sugg, Applicability::MachineApplicable);\n+                }\n+            },\n+        );\n+    }\n+}"}, {"sha": "82f454d02f713ad6bf90522c4ba779126294f5bc", "filename": "src/tools/clippy/clippy_lints/src/operators/numeric_arithmetic.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fnumeric_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fnumeric_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fnumeric_arithmetic.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,127 @@\n+use clippy_utils::consts::constant_simple;\n+use clippy_utils::diagnostics::span_lint;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::Span;\n+\n+use super::{FLOAT_ARITHMETIC, INTEGER_ARITHMETIC};\n+\n+#[derive(Default)]\n+pub struct Context {\n+    expr_id: Option<hir::HirId>,\n+    /// This field is used to check whether expressions are constants, such as in enum discriminants\n+    /// and consts\n+    const_span: Option<Span>,\n+}\n+impl Context {\n+    fn skip_expr(&mut self, e: &hir::Expr<'_>) -> bool {\n+        self.expr_id.is_some() || self.const_span.map_or(false, |span| span.contains(e.span))\n+    }\n+\n+    pub fn check_binary<'tcx>(\n+        &mut self,\n+        cx: &LateContext<'tcx>,\n+        expr: &'tcx hir::Expr<'_>,\n+        op: hir::BinOpKind,\n+        l: &'tcx hir::Expr<'_>,\n+        r: &'tcx hir::Expr<'_>,\n+    ) {\n+        if self.skip_expr(expr) {\n+            return;\n+        }\n+        match op {\n+            hir::BinOpKind::And\n+            | hir::BinOpKind::Or\n+            | hir::BinOpKind::BitAnd\n+            | hir::BinOpKind::BitOr\n+            | hir::BinOpKind::BitXor\n+            | hir::BinOpKind::Eq\n+            | hir::BinOpKind::Lt\n+            | hir::BinOpKind::Le\n+            | hir::BinOpKind::Ne\n+            | hir::BinOpKind::Ge\n+            | hir::BinOpKind::Gt => return,\n+            _ => (),\n+        }\n+\n+        let (l_ty, r_ty) = (cx.typeck_results().expr_ty(l), cx.typeck_results().expr_ty(r));\n+        if l_ty.peel_refs().is_integral() && r_ty.peel_refs().is_integral() {\n+            match op {\n+                hir::BinOpKind::Div | hir::BinOpKind::Rem => match &r.kind {\n+                    hir::ExprKind::Lit(_lit) => (),\n+                    hir::ExprKind::Unary(hir::UnOp::Neg, expr) => {\n+                        if let hir::ExprKind::Lit(lit) = &expr.kind {\n+                            if let rustc_ast::ast::LitKind::Int(1, _) = lit.node {\n+                                span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n+                                self.expr_id = Some(expr.hir_id);\n+                            }\n+                        }\n+                    },\n+                    _ => {\n+                        span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n+                        self.expr_id = Some(expr.hir_id);\n+                    },\n+                },\n+                _ => {\n+                    span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n+                    self.expr_id = Some(expr.hir_id);\n+                },\n+            }\n+        } else if r_ty.peel_refs().is_floating_point() && r_ty.peel_refs().is_floating_point() {\n+            span_lint(cx, FLOAT_ARITHMETIC, expr.span, \"floating-point arithmetic detected\");\n+            self.expr_id = Some(expr.hir_id);\n+        }\n+    }\n+\n+    pub fn check_negate<'tcx>(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, arg: &'tcx hir::Expr<'_>) {\n+        if self.skip_expr(expr) {\n+            return;\n+        }\n+        let ty = cx.typeck_results().expr_ty(arg);\n+        if constant_simple(cx, cx.typeck_results(), expr).is_none() {\n+            if ty.is_integral() {\n+                span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");\n+                self.expr_id = Some(expr.hir_id);\n+            } else if ty.is_floating_point() {\n+                span_lint(cx, FLOAT_ARITHMETIC, expr.span, \"floating-point arithmetic detected\");\n+                self.expr_id = Some(expr.hir_id);\n+            }\n+        }\n+    }\n+\n+    pub fn expr_post(&mut self, id: hir::HirId) {\n+        if Some(id) == self.expr_id {\n+            self.expr_id = None;\n+        }\n+    }\n+\n+    pub fn enter_body(&mut self, cx: &LateContext<'_>, body: &hir::Body<'_>) {\n+        let body_owner = cx.tcx.hir().body_owner_def_id(body.id());\n+\n+        match cx.tcx.hir().body_owner_kind(body_owner) {\n+            hir::BodyOwnerKind::Static(_) | hir::BodyOwnerKind::Const => {\n+                let body_span = cx.tcx.def_span(body_owner);\n+\n+                if let Some(span) = self.const_span {\n+                    if span.contains(body_span) {\n+                        return;\n+                    }\n+                }\n+                self.const_span = Some(body_span);\n+            },\n+            hir::BodyOwnerKind::Fn | hir::BodyOwnerKind::Closure => (),\n+        }\n+    }\n+\n+    pub fn body_post(&mut self, cx: &LateContext<'_>, body: &hir::Body<'_>) {\n+        let body_owner = cx.tcx.hir().body_owner(body.id());\n+        let body_span = cx.tcx.hir().span(body_owner);\n+\n+        if let Some(span) = self.const_span {\n+            if span.contains(body_span) {\n+                return;\n+            }\n+        }\n+        self.const_span = None;\n+    }\n+}"}, {"sha": "1805672e372544d8b34e64548fd7118a67e3c8b9", "filename": "src/tools/clippy/clippy_lints/src/operators/op_ref.rs", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fop_ref.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,218 @@\n+use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n+use clippy_utils::get_enclosing_block;\n+use clippy_utils::source::snippet;\n+use clippy_utils::ty::{implements_trait, is_copy};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{def::Res, def_id::DefId, BinOpKind, BorrowKind, Expr, ExprKind, GenericArg, ItemKind, QPath, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+use super::OP_REF;\n+\n+#[expect(clippy::similar_names, clippy::too_many_lines)]\n+pub(crate) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    op: BinOpKind,\n+    left: &'tcx Expr<'_>,\n+    right: &'tcx Expr<'_>,\n+) {\n+    let (trait_id, requires_ref) = match op {\n+        BinOpKind::Add => (cx.tcx.lang_items().add_trait(), false),\n+        BinOpKind::Sub => (cx.tcx.lang_items().sub_trait(), false),\n+        BinOpKind::Mul => (cx.tcx.lang_items().mul_trait(), false),\n+        BinOpKind::Div => (cx.tcx.lang_items().div_trait(), false),\n+        BinOpKind::Rem => (cx.tcx.lang_items().rem_trait(), false),\n+        // don't lint short circuiting ops\n+        BinOpKind::And | BinOpKind::Or => return,\n+        BinOpKind::BitXor => (cx.tcx.lang_items().bitxor_trait(), false),\n+        BinOpKind::BitAnd => (cx.tcx.lang_items().bitand_trait(), false),\n+        BinOpKind::BitOr => (cx.tcx.lang_items().bitor_trait(), false),\n+        BinOpKind::Shl => (cx.tcx.lang_items().shl_trait(), false),\n+        BinOpKind::Shr => (cx.tcx.lang_items().shr_trait(), false),\n+        BinOpKind::Ne | BinOpKind::Eq => (cx.tcx.lang_items().eq_trait(), true),\n+        BinOpKind::Lt | BinOpKind::Le | BinOpKind::Ge | BinOpKind::Gt => {\n+            (cx.tcx.lang_items().partial_ord_trait(), true)\n+        },\n+    };\n+    if let Some(trait_id) = trait_id {\n+        match (&left.kind, &right.kind) {\n+            // do not suggest to dereference literals\n+            (&ExprKind::Lit(..), _) | (_, &ExprKind::Lit(..)) => {},\n+            // &foo == &bar\n+            (&ExprKind::AddrOf(BorrowKind::Ref, _, l), &ExprKind::AddrOf(BorrowKind::Ref, _, r)) => {\n+                let lty = cx.typeck_results().expr_ty(l);\n+                let rty = cx.typeck_results().expr_ty(r);\n+                let lcpy = is_copy(cx, lty);\n+                let rcpy = is_copy(cx, rty);\n+                if let Some((self_ty, other_ty)) = in_impl(cx, e, trait_id) {\n+                    if (are_equal(cx, rty, self_ty) && are_equal(cx, lty, other_ty))\n+                        || (are_equal(cx, rty, other_ty) && are_equal(cx, lty, self_ty))\n+                    {\n+                        return; // Don't lint\n+                    }\n+                }\n+                // either operator autorefs or both args are copyable\n+                if (requires_ref || (lcpy && rcpy)) && implements_trait(cx, lty, trait_id, &[rty.into()]) {\n+                    span_lint_and_then(\n+                        cx,\n+                        OP_REF,\n+                        e.span,\n+                        \"needlessly taken reference of both operands\",\n+                        |diag| {\n+                            let lsnip = snippet(cx, l.span, \"...\").to_string();\n+                            let rsnip = snippet(cx, r.span, \"...\").to_string();\n+                            multispan_sugg(\n+                                diag,\n+                                \"use the values directly\",\n+                                vec![(left.span, lsnip), (right.span, rsnip)],\n+                            );\n+                        },\n+                    );\n+                } else if lcpy\n+                    && !rcpy\n+                    && implements_trait(cx, lty, trait_id, &[cx.typeck_results().expr_ty(right).into()])\n+                {\n+                    span_lint_and_then(\n+                        cx,\n+                        OP_REF,\n+                        e.span,\n+                        \"needlessly taken reference of left operand\",\n+                        |diag| {\n+                            let lsnip = snippet(cx, l.span, \"...\").to_string();\n+                            diag.span_suggestion(\n+                                left.span,\n+                                \"use the left value directly\",\n+                                lsnip,\n+                                Applicability::MaybeIncorrect, // FIXME #2597\n+                            );\n+                        },\n+                    );\n+                } else if !lcpy\n+                    && rcpy\n+                    && implements_trait(cx, cx.typeck_results().expr_ty(left), trait_id, &[rty.into()])\n+                {\n+                    span_lint_and_then(\n+                        cx,\n+                        OP_REF,\n+                        e.span,\n+                        \"needlessly taken reference of right operand\",\n+                        |diag| {\n+                            let rsnip = snippet(cx, r.span, \"...\").to_string();\n+                            diag.span_suggestion(\n+                                right.span,\n+                                \"use the right value directly\",\n+                                rsnip,\n+                                Applicability::MaybeIncorrect, // FIXME #2597\n+                            );\n+                        },\n+                    );\n+                }\n+            },\n+            // &foo == bar\n+            (&ExprKind::AddrOf(BorrowKind::Ref, _, l), _) => {\n+                let lty = cx.typeck_results().expr_ty(l);\n+                if let Some((self_ty, other_ty)) = in_impl(cx, e, trait_id) {\n+                    let rty = cx.typeck_results().expr_ty(right);\n+                    if (are_equal(cx, rty, self_ty) && are_equal(cx, lty, other_ty))\n+                        || (are_equal(cx, rty, other_ty) && are_equal(cx, lty, self_ty))\n+                    {\n+                        return; // Don't lint\n+                    }\n+                }\n+                let lcpy = is_copy(cx, lty);\n+                if (requires_ref || lcpy)\n+                    && implements_trait(cx, lty, trait_id, &[cx.typeck_results().expr_ty(right).into()])\n+                {\n+                    span_lint_and_then(\n+                        cx,\n+                        OP_REF,\n+                        e.span,\n+                        \"needlessly taken reference of left operand\",\n+                        |diag| {\n+                            let lsnip = snippet(cx, l.span, \"...\").to_string();\n+                            diag.span_suggestion(\n+                                left.span,\n+                                \"use the left value directly\",\n+                                lsnip,\n+                                Applicability::MaybeIncorrect, // FIXME #2597\n+                            );\n+                        },\n+                    );\n+                }\n+            },\n+            // foo == &bar\n+            (_, &ExprKind::AddrOf(BorrowKind::Ref, _, r)) => {\n+                let rty = cx.typeck_results().expr_ty(r);\n+                if let Some((self_ty, other_ty)) = in_impl(cx, e, trait_id) {\n+                    let lty = cx.typeck_results().expr_ty(left);\n+                    if (are_equal(cx, rty, self_ty) && are_equal(cx, lty, other_ty))\n+                        || (are_equal(cx, rty, other_ty) && are_equal(cx, lty, self_ty))\n+                    {\n+                        return; // Don't lint\n+                    }\n+                }\n+                let rcpy = is_copy(cx, rty);\n+                if (requires_ref || rcpy)\n+                    && implements_trait(cx, cx.typeck_results().expr_ty(left), trait_id, &[rty.into()])\n+                {\n+                    span_lint_and_then(cx, OP_REF, e.span, \"taken reference of right operand\", |diag| {\n+                        let rsnip = snippet(cx, r.span, \"...\").to_string();\n+                        diag.span_suggestion(\n+                            right.span,\n+                            \"use the right value directly\",\n+                            rsnip,\n+                            Applicability::MaybeIncorrect, // FIXME #2597\n+                        );\n+                    });\n+                }\n+            },\n+            _ => {},\n+        }\n+    }\n+}\n+\n+fn in_impl<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    bin_op: DefId,\n+) -> Option<(&'tcx rustc_hir::Ty<'tcx>, &'tcx rustc_hir::Ty<'tcx>)> {\n+    if_chain! {\n+        if let Some(block) = get_enclosing_block(cx, e.hir_id);\n+        if let Some(impl_def_id) = cx.tcx.impl_of_method(block.hir_id.owner.to_def_id());\n+        let item = cx.tcx.hir().expect_item(impl_def_id.expect_local());\n+        if let ItemKind::Impl(item) = &item.kind;\n+        if let Some(of_trait) = &item.of_trait;\n+        if let Some(seg) = of_trait.path.segments.last();\n+        if let Some(Res::Def(_, trait_id)) = seg.res;\n+        if trait_id == bin_op;\n+        if let Some(generic_args) = seg.args;\n+        if let Some(GenericArg::Type(other_ty)) = generic_args.args.last();\n+\n+        then {\n+            Some((item.self_ty, other_ty))\n+        }\n+        else {\n+            None\n+        }\n+    }\n+}\n+\n+fn are_equal<'tcx>(cx: &LateContext<'tcx>, middle_ty: Ty<'_>, hir_ty: &rustc_hir::Ty<'_>) -> bool {\n+    if_chain! {\n+        if let ty::Adt(adt_def, _) = middle_ty.kind();\n+        if let Some(local_did) = adt_def.did().as_local();\n+        let item = cx.tcx.hir().expect_item(local_did);\n+        let middle_ty_id = item.def_id.to_def_id();\n+        if let TyKind::Path(QPath::Resolved(_, path)) = hir_ty.kind;\n+        if let Res::Def(_, hir_ty_id) = path.res;\n+\n+        then {\n+            hir_ty_id == middle_ty_id\n+        }\n+        else {\n+            false\n+        }\n+    }\n+}"}, {"sha": "1aefc2741c21ca345c8376675a7dc9d9db1ba4c6", "filename": "src/tools/clippy/clippy_lints/src/operators/ptr_eq.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fptr_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fptr_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fptr_eq.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,65 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_opt;\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::LateContext;\n+\n+use super::PTR_EQ;\n+\n+static LINT_MSG: &str = \"use `std::ptr::eq` when comparing raw pointers\";\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    op: BinOpKind,\n+    left: &'tcx Expr<'_>,\n+    right: &'tcx Expr<'_>,\n+) {\n+    if BinOpKind::Eq == op {\n+        let (left, right) = match (expr_as_cast_to_usize(cx, left), expr_as_cast_to_usize(cx, right)) {\n+            (Some(lhs), Some(rhs)) => (lhs, rhs),\n+            _ => (left, right),\n+        };\n+\n+        if_chain! {\n+            if let Some(left_var) = expr_as_cast_to_raw_pointer(cx, left);\n+            if let Some(right_var) = expr_as_cast_to_raw_pointer(cx, right);\n+            if let Some(left_snip) = snippet_opt(cx, left_var.span);\n+            if let Some(right_snip) = snippet_opt(cx, right_var.span);\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    PTR_EQ,\n+                    expr.span,\n+                    LINT_MSG,\n+                    \"try\",\n+                    format!(\"std::ptr::eq({}, {})\", left_snip, right_snip),\n+                    Applicability::MachineApplicable,\n+                    );\n+            }\n+        }\n+    }\n+}\n+\n+// If the given expression is a cast to a usize, return the lhs of the cast\n+// E.g., `foo as *const _ as usize` returns `foo as *const _`.\n+fn expr_as_cast_to_usize<'tcx>(cx: &LateContext<'tcx>, cast_expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    if cx.typeck_results().expr_ty(cast_expr) == cx.tcx.types.usize {\n+        if let ExprKind::Cast(expr, _) = cast_expr.kind {\n+            return Some(expr);\n+        }\n+    }\n+    None\n+}\n+\n+// If the given expression is a cast to a `*const` pointer, return the lhs of the cast\n+// E.g., `foo as *const _` returns `foo`.\n+fn expr_as_cast_to_raw_pointer<'tcx>(cx: &LateContext<'tcx>, cast_expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    if cx.typeck_results().expr_ty(cast_expr).is_unsafe_ptr() {\n+        if let ExprKind::Cast(expr, _) = cast_expr.kind {\n+            return Some(expr);\n+        }\n+    }\n+    None\n+}"}, {"sha": "9d6bec05bf095d15327032512d2b2f8d2bb11666", "filename": "src/tools/clippy/clippy_lints/src/operators/self_assignment.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fself_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fself_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fself_assignment.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,20 @@\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::eq_expr_value;\n+use clippy_utils::source::snippet;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+\n+use super::SELF_ASSIGNMENT;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, lhs: &'tcx Expr<'_>, rhs: &'tcx Expr<'_>) {\n+    if eq_expr_value(cx, lhs, rhs) {\n+        let lhs = snippet(cx, lhs.span, \"<lhs>\");\n+        let rhs = snippet(cx, rhs.span, \"<rhs>\");\n+        span_lint(\n+            cx,\n+            SELF_ASSIGNMENT,\n+            e.span,\n+            &format!(\"self-assignment of `{}` to `{}`\", rhs, lhs),\n+        );\n+    }\n+}"}, {"sha": "ff85fd554298822f768df19441cafa4b959f00c9", "filename": "src/tools/clippy/clippy_lints/src/operators/verbose_bit_mask.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fverbose_bit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fverbose_bit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fverbose_bit_mask.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,44 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::sugg::Sugg;\n+use rustc_ast::ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::LateContext;\n+\n+use super::VERBOSE_BIT_MASK;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    op: BinOpKind,\n+    left: &'tcx Expr<'_>,\n+    right: &'tcx Expr<'_>,\n+    threshold: u64,\n+) {\n+    if BinOpKind::Eq == op\n+        && let ExprKind::Binary(op1, left1, right1) = &left.kind\n+        && BinOpKind::BitAnd == op1.node\n+        && let ExprKind::Lit(lit) = &right1.kind\n+        && let LitKind::Int(n, _) = lit.node\n+        && let ExprKind::Lit(lit1) = &right.kind\n+        && let LitKind::Int(0, _) = lit1.node\n+        && n.leading_zeros() == n.count_zeros()\n+        && n > u128::from(threshold)\n+    {\n+        span_lint_and_then(\n+            cx,\n+            VERBOSE_BIT_MASK,\n+            e.span,\n+            \"bit mask could be simplified with a call to `trailing_zeros`\",\n+            |diag| {\n+                let sugg = Sugg::hir(cx, left1, \"...\").maybe_par();\n+                diag.span_suggestion(\n+                    e.span,\n+                    \"try\",\n+                    format!(\"{}.trailing_zeros() >= {}\", sugg, n.count_ones()),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            },\n+        );\n+    }\n+}"}, {"sha": "5fa4fd74853f1d09ee164aa0846dbbe424190b6b", "filename": "src/tools/clippy/clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 67, "deletions": 37, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -3,17 +3,20 @@ use std::iter;\n \n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n-use clippy_utils::ty::is_copy;\n+use clippy_utils::ty::{for_each_top_level_late_bound_region, is_copy};\n use clippy_utils::{is_self, is_self_ty};\n+use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_ast::attr;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{BindingAnnotation, Body, FnDecl, HirId, Impl, ItemKind, MutTy, Mutability, Node, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n+use rustc_middle::ty::adjustment::{Adjust, PointerCast};\n use rustc_middle::ty::layout::LayoutOf;\n+use rustc_middle::ty::{self, RegionKind};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::{sym, Span};\n@@ -141,50 +144,76 @@ impl<'tcx> PassByRefOrValue {\n         }\n \n         let fn_sig = cx.tcx.fn_sig(def_id);\n-        let fn_sig = cx.tcx.erase_late_bound_regions(fn_sig);\n-\n         let fn_body = cx.enclosing_body.map(|id| cx.tcx.hir().body(id));\n \n-        for (index, (input, &ty)) in iter::zip(decl.inputs, fn_sig.inputs()).enumerate() {\n+        // Gather all the lifetimes found in the output type which may affect whether\n+        // `TRIVIALLY_COPY_PASS_BY_REF` should be linted.\n+        let mut output_regions = FxHashSet::default();\n+        for_each_top_level_late_bound_region(fn_sig.skip_binder().output(), |region| -> ControlFlow<!> {\n+            output_regions.insert(region);\n+            ControlFlow::Continue(())\n+        });\n+\n+        for (index, (input, ty)) in iter::zip(\n+            decl.inputs,\n+            fn_sig.skip_binder().inputs().iter().map(|&ty| fn_sig.rebind(ty)),\n+        )\n+        .enumerate()\n+        {\n             // All spans generated from a proc-macro invocation are the same...\n             match span {\n-                Some(s) if s == input.span => return,\n+                Some(s) if s == input.span => continue,\n                 _ => (),\n             }\n \n-            match ty.kind() {\n-                ty::Ref(input_lt, ty, Mutability::Not) => {\n-                    // Use lifetimes to determine if we're returning a reference to the\n-                    // argument. In that case we can't switch to pass-by-value as the\n-                    // argument will not live long enough.\n-                    let output_lts = match *fn_sig.output().kind() {\n-                        ty::Ref(output_lt, _, _) => vec![output_lt],\n-                        ty::Adt(_, substs) => substs.regions().collect(),\n-                        _ => vec![],\n-                    };\n+            match *ty.skip_binder().kind() {\n+                ty::Ref(lt, ty, Mutability::Not) => {\n+                    match lt.kind() {\n+                        RegionKind::ReLateBound(index, region)\n+                            if index.as_u32() == 0 && output_regions.contains(&region) =>\n+                        {\n+                            continue;\n+                        },\n+                        // Early bound regions on functions are either from the containing item, are bounded by another\n+                        // lifetime, or are used as a bound for a type or lifetime.\n+                        RegionKind::ReEarlyBound(..) => continue,\n+                        _ => (),\n+                    }\n \n-                    if_chain! {\n-                        if !output_lts.contains(input_lt);\n-                        if is_copy(cx, *ty);\n-                        if let Some(size) = cx.layout_of(*ty).ok().map(|l| l.size.bytes());\n-                        if size <= self.ref_min_size;\n-                        if let hir::TyKind::Rptr(_, MutTy { ty: decl_ty, .. }) = input.kind;\n-                        then {\n-                            let value_type = if fn_body.and_then(|body| body.params.get(index)).map_or(false, is_self) {\n-                                \"self\".into()\n-                            } else {\n-                                snippet(cx, decl_ty.span, \"_\").into()\n-                            };\n-                            span_lint_and_sugg(\n-                                cx,\n-                                TRIVIALLY_COPY_PASS_BY_REF,\n-                                input.span,\n-                                &format!(\"this argument ({} byte) is passed by reference, but would be more efficient if passed by value (limit: {} byte)\", size, self.ref_min_size),\n-                                \"consider passing by value instead\",\n-                                value_type,\n-                                Applicability::Unspecified,\n-                            );\n+                    let ty = cx.tcx.erase_late_bound_regions(fn_sig.rebind(ty));\n+                    if is_copy(cx, ty)\n+                        && let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes())\n+                        && size <= self.ref_min_size\n+                        && let hir::TyKind::Rptr(_, MutTy { ty: decl_ty, .. }) = input.kind\n+                    {\n+                        if let Some(typeck) = cx.maybe_typeck_results() {\n+                            // Don't lint if an unsafe pointer is created.\n+                            // TODO: Limit the check only to unsafe pointers to the argument (or part of the argument)\n+                            //       which escape the current function.\n+                            if typeck.node_types().iter().any(|(_, &ty)| ty.is_unsafe_ptr())\n+                                || typeck\n+                                    .adjustments()\n+                                    .iter()\n+                                    .flat_map(|(_, a)| a)\n+                                    .any(|a| matches!(a.kind, Adjust::Pointer(PointerCast::UnsafeFnPointer)))\n+                            {\n+                                continue;\n+                            }\n                         }\n+                        let value_type = if fn_body.and_then(|body| body.params.get(index)).map_or(false, is_self) {\n+                            \"self\".into()\n+                        } else {\n+                            snippet(cx, decl_ty.span, \"_\").into()\n+                        };\n+                        span_lint_and_sugg(\n+                            cx,\n+                            TRIVIALLY_COPY_PASS_BY_REF,\n+                            input.span,\n+                            &format!(\"this argument ({} byte) is passed by reference, but would be more efficient if passed by value (limit: {} byte)\", size, self.ref_min_size),\n+                            \"consider passing by value instead\",\n+                            value_type,\n+                            Applicability::Unspecified,\n+                        );\n                     }\n                 },\n \n@@ -196,6 +225,7 @@ impl<'tcx> PassByRefOrValue {\n                             _ => continue,\n                         }\n                     }\n+                    let ty = cx.tcx.erase_late_bound_regions(ty);\n \n                     if_chain! {\n                         if is_copy(cx, ty);"}, {"sha": "25b73918c0a259de0c56324a028ea7e58d588e35", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,6 +1,6 @@\n //! Checks for usage of  `&Vec[_]` and `&String`.\n \n-use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_and_then};\n+use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_and_then, span_lint_hir_and_then};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::expr_sig;\n use clippy_utils::visitors::contains_unsafe_block;\n@@ -166,15 +166,14 @@ impl<'tcx> LateLintPass<'tcx> for Ptr {\n             )\n             .filter(|arg| arg.mutability() == Mutability::Not)\n             {\n-                span_lint_and_sugg(\n-                    cx,\n-                    PTR_ARG,\n-                    arg.span,\n-                    &arg.build_msg(),\n-                    \"change this to\",\n-                    format!(\"{}{}\", arg.ref_prefix, arg.deref_ty.display(cx)),\n-                    Applicability::Unspecified,\n-                );\n+                span_lint_hir_and_then(cx, PTR_ARG, arg.emission_id, arg.span, &arg.build_msg(), |diag| {\n+                    diag.span_suggestion(\n+                        arg.span,\n+                        \"change this to\",\n+                        format!(\"{}{}\", arg.ref_prefix, arg.deref_ty.display(cx)),\n+                        Applicability::Unspecified,\n+                    );\n+                });\n             }\n         }\n     }\n@@ -221,7 +220,7 @@ impl<'tcx> LateLintPass<'tcx> for Ptr {\n         let results = check_ptr_arg_usage(cx, body, &lint_args);\n \n         for (result, args) in results.iter().zip(lint_args.iter()).filter(|(r, _)| !r.skip) {\n-            span_lint_and_then(cx, PTR_ARG, args.span, &args.build_msg(), |diag| {\n+            span_lint_hir_and_then(cx, PTR_ARG, args.emission_id, args.span, &args.build_msg(), |diag| {\n                 diag.multipart_suggestion(\n                     \"change this to\",\n                     iter::once((args.span, format!(\"{}{}\", args.ref_prefix, args.deref_ty.display(cx))))\n@@ -315,6 +314,7 @@ struct PtrArgReplacement {\n \n struct PtrArg<'tcx> {\n     idx: usize,\n+    emission_id: hir::HirId,\n     span: Span,\n     ty_did: DefId,\n     ty_name: Symbol,\n@@ -419,10 +419,8 @@ fn check_fn_args<'cx, 'tcx: 'cx>(\n                 if let [.., name] = path.segments;\n                 if cx.tcx.item_name(adt.did()) == name.ident.name;\n \n-                if !is_lint_allowed(cx, PTR_ARG, hir_ty.hir_id);\n-                if params.get(i).map_or(true, |p| !is_lint_allowed(cx, PTR_ARG, p.hir_id));\n-\n                 then {\n+                    let emission_id = params.get(i).map_or(hir_ty.hir_id, |param| param.hir_id);\n                     let (method_renames, deref_ty) = match cx.tcx.get_diagnostic_name(adt.did()) {\n                         Some(sym::Vec) => (\n                             [(\"clone\", \".to_owned()\")].as_slice(),\n@@ -455,21 +453,28 @@ fn check_fn_args<'cx, 'tcx: 'cx>(\n                                 })\n                                 .and_then(|arg| snippet_opt(cx, arg.span))\n                                 .unwrap_or_else(|| substs.type_at(1).to_string());\n-                            span_lint_and_sugg(\n+                            span_lint_hir_and_then(\n                                 cx,\n                                 PTR_ARG,\n+                                emission_id,\n                                 hir_ty.span,\n                                 \"using a reference to `Cow` is not recommended\",\n-                                \"change this to\",\n-                                format!(\"&{}{}\", mutability.prefix_str(), ty_name),\n-                                Applicability::Unspecified,\n+                                |diag| {\n+                                    diag.span_suggestion(\n+                                        hir_ty.span,\n+                                        \"change this to\",\n+                                        format!(\"&{}{}\", mutability.prefix_str(), ty_name),\n+                                        Applicability::Unspecified,\n+                                    );\n+                                }\n                             );\n                             return None;\n                         },\n                         _ => return None,\n                     };\n                     return Some(PtrArg {\n                         idx: i,\n+                        emission_id,\n                         span: hir_ty.span,\n                         ty_did: adt.did(),\n                         ty_name: name.ident.name,\n@@ -574,14 +579,13 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n                 Some((Node::Expr(e), child_id)) => match e.kind {\n                     ExprKind::Call(f, expr_args) => {\n                         let i = expr_args.iter().position(|arg| arg.hir_id == child_id).unwrap_or(0);\n-                        if expr_sig(self.cx, f)\n-                            .map(|sig| sig.input(i).skip_binder().peel_refs())\n-                            .map_or(true, |ty| match *ty.kind() {\n+                        if expr_sig(self.cx, f).and_then(|sig| sig.input(i)).map_or(true, |ty| {\n+                            match *ty.skip_binder().peel_refs().kind() {\n                                 ty::Param(_) => true,\n                                 ty::Adt(def, _) => def.did() == args.ty_did,\n                                 _ => false,\n-                            })\n-                        {\n+                            }\n+                        }) {\n                             // Passed to a function taking the non-dereferenced type.\n                             set_skip_flag();\n                         }"}, {"sha": "2bec93ac606057e22c483777f9a9a546d332a787", "filename": "src/tools/clippy/clippy_lints/src/ptr_eq.rs", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_eq.rs?ref=a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58", "patch": "@@ -1,97 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_opt;\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Use `std::ptr::eq` when applicable\n-    ///\n-    /// ### Why is this bad?\n-    /// `ptr::eq` can be used to compare `&T` references\n-    /// (which coerce to `*const T` implicitly) by their address rather than\n-    /// comparing the values they point to.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let a = &[1, 2, 3];\n-    /// let b = &[1, 2, 3];\n-    ///\n-    /// assert!(a as *const _ as usize == b as *const _ as usize);\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// let a = &[1, 2, 3];\n-    /// let b = &[1, 2, 3];\n-    ///\n-    /// assert!(std::ptr::eq(a, b));\n-    /// ```\n-    #[clippy::version = \"1.49.0\"]\n-    pub PTR_EQ,\n-    style,\n-    \"use `std::ptr::eq` when comparing raw pointers\"\n-}\n-\n-declare_lint_pass!(PtrEq => [PTR_EQ]);\n-\n-static LINT_MSG: &str = \"use `std::ptr::eq` when comparing raw pointers\";\n-\n-impl<'tcx> LateLintPass<'tcx> for PtrEq {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if expr.span.from_expansion() {\n-            return;\n-        }\n-\n-        if let ExprKind::Binary(ref op, left, right) = expr.kind {\n-            if BinOpKind::Eq == op.node {\n-                let (left, right) = match (expr_as_cast_to_usize(cx, left), expr_as_cast_to_usize(cx, right)) {\n-                    (Some(lhs), Some(rhs)) => (lhs, rhs),\n-                    _ => (left, right),\n-                };\n-\n-                if_chain! {\n-                    if let Some(left_var) = expr_as_cast_to_raw_pointer(cx, left);\n-                    if let Some(right_var) = expr_as_cast_to_raw_pointer(cx, right);\n-                    if let Some(left_snip) = snippet_opt(cx, left_var.span);\n-                    if let Some(right_snip) = snippet_opt(cx, right_var.span);\n-                    then {\n-                        span_lint_and_sugg(\n-                            cx,\n-                            PTR_EQ,\n-                            expr.span,\n-                            LINT_MSG,\n-                            \"try\",\n-                            format!(\"std::ptr::eq({}, {})\", left_snip, right_snip),\n-                            Applicability::MachineApplicable,\n-                            );\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-// If the given expression is a cast to a usize, return the lhs of the cast\n-// E.g., `foo as *const _ as usize` returns `foo as *const _`.\n-fn expr_as_cast_to_usize<'tcx>(cx: &LateContext<'tcx>, cast_expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n-    if cx.typeck_results().expr_ty(cast_expr) == cx.tcx.types.usize {\n-        if let ExprKind::Cast(expr, _) = cast_expr.kind {\n-            return Some(expr);\n-        }\n-    }\n-    None\n-}\n-\n-// If the given expression is a cast to a `*const` pointer, return the lhs of the cast\n-// E.g., `foo as *const _` returns `foo`.\n-fn expr_as_cast_to_raw_pointer<'tcx>(cx: &LateContext<'tcx>, cast_expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n-    if cx.typeck_results().expr_ty(cast_expr).is_unsafe_ptr() {\n-        if let ExprKind::Cast(expr, _) = cast_expr.kind {\n-            return Some(expr);\n-        }\n-    }\n-    None\n-}"}, {"sha": "f8801f769e83d6cc2dddd94abac1f4bbc2f10da8", "filename": "src/tools/clippy/clippy_lints/src/redundant_static_lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -87,7 +87,7 @@ impl RedundantStaticLifetimes {\n                         _ => {},\n                     }\n                 }\n-                self.visit_type(&*borrow_type.ty, cx, reason);\n+                self.visit_type(&borrow_type.ty, cx, reason);\n             },\n             _ => {},\n         }"}, {"sha": "5ae04947b82d0bd789d4cea2c2ee78de34bf910a", "filename": "src/tools/clippy/clippy_lints/src/returns.rs", "status": "modified", "additions": 52, "deletions": 19, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n+use clippy_utils::diagnostics::span_lint_hir_and_then;\n use clippy_utils::source::{snippet_opt, snippet_with_context};\n use clippy_utils::{fn_def_id, path_to_local_id};\n use if_chain::if_chain;\n@@ -94,9 +94,10 @@ impl<'tcx> LateLintPass<'tcx> for Return {\n             if !in_external_macro(cx.sess(), retexpr.span);\n             if !local.span.from_expansion();\n             then {\n-                span_lint_and_then(\n+                span_lint_hir_and_then(\n                     cx,\n                     LET_AND_RETURN,\n+                    retexpr.hir_id,\n                     retexpr.span,\n                     \"returning the result of a `let` binding from a block\",\n                     |err| {\n@@ -185,6 +186,7 @@ fn check_final_expr<'tcx>(\n                 if !borrows {\n                     emit_return_lint(\n                         cx,\n+                        inner.map_or(expr.hir_id, |inner| inner.hir_id),\n                         span.expect(\"`else return` is not possible\"),\n                         inner.as_ref().map(|i| i.span),\n                         replacement,\n@@ -220,50 +222,81 @@ fn check_final_expr<'tcx>(\n     }\n }\n \n-fn emit_return_lint(cx: &LateContext<'_>, ret_span: Span, inner_span: Option<Span>, replacement: RetReplacement) {\n+fn emit_return_lint(\n+    cx: &LateContext<'_>,\n+    emission_place: HirId,\n+    ret_span: Span,\n+    inner_span: Option<Span>,\n+    replacement: RetReplacement,\n+) {\n     if ret_span.from_expansion() {\n         return;\n     }\n     match inner_span {\n         Some(inner_span) => {\n             let mut applicability = Applicability::MachineApplicable;\n-            span_lint_and_then(cx, NEEDLESS_RETURN, ret_span, \"unneeded `return` statement\", |diag| {\n-                let (snippet, _) = snippet_with_context(cx, inner_span, ret_span.ctxt(), \"..\", &mut applicability);\n-                diag.span_suggestion(ret_span, \"remove `return`\", snippet, applicability);\n-            });\n+            span_lint_hir_and_then(\n+                cx,\n+                NEEDLESS_RETURN,\n+                emission_place,\n+                ret_span,\n+                \"unneeded `return` statement\",\n+                |diag| {\n+                    let (snippet, _) = snippet_with_context(cx, inner_span, ret_span.ctxt(), \"..\", &mut applicability);\n+                    diag.span_suggestion(ret_span, \"remove `return`\", snippet, applicability);\n+                },\n+            );\n         },\n         None => match replacement {\n             RetReplacement::Empty => {\n-                span_lint_and_sugg(\n+                span_lint_hir_and_then(\n                     cx,\n                     NEEDLESS_RETURN,\n+                    emission_place,\n                     ret_span,\n                     \"unneeded `return` statement\",\n-                    \"remove `return`\",\n-                    String::new(),\n-                    Applicability::MachineApplicable,\n+                    |diag| {\n+                        diag.span_suggestion(\n+                            ret_span,\n+                            \"remove `return`\",\n+                            String::new(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    },\n                 );\n             },\n             RetReplacement::Block => {\n-                span_lint_and_sugg(\n+                span_lint_hir_and_then(\n                     cx,\n                     NEEDLESS_RETURN,\n+                    emission_place,\n                     ret_span,\n                     \"unneeded `return` statement\",\n-                    \"replace `return` with an empty block\",\n-                    \"{}\".to_string(),\n-                    Applicability::MachineApplicable,\n+                    |diag| {\n+                        diag.span_suggestion(\n+                            ret_span,\n+                            \"replace `return` with an empty block\",\n+                            \"{}\".to_string(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    },\n                 );\n             },\n             RetReplacement::Unit => {\n-                span_lint_and_sugg(\n+                span_lint_hir_and_then(\n                     cx,\n                     NEEDLESS_RETURN,\n+                    emission_place,\n                     ret_span,\n                     \"unneeded `return` statement\",\n-                    \"replace `return` with a unit value\",\n-                    \"()\".to_string(),\n-                    Applicability::MachineApplicable,\n+                    |diag| {\n+                        diag.span_suggestion(\n+                            ret_span,\n+                            \"replace `return` with a unit value\",\n+                            \"()\".to_string(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    },\n                 );\n             },\n         },"}, {"sha": "b14f0518bdb77807751ee8041097a98ef96e10ff", "filename": "src/tools/clippy/clippy_lints/src/self_assignment.rs", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_assignment.rs?ref=a9eb9c52f3e8d8b6402e6acc69b9bcfc4f371d58", "patch": "@@ -1,56 +0,0 @@\n-use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::eq_expr_value;\n-use clippy_utils::source::snippet;\n-use rustc_hir::{Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for explicit self-assignments.\n-    ///\n-    /// ### Why is this bad?\n-    /// Self-assignments are redundant and unlikely to be\n-    /// intentional.\n-    ///\n-    /// ### Known problems\n-    /// If expression contains any deref coercions or\n-    /// indexing operations they are assumed not to have any side effects.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// struct Event {\n-    ///     id: usize,\n-    ///     x: i32,\n-    ///     y: i32,\n-    /// }\n-    ///\n-    /// fn copy_position(a: &mut Event, b: &Event) {\n-    ///     a.x = b.x;\n-    ///     a.y = a.y;\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.48.0\"]\n-    pub SELF_ASSIGNMENT,\n-    correctness,\n-    \"explicit self-assignment\"\n-}\n-\n-declare_lint_pass!(SelfAssignment => [SELF_ASSIGNMENT]);\n-\n-impl<'tcx> LateLintPass<'tcx> for SelfAssignment {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Assign(lhs, rhs, _) = &expr.kind {\n-            if eq_expr_value(cx, lhs, rhs) {\n-                let lhs = snippet(cx, lhs.span, \"<lhs>\");\n-                let rhs = snippet(cx, rhs.span, \"<rhs>\");\n-                span_lint(\n-                    cx,\n-                    SELF_ASSIGNMENT,\n-                    expr.span,\n-                    &format!(\"self-assignment of `{}` to `{}`\", rhs, lhs),\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "2c8aa17e80dbdeb3fa5c3a33c91fce560f450e7d", "filename": "src/tools/clippy/clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -26,6 +26,9 @@ declare_clippy_lint! {\n     /// let mut vec1 = Vec::with_capacity(len);\n     /// vec1.resize(len, 0);\n     ///\n+    /// let mut vec1 = Vec::with_capacity(len);\n+    /// vec1.resize(vec1.capacity(), 0);\n+    ///\n     /// let mut vec2 = Vec::with_capacity(len);\n     /// vec2.extend(repeat(0).take(len));\n     /// ```\n@@ -211,23 +214,20 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n \n     /// Checks if the given expression is resizing a vector with 0\n     fn search_slow_resize_filling(&mut self, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if self.initialization_found;\n-            if let ExprKind::MethodCall(path, [self_arg, len_arg, fill_arg], _) = expr.kind;\n-            if path_to_local_id(self_arg, self.vec_alloc.local_id);\n-            if path.ident.name == sym!(resize);\n-\n+        if self.initialization_found\n+            && let ExprKind::MethodCall(path, [self_arg, len_arg, fill_arg], _) = expr.kind\n+            && path_to_local_id(self_arg, self.vec_alloc.local_id)\n+            && path.ident.name == sym!(resize)\n             // Check that is filled with 0\n-            if let ExprKind::Lit(ref lit) = fill_arg.kind;\n-            if let LitKind::Int(0, _) = lit.node;\n-\n-            // Check that len expression is equals to `with_capacity` expression\n-            if SpanlessEq::new(self.cx).eq_expr(len_arg, self.vec_alloc.len_expr);\n-\n-            then {\n-                self.slow_expression = Some(InitializationType::Resize(expr));\n+            && let ExprKind::Lit(ref lit) = fill_arg.kind\n+            && let LitKind::Int(0, _) = lit.node {\n+                // Check that len expression is equals to `with_capacity` expression\n+                if SpanlessEq::new(self.cx).eq_expr(len_arg, self.vec_alloc.len_expr) {\n+                    self.slow_expression = Some(InitializationType::Resize(expr));\n+                } else if let ExprKind::MethodCall(path, _, _) = len_arg.kind && path.ident.as_str() == \"capacity\" {\n+                    self.slow_expression = Some(InitializationType::Resize(expr));\n+                }\n             }\n-        }\n     }\n \n     /// Returns `true` if give expression is `repeat(0).take(...)`\n@@ -240,12 +240,15 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n             if let Some(repeat_expr) = take_args.get(0);\n             if self.is_repeat_zero(repeat_expr);\n \n-            // Check that len expression is equals to `with_capacity` expression\n             if let Some(len_arg) = take_args.get(1);\n-            if SpanlessEq::new(self.cx).eq_expr(len_arg, self.vec_alloc.len_expr);\n \n             then {\n-                return true;\n+                // Check that len expression is equals to `with_capacity` expression\n+                if SpanlessEq::new(self.cx).eq_expr(len_arg, self.vec_alloc.len_expr) {\n+                    return true;\n+                } else if let ExprKind::MethodCall(path, _, _) = len_arg.kind && path.ident.as_str() == \"capacity\" {\n+                    return true;\n+                }\n             }\n         }\n "}, {"sha": "eb704a07451ca370a5c4246d76edd4341f3b2b21", "filename": "src/tools/clippy/clippy_lints/src/strings.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -60,6 +60,12 @@ declare_clippy_lint! {\n     /// let x = \"Hello\".to_owned();\n     /// x + \", World\";\n     /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// let mut x = \"Hello\".to_owned();\n+    /// x.push_str(\", World\");\n+    /// ```\n     #[clippy::version = \"pre 1.29.0\"]\n     pub STRING_ADD,\n     restriction,"}, {"sha": "5f3e98144f42ddfb5ccf9ce5021e652e0369a08d", "filename": "src/tools/clippy/clippy_lints/src/transmute/mod.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fmod.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -16,9 +16,10 @@ mod wrong_transmute;\n \n use clippy_utils::in_constant;\n use if_chain::if_chain;\n-use rustc_hir::{Expr, ExprKind};\n+use rustc_hir::{Expr, ExprKind, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol::sym;\n \n declare_clippy_lint! {\n@@ -385,7 +386,10 @@ declare_clippy_lint! {\n     \"transmute to or from a type with an undefined representation\"\n }\n \n-declare_lint_pass!(Transmute => [\n+pub struct Transmute {\n+    msrv: Option<RustcVersion>,\n+}\n+impl_lint_pass!(Transmute => [\n     CROSSPOINTER_TRANSMUTE,\n     TRANSMUTE_PTR_TO_REF,\n     TRANSMUTE_PTR_TO_PTR,\n@@ -401,13 +405,18 @@ declare_lint_pass!(Transmute => [\n     TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n     TRANSMUTE_UNDEFINED_REPR,\n ]);\n-\n+impl Transmute {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n impl<'tcx> LateLintPass<'tcx> for Transmute {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Call(path_expr, [arg]) = e.kind;\n-            if let ExprKind::Path(ref qpath) = path_expr.kind;\n-            if let Some(def_id) = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id();\n+            if let ExprKind::Path(QPath::Resolved(None, path)) = path_expr.kind;\n+            if let Some(def_id) = path.res.opt_def_id();\n             if cx.tcx.is_diagnostic_item(sym::transmute, def_id);\n             then {\n                 // Avoid suggesting non-const operations in const contexts:\n@@ -427,7 +436,7 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n \n                 let linted = wrong_transmute::check(cx, e, from_ty, to_ty)\n                     | crosspointer_transmute::check(cx, e, from_ty, to_ty)\n-                    | transmute_ptr_to_ref::check(cx, e, from_ty, to_ty, arg, qpath)\n+                    | transmute_ptr_to_ref::check(cx, e, from_ty, to_ty, arg, path, self.msrv)\n                     | transmute_int_to_char::check(cx, e, from_ty, to_ty, arg, const_context)\n                     | transmute_ref_to_ref::check(cx, e, from_ty, to_ty, arg, const_context)\n                     | transmute_ptr_to_ptr::check(cx, e, from_ty, to_ty, arg)\n@@ -446,4 +455,6 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n             }\n         }\n     }\n+\n+    extract_msrv_attr!(LateContext);\n }"}, {"sha": "3ed5d5c69508173d2a81ffdecbd1550c106ba39f", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_ptr_to_ref.rs", "status": "modified", "additions": 42, "deletions": 14, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,11 +1,12 @@\n-use super::utils::get_type_snippet;\n use super::TRANSMUTE_PTR_TO_REF;\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{meets_msrv, msrvs, sugg};\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, Mutability, QPath};\n+use rustc_hir::{self as hir, Expr, GenericArg, Mutability, Path, TyKind};\n use rustc_lint::LateContext;\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, Ty, TypeFoldable};\n+use rustc_semver::RustcVersion;\n \n /// Checks for `transmute_ptr_to_ref` lint.\n /// Returns `true` if it's triggered, otherwise returns `false`.\n@@ -15,7 +16,8 @@ pub(super) fn check<'tcx>(\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n     arg: &'tcx Expr<'_>,\n-    qpath: &'tcx QPath<'_>,\n+    path: &'tcx Path<'_>,\n+    msrv: Option<RustcVersion>,\n ) -> bool {\n     match (&from_ty.kind(), &to_ty.kind()) {\n         (ty::RawPtr(from_ptr_ty), ty::Ref(_, to_ref_ty, mutbl)) => {\n@@ -34,23 +36,49 @@ pub(super) fn check<'tcx>(\n                     } else {\n                         (\"&*\", \"*const\")\n                     };\n+                    let mut app = Applicability::MachineApplicable;\n \n-                    let arg = if from_ptr_ty.ty == *to_ref_ty {\n-                        arg\n+                    let sugg = if let Some(ty) = get_explicit_type(path) {\n+                        let ty_snip = snippet_with_applicability(cx, ty.span, \"..\", &mut app);\n+                        if meets_msrv(msrv, msrvs::POINTER_CAST) {\n+                            format!(\"{}{}.cast::<{}>()\", deref, arg.maybe_par(), ty_snip)\n+                        } else if from_ptr_ty.has_erased_regions() {\n+                            sugg::make_unop(deref, arg.as_ty(format!(\"{} () as {} {}\", cast, cast, ty_snip)))\n+                                .to_string()\n+                        } else {\n+                            sugg::make_unop(deref, arg.as_ty(format!(\"{} {}\", cast, ty_snip))).to_string()\n+                        }\n+                    } else if from_ptr_ty.ty == *to_ref_ty {\n+                        if from_ptr_ty.has_erased_regions() {\n+                            if meets_msrv(msrv, msrvs::POINTER_CAST) {\n+                                format!(\"{}{}.cast::<{}>()\", deref, arg.maybe_par(), to_ref_ty)\n+                            } else {\n+                                sugg::make_unop(deref, arg.as_ty(format!(\"{} () as {} {}\", cast, cast, to_ref_ty)))\n+                                    .to_string()\n+                            }\n+                        } else {\n+                            sugg::make_unop(deref, arg).to_string()\n+                        }\n                     } else {\n-                        arg.as_ty(&format!(\"{} {}\", cast, get_type_snippet(cx, qpath, *to_ref_ty)))\n+                        sugg::make_unop(deref, arg.as_ty(format!(\"{} {}\", cast, to_ref_ty))).to_string()\n                     };\n \n-                    diag.span_suggestion(\n-                        e.span,\n-                        \"try\",\n-                        sugg::make_unop(deref, arg).to_string(),\n-                        Applicability::Unspecified,\n-                    );\n+                    diag.span_suggestion(e.span, \"try\", sugg, app);\n                 },\n             );\n             true\n         },\n         _ => false,\n     }\n }\n+\n+/// Gets the type `Bar` in `\u2026::transmute<Foo, &Bar>`.\n+fn get_explicit_type<'tcx>(path: &'tcx Path<'tcx>) -> Option<&'tcx hir::Ty<'tcx>> {\n+    if let GenericArg::Type(ty) = path.segments.last()?.args?.args.get(1)?\n+        && let TyKind::Rptr(_, ty) = &ty.kind\n+    {\n+        Some(ty.ty)\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "74927570b40ebe579ec00b3df789f8a7d5820e1f", "filename": "src/tools/clippy/clippy_lints/src/transmute/utils.rs", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,35 +1,9 @@\n-use clippy_utils::last_path_segment;\n-use clippy_utils::source::snippet;\n-use if_chain::if_chain;\n-use rustc_hir::{Expr, GenericArg, QPath, TyKind};\n+use rustc_hir::Expr;\n use rustc_lint::LateContext;\n use rustc_middle::ty::{cast::CastKind, Ty};\n use rustc_span::DUMMY_SP;\n use rustc_typeck::check::{cast::CastCheck, FnCtxt, Inherited};\n \n-/// Gets the snippet of `Bar` in `\u2026::transmute<Foo, &Bar>`. If that snippet is\n-/// not available , use\n-/// the type's `ToString` implementation. In weird cases it could lead to types\n-/// with invalid `'_`\n-/// lifetime, but it should be rare.\n-pub(super) fn get_type_snippet(cx: &LateContext<'_>, path: &QPath<'_>, to_ref_ty: Ty<'_>) -> String {\n-    let seg = last_path_segment(path);\n-    if_chain! {\n-        if let Some(params) = seg.args;\n-        if !params.parenthesized;\n-        if let Some(to_ty) = params.args.iter().filter_map(|arg| match arg {\n-            GenericArg::Type(ty) => Some(ty),\n-            _ => None,\n-        }).nth(1);\n-        if let TyKind::Rptr(_, ref to_ty) = to_ty.kind;\n-        then {\n-            return snippet(cx, to_ty.ty.span, &to_ref_ty.to_string()).to_string();\n-        }\n-    }\n-\n-    to_ref_ty.to_string()\n-}\n-\n // check if the component types of the transmuted collection and the result have different ABI,\n // size or alignment\n pub(super) fn is_layout_incompatible<'tcx>(cx: &LateContext<'tcx>, from: Ty<'tcx>, to: Ty<'tcx>) -> bool {"}, {"sha": "a832dfcccaf36eaba7a3813956f4af40073c5906", "filename": "src/tools/clippy/clippy_lints/src/unused_async.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_async.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use rustc_hir::intravisit::{walk_expr, walk_fn, FnKind, Visitor};\n-use rustc_hir::{Body, Expr, ExprKind, FnDecl, FnHeader, HirId, IsAsync, YieldSource};\n+use rustc_hir::{Body, Expr, ExprKind, FnDecl, HirId, IsAsync, YieldSource};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::nested_filter;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -68,20 +68,18 @@ impl<'tcx> LateLintPass<'tcx> for UnusedAsync {\n         span: Span,\n         hir_id: HirId,\n     ) {\n-        if let FnKind::ItemFn(_, _, FnHeader { asyncness, .. }) = &fn_kind {\n-            if matches!(asyncness, IsAsync::Async) {\n-                let mut visitor = AsyncFnVisitor { cx, found_await: false };\n-                walk_fn(&mut visitor, fn_kind, fn_decl, body.id(), span, hir_id);\n-                if !visitor.found_await {\n-                    span_lint_and_help(\n-                        cx,\n-                        UNUSED_ASYNC,\n-                        span,\n-                        \"unused `async` for function with no await statements\",\n-                        None,\n-                        \"consider removing the `async` from this function\",\n-                    );\n-                }\n+        if !span.from_expansion() && fn_kind.asyncness() == IsAsync::Async {\n+            let mut visitor = AsyncFnVisitor { cx, found_await: false };\n+            walk_fn(&mut visitor, fn_kind, fn_decl, body.id(), span, hir_id);\n+            if !visitor.found_await {\n+                span_lint_and_help(\n+                    cx,\n+                    UNUSED_ASYNC,\n+                    span,\n+                    \"unused `async` for function with no await statements\",\n+                    None,\n+                    \"consider removing the `async` from this function\",\n+                );\n             }\n         }\n     }"}, {"sha": "d3f9e5abfd739a2ba9e2b66cb132d49ca87ceb54", "filename": "src/tools/clippy/clippy_lints/src/unwrap.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::diagnostics::span_lint_hir_and_then;\n use clippy_utils::higher;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{path_to_local, usage::is_potentially_mutated};\n@@ -251,9 +251,10 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n                             unwrappable.kind.error_variant_pattern()\n                         };\n \n-                        span_lint_and_then(\n+                        span_lint_hir_and_then(\n                             self.cx,\n                             UNNECESSARY_UNWRAP,\n+                            expr.hir_id,\n                             expr.span,\n                             &format!(\n                                 \"called `{}` on `{}` after checking its variant with `{}`\",\n@@ -283,9 +284,10 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n                             },\n                         );\n                     } else {\n-                        span_lint_and_then(\n+                        span_lint_hir_and_then(\n                             self.cx,\n                             PANICKING_UNWRAP,\n+                            expr.hir_id,\n                             expr.span,\n                             &format!(\"this call to `{}()` will always panic\",\n                             method_name.ident.name),"}, {"sha": "a94f0357977eab8766bea03e03d1eee36b0b003f", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 87, "deletions": 20, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,3 +1,4 @@\n+use crate::utils::internal_lints::metadata_collector::is_deprecated_lint;\n use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::macros::root_macro_call_first_node;\n@@ -338,6 +339,46 @@ declare_clippy_lint! {\n     \"checking if all necessary steps were taken when adding a MSRV to a lint\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for cases of an auto-generated deprecated lint without an updated reason,\n+    /// i.e. `\"default deprecation note\"`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Indicates that the documentation is incomplete.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// declare_deprecated_lint! {\n+    ///     /// ### What it does\n+    ///     /// Nothing. This lint has been deprecated.\n+    ///     ///\n+    ///     /// ### Deprecation reason\n+    ///     /// TODO\n+    ///     #[clippy::version = \"1.63.0\"]\n+    ///     pub COOL_LINT,\n+    ///     \"default deprecation note\"\n+    /// }\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// declare_deprecated_lint! {\n+    ///     /// ### What it does\n+    ///     /// Nothing. This lint has been deprecated.\n+    ///     ///\n+    ///     /// ### Deprecation reason\n+    ///     /// This lint has been replaced by `cooler_lint`\n+    ///     #[clippy::version = \"1.63.0\"]\n+    ///     pub COOL_LINT,\n+    ///     \"this lint has been replaced by `cooler_lint`\"\n+    /// }\n+    /// ```\n+    pub DEFAULT_DEPRECATION_REASON,\n+    internal,\n+    \"found 'default deprecation note' in a deprecated lint declaration\"\n+}\n+\n declare_lint_pass!(ClippyLintsInternal => [CLIPPY_LINTS_INTERNAL]);\n \n impl EarlyLintPass for ClippyLintsInternal {\n@@ -375,42 +416,67 @@ pub struct LintWithoutLintPass {\n     registered_lints: FxHashSet<Symbol>,\n }\n \n-impl_lint_pass!(LintWithoutLintPass => [DEFAULT_LINT, LINT_WITHOUT_LINT_PASS, INVALID_CLIPPY_VERSION_ATTRIBUTE, MISSING_CLIPPY_VERSION_ATTRIBUTE]);\n+impl_lint_pass!(LintWithoutLintPass => [DEFAULT_LINT, LINT_WITHOUT_LINT_PASS, INVALID_CLIPPY_VERSION_ATTRIBUTE, MISSING_CLIPPY_VERSION_ATTRIBUTE, DEFAULT_DEPRECATION_REASON]);\n \n impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if is_lint_allowed(cx, DEFAULT_LINT, item.hir_id()) {\n+        if is_lint_allowed(cx, DEFAULT_LINT, item.hir_id())\n+            || is_lint_allowed(cx, DEFAULT_DEPRECATION_REASON, item.hir_id())\n+        {\n             return;\n         }\n \n         if let hir::ItemKind::Static(ty, Mutability::Not, body_id) = item.kind {\n-            if is_lint_ref_type(cx, ty) {\n+            let is_lint_ref_ty = is_lint_ref_type(cx, ty);\n+            if is_deprecated_lint(cx, ty) || is_lint_ref_ty {\n                 check_invalid_clippy_version_attribute(cx, item);\n \n                 let expr = &cx.tcx.hir().body(body_id).value;\n-                if_chain! {\n-                    if let ExprKind::AddrOf(_, _, inner_exp) = expr.kind;\n-                    if let ExprKind::Struct(_, fields, _) = inner_exp.kind;\n-                    let field = fields\n-                        .iter()\n-                        .find(|f| f.ident.as_str() == \"desc\")\n-                        .expect(\"lints must have a description field\");\n-                    if let ExprKind::Lit(Spanned {\n-                        node: LitKind::Str(ref sym, _),\n-                        ..\n-                    }) = field.expr.kind;\n-                    if sym.as_str() == \"default lint description\";\n-\n-                    then {\n+                let fields;\n+                if is_lint_ref_ty {\n+                    if let ExprKind::AddrOf(_, _, inner_exp) = expr.kind\n+                        && let ExprKind::Struct(_, struct_fields, _) = inner_exp.kind {\n+                            fields = struct_fields;\n+                    } else {\n+                        return;\n+                    }\n+                } else if let ExprKind::Struct(_, struct_fields, _) = expr.kind {\n+                    fields = struct_fields;\n+                } else {\n+                    return;\n+                }\n+\n+                let field = fields\n+                    .iter()\n+                    .find(|f| f.ident.as_str() == \"desc\")\n+                    .expect(\"lints must have a description field\");\n+\n+                if let ExprKind::Lit(Spanned {\n+                    node: LitKind::Str(ref sym, _),\n+                    ..\n+                }) = field.expr.kind\n+                {\n+                    let sym_str = sym.as_str();\n+                    if is_lint_ref_ty {\n+                        if sym_str == \"default lint description\" {\n+                            span_lint(\n+                                cx,\n+                                DEFAULT_LINT,\n+                                item.span,\n+                                &format!(\"the lint `{}` has the default lint description\", item.ident.name),\n+                            );\n+                        }\n+\n+                        self.declared_lints.insert(item.ident.name, item.span);\n+                    } else if sym_str == \"default deprecation note\" {\n                         span_lint(\n                             cx,\n-                            DEFAULT_LINT,\n+                            DEFAULT_DEPRECATION_REASON,\n                             item.span,\n-                            &format!(\"the lint `{}` has the default lint description\", item.ident.name),\n+                            &format!(\"the lint `{}` has the default deprecation reason\", item.ident.name),\n                         );\n                     }\n                 }\n-                self.declared_lints.insert(item.ident.name, item.span);\n             }\n         } else if let Some(macro_call) = root_macro_call_first_node(cx, item) {\n             if !matches!(\n@@ -668,6 +734,7 @@ impl<'tcx> LateLintPass<'tcx> for CollapsibleCalls {\n             let body = cx.tcx.hir().body(*body);\n             let only_expr = peel_blocks_with_stmt(&body.value);\n             if let ExprKind::MethodCall(ps, span_call_args, _) = &only_expr.kind;\n+            if let ExprKind::Path(..) = span_call_args[0].kind;\n             then {\n                 let and_then_snippets = get_and_then_snippets(cx, and_then_args);\n                 let mut sle = SpanlessEq::new(cx).deny_side_effects();"}, {"sha": "6518e0a6ea07390620fff232344e21c30312b417", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -104,7 +104,7 @@ macro_rules! RENAME_VALUE_TEMPLATE {\n     };\n }\n \n-const LINT_EMISSION_FUNCTIONS: [&[&str]; 8] = [\n+const LINT_EMISSION_FUNCTIONS: [&[&str]; 7] = [\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint\"],\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_help\"],\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_note\"],\n@@ -190,7 +190,12 @@ impl MetadataCollector {\n             lints: BinaryHeap::<LintMetadata>::default(),\n             applicability_info: FxHashMap::<String, ApplicabilityInfo>::default(),\n             config: collect_configs(),\n-            clippy_project_root: clippy_dev::clippy_project_root(),\n+            clippy_project_root: std::env::current_dir()\n+                .expect(\"failed to get current dir\")\n+                .ancestors()\n+                .nth(1)\n+                .expect(\"failed to get project root\")\n+                .to_path_buf(),\n         }\n     }\n \n@@ -841,7 +846,7 @@ fn get_lint_level_from_group(lint_group: &str) -> Option<&'static str> {\n         .find_map(|(group_name, group_level)| (*group_name == lint_group).then(|| *group_level))\n }\n \n-fn is_deprecated_lint(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> bool {\n+pub(super) fn is_deprecated_lint(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> bool {\n     if let hir::TyKind::Path(ref path) = ty.kind {\n         if let hir::def::Res::Def(DefKind::Struct, def_id) = cx.qpath_res(path, ty.hir_id) {\n             return match_def_path(cx, def_id, &DEPRECATED_LINT_TYPE);"}, {"sha": "0fee3e812d286db1a143c583455b8e12a8e00062", "filename": "src/tools/clippy/clippy_lints/src/vec_resize_to_zero.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_resize_to_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_resize_to_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_resize_to_zero.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -20,6 +20,11 @@ declare_clippy_lint! {\n     /// ```rust\n     /// vec!(1, 2, 3, 4, 5).resize(0, 5)\n     /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// vec!(1, 2, 3, 4, 5).clear()\n+    /// ```\n     #[clippy::version = \"1.46.0\"]\n     pub VEC_RESIZE_TO_ZERO,\n     correctness,"}, {"sha": "bb443bdc1168fc97ee0b363b9908c0cd1c423aac", "filename": "src/tools/clippy/clippy_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2FCargo.toml?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy_utils\"\n-version = \"0.1.63\"\n+version = \"0.1.64\"\n edition = \"2021\"\n publish = false\n "}, {"sha": "793e3cc58c21dba57339fb431899bef7e2bdf523", "filename": "src/tools/clippy/clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,4 +1,5 @@\n use crate::consts::constant_simple;\n+use crate::macros::macro_backtrace;\n use crate::source::snippet_opt;\n use rustc_ast::ast::InlineAsmTemplatePiece;\n use rustc_data_structures::fx::FxHasher;\n@@ -12,9 +13,13 @@ use rustc_hir::{\n use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty::TypeckResults;\n-use rustc_span::Symbol;\n+use rustc_span::{sym, Symbol};\n use std::hash::{Hash, Hasher};\n \n+/// Callback that is called when two expressions are not equal in the sense of `SpanlessEq`, but\n+/// other conditions would make them equal.\n+type SpanlessEqCallback<'a> = dyn FnMut(&Expr<'_>, &Expr<'_>) -> bool + 'a;\n+\n /// Type used to check whether two ast are the same. This is different from the\n /// operator `==` on ast types as this operator would compare true equality with\n /// ID and span.\n@@ -25,7 +30,7 @@ pub struct SpanlessEq<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n     maybe_typeck_results: Option<(&'tcx TypeckResults<'tcx>, &'tcx TypeckResults<'tcx>)>,\n     allow_side_effects: bool,\n-    expr_fallback: Option<Box<dyn FnMut(&Expr<'_>, &Expr<'_>) -> bool + 'a>>,\n+    expr_fallback: Option<Box<SpanlessEqCallback<'a>>>,\n }\n \n impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n@@ -121,6 +126,9 @@ impl HirEqInterExpr<'_, '_, '_> {\n \n     /// Checks whether two blocks are the same.\n     fn eq_block(&mut self, left: &Block<'_>, right: &Block<'_>) -> bool {\n+        if self.cannot_be_compared_block(left) || self.cannot_be_compared_block(right) {\n+            return false;\n+        }\n         match (left.stmts, left.expr, right.stmts, right.expr) {\n             ([], None, [], None) => {\n                 // For empty blocks, check to see if the tokens are equal. This will catch the case where a macro\n@@ -171,6 +179,38 @@ impl HirEqInterExpr<'_, '_, '_> {\n         }\n     }\n \n+    fn cannot_be_compared_block(&mut self, block: &Block<'_>) -> bool {\n+        if block.stmts.last().map_or(false, |stmt| {\n+            matches!(\n+                stmt.kind,\n+                StmtKind::Semi(semi_expr) if self.should_ignore(semi_expr)\n+            )\n+        }) {\n+            return true;\n+        }\n+\n+        if let Some(block_expr) = block.expr\n+            && self.should_ignore(block_expr)\n+        {\n+            return true\n+        }\n+\n+        false\n+    }\n+\n+    fn should_ignore(&mut self, expr: &Expr<'_>) -> bool {\n+        if macro_backtrace(expr.span).last().map_or(false, |macro_call| {\n+            matches!(\n+                &self.inner.cx.tcx.get_diagnostic_name(macro_call.def_id),\n+                Some(sym::todo_macro | sym::unimplemented_macro)\n+            )\n+        }) {\n+            return true;\n+        }\n+\n+        false\n+    }\n+\n     pub fn eq_array_length(&mut self, left: ArrayLen, right: ArrayLen) -> bool {\n         match (left, right) {\n             (ArrayLen::Infer(..), ArrayLen::Infer(..)) => true,"}, {"sha": "9fa28e137f974288c629634bc745939b3ca93e24", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 66, "deletions": 3, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1539,9 +1539,13 @@ pub fn is_try<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'tcx>) -> Option<&'tc\n     None\n }\n \n-/// Returns `true` if the lint is allowed in the current context\n+/// Returns `true` if the lint is allowed in the current context. This is useful for\n+/// skipping long running code when it's unnecessary\n ///\n-/// Useful for skipping long running code when it's unnecessary\n+/// This function should check the lint level for the same node, that the lint will\n+/// be emitted at. If the information is buffered to be emitted at a later point, please\n+/// make sure to use `span_lint_hir` functions to emit the lint. This ensures that\n+/// expectations at the checked nodes will be fulfilled.\n pub fn is_lint_allowed(cx: &LateContext<'_>, lint: &'static Lint, id: HirId) -> bool {\n     cx.tcx.lint_level_at_node(lint, id).0 == Level::Allow\n }\n@@ -2058,6 +2062,21 @@ pub fn peel_hir_expr_refs<'a>(expr: &'a Expr<'a>) -> (&'a Expr<'a>, usize) {\n     (e, count)\n }\n \n+/// Peels off all references on the type. Returns the underlying type and the number of references\n+/// removed.\n+pub fn peel_hir_ty_refs<'a>(mut ty: &'a hir::Ty<'a>) -> (&'a hir::Ty<'a>, usize) {\n+    let mut count = 0;\n+    loop {\n+        match &ty.kind {\n+            TyKind::Rptr(_, ref_ty) => {\n+                ty = ref_ty.ty;\n+                count += 1;\n+            },\n+            _ => break (ty, count),\n+        }\n+    }\n+}\n+\n /// Removes `AddrOf` operators (`&`) or deref operators (`*`), but only if a reference type is\n /// dereferenced. An overloaded deref such as `Vec` to slice would not be removed.\n pub fn peel_ref_operators<'hir>(cx: &LateContext<'_>, mut expr: &'hir Expr<'hir>) -> &'hir Expr<'hir> {\n@@ -2110,7 +2129,7 @@ fn with_test_item_names<'tcx>(tcx: TyCtxt<'tcx>, module: LocalDefId, f: impl Fn(\n                 }\n             }\n             names.sort_unstable();\n-            f(&*entry.insert(names))\n+            f(entry.insert(names))\n         },\n     }\n }\n@@ -2168,6 +2187,50 @@ pub fn is_test_module_or_function(tcx: TyCtxt<'_>, item: &Item<'_>) -> bool {\n             && item.ident.name.as_str().split('_').any(|a| a == \"test\" || a == \"tests\")\n }\n \n+/// Walks the HIR tree from the given expression, up to the node where the value produced by the\n+/// expression is consumed. Calls the function for every node encountered this way until it returns\n+/// `Some`.\n+///\n+/// This allows walking through `if`, `match`, `break`, block expressions to find where the value\n+/// produced by the expression is consumed.\n+pub fn walk_to_expr_usage<'tcx, T>(\n+    cx: &LateContext<'tcx>,\n+    e: &Expr<'tcx>,\n+    mut f: impl FnMut(Node<'tcx>, HirId) -> Option<T>,\n+) -> Option<T> {\n+    let map = cx.tcx.hir();\n+    let mut iter = map.parent_iter(e.hir_id);\n+    let mut child_id = e.hir_id;\n+\n+    while let Some((parent_id, parent)) = iter.next() {\n+        if let Some(x) = f(parent, child_id) {\n+            return Some(x);\n+        }\n+        let parent = match parent {\n+            Node::Expr(e) => e,\n+            Node::Block(Block { expr: Some(body), .. }) | Node::Arm(Arm { body, .. }) if body.hir_id == child_id => {\n+                child_id = parent_id;\n+                continue;\n+            },\n+            Node::Arm(a) if a.body.hir_id == child_id => {\n+                child_id = parent_id;\n+                continue;\n+            },\n+            _ => return None,\n+        };\n+        match parent.kind {\n+            ExprKind::If(child, ..) | ExprKind::Match(child, ..) if child.hir_id != child_id => child_id = parent_id,\n+            ExprKind::Break(Destination { target_id: Ok(id), .. }, _) => {\n+                child_id = id;\n+                iter = map.parent_iter(id);\n+            },\n+            ExprKind::Block(..) => child_id = parent_id,\n+            _ => return None,\n+        }\n+    }\n+    None\n+}\n+\n macro_rules! op_utils {\n     ($($name:ident $assign:ident)*) => {\n         /// Binary operation traits like `LangItem::Add`"}, {"sha": "b09c929f76e2267cbc6145d0e95402346a9e0542", "filename": "src/tools/clippy/clippy_utils/src/msrvs.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmsrvs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmsrvs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmsrvs.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -12,8 +12,8 @@ macro_rules! msrv_aliases {\n \n // names may refer to stabilized feature flags or library items\n msrv_aliases! {\n-    1,53,0 { OR_PATTERNS, MANUAL_BITS }\n-    1,52,0 { STR_SPLIT_ONCE }\n+    1,53,0 { OR_PATTERNS, MANUAL_BITS, BTREE_MAP_RETAIN, BTREE_SET_RETAIN }\n+    1,52,0 { STR_SPLIT_ONCE, REM_EUCLID_CONST }\n     1,51,0 { BORROW_AS_PTR, UNSIGNED_ABS }\n     1,50,0 { BOOL_THEN }\n     1,47,0 { TAU }\n@@ -23,14 +23,15 @@ msrv_aliases! {\n     1,42,0 { MATCHES_MACRO, SLICE_PATTERNS, PTR_SLICE_RAW_PARTS }\n     1,41,0 { RE_REBALANCING_COHERENCE, RESULT_MAP_OR_ELSE }\n     1,40,0 { MEM_TAKE, NON_EXHAUSTIVE, OPTION_AS_DEREF }\n-    1,38,0 { POINTER_CAST }\n+    1,38,0 { POINTER_CAST, REM_EUCLID }\n     1,37,0 { TYPE_ALIAS_ENUM_VARIANTS }\n     1,36,0 { ITERATOR_COPIED }\n     1,35,0 { OPTION_COPIED, RANGE_CONTAINS }\n     1,34,0 { TRY_FROM }\n     1,30,0 { ITERATOR_FIND_MAP, TOOL_ATTRIBUTES }\n     1,28,0 { FROM_BOOL }\n-    1,26,0 { RANGE_INCLUSIVE }\n+    1,26,0 { RANGE_INCLUSIVE, STRING_RETAIN }\n+    1,18,0 { HASH_MAP_RETAIN, HASH_SET_RETAIN }\n     1,17,0 { FIELD_INIT_SHORTHAND, STATIC_IN_CONST, EXPECT_ERR }\n     1,16,0 { STR_REPEAT }\n     1,24,0 { IS_ASCII_DIGIT }"}, {"sha": "6542e77113b459e156eb0072fce4391869881b1b", "filename": "src/tools/clippy/clippy_utils/src/paths.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -21,8 +21,14 @@ pub const ASREF_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsRef\"];\n pub const BTREEMAP_CONTAINS_KEY: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\", \"contains_key\"];\n pub const BTREEMAP_ENTRY: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"entry\", \"Entry\"];\n pub const BTREEMAP_INSERT: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\", \"insert\"];\n+pub const BTREESET_ITER: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"set\", \"BTreeSet\", \"iter\"];\n pub const CLONE_TRAIT_METHOD: [&str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n pub const COW: [&str; 3] = [\"alloc\", \"borrow\", \"Cow\"];\n+pub const CORE_ITER_COLLECT: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"collect\"];\n+pub const CORE_ITER_CLONED: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"cloned\"];\n+pub const CORE_ITER_COPIED: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"copied\"];\n+pub const CORE_ITER_FILTER: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"filter\"];\n+pub const CORE_ITER_INTO_ITER: [&str; 6] = [\"core\", \"iter\", \"traits\", \"collect\", \"IntoIterator\", \"into_iter\"];\n pub const CSTRING_AS_C_STR: [&str; 5] = [\"alloc\", \"ffi\", \"c_str\", \"CString\", \"as_c_str\"];\n pub const DEFAULT_TRAIT_METHOD: [&str; 4] = [\"core\", \"default\", \"Default\", \"default\"];\n pub const DEREF_MUT_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"DerefMut\", \"deref_mut\"];\n@@ -50,6 +56,7 @@ pub const FUTURES_IO_ASYNCWRITEEXT: [&str; 3] = [\"futures_util\", \"io\", \"AsyncWri\n pub const HASHMAP_CONTAINS_KEY: [&str; 6] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\", \"contains_key\"];\n pub const HASHMAP_ENTRY: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n pub const HASHMAP_INSERT: [&str; 6] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\", \"insert\"];\n+pub const HASHSET_ITER: [&str; 6] = [\"std\", \"collections\", \"hash\", \"set\", \"HashSet\", \"iter\"];\n #[cfg(feature = \"internal\")]\n pub const IDENT: [&str; 3] = [\"rustc_span\", \"symbol\", \"Ident\"];\n #[cfg(feature = \"internal\")]\n@@ -62,6 +69,7 @@ pub const IO_WRITE: [&str; 3] = [\"std\", \"io\", \"Write\"];\n pub const IPADDR_V4: [&str; 5] = [\"std\", \"net\", \"ip\", \"IpAddr\", \"V4\"];\n pub const IPADDR_V6: [&str; 5] = [\"std\", \"net\", \"ip\", \"IpAddr\", \"V6\"];\n pub const ITER_COUNT: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"count\"];\n+pub const ITER_EMPTY: [&str; 5] = [\"core\", \"iter\", \"sources\", \"empty\", \"Empty\"];\n pub const ITER_REPEAT: [&str; 5] = [\"core\", \"iter\", \"sources\", \"repeat\", \"repeat\"];\n #[expect(clippy::invalid_paths)] // internal lints do not know about all external crates\n pub const ITERTOOLS_NEXT_TUPLE: [&str; 3] = [\"itertools\", \"Itertools\", \"next_tuple\"];\n@@ -83,8 +91,6 @@ pub const OPTION_SOME: [&str; 4] = [\"core\", \"option\", \"Option\", \"Some\"];\n pub const ORD: [&str; 3] = [\"core\", \"cmp\", \"Ord\"];\n pub const OS_STRING_AS_OS_STR: [&str; 5] = [\"std\", \"ffi\", \"os_str\", \"OsString\", \"as_os_str\"];\n pub const OS_STR_TO_OS_STRING: [&str; 5] = [\"std\", \"ffi\", \"os_str\", \"OsStr\", \"to_os_string\"];\n-pub const PARKING_LOT_RAWMUTEX: [&str; 3] = [\"parking_lot\", \"raw_mutex\", \"RawMutex\"];\n-pub const PARKING_LOT_RAWRWLOCK: [&str; 3] = [\"parking_lot\", \"raw_rwlock\", \"RawRwLock\"];\n pub const PARKING_LOT_MUTEX_GUARD: [&str; 3] = [\"lock_api\", \"mutex\", \"MutexGuard\"];\n pub const PARKING_LOT_RWLOCK_READ_GUARD: [&str; 3] = [\"lock_api\", \"rwlock\", \"RwLockReadGuard\"];\n pub const PARKING_LOT_RWLOCK_WRITE_GUARD: [&str; 3] = [\"lock_api\", \"rwlock\", \"RwLockWriteGuard\"];\n@@ -144,6 +150,7 @@ pub const SLICE_FROM_RAW_PARTS: [&str; 4] = [\"core\", \"slice\", \"raw\", \"from_raw_p\n pub const SLICE_FROM_RAW_PARTS_MUT: [&str; 4] = [\"core\", \"slice\", \"raw\", \"from_raw_parts_mut\"];\n pub const SLICE_GET: [&str; 4] = [\"core\", \"slice\", \"<impl [T]>\", \"get\"];\n pub const SLICE_INTO_VEC: [&str; 4] = [\"alloc\", \"slice\", \"<impl [T]>\", \"into_vec\"];\n+pub const SLICE_INTO: [&str; 4] = [\"core\", \"slice\", \"<impl [T]>\", \"iter\"];\n pub const SLICE_ITER: [&str; 4] = [\"core\", \"slice\", \"iter\", \"Iter\"];\n pub const STDERR: [&str; 4] = [\"std\", \"io\", \"stdio\", \"stderr\"];\n pub const STDOUT: [&str; 4] = [\"std\", \"io\", \"stdio\", \"stdout\"];\n@@ -153,6 +160,7 @@ pub const STRING_AS_MUT_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"as_mut_s\n pub const STRING_AS_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"as_str\"];\n pub const STRING_NEW: [&str; 4] = [\"alloc\", \"string\", \"String\", \"new\"];\n pub const STR_BYTES: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"bytes\"];\n+pub const STR_CHARS: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"chars\"];\n pub const STR_ENDS_WITH: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"ends_with\"];\n pub const STR_FROM_UTF8: [&str; 4] = [\"core\", \"str\", \"converts\", \"from_utf8\"];\n pub const STR_LEN: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"len\"];\n@@ -178,6 +186,7 @@ pub const TOKIO_IO_ASYNCWRITEEXT: [&str; 5] = [\"tokio\", \"io\", \"util\", \"async_wri\n pub const TRY_FROM: [&str; 4] = [\"core\", \"convert\", \"TryFrom\", \"try_from\"];\n pub const VEC_AS_MUT_SLICE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"as_mut_slice\"];\n pub const VEC_AS_SLICE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"as_slice\"];\n+pub const VEC_DEQUE_ITER: [&str; 5] = [\"alloc\", \"collections\", \"vec_deque\", \"VecDeque\", \"iter\"];\n pub const VEC_FROM_ELEM: [&str; 3] = [\"alloc\", \"vec\", \"from_elem\"];\n pub const VEC_NEW: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"new\"];\n pub const VEC_RESIZE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"resize\"];"}, {"sha": "6ca36eed4e654b7c8144a1ce618ad45b43f19944", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 194, "deletions": 72, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -2,19 +2,20 @@\n \n #![allow(clippy::module_name_repetitions)]\n \n+use core::ops::ControlFlow;\n use rustc_ast::ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorKind, DefKind, Res};\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::{Expr, LangItem, TyKind, Unsafety};\n+use rustc_hir::{Expr, FnDecl, LangItem, TyKind, Unsafety};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::mir::interpret::{ConstValue, Scalar};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n use rustc_middle::ty::{\n-    self, AdtDef, Binder, FnSig, IntTy, ParamEnv, Predicate, PredicateKind, Ty, TyCtxt, TypeFoldable, UintTy,\n-    VariantDiscr,\n+    self, AdtDef, Binder, BoundRegion, DefIdTree, FnSig, IntTy, ParamEnv, Predicate, PredicateKind, ProjectionTy,\n+    Region, RegionKind, Ty, TyCtxt, TypeFoldable, TypeSuperFoldable, TypeVisitor, UintTy, VariantDef, VariantDiscr,\n };\n use rustc_span::symbol::Ident;\n use rustc_span::{sym, Span, Symbol, DUMMY_SP};\n@@ -501,24 +502,54 @@ pub fn all_predicates_of(tcx: TyCtxt<'_>, id: DefId) -> impl Iterator<Item = &(P\n #[derive(Clone, Copy)]\n pub enum ExprFnSig<'tcx> {\n     Sig(Binder<'tcx, FnSig<'tcx>>),\n-    Closure(Binder<'tcx, FnSig<'tcx>>),\n+    Closure(Option<&'tcx FnDecl<'tcx>>, Binder<'tcx, FnSig<'tcx>>),\n     Trait(Binder<'tcx, Ty<'tcx>>, Option<Binder<'tcx, Ty<'tcx>>>),\n }\n impl<'tcx> ExprFnSig<'tcx> {\n-    /// Gets the argument type at the given offset.\n-    pub fn input(self, i: usize) -> Binder<'tcx, Ty<'tcx>> {\n+    /// Gets the argument type at the given offset. This will return `None` when the index is out of\n+    /// bounds only for variadic functions, otherwise this will panic.\n+    pub fn input(self, i: usize) -> Option<Binder<'tcx, Ty<'tcx>>> {\n         match self {\n-            Self::Sig(sig) => sig.input(i),\n-            Self::Closure(sig) => sig.input(0).map_bound(|ty| ty.tuple_fields()[i]),\n-            Self::Trait(inputs, _) => inputs.map_bound(|ty| ty.tuple_fields()[i]),\n+            Self::Sig(sig) => {\n+                if sig.c_variadic() {\n+                    sig.inputs().map_bound(|inputs| inputs.get(i).copied()).transpose()\n+                } else {\n+                    Some(sig.input(i))\n+                }\n+            },\n+            Self::Closure(_, sig) => Some(sig.input(0).map_bound(|ty| ty.tuple_fields()[i])),\n+            Self::Trait(inputs, _) => Some(inputs.map_bound(|ty| ty.tuple_fields()[i])),\n+        }\n+    }\n+\n+    /// Gets the argument type at the given offset. For closures this will also get the type as\n+    /// written. This will return `None` when the index is out of bounds only for variadic\n+    /// functions, otherwise this will panic.\n+    pub fn input_with_hir(self, i: usize) -> Option<(Option<&'tcx hir::Ty<'tcx>>, Binder<'tcx, Ty<'tcx>>)> {\n+        match self {\n+            Self::Sig(sig) => {\n+                if sig.c_variadic() {\n+                    sig.inputs()\n+                        .map_bound(|inputs| inputs.get(i).copied())\n+                        .transpose()\n+                        .map(|arg| (None, arg))\n+                } else {\n+                    Some((None, sig.input(i)))\n+                }\n+            },\n+            Self::Closure(decl, sig) => Some((\n+                decl.and_then(|decl| decl.inputs.get(i)),\n+                sig.input(0).map_bound(|ty| ty.tuple_fields()[i]),\n+            )),\n+            Self::Trait(inputs, _) => Some((None, inputs.map_bound(|ty| ty.tuple_fields()[i]))),\n         }\n     }\n \n     /// Gets the result type, if one could be found. Note that the result type of a trait may not be\n     /// specified.\n     pub fn output(self) -> Option<Binder<'tcx, Ty<'tcx>>> {\n         match self {\n-            Self::Sig(sig) | Self::Closure(sig) => Some(sig.output()),\n+            Self::Sig(sig) | Self::Closure(_, sig) => Some(sig.output()),\n             Self::Trait(_, output) => output,\n         }\n     }\n@@ -529,74 +560,123 @@ pub fn expr_sig<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> Option<ExprFnS\n     if let Res::Def(DefKind::Fn | DefKind::Ctor(_, CtorKind::Fn) | DefKind::AssocFn, id) = path_res(cx, expr) {\n         Some(ExprFnSig::Sig(cx.tcx.fn_sig(id)))\n     } else {\n-        let ty = cx.typeck_results().expr_ty_adjusted(expr).peel_refs();\n-        match *ty.kind() {\n-            ty::Closure(_, subs) => Some(ExprFnSig::Closure(subs.as_closure().sig())),\n-            ty::FnDef(id, subs) => Some(ExprFnSig::Sig(cx.tcx.bound_fn_sig(id).subst(cx.tcx, subs))),\n-            ty::FnPtr(sig) => Some(ExprFnSig::Sig(sig)),\n-            ty::Dynamic(bounds, _) => {\n-                let lang_items = cx.tcx.lang_items();\n-                match bounds.principal() {\n-                    Some(bound)\n-                        if Some(bound.def_id()) == lang_items.fn_trait()\n-                            || Some(bound.def_id()) == lang_items.fn_once_trait()\n-                            || Some(bound.def_id()) == lang_items.fn_mut_trait() =>\n-                    {\n-                        let output = bounds\n-                            .projection_bounds()\n-                            .find(|p| lang_items.fn_once_output().map_or(false, |id| id == p.item_def_id()))\n-                            .map(|p| p.map_bound(|p| p.term.ty().expect(\"return type was a const\")));\n-                        Some(ExprFnSig::Trait(bound.map_bound(|b| b.substs.type_at(0)), output))\n-                    },\n-                    _ => None,\n+        ty_sig(cx, cx.typeck_results().expr_ty_adjusted(expr).peel_refs())\n+    }\n+}\n+\n+fn ty_sig<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<ExprFnSig<'tcx>> {\n+    match *ty.kind() {\n+        ty::Closure(id, subs) => {\n+            let decl = id\n+                .as_local()\n+                .and_then(|id| cx.tcx.hir().fn_decl_by_hir_id(cx.tcx.hir().local_def_id_to_hir_id(id)));\n+            Some(ExprFnSig::Closure(decl, subs.as_closure().sig()))\n+        },\n+        ty::FnDef(id, subs) => Some(ExprFnSig::Sig(cx.tcx.bound_fn_sig(id).subst(cx.tcx, subs))),\n+        ty::FnPtr(sig) => Some(ExprFnSig::Sig(sig)),\n+        ty::Dynamic(bounds, _) => {\n+            let lang_items = cx.tcx.lang_items();\n+            match bounds.principal() {\n+                Some(bound)\n+                    if Some(bound.def_id()) == lang_items.fn_trait()\n+                        || Some(bound.def_id()) == lang_items.fn_once_trait()\n+                        || Some(bound.def_id()) == lang_items.fn_mut_trait() =>\n+                {\n+                    let output = bounds\n+                        .projection_bounds()\n+                        .find(|p| lang_items.fn_once_output().map_or(false, |id| id == p.item_def_id()))\n+                        .map(|p| p.map_bound(|p| p.term.ty().unwrap()));\n+                    Some(ExprFnSig::Trait(bound.map_bound(|b| b.substs.type_at(0)), output))\n+                },\n+                _ => None,\n+            }\n+        },\n+        ty::Projection(proj) => match cx.tcx.try_normalize_erasing_regions(cx.param_env, ty) {\n+            Ok(normalized_ty) if normalized_ty != ty => ty_sig(cx, normalized_ty),\n+            _ => sig_for_projection(cx, proj).or_else(|| sig_from_bounds(cx, ty)),\n+        },\n+        ty::Param(_) => sig_from_bounds(cx, ty),\n+        _ => None,\n+    }\n+}\n+\n+fn sig_from_bounds<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<ExprFnSig<'tcx>> {\n+    let mut inputs = None;\n+    let mut output = None;\n+    let lang_items = cx.tcx.lang_items();\n+\n+    for (pred, _) in all_predicates_of(cx.tcx, cx.typeck_results().hir_owner.to_def_id()) {\n+        match pred.kind().skip_binder() {\n+            PredicateKind::Trait(p)\n+                if (lang_items.fn_trait() == Some(p.def_id())\n+                    || lang_items.fn_mut_trait() == Some(p.def_id())\n+                    || lang_items.fn_once_trait() == Some(p.def_id()))\n+                    && p.self_ty() == ty =>\n+            {\n+                if inputs.is_some() {\n+                    // Multiple different fn trait impls. Is this even allowed?\n+                    return None;\n                 }\n+                inputs = Some(pred.kind().rebind(p.trait_ref.substs.type_at(1)));\n             },\n-            ty::Param(_) | ty::Projection(..) => {\n-                let mut inputs = None;\n-                let mut output = None;\n-                let lang_items = cx.tcx.lang_items();\n-\n-                for (pred, _) in all_predicates_of(cx.tcx, cx.typeck_results().hir_owner.to_def_id()) {\n-                    let mut is_input = false;\n-                    if let Some(ty) = pred\n-                        .kind()\n-                        .map_bound(|pred| match pred {\n-                            PredicateKind::Trait(p)\n-                                if (lang_items.fn_trait() == Some(p.def_id())\n-                                    || lang_items.fn_mut_trait() == Some(p.def_id())\n-                                    || lang_items.fn_once_trait() == Some(p.def_id()))\n-                                    && p.self_ty() == ty =>\n-                            {\n-                                is_input = true;\n-                                Some(p.trait_ref.substs.type_at(1))\n-                            },\n-                            PredicateKind::Projection(p)\n-                                if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output()\n-                                    && p.projection_ty.self_ty() == ty =>\n-                            {\n-                                is_input = false;\n-                                p.term.ty()\n-                            },\n-                            _ => None,\n-                        })\n-                        .transpose()\n-                    {\n-                        if is_input && inputs.is_none() {\n-                            inputs = Some(ty);\n-                        } else if !is_input && output.is_none() {\n-                            output = Some(ty);\n-                        } else {\n-                            // Multiple different fn trait impls. Is this even allowed?\n-                            return None;\n-                        }\n-                    }\n+            PredicateKind::Projection(p)\n+                if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output()\n+                    && p.projection_ty.self_ty() == ty =>\n+            {\n+                if output.is_some() {\n+                    // Multiple different fn trait impls. Is this even allowed?\n+                    return None;\n                 }\n+                output = Some(pred.kind().rebind(p.term.ty().unwrap()));\n+            },\n+            _ => (),\n+        }\n+    }\n+\n+    inputs.map(|ty| ExprFnSig::Trait(ty, output))\n+}\n+\n+fn sig_for_projection<'tcx>(cx: &LateContext<'tcx>, ty: ProjectionTy<'tcx>) -> Option<ExprFnSig<'tcx>> {\n+    let mut inputs = None;\n+    let mut output = None;\n+    let lang_items = cx.tcx.lang_items();\n \n-                inputs.map(|ty| ExprFnSig::Trait(ty, output))\n+    for pred in cx\n+        .tcx\n+        .bound_explicit_item_bounds(ty.item_def_id)\n+        .transpose_iter()\n+        .map(|x| x.map_bound(|(p, _)| p))\n+    {\n+        match pred.0.kind().skip_binder() {\n+            PredicateKind::Trait(p)\n+                if (lang_items.fn_trait() == Some(p.def_id())\n+                    || lang_items.fn_mut_trait() == Some(p.def_id())\n+                    || lang_items.fn_once_trait() == Some(p.def_id())) =>\n+            {\n+                if inputs.is_some() {\n+                    // Multiple different fn trait impls. Is this even allowed?\n+                    return None;\n+                }\n+                inputs = Some(\n+                    pred.map_bound(|pred| pred.kind().rebind(p.trait_ref.substs.type_at(1)))\n+                        .subst(cx.tcx, ty.substs),\n+                );\n             },\n-            _ => None,\n+            PredicateKind::Projection(p) if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output() => {\n+                if output.is_some() {\n+                    // Multiple different fn trait impls. Is this even allowed?\n+                    return None;\n+                }\n+                output = Some(\n+                    pred.map_bound(|pred| pred.kind().rebind(p.term.ty().unwrap()))\n+                        .subst(cx.tcx, ty.substs),\n+                );\n+            },\n+            _ => (),\n         }\n     }\n+\n+    inputs.map(|ty| ExprFnSig::Trait(ty, output))\n }\n \n #[derive(Clone, Copy)]\n@@ -667,3 +747,45 @@ pub fn is_c_void(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n         false\n     }\n }\n+\n+pub fn for_each_top_level_late_bound_region<B>(\n+    ty: Ty<'_>,\n+    f: impl FnMut(BoundRegion) -> ControlFlow<B>,\n+) -> ControlFlow<B> {\n+    struct V<F> {\n+        index: u32,\n+        f: F,\n+    }\n+    impl<'tcx, B, F: FnMut(BoundRegion) -> ControlFlow<B>> TypeVisitor<'tcx> for V<F> {\n+        type BreakTy = B;\n+        fn visit_region(&mut self, r: Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            if let RegionKind::ReLateBound(idx, bound) = r.kind() && idx.as_u32() == self.index {\n+                (self.f)(bound)\n+            } else {\n+                ControlFlow::Continue(())\n+            }\n+        }\n+        fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<'tcx, T>) -> ControlFlow<Self::BreakTy> {\n+            self.index += 1;\n+            let res = t.super_visit_with(self);\n+            self.index -= 1;\n+            res\n+        }\n+    }\n+    ty.visit_with(&mut V { index: 0, f })\n+}\n+\n+/// Gets the struct or enum variant from the given `Res`\n+pub fn variant_of_res<'tcx>(cx: &LateContext<'tcx>, res: Res) -> Option<&'tcx VariantDef> {\n+    match res {\n+        Res::Def(DefKind::Struct, id) => Some(cx.tcx.adt_def(id).non_enum_variant()),\n+        Res::Def(DefKind::Variant, id) => Some(cx.tcx.adt_def(cx.tcx.parent(id)).variant_with_id(id)),\n+        Res::Def(DefKind::Ctor(CtorOf::Struct, _), id) => Some(cx.tcx.adt_def(cx.tcx.parent(id)).non_enum_variant()),\n+        Res::Def(DefKind::Ctor(CtorOf::Variant, _), id) => {\n+            let var_id = cx.tcx.parent(id);\n+            Some(cx.tcx.adt_def(cx.tcx.parent(var_id)).variant_with_id(var_id))\n+        },\n+        Res::SelfCtor(id) => Some(cx.tcx.type_of(id).ty_adt_def().unwrap().non_enum_variant()),\n+        _ => None,\n+    }\n+}"}, {"sha": "68cfa8c1aa8ec22e5a96a53e473759943cd018fa", "filename": "src/tools/clippy/clippy_utils/src/visitors.rs", "status": "modified", "additions": 127, "deletions": 4, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fvisitors.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,16 +1,18 @@\n+use crate::ty::needs_ordered_drop;\n use crate::{get_enclosing_block, path_to_local_id};\n use core::ops::ControlFlow;\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::intravisit::{self, walk_block, walk_expr, Visitor};\n use rustc_hir::{\n-    Arm, Block, BlockCheckMode, Body, BodyId, Expr, ExprKind, HirId, ItemId, ItemKind, Stmt, UnOp, UnsafeSource,\n-    Unsafety,\n+    Arm, Block, BlockCheckMode, Body, BodyId, Expr, ExprKind, HirId, ItemId, ItemKind, Let, QPath, Stmt, UnOp,\n+    UnsafeSource, Unsafety,\n };\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::ty;\n+use rustc_middle::ty::adjustment::Adjust;\n+use rustc_middle::ty::{self, Ty, TypeckResults};\n \n /// Convenience method for creating a `Visitor` with just `visit_expr` overridden and nested\n /// bodies (i.e. closures) are visited.\n@@ -494,3 +496,124 @@ pub fn for_each_local_use_after_expr<'tcx, B>(\n         ControlFlow::Continue(())\n     }\n }\n+\n+// Calls the given function for every unconsumed temporary created by the expression. Note the\n+// function is only guaranteed to be called for types which need to be dropped, but it may be called\n+// for other types.\n+pub fn for_each_unconsumed_temporary<'tcx, B>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'tcx>,\n+    mut f: impl FnMut(Ty<'tcx>) -> ControlFlow<B>,\n+) -> ControlFlow<B> {\n+    // Todo: Handle partially consumed values.\n+    fn helper<'tcx, B>(\n+        typeck: &'tcx TypeckResults<'tcx>,\n+        consume: bool,\n+        e: &'tcx Expr<'tcx>,\n+        f: &mut impl FnMut(Ty<'tcx>) -> ControlFlow<B>,\n+    ) -> ControlFlow<B> {\n+        if !consume\n+            || matches!(\n+                typeck.expr_adjustments(e),\n+                [adjust, ..] if matches!(adjust.kind, Adjust::Borrow(_) | Adjust::Deref(_))\n+            )\n+        {\n+            match e.kind {\n+                ExprKind::Path(QPath::Resolved(None, p))\n+                    if matches!(p.res, Res::Def(DefKind::Ctor(_, CtorKind::Const), _)) =>\n+                {\n+                    f(typeck.expr_ty(e))?;\n+                },\n+                ExprKind::Path(_)\n+                | ExprKind::Unary(UnOp::Deref, _)\n+                | ExprKind::Index(..)\n+                | ExprKind::Field(..)\n+                | ExprKind::AddrOf(..) => (),\n+                _ => f(typeck.expr_ty(e))?,\n+            }\n+        }\n+        match e.kind {\n+            ExprKind::AddrOf(_, _, e)\n+            | ExprKind::Field(e, _)\n+            | ExprKind::Unary(UnOp::Deref, e)\n+            | ExprKind::Match(e, ..)\n+            | ExprKind::Let(&Let { init: e, .. }) => {\n+                helper(typeck, false, e, f)?;\n+            },\n+            ExprKind::Block(&Block { expr: Some(e), .. }, _)\n+            | ExprKind::Box(e)\n+            | ExprKind::Cast(e, _)\n+            | ExprKind::Unary(_, e) => {\n+                helper(typeck, true, e, f)?;\n+            },\n+            ExprKind::Call(callee, args) => {\n+                helper(typeck, true, callee, f)?;\n+                for arg in args {\n+                    helper(typeck, true, arg, f)?;\n+                }\n+            },\n+            ExprKind::MethodCall(_, args, _) | ExprKind::Tup(args) | ExprKind::Array(args) => {\n+                for arg in args {\n+                    helper(typeck, true, arg, f)?;\n+                }\n+            },\n+            ExprKind::Index(borrowed, consumed)\n+            | ExprKind::Assign(borrowed, consumed, _)\n+            | ExprKind::AssignOp(_, borrowed, consumed) => {\n+                helper(typeck, false, borrowed, f)?;\n+                helper(typeck, true, consumed, f)?;\n+            },\n+            ExprKind::Binary(_, lhs, rhs) => {\n+                helper(typeck, true, lhs, f)?;\n+                helper(typeck, true, rhs, f)?;\n+            },\n+            ExprKind::Struct(_, fields, default) => {\n+                for field in fields {\n+                    helper(typeck, true, field.expr, f)?;\n+                }\n+                if let Some(default) = default {\n+                    helper(typeck, false, default, f)?;\n+                }\n+            },\n+            ExprKind::If(cond, then, else_expr) => {\n+                helper(typeck, true, cond, f)?;\n+                helper(typeck, true, then, f)?;\n+                if let Some(else_expr) = else_expr {\n+                    helper(typeck, true, else_expr, f)?;\n+                }\n+            },\n+            ExprKind::Type(e, _) => {\n+                helper(typeck, consume, e, f)?;\n+            },\n+\n+            // Either drops temporaries, jumps out of the current expression, or has no sub expression.\n+            ExprKind::DropTemps(_)\n+            | ExprKind::Ret(_)\n+            | ExprKind::Break(..)\n+            | ExprKind::Yield(..)\n+            | ExprKind::Block(..)\n+            | ExprKind::Loop(..)\n+            | ExprKind::Repeat(..)\n+            | ExprKind::Lit(_)\n+            | ExprKind::ConstBlock(_)\n+            | ExprKind::Closure { .. }\n+            | ExprKind::Path(_)\n+            | ExprKind::Continue(_)\n+            | ExprKind::InlineAsm(_)\n+            | ExprKind::Err => (),\n+        }\n+        ControlFlow::Continue(())\n+    }\n+    helper(cx.typeck_results(), true, e, &mut f)\n+}\n+\n+pub fn any_temporaries_need_ordered_drop<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'tcx>) -> bool {\n+    for_each_unconsumed_temporary(cx, e, |ty| {\n+        if needs_ordered_drop(cx, ty) {\n+            ControlFlow::Break(())\n+        } else {\n+            ControlFlow::Continue(())\n+        }\n+    })\n+    .is_break()\n+}"}, {"sha": "6cc6d5036b379261f729c64128a5f4c68c604cf6", "filename": "src/tools/clippy/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Frust-toolchain?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-06-16\"\n+channel = \"nightly-2022-06-30\"\n components = [\"cargo\", \"llvm-tools-preview\", \"rust-src\", \"rust-std\", \"rustc\", \"rustc-dev\", \"rustfmt\"]"}, {"sha": "96d542cfe105223b59c13d7b57398de1d7e70d2e", "filename": "src/tools/clippy/src/driver.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -60,6 +60,7 @@ fn test_arg_value() {\n     assert_eq!(arg_value(args, \"--bar\", |p| p == \"foo\"), None);\n     assert_eq!(arg_value(args, \"--foobar\", |p| p == \"foo\"), None);\n     assert_eq!(arg_value(args, \"--foobar\", |p| p == \"123\"), Some(\"123\"));\n+    assert_eq!(arg_value(args, \"--foobar\", |p| p.contains(\"12\")), Some(\"123\"));\n     assert_eq!(arg_value(args, \"--foo\", |_| true), None);\n }\n \n@@ -152,7 +153,8 @@ You can use tool lints to allow or deny lints from your code, eg.:\n \n const BUG_REPORT_URL: &str = \"https://github.com/rust-lang/rust-clippy/issues/new\";\n \n-static ICE_HOOK: LazyLock<Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send + 'static>> = LazyLock::new(|| {\n+type PanicCallback = dyn Fn(&panic::PanicInfo<'_>) + Sync + Send + 'static;\n+static ICE_HOOK: LazyLock<Box<PanicCallback>> = LazyLock::new(|| {\n     let hook = panic::take_hook();\n     panic::set_hook(Box::new(|info| report_clippy_ice(info, BUG_REPORT_URL)));\n     hook\n@@ -334,15 +336,13 @@ pub fn main() {\n         // - IF Clippy is run on the main crate, not on deps (`!cap_lints_allow`) THEN\n         //    - IF `--no-deps` is not set (`!no_deps`) OR\n         //    - IF `--no-deps` is set and Clippy is run on the specified primary package\n-        let cap_lints_allow = arg_value(&orig_args, \"--cap-lints\", |val| val == \"allow\").is_some();\n+        let cap_lints_allow = arg_value(&orig_args, \"--cap-lints\", |val| val == \"allow\").is_some()\n+            && arg_value(&orig_args, \"--force-warn\", |val| val.contains(\"clippy::\")).is_none();\n         let in_primary_package = env::var(\"CARGO_PRIMARY_PACKAGE\").is_ok();\n \n         let clippy_enabled = !cap_lints_allow && (!no_deps || in_primary_package);\n         if clippy_enabled {\n             args.extend(clippy_args);\n-        }\n-\n-        if clippy_enabled {\n             rustc_driver::RunCompiler::new(&args, &mut ClippyCallbacks { clippy_args_var }).run()\n         } else {\n             rustc_driver::RunCompiler::new(&args, &mut RustcCallbacks { clippy_args_var }).run()"}, {"sha": "bf7a39edf4c91e72d1c8e2bd04417d173b7ba9fb", "filename": "src/tools/clippy/tests/compile-test.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -23,6 +23,7 @@ const RUN_INTERNAL_TESTS: bool = cfg!(feature = \"internal\");\n \n /// All crates used in UI tests are listed here\n static TEST_DEPENDENCIES: &[&str] = &[\n+    \"clippy_lints\",\n     \"clippy_utils\",\n     \"derive_new\",\n     \"futures\",\n@@ -41,6 +42,8 @@ static TEST_DEPENDENCIES: &[&str] = &[\n // Test dependencies may need an `extern crate` here to ensure that they show up\n // in the depinfo file (otherwise cargo thinks they are unused)\n #[allow(unused_extern_crates)]\n+extern crate clippy_lints;\n+#[allow(unused_extern_crates)]\n extern crate clippy_utils;\n #[allow(unused_extern_crates)]\n extern crate derive_new;\n@@ -124,7 +127,7 @@ fn base_config(test_dir: &str) -> compiletest::Config {\n     let mut config = compiletest::Config {\n         edition: Some(\"2021\".into()),\n         mode: TestMode::Ui,\n-        ..compiletest::Config::default()\n+        ..Default::default()\n     };\n \n     if let Ok(filters) = env::var(\"TESTNAME\") {\n@@ -280,6 +283,24 @@ fn run_ui_cargo() {\n                 }\n \n                 env::set_current_dir(&src_path)?;\n+\n+                let cargo_toml_path = case.path().join(\"Cargo.toml\");\n+                let cargo_content = fs::read(&cargo_toml_path)?;\n+                let cargo_parsed: toml::Value = toml::from_str(\n+                    std::str::from_utf8(&cargo_content).expect(\"`Cargo.toml` is not a valid utf-8 file!\"),\n+                )\n+                .expect(\"Can't parse `Cargo.toml`\");\n+\n+                let _g = VarGuard::set(\"CARGO_MANIFEST_DIR\", case.path());\n+                let _h = VarGuard::set(\n+                    \"CARGO_PKG_RUST_VERSION\",\n+                    cargo_parsed\n+                        .get(\"package\")\n+                        .and_then(|p| p.get(\"rust-version\"))\n+                        .and_then(toml::Value::as_str)\n+                        .unwrap_or(\"\"),\n+                );\n+\n                 for file in fs::read_dir(&src_path)? {\n                     let file = file?;\n                     if file.file_type()?.is_dir() {"}, {"sha": "73ec29c5803bda497ef4fbaf710da076f04affd3", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/fail_both_diff/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_both_diff%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_both_diff%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_both_diff%2FCargo.toml?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"fail-both-diff\"\n+version = \"0.1.0\"\n+rust-version = \"1.56\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]"}, {"sha": "abe19b3a00710b0df233e46ec068878c779c28ab", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/fail_both_diff/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_both_diff%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_both_diff%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_both_diff%2Fclippy.toml?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1 @@\n+msrv = \"1.59\""}, {"sha": "5b91d5508678f7c724c2e389ee7142d366fdfecf", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/fail_both_diff/src/main.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_both_diff%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_both_diff%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_both_diff%2Fsrc%2Fmain.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,11 @@\n+#![deny(clippy::use_self)]\n+\n+pub struct Foo;\n+\n+impl Foo {\n+    pub fn bar() -> Foo {\n+        Foo\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "9a7d802dc6d3a64ae041532679d4d6b0f1c7f520", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/fail_both_diff/src/main.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_both_diff%2Fsrc%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_both_diff%2Fsrc%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_both_diff%2Fsrc%2Fmain.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,16 @@\n+warning: the MSRV in `clippy.toml` and `Cargo.toml` differ; using `1.59.0` from `clippy.toml`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/main.rs:6:21\n+   |\n+LL |     pub fn bar() -> Foo {\n+   |                     ^^^ help: use the applicable keyword: `Self`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/main.rs:1:9\n+   |\n+LL | #![deny(clippy::use_self)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error; 1 warning emitted\n+"}, {"sha": "2d6d547e4fe3af7e69903ec0626659b2aba6b5b8", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/fail_both_same/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_both_same%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_both_same%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_both_same%2FCargo.toml?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"fail-both-same\"\n+version = \"0.1.0\"\n+rust-version = \"1.57.0\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]"}, {"sha": "5cccb362c14214d49481646949047565c12a3208", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/fail_both_same/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_both_same%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_both_same%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_both_same%2Fclippy.toml?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1 @@\n+msrv = \"1.57\""}, {"sha": "5b91d5508678f7c724c2e389ee7142d366fdfecf", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/fail_both_same/src/main.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_both_same%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_both_same%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_both_same%2Fsrc%2Fmain.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,11 @@\n+#![deny(clippy::use_self)]\n+\n+pub struct Foo;\n+\n+impl Foo {\n+    pub fn bar() -> Foo {\n+        Foo\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "a280e1bacdfdca063dae06c0edd6cf8a2f0ea52b", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/fail_both_same/src/main.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_both_same%2Fsrc%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_both_same%2Fsrc%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_both_same%2Fsrc%2Fmain.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,14 @@\n+error: unnecessary structure name repetition\n+  --> $DIR/main.rs:6:21\n+   |\n+LL |     pub fn bar() -> Foo {\n+   |                     ^^^ help: use the applicable keyword: `Self`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/main.rs:1:9\n+   |\n+LL | #![deny(clippy::use_self)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "36a53bd829d9eb0b8bc2c7137485df9508c6a389", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/fail_cargo/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_cargo%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_cargo%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_cargo%2FCargo.toml?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"fail-cargo\"\n+version = \"0.1.0\"\n+rust-version = \"1.56.1\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]"}, {"sha": "5b91d5508678f7c724c2e389ee7142d366fdfecf", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/fail_cargo/src/main.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_cargo%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_cargo%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_cargo%2Fsrc%2Fmain.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,11 @@\n+#![deny(clippy::use_self)]\n+\n+pub struct Foo;\n+\n+impl Foo {\n+    pub fn bar() -> Foo {\n+        Foo\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "a280e1bacdfdca063dae06c0edd6cf8a2f0ea52b", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/fail_cargo/src/main.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_cargo%2Fsrc%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_cargo%2Fsrc%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_cargo%2Fsrc%2Fmain.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,14 @@\n+error: unnecessary structure name repetition\n+  --> $DIR/main.rs:6:21\n+   |\n+LL |     pub fn bar() -> Foo {\n+   |                     ^^^ help: use the applicable keyword: `Self`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/main.rs:1:9\n+   |\n+LL | #![deny(clippy::use_self)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "9f644a1a39a50b0f428ea6eed535602fb2ff940a", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/fail_clippy/Cargo.toml", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_clippy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_clippy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_clippy%2FCargo.toml?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,7 @@\n+[package]\n+name = \"fail-clippy\"\n+version = \"0.1.0\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]"}, {"sha": "ddbdbc1fa25907fec3d4a0ce50e64cb3e56b3d4a", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/fail_clippy/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_clippy%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_clippy%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_clippy%2Fclippy.toml?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1 @@\n+msrv = \"1.58\""}, {"sha": "5b91d5508678f7c724c2e389ee7142d366fdfecf", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/fail_clippy/src/main.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_clippy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_clippy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_clippy%2Fsrc%2Fmain.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,11 @@\n+#![deny(clippy::use_self)]\n+\n+pub struct Foo;\n+\n+impl Foo {\n+    pub fn bar() -> Foo {\n+        Foo\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "a280e1bacdfdca063dae06c0edd6cf8a2f0ea52b", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/fail_clippy/src/main.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_clippy%2Fsrc%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_clippy%2Fsrc%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_clippy%2Fsrc%2Fmain.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,14 @@\n+error: unnecessary structure name repetition\n+  --> $DIR/main.rs:6:21\n+   |\n+LL |     pub fn bar() -> Foo {\n+   |                     ^^^ help: use the applicable keyword: `Self`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/main.rs:1:9\n+   |\n+LL | #![deny(clippy::use_self)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "5380e993b29362c5c45aa0c73e26aef0fbb39cee", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/fail_file_attr/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_file_attr%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_file_attr%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_file_attr%2FCargo.toml?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"fail-file-attr\"\n+version = \"0.1.0\"\n+rust-version = \"1.13\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]"}, {"sha": "ea5d806594b5e05072fa400a7998879f078aad5b", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/fail_file_attr/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_file_attr%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_file_attr%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_file_attr%2Fclippy.toml?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1 @@\n+msrv = \"1.13.0\""}, {"sha": "bcbffa82a5417239aac706cbfa0dfe265d05165c", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/fail_file_attr/src/main.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_file_attr%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_file_attr%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_file_attr%2Fsrc%2Fmain.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,16 @@\n+// FIXME: this should produce a warning, because the attribute says 1.58 and the cargo.toml file\n+// says 1.13\n+\n+#![feature(custom_inner_attributes)]\n+#![clippy::msrv = \"1.58.0\"]\n+#![deny(clippy::use_self)]\n+\n+pub struct Foo;\n+\n+impl Foo {\n+    pub fn bar() -> Foo {\n+        Foo\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "88f6e00922bc4875acfdb9f199daa4951d9a5ffc", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/fail_file_attr/src/main.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_file_attr%2Fsrc%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_file_attr%2Fsrc%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Ffail_file_attr%2Fsrc%2Fmain.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,14 @@\n+error: unnecessary structure name repetition\n+  --> $DIR/main.rs:11:21\n+   |\n+LL |     pub fn bar() -> Foo {\n+   |                     ^^^ help: use the applicable keyword: `Self`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/main.rs:6:9\n+   |\n+LL | #![deny(clippy::use_self)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "1f9bd8f9a84e30595924aa2d996f71e9a561e5a8", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/pass_both_same/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_both_same%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_both_same%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_both_same%2FCargo.toml?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"fail-both-same\"\n+version = \"0.1.0\"\n+rust-version = \"1.13.0\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]"}, {"sha": "5e8e48b636b635f726f724af06a3067cfa646f88", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/pass_both_same/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_both_same%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_both_same%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_both_same%2Fclippy.toml?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1 @@\n+msrv = \"1.13\""}, {"sha": "5b91d5508678f7c724c2e389ee7142d366fdfecf", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/pass_both_same/src/main.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_both_same%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_both_same%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_both_same%2Fsrc%2Fmain.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,11 @@\n+#![deny(clippy::use_self)]\n+\n+pub struct Foo;\n+\n+impl Foo {\n+    pub fn bar() -> Foo {\n+        Foo\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "77538027c0f878ded2bf400f2b4213528a27aa87", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/pass_cargo/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_cargo%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_cargo%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_cargo%2FCargo.toml?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"fail-cargo\"\n+version = \"0.1.0\"\n+rust-version = \"1.13.0\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]"}, {"sha": "5b91d5508678f7c724c2e389ee7142d366fdfecf", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/pass_cargo/src/main.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_cargo%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_cargo%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_cargo%2Fsrc%2Fmain.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,11 @@\n+#![deny(clippy::use_self)]\n+\n+pub struct Foo;\n+\n+impl Foo {\n+    pub fn bar() -> Foo {\n+        Foo\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "9f644a1a39a50b0f428ea6eed535602fb2ff940a", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/pass_clippy/Cargo.toml", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_clippy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_clippy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_clippy%2FCargo.toml?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,7 @@\n+[package]\n+name = \"fail-clippy\"\n+version = \"0.1.0\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]"}, {"sha": "5e8e48b636b635f726f724af06a3067cfa646f88", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/pass_clippy/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_clippy%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_clippy%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_clippy%2Fclippy.toml?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1 @@\n+msrv = \"1.13\""}, {"sha": "5b91d5508678f7c724c2e389ee7142d366fdfecf", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/pass_clippy/src/main.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_clippy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_clippy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_clippy%2Fsrc%2Fmain.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,11 @@\n+#![deny(clippy::use_self)]\n+\n+pub struct Foo;\n+\n+impl Foo {\n+    pub fn bar() -> Foo {\n+        Foo\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "f0387cd90b80f9e63ffa400b74a82fc145c13883", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/pass_file_attr/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_file_attr%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_file_attr%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_file_attr%2FCargo.toml?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"fail-file-attr\"\n+version = \"0.1.0\"\n+rust-version = \"1.59\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]"}, {"sha": "27fe4771d2d6b9a3f651f359fe9effafd0b25f5b", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/pass_file_attr/src/main.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_file_attr%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_file_attr%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fpass_file_attr%2Fsrc%2Fmain.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,13 @@\n+#![feature(custom_inner_attributes)]\n+#![clippy::msrv = \"1.13.0\"]\n+#![deny(clippy::use_self)]\n+\n+pub struct Foo;\n+\n+impl Foo {\n+    pub fn bar() -> Foo {\n+        Foo\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "a19d5b33fe563e22e864f7c5f49efa019b33755f", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/warn_both_diff/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fwarn_both_diff%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fwarn_both_diff%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fwarn_both_diff%2FCargo.toml?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"warn-both-diff\"\n+version = \"0.1.0\"\n+rust-version = \"1.56.0\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]"}, {"sha": "5e8e48b636b635f726f724af06a3067cfa646f88", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/warn_both_diff/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fwarn_both_diff%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fwarn_both_diff%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fwarn_both_diff%2Fclippy.toml?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1 @@\n+msrv = \"1.13\""}, {"sha": "5b91d5508678f7c724c2e389ee7142d366fdfecf", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/warn_both_diff/src/main.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fwarn_both_diff%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fwarn_both_diff%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fwarn_both_diff%2Fsrc%2Fmain.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,11 @@\n+#![deny(clippy::use_self)]\n+\n+pub struct Foo;\n+\n+impl Foo {\n+    pub fn bar() -> Foo {\n+        Foo\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "eeae5b7b275e9678c503b3cce83015a4a8718ed0", "filename": "src/tools/clippy/tests/ui-cargo/cargo_rust_version/warn_both_diff/src/main.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fwarn_both_diff%2Fsrc%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fwarn_both_diff%2Fsrc%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_rust_version%2Fwarn_both_diff%2Fsrc%2Fmain.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,4 @@\n+warning: the MSRV in `clippy.toml` and `Cargo.toml` differ; using `1.13.0` from `clippy.toml`\n+\n+warning: 1 warning emitted\n+"}, {"sha": "98697e001f99a69a0dd5ab6e467793127e8fc7ab", "filename": "src/tools/clippy/tests/ui-cargo/multiple_config_files/warn/src/main.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_config_files%2Fwarn%2Fsrc%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_config_files%2Fwarn%2Fsrc%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_config_files%2Fwarn%2Fsrc%2Fmain.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,2 +1,2 @@\n-Using config file `$SRC_DIR/tests/ui-cargo/multiple_config_files/warn/.clippy.toml`\n-Warning: `$SRC_DIR/tests/ui-cargo/multiple_config_files/warn/clippy.toml` will be ignored.\n+Using config file `$SRC_DIR/.clippy.toml`\n+Warning: `$SRC_DIR/clippy.toml` will be ignored."}, {"sha": "9f299d7dec720b51f2c4df8ba2fd7faa3095e165", "filename": "src/tools/clippy/tests/ui-internal/collapsible_span_lint_calls.fixed", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Fcollapsible_span_lint_calls.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Fcollapsible_span_lint_calls.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Fcollapsible_span_lint_calls.fixed?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -45,7 +45,12 @@ impl EarlyLintPass for Pass {\n             if predicate {\n                 db.note(note_msg);\n             }\n-        })\n+        });\n+\n+        // Issue #8798\n+        span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |db| {\n+            db.help(help_msg).help(help_msg);\n+        });\n     }\n }\n "}, {"sha": "2b113f555e46bf38fed4ef19eccfc7214cd5a924", "filename": "src/tools/clippy/tests/ui-internal/collapsible_span_lint_calls.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Fcollapsible_span_lint_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Fcollapsible_span_lint_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Fcollapsible_span_lint_calls.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -55,7 +55,12 @@ impl EarlyLintPass for Pass {\n             if predicate {\n                 db.note(note_msg);\n             }\n-        })\n+        });\n+\n+        // Issue #8798\n+        span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |db| {\n+            db.help(help_msg).help(help_msg);\n+        });\n     }\n }\n "}, {"sha": "c8961d5e1f0bd6fc8780707c23f690176787bab0", "filename": "src/tools/clippy/tests/ui-internal/default_deprecation_reason.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Fdefault_deprecation_reason.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Fdefault_deprecation_reason.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Fdefault_deprecation_reason.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,30 @@\n+#![deny(clippy::internal)]\n+#![feature(rustc_private)]\n+\n+#[macro_use]\n+extern crate clippy_lints;\n+use clippy_lints::deprecated_lints::ClippyDeprecatedLint;\n+\n+declare_deprecated_lint! {\n+    /// ### What it does\n+    /// Nothing. This lint has been deprecated.\n+    ///\n+    /// ### Deprecation reason\n+    /// TODO\n+    #[clippy::version = \"1.63.0\"]\n+    pub COOL_LINT_DEFAULT,\n+    \"default deprecation note\"\n+}\n+\n+declare_deprecated_lint! {\n+    /// ### What it does\n+    /// Nothing. This lint has been deprecated.\n+    ///\n+    /// ### Deprecation reason\n+    /// This lint has been replaced by `cooler_lint`\n+    #[clippy::version = \"1.63.0\"]\n+    pub COOL_LINT,\n+    \"this lint has been replaced by `cooler_lint`\"\n+}\n+\n+fn main() {}"}, {"sha": "ca26b649f986a6ca8d880f4dade94605b1941b2b", "filename": "src/tools/clippy/tests/ui-internal/default_deprecation_reason.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Fdefault_deprecation_reason.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Fdefault_deprecation_reason.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Fdefault_deprecation_reason.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,22 @@\n+error: the lint `COOL_LINT_DEFAULT` has the default deprecation reason\n+  --> $DIR/default_deprecation_reason.rs:8:1\n+   |\n+LL | / declare_deprecated_lint! {\n+LL | |     /// ### What it does\n+LL | |     /// Nothing. This lint has been deprecated.\n+LL | |     ///\n+...  |\n+LL | |     \"default deprecation note\"\n+LL | | }\n+   | |_^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/default_deprecation_reason.rs:1:9\n+   |\n+LL | #![deny(clippy::internal)]\n+   |         ^^^^^^^^^^^^^^^^\n+   = note: `#[deny(clippy::default_deprecation_reason)]` implied by `#[deny(clippy::internal)]`\n+   = note: this error originates in the macro `declare_deprecated_lint` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+"}, {"sha": "5bd2c2799f03683cab8c787f8a5c827616e12bfc", "filename": "src/tools/clippy/tests/ui/auxiliary/macro_rules.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fmacro_rules.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -127,3 +127,11 @@ macro_rules! ptr_as_ptr_cast {\n         $ptr as *const i32\n     };\n }\n+\n+#[macro_export]\n+macro_rules! manual_rem_euclid {\n+    () => {\n+        let value: i32 = 5;\n+        let _: i32 = ((value % 4) + 4) % 4;\n+    };\n+}"}, {"sha": "a89a06308d093a6e7cfef00df57ce43992ec9210", "filename": "src/tools/clippy/tests/ui/auxiliary/proc_macro_derive.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fproc_macro_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fproc_macro_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauxiliary%2Fproc_macro_derive.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -72,3 +72,17 @@ pub fn mini_macro(_: TokenStream) -> TokenStream {\n         }\n     )\n }\n+\n+#[proc_macro_derive(ExtraLifetimeDerive)]\n+#[allow(unused)]\n+pub fn extra_lifetime(_input: TokenStream) -> TokenStream {\n+    quote!(\n+        pub struct ExtraLifetime;\n+\n+        impl<'b> ExtraLifetime {\n+            pub fn something<'c>() -> Self {\n+                Self\n+            }\n+        }\n+    )\n+}"}, {"sha": "4639f00a8d83018670156e3a6d9f56a16996f2a4", "filename": "src/tools/clippy/tests/ui/boxed_local.rs", "status": "renamed", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fboxed_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fboxed_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fboxed_local.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,4 +1,5 @@\n #![feature(box_syntax)]\n+#![feature(lint_reasons)]\n #![allow(\n     clippy::borrowed_box,\n     clippy::needless_pass_by_value,\n@@ -202,3 +203,7 @@ mod issue4804 {\n         fn foo(x: Box<u32>) {}\n     }\n }\n+\n+fn check_expect(#[expect(clippy::boxed_local)] x: Box<A>) {\n+    x.foo();\n+}", "previous_filename": "src/tools/clippy/tests/ui/escape_analysis.rs"}, {"sha": "9036529f39c519c6043320c7982366f36614ffe1", "filename": "src/tools/clippy/tests/ui/boxed_local.stderr", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fboxed_local.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fboxed_local.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fboxed_local.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,25 +1,25 @@\n error: local variable doesn't need to be boxed here\n-  --> $DIR/escape_analysis.rs:40:13\n+  --> $DIR/boxed_local.rs:41:13\n    |\n LL | fn warn_arg(x: Box<A>) {\n    |             ^\n    |\n    = note: `-D clippy::boxed-local` implied by `-D warnings`\n \n error: local variable doesn't need to be boxed here\n-  --> $DIR/escape_analysis.rs:131:12\n+  --> $DIR/boxed_local.rs:132:12\n    |\n LL | pub fn new(_needs_name: Box<PeekableSeekable<&()>>) -> () {}\n    |            ^^^^^^^^^^^\n \n error: local variable doesn't need to be boxed here\n-  --> $DIR/escape_analysis.rs:195:44\n+  --> $DIR/boxed_local.rs:196:44\n    |\n LL |         fn default_impl_x(self: Box<Self>, x: Box<u32>) -> u32 {\n    |                                            ^\n \n error: local variable doesn't need to be boxed here\n-  --> $DIR/escape_analysis.rs:202:16\n+  --> $DIR/boxed_local.rs:203:16\n    |\n LL |         fn foo(x: Box<u32>) {}\n    |                ^", "previous_filename": "src/tools/clippy/tests/ui/escape_analysis.stderr"}, {"sha": "82dce81979fd9d906230acc53f557470331aab52", "filename": "src/tools/clippy/tests/ui/checked_unwrap/simple_conditionals.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,3 +1,4 @@\n+#![feature(lint_reasons)]\n #![deny(clippy::panicking_unwrap, clippy::unnecessary_unwrap)]\n #![allow(clippy::if_same_then_else, clippy::branches_sharing_code)]\n \n@@ -84,3 +85,18 @@ fn main() {\n \n     assert!(x.is_ok(), \"{:?}\", x.unwrap_err()); // ok, it's a common test pattern\n }\n+\n+fn check_expect() {\n+    let x = Some(());\n+    if x.is_some() {\n+        #[expect(clippy::unnecessary_unwrap)]\n+        x.unwrap(); // unnecessary\n+        #[expect(clippy::unnecessary_unwrap)]\n+        x.expect(\"an error message\"); // unnecessary\n+    } else {\n+        #[expect(clippy::panicking_unwrap)]\n+        x.unwrap(); // will panic\n+        #[expect(clippy::panicking_unwrap)]\n+        x.expect(\"an error message\"); // will panic\n+    }\n+}"}, {"sha": "ef68827422233e2de992d615c047802bf23cbdad", "filename": "src/tools/clippy/tests/ui/checked_unwrap/simple_conditionals.stderr", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,19 +1,19 @@\n error: called `unwrap` on `x` after checking its variant with `is_some`\n-  --> $DIR/simple_conditionals.rs:39:9\n+  --> $DIR/simple_conditionals.rs:40:9\n    |\n LL |     if x.is_some() {\n    |     -------------- help: try: `if let Some(..) = x`\n LL |         x.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n    |\n note: the lint level is defined here\n-  --> $DIR/simple_conditionals.rs:1:35\n+  --> $DIR/simple_conditionals.rs:2:35\n    |\n LL | #![deny(clippy::panicking_unwrap, clippy::unnecessary_unwrap)]\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `expect` on `x` after checking its variant with `is_some`\n-  --> $DIR/simple_conditionals.rs:40:9\n+  --> $DIR/simple_conditionals.rs:41:9\n    |\n LL |     if x.is_some() {\n    |     -------------- help: try: `if let Some(..) = x`\n@@ -22,7 +22,7 @@ LL |         x.expect(\"an error message\"); // unnecessary\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this call to `unwrap()` will always panic\n-  --> $DIR/simple_conditionals.rs:42:9\n+  --> $DIR/simple_conditionals.rs:43:9\n    |\n LL |     if x.is_some() {\n    |        ----------- because of this check\n@@ -31,13 +31,13 @@ LL |         x.unwrap(); // will panic\n    |         ^^^^^^^^^^\n    |\n note: the lint level is defined here\n-  --> $DIR/simple_conditionals.rs:1:9\n+  --> $DIR/simple_conditionals.rs:2:9\n    |\n LL | #![deny(clippy::panicking_unwrap, clippy::unnecessary_unwrap)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this call to `expect()` will always panic\n-  --> $DIR/simple_conditionals.rs:43:9\n+  --> $DIR/simple_conditionals.rs:44:9\n    |\n LL |     if x.is_some() {\n    |        ----------- because of this check\n@@ -46,15 +46,15 @@ LL |         x.expect(\"an error message\"); // will panic\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this call to `unwrap()` will always panic\n-  --> $DIR/simple_conditionals.rs:46:9\n+  --> $DIR/simple_conditionals.rs:47:9\n    |\n LL |     if x.is_none() {\n    |        ----------- because of this check\n LL |         x.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n error: called `unwrap` on `x` after checking its variant with `is_none`\n-  --> $DIR/simple_conditionals.rs:48:9\n+  --> $DIR/simple_conditionals.rs:49:9\n    |\n LL |     if x.is_none() {\n    |     -------------- help: try: `if let Some(..) = x`\n@@ -63,7 +63,7 @@ LL |         x.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n \n error: called `unwrap` on `x` after checking its variant with `is_some`\n-  --> $DIR/simple_conditionals.rs:7:13\n+  --> $DIR/simple_conditionals.rs:8:13\n    |\n LL |         if $a.is_some() {\n    |         --------------- help: try: `if let Some(..) = x`\n@@ -76,15 +76,15 @@ LL |     m!(x);\n    = note: this error originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: called `unwrap` on `x` after checking its variant with `is_ok`\n-  --> $DIR/simple_conditionals.rs:56:9\n+  --> $DIR/simple_conditionals.rs:57:9\n    |\n LL |     if x.is_ok() {\n    |     ------------ help: try: `if let Ok(..) = x`\n LL |         x.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n \n error: called `expect` on `x` after checking its variant with `is_ok`\n-  --> $DIR/simple_conditionals.rs:57:9\n+  --> $DIR/simple_conditionals.rs:58:9\n    |\n LL |     if x.is_ok() {\n    |     ------------ help: try: `if let Ok(..) = x`\n@@ -93,7 +93,7 @@ LL |         x.expect(\"an error message\"); // unnecessary\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this call to `unwrap_err()` will always panic\n-  --> $DIR/simple_conditionals.rs:58:9\n+  --> $DIR/simple_conditionals.rs:59:9\n    |\n LL |     if x.is_ok() {\n    |        --------- because of this check\n@@ -102,7 +102,7 @@ LL |         x.unwrap_err(); // will panic\n    |         ^^^^^^^^^^^^^^\n \n error: this call to `unwrap()` will always panic\n-  --> $DIR/simple_conditionals.rs:60:9\n+  --> $DIR/simple_conditionals.rs:61:9\n    |\n LL |     if x.is_ok() {\n    |        --------- because of this check\n@@ -111,7 +111,7 @@ LL |         x.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n error: this call to `expect()` will always panic\n-  --> $DIR/simple_conditionals.rs:61:9\n+  --> $DIR/simple_conditionals.rs:62:9\n    |\n LL |     if x.is_ok() {\n    |        --------- because of this check\n@@ -120,7 +120,7 @@ LL |         x.expect(\"an error message\"); // will panic\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `unwrap_err` on `x` after checking its variant with `is_ok`\n-  --> $DIR/simple_conditionals.rs:62:9\n+  --> $DIR/simple_conditionals.rs:63:9\n    |\n LL |     if x.is_ok() {\n    |     ------------ help: try: `if let Err(..) = x`\n@@ -129,15 +129,15 @@ LL |         x.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n \n error: this call to `unwrap()` will always panic\n-  --> $DIR/simple_conditionals.rs:65:9\n+  --> $DIR/simple_conditionals.rs:66:9\n    |\n LL |     if x.is_err() {\n    |        ---------- because of this check\n LL |         x.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n error: called `unwrap_err` on `x` after checking its variant with `is_err`\n-  --> $DIR/simple_conditionals.rs:66:9\n+  --> $DIR/simple_conditionals.rs:67:9\n    |\n LL |     if x.is_err() {\n    |     ------------- help: try: `if let Err(..) = x`\n@@ -146,7 +146,7 @@ LL |         x.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n \n error: called `unwrap` on `x` after checking its variant with `is_err`\n-  --> $DIR/simple_conditionals.rs:68:9\n+  --> $DIR/simple_conditionals.rs:69:9\n    |\n LL |     if x.is_err() {\n    |     ------------- help: try: `if let Ok(..) = x`\n@@ -155,7 +155,7 @@ LL |         x.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n \n error: this call to `unwrap_err()` will always panic\n-  --> $DIR/simple_conditionals.rs:69:9\n+  --> $DIR/simple_conditionals.rs:70:9\n    |\n LL |     if x.is_err() {\n    |        ---------- because of this check"}, {"sha": "62af545db503b73651a8ea973ce10e830df3c1f4", "filename": "src/tools/clippy/tests/ui/declare_interior_mutable_const/others.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdeclare_interior_mutable_const%2Fothers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdeclare_interior_mutable_const%2Fothers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdeclare_interior_mutable_const%2Fothers.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -31,4 +31,9 @@ const NO_ANN: &dyn Display = &70;\n static STATIC_TUPLE: (AtomicUsize, String) = (ATOMIC, STRING);\n //^ there should be no lints on this line\n \n+// issue #8493\n+thread_local! {\n+    static THREAD_LOCAL: Cell<i32> = const { Cell::new(0) };\n+}\n+\n fn main() {}"}, {"sha": "f1abfdcd6ce69406a065b0fdbde61eca82ec23b5", "filename": "src/tools/clippy/tests/ui/default_instead_of_iter_empty.fixed", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_instead_of_iter_empty.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_instead_of_iter_empty.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_instead_of_iter_empty.fixed?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,21 @@\n+// run-rustfix\n+#![warn(clippy::default_instead_of_iter_empty)]\n+#![allow(dead_code)]\n+use std::collections::HashMap;\n+\n+#[derive(Default)]\n+struct Iter {\n+    iter: std::iter::Empty<usize>,\n+}\n+\n+fn main() {\n+    // Do lint.\n+    let _ = std::iter::empty::<usize>();\n+    let _ = std::iter::empty::<HashMap<usize, usize>>();\n+    let _foo: std::iter::Empty<usize> = std::iter::empty();\n+\n+    // Do not lint.\n+    let _ = Vec::<usize>::default();\n+    let _ = String::default();\n+    let _ = Iter::default();\n+}"}, {"sha": "2630519c46da4677db9a92504dd0fef1dcd380e7", "filename": "src/tools/clippy/tests/ui/default_instead_of_iter_empty.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_instead_of_iter_empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_instead_of_iter_empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_instead_of_iter_empty.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,21 @@\n+// run-rustfix\n+#![warn(clippy::default_instead_of_iter_empty)]\n+#![allow(dead_code)]\n+use std::collections::HashMap;\n+\n+#[derive(Default)]\n+struct Iter {\n+    iter: std::iter::Empty<usize>,\n+}\n+\n+fn main() {\n+    // Do lint.\n+    let _ = std::iter::Empty::<usize>::default();\n+    let _ = std::iter::Empty::<HashMap<usize, usize>>::default();\n+    let _foo: std::iter::Empty<usize> = std::iter::Empty::default();\n+\n+    // Do not lint.\n+    let _ = Vec::<usize>::default();\n+    let _ = String::default();\n+    let _ = Iter::default();\n+}"}, {"sha": "460fc84def8a525e23f0e0022219c46dd60391a3", "filename": "src/tools/clippy/tests/ui/default_instead_of_iter_empty.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_instead_of_iter_empty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_instead_of_iter_empty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_instead_of_iter_empty.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,22 @@\n+error: `std::iter::empty()` is the more idiomatic way\n+  --> $DIR/default_instead_of_iter_empty.rs:13:13\n+   |\n+LL |     let _ = std::iter::Empty::<usize>::default();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `std::iter::empty::<usize>()`\n+   |\n+   = note: `-D clippy::default-instead-of-iter-empty` implied by `-D warnings`\n+\n+error: `std::iter::empty()` is the more idiomatic way\n+  --> $DIR/default_instead_of_iter_empty.rs:14:13\n+   |\n+LL |     let _ = std::iter::Empty::<HashMap<usize, usize>>::default();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `std::iter::empty::<HashMap<usize, usize>>()`\n+\n+error: `std::iter::empty()` is the more idiomatic way\n+  --> $DIR/default_instead_of_iter_empty.rs:15:41\n+   |\n+LL |     let _foo: std::iter::Empty<usize> = std::iter::Empty::default();\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `std::iter::empty()`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "efed12ee2ef6f68314960764475205c2dce63bc4", "filename": "src/tools/clippy/tests/ui/enum_variants.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fenum_variants.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -158,4 +158,25 @@ enum Phase {\n     PostLookup,\n }\n \n+mod issue9018 {\n+    enum DoLint {\n+        _TypeCreate,\n+        _TypeRead,\n+        _TypeUpdate,\n+        _TypeDestroy,\n+    }\n+\n+    enum DoLintToo {\n+        _CreateType,\n+        _UpdateType,\n+        _DeleteType,\n+    }\n+\n+    enum DoNotLint {\n+        _Foo,\n+        _Bar,\n+        _Baz,\n+    }\n+}\n+\n fn main() {}"}, {"sha": "7342aff80f0167ed11cbd4549a7408b99299af96", "filename": "src/tools/clippy/tests/ui/enum_variants.stderr", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fenum_variants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fenum_variants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fenum_variants.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -120,5 +120,30 @@ LL | | }\n    |\n    = help: remove the postfixes and use full paths to the variants instead of glob imports\n \n-error: aborting due to 12 previous errors\n+error: all variants have the same prefix: `_Type`\n+  --> $DIR/enum_variants.rs:162:5\n+   |\n+LL | /     enum DoLint {\n+LL | |         _TypeCreate,\n+LL | |         _TypeRead,\n+LL | |         _TypeUpdate,\n+LL | |         _TypeDestroy,\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: remove the prefixes and use full paths to the variants instead of glob imports\n+\n+error: all variants have the same postfix: `Type`\n+  --> $DIR/enum_variants.rs:169:5\n+   |\n+LL | /     enum DoLintToo {\n+LL | |         _CreateType,\n+LL | |         _UpdateType,\n+LL | |         _DeleteType,\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: remove the postfixes and use full paths to the variants instead of glob imports\n+\n+error: aborting due to 14 previous errors\n "}, {"sha": "d4ff1b1566dc613bd50d9c46e1f3c5ccdb4d5b64", "filename": "src/tools/clippy/tests/ui/explicit_auto_deref.fixed", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_auto_deref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_auto_deref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_auto_deref.fixed?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,214 @@\n+// run-rustfix\n+\n+#![warn(clippy::explicit_auto_deref)]\n+#![allow(\n+    dead_code,\n+    unused_braces,\n+    clippy::borrowed_box,\n+    clippy::needless_borrow,\n+    clippy::needless_return,\n+    clippy::ptr_arg,\n+    clippy::redundant_field_names,\n+    clippy::too_many_arguments,\n+    clippy::borrow_deref_ref,\n+    clippy::let_unit_value\n+)]\n+\n+trait CallableStr {\n+    type T: Fn(&str);\n+    fn callable_str(&self) -> Self::T;\n+}\n+impl CallableStr for () {\n+    type T = fn(&str);\n+    fn callable_str(&self) -> Self::T {\n+        fn f(_: &str) {}\n+        f\n+    }\n+}\n+impl CallableStr for i32 {\n+    type T = <() as CallableStr>::T;\n+    fn callable_str(&self) -> Self::T {\n+        ().callable_str()\n+    }\n+}\n+\n+trait CallableT<U: ?Sized> {\n+    type T: Fn(&U);\n+    fn callable_t(&self) -> Self::T;\n+}\n+impl<U: ?Sized> CallableT<U> for () {\n+    type T = fn(&U);\n+    fn callable_t(&self) -> Self::T {\n+        fn f<U: ?Sized>(_: &U) {}\n+        f::<U>\n+    }\n+}\n+impl<U: ?Sized> CallableT<U> for i32 {\n+    type T = <() as CallableT<U>>::T;\n+    fn callable_t(&self) -> Self::T {\n+        ().callable_t()\n+    }\n+}\n+\n+fn f_str(_: &str) {}\n+fn f_string(_: &String) {}\n+fn f_t<T>(_: T) {}\n+fn f_ref_t<T: ?Sized>(_: &T) {}\n+\n+fn f_str_t<T>(_: &str, _: T) {}\n+\n+fn f_box_t<T>(_: &Box<T>) {}\n+\n+extern \"C\" {\n+    fn var(_: u32, ...);\n+}\n+\n+fn main() {\n+    let s = String::new();\n+\n+    let _: &str = &s;\n+    let _ = &*s; // Don't lint. Inferred type would change.\n+    let _: &_ = &*s; // Don't lint. Inferred type would change.\n+\n+    f_str(&s);\n+    f_t(&*s); // Don't lint. Inferred type would change.\n+    f_ref_t(&*s); // Don't lint. Inferred type would change.\n+\n+    f_str_t(&s, &*s); // Don't lint second param.\n+\n+    let b = Box::new(Box::new(Box::new(5)));\n+    let _: &Box<i32> = &b;\n+    let _: &Box<_> = &**b; // Don't lint. Inferred type would change.\n+\n+    f_box_t(&**b); // Don't lint. Inferred type would change.\n+\n+    let c = |_x: &str| ();\n+    c(&s);\n+\n+    let c = |_x| ();\n+    c(&*s); // Don't lint. Inferred type would change.\n+\n+    fn _f(x: &String) -> &str {\n+        x\n+    }\n+\n+    fn _f1(x: &String) -> &str {\n+        { x }\n+    }\n+\n+    fn _f2(x: &String) -> &str {\n+        { x }\n+    }\n+\n+    fn _f3(x: &Box<Box<Box<i32>>>) -> &Box<i32> {\n+        x\n+    }\n+\n+    fn _f4(\n+        x: String,\n+        f1: impl Fn(&str),\n+        f2: &dyn Fn(&str),\n+        f3: fn(&str),\n+        f4: impl CallableStr,\n+        f5: <() as CallableStr>::T,\n+        f6: <i32 as CallableStr>::T,\n+        f7: &dyn CallableStr<T = fn(&str)>,\n+        f8: impl CallableT<str>,\n+        f9: <() as CallableT<str>>::T,\n+        f10: <i32 as CallableT<str>>::T,\n+        f11: &dyn CallableT<str, T = fn(&str)>,\n+    ) {\n+        f1(&x);\n+        f2(&x);\n+        f3(&x);\n+        f4.callable_str()(&x);\n+        f5(&x);\n+        f6(&x);\n+        f7.callable_str()(&x);\n+        f8.callable_t()(&x);\n+        f9(&x);\n+        f10(&x);\n+        f11.callable_t()(&x);\n+    }\n+\n+    struct S1<'a>(&'a str);\n+    let _ = S1(&s);\n+\n+    struct S2<'a> {\n+        s: &'a str,\n+    }\n+    let _ = S2 { s: &s };\n+\n+    struct S3<'a, T: ?Sized>(&'a T);\n+    let _ = S3(&*s); // Don't lint. Inferred type would change.\n+\n+    struct S4<'a, T: ?Sized> {\n+        s: &'a T,\n+    }\n+    let _ = S4 { s: &*s }; // Don't lint. Inferred type would change.\n+\n+    enum E1<'a> {\n+        S1(&'a str),\n+        S2 { s: &'a str },\n+    }\n+    impl<'a> E1<'a> {\n+        fn m1(s: &'a String) {\n+            let _ = Self::S1(s);\n+            let _ = Self::S2 { s: s };\n+        }\n+    }\n+    let _ = E1::S1(&s);\n+    let _ = E1::S2 { s: &s };\n+\n+    enum E2<'a, T: ?Sized> {\n+        S1(&'a T),\n+        S2 { s: &'a T },\n+    }\n+    let _ = E2::S1(&*s); // Don't lint. Inferred type would change.\n+    let _ = E2::S2 { s: &*s }; // Don't lint. Inferred type would change.\n+\n+    let ref_s = &s;\n+    let _: &String = &*ref_s; // Don't lint reborrow.\n+    f_string(&*ref_s); // Don't lint reborrow.\n+\n+    struct S5 {\n+        foo: u32,\n+    }\n+    let b = Box::new(Box::new(S5 { foo: 5 }));\n+    let _ = b.foo;\n+    let _ = b.foo;\n+    let _ = b.foo;\n+\n+    struct S6 {\n+        foo: S5,\n+    }\n+    impl core::ops::Deref for S6 {\n+        type Target = S5;\n+        fn deref(&self) -> &Self::Target {\n+            &self.foo\n+        }\n+    }\n+    let s6 = S6 { foo: S5 { foo: 5 } };\n+    let _ = (*s6).foo; // Don't lint. `S6` also has a field named `foo`\n+\n+    let ref_str = &\"foo\";\n+    let _ = f_str(ref_str);\n+    let ref_ref_str = &ref_str;\n+    let _ = f_str(ref_ref_str);\n+\n+    fn _f5(x: &u32) -> u32 {\n+        if true {\n+            *x\n+        } else {\n+            return *x;\n+        }\n+    }\n+\n+    f_str(&&ref_str); // `needless_borrow` will suggest removing both references\n+    f_str(&ref_str); // `needless_borrow` will suggest removing only one reference\n+\n+    let x = &&40;\n+    unsafe {\n+        var(0, &**x);\n+    }\n+}"}, {"sha": "99294a7947bf16e8d24939434a085e1384fccbf6", "filename": "src/tools/clippy/tests/ui/explicit_auto_deref.rs", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_auto_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_auto_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_auto_deref.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,214 @@\n+// run-rustfix\n+\n+#![warn(clippy::explicit_auto_deref)]\n+#![allow(\n+    dead_code,\n+    unused_braces,\n+    clippy::borrowed_box,\n+    clippy::needless_borrow,\n+    clippy::needless_return,\n+    clippy::ptr_arg,\n+    clippy::redundant_field_names,\n+    clippy::too_many_arguments,\n+    clippy::borrow_deref_ref,\n+    clippy::let_unit_value\n+)]\n+\n+trait CallableStr {\n+    type T: Fn(&str);\n+    fn callable_str(&self) -> Self::T;\n+}\n+impl CallableStr for () {\n+    type T = fn(&str);\n+    fn callable_str(&self) -> Self::T {\n+        fn f(_: &str) {}\n+        f\n+    }\n+}\n+impl CallableStr for i32 {\n+    type T = <() as CallableStr>::T;\n+    fn callable_str(&self) -> Self::T {\n+        ().callable_str()\n+    }\n+}\n+\n+trait CallableT<U: ?Sized> {\n+    type T: Fn(&U);\n+    fn callable_t(&self) -> Self::T;\n+}\n+impl<U: ?Sized> CallableT<U> for () {\n+    type T = fn(&U);\n+    fn callable_t(&self) -> Self::T {\n+        fn f<U: ?Sized>(_: &U) {}\n+        f::<U>\n+    }\n+}\n+impl<U: ?Sized> CallableT<U> for i32 {\n+    type T = <() as CallableT<U>>::T;\n+    fn callable_t(&self) -> Self::T {\n+        ().callable_t()\n+    }\n+}\n+\n+fn f_str(_: &str) {}\n+fn f_string(_: &String) {}\n+fn f_t<T>(_: T) {}\n+fn f_ref_t<T: ?Sized>(_: &T) {}\n+\n+fn f_str_t<T>(_: &str, _: T) {}\n+\n+fn f_box_t<T>(_: &Box<T>) {}\n+\n+extern \"C\" {\n+    fn var(_: u32, ...);\n+}\n+\n+fn main() {\n+    let s = String::new();\n+\n+    let _: &str = &*s;\n+    let _ = &*s; // Don't lint. Inferred type would change.\n+    let _: &_ = &*s; // Don't lint. Inferred type would change.\n+\n+    f_str(&*s);\n+    f_t(&*s); // Don't lint. Inferred type would change.\n+    f_ref_t(&*s); // Don't lint. Inferred type would change.\n+\n+    f_str_t(&*s, &*s); // Don't lint second param.\n+\n+    let b = Box::new(Box::new(Box::new(5)));\n+    let _: &Box<i32> = &**b;\n+    let _: &Box<_> = &**b; // Don't lint. Inferred type would change.\n+\n+    f_box_t(&**b); // Don't lint. Inferred type would change.\n+\n+    let c = |_x: &str| ();\n+    c(&*s);\n+\n+    let c = |_x| ();\n+    c(&*s); // Don't lint. Inferred type would change.\n+\n+    fn _f(x: &String) -> &str {\n+        &**x\n+    }\n+\n+    fn _f1(x: &String) -> &str {\n+        { &**x }\n+    }\n+\n+    fn _f2(x: &String) -> &str {\n+        &**{ x }\n+    }\n+\n+    fn _f3(x: &Box<Box<Box<i32>>>) -> &Box<i32> {\n+        &***x\n+    }\n+\n+    fn _f4(\n+        x: String,\n+        f1: impl Fn(&str),\n+        f2: &dyn Fn(&str),\n+        f3: fn(&str),\n+        f4: impl CallableStr,\n+        f5: <() as CallableStr>::T,\n+        f6: <i32 as CallableStr>::T,\n+        f7: &dyn CallableStr<T = fn(&str)>,\n+        f8: impl CallableT<str>,\n+        f9: <() as CallableT<str>>::T,\n+        f10: <i32 as CallableT<str>>::T,\n+        f11: &dyn CallableT<str, T = fn(&str)>,\n+    ) {\n+        f1(&*x);\n+        f2(&*x);\n+        f3(&*x);\n+        f4.callable_str()(&*x);\n+        f5(&*x);\n+        f6(&*x);\n+        f7.callable_str()(&*x);\n+        f8.callable_t()(&*x);\n+        f9(&*x);\n+        f10(&*x);\n+        f11.callable_t()(&*x);\n+    }\n+\n+    struct S1<'a>(&'a str);\n+    let _ = S1(&*s);\n+\n+    struct S2<'a> {\n+        s: &'a str,\n+    }\n+    let _ = S2 { s: &*s };\n+\n+    struct S3<'a, T: ?Sized>(&'a T);\n+    let _ = S3(&*s); // Don't lint. Inferred type would change.\n+\n+    struct S4<'a, T: ?Sized> {\n+        s: &'a T,\n+    }\n+    let _ = S4 { s: &*s }; // Don't lint. Inferred type would change.\n+\n+    enum E1<'a> {\n+        S1(&'a str),\n+        S2 { s: &'a str },\n+    }\n+    impl<'a> E1<'a> {\n+        fn m1(s: &'a String) {\n+            let _ = Self::S1(&**s);\n+            let _ = Self::S2 { s: &**s };\n+        }\n+    }\n+    let _ = E1::S1(&*s);\n+    let _ = E1::S2 { s: &*s };\n+\n+    enum E2<'a, T: ?Sized> {\n+        S1(&'a T),\n+        S2 { s: &'a T },\n+    }\n+    let _ = E2::S1(&*s); // Don't lint. Inferred type would change.\n+    let _ = E2::S2 { s: &*s }; // Don't lint. Inferred type would change.\n+\n+    let ref_s = &s;\n+    let _: &String = &*ref_s; // Don't lint reborrow.\n+    f_string(&*ref_s); // Don't lint reborrow.\n+\n+    struct S5 {\n+        foo: u32,\n+    }\n+    let b = Box::new(Box::new(S5 { foo: 5 }));\n+    let _ = b.foo;\n+    let _ = (*b).foo;\n+    let _ = (**b).foo;\n+\n+    struct S6 {\n+        foo: S5,\n+    }\n+    impl core::ops::Deref for S6 {\n+        type Target = S5;\n+        fn deref(&self) -> &Self::Target {\n+            &self.foo\n+        }\n+    }\n+    let s6 = S6 { foo: S5 { foo: 5 } };\n+    let _ = (*s6).foo; // Don't lint. `S6` also has a field named `foo`\n+\n+    let ref_str = &\"foo\";\n+    let _ = f_str(*ref_str);\n+    let ref_ref_str = &ref_str;\n+    let _ = f_str(**ref_ref_str);\n+\n+    fn _f5(x: &u32) -> u32 {\n+        if true {\n+            *x\n+        } else {\n+            return *x;\n+        }\n+    }\n+\n+    f_str(&&*ref_str); // `needless_borrow` will suggest removing both references\n+    f_str(&&**ref_str); // `needless_borrow` will suggest removing only one reference\n+\n+    let x = &&40;\n+    unsafe {\n+        var(0, &**x);\n+    }\n+}"}, {"sha": "55f956e37aed77fb51d97e222658614a9e2ccff6", "filename": "src/tools/clippy/tests/ui/explicit_auto_deref.stderr", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_auto_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_auto_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_auto_deref.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,196 @@\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:69:20\n+   |\n+LL |     let _: &str = &*s;\n+   |                    ^^ help: try this: `s`\n+   |\n+   = note: `-D clippy::explicit-auto-deref` implied by `-D warnings`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:73:12\n+   |\n+LL |     f_str(&*s);\n+   |            ^^ help: try this: `s`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:77:14\n+   |\n+LL |     f_str_t(&*s, &*s); // Don't lint second param.\n+   |              ^^ help: try this: `s`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:80:25\n+   |\n+LL |     let _: &Box<i32> = &**b;\n+   |                         ^^^ help: try this: `b`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:86:8\n+   |\n+LL |     c(&*s);\n+   |        ^^ help: try this: `s`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:92:9\n+   |\n+LL |         &**x\n+   |         ^^^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:96:11\n+   |\n+LL |         { &**x }\n+   |           ^^^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:100:9\n+   |\n+LL |         &**{ x }\n+   |         ^^^^^^^^ help: try this: `{ x }`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:104:9\n+   |\n+LL |         &***x\n+   |         ^^^^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:121:13\n+   |\n+LL |         f1(&*x);\n+   |             ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:122:13\n+   |\n+LL |         f2(&*x);\n+   |             ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:123:13\n+   |\n+LL |         f3(&*x);\n+   |             ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:124:28\n+   |\n+LL |         f4.callable_str()(&*x);\n+   |                            ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:125:13\n+   |\n+LL |         f5(&*x);\n+   |             ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:126:13\n+   |\n+LL |         f6(&*x);\n+   |             ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:127:28\n+   |\n+LL |         f7.callable_str()(&*x);\n+   |                            ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:128:26\n+   |\n+LL |         f8.callable_t()(&*x);\n+   |                          ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:129:13\n+   |\n+LL |         f9(&*x);\n+   |             ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:130:14\n+   |\n+LL |         f10(&*x);\n+   |              ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:131:27\n+   |\n+LL |         f11.callable_t()(&*x);\n+   |                           ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:135:17\n+   |\n+LL |     let _ = S1(&*s);\n+   |                 ^^ help: try this: `s`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:140:22\n+   |\n+LL |     let _ = S2 { s: &*s };\n+   |                      ^^ help: try this: `s`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:156:30\n+   |\n+LL |             let _ = Self::S1(&**s);\n+   |                              ^^^^ help: try this: `s`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:157:35\n+   |\n+LL |             let _ = Self::S2 { s: &**s };\n+   |                                   ^^^^ help: try this: `s`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:160:21\n+   |\n+LL |     let _ = E1::S1(&*s);\n+   |                     ^^ help: try this: `s`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:161:26\n+   |\n+LL |     let _ = E1::S2 { s: &*s };\n+   |                          ^^ help: try this: `s`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:179:13\n+   |\n+LL |     let _ = (*b).foo;\n+   |             ^^^^ help: try this: `b`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:180:13\n+   |\n+LL |     let _ = (**b).foo;\n+   |             ^^^^^ help: try this: `b`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:195:19\n+   |\n+LL |     let _ = f_str(*ref_str);\n+   |                   ^^^^^^^^ help: try this: `ref_str`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:197:19\n+   |\n+LL |     let _ = f_str(**ref_ref_str);\n+   |                   ^^^^^^^^^^^^^ help: try this: `ref_ref_str`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:207:13\n+   |\n+LL |     f_str(&&*ref_str); // `needless_borrow` will suggest removing both references\n+   |             ^^^^^^^^ help: try this: `ref_str`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:208:12\n+   |\n+LL |     f_str(&&**ref_str); // `needless_borrow` will suggest removing only one reference\n+   |            ^^^^^^^^^^ help: try this: `ref_str`\n+\n+error: aborting due to 32 previous errors\n+"}, {"sha": "523cae183ee6ec27fac2400d22d128202b4b1b9d", "filename": "src/tools/clippy/tests/ui/explicit_deref_methods.fixed", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_deref_methods.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_deref_methods.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_deref_methods.fixed?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -4,7 +4,8 @@\n     unused_variables,\n     clippy::clone_double_ref,\n     clippy::needless_borrow,\n-    clippy::borrow_deref_ref\n+    clippy::borrow_deref_ref,\n+    clippy::explicit_auto_deref\n )]\n #![warn(clippy::explicit_deref_methods)]\n "}, {"sha": "0bbc1ae57cdf6dfc23eea738be3423db677a5dda", "filename": "src/tools/clippy/tests/ui/explicit_deref_methods.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_deref_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_deref_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_deref_methods.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -4,7 +4,8 @@\n     unused_variables,\n     clippy::clone_double_ref,\n     clippy::needless_borrow,\n-    clippy::borrow_deref_ref\n+    clippy::borrow_deref_ref,\n+    clippy::explicit_auto_deref\n )]\n #![warn(clippy::explicit_deref_methods)]\n "}, {"sha": "4b10ed1377b0dc46f6eaf955bb23cb423542b2ab", "filename": "src/tools/clippy/tests/ui/explicit_deref_methods.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_deref_methods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_deref_methods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_deref_methods.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,73 +1,73 @@\n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:35:19\n+  --> $DIR/explicit_deref_methods.rs:36:19\n    |\n LL |     let b: &str = a.deref();\n    |                   ^^^^^^^^^ help: try this: `&*a`\n    |\n    = note: `-D clippy::explicit-deref-methods` implied by `-D warnings`\n \n error: explicit `deref_mut` method call\n-  --> $DIR/explicit_deref_methods.rs:37:23\n+  --> $DIR/explicit_deref_methods.rs:38:23\n    |\n LL |     let b: &mut str = a.deref_mut();\n    |                       ^^^^^^^^^^^^^ help: try this: `&mut **a`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:40:39\n+  --> $DIR/explicit_deref_methods.rs:41:39\n    |\n LL |     let b: String = format!(\"{}, {}\", a.deref(), a.deref());\n    |                                       ^^^^^^^^^ help: try this: `&*a`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:40:50\n+  --> $DIR/explicit_deref_methods.rs:41:50\n    |\n LL |     let b: String = format!(\"{}, {}\", a.deref(), a.deref());\n    |                                                  ^^^^^^^^^ help: try this: `&*a`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:42:20\n+  --> $DIR/explicit_deref_methods.rs:43:20\n    |\n LL |     println!(\"{}\", a.deref());\n    |                    ^^^^^^^^^ help: try this: `&*a`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:45:11\n+  --> $DIR/explicit_deref_methods.rs:46:11\n    |\n LL |     match a.deref() {\n    |           ^^^^^^^^^ help: try this: `&*a`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:49:28\n+  --> $DIR/explicit_deref_methods.rs:50:28\n    |\n LL |     let b: String = concat(a.deref());\n    |                            ^^^^^^^^^ help: try this: `&*a`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:51:13\n+  --> $DIR/explicit_deref_methods.rs:52:13\n    |\n LL |     let b = just_return(a).deref();\n    |             ^^^^^^^^^^^^^^^^^^^^^^ help: try this: `just_return(a)`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:53:28\n+  --> $DIR/explicit_deref_methods.rs:54:28\n    |\n LL |     let b: String = concat(just_return(a).deref());\n    |                            ^^^^^^^^^^^^^^^^^^^^^^ help: try this: `just_return(a)`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:55:19\n+  --> $DIR/explicit_deref_methods.rs:56:19\n    |\n LL |     let b: &str = a.deref().deref();\n    |                   ^^^^^^^^^^^^^^^^^ help: try this: `&**a`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:58:13\n+  --> $DIR/explicit_deref_methods.rs:59:13\n    |\n LL |     let b = opt_a.unwrap().deref();\n    |             ^^^^^^^^^^^^^^^^^^^^^^ help: try this: `&*opt_a.unwrap()`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:84:31\n+  --> $DIR/explicit_deref_methods.rs:85:31\n    |\n LL |     let b: &str = expr_deref!(a.deref());\n    |                               ^^^^^^^^^ help: try this: `&*a`"}, {"sha": "d6631e01290009feee27ded294e324031b763be7", "filename": "src/tools/clippy/tests/ui/extra_unused_lifetimes.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fextra_unused_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fextra_unused_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fextra_unused_lifetimes.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,3 +1,5 @@\n+// aux-build:proc_macro_derive.rs\n+\n #![allow(\n     unused,\n     dead_code,\n@@ -7,6 +9,9 @@\n )]\n #![warn(clippy::extra_unused_lifetimes)]\n \n+#[macro_use]\n+extern crate proc_macro_derive;\n+\n fn empty() {}\n \n fn used_lt<'a>(x: &'a u8) {}\n@@ -114,4 +119,11 @@ mod second_case {\n     }\n }\n \n+// Should not lint\n+#[derive(ExtraLifetimeDerive)]\n+struct Human<'a> {\n+    pub bones: i32,\n+    pub name: &'a str,\n+}\n+\n fn main() {}"}, {"sha": "26ebc3976dfca222642cc1557c89a2ad1c3e0da0", "filename": "src/tools/clippy/tests/ui/extra_unused_lifetimes.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fextra_unused_lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fextra_unused_lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fextra_unused_lifetimes.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,37 +1,37 @@\n error: this lifetime isn't used in the function definition\n-  --> $DIR/extra_unused_lifetimes.rs:14:14\n+  --> $DIR/extra_unused_lifetimes.rs:19:14\n    |\n LL | fn unused_lt<'a>(x: u8) {}\n    |              ^^\n    |\n    = note: `-D clippy::extra-unused-lifetimes` implied by `-D warnings`\n \n error: this lifetime isn't used in the function definition\n-  --> $DIR/extra_unused_lifetimes.rs:41:10\n+  --> $DIR/extra_unused_lifetimes.rs:46:10\n    |\n LL |     fn x<'a>(&self) {}\n    |          ^^\n \n error: this lifetime isn't used in the function definition\n-  --> $DIR/extra_unused_lifetimes.rs:67:22\n+  --> $DIR/extra_unused_lifetimes.rs:72:22\n    |\n LL |         fn unused_lt<'a>(x: u8) {}\n    |                      ^^\n \n error: this lifetime isn't used in the impl\n-  --> $DIR/extra_unused_lifetimes.rs:78:10\n+  --> $DIR/extra_unused_lifetimes.rs:83:10\n    |\n LL |     impl<'a> std::ops::AddAssign<&Scalar> for &mut Scalar {\n    |          ^^\n \n error: this lifetime isn't used in the impl\n-  --> $DIR/extra_unused_lifetimes.rs:84:10\n+  --> $DIR/extra_unused_lifetimes.rs:89:10\n    |\n LL |     impl<'b> Scalar {\n    |          ^^\n \n error: this lifetime isn't used in the function definition\n-  --> $DIR/extra_unused_lifetimes.rs:85:26\n+  --> $DIR/extra_unused_lifetimes.rs:90:26\n    |\n LL |         pub fn something<'c>() -> Self {\n    |                          ^^"}, {"sha": "2598c2ab426d31fbf46d770da687bff9f2bcda2e", "filename": "src/tools/clippy/tests/ui/if_same_then_else.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_same_then_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_same_then_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_same_then_else.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -6,7 +6,9 @@\n     clippy::no_effect,\n     clippy::unused_unit,\n     clippy::zero_divided_by_zero,\n-    clippy::branches_sharing_code\n+    clippy::branches_sharing_code,\n+    dead_code,\n+    unreachable_code\n )]\n \n struct Foo {\n@@ -155,4 +157,61 @@ mod issue_5698 {\n     }\n }\n \n+mod issue_8836 {\n+    fn do_not_lint() {\n+        if true {\n+            todo!()\n+        } else {\n+            todo!()\n+        }\n+        if true {\n+            todo!();\n+        } else {\n+            todo!();\n+        }\n+        if true {\n+            unimplemented!()\n+        } else {\n+            unimplemented!()\n+        }\n+        if true {\n+            unimplemented!();\n+        } else {\n+            unimplemented!();\n+        }\n+\n+        if true {\n+            println!(\"FOO\");\n+            todo!();\n+        } else {\n+            println!(\"FOO\");\n+            todo!();\n+        }\n+\n+        if true {\n+            println!(\"FOO\");\n+            unimplemented!();\n+        } else {\n+            println!(\"FOO\");\n+            unimplemented!();\n+        }\n+\n+        if true {\n+            println!(\"FOO\");\n+            todo!()\n+        } else {\n+            println!(\"FOO\");\n+            todo!()\n+        }\n+\n+        if true {\n+            println!(\"FOO\");\n+            unimplemented!()\n+        } else {\n+            println!(\"FOO\");\n+            unimplemented!()\n+        }\n+    }\n+}\n+\n fn main() {}"}, {"sha": "2cdf442486a306334ea93c052ac421fe84a6b936", "filename": "src/tools/clippy/tests/ui/if_same_then_else.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_same_then_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_same_then_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fif_same_then_else.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,5 +1,5 @@\n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else.rs:21:13\n+  --> $DIR/if_same_then_else.rs:23:13\n    |\n LL |       if true {\n    |  _____________^\n@@ -13,7 +13,7 @@ LL | |     } else {\n    |\n    = note: `-D clippy::if-same-then-else` implied by `-D warnings`\n note: same as this\n-  --> $DIR/if_same_then_else.rs:29:12\n+  --> $DIR/if_same_then_else.rs:31:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -26,7 +26,7 @@ LL | |     }\n    | |_____^\n \n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else.rs:65:21\n+  --> $DIR/if_same_then_else.rs:67:21\n    |\n LL |       let _ = if true {\n    |  _____________________^\n@@ -35,7 +35,7 @@ LL | |     } else {\n    | |_____^\n    |\n note: same as this\n-  --> $DIR/if_same_then_else.rs:67:12\n+  --> $DIR/if_same_then_else.rs:69:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -45,7 +45,7 @@ LL | |     };\n    | |_____^\n \n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else.rs:72:21\n+  --> $DIR/if_same_then_else.rs:74:21\n    |\n LL |       let _ = if true {\n    |  _____________________^\n@@ -54,7 +54,7 @@ LL | |     } else {\n    | |_____^\n    |\n note: same as this\n-  --> $DIR/if_same_then_else.rs:74:12\n+  --> $DIR/if_same_then_else.rs:76:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -64,7 +64,7 @@ LL | |     };\n    | |_____^\n \n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else.rs:88:21\n+  --> $DIR/if_same_then_else.rs:90:21\n    |\n LL |       let _ = if true {\n    |  _____________________^\n@@ -73,7 +73,7 @@ LL | |     } else {\n    | |_____^\n    |\n note: same as this\n-  --> $DIR/if_same_then_else.rs:90:12\n+  --> $DIR/if_same_then_else.rs:92:12\n    |\n LL |       } else {\n    |  ____________^\n@@ -83,7 +83,7 @@ LL | |     };\n    | |_____^\n \n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else.rs:95:13\n+  --> $DIR/if_same_then_else.rs:97:13\n    |\n LL |       if true {\n    |  _____________^\n@@ -96,7 +96,7 @@ LL | |     } else {\n    | |_____^\n    |\n note: same as this\n-  --> $DIR/if_same_then_else.rs:102:12\n+  --> $DIR/if_same_then_else.rs:104:12\n    |\n LL |       } else {\n    |  ____________^"}, {"sha": "5e55b8b6739198d74b68dd706d80054528f9133b", "filename": "src/tools/clippy/tests/ui/implicit_return.fixed", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fimplicit_return.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fimplicit_return.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fimplicit_return.fixed?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-\n+#![feature(lint_reasons)]\n #![warn(clippy::implicit_return)]\n #![allow(clippy::needless_return, clippy::needless_bool, unused, clippy::never_loop)]\n \n@@ -128,3 +128,13 @@ async fn foo() -> bool {\n }\n \n fn main() {}\n+\n+fn check_expect() -> bool {\n+    if true {\n+        // no error!\n+        return true;\n+    }\n+\n+    #[expect(clippy::implicit_return)]\n+    true\n+}"}, {"sha": "76f0a98035209f63e1b33f5afa67fef1a91eb5f1", "filename": "src/tools/clippy/tests/ui/implicit_return.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fimplicit_return.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-\n+#![feature(lint_reasons)]\n #![warn(clippy::implicit_return)]\n #![allow(clippy::needless_return, clippy::needless_bool, unused, clippy::never_loop)]\n \n@@ -128,3 +128,13 @@ async fn foo() -> bool {\n }\n \n fn main() {}\n+\n+fn check_expect() -> bool {\n+    if true {\n+        // no error!\n+        return true;\n+    }\n+\n+    #[expect(clippy::implicit_return)]\n+    true\n+}"}, {"sha": "7a7c4e9249952911d17b70a3935b86bb166effc5", "filename": "src/tools/clippy/tests/ui/let_underscore_lock.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_underscore_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_underscore_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_underscore_lock.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -13,6 +13,10 @@ fn main() {\n     let _ = rw.try_read();\n     let _ = rw.try_write();\n \n+    // These shouldn't throw an error.\n+    let _ = m;\n+    let _ = rw;\n+\n     use parking_lot::{lock_api::RawMutex, Mutex, RwLock};\n \n     let p_m: Mutex<()> = Mutex::const_new(RawMutex::INIT, ());\n@@ -24,4 +28,9 @@ fn main() {\n     let p_rw = RwLock::new(0);\n     let _ = p_rw.read();\n     let _ = p_rw.write();\n+\n+    // These shouldn't throw an error.\n+    let _ = p_m;\n+    let _ = p_m1;\n+    let _ = p_rw;\n }"}, {"sha": "4365b48fabb9c676f7b779b11e79d81df36f366f", "filename": "src/tools/clippy/tests/ui/let_underscore_lock.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_underscore_lock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_underscore_lock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_underscore_lock.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -48,31 +48,31 @@ LL |     let _ = rw.try_write();\n    = help: consider using an underscore-prefixed named binding or dropping explicitly with `std::mem::drop`\n \n error: non-binding let on a synchronization lock\n-  --> $DIR/let_underscore_lock.rs:19:5\n+  --> $DIR/let_underscore_lock.rs:23:5\n    |\n LL |     let _ = p_m.lock();\n    |     ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider using an underscore-prefixed named binding or dropping explicitly with `std::mem::drop`\n \n error: non-binding let on a synchronization lock\n-  --> $DIR/let_underscore_lock.rs:22:5\n+  --> $DIR/let_underscore_lock.rs:26:5\n    |\n LL |     let _ = p_m1.lock();\n    |     ^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider using an underscore-prefixed named binding or dropping explicitly with `std::mem::drop`\n \n error: non-binding let on a synchronization lock\n-  --> $DIR/let_underscore_lock.rs:25:5\n+  --> $DIR/let_underscore_lock.rs:29:5\n    |\n LL |     let _ = p_rw.read();\n    |     ^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider using an underscore-prefixed named binding or dropping explicitly with `std::mem::drop`\n \n error: non-binding let on a synchronization lock\n-  --> $DIR/let_underscore_lock.rs:26:5\n+  --> $DIR/let_underscore_lock.rs:30:5\n    |\n LL |     let _ = p_rw.write();\n    |     ^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "dd6b1db5f70a0ed2cb50de66b676c24844defe9b", "filename": "src/tools/clippy/tests/ui/logic_bug.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flogic_bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flogic_bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flogic_bug.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,3 +1,4 @@\n+#![feature(lint_reasons)]\n #![allow(unused, clippy::diverging_sub_expression)]\n #![warn(clippy::logic_bug)]\n \n@@ -24,3 +25,10 @@ fn equality_stuff() {\n     let _ = a > b && a <= b;\n     let _ = a > b && a == b;\n }\n+\n+fn check_expect() {\n+    let a: i32 = unimplemented!();\n+    let b: i32 = unimplemented!();\n+    #[expect(clippy::logic_bug)]\n+    let _ = a < b && a >= b;\n+}"}, {"sha": "4021fbf45705324545b033c093050ec0de40cd42", "filename": "src/tools/clippy/tests/ui/logic_bug.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flogic_bug.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flogic_bug.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flogic_bug.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,60 +1,60 @@\n error: this boolean expression contains a logic bug\n-  --> $DIR/logic_bug.rs:10:13\n+  --> $DIR/logic_bug.rs:11:13\n    |\n LL |     let _ = a && b || a;\n    |             ^^^^^^^^^^^ help: it would look like the following: `a`\n    |\n    = note: `-D clippy::logic-bug` implied by `-D warnings`\n help: this expression can be optimized out by applying boolean operations to the outer expression\n-  --> $DIR/logic_bug.rs:10:18\n+  --> $DIR/logic_bug.rs:11:18\n    |\n LL |     let _ = a && b || a;\n    |                  ^\n \n error: this boolean expression contains a logic bug\n-  --> $DIR/logic_bug.rs:12:13\n+  --> $DIR/logic_bug.rs:13:13\n    |\n LL |     let _ = false && a;\n    |             ^^^^^^^^^^ help: it would look like the following: `false`\n    |\n help: this expression can be optimized out by applying boolean operations to the outer expression\n-  --> $DIR/logic_bug.rs:12:22\n+  --> $DIR/logic_bug.rs:13:22\n    |\n LL |     let _ = false && a;\n    |                      ^\n \n error: this boolean expression contains a logic bug\n-  --> $DIR/logic_bug.rs:22:13\n+  --> $DIR/logic_bug.rs:23:13\n    |\n LL |     let _ = a == b && a != b;\n    |             ^^^^^^^^^^^^^^^^ help: it would look like the following: `false`\n    |\n help: this expression can be optimized out by applying boolean operations to the outer expression\n-  --> $DIR/logic_bug.rs:22:13\n+  --> $DIR/logic_bug.rs:23:13\n    |\n LL |     let _ = a == b && a != b;\n    |             ^^^^^^\n \n error: this boolean expression contains a logic bug\n-  --> $DIR/logic_bug.rs:23:13\n+  --> $DIR/logic_bug.rs:24:13\n    |\n LL |     let _ = a < b && a >= b;\n    |             ^^^^^^^^^^^^^^^ help: it would look like the following: `false`\n    |\n help: this expression can be optimized out by applying boolean operations to the outer expression\n-  --> $DIR/logic_bug.rs:23:13\n+  --> $DIR/logic_bug.rs:24:13\n    |\n LL |     let _ = a < b && a >= b;\n    |             ^^^^^\n \n error: this boolean expression contains a logic bug\n-  --> $DIR/logic_bug.rs:24:13\n+  --> $DIR/logic_bug.rs:25:13\n    |\n LL |     let _ = a > b && a <= b;\n    |             ^^^^^^^^^^^^^^^ help: it would look like the following: `false`\n    |\n help: this expression can be optimized out by applying boolean operations to the outer expression\n-  --> $DIR/logic_bug.rs:24:13\n+  --> $DIR/logic_bug.rs:25:13\n    |\n LL |     let _ = a > b && a <= b;\n    |             ^^^^^"}, {"sha": "e612480d264bdbc5ecf7fe7219dc8fb555c66cd5", "filename": "src/tools/clippy/tests/ui/macro_use_imports.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmacro_use_imports.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmacro_use_imports.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmacro_use_imports.fixed?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -4,6 +4,7 @@\n // run-rustfix\n // ignore-32bit\n \n+#![feature(lint_reasons)]\n #![allow(unused_imports, unreachable_code, unused_variables, dead_code, unused_attributes)]\n #![allow(clippy::single_component_path_imports)]\n #![warn(clippy::macro_use_imports)]"}, {"sha": "b34817cc3b2696e2e939ce9de2cdd660185bce48", "filename": "src/tools/clippy/tests/ui/macro_use_imports.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmacro_use_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmacro_use_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmacro_use_imports.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -4,6 +4,7 @@\n // run-rustfix\n // ignore-32bit\n \n+#![feature(lint_reasons)]\n #![allow(unused_imports, unreachable_code, unused_variables, dead_code, unused_attributes)]\n #![allow(clippy::single_component_path_imports)]\n #![warn(clippy::macro_use_imports)]"}, {"sha": "bf7b6edd0e314732cc71a469a23dc0a130aaa394", "filename": "src/tools/clippy/tests/ui/macro_use_imports.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmacro_use_imports.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmacro_use_imports.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmacro_use_imports.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,28 +1,28 @@\n error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n-  --> $DIR/macro_use_imports.rs:18:5\n+  --> $DIR/macro_use_imports.rs:23:5\n    |\n LL |     #[macro_use]\n-   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::{pub_macro, function_macro, ty_macro, inner_mod_macro, pub_in_private_macro};`\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::{inner::foofoo, inner::try_err};`\n    |\n    = note: `-D clippy::macro-use-imports` implied by `-D warnings`\n \n error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n-  --> $DIR/macro_use_imports.rs:20:5\n+  --> $DIR/macro_use_imports.rs:21:5\n    |\n LL |     #[macro_use]\n    |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mini_mac::ClippyMiniMacroTest;`\n \n error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n-  --> $DIR/macro_use_imports.rs:22:5\n+  --> $DIR/macro_use_imports.rs:25:5\n    |\n LL |     #[macro_use]\n-   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::{inner::foofoo, inner::try_err};`\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::inner::nested::string_add;`\n \n error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n-  --> $DIR/macro_use_imports.rs:24:5\n+  --> $DIR/macro_use_imports.rs:19:5\n    |\n LL |     #[macro_use]\n-   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::inner::nested::string_add;`\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::{pub_macro, function_macro, ty_macro, inner_mod_macro, pub_in_private_macro};`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "8a1b05da9efc78231103984cfec6d253ee9e9e4f", "filename": "src/tools/clippy/tests/ui/macro_use_imports_expect.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmacro_use_imports_expect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmacro_use_imports_expect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmacro_use_imports_expect.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,51 @@\n+// aux-build:macro_rules.rs\n+// aux-build:macro_use_helper.rs\n+// aux-build:proc_macro_derive.rs\n+// ignore-32bit\n+\n+#![feature(lint_reasons)]\n+#![allow(unused_imports, unreachable_code, unused_variables, dead_code, unused_attributes)]\n+#![allow(clippy::single_component_path_imports)]\n+#![warn(clippy::macro_use_imports)]\n+\n+#[macro_use]\n+extern crate macro_use_helper as mac;\n+\n+#[macro_use]\n+extern crate proc_macro_derive as mini_mac;\n+\n+mod a {\n+    #[expect(clippy::macro_use_imports)]\n+    #[macro_use]\n+    use mac;\n+    #[expect(clippy::macro_use_imports)]\n+    #[macro_use]\n+    use mini_mac;\n+    #[expect(clippy::macro_use_imports)]\n+    #[macro_use]\n+    use mac::inner;\n+    #[expect(clippy::macro_use_imports)]\n+    #[macro_use]\n+    use mac::inner::nested;\n+\n+    #[derive(ClippyMiniMacroTest)]\n+    struct Test;\n+\n+    fn test() {\n+        pub_macro!();\n+        inner_mod_macro!();\n+        pub_in_private_macro!(_var);\n+        function_macro!();\n+        let v: ty_macro!() = Vec::default();\n+\n+        inner::try_err!();\n+        inner::foofoo!();\n+        nested::string_add!();\n+    }\n+}\n+\n+// issue #7015, ICE due to calling `module_children` with local `DefId`\n+#[macro_use]\n+use a as b;\n+\n+fn main() {}"}, {"sha": "257fe045f78a1d0d07f9724f184bb773c05f2bfd", "filename": "src/tools/clippy/tests/ui/manual_find.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_find.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_find.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_find.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,22 @@\n+#![allow(unused)]\n+#![warn(clippy::manual_find)]\n+\n+fn vec_string(strings: Vec<String>) -> Option<String> {\n+    for s in strings {\n+        if s == String::new() {\n+            return Some(s);\n+        }\n+    }\n+    None\n+}\n+\n+fn tuple(arr: Vec<(String, i32)>) -> Option<String> {\n+    for (s, _) in arr {\n+        if s == String::new() {\n+            return Some(s);\n+        }\n+    }\n+    None\n+}\n+\n+fn main() {}"}, {"sha": "da0fd4aaef7d6d47296145a61d987151e98a898b", "filename": "src/tools/clippy/tests/ui/manual_find.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_find.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_find.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_find.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,29 @@\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find.rs:5:5\n+   |\n+LL | /     for s in strings {\n+LL | |         if s == String::new() {\n+LL | |             return Some(s);\n+LL | |         }\n+LL | |     }\n+LL | |     None\n+   | |________^ help: replace with an iterator: `strings.into_iter().find(|s| s == String::new())`\n+   |\n+   = note: `-D clippy::manual-find` implied by `-D warnings`\n+   = note: you may need to dereference some variables\n+\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find.rs:14:5\n+   |\n+LL | /     for (s, _) in arr {\n+LL | |         if s == String::new() {\n+LL | |             return Some(s);\n+LL | |         }\n+LL | |     }\n+LL | |     None\n+   | |________^ help: replace with an iterator: `arr.into_iter().map(|(s, _)| s).find(|s| s == String::new())`\n+   |\n+   = note: you may need to dereference some variables\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "36d1644c22bdac4f2897be042e13ecba34d1420d", "filename": "src/tools/clippy/tests/ui/manual_find_fixable.fixed", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_find_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_find_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_find_fixable.fixed?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,182 @@\n+// run-rustfix\n+\n+#![allow(unused, clippy::needless_return)]\n+#![warn(clippy::manual_find)]\n+\n+use std::collections::HashMap;\n+\n+const ARRAY: &[u32; 5] = &[2, 7, 1, 9, 3];\n+\n+fn lookup(n: u32) -> Option<u32> {\n+    ARRAY.iter().find(|&&v| v == n).copied()\n+}\n+\n+fn with_pat(arr: Vec<(u32, u32)>) -> Option<u32> {\n+    arr.into_iter().map(|(a, _)| a).find(|&a| a % 2 == 0)\n+}\n+\n+struct Data {\n+    name: String,\n+    is_true: bool,\n+}\n+fn with_struct(arr: Vec<Data>) -> Option<Data> {\n+    arr.into_iter().find(|el| el.name.len() == 10)\n+}\n+\n+struct Tuple(usize, usize);\n+fn with_tuple_struct(arr: Vec<Tuple>) -> Option<usize> {\n+    arr.into_iter().map(|Tuple(a, _)| a).find(|&a| a >= 3)\n+}\n+\n+struct A;\n+impl A {\n+    fn should_keep(&self) -> bool {\n+        true\n+    }\n+}\n+fn with_method_call(arr: Vec<A>) -> Option<A> {\n+    arr.into_iter().find(|el| el.should_keep())\n+}\n+\n+fn with_closure(arr: Vec<u32>) -> Option<u32> {\n+    let f = |el: u32| -> u32 { el + 10 };\n+    arr.into_iter().find(|&el| f(el) == 20)\n+}\n+\n+fn with_closure2(arr: HashMap<String, i32>) -> Option<i32> {\n+    let f = |el: i32| -> bool { el == 10 };\n+    arr.values().find(|&&el| f(el)).copied()\n+}\n+\n+fn with_bool(arr: Vec<Data>) -> Option<Data> {\n+    arr.into_iter().find(|el| el.is_true)\n+}\n+\n+fn with_side_effects(arr: Vec<u32>) -> Option<u32> {\n+    for v in arr {\n+        if v == 1 {\n+            println!(\"side effect\");\n+            return Some(v);\n+        }\n+    }\n+    None\n+}\n+\n+fn with_else(arr: Vec<u32>) -> Option<u32> {\n+    for el in arr {\n+        if el % 2 == 0 {\n+            return Some(el);\n+        } else {\n+            println!(\"{}\", el);\n+        }\n+    }\n+    None\n+}\n+\n+fn tuple_with_ref(v: [(u8, &u8); 3]) -> Option<u8> {\n+    v.into_iter().map(|(_, &x)| x).find(|&x| x > 10)\n+}\n+\n+fn ref_to_tuple_with_ref(v: &[(u8, &u8)]) -> Option<u8> {\n+    v.iter().map(|&(_, &x)| x).find(|&x| x > 10)\n+}\n+\n+fn explicit_ret(arr: Vec<i32>) -> Option<i32> {\n+    arr.into_iter().find(|&x| x >= 5)\n+}\n+\n+fn plus_one(a: i32) -> Option<i32> {\n+    Some(a + 1)\n+}\n+fn fn_instead_of_some(a: &[i32]) -> Option<i32> {\n+    for &x in a {\n+        if x == 1 {\n+            return plus_one(x);\n+        }\n+    }\n+    None\n+}\n+\n+fn for_in_condition(a: &[i32], b: bool) -> Option<i32> {\n+    if b {\n+        for &x in a {\n+            if x == 1 {\n+                return Some(x);\n+            }\n+        }\n+    }\n+    None\n+}\n+\n+fn intermediate_statements(a: &[i32]) -> Option<i32> {\n+    for &x in a {\n+        if x == 1 {\n+            return Some(x);\n+        }\n+    }\n+\n+    println!(\"side effect\");\n+\n+    None\n+}\n+\n+fn mixed_binding_modes(arr: Vec<(i32, String)>) -> Option<i32> {\n+    for (x, mut s) in arr {\n+        if x == 1 && s.as_mut_str().len() == 2 {\n+            return Some(x);\n+        }\n+    }\n+    None\n+}\n+\n+fn as_closure() {\n+    #[rustfmt::skip]\n+    let f = |arr: Vec<i32>| -> Option<i32> {\n+        arr.into_iter().find(|&x| x < 1)\n+    };\n+}\n+\n+fn in_block(a: &[i32]) -> Option<i32> {\n+    let should_be_none = {\n+        for &x in a {\n+            if x == 1 {\n+                return Some(x);\n+            }\n+        }\n+        None\n+    };\n+\n+    assert!(should_be_none.is_none());\n+\n+    should_be_none\n+}\n+\n+// Not handled yet\n+fn mut_binding(v: Vec<String>) -> Option<String> {\n+    for mut s in v {\n+        if s.as_mut_str().len() > 1 {\n+            return Some(s);\n+        }\n+    }\n+    None\n+}\n+\n+fn subpattern(v: Vec<[u32; 32]>) -> Option<[u32; 32]> {\n+    for a @ [first, ..] in v {\n+        if a[12] == first {\n+            return Some(a);\n+        }\n+    }\n+    None\n+}\n+\n+fn two_bindings(v: Vec<(u8, u8)>) -> Option<u8> {\n+    for (a, n) in v {\n+        if a == n {\n+            return Some(a);\n+        }\n+    }\n+    None\n+}\n+\n+fn main() {}"}, {"sha": "ed277ddaa722d2767acdaafdae6c7aaf9697d827", "filename": "src/tools/clippy/tests/ui/manual_find_fixable.rs", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_find_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_find_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_find_fixable.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,242 @@\n+// run-rustfix\n+\n+#![allow(unused, clippy::needless_return)]\n+#![warn(clippy::manual_find)]\n+\n+use std::collections::HashMap;\n+\n+const ARRAY: &[u32; 5] = &[2, 7, 1, 9, 3];\n+\n+fn lookup(n: u32) -> Option<u32> {\n+    for &v in ARRAY {\n+        if v == n {\n+            return Some(v);\n+        }\n+    }\n+    None\n+}\n+\n+fn with_pat(arr: Vec<(u32, u32)>) -> Option<u32> {\n+    for (a, _) in arr {\n+        if a % 2 == 0 {\n+            return Some(a);\n+        }\n+    }\n+    None\n+}\n+\n+struct Data {\n+    name: String,\n+    is_true: bool,\n+}\n+fn with_struct(arr: Vec<Data>) -> Option<Data> {\n+    for el in arr {\n+        if el.name.len() == 10 {\n+            return Some(el);\n+        }\n+    }\n+    None\n+}\n+\n+struct Tuple(usize, usize);\n+fn with_tuple_struct(arr: Vec<Tuple>) -> Option<usize> {\n+    for Tuple(a, _) in arr {\n+        if a >= 3 {\n+            return Some(a);\n+        }\n+    }\n+    None\n+}\n+\n+struct A;\n+impl A {\n+    fn should_keep(&self) -> bool {\n+        true\n+    }\n+}\n+fn with_method_call(arr: Vec<A>) -> Option<A> {\n+    for el in arr {\n+        if el.should_keep() {\n+            return Some(el);\n+        }\n+    }\n+    None\n+}\n+\n+fn with_closure(arr: Vec<u32>) -> Option<u32> {\n+    let f = |el: u32| -> u32 { el + 10 };\n+    for el in arr {\n+        if f(el) == 20 {\n+            return Some(el);\n+        }\n+    }\n+    None\n+}\n+\n+fn with_closure2(arr: HashMap<String, i32>) -> Option<i32> {\n+    let f = |el: i32| -> bool { el == 10 };\n+    for &el in arr.values() {\n+        if f(el) {\n+            return Some(el);\n+        }\n+    }\n+    None\n+}\n+\n+fn with_bool(arr: Vec<Data>) -> Option<Data> {\n+    for el in arr {\n+        if el.is_true {\n+            return Some(el);\n+        }\n+    }\n+    None\n+}\n+\n+fn with_side_effects(arr: Vec<u32>) -> Option<u32> {\n+    for v in arr {\n+        if v == 1 {\n+            println!(\"side effect\");\n+            return Some(v);\n+        }\n+    }\n+    None\n+}\n+\n+fn with_else(arr: Vec<u32>) -> Option<u32> {\n+    for el in arr {\n+        if el % 2 == 0 {\n+            return Some(el);\n+        } else {\n+            println!(\"{}\", el);\n+        }\n+    }\n+    None\n+}\n+\n+fn tuple_with_ref(v: [(u8, &u8); 3]) -> Option<u8> {\n+    for (_, &x) in v {\n+        if x > 10 {\n+            return Some(x);\n+        }\n+    }\n+    None\n+}\n+\n+fn ref_to_tuple_with_ref(v: &[(u8, &u8)]) -> Option<u8> {\n+    for &(_, &x) in v {\n+        if x > 10 {\n+            return Some(x);\n+        }\n+    }\n+    None\n+}\n+\n+fn explicit_ret(arr: Vec<i32>) -> Option<i32> {\n+    for x in arr {\n+        if x >= 5 {\n+            return Some(x);\n+        }\n+    }\n+    return None;\n+}\n+\n+fn plus_one(a: i32) -> Option<i32> {\n+    Some(a + 1)\n+}\n+fn fn_instead_of_some(a: &[i32]) -> Option<i32> {\n+    for &x in a {\n+        if x == 1 {\n+            return plus_one(x);\n+        }\n+    }\n+    None\n+}\n+\n+fn for_in_condition(a: &[i32], b: bool) -> Option<i32> {\n+    if b {\n+        for &x in a {\n+            if x == 1 {\n+                return Some(x);\n+            }\n+        }\n+    }\n+    None\n+}\n+\n+fn intermediate_statements(a: &[i32]) -> Option<i32> {\n+    for &x in a {\n+        if x == 1 {\n+            return Some(x);\n+        }\n+    }\n+\n+    println!(\"side effect\");\n+\n+    None\n+}\n+\n+fn mixed_binding_modes(arr: Vec<(i32, String)>) -> Option<i32> {\n+    for (x, mut s) in arr {\n+        if x == 1 && s.as_mut_str().len() == 2 {\n+            return Some(x);\n+        }\n+    }\n+    None\n+}\n+\n+fn as_closure() {\n+    #[rustfmt::skip]\n+    let f = |arr: Vec<i32>| -> Option<i32> {\n+        for x in arr {\n+            if x < 1 {\n+                return Some(x);\n+            }\n+        }\n+        None\n+    };\n+}\n+\n+fn in_block(a: &[i32]) -> Option<i32> {\n+    let should_be_none = {\n+        for &x in a {\n+            if x == 1 {\n+                return Some(x);\n+            }\n+        }\n+        None\n+    };\n+\n+    assert!(should_be_none.is_none());\n+\n+    should_be_none\n+}\n+\n+// Not handled yet\n+fn mut_binding(v: Vec<String>) -> Option<String> {\n+    for mut s in v {\n+        if s.as_mut_str().len() > 1 {\n+            return Some(s);\n+        }\n+    }\n+    None\n+}\n+\n+fn subpattern(v: Vec<[u32; 32]>) -> Option<[u32; 32]> {\n+    for a @ [first, ..] in v {\n+        if a[12] == first {\n+            return Some(a);\n+        }\n+    }\n+    None\n+}\n+\n+fn two_bindings(v: Vec<(u8, u8)>) -> Option<u8> {\n+    for (a, n) in v {\n+        if a == n {\n+            return Some(a);\n+        }\n+    }\n+    None\n+}\n+\n+fn main() {}"}, {"sha": "dbc4ff69a740b8780e77b9d51ebcd6aa08f75906", "filename": "src/tools/clippy/tests/ui/manual_find_fixable.stderr", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_find_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_find_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_find_fixable.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,142 @@\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find_fixable.rs:11:5\n+   |\n+LL | /     for &v in ARRAY {\n+LL | |         if v == n {\n+LL | |             return Some(v);\n+LL | |         }\n+LL | |     }\n+LL | |     None\n+   | |________^ help: replace with an iterator: `ARRAY.iter().find(|&&v| v == n).copied()`\n+   |\n+   = note: `-D clippy::manual-find` implied by `-D warnings`\n+\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find_fixable.rs:20:5\n+   |\n+LL | /     for (a, _) in arr {\n+LL | |         if a % 2 == 0 {\n+LL | |             return Some(a);\n+LL | |         }\n+LL | |     }\n+LL | |     None\n+   | |________^ help: replace with an iterator: `arr.into_iter().map(|(a, _)| a).find(|&a| a % 2 == 0)`\n+\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find_fixable.rs:33:5\n+   |\n+LL | /     for el in arr {\n+LL | |         if el.name.len() == 10 {\n+LL | |             return Some(el);\n+LL | |         }\n+LL | |     }\n+LL | |     None\n+   | |________^ help: replace with an iterator: `arr.into_iter().find(|el| el.name.len() == 10)`\n+   |\n+   = note: you may need to dereference some variables\n+\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find_fixable.rs:43:5\n+   |\n+LL | /     for Tuple(a, _) in arr {\n+LL | |         if a >= 3 {\n+LL | |             return Some(a);\n+LL | |         }\n+LL | |     }\n+LL | |     None\n+   | |________^ help: replace with an iterator: `arr.into_iter().map(|Tuple(a, _)| a).find(|&a| a >= 3)`\n+\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find_fixable.rs:58:5\n+   |\n+LL | /     for el in arr {\n+LL | |         if el.should_keep() {\n+LL | |             return Some(el);\n+LL | |         }\n+LL | |     }\n+LL | |     None\n+   | |________^ help: replace with an iterator: `arr.into_iter().find(|el| el.should_keep())`\n+   |\n+   = note: you may need to dereference some variables\n+\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find_fixable.rs:68:5\n+   |\n+LL | /     for el in arr {\n+LL | |         if f(el) == 20 {\n+LL | |             return Some(el);\n+LL | |         }\n+LL | |     }\n+LL | |     None\n+   | |________^ help: replace with an iterator: `arr.into_iter().find(|&el| f(el) == 20)`\n+\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find_fixable.rs:78:5\n+   |\n+LL | /     for &el in arr.values() {\n+LL | |         if f(el) {\n+LL | |             return Some(el);\n+LL | |         }\n+LL | |     }\n+LL | |     None\n+   | |________^ help: replace with an iterator: `arr.values().find(|&&el| f(el)).copied()`\n+\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find_fixable.rs:87:5\n+   |\n+LL | /     for el in arr {\n+LL | |         if el.is_true {\n+LL | |             return Some(el);\n+LL | |         }\n+LL | |     }\n+LL | |     None\n+   | |________^ help: replace with an iterator: `arr.into_iter().find(|el| el.is_true)`\n+   |\n+   = note: you may need to dereference some variables\n+\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find_fixable.rs:117:5\n+   |\n+LL | /     for (_, &x) in v {\n+LL | |         if x > 10 {\n+LL | |             return Some(x);\n+LL | |         }\n+LL | |     }\n+LL | |     None\n+   | |________^ help: replace with an iterator: `v.into_iter().map(|(_, &x)| x).find(|&x| x > 10)`\n+\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find_fixable.rs:126:5\n+   |\n+LL | /     for &(_, &x) in v {\n+LL | |         if x > 10 {\n+LL | |             return Some(x);\n+LL | |         }\n+LL | |     }\n+LL | |     None\n+   | |________^ help: replace with an iterator: `v.iter().map(|&(_, &x)| x).find(|&x| x > 10)`\n+\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find_fixable.rs:135:5\n+   |\n+LL | /     for x in arr {\n+LL | |         if x >= 5 {\n+LL | |             return Some(x);\n+LL | |         }\n+LL | |     }\n+LL | |     return None;\n+   | |________________^ help: replace with an iterator: `arr.into_iter().find(|&x| x >= 5)`\n+\n+error: manual implementation of `Iterator::find`\n+  --> $DIR/manual_find_fixable.rs:190:9\n+   |\n+LL | /         for x in arr {\n+LL | |             if x < 1 {\n+LL | |                 return Some(x);\n+LL | |             }\n+LL | |         }\n+LL | |         None\n+   | |____________^ help: replace with an iterator: `arr.into_iter().find(|&x| x < 1)`\n+\n+error: aborting due to 12 previous errors\n+"}, {"sha": "03b2433f6666b4b7af00e1a870b3731724129fef", "filename": "src/tools/clippy/tests/ui/manual_non_exhaustive_enum.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_non_exhaustive_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_non_exhaustive_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_non_exhaustive_enum.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,3 +1,4 @@\n+#![feature(lint_reasons)]\n #![warn(clippy::manual_non_exhaustive)]\n #![allow(unused)]\n \n@@ -75,4 +76,12 @@ fn foo(x: &mut UsedHidden) {\n     }\n }\n \n+#[expect(clippy::manual_non_exhaustive)]\n+enum ExpectLint {\n+    A,\n+    B,\n+    #[doc(hidden)]\n+    _C,\n+}\n+\n fn main() {}"}, {"sha": "144fe86df554ba41d59b64704728ed52668968b6", "filename": "src/tools/clippy/tests/ui/manual_non_exhaustive_enum.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_non_exhaustive_enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_non_exhaustive_enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_non_exhaustive_enum.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,5 +1,5 @@\n error: this seems like a manual implementation of the non-exhaustive pattern\n-  --> $DIR/manual_non_exhaustive_enum.rs:4:1\n+  --> $DIR/manual_non_exhaustive_enum.rs:5:1\n    |\n LL |   enum E {\n    |   ^-----\n@@ -15,13 +15,13 @@ LL | | }\n    |\n    = note: `-D clippy::manual-non-exhaustive` implied by `-D warnings`\n help: remove this variant\n-  --> $DIR/manual_non_exhaustive_enum.rs:8:5\n+  --> $DIR/manual_non_exhaustive_enum.rs:9:5\n    |\n LL |     _C,\n    |     ^^\n \n error: this seems like a manual implementation of the non-exhaustive pattern\n-  --> $DIR/manual_non_exhaustive_enum.rs:13:1\n+  --> $DIR/manual_non_exhaustive_enum.rs:14:1\n    |\n LL | / enum Ep {\n LL | |     A,\n@@ -32,7 +32,7 @@ LL | | }\n    | |_^\n    |\n help: remove this variant\n-  --> $DIR/manual_non_exhaustive_enum.rs:17:5\n+  --> $DIR/manual_non_exhaustive_enum.rs:18:5\n    |\n LL |     _C,\n    |     ^^"}, {"sha": "5601c96c10b28fe4af39b4301a263bfd748d4946", "filename": "src/tools/clippy/tests/ui/manual_rem_euclid.fixed", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_rem_euclid.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_rem_euclid.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_rem_euclid.fixed?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,55 @@\n+// run-rustfix\n+// aux-build:macro_rules.rs\n+\n+#![warn(clippy::manual_rem_euclid)]\n+\n+#[macro_use]\n+extern crate macro_rules;\n+\n+macro_rules! internal_rem_euclid {\n+    () => {\n+        let value: i32 = 5;\n+        let _: i32 = value.rem_euclid(4);\n+    };\n+}\n+\n+fn main() {\n+    let value: i32 = 5;\n+\n+    let _: i32 = value.rem_euclid(4);\n+    let _: i32 = value.rem_euclid(4);\n+    let _: i32 = value.rem_euclid(4);\n+    let _: i32 = value.rem_euclid(4);\n+    let _: i32 = 1 + value.rem_euclid(4);\n+\n+    let _: i32 = (3 + value % 4) % 4;\n+    let _: i32 = (-4 + value % -4) % -4;\n+    let _: i32 = ((5 % 4) + 4) % 4;\n+\n+    // Make sure the lint does not trigger if it would cause an error, like with an ambiguous\n+    // integer type\n+    let not_annotated = 24;\n+    let _ = ((not_annotated % 4) + 4) % 4;\n+    let inferred: _ = 24;\n+    let _ = ((inferred % 4) + 4) % 4;\n+\n+    // For lint to apply the constant must always be on the RHS of the previous value for %\n+    let _: i32 = 4 % ((value % 4) + 4);\n+    let _: i32 = ((4 % value) + 4) % 4;\n+\n+    // Lint in internal macros\n+    internal_rem_euclid!();\n+\n+    // Do not lint in external macros\n+    manual_rem_euclid!();\n+}\n+\n+// Should lint for params too\n+pub fn rem_euclid_4(num: i32) -> i32 {\n+    num.rem_euclid(4)\n+}\n+\n+// Constant version came later, should still lint\n+pub const fn const_rem_euclid_4(num: i32) -> i32 {\n+    num.rem_euclid(4)\n+}"}, {"sha": "52135be26b73c290640ab8cde7eefb7dc0111dd5", "filename": "src/tools/clippy/tests/ui/manual_rem_euclid.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_rem_euclid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_rem_euclid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_rem_euclid.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,55 @@\n+// run-rustfix\n+// aux-build:macro_rules.rs\n+\n+#![warn(clippy::manual_rem_euclid)]\n+\n+#[macro_use]\n+extern crate macro_rules;\n+\n+macro_rules! internal_rem_euclid {\n+    () => {\n+        let value: i32 = 5;\n+        let _: i32 = ((value % 4) + 4) % 4;\n+    };\n+}\n+\n+fn main() {\n+    let value: i32 = 5;\n+\n+    let _: i32 = ((value % 4) + 4) % 4;\n+    let _: i32 = (4 + (value % 4)) % 4;\n+    let _: i32 = (value % 4 + 4) % 4;\n+    let _: i32 = (4 + value % 4) % 4;\n+    let _: i32 = 1 + (4 + value % 4) % 4;\n+\n+    let _: i32 = (3 + value % 4) % 4;\n+    let _: i32 = (-4 + value % -4) % -4;\n+    let _: i32 = ((5 % 4) + 4) % 4;\n+\n+    // Make sure the lint does not trigger if it would cause an error, like with an ambiguous\n+    // integer type\n+    let not_annotated = 24;\n+    let _ = ((not_annotated % 4) + 4) % 4;\n+    let inferred: _ = 24;\n+    let _ = ((inferred % 4) + 4) % 4;\n+\n+    // For lint to apply the constant must always be on the RHS of the previous value for %\n+    let _: i32 = 4 % ((value % 4) + 4);\n+    let _: i32 = ((4 % value) + 4) % 4;\n+\n+    // Lint in internal macros\n+    internal_rem_euclid!();\n+\n+    // Do not lint in external macros\n+    manual_rem_euclid!();\n+}\n+\n+// Should lint for params too\n+pub fn rem_euclid_4(num: i32) -> i32 {\n+    ((num % 4) + 4) % 4\n+}\n+\n+// Constant version came later, should still lint\n+pub const fn const_rem_euclid_4(num: i32) -> i32 {\n+    ((num % 4) + 4) % 4\n+}"}, {"sha": "a237fd0213c1eeb187fea7ab79183d2b15950ee7", "filename": "src/tools/clippy/tests/ui/manual_rem_euclid.stderr", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_rem_euclid.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_rem_euclid.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_rem_euclid.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,57 @@\n+error: manual `rem_euclid` implementation\n+  --> $DIR/manual_rem_euclid.rs:19:18\n+   |\n+LL |     let _: i32 = ((value % 4) + 4) % 4;\n+   |                  ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `value.rem_euclid(4)`\n+   |\n+   = note: `-D clippy::manual-rem-euclid` implied by `-D warnings`\n+\n+error: manual `rem_euclid` implementation\n+  --> $DIR/manual_rem_euclid.rs:20:18\n+   |\n+LL |     let _: i32 = (4 + (value % 4)) % 4;\n+   |                  ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `value.rem_euclid(4)`\n+\n+error: manual `rem_euclid` implementation\n+  --> $DIR/manual_rem_euclid.rs:21:18\n+   |\n+LL |     let _: i32 = (value % 4 + 4) % 4;\n+   |                  ^^^^^^^^^^^^^^^^^^^ help: consider using: `value.rem_euclid(4)`\n+\n+error: manual `rem_euclid` implementation\n+  --> $DIR/manual_rem_euclid.rs:22:18\n+   |\n+LL |     let _: i32 = (4 + value % 4) % 4;\n+   |                  ^^^^^^^^^^^^^^^^^^^ help: consider using: `value.rem_euclid(4)`\n+\n+error: manual `rem_euclid` implementation\n+  --> $DIR/manual_rem_euclid.rs:23:22\n+   |\n+LL |     let _: i32 = 1 + (4 + value % 4) % 4;\n+   |                      ^^^^^^^^^^^^^^^^^^^ help: consider using: `value.rem_euclid(4)`\n+\n+error: manual `rem_euclid` implementation\n+  --> $DIR/manual_rem_euclid.rs:12:22\n+   |\n+LL |         let _: i32 = ((value % 4) + 4) % 4;\n+   |                      ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `value.rem_euclid(4)`\n+...\n+LL |     internal_rem_euclid!();\n+   |     ---------------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `internal_rem_euclid` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: manual `rem_euclid` implementation\n+  --> $DIR/manual_rem_euclid.rs:49:5\n+   |\n+LL |     ((num % 4) + 4) % 4\n+   |     ^^^^^^^^^^^^^^^^^^^ help: consider using: `num.rem_euclid(4)`\n+\n+error: manual `rem_euclid` implementation\n+  --> $DIR/manual_rem_euclid.rs:54:5\n+   |\n+LL |     ((num % 4) + 4) % 4\n+   |     ^^^^^^^^^^^^^^^^^^^ help: consider using: `num.rem_euclid(4)`\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "fba503a20667ac4d7c35a9456aef5296f4e558e1", "filename": "src/tools/clippy/tests/ui/manual_retain.fixed", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_retain.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_retain.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_retain.fixed?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,240 @@\n+// run-rustfix\n+#![feature(custom_inner_attributes)]\n+#![warn(clippy::manual_retain)]\n+#![allow(unused)]\n+use std::collections::BTreeMap;\n+use std::collections::BTreeSet;\n+use std::collections::BinaryHeap;\n+use std::collections::HashMap;\n+use std::collections::HashSet;\n+use std::collections::VecDeque;\n+\n+fn main() {\n+    binary_heap_retain();\n+    btree_set_retain();\n+    btree_map_retain();\n+    hash_set_retain();\n+    hash_map_retain();\n+    string_retain();\n+    vec_deque_retain();\n+    vec_retain();\n+    _msrv_153();\n+    _msrv_126();\n+    _msrv_118();\n+}\n+\n+fn binary_heap_retain() {\n+    // NOTE: Do not lint now, because binary_heap_retain is nighyly API.\n+    // And we need to add a test case for msrv if we update this implmention.\n+    // https://github.com/rust-lang/rust/issues/71503\n+    let mut heap = BinaryHeap::from([1, 2, 3]);\n+    heap = heap.into_iter().filter(|x| x % 2 == 0).collect();\n+    heap = heap.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    heap = heap.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+\n+    // Do not lint, because type conversion is performed\n+    heap = heap.into_iter().filter(|x| x % 2 == 0).collect::<BinaryHeap<i8>>();\n+    heap = heap.iter().filter(|&x| x % 2 == 0).copied().collect::<BinaryHeap<i8>>();\n+    heap = heap.iter().filter(|&x| x % 2 == 0).cloned().collect::<BinaryHeap<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: BinaryHeap<i8> = heap.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut foobar: BinaryHeap<i8> = heap.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.into_iter().filter(|x| x % 2 == 0).collect();\n+}\n+\n+fn btree_map_retain() {\n+    let mut btree_map: BTreeMap<i8, i8> = (0..8).map(|x| (x, x * 10)).collect();\n+    // Do lint.\n+    btree_map.retain(|k, _| k % 2 == 0);\n+    btree_map.retain(|_, &mut v| v % 2 == 0);\n+    btree_map.retain(|k, &mut v| (k % 2 == 0) && (v % 2 == 0));\n+\n+    // Do not lint.\n+    btree_map = btree_map\n+        .into_iter()\n+        .filter(|(x, _)| x % 2 == 0)\n+        .collect::<BTreeMap<i8, i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut foobar: BTreeMap<i8, i8> = btree_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    btree_map = foobar.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+}\n+\n+fn btree_set_retain() {\n+    let mut btree_set = BTreeSet::from([1, 2, 3, 4, 5, 6]);\n+\n+    // Do lint.\n+    btree_set.retain(|x| x % 2 == 0);\n+    btree_set.retain(|x| x % 2 == 0);\n+    btree_set.retain(|x| x % 2 == 0);\n+\n+    // Do not lint, because type conversion is performed\n+    btree_set = btree_set\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .copied()\n+        .collect::<BTreeSet<i8>>();\n+\n+    btree_set = btree_set\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .cloned()\n+        .collect::<BTreeSet<i8>>();\n+\n+    btree_set = btree_set.into_iter().filter(|x| x % 2 == 0).collect::<BTreeSet<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut foobar: BTreeSet<i8> = btree_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut bar: BTreeSet<i8> = btree_set.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+    bar = foobar.into_iter().filter(|x| x % 2 == 0).collect();\n+}\n+\n+fn hash_map_retain() {\n+    let mut hash_map: HashMap<i8, i8> = (0..8).map(|x| (x, x * 10)).collect();\n+    // Do lint.\n+    hash_map.retain(|k, _| k % 2 == 0);\n+    hash_map.retain(|_, &mut v| v % 2 == 0);\n+    hash_map.retain(|k, &mut v| (k % 2 == 0) && (v % 2 == 0));\n+\n+    // Do not lint.\n+    hash_map = hash_map\n+        .into_iter()\n+        .filter(|(x, _)| x % 2 == 0)\n+        .collect::<HashMap<i8, i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut foobar: HashMap<i8, i8> = hash_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    hash_map = foobar.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+}\n+\n+fn hash_set_retain() {\n+    let mut hash_set = HashSet::from([1, 2, 3, 4, 5, 6]);\n+    // Do lint.\n+    hash_set.retain(|x| x % 2 == 0);\n+    hash_set.retain(|x| x % 2 == 0);\n+    hash_set.retain(|x| x % 2 == 0);\n+\n+    // Do not lint, because type conversion is performed\n+    hash_set = hash_set.into_iter().filter(|x| x % 2 == 0).collect::<HashSet<i8>>();\n+    hash_set = hash_set\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .copied()\n+        .collect::<HashSet<i8>>();\n+\n+    hash_set = hash_set\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .cloned()\n+        .collect::<HashSet<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: HashSet<i8> = hash_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut foobar: HashSet<i8> = hash_set.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+    bar = foobar.into_iter().filter(|&x| x % 2 == 0).collect();\n+}\n+\n+fn string_retain() {\n+    let mut s = String::from(\"foobar\");\n+    // Do lint.\n+    s.retain(|c| c != 'o');\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: String = s.chars().filter(|&c| c != 'o').to_owned().collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    s = bar.chars().filter(|&c| c != 'o').to_owned().collect();\n+}\n+\n+fn vec_retain() {\n+    let mut vec = vec![0, 1, 2];\n+    // Do lint.\n+    vec.retain(|x| x % 2 == 0);\n+    vec.retain(|x| x % 2 == 0);\n+    vec.retain(|x| x % 2 == 0);\n+\n+    // Do not lint, because type conversion is performed\n+    vec = vec.into_iter().filter(|x| x % 2 == 0).collect::<Vec<i8>>();\n+    vec = vec.iter().filter(|&x| x % 2 == 0).copied().collect::<Vec<i8>>();\n+    vec = vec.iter().filter(|&x| x % 2 == 0).cloned().collect::<Vec<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: Vec<i8> = vec.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut foobar: Vec<i8> = vec.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+    bar = foobar.into_iter().filter(|x| x % 2 == 0).collect();\n+}\n+\n+fn vec_deque_retain() {\n+    let mut vec_deque = VecDeque::new();\n+    vec_deque.extend(1..5);\n+\n+    // Do lint.\n+    vec_deque.retain(|x| x % 2 == 0);\n+    vec_deque.retain(|x| x % 2 == 0);\n+    vec_deque.retain(|x| x % 2 == 0);\n+\n+    // Do not lint, because type conversion is performed\n+    vec_deque = vec_deque\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .copied()\n+        .collect::<VecDeque<i8>>();\n+    vec_deque = vec_deque\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .cloned()\n+        .collect::<VecDeque<i8>>();\n+    vec_deque = vec_deque.into_iter().filter(|x| x % 2 == 0).collect::<VecDeque<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: VecDeque<i8> = vec_deque.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut foobar: VecDeque<i8> = vec_deque.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+    bar = foobar.into_iter().filter(|x| x % 2 == 0).collect();\n+}\n+\n+fn _msrv_153() {\n+    #![clippy::msrv = \"1.52\"]\n+    let mut btree_map: BTreeMap<i8, i8> = (0..8).map(|x| (x, x * 10)).collect();\n+    btree_map = btree_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+\n+    let mut btree_set = BTreeSet::from([1, 2, 3, 4, 5, 6]);\n+    btree_set = btree_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+}\n+\n+fn _msrv_126() {\n+    #![clippy::msrv = \"1.25\"]\n+    let mut s = String::from(\"foobar\");\n+    s = s.chars().filter(|&c| c != 'o').to_owned().collect();\n+}\n+\n+fn _msrv_118() {\n+    #![clippy::msrv = \"1.17\"]\n+    let mut hash_set = HashSet::from([1, 2, 3, 4, 5, 6]);\n+    hash_set = hash_set.into_iter().filter(|x| x % 2 == 0).collect();\n+    let mut hash_map: HashMap<i8, i8> = (0..8).map(|x| (x, x * 10)).collect();\n+    hash_map = hash_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+}"}, {"sha": "81a849fe7684ccbb5e3fcbf6b11ae4392391f2c2", "filename": "src/tools/clippy/tests/ui/manual_retain.rs", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_retain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_retain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_retain.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,246 @@\n+// run-rustfix\n+#![feature(custom_inner_attributes)]\n+#![warn(clippy::manual_retain)]\n+#![allow(unused)]\n+use std::collections::BTreeMap;\n+use std::collections::BTreeSet;\n+use std::collections::BinaryHeap;\n+use std::collections::HashMap;\n+use std::collections::HashSet;\n+use std::collections::VecDeque;\n+\n+fn main() {\n+    binary_heap_retain();\n+    btree_set_retain();\n+    btree_map_retain();\n+    hash_set_retain();\n+    hash_map_retain();\n+    string_retain();\n+    vec_deque_retain();\n+    vec_retain();\n+    _msrv_153();\n+    _msrv_126();\n+    _msrv_118();\n+}\n+\n+fn binary_heap_retain() {\n+    // NOTE: Do not lint now, because binary_heap_retain is nighyly API.\n+    // And we need to add a test case for msrv if we update this implmention.\n+    // https://github.com/rust-lang/rust/issues/71503\n+    let mut heap = BinaryHeap::from([1, 2, 3]);\n+    heap = heap.into_iter().filter(|x| x % 2 == 0).collect();\n+    heap = heap.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    heap = heap.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+\n+    // Do not lint, because type conversion is performed\n+    heap = heap.into_iter().filter(|x| x % 2 == 0).collect::<BinaryHeap<i8>>();\n+    heap = heap.iter().filter(|&x| x % 2 == 0).copied().collect::<BinaryHeap<i8>>();\n+    heap = heap.iter().filter(|&x| x % 2 == 0).cloned().collect::<BinaryHeap<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: BinaryHeap<i8> = heap.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut foobar: BinaryHeap<i8> = heap.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.into_iter().filter(|x| x % 2 == 0).collect();\n+}\n+\n+fn btree_map_retain() {\n+    let mut btree_map: BTreeMap<i8, i8> = (0..8).map(|x| (x, x * 10)).collect();\n+    // Do lint.\n+    btree_map = btree_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+    btree_map = btree_map.into_iter().filter(|(_, v)| v % 2 == 0).collect();\n+    btree_map = btree_map\n+        .into_iter()\n+        .filter(|(k, v)| (k % 2 == 0) && (v % 2 == 0))\n+        .collect();\n+\n+    // Do not lint.\n+    btree_map = btree_map\n+        .into_iter()\n+        .filter(|(x, _)| x % 2 == 0)\n+        .collect::<BTreeMap<i8, i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut foobar: BTreeMap<i8, i8> = btree_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    btree_map = foobar.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+}\n+\n+fn btree_set_retain() {\n+    let mut btree_set = BTreeSet::from([1, 2, 3, 4, 5, 6]);\n+\n+    // Do lint.\n+    btree_set = btree_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    btree_set = btree_set.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+    btree_set = btree_set.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because type conversion is performed\n+    btree_set = btree_set\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .copied()\n+        .collect::<BTreeSet<i8>>();\n+\n+    btree_set = btree_set\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .cloned()\n+        .collect::<BTreeSet<i8>>();\n+\n+    btree_set = btree_set.into_iter().filter(|x| x % 2 == 0).collect::<BTreeSet<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut foobar: BTreeSet<i8> = btree_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut bar: BTreeSet<i8> = btree_set.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+    bar = foobar.into_iter().filter(|x| x % 2 == 0).collect();\n+}\n+\n+fn hash_map_retain() {\n+    let mut hash_map: HashMap<i8, i8> = (0..8).map(|x| (x, x * 10)).collect();\n+    // Do lint.\n+    hash_map = hash_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+    hash_map = hash_map.into_iter().filter(|(_, v)| v % 2 == 0).collect();\n+    hash_map = hash_map\n+        .into_iter()\n+        .filter(|(k, v)| (k % 2 == 0) && (v % 2 == 0))\n+        .collect();\n+\n+    // Do not lint.\n+    hash_map = hash_map\n+        .into_iter()\n+        .filter(|(x, _)| x % 2 == 0)\n+        .collect::<HashMap<i8, i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut foobar: HashMap<i8, i8> = hash_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    hash_map = foobar.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+}\n+\n+fn hash_set_retain() {\n+    let mut hash_set = HashSet::from([1, 2, 3, 4, 5, 6]);\n+    // Do lint.\n+    hash_set = hash_set.into_iter().filter(|x| x % 2 == 0).collect();\n+    hash_set = hash_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    hash_set = hash_set.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+\n+    // Do not lint, because type conversion is performed\n+    hash_set = hash_set.into_iter().filter(|x| x % 2 == 0).collect::<HashSet<i8>>();\n+    hash_set = hash_set\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .copied()\n+        .collect::<HashSet<i8>>();\n+\n+    hash_set = hash_set\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .cloned()\n+        .collect::<HashSet<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: HashSet<i8> = hash_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut foobar: HashSet<i8> = hash_set.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+    bar = foobar.into_iter().filter(|&x| x % 2 == 0).collect();\n+}\n+\n+fn string_retain() {\n+    let mut s = String::from(\"foobar\");\n+    // Do lint.\n+    s = s.chars().filter(|&c| c != 'o').to_owned().collect();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: String = s.chars().filter(|&c| c != 'o').to_owned().collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    s = bar.chars().filter(|&c| c != 'o').to_owned().collect();\n+}\n+\n+fn vec_retain() {\n+    let mut vec = vec![0, 1, 2];\n+    // Do lint.\n+    vec = vec.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    vec = vec.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+    vec = vec.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because type conversion is performed\n+    vec = vec.into_iter().filter(|x| x % 2 == 0).collect::<Vec<i8>>();\n+    vec = vec.iter().filter(|&x| x % 2 == 0).copied().collect::<Vec<i8>>();\n+    vec = vec.iter().filter(|&x| x % 2 == 0).cloned().collect::<Vec<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: Vec<i8> = vec.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut foobar: Vec<i8> = vec.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+    bar = foobar.into_iter().filter(|x| x % 2 == 0).collect();\n+}\n+\n+fn vec_deque_retain() {\n+    let mut vec_deque = VecDeque::new();\n+    vec_deque.extend(1..5);\n+\n+    // Do lint.\n+    vec_deque = vec_deque.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    vec_deque = vec_deque.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+    vec_deque = vec_deque.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because type conversion is performed\n+    vec_deque = vec_deque\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .copied()\n+        .collect::<VecDeque<i8>>();\n+    vec_deque = vec_deque\n+        .iter()\n+        .filter(|&x| x % 2 == 0)\n+        .cloned()\n+        .collect::<VecDeque<i8>>();\n+    vec_deque = vec_deque.into_iter().filter(|x| x % 2 == 0).collect::<VecDeque<i8>>();\n+\n+    // Do not lint, because this expression is not assign.\n+    let mut bar: VecDeque<i8> = vec_deque.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    let mut foobar: VecDeque<i8> = vec_deque.into_iter().filter(|x| x % 2 == 0).collect();\n+\n+    // Do not lint, because it is an assignment to a different variable.\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).copied().collect();\n+    bar = foobar.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+    bar = foobar.into_iter().filter(|x| x % 2 == 0).collect();\n+}\n+\n+fn _msrv_153() {\n+    #![clippy::msrv = \"1.52\"]\n+    let mut btree_map: BTreeMap<i8, i8> = (0..8).map(|x| (x, x * 10)).collect();\n+    btree_map = btree_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+\n+    let mut btree_set = BTreeSet::from([1, 2, 3, 4, 5, 6]);\n+    btree_set = btree_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+}\n+\n+fn _msrv_126() {\n+    #![clippy::msrv = \"1.25\"]\n+    let mut s = String::from(\"foobar\");\n+    s = s.chars().filter(|&c| c != 'o').to_owned().collect();\n+}\n+\n+fn _msrv_118() {\n+    #![clippy::msrv = \"1.17\"]\n+    let mut hash_set = HashSet::from([1, 2, 3, 4, 5, 6]);\n+    hash_set = hash_set.into_iter().filter(|x| x % 2 == 0).collect();\n+    let mut hash_map: HashMap<i8, i8> = (0..8).map(|x| (x, x * 10)).collect();\n+    hash_map = hash_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+}"}, {"sha": "ec635919b48fb99814c6b908d4da38d8b4ec9084", "filename": "src/tools/clippy/tests/ui/manual_retain.stderr", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_retain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_retain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_retain.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,124 @@\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:52:5\n+   |\n+LL |     btree_map = btree_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `btree_map.retain(|k, _| k % 2 == 0)`\n+   |\n+   = note: `-D clippy::manual-retain` implied by `-D warnings`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:53:5\n+   |\n+LL |     btree_map = btree_map.into_iter().filter(|(_, v)| v % 2 == 0).collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `btree_map.retain(|_, &mut v| v % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:54:5\n+   |\n+LL | /     btree_map = btree_map\n+LL | |         .into_iter()\n+LL | |         .filter(|(k, v)| (k % 2 == 0) && (v % 2 == 0))\n+LL | |         .collect();\n+   | |__________________^ help: consider calling `.retain()` instead: `btree_map.retain(|k, &mut v| (k % 2 == 0) && (v % 2 == 0))`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:76:5\n+   |\n+LL |     btree_set = btree_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `btree_set.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:77:5\n+   |\n+LL |     btree_set = btree_set.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `btree_set.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:78:5\n+   |\n+LL |     btree_set = btree_set.into_iter().filter(|x| x % 2 == 0).collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `btree_set.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:108:5\n+   |\n+LL |     hash_map = hash_map.into_iter().filter(|(k, _)| k % 2 == 0).collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `hash_map.retain(|k, _| k % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:109:5\n+   |\n+LL |     hash_map = hash_map.into_iter().filter(|(_, v)| v % 2 == 0).collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `hash_map.retain(|_, &mut v| v % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:110:5\n+   |\n+LL | /     hash_map = hash_map\n+LL | |         .into_iter()\n+LL | |         .filter(|(k, v)| (k % 2 == 0) && (v % 2 == 0))\n+LL | |         .collect();\n+   | |__________________^ help: consider calling `.retain()` instead: `hash_map.retain(|k, &mut v| (k % 2 == 0) && (v % 2 == 0))`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:131:5\n+   |\n+LL |     hash_set = hash_set.into_iter().filter(|x| x % 2 == 0).collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `hash_set.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:132:5\n+   |\n+LL |     hash_set = hash_set.iter().filter(|&x| x % 2 == 0).copied().collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `hash_set.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:133:5\n+   |\n+LL |     hash_set = hash_set.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `hash_set.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:162:5\n+   |\n+LL |     s = s.chars().filter(|&c| c != 'o').to_owned().collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `s.retain(|c| c != 'o')`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:174:5\n+   |\n+LL |     vec = vec.iter().filter(|&x| x % 2 == 0).copied().collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `vec.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:175:5\n+   |\n+LL |     vec = vec.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `vec.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:176:5\n+   |\n+LL |     vec = vec.into_iter().filter(|x| x % 2 == 0).collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `vec.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:198:5\n+   |\n+LL |     vec_deque = vec_deque.iter().filter(|&x| x % 2 == 0).copied().collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `vec_deque.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:199:5\n+   |\n+LL |     vec_deque = vec_deque.iter().filter(|&x| x % 2 == 0).cloned().collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `vec_deque.retain(|x| x % 2 == 0)`\n+\n+error: this expression can be written more simply using `.retain()`\n+  --> $DIR/manual_retain.rs:200:5\n+   |\n+LL |     vec_deque = vec_deque.into_iter().filter(|x| x % 2 == 0).collect();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.retain()` instead: `vec_deque.retain(|x| x % 2 == 0)`\n+\n+error: aborting due to 19 previous errors\n+"}, {"sha": "1970c2eae531420a9dbc6f36964d7bba80890d8a", "filename": "src/tools/clippy/tests/ui/methods.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -15,6 +15,7 @@\n     clippy::use_self,\n     clippy::useless_format,\n     clippy::wrong_self_convention,\n+    clippy::unused_async,\n     clippy::unused_self,\n     unused\n )]"}, {"sha": "b63672dd6fdbb546dac805e74727f9bf8982851f", "filename": "src/tools/clippy/tests/ui/methods.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmethods.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,5 +1,5 @@\n error: methods called `new` usually return `Self`\n-  --> $DIR/methods.rs:103:5\n+  --> $DIR/methods.rs:104:5\n    |\n LL | /     fn new() -> i32 {\n LL | |         0\n@@ -9,7 +9,7 @@ LL | |     }\n    = note: `-D clippy::new-ret-no-self` implied by `-D warnings`\n \n error: called `filter(..).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(..)` instead\n-  --> $DIR/methods.rs:124:13\n+  --> $DIR/methods.rs:125:13\n    |\n LL |       let _ = v.iter().filter(|&x| {\n    |  _____________^"}, {"sha": "44e407bd1ab2ba5084c8d38bfa2df046de1829aa", "filename": "src/tools/clippy/tests/ui/min_rust_version_attr.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmin_rust_version_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmin_rust_version_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmin_rust_version_attr.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -155,6 +155,11 @@ fn cast_abs_to_unsigned() {\n     assert_eq!(10u32, x.abs() as u32);\n }\n \n+fn manual_rem_euclid() {\n+    let x: i32 = 10;\n+    let _: i32 = ((x % 4) + 4) % 4;\n+}\n+\n fn main() {\n     filter_map_next();\n     checked_conversion();\n@@ -174,6 +179,7 @@ fn main() {\n     int_from_bool();\n     err_expect();\n     cast_abs_to_unsigned();\n+    manual_rem_euclid();\n }\n \n mod just_under_msrv {\n@@ -211,3 +217,12 @@ mod just_above_msrv {\n         }\n     }\n }\n+\n+mod const_rem_euclid {\n+    #![feature(custom_inner_attributes)]\n+    #![clippy::msrv = \"1.50.0\"]\n+\n+    pub const fn const_rem_euclid_4(num: i32) -> i32 {\n+        ((num % 4) + 4) % 4\n+    }\n+}"}, {"sha": "b1c23b539ffdeb9fc62a262deb39656f6b314967", "filename": "src/tools/clippy/tests/ui/min_rust_version_attr.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmin_rust_version_attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmin_rust_version_attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmin_rust_version_attr.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,12 +1,12 @@\n error: stripping a prefix manually\n-  --> $DIR/min_rust_version_attr.rs:198:24\n+  --> $DIR/min_rust_version_attr.rs:204:24\n    |\n LL |             assert_eq!(s[\"hello, \".len()..].to_uppercase(), \"WORLD!\");\n    |                        ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::manual-strip` implied by `-D warnings`\n note: the prefix was tested here\n-  --> $DIR/min_rust_version_attr.rs:197:9\n+  --> $DIR/min_rust_version_attr.rs:203:9\n    |\n LL |         if s.starts_with(\"hello, \") {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -17,13 +17,13 @@ LL ~             assert_eq!(<stripped>.to_uppercase(), \"WORLD!\");\n    |\n \n error: stripping a prefix manually\n-  --> $DIR/min_rust_version_attr.rs:210:24\n+  --> $DIR/min_rust_version_attr.rs:216:24\n    |\n LL |             assert_eq!(s[\"hello, \".len()..].to_uppercase(), \"WORLD!\");\n    |                        ^^^^^^^^^^^^^^^^^^^^\n    |\n note: the prefix was tested here\n-  --> $DIR/min_rust_version_attr.rs:209:9\n+  --> $DIR/min_rust_version_attr.rs:215:9\n    |\n LL |         if s.starts_with(\"hello, \") {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "cb005122436019f2a2be9ac1c8fb219d8257e534", "filename": "src/tools/clippy/tests/ui/needless_borrow.fixed", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.fixed?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -62,7 +62,18 @@ fn main() {\n         0 => &mut x,\n         _ => &mut *x,\n     };\n-\n+    let y: &mut i32 = match 0 {\n+        // Lint here. The type given above triggers auto-borrow.\n+        0 => x,\n+        _ => &mut *x,\n+    };\n+    fn ref_mut_i32(_: &mut i32) {}\n+    ref_mut_i32(match 0 {\n+        // Lint here. The type given above triggers auto-borrow.\n+        0 => x,\n+        _ => &mut *x,\n+    });\n+    // use 'x' after to make sure it's still usable in the fixed code.\n     *x = 5;\n \n     let s = String::new();\n@@ -74,6 +85,36 @@ fn main() {\n     let _ = x.0;\n     let x = &x as *const (i32, i32);\n     let _ = unsafe { (*x).0 };\n+\n+    // Issue #8367\n+    trait Foo {\n+        fn foo(self);\n+    }\n+    impl Foo for &'_ () {\n+        fn foo(self) {}\n+    }\n+    (&()).foo(); // Don't lint. `()` doesn't implement `Foo`\n+    (&()).foo();\n+\n+    impl Foo for i32 {\n+        fn foo(self) {}\n+    }\n+    impl Foo for &'_ i32 {\n+        fn foo(self) {}\n+    }\n+    (&5).foo(); // Don't lint. `5` will call `<i32 as Foo>::foo`\n+    (&5).foo();\n+\n+    trait FooRef {\n+        fn foo_ref(&self);\n+    }\n+    impl FooRef for () {\n+        fn foo_ref(&self) {}\n+    }\n+    impl FooRef for &'_ () {\n+        fn foo_ref(&self) {}\n+    }\n+    (&&()).foo_ref(); // Don't lint. `&()` will call `<() as FooRef>::foo_ref`\n }\n \n #[allow(clippy::needless_borrowed_reference)]"}, {"sha": "d636a40100378c0f5bebc5cbb3f85b9f902ab365", "filename": "src/tools/clippy/tests/ui/needless_borrow.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -62,7 +62,18 @@ fn main() {\n         0 => &mut x,\n         _ => &mut *x,\n     };\n-\n+    let y: &mut i32 = match 0 {\n+        // Lint here. The type given above triggers auto-borrow.\n+        0 => &mut x,\n+        _ => &mut *x,\n+    };\n+    fn ref_mut_i32(_: &mut i32) {}\n+    ref_mut_i32(match 0 {\n+        // Lint here. The type given above triggers auto-borrow.\n+        0 => &mut x,\n+        _ => &mut *x,\n+    });\n+    // use 'x' after to make sure it's still usable in the fixed code.\n     *x = 5;\n \n     let s = String::new();\n@@ -74,6 +85,36 @@ fn main() {\n     let _ = (&x).0;\n     let x = &x as *const (i32, i32);\n     let _ = unsafe { (&*x).0 };\n+\n+    // Issue #8367\n+    trait Foo {\n+        fn foo(self);\n+    }\n+    impl Foo for &'_ () {\n+        fn foo(self) {}\n+    }\n+    (&()).foo(); // Don't lint. `()` doesn't implement `Foo`\n+    (&&()).foo();\n+\n+    impl Foo for i32 {\n+        fn foo(self) {}\n+    }\n+    impl Foo for &'_ i32 {\n+        fn foo(self) {}\n+    }\n+    (&5).foo(); // Don't lint. `5` will call `<i32 as Foo>::foo`\n+    (&&5).foo();\n+\n+    trait FooRef {\n+        fn foo_ref(&self);\n+    }\n+    impl FooRef for () {\n+        fn foo_ref(&self) {}\n+    }\n+    impl FooRef for &'_ () {\n+        fn foo_ref(&self) {}\n+    }\n+    (&&()).foo_ref(); // Don't lint. `&()` will call `<() as FooRef>::foo_ref`\n }\n \n #[allow(clippy::needless_borrowed_reference)]"}, {"sha": "8a2e2b9895908f1ac5fb1d2d2737b5a5a230e5a7", "filename": "src/tools/clippy/tests/ui/needless_borrow.stderr", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -84,17 +84,41 @@ error: this expression creates a reference which is immediately dereferenced by\n LL |     let y: &mut i32 = &mut &mut x;\n    |                       ^^^^^^^^^^^ help: change this to: `x`\n \n+error: this expression creates a reference which is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:67:14\n+   |\n+LL |         0 => &mut x,\n+   |              ^^^^^^ help: change this to: `x`\n+\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:73:14\n+   |\n+LL |         0 => &mut x,\n+   |              ^^^^^^ help: change this to: `x`\n+\n error: this expression borrows a value the compiler would automatically borrow\n-  --> $DIR/needless_borrow.rs:74:13\n+  --> $DIR/needless_borrow.rs:85:13\n    |\n LL |     let _ = (&x).0;\n    |             ^^^^ help: change this to: `x`\n \n error: this expression borrows a value the compiler would automatically borrow\n-  --> $DIR/needless_borrow.rs:76:22\n+  --> $DIR/needless_borrow.rs:87:22\n    |\n LL |     let _ = unsafe { (&*x).0 };\n    |                      ^^^^^ help: change this to: `(*x)`\n \n-error: aborting due to 16 previous errors\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:97:5\n+   |\n+LL |     (&&()).foo();\n+   |     ^^^^^^ help: change this to: `(&())`\n+\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:106:5\n+   |\n+LL |     (&&5).foo();\n+   |     ^^^^^ help: change this to: `(&5)`\n+\n+error: aborting due to 20 previous errors\n "}, {"sha": "222e8e617995d7943e4d0d6cd1e7ea7da452364e", "filename": "src/tools/clippy/tests/ui/needless_borrow_pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow_pat.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,7 +1,7 @@\n // FIXME: run-rustfix waiting on multi-span suggestions\n \n #![warn(clippy::needless_borrow)]\n-#![allow(clippy::needless_borrowed_reference)]\n+#![allow(clippy::needless_borrowed_reference, clippy::explicit_auto_deref)]\n \n fn f1(_: &str) {}\n macro_rules! m1 {"}, {"sha": "0bc0d0011efe00cd009475cb7972c3162cde1c62", "filename": "src/tools/clippy/tests/ui/needless_return.fixed", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.fixed?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,5 +1,6 @@\n // run-rustfix\n \n+#![feature(lint_reasons)]\n #![feature(let_else)]\n #![allow(unused)]\n #![allow(\n@@ -10,6 +11,8 @@\n )]\n #![warn(clippy::needless_return)]\n \n+use std::cell::RefCell;\n+\n macro_rules! the_answer {\n     () => {\n         42\n@@ -86,17 +89,15 @@ fn test_nested_match(x: u32) {\n     }\n }\n \n-fn read_line() -> String {\n-    use std::io::BufRead;\n-    let stdin = ::std::io::stdin();\n-    return stdin.lock().lines().next().unwrap().unwrap();\n+fn temporary_outlives_local() -> String {\n+    let x = RefCell::<String>::default();\n+    return x.borrow().clone();\n }\n \n fn borrows_but_not_last(value: bool) -> String {\n     if value {\n-        use std::io::BufRead;\n-        let stdin = ::std::io::stdin();\n-        let _a = stdin.lock().lines().next().unwrap().unwrap();\n+        let x = RefCell::<String>::default();\n+        let _a = x.borrow().clone();\n         String::from(\"test\")\n     } else {\n         String::new()\n@@ -197,17 +198,15 @@ async fn async_test_void_match(x: u32) {\n     }\n }\n \n-async fn async_read_line() -> String {\n-    use std::io::BufRead;\n-    let stdin = ::std::io::stdin();\n-    return stdin.lock().lines().next().unwrap().unwrap();\n+async fn async_temporary_outlives_local() -> String {\n+    let x = RefCell::<String>::default();\n+    return x.borrow().clone();\n }\n \n async fn async_borrows_but_not_last(value: bool) -> String {\n     if value {\n-        use std::io::BufRead;\n-        let stdin = ::std::io::stdin();\n-        let _a = stdin.lock().lines().next().unwrap().unwrap();\n+        let x = RefCell::<String>::default();\n+        let _a = x.borrow().clone();\n         String::from(\"test\")\n     } else {\n         String::new()\n@@ -229,4 +228,13 @@ fn needless_return_macro() -> String {\n     format!(\"Hello {}\", \"world!\")\n }\n \n+fn check_expect() -> bool {\n+    if true {\n+        // no error!\n+        return true;\n+    }\n+    #[expect(clippy::needless_return)]\n+    return true;\n+}\n+\n fn main() {}"}, {"sha": "eb9f72e8e7822fe8839060d77bc9ca237d1f5057", "filename": "src/tools/clippy/tests/ui/needless_return.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,5 +1,6 @@\n // run-rustfix\n \n+#![feature(lint_reasons)]\n #![feature(let_else)]\n #![allow(unused)]\n #![allow(\n@@ -10,6 +11,8 @@\n )]\n #![warn(clippy::needless_return)]\n \n+use std::cell::RefCell;\n+\n macro_rules! the_answer {\n     () => {\n         42\n@@ -86,17 +89,15 @@ fn test_nested_match(x: u32) {\n     }\n }\n \n-fn read_line() -> String {\n-    use std::io::BufRead;\n-    let stdin = ::std::io::stdin();\n-    return stdin.lock().lines().next().unwrap().unwrap();\n+fn temporary_outlives_local() -> String {\n+    let x = RefCell::<String>::default();\n+    return x.borrow().clone();\n }\n \n fn borrows_but_not_last(value: bool) -> String {\n     if value {\n-        use std::io::BufRead;\n-        let stdin = ::std::io::stdin();\n-        let _a = stdin.lock().lines().next().unwrap().unwrap();\n+        let x = RefCell::<String>::default();\n+        let _a = x.borrow().clone();\n         return String::from(\"test\");\n     } else {\n         return String::new();\n@@ -197,17 +198,15 @@ async fn async_test_void_match(x: u32) {\n     }\n }\n \n-async fn async_read_line() -> String {\n-    use std::io::BufRead;\n-    let stdin = ::std::io::stdin();\n-    return stdin.lock().lines().next().unwrap().unwrap();\n+async fn async_temporary_outlives_local() -> String {\n+    let x = RefCell::<String>::default();\n+    return x.borrow().clone();\n }\n \n async fn async_borrows_but_not_last(value: bool) -> String {\n     if value {\n-        use std::io::BufRead;\n-        let stdin = ::std::io::stdin();\n-        let _a = stdin.lock().lines().next().unwrap().unwrap();\n+        let x = RefCell::<String>::default();\n+        let _a = x.borrow().clone();\n         return String::from(\"test\");\n     } else {\n         return String::new();\n@@ -229,4 +228,13 @@ fn needless_return_macro() -> String {\n     return format!(\"Hello {}\", \"world!\");\n }\n \n+fn check_expect() -> bool {\n+    if true {\n+        // no error!\n+        return true;\n+    }\n+    #[expect(clippy::needless_return)]\n+    return true;\n+}\n+\n fn main() {}"}, {"sha": "83ff07638693c7ef5a6d861c84b58bf3486c0d2e", "filename": "src/tools/clippy/tests/ui/needless_return.stderr", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_return.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,223 +1,223 @@\n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:24:5\n+  --> $DIR/needless_return.rs:27:5\n    |\n LL |     return true;\n    |     ^^^^^^^^^^^^ help: remove `return`: `true`\n    |\n    = note: `-D clippy::needless-return` implied by `-D warnings`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:28:5\n+  --> $DIR/needless_return.rs:31:5\n    |\n LL |     return true;\n    |     ^^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:33:9\n+  --> $DIR/needless_return.rs:36:9\n    |\n LL |         return true;\n    |         ^^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:35:9\n+  --> $DIR/needless_return.rs:38:9\n    |\n LL |         return false;\n    |         ^^^^^^^^^^^^^ help: remove `return`: `false`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:41:17\n+  --> $DIR/needless_return.rs:44:17\n    |\n LL |         true => return false,\n    |                 ^^^^^^^^^^^^ help: remove `return`: `false`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:43:13\n+  --> $DIR/needless_return.rs:46:13\n    |\n LL |             return true;\n    |             ^^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:50:9\n+  --> $DIR/needless_return.rs:53:9\n    |\n LL |         return true;\n    |         ^^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:52:16\n+  --> $DIR/needless_return.rs:55:16\n    |\n LL |     let _ = || return true;\n    |                ^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:56:5\n+  --> $DIR/needless_return.rs:59:5\n    |\n LL |     return the_answer!();\n    |     ^^^^^^^^^^^^^^^^^^^^^ help: remove `return`: `the_answer!()`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:60:5\n+  --> $DIR/needless_return.rs:63:5\n    |\n LL |     return;\n    |     ^^^^^^^ help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:65:9\n+  --> $DIR/needless_return.rs:68:9\n    |\n LL |         return;\n    |         ^^^^^^^ help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:67:9\n+  --> $DIR/needless_return.rs:70:9\n    |\n LL |         return;\n    |         ^^^^^^^ help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:74:14\n+  --> $DIR/needless_return.rs:77:14\n    |\n LL |         _ => return,\n    |              ^^^^^^ help: replace `return` with a unit value: `()`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:83:13\n+  --> $DIR/needless_return.rs:86:13\n    |\n LL |             return;\n    |             ^^^^^^^ help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:85:14\n+  --> $DIR/needless_return.rs:88:14\n    |\n LL |         _ => return,\n    |              ^^^^^^ help: replace `return` with a unit value: `()`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:100:9\n+  --> $DIR/needless_return.rs:101:9\n    |\n LL |         return String::from(\"test\");\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove `return`: `String::from(\"test\")`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:102:9\n+  --> $DIR/needless_return.rs:103:9\n    |\n LL |         return String::new();\n    |         ^^^^^^^^^^^^^^^^^^^^^ help: remove `return`: `String::new()`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:124:32\n+  --> $DIR/needless_return.rs:125:32\n    |\n LL |         bar.unwrap_or_else(|_| return)\n    |                                ^^^^^^ help: replace `return` with an empty block: `{}`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:129:13\n+  --> $DIR/needless_return.rs:130:13\n    |\n LL |             return;\n    |             ^^^^^^^ help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:131:20\n+  --> $DIR/needless_return.rs:132:20\n    |\n LL |         let _ = || return;\n    |                    ^^^^^^ help: replace `return` with an empty block: `{}`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:137:32\n+  --> $DIR/needless_return.rs:138:32\n    |\n LL |         res.unwrap_or_else(|_| return Foo)\n    |                                ^^^^^^^^^^ help: remove `return`: `Foo`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:146:5\n+  --> $DIR/needless_return.rs:147:5\n    |\n LL |     return true;\n    |     ^^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:150:5\n+  --> $DIR/needless_return.rs:151:5\n    |\n LL |     return true;\n    |     ^^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:155:9\n+  --> $DIR/needless_return.rs:156:9\n    |\n LL |         return true;\n    |         ^^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:157:9\n+  --> $DIR/needless_return.rs:158:9\n    |\n LL |         return false;\n    |         ^^^^^^^^^^^^^ help: remove `return`: `false`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:163:17\n+  --> $DIR/needless_return.rs:164:17\n    |\n LL |         true => return false,\n    |                 ^^^^^^^^^^^^ help: remove `return`: `false`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:165:13\n+  --> $DIR/needless_return.rs:166:13\n    |\n LL |             return true;\n    |             ^^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:172:9\n+  --> $DIR/needless_return.rs:173:9\n    |\n LL |         return true;\n    |         ^^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:174:16\n+  --> $DIR/needless_return.rs:175:16\n    |\n LL |     let _ = || return true;\n    |                ^^^^^^^^^^^ help: remove `return`: `true`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:178:5\n+  --> $DIR/needless_return.rs:179:5\n    |\n LL |     return the_answer!();\n    |     ^^^^^^^^^^^^^^^^^^^^^ help: remove `return`: `the_answer!()`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:182:5\n+  --> $DIR/needless_return.rs:183:5\n    |\n LL |     return;\n    |     ^^^^^^^ help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:187:9\n+  --> $DIR/needless_return.rs:188:9\n    |\n LL |         return;\n    |         ^^^^^^^ help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:189:9\n+  --> $DIR/needless_return.rs:190:9\n    |\n LL |         return;\n    |         ^^^^^^^ help: remove `return`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:196:14\n+  --> $DIR/needless_return.rs:197:14\n    |\n LL |         _ => return,\n    |              ^^^^^^ help: replace `return` with a unit value: `()`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:211:9\n+  --> $DIR/needless_return.rs:210:9\n    |\n LL |         return String::from(\"test\");\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove `return`: `String::from(\"test\")`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:213:9\n+  --> $DIR/needless_return.rs:212:9\n    |\n LL |         return String::new();\n    |         ^^^^^^^^^^^^^^^^^^^^^ help: remove `return`: `String::new()`\n \n error: unneeded `return` statement\n-  --> $DIR/needless_return.rs:229:5\n+  --> $DIR/needless_return.rs:228:5\n    |\n LL |     return format!(\"Hello {}\", \"world!\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove `return`: `format!(\"Hello {}\", \"world!\")`"}, {"sha": "58ab9e856783849ceacfb1bfc9e8ea6533a19a6c", "filename": "src/tools/clippy/tests/ui/neg_multiply.fixed", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneg_multiply.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneg_multiply.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneg_multiply.fixed?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -38,6 +38,9 @@ fn main() {\n \n     0xcafe | -0xff00;\n \n+    -(3_usize as i32);\n+    -(3_usize as i32);\n+\n     -1 * -1; // should be ok\n \n     X * -1; // should be ok"}, {"sha": "581290dc72e43e87fccc68c6b322996a9ee55f1d", "filename": "src/tools/clippy/tests/ui/neg_multiply.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneg_multiply.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -38,6 +38,9 @@ fn main() {\n \n     0xcafe | 0xff00 * -1;\n \n+    3_usize as i32 * -1;\n+    (3_usize as i32) * -1;\n+\n     -1 * -1; // should be ok\n \n     X * -1; // should be ok"}, {"sha": "388ef29eb8567fa178ef4d03be77aab1479938ce", "filename": "src/tools/clippy/tests/ui/neg_multiply.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneg_multiply.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneg_multiply.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneg_multiply.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -36,5 +36,17 @@ error: this multiplication by -1 can be written more succinctly\n LL |     0xcafe | 0xff00 * -1;\n    |              ^^^^^^^^^^^ help: consider using: `-0xff00`\n \n-error: aborting due to 6 previous errors\n+error: this multiplication by -1 can be written more succinctly\n+  --> $DIR/neg_multiply.rs:41:5\n+   |\n+LL |     3_usize as i32 * -1;\n+   |     ^^^^^^^^^^^^^^^^^^^ help: consider using: `-(3_usize as i32)`\n+\n+error: this multiplication by -1 can be written more succinctly\n+  --> $DIR/neg_multiply.rs:42:5\n+   |\n+LL |     (3_usize as i32) * -1;\n+   |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `-(3_usize as i32)`\n+\n+error: aborting due to 8 previous errors\n "}, {"sha": "24ae62bb05884104c59d25e7d20ed0260a35481d", "filename": "src/tools/clippy/tests/ui/nonminimal_bool.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fnonminimal_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fnonminimal_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fnonminimal_bool.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,3 +1,4 @@\n+#![feature(lint_reasons)]\n #![allow(unused, clippy::diverging_sub_expression)]\n #![warn(clippy::nonminimal_bool)]\n \n@@ -50,3 +51,9 @@ fn issue4548() {\n \n     if i != j && f(i, j) != 0 || i == j && f(i, j) != 1 {}\n }\n+\n+fn check_expect() {\n+    let a: bool = unimplemented!();\n+    #[expect(clippy::nonminimal_bool)]\n+    let _ = !!a;\n+}"}, {"sha": "fc6a5ce1dc2eef4e6ffc2860aa19154b84c53614", "filename": "src/tools/clippy/tests/ui/nonminimal_bool.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fnonminimal_bool.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fnonminimal_bool.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fnonminimal_bool.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,49 +1,49 @@\n error: this boolean expression can be simplified\n-  --> $DIR/nonminimal_bool.rs:10:13\n+  --> $DIR/nonminimal_bool.rs:11:13\n    |\n LL |     let _ = !true;\n    |             ^^^^^ help: try: `false`\n    |\n    = note: `-D clippy::nonminimal-bool` implied by `-D warnings`\n \n error: this boolean expression can be simplified\n-  --> $DIR/nonminimal_bool.rs:11:13\n+  --> $DIR/nonminimal_bool.rs:12:13\n    |\n LL |     let _ = !false;\n    |             ^^^^^^ help: try: `true`\n \n error: this boolean expression can be simplified\n-  --> $DIR/nonminimal_bool.rs:12:13\n+  --> $DIR/nonminimal_bool.rs:13:13\n    |\n LL |     let _ = !!a;\n    |             ^^^ help: try: `a`\n \n error: this boolean expression can be simplified\n-  --> $DIR/nonminimal_bool.rs:13:13\n+  --> $DIR/nonminimal_bool.rs:14:13\n    |\n LL |     let _ = false || a;\n    |             ^^^^^^^^^^ help: try: `a`\n \n error: this boolean expression can be simplified\n-  --> $DIR/nonminimal_bool.rs:17:13\n+  --> $DIR/nonminimal_bool.rs:18:13\n    |\n LL |     let _ = !(!a && b);\n    |             ^^^^^^^^^^ help: try: `a || !b`\n \n error: this boolean expression can be simplified\n-  --> $DIR/nonminimal_bool.rs:18:13\n+  --> $DIR/nonminimal_bool.rs:19:13\n    |\n LL |     let _ = !(!a || b);\n    |             ^^^^^^^^^^ help: try: `a && !b`\n \n error: this boolean expression can be simplified\n-  --> $DIR/nonminimal_bool.rs:19:13\n+  --> $DIR/nonminimal_bool.rs:20:13\n    |\n LL |     let _ = !a && !(b && c);\n    |             ^^^^^^^^^^^^^^^ help: try: `!(a || b && c)`\n \n error: this boolean expression can be simplified\n-  --> $DIR/nonminimal_bool.rs:27:13\n+  --> $DIR/nonminimal_bool.rs:28:13\n    |\n LL |     let _ = a == b && c == 5 && a == b;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -56,7 +56,7 @@ LL |     let _ = a == b && c == 5;\n    |             ~~~~~~~~~~~~~~~~\n \n error: this boolean expression can be simplified\n-  --> $DIR/nonminimal_bool.rs:28:13\n+  --> $DIR/nonminimal_bool.rs:29:13\n    |\n LL |     let _ = a == b || c == 5 || a == b;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -69,7 +69,7 @@ LL |     let _ = a == b || c == 5;\n    |             ~~~~~~~~~~~~~~~~\n \n error: this boolean expression can be simplified\n-  --> $DIR/nonminimal_bool.rs:29:13\n+  --> $DIR/nonminimal_bool.rs:30:13\n    |\n LL |     let _ = a == b && c == 5 && b == a;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -82,7 +82,7 @@ LL |     let _ = a == b && c == 5;\n    |             ~~~~~~~~~~~~~~~~\n \n error: this boolean expression can be simplified\n-  --> $DIR/nonminimal_bool.rs:30:13\n+  --> $DIR/nonminimal_bool.rs:31:13\n    |\n LL |     let _ = a != b || !(a != b || c == d);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -95,7 +95,7 @@ LL |     let _ = a != b || c != d;\n    |             ~~~~~~~~~~~~~~~~\n \n error: this boolean expression can be simplified\n-  --> $DIR/nonminimal_bool.rs:31:13\n+  --> $DIR/nonminimal_bool.rs:32:13\n    |\n LL |     let _ = a != b && !(a != b && c == d);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "fd15001e540c6021d472bfd293fff12a53dec206", "filename": "src/tools/clippy/tests/ui/ptr_arg.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fptr_arg.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,3 +1,4 @@\n+#![feature(lint_reasons)]\n #![allow(unused, clippy::many_single_char_names, clippy::redundant_clone)]\n #![warn(clippy::ptr_arg)]\n \n@@ -109,16 +110,20 @@ mod issue_5644 {\n         #[allow(clippy::ptr_arg)] _s: &String,\n         #[allow(clippy::ptr_arg)] _p: &PathBuf,\n         #[allow(clippy::ptr_arg)] _c: &Cow<[i32]>,\n+        #[expect(clippy::ptr_arg)] _expect: &Cow<[i32]>,\n     ) {\n     }\n \n+    fn some_allowed(#[allow(clippy::ptr_arg)] _v: &Vec<u32>, _s: &String) {}\n+\n     struct S;\n     impl S {\n         fn allowed(\n             #[allow(clippy::ptr_arg)] _v: &Vec<u32>,\n             #[allow(clippy::ptr_arg)] _s: &String,\n             #[allow(clippy::ptr_arg)] _p: &PathBuf,\n             #[allow(clippy::ptr_arg)] _c: &Cow<[i32]>,\n+            #[expect(clippy::ptr_arg)] _expect: &Cow<[i32]>,\n         ) {\n         }\n     }\n@@ -129,6 +134,7 @@ mod issue_5644 {\n             #[allow(clippy::ptr_arg)] _s: &String,\n             #[allow(clippy::ptr_arg)] _p: &PathBuf,\n             #[allow(clippy::ptr_arg)] _c: &Cow<[i32]>,\n+            #[expect(clippy::ptr_arg)] _expect: &Cow<[i32]>,\n         ) {\n         }\n     }"}, {"sha": "d64b5f454a5aa985f2d966e153befb4cb9d07e8d", "filename": "src/tools/clippy/tests/ui/ptr_arg.stderr", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fptr_arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fptr_arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fptr_arg.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,49 +1,49 @@\n error: writing `&Vec` instead of `&[_]` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:7:14\n+  --> $DIR/ptr_arg.rs:8:14\n    |\n LL | fn do_vec(x: &Vec<i64>) {\n    |              ^^^^^^^^^ help: change this to: `&[i64]`\n    |\n    = note: `-D clippy::ptr-arg` implied by `-D warnings`\n \n error: writing `&mut Vec` instead of `&mut [_]` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:11:18\n+  --> $DIR/ptr_arg.rs:12:18\n    |\n LL | fn do_vec_mut(x: &mut Vec<i64>) {\n    |                  ^^^^^^^^^^^^^ help: change this to: `&mut [i64]`\n \n error: writing `&String` instead of `&str` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:15:14\n+  --> $DIR/ptr_arg.rs:16:14\n    |\n LL | fn do_str(x: &String) {\n    |              ^^^^^^^ help: change this to: `&str`\n \n error: writing `&mut String` instead of `&mut str` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:19:18\n+  --> $DIR/ptr_arg.rs:20:18\n    |\n LL | fn do_str_mut(x: &mut String) {\n    |                  ^^^^^^^^^^^ help: change this to: `&mut str`\n \n error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:23:15\n+  --> $DIR/ptr_arg.rs:24:15\n    |\n LL | fn do_path(x: &PathBuf) {\n    |               ^^^^^^^^ help: change this to: `&Path`\n \n error: writing `&mut PathBuf` instead of `&mut Path` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:27:19\n+  --> $DIR/ptr_arg.rs:28:19\n    |\n LL | fn do_path_mut(x: &mut PathBuf) {\n    |                   ^^^^^^^^^^^^ help: change this to: `&mut Path`\n \n error: writing `&Vec` instead of `&[_]` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:35:18\n+  --> $DIR/ptr_arg.rs:36:18\n    |\n LL |     fn do_vec(x: &Vec<i64>);\n    |                  ^^^^^^^^^ help: change this to: `&[i64]`\n \n error: writing `&Vec` instead of `&[_]` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:48:14\n+  --> $DIR/ptr_arg.rs:49:14\n    |\n LL | fn cloned(x: &Vec<u8>) -> Vec<u8> {\n    |              ^^^^^^^^\n@@ -60,7 +60,7 @@ LL ~     x.to_owned()\n    |\n \n error: writing `&String` instead of `&str` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:57:18\n+  --> $DIR/ptr_arg.rs:58:18\n    |\n LL | fn str_cloned(x: &String) -> String {\n    |                  ^^^^^^^\n@@ -76,7 +76,7 @@ LL ~     x.to_owned()\n    |\n \n error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:65:19\n+  --> $DIR/ptr_arg.rs:66:19\n    |\n LL | fn path_cloned(x: &PathBuf) -> PathBuf {\n    |                   ^^^^^^^^\n@@ -92,7 +92,7 @@ LL ~     x.to_path_buf()\n    |\n \n error: writing `&String` instead of `&str` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:73:44\n+  --> $DIR/ptr_arg.rs:74:44\n    |\n LL | fn false_positive_capacity(x: &Vec<u8>, y: &String) {\n    |                                            ^^^^^^^\n@@ -106,13 +106,19 @@ LL ~     let c = y;\n    |\n \n error: using a reference to `Cow` is not recommended\n-  --> $DIR/ptr_arg.rs:87:25\n+  --> $DIR/ptr_arg.rs:88:25\n    |\n LL | fn test_cow_with_ref(c: &Cow<[i32]>) {}\n    |                         ^^^^^^^^^^^ help: change this to: `&[i32]`\n \n+error: writing `&String` instead of `&str` involves a new object where a slice will do\n+  --> $DIR/ptr_arg.rs:117:66\n+   |\n+LL |     fn some_allowed(#[allow(clippy::ptr_arg)] _v: &Vec<u32>, _s: &String) {}\n+   |                                                                  ^^^^^^^ help: change this to: `&str`\n+\n error: writing `&Vec` instead of `&[_]` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:140:21\n+  --> $DIR/ptr_arg.rs:146:21\n    |\n LL |     fn foo_vec(vec: &Vec<u8>) {\n    |                     ^^^^^^^^\n@@ -125,7 +131,7 @@ LL ~         let _ = vec.to_owned().clone();\n    |\n \n error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:145:23\n+  --> $DIR/ptr_arg.rs:151:23\n    |\n LL |     fn foo_path(path: &PathBuf) {\n    |                       ^^^^^^^^\n@@ -138,7 +144,7 @@ LL ~         let _ = path.to_path_buf().clone();\n    |\n \n error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:150:21\n+  --> $DIR/ptr_arg.rs:156:21\n    |\n LL |     fn foo_str(str: &PathBuf) {\n    |                     ^^^^^^^^\n@@ -151,10 +157,10 @@ LL ~         let _ = str.to_path_buf().clone();\n    |\n \n error: writing `&mut Vec` instead of `&mut [_]` involves a new object where a slice will do\n-  --> $DIR/ptr_arg.rs:156:29\n+  --> $DIR/ptr_arg.rs:162:29\n    |\n LL | fn mut_vec_slice_methods(v: &mut Vec<u32>) {\n    |                             ^^^^^^^^^^^^^ help: change this to: `&mut [u32]`\n \n-error: aborting due to 16 previous errors\n+error: aborting due to 17 previous errors\n "}, {"sha": "da52c0acf93b0fd463f70b4af1f448ece365acfb", "filename": "src/tools/clippy/tests/ui/redundant_clone.fixed", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_clone.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_clone.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_clone.fixed?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n // rustfix-only-machine-applicable\n \n+#![feature(lint_reasons)]\n #![allow(clippy::implicit_clone, clippy::drop_non_drop)]\n use std::ffi::OsString;\n use std::path::Path;\n@@ -29,6 +30,10 @@ fn main() {\n     #[allow(clippy::redundant_clone)]\n     let _s = String::new().to_string();\n \n+    // Check that lint level works\n+    #[expect(clippy::redundant_clone)]\n+    let _s = String::new().to_string();\n+\n     let tup = (String::from(\"foo\"),);\n     let _t = tup.0;\n "}, {"sha": "5867d019dbb7d4742713541a5c81af848c24233a", "filename": "src/tools/clippy/tests/ui/redundant_clone.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_clone.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n // rustfix-only-machine-applicable\n \n+#![feature(lint_reasons)]\n #![allow(clippy::implicit_clone, clippy::drop_non_drop)]\n use std::ffi::OsString;\n use std::path::Path;\n@@ -29,6 +30,10 @@ fn main() {\n     #[allow(clippy::redundant_clone)]\n     let _s = String::new().to_string();\n \n+    // Check that lint level works\n+    #[expect(clippy::redundant_clone)]\n+    let _s = String::new().to_string();\n+\n     let tup = (String::from(\"foo\"),);\n     let _t = tup.0.clone();\n "}, {"sha": "aa1dd7cbb45cdb9f3e5aaf8ad0ffc4df8f5cdb52", "filename": "src/tools/clippy/tests/ui/redundant_clone.stderr", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_clone.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,180 +1,180 @@\n error: redundant clone\n-  --> $DIR/redundant_clone.rs:9:42\n+  --> $DIR/redundant_clone.rs:10:42\n    |\n LL |     let _s = [\"lorem\", \"ipsum\"].join(\" \").to_string();\n    |                                          ^^^^^^^^^^^^ help: remove this\n    |\n    = note: `-D clippy::redundant-clone` implied by `-D warnings`\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:9:14\n+  --> $DIR/redundant_clone.rs:10:14\n    |\n LL |     let _s = [\"lorem\", \"ipsum\"].join(\" \").to_string();\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:12:15\n+  --> $DIR/redundant_clone.rs:13:15\n    |\n LL |     let _s = s.clone();\n    |               ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:12:14\n+  --> $DIR/redundant_clone.rs:13:14\n    |\n LL |     let _s = s.clone();\n    |              ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:15:15\n+  --> $DIR/redundant_clone.rs:16:15\n    |\n LL |     let _s = s.to_string();\n    |               ^^^^^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:15:14\n+  --> $DIR/redundant_clone.rs:16:14\n    |\n LL |     let _s = s.to_string();\n    |              ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:18:15\n+  --> $DIR/redundant_clone.rs:19:15\n    |\n LL |     let _s = s.to_owned();\n    |               ^^^^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:18:14\n+  --> $DIR/redundant_clone.rs:19:14\n    |\n LL |     let _s = s.to_owned();\n    |              ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:20:42\n+  --> $DIR/redundant_clone.rs:21:42\n    |\n LL |     let _s = Path::new(\"/a/b/\").join(\"c\").to_owned();\n    |                                          ^^^^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:20:14\n+  --> $DIR/redundant_clone.rs:21:14\n    |\n LL |     let _s = Path::new(\"/a/b/\").join(\"c\").to_owned();\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:22:42\n+  --> $DIR/redundant_clone.rs:23:42\n    |\n LL |     let _s = Path::new(\"/a/b/\").join(\"c\").to_path_buf();\n    |                                          ^^^^^^^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:22:14\n+  --> $DIR/redundant_clone.rs:23:14\n    |\n LL |     let _s = Path::new(\"/a/b/\").join(\"c\").to_path_buf();\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:24:29\n+  --> $DIR/redundant_clone.rs:25:29\n    |\n LL |     let _s = OsString::new().to_owned();\n    |                             ^^^^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:24:14\n+  --> $DIR/redundant_clone.rs:25:14\n    |\n LL |     let _s = OsString::new().to_owned();\n    |              ^^^^^^^^^^^^^^^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:26:29\n+  --> $DIR/redundant_clone.rs:27:29\n    |\n LL |     let _s = OsString::new().to_os_string();\n    |                             ^^^^^^^^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:26:14\n+  --> $DIR/redundant_clone.rs:27:14\n    |\n LL |     let _s = OsString::new().to_os_string();\n    |              ^^^^^^^^^^^^^^^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:33:19\n+  --> $DIR/redundant_clone.rs:38:19\n    |\n LL |     let _t = tup.0.clone();\n    |                   ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:33:14\n+  --> $DIR/redundant_clone.rs:38:14\n    |\n LL |     let _t = tup.0.clone();\n    |              ^^^^^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:65:25\n+  --> $DIR/redundant_clone.rs:70:25\n    |\n LL |     if b { (a.clone(), a.clone()) } else { (Alpha, a) }\n    |                         ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:65:24\n+  --> $DIR/redundant_clone.rs:70:24\n    |\n LL |     if b { (a.clone(), a.clone()) } else { (Alpha, a) }\n    |                        ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:122:15\n+  --> $DIR/redundant_clone.rs:127:15\n    |\n LL |     let _s = s.clone();\n    |               ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:122:14\n+  --> $DIR/redundant_clone.rs:127:14\n    |\n LL |     let _s = s.clone();\n    |              ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:123:15\n+  --> $DIR/redundant_clone.rs:128:15\n    |\n LL |     let _t = t.clone();\n    |               ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:123:14\n+  --> $DIR/redundant_clone.rs:128:14\n    |\n LL |     let _t = t.clone();\n    |              ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:133:19\n+  --> $DIR/redundant_clone.rs:138:19\n    |\n LL |         let _f = f.clone();\n    |                   ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:133:18\n+  --> $DIR/redundant_clone.rs:138:18\n    |\n LL |         let _f = f.clone();\n    |                  ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:145:14\n+  --> $DIR/redundant_clone.rs:150:14\n    |\n LL |     let y = x.clone().join(\"matthias\");\n    |              ^^^^^^^^ help: remove this\n    |\n note: cloned value is neither consumed nor mutated\n-  --> $DIR/redundant_clone.rs:145:13\n+  --> $DIR/redundant_clone.rs:150:13\n    |\n LL |     let y = x.clone().join(\"matthias\");\n    |             ^^^^^^^^^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:199:11\n+  --> $DIR/redundant_clone.rs:204:11\n    |\n LL |     foo(&x.clone(), move || {\n    |           ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:199:10\n+  --> $DIR/redundant_clone.rs:204:10\n    |\n LL |     foo(&x.clone(), move || {\n    |          ^"}, {"sha": "c8d0e56b197f4e939022ac07eddbdb8018176d84", "filename": "src/tools/clippy/tests/ui/ref_binding_to_reference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fref_binding_to_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fref_binding_to_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fref_binding_to_reference.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -2,7 +2,7 @@\n \n #![feature(lint_reasons)]\n #![warn(clippy::ref_binding_to_reference)]\n-#![allow(clippy::needless_borrowed_reference)]\n+#![allow(clippy::needless_borrowed_reference, clippy::explicit_auto_deref)]\n \n fn f1(_: &str) {}\n macro_rules! m2 {"}, {"sha": "5190c5304c75d127f0c03deff0c424e049fb580d", "filename": "src/tools/clippy/tests/ui/search_is_some_fixable_none.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsearch_is_some_fixable_none.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsearch_is_some_fixable_none.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsearch_is_some_fixable_none.fixed?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(dead_code)]\n+#![allow(dead_code, clippy::explicit_auto_deref)]\n #![warn(clippy::search_is_some)]\n \n fn main() {"}, {"sha": "310d87333a93c4270f8becf2466705c70208a6bf", "filename": "src/tools/clippy/tests/ui/search_is_some_fixable_none.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsearch_is_some_fixable_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsearch_is_some_fixable_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsearch_is_some_fixable_none.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(dead_code)]\n+#![allow(dead_code, clippy::explicit_auto_deref)]\n #![warn(clippy::search_is_some)]\n \n fn main() {"}, {"sha": "5a2aee465d1bdee6d95cd79f1763aef9b73e4300", "filename": "src/tools/clippy/tests/ui/search_is_some_fixable_some.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsearch_is_some_fixable_some.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsearch_is_some_fixable_some.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsearch_is_some_fixable_some.fixed?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(dead_code)]\n+#![allow(dead_code, clippy::explicit_auto_deref)]\n #![warn(clippy::search_is_some)]\n \n fn main() {"}, {"sha": "0e98ae18a217cb840dad5c974c1b221488c64b14", "filename": "src/tools/clippy/tests/ui/search_is_some_fixable_some.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsearch_is_some_fixable_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsearch_is_some_fixable_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsearch_is_some_fixable_some.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(dead_code)]\n+#![allow(dead_code, clippy::explicit_auto_deref)]\n #![warn(clippy::search_is_some)]\n \n fn main() {"}, {"sha": "50999c6f2198b024c29b657425ccbf89c1692b12", "filename": "src/tools/clippy/tests/ui/should_impl_trait/corner_cases.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshould_impl_trait%2Fcorner_cases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshould_impl_trait%2Fcorner_cases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fshould_impl_trait%2Fcorner_cases.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -8,7 +8,8 @@\n     clippy::missing_safety_doc,\n     clippy::wrong_self_convention,\n     clippy::missing_panics_doc,\n-    clippy::return_self_not_must_use\n+    clippy::return_self_not_must_use,\n+    clippy::unused_async\n )]\n \n use std::ops::Mul;"}, {"sha": "185e5009b60f1500db71b3e49cbad47f3cc09462", "filename": "src/tools/clippy/tests/ui/significant_drop_in_scrutinee.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsignificant_drop_in_scrutinee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsignificant_drop_in_scrutinee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsignificant_drop_in_scrutinee.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -64,6 +64,19 @@ fn should_trigger_lint_with_mutex_guard_in_match_scrutinee() {\n     };\n }\n \n+fn should_not_trigger_lint_with_mutex_guard_in_match_scrutinee_when_lint_allowed() {\n+    let mutex = Mutex::new(State {});\n+\n+    // Lint should not be triggered because it is \"allowed\" below.\n+    #[allow(clippy::significant_drop_in_scrutinee)]\n+    match mutex.lock().unwrap().foo() {\n+        true => {\n+            mutex.lock().unwrap().bar();\n+        },\n+        false => {},\n+    };\n+}\n+\n fn should_not_trigger_lint_for_insignificant_drop() {\n     // Should not trigger lint because there are no temporaries whose drops have a significant\n     // side effect.\n@@ -591,4 +604,20 @@ fn should_trigger_lint_for_read_write_lock_for_loop() {\n     }\n }\n \n+fn do_bar(mutex: &Mutex<State>) {\n+    mutex.lock().unwrap().bar();\n+}\n+\n+fn should_trigger_lint_without_significant_drop_in_arm() {\n+    let mutex = Mutex::new(State {});\n+\n+    // Should trigger lint because the lifetime of the temporary MutexGuard is surprising because it\n+    // is preserved until the end of the match, but there is no clear indication that this is the\n+    // case.\n+    match mutex.lock().unwrap().foo() {\n+        true => do_bar(&mutex),\n+        false => {},\n+    };\n+}\n+\n fn main() {}"}, {"sha": "88ea6bce25b6bb0249aeb7379bae80b14195ce36", "filename": "src/tools/clippy/tests/ui/significant_drop_in_scrutinee.stderr", "status": "modified", "additions": 264, "deletions": 67, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsignificant_drop_in_scrutinee.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsignificant_drop_in_scrutinee.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsignificant_drop_in_scrutinee.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,174 +1,290 @@\n-error: temporary with significant drop in match scrutinee\n+error: temporary with significant `Drop` in `match` scrutinee will live until the end of the `match` expression\n   --> $DIR/significant_drop_in_scrutinee.rs:59:11\n    |\n LL |     match mutex.lock().unwrap().foo() {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         true => {\n+LL |             mutex.lock().unwrap().bar();\n+   |             --------------------- another value with significant `Drop` created here\n+...\n+LL |     };\n+   |      - temporary lives until here\n    |\n    = note: `-D clippy::significant-drop-in-scrutinee` implied by `-D warnings`\n+   = note: this might lead to deadlocks or other unexpected behavior\n help: try moving the temporary above the match\n    |\n LL ~     let value = mutex.lock().unwrap().foo();\n LL ~     match value {\n    |\n \n-error: temporary with significant drop in match scrutinee\n-  --> $DIR/significant_drop_in_scrutinee.rs:132:11\n+error: temporary with significant `Drop` in `match` scrutinee will live until the end of the `match` expression\n+  --> $DIR/significant_drop_in_scrutinee.rs:145:11\n    |\n LL |     match s.lock_m().get_the_value() {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n+...\n+LL |             println!(\"{}\", s.lock_m().get_the_value());\n+   |                            ---------- another value with significant `Drop` created here\n+...\n+LL |     }\n+   |      - temporary lives until here\n+   |\n+   = note: this might lead to deadlocks or other unexpected behavior\n help: try moving the temporary above the match\n    |\n LL ~     let value = s.lock_m().get_the_value();\n LL ~     match value {\n    |\n \n-error: temporary with significant drop in match scrutinee\n-  --> $DIR/significant_drop_in_scrutinee.rs:153:11\n+error: temporary with significant `Drop` in `match` scrutinee will live until the end of the `match` expression\n+  --> $DIR/significant_drop_in_scrutinee.rs:166:11\n    |\n LL |     match s.lock_m_m().get_the_value() {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n+...\n+LL |             println!(\"{}\", s.lock_m().get_the_value());\n+   |                            ---------- another value with significant `Drop` created here\n+...\n+LL |     }\n+   |      - temporary lives until here\n+   |\n+   = note: this might lead to deadlocks or other unexpected behavior\n help: try moving the temporary above the match\n    |\n LL ~     let value = s.lock_m_m().get_the_value();\n LL ~     match value {\n    |\n \n-error: temporary with significant drop in match scrutinee\n-  --> $DIR/significant_drop_in_scrutinee.rs:201:11\n+error: temporary with significant `Drop` in `match` scrutinee will live until the end of the `match` expression\n+  --> $DIR/significant_drop_in_scrutinee.rs:214:11\n    |\n LL |     match counter.temp_increment().len() {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |     };\n+   |      - temporary lives until here\n    |\n+   = note: this might lead to deadlocks or other unexpected behavior\n help: try moving the temporary above the match\n    |\n LL ~     let value = counter.temp_increment().len();\n LL ~     match value {\n    |\n \n-error: temporary with significant drop in match scrutinee\n-  --> $DIR/significant_drop_in_scrutinee.rs:224:16\n+error: temporary with significant `Drop` in `match` scrutinee will live until the end of the `match` expression\n+  --> $DIR/significant_drop_in_scrutinee.rs:237:16\n    |\n LL |         match (mutex1.lock().unwrap().s.len(), true) {\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n+...\n+LL |                 mutex1.lock().unwrap().s.len();\n+   |                 ---------------------- another value with significant `Drop` created here\n+...\n+LL |         };\n+   |          - temporary lives until here\n+   |\n+   = note: this might lead to deadlocks or other unexpected behavior\n help: try moving the temporary above the match\n    |\n LL ~         let value = mutex1.lock().unwrap().s.len();\n LL ~         match (value, true) {\n    |\n \n-error: temporary with significant drop in match scrutinee\n-  --> $DIR/significant_drop_in_scrutinee.rs:233:22\n+error: temporary with significant `Drop` in `match` scrutinee will live until the end of the `match` expression\n+  --> $DIR/significant_drop_in_scrutinee.rs:246:22\n    |\n LL |         match (true, mutex1.lock().unwrap().s.len(), true) {\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n+...\n+LL |                 mutex1.lock().unwrap().s.len();\n+   |                 ---------------------- another value with significant `Drop` created here\n+...\n+LL |         };\n+   |          - temporary lives until here\n+   |\n+   = note: this might lead to deadlocks or other unexpected behavior\n help: try moving the temporary above the match\n    |\n LL ~         let value = mutex1.lock().unwrap().s.len();\n LL ~         match (true, value, true) {\n    |\n \n-error: temporary with significant drop in match scrutinee\n-  --> $DIR/significant_drop_in_scrutinee.rs:243:16\n+error: temporary with significant `Drop` in `match` scrutinee will live until the end of the `match` expression\n+  --> $DIR/significant_drop_in_scrutinee.rs:256:16\n    |\n LL |         match (mutex1.lock().unwrap().s.len(), true, mutex2.lock().unwrap().s.len()) {\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n+...\n+LL |                 mutex1.lock().unwrap().s.len();\n+   |                 ---------------------- another value with significant `Drop` created here\n+LL |                 mutex2.lock().unwrap().s.len();\n+   |                 ---------------------- another value with significant `Drop` created here\n+...\n+LL |         };\n+   |          - temporary lives until here\n+   |\n+   = note: this might lead to deadlocks or other unexpected behavior\n help: try moving the temporary above the match\n    |\n LL ~         let value = mutex1.lock().unwrap().s.len();\n LL ~         match (value, true, mutex2.lock().unwrap().s.len()) {\n    |\n \n-error: temporary with significant drop in match scrutinee\n-  --> $DIR/significant_drop_in_scrutinee.rs:243:54\n+error: temporary with significant `Drop` in `match` scrutinee will live until the end of the `match` expression\n+  --> $DIR/significant_drop_in_scrutinee.rs:256:54\n    |\n LL |         match (mutex1.lock().unwrap().s.len(), true, mutex2.lock().unwrap().s.len()) {\n    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n+...\n+LL |                 mutex1.lock().unwrap().s.len();\n+   |                 ---------------------- another value with significant `Drop` created here\n+LL |                 mutex2.lock().unwrap().s.len();\n+   |                 ---------------------- another value with significant `Drop` created here\n+...\n+LL |         };\n+   |          - temporary lives until here\n+   |\n+   = note: this might lead to deadlocks or other unexpected behavior\n help: try moving the temporary above the match\n    |\n LL ~         let value = mutex2.lock().unwrap().s.len();\n LL ~         match (mutex1.lock().unwrap().s.len(), true, value) {\n    |\n \n-error: temporary with significant drop in match scrutinee\n-  --> $DIR/significant_drop_in_scrutinee.rs:254:15\n+error: temporary with significant `Drop` in `match` scrutinee will live until the end of the `match` expression\n+  --> $DIR/significant_drop_in_scrutinee.rs:267:15\n    |\n LL |         match mutex3.lock().unwrap().s.as_str() {\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |                 mutex1.lock().unwrap().s.len();\n+   |                 ---------------------- another value with significant `Drop` created here\n+LL |                 mutex2.lock().unwrap().s.len();\n+   |                 ---------------------- another value with significant `Drop` created here\n+...\n+LL |         };\n+   |          - temporary lives until here\n+   |\n+   = note: this might lead to deadlocks or other unexpected behavior\n \n-error: temporary with significant drop in match scrutinee\n-  --> $DIR/significant_drop_in_scrutinee.rs:264:22\n+error: temporary with significant `Drop` in `match` scrutinee will live until the end of the `match` expression\n+  --> $DIR/significant_drop_in_scrutinee.rs:277:22\n    |\n LL |         match (true, mutex3.lock().unwrap().s.as_str()) {\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |                 mutex1.lock().unwrap().s.len();\n+   |                 ---------------------- another value with significant `Drop` created here\n+LL |                 mutex2.lock().unwrap().s.len();\n+   |                 ---------------------- another value with significant `Drop` created here\n+...\n+LL |         };\n+   |          - temporary lives until here\n+   |\n+   = note: this might lead to deadlocks or other unexpected behavior\n \n-error: temporary with significant drop in match scrutinee\n-  --> $DIR/significant_drop_in_scrutinee.rs:283:11\n+error: temporary with significant `Drop` in `match` scrutinee will live until the end of the `match` expression\n+  --> $DIR/significant_drop_in_scrutinee.rs:296:11\n    |\n LL |     match mutex.lock().unwrap().s.len() > 1 {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n+LL |         true => {\n+LL |             mutex.lock().unwrap().s.len();\n+   |             --------------------- another value with significant `Drop` created here\n+...\n+LL |     };\n+   |      - temporary lives until here\n+   |\n+   = note: this might lead to deadlocks or other unexpected behavior\n help: try moving the temporary above the match\n    |\n LL ~     let value = mutex.lock().unwrap().s.len() > 1;\n LL ~     match value {\n    |\n \n-error: temporary with significant drop in match scrutinee\n-  --> $DIR/significant_drop_in_scrutinee.rs:290:11\n+error: temporary with significant `Drop` in `match` scrutinee will live until the end of the `match` expression\n+  --> $DIR/significant_drop_in_scrutinee.rs:303:11\n    |\n LL |     match 1 < mutex.lock().unwrap().s.len() {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n+LL |         true => {\n+LL |             mutex.lock().unwrap().s.len();\n+   |             --------------------- another value with significant `Drop` created here\n+...\n+LL |     };\n+   |      - temporary lives until here\n+   |\n+   = note: this might lead to deadlocks or other unexpected behavior\n help: try moving the temporary above the match\n    |\n LL ~     let value = 1 < mutex.lock().unwrap().s.len();\n LL ~     match value {\n    |\n \n-error: temporary with significant drop in match scrutinee\n-  --> $DIR/significant_drop_in_scrutinee.rs:308:11\n+error: temporary with significant `Drop` in `match` scrutinee will live until the end of the `match` expression\n+  --> $DIR/significant_drop_in_scrutinee.rs:321:11\n    |\n LL |     match mutex1.lock().unwrap().s.len() < mutex2.lock().unwrap().s.len() {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n+...\n+LL |                 mutex1.lock().unwrap().s.len(),\n+   |                 ---------------------- another value with significant `Drop` created here\n+LL |                 mutex2.lock().unwrap().s.len()\n+   |                 ---------------------- another value with significant `Drop` created here\n+...\n+LL |     };\n+   |      - temporary lives until here\n+   |\n+   = note: this might lead to deadlocks or other unexpected behavior\n help: try moving the temporary above the match\n    |\n LL ~     let value = mutex1.lock().unwrap().s.len() < mutex2.lock().unwrap().s.len();\n LL ~     match value {\n    |\n \n-error: temporary with significant drop in match scrutinee\n-  --> $DIR/significant_drop_in_scrutinee.rs:319:11\n+error: temporary with significant `Drop` in `match` scrutinee will live until the end of the `match` expression\n+  --> $DIR/significant_drop_in_scrutinee.rs:332:11\n    |\n LL |     match mutex1.lock().unwrap().s.len() >= mutex2.lock().unwrap().s.len() {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n+...\n+LL |                 mutex1.lock().unwrap().s.len(),\n+   |                 ---------------------- another value with significant `Drop` created here\n+LL |                 mutex2.lock().unwrap().s.len()\n+   |                 ---------------------- another value with significant `Drop` created here\n+...\n+LL |     };\n+   |      - temporary lives until here\n+   |\n+   = note: this might lead to deadlocks or other unexpected behavior\n help: try moving the temporary above the match\n    |\n LL ~     let value = mutex1.lock().unwrap().s.len() >= mutex2.lock().unwrap().s.len();\n LL ~     match value {\n    |\n \n-error: temporary with significant drop in match scrutinee\n-  --> $DIR/significant_drop_in_scrutinee.rs:354:11\n+error: temporary with significant `Drop` in `match` scrutinee will live until the end of the `match` expression\n+  --> $DIR/significant_drop_in_scrutinee.rs:367:11\n    |\n LL |     match get_mutex_guard().s.len() > 1 {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n+LL |         true => {\n+LL |             mutex1.lock().unwrap().s.len();\n+   |             ---------------------- another value with significant `Drop` created here\n+...\n+LL |     };\n+   |      - temporary lives until here\n+   |\n+   = note: this might lead to deadlocks or other unexpected behavior\n help: try moving the temporary above the match\n    |\n LL ~     let value = get_mutex_guard().s.len() > 1;\n LL ~     match value {\n    |\n \n-error: temporary with significant drop in match scrutinee\n-  --> $DIR/significant_drop_in_scrutinee.rs:371:11\n+error: temporary with significant `Drop` in `match` scrutinee will live until the end of the `match` expression\n+  --> $DIR/significant_drop_in_scrutinee.rs:384:11\n    |\n LL |       match match i {\n    |  ___________^\n@@ -179,7 +295,14 @@ LL | |     .s\n LL | |     .len()\n LL | |         > 1\n    | |___________^\n-   |\n+...\n+LL |               mutex1.lock().unwrap().s.len();\n+   |               ---------------------- another value with significant `Drop` created here\n+...\n+LL |       };\n+   |        - temporary lives until here\n+   |\n+   = note: this might lead to deadlocks or other unexpected behavior\n help: try moving the temporary above the match\n    |\n LL ~     let value = match i {\n@@ -192,8 +315,8 @@ LL +         > 1;\n LL ~     match value\n    |\n \n-error: temporary with significant drop in match scrutinee\n-  --> $DIR/significant_drop_in_scrutinee.rs:397:11\n+error: temporary with significant `Drop` in `match` scrutinee will live until the end of the `match` expression\n+  --> $DIR/significant_drop_in_scrutinee.rs:410:11\n    |\n LL |       match if i > 1 {\n    |  ___________^\n@@ -204,7 +327,14 @@ LL | |         mutex2.lock().unwrap()\n LL | |     .len()\n LL | |         > 1\n    | |___________^\n-   |\n+...\n+LL |               mutex1.lock().unwrap().s.len();\n+   |               ---------------------- another value with significant `Drop` created here\n+...\n+LL |       };\n+   |        - temporary lives until here\n+   |\n+   = note: this might lead to deadlocks or other unexpected behavior\n help: try moving the temporary above the match\n    |\n LL ~     let value = if i > 1 {\n@@ -218,83 +348,150 @@ LL +         > 1;\n LL ~     match value\n    |\n \n-error: temporary with significant drop in match scrutinee\n-  --> $DIR/significant_drop_in_scrutinee.rs:451:11\n+error: temporary with significant `Drop` in `match` scrutinee will live until the end of the `match` expression\n+  --> $DIR/significant_drop_in_scrutinee.rs:464:11\n    |\n LL |     match s.lock().deref().deref() {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         0 | 1 => println!(\"Value was less than 2\"),\n+LL |         _ => println!(\"Value is {}\", s.lock().deref()),\n+   |                                      ---------------- another value with significant `Drop` created here\n+LL |     };\n+   |      - temporary lives until here\n    |\n+   = note: this might lead to deadlocks or other unexpected behavior\n help: try moving the temporary above the match and create a copy\n    |\n LL ~     let value = *s.lock().deref().deref();\n LL ~     match value {\n    |\n \n-error: temporary with significant drop in match scrutinee\n-  --> $DIR/significant_drop_in_scrutinee.rs:479:11\n+error: temporary with significant `Drop` in `match` scrutinee will live until the end of the `match` expression\n+  --> $DIR/significant_drop_in_scrutinee.rs:492:11\n    |\n LL |     match s.lock().deref().deref() {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         matcher => println!(\"Value is {}\", s.lock().deref()),\n+   |                                            ---------------- another value with significant `Drop` created here\n+LL |         _ => println!(\"Value was not a match\"),\n+LL |     };\n+   |      - temporary lives until here\n+   |\n+   = note: this might lead to deadlocks or other unexpected behavior\n \n-error: temporary with significant drop in match scrutinee\n-  --> $DIR/significant_drop_in_scrutinee.rs:498:11\n+error: temporary with significant `Drop` in `match` scrutinee will live until the end of the `match` expression\n+  --> $DIR/significant_drop_in_scrutinee.rs:511:11\n    |\n LL |     match mutex.lock().unwrap().i = i {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n+LL |         _ => {\n+LL |             println!(\"{}\", mutex.lock().unwrap().i);\n+   |                            --------------------- another value with significant `Drop` created here\n+LL |         },\n+LL |     };\n+   |      - temporary lives until here\n+   |\n+   = note: this might lead to deadlocks or other unexpected behavior\n help: try moving the temporary above the match\n    |\n LL ~     mutex.lock().unwrap().i = i;\n LL ~     match () {\n    |\n \n-error: temporary with significant drop in match scrutinee\n-  --> $DIR/significant_drop_in_scrutinee.rs:504:11\n+error: temporary with significant `Drop` in `match` scrutinee will live until the end of the `match` expression\n+  --> $DIR/significant_drop_in_scrutinee.rs:517:11\n    |\n LL |     match i = mutex.lock().unwrap().i {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n+LL |         _ => {\n+LL |             println!(\"{}\", mutex.lock().unwrap().i);\n+   |                            --------------------- another value with significant `Drop` created here\n+LL |         },\n+LL |     };\n+   |      - temporary lives until here\n+   |\n+   = note: this might lead to deadlocks or other unexpected behavior\n help: try moving the temporary above the match\n    |\n LL ~     i = mutex.lock().unwrap().i;\n LL ~     match () {\n    |\n \n-error: temporary with significant drop in match scrutinee\n-  --> $DIR/significant_drop_in_scrutinee.rs:510:11\n+error: temporary with significant `Drop` in `match` scrutinee will live until the end of the `match` expression\n+  --> $DIR/significant_drop_in_scrutinee.rs:523:11\n    |\n LL |     match mutex.lock().unwrap().i += 1 {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n+LL |         _ => {\n+LL |             println!(\"{}\", mutex.lock().unwrap().i);\n+   |                            --------------------- another value with significant `Drop` created here\n+LL |         },\n+LL |     };\n+   |      - temporary lives until here\n+   |\n+   = note: this might lead to deadlocks or other unexpected behavior\n help: try moving the temporary above the match\n    |\n LL ~     mutex.lock().unwrap().i += 1;\n LL ~     match () {\n    |\n \n-error: temporary with significant drop in match scrutinee\n-  --> $DIR/significant_drop_in_scrutinee.rs:516:11\n+error: temporary with significant `Drop` in `match` scrutinee will live until the end of the `match` expression\n+  --> $DIR/significant_drop_in_scrutinee.rs:529:11\n    |\n LL |     match i += mutex.lock().unwrap().i {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n+LL |         _ => {\n+LL |             println!(\"{}\", mutex.lock().unwrap().i);\n+   |                            --------------------- another value with significant `Drop` created here\n+LL |         },\n+LL |     };\n+   |      - temporary lives until here\n+   |\n+   = note: this might lead to deadlocks or other unexpected behavior\n help: try moving the temporary above the match\n    |\n LL ~     i += mutex.lock().unwrap().i;\n LL ~     match () {\n    |\n \n-error: temporary with significant drop in match scrutinee\n-  --> $DIR/significant_drop_in_scrutinee.rs:579:11\n+error: temporary with significant `Drop` in `match` scrutinee will live until the end of the `match` expression\n+  --> $DIR/significant_drop_in_scrutinee.rs:592:11\n    |\n LL |     match rwlock.read().unwrap().to_number() {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |     };\n+   |      - temporary lives until here\n+   |\n+   = note: this might lead to deadlocks or other unexpected behavior\n \n-error: temporary with significant drop in for loop\n-  --> $DIR/significant_drop_in_scrutinee.rs:589:14\n+error: temporary with significant `Drop` in `for` loop condition will live until the end of the `for` expression\n+  --> $DIR/significant_drop_in_scrutinee.rs:602:14\n    |\n LL |     for s in rwlock.read().unwrap().iter() {\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         println!(\"{}\", s);\n+LL |     }\n+   |      - temporary lives until here\n+   |\n+   = note: this might lead to deadlocks or other unexpected behavior\n+\n+error: temporary with significant `Drop` in `match` scrutinee will live until the end of the `match` expression\n+  --> $DIR/significant_drop_in_scrutinee.rs:617:11\n+   |\n+LL |     match mutex.lock().unwrap().foo() {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |     };\n+   |      - temporary lives until here\n+   |\n+   = note: this might lead to deadlocks or other unexpected behavior\n+help: try moving the temporary above the match\n+   |\n+LL ~     let value = mutex.lock().unwrap().foo();\n+LL ~     match value {\n+   |\n \n-error: aborting due to 25 previous errors\n+error: aborting due to 26 previous errors\n "}, {"sha": "4d2b9ec5f903aef7bd0b8486d8ffb1206339d328", "filename": "src/tools/clippy/tests/ui/single_match.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -38,6 +38,15 @@ LL | |         _ => {},\n LL | |     };\n    | |_____^ help: try this: `if let (2..=3, 7..=9) = z { dummy() }`\n \n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match.rs:54:5\n+   |\n+LL | /     match x {\n+LL | |         Some(y) => dummy(),\n+LL | |         None => (),\n+LL | |     };\n+   | |_____^ help: try this: `if let Some(y) = x { dummy() }`\n+\n error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n   --> $DIR/single_match.rs:59:5\n    |\n@@ -146,5 +155,5 @@ LL | |         (..) => {},\n LL | |     }\n    | |_____^ help: try this: `if let (.., Some(E::V), _) = (Some(42), Some(E::V), Some(42)) {}`\n \n-error: aborting due to 15 previous errors\n+error: aborting due to 16 previous errors\n "}, {"sha": "70d6febb71f9da4d7ea4d7adc0c094382960a1d9", "filename": "src/tools/clippy/tests/ui/single_match_else.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match_else.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -97,4 +97,23 @@ fn main() {\n             return;\n         },\n     }\n+\n+    // lint here\n+    use std::convert::Infallible;\n+    match Result::<i32, Infallible>::Ok(1) {\n+        Ok(a) => println!(\"${:?}\", a),\n+        Err(_) => {\n+            println!(\"else block\");\n+            return;\n+        }\n+    }\n+\n+    use std::borrow::Cow;\n+    match Cow::from(\"moo\") {\n+        Cow::Owned(a) => println!(\"${:?}\", a),\n+        Cow::Borrowed(_) => {\n+            println!(\"else block\");\n+            return;\n+        }\n+    }\n }"}, {"sha": "38fd9c6a6782ac87d4ab12a418581cb6bd813576", "filename": "src/tools/clippy/tests/ui/single_match_else.stderr", "status": "modified", "additions": 81, "deletions": 1, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match_else.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -20,5 +20,85 @@ LL +         None\n LL ~     };\n    |\n \n-error: aborting due to previous error\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match_else.rs:84:5\n+   |\n+LL | /     match Some(1) {\n+LL | |         Some(a) => println!(\"${:?}\", a),\n+LL | |         None => {\n+LL | |             println!(\"else block\");\n+LL | |             return\n+LL | |         },\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL ~     if let Some(a) = Some(1) { println!(\"${:?}\", a) } else {\n+LL +         println!(\"else block\");\n+LL +         return\n+LL +     }\n+   |\n+\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match_else.rs:93:5\n+   |\n+LL | /     match Some(1) {\n+LL | |         Some(a) => println!(\"${:?}\", a),\n+LL | |         None => {\n+LL | |             println!(\"else block\");\n+LL | |             return;\n+LL | |         },\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL ~     if let Some(a) = Some(1) { println!(\"${:?}\", a) } else {\n+LL +         println!(\"else block\");\n+LL +         return;\n+LL +     }\n+   |\n+\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match_else.rs:103:5\n+   |\n+LL | /     match Result::<i32, Infallible>::Ok(1) {\n+LL | |         Ok(a) => println!(\"${:?}\", a),\n+LL | |         Err(_) => {\n+LL | |             println!(\"else block\");\n+LL | |             return;\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL ~     if let Ok(a) = Result::<i32, Infallible>::Ok(1) { println!(\"${:?}\", a) } else {\n+LL +         println!(\"else block\");\n+LL +         return;\n+LL +     }\n+   |\n+\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match_else.rs:112:5\n+   |\n+LL | /     match Cow::from(\"moo\") {\n+LL | |         Cow::Owned(a) => println!(\"${:?}\", a),\n+LL | |         Cow::Borrowed(_) => {\n+LL | |             println!(\"else block\");\n+LL | |             return;\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL ~     if let Cow::Owned(a) = Cow::from(\"moo\") { println!(\"${:?}\", a) } else {\n+LL +         println!(\"else block\");\n+LL +         return;\n+LL +     }\n+   |\n+\n+error: aborting due to 5 previous errors\n "}, {"sha": "16be9f6d203aa3d332fc2af2964f60e1f580473a", "filename": "src/tools/clippy/tests/ui/slow_vector_initialization.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fslow_vector_initialization.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -19,6 +19,9 @@ fn extend_vector() {\n     // Extend with mismatching expression should not be warned\n     let mut vec3 = Vec::with_capacity(24322);\n     vec3.extend(repeat(0).take(2));\n+\n+    let mut vec4 = Vec::with_capacity(len);\n+    vec4.extend(repeat(0).take(vec4.capacity()));\n }\n \n fn mixed_extend_resize_vector() {\n@@ -48,6 +51,9 @@ fn resize_vector() {\n     let mut vec3 = Vec::with_capacity(len - 10);\n     vec3.resize(len - 10, 0);\n \n+    let mut vec4 = Vec::with_capacity(len);\n+    vec4.resize(vec4.capacity(), 0);\n+\n     // Reinitialization should be warned\n     vec1 = Vec::with_capacity(10);\n     vec1.resize(10, 0);"}, {"sha": "cb3ce3e95a7aff623bcd938760801b6ab3328707", "filename": "src/tools/clippy/tests/ui/slow_vector_initialization.stderr", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fslow_vector_initialization.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fslow_vector_initialization.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fslow_vector_initialization.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -17,44 +17,60 @@ LL |     vec2.extend(repeat(0).take(len - 10));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: slow zero-filling initialization\n-  --> $DIR/slow_vector_initialization.rs:31:5\n+  --> $DIR/slow_vector_initialization.rs:24:5\n+   |\n+LL |     let mut vec4 = Vec::with_capacity(len);\n+   |                    ----------------------- help: consider replace allocation with: `vec![0; len]`\n+LL |     vec4.extend(repeat(0).take(vec4.capacity()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: slow zero-filling initialization\n+  --> $DIR/slow_vector_initialization.rs:34:5\n    |\n LL |     let mut resized_vec = Vec::with_capacity(30);\n    |                           ---------------------- help: consider replace allocation with: `vec![0; 30]`\n LL |     resized_vec.resize(30, 0);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: slow zero-filling initialization\n-  --> $DIR/slow_vector_initialization.rs:34:5\n+  --> $DIR/slow_vector_initialization.rs:37:5\n    |\n LL |     let mut extend_vec = Vec::with_capacity(30);\n    |                          ---------------------- help: consider replace allocation with: `vec![0; 30]`\n LL |     extend_vec.extend(repeat(0).take(30));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: slow zero-filling initialization\n-  --> $DIR/slow_vector_initialization.rs:41:5\n+  --> $DIR/slow_vector_initialization.rs:44:5\n    |\n LL |     let mut vec1 = Vec::with_capacity(len);\n    |                    ----------------------- help: consider replace allocation with: `vec![0; len]`\n LL |     vec1.resize(len, 0);\n    |     ^^^^^^^^^^^^^^^^^^^\n \n error: slow zero-filling initialization\n-  --> $DIR/slow_vector_initialization.rs:49:5\n+  --> $DIR/slow_vector_initialization.rs:52:5\n    |\n LL |     let mut vec3 = Vec::with_capacity(len - 10);\n    |                    ---------------------------- help: consider replace allocation with: `vec![0; len - 10]`\n LL |     vec3.resize(len - 10, 0);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: slow zero-filling initialization\n-  --> $DIR/slow_vector_initialization.rs:53:5\n+  --> $DIR/slow_vector_initialization.rs:55:5\n+   |\n+LL |     let mut vec4 = Vec::with_capacity(len);\n+   |                    ----------------------- help: consider replace allocation with: `vec![0; len]`\n+LL |     vec4.resize(vec4.capacity(), 0);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: slow zero-filling initialization\n+  --> $DIR/slow_vector_initialization.rs:59:5\n    |\n LL |     vec1 = Vec::with_capacity(10);\n    |            ---------------------- help: consider replace allocation with: `vec![0; 10]`\n LL |     vec1.resize(10, 0);\n    |     ^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 9 previous errors\n "}, {"sha": "e5fe9133f975eebc1e6d6ff3821cecd36ba5480a", "filename": "src/tools/clippy/tests/ui/transmute_ptr_to_ref.fixed", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_ptr_to_ref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_ptr_to_ref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_ptr_to_ref.fixed?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -0,0 +1,78 @@\n+// run-rustfix\n+\n+#![feature(custom_inner_attributes)]\n+#![warn(clippy::transmute_ptr_to_ref)]\n+#![allow(clippy::match_single_binding)]\n+\n+unsafe fn _ptr_to_ref<T, U>(p: *const T, m: *mut T, o: *const U, om: *mut U) {\n+    let _: &T = &*p;\n+    let _: &T = &*p;\n+\n+    let _: &mut T = &mut *m;\n+    let _: &mut T = &mut *m;\n+\n+    let _: &T = &*m;\n+    let _: &T = &*m;\n+\n+    let _: &mut T = &mut *(p as *mut T);\n+    let _ = &mut *(p as *mut T);\n+\n+    let _: &T = &*(o as *const T);\n+    let _: &T = &*(o as *const T);\n+\n+    let _: &mut T = &mut *(om as *mut T);\n+    let _: &mut T = &mut *(om as *mut T);\n+\n+    let _: &T = &*(om as *const T);\n+    let _: &T = &*(om as *const T);\n+}\n+\n+fn _issue1231() {\n+    struct Foo<'a, T> {\n+        bar: &'a T,\n+    }\n+\n+    let raw = 42 as *const i32;\n+    let _: &Foo<u8> = unsafe { &*raw.cast::<Foo<_>>() };\n+\n+    let _: &Foo<&u8> = unsafe { &*raw.cast::<Foo<&_>>() };\n+\n+    type Bar<'a> = &'a u8;\n+    let raw = 42 as *const i32;\n+    unsafe { &*(raw as *const u8) };\n+}\n+\n+unsafe fn _issue8924<'a, 'b, 'c>(x: *const &'a u32, y: *const &'b u32) -> &'c &'b u32 {\n+    match 0 {\n+        0 => &*x.cast::<&u32>(),\n+        1 => &*y.cast::<&u32>(),\n+        2 => &*x.cast::<&'b u32>(),\n+        _ => &*y.cast::<&'b u32>(),\n+    }\n+}\n+\n+unsafe fn _meets_msrv<'a, 'b, 'c>(x: *const &'a u32) -> &'c &'b u32 {\n+    #![clippy::msrv = \"1.38\"]\n+    let a = 0u32;\n+    let a = &a as *const u32;\n+    let _: &u32 = &*a;\n+    let _: &u32 = &*a.cast::<u32>();\n+    match 0 {\n+        0 => &*x.cast::<&u32>(),\n+        _ => &*x.cast::<&'b u32>(),\n+    }\n+}\n+\n+unsafe fn _under_msrv<'a, 'b, 'c>(x: *const &'a u32) -> &'c &'b u32 {\n+    #![clippy::msrv = \"1.37\"]\n+    let a = 0u32;\n+    let a = &a as *const u32;\n+    let _: &u32 = &*a;\n+    let _: &u32 = &*(a as *const u32);\n+    match 0 {\n+        0 => &*(x as *const () as *const &u32),\n+        _ => &*(x as *const () as *const &'b u32),\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "fe49cdc324fdd397e3db32cf85f46338753ae702", "filename": "src/tools/clippy/tests/ui/transmute_ptr_to_ref.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_ptr_to_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_ptr_to_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_ptr_to_ref.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,4 +1,8 @@\n+// run-rustfix\n+\n+#![feature(custom_inner_attributes)]\n #![warn(clippy::transmute_ptr_to_ref)]\n+#![allow(clippy::match_single_binding)]\n \n unsafe fn _ptr_to_ref<T, U>(p: *const T, m: *mut T, o: *const U, om: *mut U) {\n     let _: &T = std::mem::transmute(p);\n@@ -23,7 +27,7 @@ unsafe fn _ptr_to_ref<T, U>(p: *const T, m: *mut T, o: *const U, om: *mut U) {\n     let _: &T = &*(om as *const T);\n }\n \n-fn issue1231() {\n+fn _issue1231() {\n     struct Foo<'a, T> {\n         bar: &'a T,\n     }\n@@ -38,4 +42,37 @@ fn issue1231() {\n     unsafe { std::mem::transmute::<_, Bar>(raw) };\n }\n \n+unsafe fn _issue8924<'a, 'b, 'c>(x: *const &'a u32, y: *const &'b u32) -> &'c &'b u32 {\n+    match 0 {\n+        0 => std::mem::transmute(x),\n+        1 => std::mem::transmute(y),\n+        2 => std::mem::transmute::<_, &&'b u32>(x),\n+        _ => std::mem::transmute::<_, &&'b u32>(y),\n+    }\n+}\n+\n+unsafe fn _meets_msrv<'a, 'b, 'c>(x: *const &'a u32) -> &'c &'b u32 {\n+    #![clippy::msrv = \"1.38\"]\n+    let a = 0u32;\n+    let a = &a as *const u32;\n+    let _: &u32 = std::mem::transmute(a);\n+    let _: &u32 = std::mem::transmute::<_, &u32>(a);\n+    match 0 {\n+        0 => std::mem::transmute(x),\n+        _ => std::mem::transmute::<_, &&'b u32>(x),\n+    }\n+}\n+\n+unsafe fn _under_msrv<'a, 'b, 'c>(x: *const &'a u32) -> &'c &'b u32 {\n+    #![clippy::msrv = \"1.37\"]\n+    let a = 0u32;\n+    let a = &a as *const u32;\n+    let _: &u32 = std::mem::transmute(a);\n+    let _: &u32 = std::mem::transmute::<_, &u32>(a);\n+    match 0 {\n+        0 => std::mem::transmute(x),\n+        _ => std::mem::transmute::<_, &&'b u32>(x),\n+    }\n+}\n+\n fn main() {}"}, {"sha": "2993e5e7b0c91d45ac297ce04cc93dceb24d928b", "filename": "src/tools/clippy/tests/ui/transmute_ptr_to_ref.stderr", "status": "modified", "additions": 87, "deletions": 15, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_ptr_to_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_ptr_to_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_ptr_to_ref.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,64 +1,136 @@\n error: transmute from a pointer type (`*const T`) to a reference type (`&T`)\n-  --> $DIR/transmute_ptr_to_ref.rs:4:17\n+  --> $DIR/transmute_ptr_to_ref.rs:8:17\n    |\n LL |     let _: &T = std::mem::transmute(p);\n    |                 ^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*p`\n    |\n    = note: `-D clippy::transmute-ptr-to-ref` implied by `-D warnings`\n \n error: transmute from a pointer type (`*mut T`) to a reference type (`&mut T`)\n-  --> $DIR/transmute_ptr_to_ref.rs:7:21\n+  --> $DIR/transmute_ptr_to_ref.rs:11:21\n    |\n LL |     let _: &mut T = std::mem::transmute(m);\n    |                     ^^^^^^^^^^^^^^^^^^^^^^ help: try: `&mut *m`\n \n error: transmute from a pointer type (`*mut T`) to a reference type (`&T`)\n-  --> $DIR/transmute_ptr_to_ref.rs:10:17\n+  --> $DIR/transmute_ptr_to_ref.rs:14:17\n    |\n LL |     let _: &T = std::mem::transmute(m);\n    |                 ^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*m`\n \n error: transmute from a pointer type (`*mut T`) to a reference type (`&mut T`)\n-  --> $DIR/transmute_ptr_to_ref.rs:13:21\n+  --> $DIR/transmute_ptr_to_ref.rs:17:21\n    |\n LL |     let _: &mut T = std::mem::transmute(p as *mut T);\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&mut *(p as *mut T)`\n \n error: transmute from a pointer type (`*const U`) to a reference type (`&T`)\n-  --> $DIR/transmute_ptr_to_ref.rs:16:17\n+  --> $DIR/transmute_ptr_to_ref.rs:20:17\n    |\n LL |     let _: &T = std::mem::transmute(o);\n    |                 ^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*(o as *const T)`\n \n error: transmute from a pointer type (`*mut U`) to a reference type (`&mut T`)\n-  --> $DIR/transmute_ptr_to_ref.rs:19:21\n+  --> $DIR/transmute_ptr_to_ref.rs:23:21\n    |\n LL |     let _: &mut T = std::mem::transmute(om);\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&mut *(om as *mut T)`\n \n error: transmute from a pointer type (`*mut U`) to a reference type (`&T`)\n-  --> $DIR/transmute_ptr_to_ref.rs:22:17\n+  --> $DIR/transmute_ptr_to_ref.rs:26:17\n    |\n LL |     let _: &T = std::mem::transmute(om);\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*(om as *const T)`\n \n-error: transmute from a pointer type (`*const i32`) to a reference type (`&issue1231::Foo<u8>`)\n-  --> $DIR/transmute_ptr_to_ref.rs:32:32\n+error: transmute from a pointer type (`*const i32`) to a reference type (`&_issue1231::Foo<u8>`)\n+  --> $DIR/transmute_ptr_to_ref.rs:36:32\n    |\n LL |     let _: &Foo<u8> = unsafe { std::mem::transmute::<_, &Foo<_>>(raw) };\n-   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*(raw as *const Foo<_>)`\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*raw.cast::<Foo<_>>()`\n \n-error: transmute from a pointer type (`*const i32`) to a reference type (`&issue1231::Foo<&u8>`)\n-  --> $DIR/transmute_ptr_to_ref.rs:34:33\n+error: transmute from a pointer type (`*const i32`) to a reference type (`&_issue1231::Foo<&u8>`)\n+  --> $DIR/transmute_ptr_to_ref.rs:38:33\n    |\n LL |     let _: &Foo<&u8> = unsafe { std::mem::transmute::<_, &Foo<&_>>(raw) };\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*(raw as *const Foo<&_>)`\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*raw.cast::<Foo<&_>>()`\n \n error: transmute from a pointer type (`*const i32`) to a reference type (`&u8`)\n-  --> $DIR/transmute_ptr_to_ref.rs:38:14\n+  --> $DIR/transmute_ptr_to_ref.rs:42:14\n    |\n LL |     unsafe { std::mem::transmute::<_, Bar>(raw) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*(raw as *const u8)`\n \n-error: aborting due to 10 previous errors\n+error: transmute from a pointer type (`*const &u32`) to a reference type (`&&u32`)\n+  --> $DIR/transmute_ptr_to_ref.rs:47:14\n+   |\n+LL |         0 => std::mem::transmute(x),\n+   |              ^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*x.cast::<&u32>()`\n+\n+error: transmute from a pointer type (`*const &u32`) to a reference type (`&&u32`)\n+  --> $DIR/transmute_ptr_to_ref.rs:48:14\n+   |\n+LL |         1 => std::mem::transmute(y),\n+   |              ^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*y.cast::<&u32>()`\n+\n+error: transmute from a pointer type (`*const &u32`) to a reference type (`&&u32`)\n+  --> $DIR/transmute_ptr_to_ref.rs:49:14\n+   |\n+LL |         2 => std::mem::transmute::<_, &&'b u32>(x),\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*x.cast::<&'b u32>()`\n+\n+error: transmute from a pointer type (`*const &u32`) to a reference type (`&&u32`)\n+  --> $DIR/transmute_ptr_to_ref.rs:50:14\n+   |\n+LL |         _ => std::mem::transmute::<_, &&'b u32>(y),\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*y.cast::<&'b u32>()`\n+\n+error: transmute from a pointer type (`*const u32`) to a reference type (`&u32`)\n+  --> $DIR/transmute_ptr_to_ref.rs:58:19\n+   |\n+LL |     let _: &u32 = std::mem::transmute(a);\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*a`\n+\n+error: transmute from a pointer type (`*const u32`) to a reference type (`&u32`)\n+  --> $DIR/transmute_ptr_to_ref.rs:59:19\n+   |\n+LL |     let _: &u32 = std::mem::transmute::<_, &u32>(a);\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*a.cast::<u32>()`\n+\n+error: transmute from a pointer type (`*const &u32`) to a reference type (`&&u32`)\n+  --> $DIR/transmute_ptr_to_ref.rs:61:14\n+   |\n+LL |         0 => std::mem::transmute(x),\n+   |              ^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*x.cast::<&u32>()`\n+\n+error: transmute from a pointer type (`*const &u32`) to a reference type (`&&u32`)\n+  --> $DIR/transmute_ptr_to_ref.rs:62:14\n+   |\n+LL |         _ => std::mem::transmute::<_, &&'b u32>(x),\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*x.cast::<&'b u32>()`\n+\n+error: transmute from a pointer type (`*const u32`) to a reference type (`&u32`)\n+  --> $DIR/transmute_ptr_to_ref.rs:70:19\n+   |\n+LL |     let _: &u32 = std::mem::transmute(a);\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*a`\n+\n+error: transmute from a pointer type (`*const u32`) to a reference type (`&u32`)\n+  --> $DIR/transmute_ptr_to_ref.rs:71:19\n+   |\n+LL |     let _: &u32 = std::mem::transmute::<_, &u32>(a);\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*(a as *const u32)`\n+\n+error: transmute from a pointer type (`*const &u32`) to a reference type (`&&u32`)\n+  --> $DIR/transmute_ptr_to_ref.rs:73:14\n+   |\n+LL |         0 => std::mem::transmute(x),\n+   |              ^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*(x as *const () as *const &u32)`\n+\n+error: transmute from a pointer type (`*const &u32`) to a reference type (`&&u32`)\n+  --> $DIR/transmute_ptr_to_ref.rs:74:14\n+   |\n+LL |         _ => std::mem::transmute::<_, &&'b u32>(x),\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*(x as *const () as *const &'b u32)`\n+\n+error: aborting due to 22 previous errors\n "}, {"sha": "8f78f16a0a1a65939cd427b4a23fc64bf897a706", "filename": "src/tools/clippy/tests/ui/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrivially_copy_pass_by_ref.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -113,6 +113,44 @@ mod issue5876 {\n     }\n }\n \n+fn _ref_to_opt_ref_implicit(x: &u32) -> Option<&u32> {\n+    Some(x)\n+}\n+\n+#[allow(clippy::needless_lifetimes)]\n+fn _ref_to_opt_ref_explicit<'a>(x: &'a u32) -> Option<&'a u32> {\n+    Some(x)\n+}\n+\n+fn _with_constraint<'a, 'b: 'a>(x: &'b u32, y: &'a u32) -> &'a u32 {\n+    if true { x } else { y }\n+}\n+\n+async fn _async_implicit(x: &u32) -> &u32 {\n+    x\n+}\n+\n+#[allow(clippy::needless_lifetimes)]\n+async fn _async_explicit<'a>(x: &'a u32) -> &'a u32 {\n+    x\n+}\n+\n+fn _unrelated_lifetimes<'a, 'b>(_x: &'a u32, y: &'b u32) -> &'b u32 {\n+    y\n+}\n+\n+fn _return_ptr(x: &u32) -> *const u32 {\n+    x\n+}\n+\n+fn _return_field_ptr(x: &(u32, u32)) -> *const u32 {\n+    &x.0\n+}\n+\n+fn _return_field_ptr_addr_of(x: &(u32, u32)) -> *const u32 {\n+    core::ptr::addr_of!(x.0)\n+}\n+\n fn main() {\n     let (mut foo, bar) = (Foo(0), Bar([0; 24]));\n     let (mut a, b, c, x, y, z) = (0, 0, Bar([0; 24]), 0, Foo(0), 0);"}, {"sha": "66ecb3d8e77acfd3f5b822f307aff7d1f3bb775f", "filename": "src/tools/clippy/tests/ui/trivially_copy_pass_by_ref.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrivially_copy_pass_by_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrivially_copy_pass_by_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrivially_copy_pass_by_ref.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -106,5 +106,11 @@ error: this argument (N byte) is passed by reference, but would be more efficien\n LL |     fn foo(x: &i32) {\n    |               ^^^^ help: consider passing by value instead: `i32`\n \n-error: aborting due to 17 previous errors\n+error: this argument (N byte) is passed by reference, but would be more efficient if passed by value (limit: N byte)\n+  --> $DIR/trivially_copy_pass_by_ref.rs:138:37\n+   |\n+LL | fn _unrelated_lifetimes<'a, 'b>(_x: &'a u32, y: &'b u32) -> &'b u32 {\n+   |                                     ^^^^^^^ help: consider passing by value instead: `u32`\n+\n+error: aborting due to 18 previous errors\n "}, {"sha": "4ca7f29b34cd085af07587e6b755a8ee3855dbef", "filename": "src/tools/clippy/tests/ui/unused_async.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_async.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,5 +1,8 @@\n #![warn(clippy::unused_async)]\n \n+use std::future::Future;\n+use std::pin::Pin;\n+\n async fn foo() -> i32 {\n     4\n }\n@@ -8,6 +11,37 @@ async fn bar() -> i32 {\n     foo().await\n }\n \n+struct S;\n+\n+impl S {\n+    async fn unused(&self) -> i32 {\n+        1\n+    }\n+\n+    async fn used(&self) -> i32 {\n+        self.unused().await\n+    }\n+}\n+\n+trait AsyncTrait {\n+    fn trait_method() -> Pin<Box<dyn Future<Output = i32>>>;\n+}\n+\n+macro_rules! async_trait_impl {\n+    () => {\n+        impl AsyncTrait for S {\n+            fn trait_method() -> Pin<Box<dyn Future<Output = i32>>> {\n+                async fn unused() -> i32 {\n+                    5\n+                }\n+\n+                Box::pin(unused())\n+            }\n+        }\n+    };\n+}\n+async_trait_impl!();\n+\n fn main() {\n     foo();\n     bar();"}, {"sha": "8b8ad065a4caa6f9992a3da9f188c2c03cd4180c", "filename": "src/tools/clippy/tests/ui/unused_async.stderr", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_async.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,5 +1,5 @@\n error: unused `async` for function with no await statements\n-  --> $DIR/unused_async.rs:3:1\n+  --> $DIR/unused_async.rs:6:1\n    |\n LL | / async fn foo() -> i32 {\n LL | |     4\n@@ -9,5 +9,15 @@ LL | | }\n    = note: `-D clippy::unused-async` implied by `-D warnings`\n    = help: consider removing the `async` from this function\n \n-error: aborting due to previous error\n+error: unused `async` for function with no await statements\n+  --> $DIR/unused_async.rs:17:5\n+   |\n+LL | /     async fn unused(&self) -> i32 {\n+LL | |         1\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider removing the `async` from this function\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "90cb8945e77ff1a1d86f79d87b3cf9159302b3c9", "filename": "src/tools/clippy/tests/ui/useless_asref.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_asref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_asref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_asref.fixed?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n \n #![deny(clippy::useless_asref)]\n+#![allow(clippy::explicit_auto_deref)]\n \n use std::fmt::Debug;\n "}, {"sha": "cb9f8ae5909a551856a33fe57e94f6c77eab6306", "filename": "src/tools/clippy/tests/ui/useless_asref.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_asref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_asref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_asref.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n \n #![deny(clippy::useless_asref)]\n+#![allow(clippy::explicit_auto_deref)]\n \n use std::fmt::Debug;\n "}, {"sha": "b21c67bb3645f0bee32311879842ecd86ebaf87c", "filename": "src/tools/clippy/tests/ui/useless_asref.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_asref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_asref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuseless_asref.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,5 +1,5 @@\n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:43:18\n+  --> $DIR/useless_asref.rs:44:18\n    |\n LL |         foo_rstr(rstr.as_ref());\n    |                  ^^^^^^^^^^^^^ help: try this: `rstr`\n@@ -11,61 +11,61 @@ LL | #![deny(clippy::useless_asref)]\n    |         ^^^^^^^^^^^^^^^^^^^^^\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:45:20\n+  --> $DIR/useless_asref.rs:46:20\n    |\n LL |         foo_rslice(rslice.as_ref());\n    |                    ^^^^^^^^^^^^^^^ help: try this: `rslice`\n \n error: this call to `as_mut` does nothing\n-  --> $DIR/useless_asref.rs:49:21\n+  --> $DIR/useless_asref.rs:50:21\n    |\n LL |         foo_mrslice(mrslice.as_mut());\n    |                     ^^^^^^^^^^^^^^^^ help: try this: `mrslice`\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:51:20\n+  --> $DIR/useless_asref.rs:52:20\n    |\n LL |         foo_rslice(mrslice.as_ref());\n    |                    ^^^^^^^^^^^^^^^^ help: try this: `mrslice`\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:58:20\n+  --> $DIR/useless_asref.rs:59:20\n    |\n LL |         foo_rslice(rrrrrslice.as_ref());\n    |                    ^^^^^^^^^^^^^^^^^^^ help: try this: `rrrrrslice`\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:60:18\n+  --> $DIR/useless_asref.rs:61:18\n    |\n LL |         foo_rstr(rrrrrstr.as_ref());\n    |                  ^^^^^^^^^^^^^^^^^ help: try this: `rrrrrstr`\n \n error: this call to `as_mut` does nothing\n-  --> $DIR/useless_asref.rs:65:21\n+  --> $DIR/useless_asref.rs:66:21\n    |\n LL |         foo_mrslice(mrrrrrslice.as_mut());\n    |                     ^^^^^^^^^^^^^^^^^^^^ help: try this: `mrrrrrslice`\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:67:20\n+  --> $DIR/useless_asref.rs:68:20\n    |\n LL |         foo_rslice(mrrrrrslice.as_ref());\n    |                    ^^^^^^^^^^^^^^^^^^^^ help: try this: `mrrrrrslice`\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:71:16\n+  --> $DIR/useless_asref.rs:72:16\n    |\n LL |     foo_rrrrmr((&&&&MoreRef).as_ref());\n    |                ^^^^^^^^^^^^^^^^^^^^^^ help: try this: `(&&&&MoreRef)`\n \n error: this call to `as_mut` does nothing\n-  --> $DIR/useless_asref.rs:121:13\n+  --> $DIR/useless_asref.rs:122:13\n    |\n LL |     foo_mrt(mrt.as_mut());\n    |             ^^^^^^^^^^^^ help: try this: `mrt`\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:123:12\n+  --> $DIR/useless_asref.rs:124:12\n    |\n LL |     foo_rt(mrt.as_ref());\n    |            ^^^^^^^^^^^^ help: try this: `mrt`"}, {"sha": "c42e2a79a9bf9048dd19ea4942348a1df7695543", "filename": "src/tools/clippy/tests/ui/while_let_loop.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_loop.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -117,3 +117,29 @@ fn issue1948() {\n         }\n     };\n }\n+\n+fn issue_7913(m: &std::sync::Mutex<Vec<u32>>) {\n+    // Don't lint. The lock shouldn't be held while printing.\n+    loop {\n+        let x = if let Some(x) = m.lock().unwrap().pop() {\n+            x\n+        } else {\n+            break;\n+        };\n+\n+        println!(\"{}\", x);\n+    }\n+}\n+\n+fn issue_5715(mut m: core::cell::RefCell<Option<u32>>) {\n+    // Don't lint. The temporary from `borrow_mut` must be dropped before overwriting the `RefCell`.\n+    loop {\n+        let x = if let &mut Some(x) = &mut *m.borrow_mut() {\n+            x\n+        } else {\n+            break;\n+        };\n+\n+        m = core::cell::RefCell::new(Some(x + 1));\n+    }\n+}"}, {"sha": "e9ff64431e19d154f614b9128a63028bb52c1ae3", "filename": "src/tools/clippy/tests/ui/while_let_on_iterator.fixed", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_on_iterator.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_on_iterator.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_on_iterator.fixed?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -6,7 +6,8 @@\n     unreachable_code,\n     unused_mut,\n     dead_code,\n-    clippy::equatable_if_let\n+    clippy::equatable_if_let,\n+    clippy::manual_find\n )]\n \n fn base() {"}, {"sha": "03da39526b2fdd735098337004d9becf9c35b8bc", "filename": "src/tools/clippy/tests/ui/while_let_on_iterator.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_on_iterator.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -6,7 +6,8 @@\n     unreachable_code,\n     unused_mut,\n     dead_code,\n-    clippy::equatable_if_let\n+    clippy::equatable_if_let,\n+    clippy::manual_find\n )]\n \n fn base() {"}, {"sha": "42859243855a6920d7ce5fdae686ae969dbbd0cf", "filename": "src/tools/clippy/tests/ui/while_let_on_iterator.stderr", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_on_iterator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_on_iterator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_on_iterator.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,141 +1,141 @@\n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:14:5\n+  --> $DIR/while_let_on_iterator.rs:15:5\n    |\n LL |     while let Option::Some(x) = iter.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in iter`\n    |\n    = note: `-D clippy::while-let-on-iterator` implied by `-D warnings`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:19:5\n+  --> $DIR/while_let_on_iterator.rs:20:5\n    |\n LL |     while let Some(x) = iter.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in iter`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:24:5\n+  --> $DIR/while_let_on_iterator.rs:25:5\n    |\n LL |     while let Some(_) = iter.next() {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for _ in iter`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:100:9\n+  --> $DIR/while_let_on_iterator.rs:101:9\n    |\n LL |         while let Some([..]) = it.next() {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for [..] in it`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:107:9\n+  --> $DIR/while_let_on_iterator.rs:108:9\n    |\n LL |         while let Some([_x]) = it.next() {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for [_x] in it`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:120:9\n+  --> $DIR/while_let_on_iterator.rs:121:9\n    |\n LL |         while let Some(x @ [_]) = it.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x @ [_] in it`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:140:9\n+  --> $DIR/while_let_on_iterator.rs:141:9\n    |\n LL |         while let Some(_) = y.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for _ in y`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:197:9\n+  --> $DIR/while_let_on_iterator.rs:198:9\n    |\n LL |         while let Some(m) = it.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in it.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:208:5\n+  --> $DIR/while_let_on_iterator.rs:209:5\n    |\n LL |     while let Some(n) = it.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for n in it`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:210:9\n+  --> $DIR/while_let_on_iterator.rs:211:9\n    |\n LL |         while let Some(m) = it.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in it`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:219:9\n+  --> $DIR/while_let_on_iterator.rs:220:9\n    |\n LL |         while let Some(m) = it.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in it`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:228:9\n+  --> $DIR/while_let_on_iterator.rs:229:9\n    |\n LL |         while let Some(m) = it.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in it.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:245:9\n+  --> $DIR/while_let_on_iterator.rs:246:9\n    |\n LL |         while let Some(m) = it.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for m in it.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:260:13\n+  --> $DIR/while_let_on_iterator.rs:261:13\n    |\n LL |             while let Some(i) = self.0.next() {\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for i in self.0.by_ref()`\n \n error: manual `!RangeInclusive::contains` implementation\n-  --> $DIR/while_let_on_iterator.rs:261:20\n+  --> $DIR/while_let_on_iterator.rs:262:20\n    |\n LL |                 if i < 3 || i > 7 {\n    |                    ^^^^^^^^^^^^^^ help: use: `!(3..=7).contains(&i)`\n    |\n    = note: `-D clippy::manual-range-contains` implied by `-D warnings`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:292:13\n+  --> $DIR/while_let_on_iterator.rs:293:13\n    |\n LL |             while let Some(i) = self.0.0.0.next() {\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for i in self.0.0.0.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:321:5\n+  --> $DIR/while_let_on_iterator.rs:322:5\n    |\n LL |     while let Some(n) = it.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for n in it.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:333:9\n+  --> $DIR/while_let_on_iterator.rs:334:9\n    |\n LL |         while let Some(x) = it.next() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in it.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:347:5\n+  --> $DIR/while_let_on_iterator.rs:348:5\n    |\n LL |     while let Some(x) = it.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in it.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:358:5\n+  --> $DIR/while_let_on_iterator.rs:359:5\n    |\n LL |     while let Some(x) = it.0.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in it.0.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:393:5\n+  --> $DIR/while_let_on_iterator.rs:394:5\n    |\n LL |     while let Some(x) = s.x.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in s.x.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:400:5\n+  --> $DIR/while_let_on_iterator.rs:401:5\n    |\n LL |     while let Some(x) = x[0].next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in x[0].by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:407:5\n+  --> $DIR/while_let_on_iterator.rs:408:5\n    |\n LL |     while let Some(..) = it.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for _ in it`"}, {"sha": "968c58f40aefa27f3518a66017eb785da09c8129", "filename": "src/tools/clippy/tests/ui/zero_div_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fzero_div_zero.rs?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,4 +1,4 @@\n-#[allow(unused_variables)]\n+#[allow(unused_variables, clippy::eq_op)]\n #[warn(clippy::zero_divided_by_zero)]\n fn main() {\n     let nan = 0.0 / 0.0;"}, {"sha": "86563542e0602ef7da031d962fab44ba042d9920", "filename": "src/tools/clippy/tests/ui/zero_div_zero.stderr", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fzero_div_zero.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fzero_div_zero.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fzero_div_zero.stderr?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -1,11 +1,3 @@\n-error: equal expressions as operands to `/`\n-  --> $DIR/zero_div_zero.rs:4:15\n-   |\n-LL |     let nan = 0.0 / 0.0;\n-   |               ^^^^^^^^^\n-   |\n-   = note: `#[deny(clippy::eq_op)]` on by default\n-\n error: constant division of `0.0` with `0.0` will always result in NaN\n   --> $DIR/zero_div_zero.rs:4:15\n    |\n@@ -15,12 +7,6 @@ LL |     let nan = 0.0 / 0.0;\n    = note: `-D clippy::zero-divided-by-zero` implied by `-D warnings`\n    = help: consider using `f64::NAN` if you would like a constant representing NaN\n \n-error: equal expressions as operands to `/`\n-  --> $DIR/zero_div_zero.rs:5:19\n-   |\n-LL |     let f64_nan = 0.0 / 0.0f64;\n-   |                   ^^^^^^^^^^^^\n-\n error: constant division of `0.0` with `0.0` will always result in NaN\n   --> $DIR/zero_div_zero.rs:5:19\n    |\n@@ -29,12 +15,6 @@ LL |     let f64_nan = 0.0 / 0.0f64;\n    |\n    = help: consider using `f64::NAN` if you would like a constant representing NaN\n \n-error: equal expressions as operands to `/`\n-  --> $DIR/zero_div_zero.rs:6:25\n-   |\n-LL |     let other_f64_nan = 0.0f64 / 0.0;\n-   |                         ^^^^^^^^^^^^\n-\n error: constant division of `0.0` with `0.0` will always result in NaN\n   --> $DIR/zero_div_zero.rs:6:25\n    |\n@@ -43,12 +23,6 @@ LL |     let other_f64_nan = 0.0f64 / 0.0;\n    |\n    = help: consider using `f64::NAN` if you would like a constant representing NaN\n \n-error: equal expressions as operands to `/`\n-  --> $DIR/zero_div_zero.rs:7:28\n-   |\n-LL |     let one_more_f64_nan = 0.0f64 / 0.0f64;\n-   |                            ^^^^^^^^^^^^^^^\n-\n error: constant division of `0.0` with `0.0` will always result in NaN\n   --> $DIR/zero_div_zero.rs:7:28\n    |\n@@ -57,5 +31,5 @@ LL |     let one_more_f64_nan = 0.0f64 / 0.0f64;\n    |\n    = help: consider using `f64::NAN` if you would like a constant representing NaN\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 4 previous errors\n "}, {"sha": "6183089911bdc0d35c0e5845b7a941da8129c185", "filename": "src/tools/clippy/util/gh-pages/index.html", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Futil%2Fgh-pages%2Findex.html", "raw_url": "https://github.com/rust-lang/rust/raw/721d53a54f73ebb023624625fe5f357478636694/src%2Ftools%2Fclippy%2Futil%2Fgh-pages%2Findex.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Futil%2Fgh-pages%2Findex.html?ref=721d53a54f73ebb023624625fe5f357478636694", "patch": "@@ -10,6 +10,7 @@\n <head>\n     <meta charset=\"UTF-8\"/>\n     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/>\n+    <meta name=\"description\" content=\"A collection of lints to catch common mistakes and improve your Rust code.\">\n \n     <title>Clippy Lints</title>\n "}]}