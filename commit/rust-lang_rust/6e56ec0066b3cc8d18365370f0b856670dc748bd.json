{"sha": "6e56ec0066b3cc8d18365370f0b856670dc748bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlNTZlYzAwNjZiM2NjOGQxODM2NTM3MGYwYjg1NjY3MGRjNzQ4YmQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-04T08:11:03Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-04T15:41:34Z"}, "message": "Move trans_call to destination_passing style\n\nIssue #667\n\nThe retptr passed to a function will now often be the actual\ndestination of the returned value (as in `{field1: func1()}`).", "tree": {"sha": "d131a36756f7600401b0ece9ba5783ea80667ad4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d131a36756f7600401b0ece9ba5783ea80667ad4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e56ec0066b3cc8d18365370f0b856670dc748bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e56ec0066b3cc8d18365370f0b856670dc748bd", "html_url": "https://github.com/rust-lang/rust/commit/6e56ec0066b3cc8d18365370f0b856670dc748bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e56ec0066b3cc8d18365370f0b856670dc748bd/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53c9b9a5dd7341dee2c600ae234ca741da8464de", "url": "https://api.github.com/repos/rust-lang/rust/commits/53c9b9a5dd7341dee2c600ae234ca741da8464de", "html_url": "https://github.com/rust-lang/rust/commit/53c9b9a5dd7341dee2c600ae234ca741da8464de"}], "stats": {"total": 113, "additions": 57, "deletions": 56}, "files": [{"sha": "09b0a8a77f225b98d3366f8a872420f558b8fbcd", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 57, "deletions": 56, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/6e56ec0066b3cc8d18365370f0b856670dc748bd/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e56ec0066b3cc8d18365370f0b856670dc748bd/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=6e56ec0066b3cc8d18365370f0b856670dc748bd", "patch": "@@ -2470,7 +2470,7 @@ fn trans_binary(cx: @block_ctxt, op: ast::binop, a: @ast::expr, b: @ast::expr,\n     }\n }\n \n-// FIXME remove once all uses have been converted to join_returns\n+// FIXME[DPS] remove once all uses have been converted to join_returns\n fn join_branches(parent_cx: @block_ctxt, ins: [result]) -> @block_ctxt {\n     let out = new_sub_block_ctxt(parent_cx, \"join\");\n     let branched = false;\n@@ -2952,8 +2952,7 @@ fn trans_for_each(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n       ast::expr_call(f, args) {\n         let pair =\n             create_real_fn_pair(cx, iter_body_llty, lliterbody, llenv.ptr);\n-        let r = trans_call(cx, f, some(pair), args, seq.id);\n-        ret r.res.bcx;\n+        ret trans_call(cx, f, some(pair), args, seq.id, ignore);\n       }\n     }\n }\n@@ -3300,6 +3299,7 @@ fn expr_is_lval(tcx: ty::ctxt, e: @ast::expr) -> bool {\n // The additional bool returned indicates whether it's mem (that is\n // represented as an alloca or heap, hence needs a 'load' to be used as an\n // immediate).\n+// FIXME[DPS] only allow this to be called on actual lvals\n fn trans_lval(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n     alt e.node {\n       ast::expr_path(p) {\n@@ -3340,10 +3340,17 @@ fn trans_lval(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n         ret lval_mem(sub.bcx, val);\n       }\n       ast::expr_call(f, args) {\n-        let {res: {bcx, val}, by_ref} =\n-            trans_call(cx, f, none, args, e.id);\n-        if by_ref { ret lval_mem(bcx, val); }\n-        else { ret lval_val(bcx, val); }\n+        // A by-ref returning function\n+        if expr_is_lval(bcx_tcx(cx), e) {\n+            let cell = empty_dest_cell();\n+            let bcx = trans_call(cx, f, none, args, e.id, by_ref(cell));\n+            ret lval_mem(bcx, *cell);\n+        } else { // By-value return\n+            let {bcx, val} = dps_to_result(cx, {|bcx, dest|\n+                trans_call(bcx, f, none, args, e.id, dest) },\n+                                           ty::expr_ty(bcx_tcx(cx), e));\n+            ret lval_val(bcx, val);\n+        }\n       }\n       _ {\n         let res = trans_expr(cx, e);\n@@ -3797,7 +3804,8 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty0: TypeRef,\n //  - trans_args\n fn trans_args(cx: @block_ctxt, outer_cx: @block_ctxt, llenv: ValueRef,\n               gen: option::t<generic_info>,\n-              lliterbody: option::t<ValueRef>, es: [@ast::expr], fn_ty: ty::t)\n+              lliterbody: option::t<ValueRef>, es: [@ast::expr], fn_ty: ty::t,\n+              dest: dest)\n    -> {bcx: @block_ctxt,\n        outer_cx: @block_ctxt,\n        args: [ValueRef],\n@@ -3813,9 +3821,9 @@ fn trans_args(cx: @block_ctxt, outer_cx: @block_ctxt, llenv: ValueRef,\n \n     let ccx = bcx_ccx(cx);\n     let tcx = ccx.tcx;\n-    let bcx: @block_ctxt = cx;\n+    let bcx = cx;\n     let ret_style = ty::ty_fn_ret_style(tcx, fn_ty);\n-    let by_ref = ast_util::ret_by_ref(ret_style);\n+    let ret_ref = ast_util::ret_by_ref(ret_style);\n \n     let retty = ty::ty_fn_ret(tcx, fn_ty), full_retty = retty;\n     alt gen {\n@@ -3828,13 +3836,21 @@ fn trans_args(cx: @block_ctxt, outer_cx: @block_ctxt, llenv: ValueRef,\n       _ { }\n     }\n     // Arg 0: Output pointer.\n-    let llretslot_res = if ty::type_is_nil(tcx, retty) {\n-        rslt(cx, llvm::LLVMGetUndef(T_ptr(T_nil())))\n-    } else if by_ref {\n-        rslt(cx, alloca(cx, T_ptr(type_of_or_i8(bcx, full_retty))))\n-    } else { alloc_ty(bcx, full_retty) };\n-    bcx = llretslot_res.bcx;\n-    let llretslot = llretslot_res.val;\n+    let llretty = type_of_or_i8(bcx, full_retty);\n+    let dest_ref = false;\n+    let llretslot = alt dest {\n+      ignore. {\n+        if ty::type_is_nil(tcx, full_retty) || !option::is_none(lliterbody) {\n+            llvm::LLVMGetUndef(T_ptr(llretty))\n+        } else { alloca(cx, llretty) }\n+      }\n+      save_in(dst) { dst }\n+      overwrite(_, _) | by_val(_) { alloca(cx, llretty) }\n+      by_ref(_) { dest_ref = true; alloca(cx, T_ptr(llretty)) }\n+    };\n+    // FIXME[DSP] does this always hold?\n+    assert dest_ref == ret_ref;\n+\n     if ty::type_contains_params(tcx, retty) {\n         // It's possible that the callee has some generic-ness somewhere in\n         // its return value -- say a method signature within an obj or a fn\n@@ -3843,7 +3859,7 @@ fn trans_args(cx: @block_ctxt, outer_cx: @block_ctxt, llenv: ValueRef,\n         // view, for the sake of making a type-compatible call.\n         check non_ty_var(ccx, retty);\n         let llretty = T_ptr(type_of_inner(ccx, bcx.sp, retty));\n-        if by_ref { llretty = T_ptr(llretty); }\n+        if ret_ref { llretty = T_ptr(llretty); }\n         llargs += [PointerCast(cx, llretslot, llretty)];\n     } else { llargs += [llretslot]; }\n \n@@ -3899,18 +3915,17 @@ fn trans_args(cx: @block_ctxt, outer_cx: @block_ctxt, llenv: ValueRef,\n \n fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n               lliterbody: option::t<ValueRef>, args: [@ast::expr],\n-              id: ast::node_id) -> {res: result, by_ref: bool} {\n+              id: ast::node_id, dest: dest) -> @block_ctxt {\n     // NB: 'f' isn't necessarily a function; it might be an entire self-call\n     // expression because of the hack that allows us to process self-calls\n     // with trans_call.\n     let tcx = bcx_tcx(in_cx);\n     let fn_expr_ty = ty::expr_ty(tcx, f);\n \n     if check type_is_native_fn_on_c_stack(tcx, fn_expr_ty) {\n-        ret trans_c_stack_native_call(in_cx, f, args);\n+        ret trans_c_stack_native_call(in_cx, f, args, dest);\n     }\n \n-    let by_ref = ast_util::ret_by_ref(ty::ty_fn_ret_style(tcx, fn_expr_ty));\n     let cx = new_scope_block_ctxt(in_cx, \"call\");\n     let f_res = trans_callee(cx, f);\n     let bcx = f_res.bcx;\n@@ -3936,65 +3951,49 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n     let ret_ty = ty::node_id_to_type(tcx, id);\n     let args_res =\n         trans_args(bcx, in_cx, llenv, f_res.generic, lliterbody, args,\n-                   fn_expr_ty);\n+                   fn_expr_ty, dest);\n     Br(args_res.outer_cx, cx.llbb);\n     bcx = args_res.bcx;\n     let llargs = args_res.args;\n     let llretslot = args_res.retslot;\n \n-    /*\n-    log_err \"calling: \" + val_str(bcx_ccx(cx).tn, faddr);\n-\n-    for arg: ValueRef in llargs {\n-        log_err \"arg: \" + val_str(bcx_ccx(cx).tn, arg);\n-    }\n-    */\n-\n     /* If the block is terminated,\n        then one or more of the args has\n        type _|_. Since that means it diverges, the code\n        for the call itself is unreachable. */\n-    let retval = C_nil();\n     bcx = invoke_full(bcx, faddr, llargs, args_res.to_zero,\n                       args_res.to_revoke);\n-    alt lliterbody {\n-      none. {\n-        if !ty::type_is_nil(tcx, ret_ty) {\n-            if by_ref {\n-                retval = Load(bcx, llretslot);\n-            } else {\n-                retval = load_if_immediate(bcx, llretslot, ret_ty);\n-                // Retval doesn't correspond to anything really tangible\n-                // in the frame, but it's a ref all the same, so we put a\n-                // note here to drop it when we're done in this scope.\n-                add_clean_temp(in_cx, retval, ret_ty);\n-            }\n+    alt dest {\n+      ignore. {\n+        if llvm::LLVMIsUndef(llretslot) != lib::llvm::True {\n+            bcx = drop_ty(bcx, llretslot, ret_ty);\n         }\n       }\n-      some(_) {\n-        // If there was an lliterbody, it means we were calling an\n-        // iter, and we are *not* the party using its 'output' value,\n-        // we should ignore llretslot.\n+      save_in(_) { } // Already saved by callee\n+      overwrite(a, t) {\n+        bcx = drop_ty(bcx, a, t);\n+        bcx = memmove_ty(bcx, a, llretslot, ret_ty);\n+      }\n+      by_ref(cell) | by_val(cell) {\n+        *cell = Load(bcx, llretslot);\n       }\n     }\n     // Forget about anything we moved out.\n     bcx = zero_and_revoke(bcx, args_res.to_zero, args_res.to_revoke);\n \n-    if !by_ref { bcx = trans_block_cleanups(bcx, cx); }\n+    bcx = trans_block_cleanups(bcx, cx);\n     let next_cx = new_sub_block_ctxt(in_cx, \"next\");\n     if bcx.unreachable || ty::type_is_bot(tcx, ret_ty) {\n         Unreachable(next_cx);\n     }\n     Br(bcx, next_cx.llbb);\n-    bcx = next_cx;\n-    ret {res: rslt(bcx, retval), by_ref: by_ref};\n+    ret next_cx;\n }\n \n // Translates a native call on the C stack. Calls into the runtime to perform\n // the stack switching operation.\n fn trans_c_stack_native_call(bcx: @block_ctxt, f: @ast::expr,\n-                             args: [@ast::expr])\n-        -> {res: result, by_ref: bool} {\n+                             args: [@ast::expr], dest: dest) -> @block_ctxt {\n     let ccx = bcx_ccx(bcx);\n     let f_res = trans_callee(bcx, f);\n     let llfn = f_res.val; bcx = f_res.bcx;\n@@ -4047,8 +4046,7 @@ fn trans_c_stack_native_call(bcx: @block_ctxt, f: @ast::expr,\n \n     // Forget about anything we moved out.\n     bcx = zero_and_revoke(bcx, to_zero, to_revoke);\n-\n-    ret {res: rslt(bcx, llretval), by_ref: false};\n+    ret store_in_dest(bcx, llretval, dest);\n }\n \n fn zero_and_revoke(bcx: @block_ctxt,\n@@ -4345,8 +4343,11 @@ fn trans_expr_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n       ast::expr_anon_obj(anon_obj) {\n         ret trans_anon_obj(bcx, e.span, anon_obj, e.id, dest);\n       }\n-      // FIXME[DPS] untangle non-lval calls and fields from trans_lval\n-      ast::expr_call(_, _) | ast::expr_field(_, _) {\n+      ast::expr_call(f, args) {\n+        ret trans_call(bcx, f, none, args, e.id, dest);\n+      }\n+      // FIXME[DPS] untangle non-lval fields from trans_lval\n+      ast::expr_field(_, _) {\n         ret lval_to_dps(bcx, e, dest);\n       }\n "}]}