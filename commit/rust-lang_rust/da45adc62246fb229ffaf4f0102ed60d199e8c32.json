{"sha": "da45adc62246fb229ffaf4f0102ed60d199e8c32", "node_id": "C_kwDOAAsO6NoAKGRhNDVhZGM2MjI0NmZiMjI5ZmZhZjRmMDEwMmVkNjBkMTk5ZThjMzI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-31T10:06:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-31T10:06:05Z"}, "message": "Auto merge of #2519 - saethlin:rustup, r=RalfJung\n\nUse the better FnEntry spans in protector errors\n\nExample error, from `tests/fail/stacked_borrows/invalidate_against_protector1.rs`:\n```\nerror: Undefined Behavior: not granting access to tag <3095> because that would remove [Unique for <3099>] which is protected because it is an argument of call 943\n  --> tests/fail/stacked_borrows/invalidate_against_protector1.rs:5:25\n   |\n5  |     let _val = unsafe { *x }; //~ ERROR: protect\n   |                         ^^ not granting access to tag <3095> because that would remove [Unique for <3099>] which is protected because it is an argument of call 943\n   |\n   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\nhelp: <3095> was created by a SharedReadWrite retag at offsets [0x0..0x4]\n  --> tests/fail/stacked_borrows/invalidate_against_protector1.rs:10:16\n   |\n10 |     let xraw = &mut x as *mut _;\n   |                ^^^^^^\nhelp: <3099> is this argument\n  --> tests/fail/stacked_borrows/invalidate_against_protector1.rs:1:23\n   |\n1  | fn inner(x: *mut i32, _y: &mut i32) {\n   |                       ^^\n   = note: backtrace:\n   = note: inside `inner` at tests/fail/stacked_borrows/invalidate_against_protector1.rs:5:25\nnote: inside `main` at tests/fail/stacked_borrows/invalidate_against_protector1.rs:12:5\n  --> tests/fail/stacked_borrows/invalidate_against_protector1.rs:12:5\n   |\n12 |     inner(xraw, xref);\n   |     ^^^^^^^^^^^^^^^^^\n```\n\nBenchmarks report no change, within noise.", "tree": {"sha": "40a76f5e17333f0d0c34256fea5c1235a1fa5b30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40a76f5e17333f0d0c34256fea5c1235a1fa5b30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da45adc62246fb229ffaf4f0102ed60d199e8c32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da45adc62246fb229ffaf4f0102ed60d199e8c32", "html_url": "https://github.com/rust-lang/rust/commit/da45adc62246fb229ffaf4f0102ed60d199e8c32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da45adc62246fb229ffaf4f0102ed60d199e8c32/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "284b59c4dc89ef7fe44ac0b372394081fcbb88f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/284b59c4dc89ef7fe44ac0b372394081fcbb88f5", "html_url": "https://github.com/rust-lang/rust/commit/284b59c4dc89ef7fe44ac0b372394081fcbb88f5"}, {"sha": "da0d4829bf7ca00fce64ce8563b84299699131b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/da0d4829bf7ca00fce64ce8563b84299699131b2", "html_url": "https://github.com/rust-lang/rust/commit/da0d4829bf7ca00fce64ce8563b84299699131b2"}], "stats": {"total": 219, "additions": 80, "deletions": 139}, "files": [{"sha": "f7e2fa5a33d3c2fcc5ab556e0799e1142539bbfa", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da45adc62246fb229ffaf4f0102ed60d199e8c32/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/da45adc62246fb229ffaf4f0102ed60d199e8c32/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=da45adc62246fb229ffaf4f0102ed60d199e8c32", "patch": "@@ -1 +1 @@\n-4065b89b1e7287047d7d6c65e7abd7b8ee70bcf0\n+94b2b15e63c5d2b2a6a0910e3dae554ce9415bf9"}, {"sha": "26442da6d655bd3a7ef43f07ff259d29c2883230", "filename": "src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da45adc62246fb229ffaf4f0102ed60d199e8c32/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da45adc62246fb229ffaf4f0102ed60d199e8c32/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=da45adc62246fb229ffaf4f0102ed60d199e8c32", "patch": "@@ -183,9 +183,8 @@ pub fn report_error<'tcx, 'mir>(\n                         if let Some((msg, span)) = invalidated {\n                             helps.push((Some(span), msg));\n                         }\n-                        if let Some([(protector_msg, protector_span), (protection_msg, protection_span)]) = protected {\n+                        if let Some((protector_msg, protector_span)) = protected {\n                             helps.push((Some(protector_span), protector_msg));\n-                            helps.push((Some(protection_span), protection_msg));\n                         }\n                     }\n                     helps"}, {"sha": "4f7e3a6a71b13120cd9e9df1dc3220393854dbd5", "filename": "src/machine.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/da45adc62246fb229ffaf4f0102ed60d199e8c32/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da45adc62246fb229ffaf4f0102ed60d199e8c32/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=da45adc62246fb229ffaf4f0102ed60d199e8c32", "patch": "@@ -743,10 +743,15 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         }\n \n         let alloc = alloc.into_owned();\n-        let stacks =\n-            ecx.machine.stacked_borrows.as_ref().map(|stacked_borrows| {\n-                Stacks::new_allocation(id, alloc.size(), stacked_borrows, kind)\n-            });\n+        let stacks = ecx.machine.stacked_borrows.as_ref().map(|stacked_borrows| {\n+            Stacks::new_allocation(\n+                id,\n+                alloc.size(),\n+                stacked_borrows,\n+                kind,\n+                ecx.machine.current_span(*ecx.tcx),\n+            )\n+        });\n         let race_alloc = ecx.machine.data_race.as_ref().map(|data_race| {\n             data_race::AllocExtra::new_allocation(\n                 data_race,"}, {"sha": "b8e777717e973b2ad4c14d8faef865b4bddcd624", "filename": "src/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 21, "deletions": 43, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/da45adc62246fb229ffaf4f0102ed60d199e8c32/src%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da45adc62246fb229ffaf4f0102ed60d199e8c32/src%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fdiagnostics.rs?ref=da45adc62246fb229ffaf4f0102ed60d199e8c32", "patch": "@@ -2,7 +2,7 @@ use smallvec::SmallVec;\n use std::fmt;\n \n use rustc_middle::mir::interpret::{alloc_range, AllocId, AllocRange};\n-use rustc_span::{Span, SpanData, DUMMY_SP};\n+use rustc_span::{Span, SpanData};\n use rustc_target::abi::Size;\n \n use crate::helpers::CurrentSpan;\n@@ -14,6 +14,7 @@ use rustc_middle::mir::interpret::InterpError;\n #[derive(Clone, Debug)]\n pub struct AllocHistory {\n     id: AllocId,\n+    base: (Item, Span),\n     creations: smallvec::SmallVec<[Creation; 1]>,\n     invalidations: smallvec::SmallVec<[Invalidation; 1]>,\n     protectors: smallvec::SmallVec<[Protection; 1]>,\n@@ -91,8 +92,6 @@ impl fmt::Display for InvalidationCause {\n \n #[derive(Clone, Debug)]\n struct Protection {\n-    /// The parent tag from which this protected tag was derived.\n-    orig_tag: ProvenanceExtra,\n     tag: SbTag,\n     span: Span,\n }\n@@ -101,7 +100,7 @@ struct Protection {\n pub struct TagHistory {\n     pub created: (String, SpanData),\n     pub invalidated: Option<(String, SpanData)>,\n-    pub protected: Option<([(String, SpanData); 2])>,\n+    pub protected: Option<(String, SpanData)>,\n }\n \n pub struct DiagnosticCxBuilder<'span, 'ecx, 'mir, 'tcx> {\n@@ -228,9 +227,10 @@ struct DeallocOp {\n }\n \n impl AllocHistory {\n-    pub fn new(id: AllocId) -> Self {\n+    pub fn new(id: AllocId, item: Item, current_span: &mut CurrentSpan<'_, '_, '_>) -> Self {\n         Self {\n             id,\n+            base: (item, current_span.get()),\n             creations: SmallVec::new(),\n             invalidations: SmallVec::new(),\n             protectors: SmallVec::new(),\n@@ -290,11 +290,7 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n         let Operation::Retag(op) = &self.operation else {\n             unreachable!(\"Protectors can only be created during a retag\")\n         };\n-        self.history.protectors.push(Protection {\n-            orig_tag: op.orig_tag,\n-            tag: op.new_tag,\n-            span: self.current_span.get(),\n-        });\n+        self.history.protectors.push(Protection { tag: op.new_tag, span: self.current_span.get() });\n     }\n \n     pub fn get_logs_relevant_to(\n@@ -331,6 +327,17 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n                         None\n                     }\n                 })\n+            }).or_else(|| {\n+                // If we didn't find a retag that created this tag, it might be the base tag of\n+                // this allocation.\n+                if self.history.base.0.tag() == tag {\n+                    Some((\n+                        format!(\"{:?} was created here, as a base tag for {:?}\", tag, self.history.id),\n+                        self.history.base.1.data()\n+                    ))\n+                } else {\n+                    None\n+                }\n             }) else {\n                 // But if we don't have a creation event, this is related to a wildcard, and there\n                 // is really nothing we can do to help.\n@@ -343,40 +350,11 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n \n         let protected = protector_tag\n             .and_then(|protector| {\n-                self.history.protectors.iter().find(|protection| {\n-                    protection.tag == protector\n-                })\n+                self.history.protectors.iter().find(|protection| protection.tag == protector)\n             })\n-            .and_then(|protection| {\n-                self.history.creations.iter().rev().find_map(|event| {\n-                    if ProvenanceExtra::Concrete(event.retag.new_tag) == protection.orig_tag {\n-                        Some((protection, event))\n-                    } else {\n-                        None\n-                    }\n-                })\n-            })\n-            .map(|(protection, protection_parent)| {\n+            .map(|protection| {\n                 let protected_tag = protection.tag;\n-                [\n-                    (\n-                        format!(\n-                            \"{tag:?} cannot be used for memory access because that would remove protected tag {protected_tag:?}, protected by this function call\",\n-                        ),\n-                        protection.span.data(),\n-                    ),\n-                    if protection_parent.retag.new_tag == tag {\n-                        (format!(\"{protected_tag:?} was derived from {tag:?}, the tag used for this memory access\"), DUMMY_SP.data())\n-                    } else {\n-                        (\n-                            format!(\n-                                \"{protected_tag:?} was derived from {protected_parent_tag:?}, which in turn was created here\",\n-                                protected_parent_tag = protection_parent.retag.new_tag,\n-                            ),\n-                            protection_parent.span.data()\n-                        )\n-                    }\n-                ]\n+                (format!(\"{protected_tag:?} is this argument\"), protection.span.data())\n             });\n \n         Some(TagHistory { created, invalidated, protected })\n@@ -448,7 +426,7 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n             | Operation::Access(AccessOp { tag, .. }) =>\n                 err_sb_ub(\n                     format!(\n-                        \"not granting access to tag {:?} because incompatible item {:?} is protected by call {:?}\",\n+                        \"not granting access to tag {:?} because that would remove {:?} which is protected because it is an argument of call {:?}\",\n                         tag, item, call_id\n                     ),\n                     None,"}, {"sha": "4f7914c5fb0ffa916b2bd490826947a9e8140f00", "filename": "src/stacked_borrows/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/da45adc62246fb229ffaf4f0102ed60d199e8c32/src%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da45adc62246fb229ffaf4f0102ed60d199e8c32/src%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fmod.rs?ref=da45adc62246fb229ffaf4f0102ed60d199e8c32", "patch": "@@ -500,13 +500,19 @@ impl<'tcx> Stack {\n impl<'tcx> Stacks {\n     /// Creates a new stack with an initial tag. For diagnostic purposes, we also need to know\n     /// the [`AllocId`] of the allocation this is associated with.\n-    fn new(size: Size, perm: Permission, tag: SbTag, id: AllocId) -> Self {\n+    fn new(\n+        size: Size,\n+        perm: Permission,\n+        tag: SbTag,\n+        id: AllocId,\n+        current_span: &mut CurrentSpan<'_, '_, '_>,\n+    ) -> Self {\n         let item = Item::new(tag, perm, false);\n         let stack = Stack::new(item);\n \n         Stacks {\n             stacks: RangeMap::new(size, stack),\n-            history: AllocHistory::new(id),\n+            history: AllocHistory::new(id, item, current_span),\n             exposed_tags: FxHashSet::default(),\n         }\n     }\n@@ -538,6 +544,7 @@ impl Stacks {\n         size: Size,\n         state: &GlobalState,\n         kind: MemoryKind<MiriMemoryKind>,\n+        mut current_span: CurrentSpan<'_, '_, '_>,\n     ) -> Self {\n         let mut extra = state.borrow_mut();\n         let (base_tag, perm) = match kind {\n@@ -550,7 +557,7 @@ impl Stacks {\n             // Everything else is shared by default.\n             _ => (extra.base_ptr_tag(id), Permission::SharedReadWrite),\n         };\n-        Stacks::new(size, perm, base_tag, id)\n+        Stacks::new(size, perm, base_tag, id, &mut current_span)\n     }\n \n     #[inline(always)]"}, {"sha": "514b1a9901e6a5288808fed27ea39bea430e26f6", "filename": "tests/fail/stacked_borrows/aliasing_mut1.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/da45adc62246fb229ffaf4f0102ed60d199e8c32/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da45adc62246fb229ffaf4f0102ed60d199e8c32/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.stderr?ref=da45adc62246fb229ffaf4f0102ed60d199e8c32", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item [Unique for <TAG>] is protected by call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n   --> $DIR/aliasing_mut1.rs:LL:CC\n    |\n LL | pub fn safe(_x: &mut i32, _y: &mut i32) {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item [Unique for <TAG>] is protected by call ID\n+   |                           ^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n@@ -11,12 +11,11 @@ help: <TAG> was created by a Unique retag at offsets [0x0..0x4]\n    |\n LL |     let xraw: *mut i32 = unsafe { mem::transmute(&mut x) };\n    |                                                  ^^^^^^\n-help: <TAG> cannot be used for memory access because that would remove protected tag <TAG>, protected by this function call\n+help: <TAG> is this argument\n   --> $DIR/aliasing_mut1.rs:LL:CC\n    |\n LL | pub fn safe(_x: &mut i32, _y: &mut i32) {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = help: <TAG> was derived from <TAG>, the tag used for this memory access\n+   |             ^^\n    = note: backtrace:\n    = note: inside `safe` at $DIR/aliasing_mut1.rs:LL:CC\n note: inside `main` at $DIR/aliasing_mut1.rs:LL:CC"}, {"sha": "5fc56a91f577d8a14af133a5a27214d36c7e4d34", "filename": "tests/fail/stacked_borrows/aliasing_mut2.stderr", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/da45adc62246fb229ffaf4f0102ed60d199e8c32/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da45adc62246fb229ffaf4f0102ed60d199e8c32/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.stderr?ref=da45adc62246fb229ffaf4f0102ed60d199e8c32", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item [SharedReadOnly for <TAG>] is protected by call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n   --> $DIR/aliasing_mut2.rs:LL:CC\n    |\n LL | pub fn safe(_x: &i32, _y: &mut i32) {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item [SharedReadOnly for <TAG>] is protected by call ID\n+   |                       ^^ not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n@@ -11,16 +11,11 @@ help: <TAG> was created by a Unique retag at offsets [0x0..0x4]\n    |\n LL |     let xref = &mut x;\n    |                ^^^^^^\n-help: <TAG> cannot be used for memory access because that would remove protected tag <TAG>, protected by this function call\n+help: <TAG> is this argument\n   --> $DIR/aliasing_mut2.rs:LL:CC\n    |\n LL | pub fn safe(_x: &i32, _y: &mut i32) {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: <TAG> was derived from <TAG>, which in turn was created here\n-  --> $DIR/aliasing_mut2.rs:LL:CC\n-   |\n-LL |     safe_raw(xshr, xraw);\n-   |              ^^^^\n+   |             ^^\n    = note: backtrace:\n    = note: inside `safe` at $DIR/aliasing_mut2.rs:LL:CC\n note: inside `main` at $DIR/aliasing_mut2.rs:LL:CC"}, {"sha": "ee38ea417003bf9a18689af99a796a68c43ecb5f", "filename": "tests/fail/stacked_borrows/aliasing_mut3.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da45adc62246fb229ffaf4f0102ed60d199e8c32/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da45adc62246fb229ffaf4f0102ed60d199e8c32/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut3.stderr?ref=da45adc62246fb229ffaf4f0102ed60d199e8c32", "patch": "@@ -2,10 +2,10 @@ error: Undefined Behavior: trying to retag from <TAG> for SharedReadOnly permiss\n   --> $DIR/aliasing_mut3.rs:LL:CC\n    |\n LL | pub fn safe(_x: &mut i32, _y: &i32) {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   | |\n-   | trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-   | this error occurs as part of FnEntry retag at ALLOC[0x0..0x4]\n+   |                           ^^\n+   |                           |\n+   |                           trying to retag from <TAG> for SharedReadOnly permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |                           this error occurs as part of FnEntry retag at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "d5c2e736696798fd75e936a4f3bd51a613c8fd76", "filename": "tests/fail/stacked_borrows/aliasing_mut4.stderr", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/da45adc62246fb229ffaf4f0102ed60d199e8c32/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da45adc62246fb229ffaf4f0102ed60d199e8c32/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.stderr?ref=da45adc62246fb229ffaf4f0102ed60d199e8c32", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item [SharedReadOnly for <TAG>] is protected by call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n   --> $DIR/aliasing_mut4.rs:LL:CC\n    |\n LL | pub fn safe(_x: &i32, _y: &mut Cell<i32>) {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item [SharedReadOnly for <TAG>] is protected by call ID\n+   |                       ^^ not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n@@ -11,16 +11,11 @@ help: <TAG> was created by a Unique retag at offsets [0x0..0x4]\n    |\n LL |     let xref = &mut x;\n    |                ^^^^^^\n-help: <TAG> cannot be used for memory access because that would remove protected tag <TAG>, protected by this function call\n+help: <TAG> is this argument\n   --> $DIR/aliasing_mut4.rs:LL:CC\n    |\n LL | pub fn safe(_x: &i32, _y: &mut Cell<i32>) {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: <TAG> was derived from <TAG>, which in turn was created here\n-  --> $DIR/aliasing_mut4.rs:LL:CC\n-   |\n-LL |     safe_raw(xshr, xraw as *mut _);\n-   |              ^^^^\n+   |             ^^\n    = note: backtrace:\n    = note: inside `safe` at $DIR/aliasing_mut4.rs:LL:CC\n note: inside `main` at $DIR/aliasing_mut4.rs:LL:CC"}, {"sha": "448f1493367af3e45c0845417233a6d9665984c4", "filename": "tests/fail/stacked_borrows/illegal_write6.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da45adc62246fb229ffaf4f0102ed60d199e8c32/tests%2Ffail%2Fstacked_borrows%2Fillegal_write6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da45adc62246fb229ffaf4f0102ed60d199e8c32/tests%2Ffail%2Fstacked_borrows%2Fillegal_write6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write6.rs?ref=da45adc62246fb229ffaf4f0102ed60d199e8c32", "patch": "@@ -7,6 +7,6 @@ fn main() {\n fn foo(a: &mut u32, y: *mut u32) -> u32 {\n     *a = 1;\n     let _b = &*a;\n-    unsafe { *y = 2 }; //~ ERROR: /not granting access .* because incompatible item .* is protected/\n+    unsafe { *y = 2 }; //~ ERROR: /not granting access .* because that would remove .* which is protected/\n     return *a;\n }"}, {"sha": "56e4bd79d477e1c247effa75a87353069a46d388", "filename": "tests/fail/stacked_borrows/illegal_write6.stderr", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/da45adc62246fb229ffaf4f0102ed60d199e8c32/tests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da45adc62246fb229ffaf4f0102ed60d199e8c32/tests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr?ref=da45adc62246fb229ffaf4f0102ed60d199e8c32", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item [Unique for <TAG>] is protected by call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n   --> $DIR/illegal_write6.rs:LL:CC\n    |\n LL |     unsafe { *y = 2 };\n-   |              ^^^^^^ not granting access to tag <TAG> because incompatible item [Unique for <TAG>] is protected by call ID\n+   |              ^^^^^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n@@ -11,21 +11,11 @@ help: <TAG> was created by a SharedReadWrite retag at offsets [0x0..0x4]\n    |\n LL |     let p = x as *mut u32;\n    |             ^\n-help: <TAG> cannot be used for memory access because that would remove protected tag <TAG>, protected by this function call\n+help: <TAG> is this argument\n   --> $DIR/illegal_write6.rs:LL:CC\n    |\n-LL | / fn foo(a: &mut u32, y: *mut u32) -> u32 {\n-LL | |     *a = 1;\n-LL | |     let _b = &*a;\n-LL | |     unsafe { *y = 2 };\n-LL | |     return *a;\n-LL | | }\n-   | |_^\n-help: <TAG> was derived from <TAG>, which in turn was created here\n-  --> $DIR/illegal_write6.rs:LL:CC\n-   |\n-LL |     foo(x, p);\n-   |         ^\n+LL | fn foo(a: &mut u32, y: *mut u32) -> u32 {\n+   |        ^\n    = note: backtrace:\n    = note: inside `foo` at $DIR/illegal_write6.rs:LL:CC\n note: inside `main` at $DIR/illegal_write6.rs:LL:CC"}, {"sha": "5e6fd6e02757bd0575f12d51065af2017cfe937d", "filename": "tests/fail/stacked_borrows/invalidate_against_protector1.stderr", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/da45adc62246fb229ffaf4f0102ed60d199e8c32/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da45adc62246fb229ffaf4f0102ed60d199e8c32/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector1.stderr?ref=da45adc62246fb229ffaf4f0102ed60d199e8c32", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item [Unique for <TAG>] is protected by call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n   --> $DIR/invalidate_against_protector1.rs:LL:CC\n    |\n LL |     let _val = unsafe { *x };\n-   |                         ^^ not granting access to tag <TAG> because incompatible item [Unique for <TAG>] is protected by call ID\n+   |                         ^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n@@ -11,21 +11,11 @@ help: <TAG> was created by a SharedReadWrite retag at offsets [0x0..0x4]\n    |\n LL |     let xraw = &mut x as *mut _;\n    |                ^^^^^^\n-help: <TAG> cannot be used for memory access because that would remove protected tag <TAG>, protected by this function call\n+help: <TAG> is this argument\n   --> $DIR/invalidate_against_protector1.rs:LL:CC\n    |\n-LL | / fn inner(x: *mut i32, _y: &mut i32) {\n-LL | |     // If `x` and `y` alias, retagging is fine with this... but we really\n-LL | |     // shouldn't be allowed to use `x` at all because `y` was assumed to be\n-LL | |     // unique for the duration of this call.\n-LL | |     let _val = unsafe { *x };\n-LL | | }\n-   | |_^\n-help: <TAG> was derived from <TAG>, which in turn was created here\n-  --> $DIR/invalidate_against_protector1.rs:LL:CC\n-   |\n-LL |     inner(xraw, xref);\n-   |                 ^^^^\n+LL | fn inner(x: *mut i32, _y: &mut i32) {\n+   |                       ^^\n    = note: backtrace:\n    = note: inside `inner` at $DIR/invalidate_against_protector1.rs:LL:CC\n note: inside `main` at $DIR/invalidate_against_protector1.rs:LL:CC"}, {"sha": "eab55d2568dee9978fe9cdf654e817e119d3e9a7", "filename": "tests/fail/stacked_borrows/invalidate_against_protector2.stderr", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/da45adc62246fb229ffaf4f0102ed60d199e8c32/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da45adc62246fb229ffaf4f0102ed60d199e8c32/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector2.stderr?ref=da45adc62246fb229ffaf4f0102ed60d199e8c32", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item [SharedReadOnly for <TAG>] is protected by call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n   --> $DIR/invalidate_against_protector2.rs:LL:CC\n    |\n LL |     unsafe { *x = 0 };\n-   |              ^^^^^^ not granting access to tag <TAG> because incompatible item [SharedReadOnly for <TAG>] is protected by call ID\n+   |              ^^^^^^ not granting access to tag <TAG> because that would remove [SharedReadOnly for <TAG>] which is protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n@@ -11,21 +11,11 @@ help: <TAG> was created by a SharedReadWrite retag at offsets [0x0..0x4]\n    |\n LL |     let xraw = &mut x as *mut _;\n    |                ^^^^^^\n-help: <TAG> cannot be used for memory access because that would remove protected tag <TAG>, protected by this function call\n+help: <TAG> is this argument\n   --> $DIR/invalidate_against_protector2.rs:LL:CC\n    |\n-LL | / fn inner(x: *mut i32, _y: &i32) {\n-LL | |     // If `x` and `y` alias, retagging is fine with this... but we really\n-LL | |     // shouldn't be allowed to write to `x` at all because `y` was assumed to be\n-LL | |     // immutable for the duration of this call.\n-LL | |     unsafe { *x = 0 };\n-LL | | }\n-   | |_^\n-help: <TAG> was derived from <TAG>, which in turn was created here\n-  --> $DIR/invalidate_against_protector2.rs:LL:CC\n-   |\n-LL |     inner(xraw, xref);\n-   |                 ^^^^\n+LL | fn inner(x: *mut i32, _y: &i32) {\n+   |                       ^^\n    = note: backtrace:\n    = note: inside `inner` at $DIR/invalidate_against_protector2.rs:LL:CC\n note: inside `main` at $DIR/invalidate_against_protector2.rs:LL:CC"}, {"sha": "6e7413cff5d4b5a11ac4779292f3a3fc3ffe011b", "filename": "tests/fail/stacked_borrows/newtype_retagging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da45adc62246fb229ffaf4f0102ed60d199e8c32/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da45adc62246fb229ffaf4f0102ed60d199e8c32/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.rs?ref=da45adc62246fb229ffaf4f0102ed60d199e8c32", "patch": "@@ -1,5 +1,5 @@\n //@compile-flags: -Zmiri-retag-fields\n-//@error-pattern: is protected by call\n+//@error-pattern: which is protected\n struct Newtype<'a>(&'a mut i32);\n \n fn dealloc_while_running(_n: Newtype<'_>, dealloc: impl FnOnce()) {"}, {"sha": "7073c8162d16824e476eb5fb6438ceaa6d58f04c", "filename": "tests/fail/stacked_borrows/newtype_retagging.stderr", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/da45adc62246fb229ffaf4f0102ed60d199e8c32/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da45adc62246fb229ffaf4f0102ed60d199e8c32/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr?ref=da45adc62246fb229ffaf4f0102ed60d199e8c32", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item [Unique for <TAG>] is protected by call ID\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n   --> RUSTLIB/alloc/src/boxed.rs:LL:CC\n    |\n LL |         Box(unsafe { Unique::new_unchecked(raw) }, alloc)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item [Unique for <TAG>] is protected by call ID\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is protected because it is an argument of call ID\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n@@ -11,18 +11,11 @@ help: <TAG> was created by a SharedReadWrite retag at offsets [0x0..0x4]\n    |\n LL |     let ptr = Box::into_raw(Box::new(0i32));\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: <TAG> cannot be used for memory access because that would remove protected tag <TAG>, protected by this function call\n+help: <TAG> is this argument\n   --> $DIR/newtype_retagging.rs:LL:CC\n    |\n-LL | / fn dealloc_while_running(_n: Newtype<'_>, dealloc: impl FnOnce()) {\n-LL | |     dealloc();\n-LL | | }\n-   | |_^\n-help: <TAG> was derived from <TAG>, which in turn was created here\n-  --> $DIR/newtype_retagging.rs:LL:CC\n-   |\n-LL |             Newtype(&mut *ptr),\n-   |             ^^^^^^^^^^^^^^^^^^\n+LL | fn dealloc_while_running(_n: Newtype<'_>, dealloc: impl FnOnce()) {\n+   |                          ^^\n    = note: backtrace:\n    = note: inside `std::boxed::Box::<i32>::from_raw_in` at RUSTLIB/alloc/src/boxed.rs:LL:CC\n    = note: inside `std::boxed::Box::<i32>::from_raw` at RUSTLIB/alloc/src/boxed.rs:LL:CC"}]}