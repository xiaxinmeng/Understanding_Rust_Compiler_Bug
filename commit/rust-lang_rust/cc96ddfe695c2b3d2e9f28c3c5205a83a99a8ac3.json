{"sha": "cc96ddfe695c2b3d2e9f28c3c5205a83a99a8ac3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjOTZkZGZlNjk1YzJiM2QyZTlmMjhjM2M1MjA1YTgzYTk5YThhYzM=", "commit": {"author": {"name": "kjeremy", "email": "kjeremy@gmail.com", "date": "2020-01-09T21:01:43Z"}, "committer": {"name": "kjeremy", "email": "kjeremy@gmail.com", "date": "2020-01-10T20:14:19Z"}, "message": "Simplify and update tests to account for access", "tree": {"sha": "43985808ce364e46c817bcd29cd7cc32e4e25aab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43985808ce364e46c817bcd29cd7cc32e4e25aab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc96ddfe695c2b3d2e9f28c3c5205a83a99a8ac3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc96ddfe695c2b3d2e9f28c3c5205a83a99a8ac3", "html_url": "https://github.com/rust-lang/rust/commit/cc96ddfe695c2b3d2e9f28c3c5205a83a99a8ac3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc96ddfe695c2b3d2e9f28c3c5205a83a99a8ac3/comments", "author": {"login": "kjeremy", "id": 4325700, "node_id": "MDQ6VXNlcjQzMjU3MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/4325700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kjeremy", "html_url": "https://github.com/kjeremy", "followers_url": "https://api.github.com/users/kjeremy/followers", "following_url": "https://api.github.com/users/kjeremy/following{/other_user}", "gists_url": "https://api.github.com/users/kjeremy/gists{/gist_id}", "starred_url": "https://api.github.com/users/kjeremy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kjeremy/subscriptions", "organizations_url": "https://api.github.com/users/kjeremy/orgs", "repos_url": "https://api.github.com/users/kjeremy/repos", "events_url": "https://api.github.com/users/kjeremy/events{/privacy}", "received_events_url": "https://api.github.com/users/kjeremy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kjeremy", "id": 4325700, "node_id": "MDQ6VXNlcjQzMjU3MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/4325700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kjeremy", "html_url": "https://github.com/kjeremy", "followers_url": "https://api.github.com/users/kjeremy/followers", "following_url": "https://api.github.com/users/kjeremy/following{/other_user}", "gists_url": "https://api.github.com/users/kjeremy/gists{/gist_id}", "starred_url": "https://api.github.com/users/kjeremy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kjeremy/subscriptions", "organizations_url": "https://api.github.com/users/kjeremy/orgs", "repos_url": "https://api.github.com/users/kjeremy/repos", "events_url": "https://api.github.com/users/kjeremy/events{/privacy}", "received_events_url": "https://api.github.com/users/kjeremy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c89d86ade392ddd4088ecdb444ea7bd002a3cff", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c89d86ade392ddd4088ecdb444ea7bd002a3cff", "html_url": "https://github.com/rust-lang/rust/commit/6c89d86ade392ddd4088ecdb444ea7bd002a3cff"}], "stats": {"total": 101, "additions": 53, "deletions": 48}, "files": [{"sha": "5b8ed370c5c2edc761be6b85d976ddcc3f0e349a", "filename": "crates/ra_ide/src/references.rs", "status": "modified", "additions": 53, "deletions": 48, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/cc96ddfe695c2b3d2e9f28c3c5205a83a99a8ac3/crates%2Fra_ide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc96ddfe695c2b3d2e9f28c3c5205a83a99a8ac3/crates%2Fra_ide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences.rs?ref=cc96ddfe695c2b3d2e9f28c3c5205a83a99a8ac3", "patch": "@@ -55,7 +55,7 @@ pub enum ReferenceKind {\n     Other,\n }\n \n-#[derive(Debug, Clone, PartialEq)]\n+#[derive(Debug, Copy, Clone, PartialEq)]\n pub enum ReferenceAccess {\n     Read,\n     Write,\n@@ -225,49 +225,41 @@ fn process_definition(\n }\n \n fn access_mode(kind: NameKind, name_ref: &ast::NameRef) -> Option<ReferenceAccess> {\n+    // Only Locals and Fields have accesses for now.\n     match kind {\n-        NameKind::Local(_) | NameKind::Field(_) => {\n-            //LetExpr or BinExpr\n-            name_ref.syntax().ancestors().find_map(|node| {\n-                match_ast! {\n-                    match (node) {\n-                        ast::BinExpr(expr) => {\n-                            if expr.op_kind()?.is_assignment() {\n-                                // If the variable or field ends on the LHS's end then it's a Write (covers fields and locals).\n-                                // FIXME: This is not terribly accurate.\n-                                if let Some(lhs) = expr.lhs() {\n-                                    if lhs.syntax().text_range().end() == name_ref.syntax().text_range().end() {\n-                                        return Some(ReferenceAccess::Write);\n-                                    } else if name_ref.syntax().text_range().is_subrange(&lhs.syntax().text_range()) {\n-                                        return Some(ReferenceAccess::Read);\n-                                    }\n-                                }\n-\n-                                // If the variable is on the RHS then it's a Read.\n-                                if let Some(rhs) = expr.rhs() {\n-                                    if name_ref.syntax().text_range().is_subrange(&rhs.syntax().text_range()) {\n-                                        return Some(ReferenceAccess::Read);\n-                                    }\n-                                }\n-                            }\n+        NameKind::Local(_) | NameKind::Field(_) => {}\n+        _ => return None,\n+    };\n \n-                            // Cannot determine access\n-                            None\n-                        },\n-                        _ => {None}\n+    let mode = name_ref.syntax().ancestors().find_map(|node| {\n+        match_ast! {\n+            match (node) {\n+                ast::BinExpr(expr) => {\n+                    if expr.op_kind()?.is_assignment() {\n+                        // If the variable or field ends on the LHS's end then it's a Write (covers fields and locals).\n+                        // FIXME: This is not terribly accurate.\n+                        if let Some(lhs) = expr.lhs() {\n+                            if lhs.syntax().text_range().end() == name_ref.syntax().text_range().end() {\n+                                return Some(ReferenceAccess::Write);\n+                            }\n+                        }\n                     }\n-                }\n-            })\n+                    return Some(ReferenceAccess::Read);\n+                },\n+                _ => {None}\n+            }\n         }\n-        _ => None,\n-    }\n+    });\n+\n+    // Default Locals and Fields to read\n+    mode.or(Some(ReferenceAccess::Read))\n }\n \n #[cfg(test)]\n mod tests {\n     use crate::{\n         mock_analysis::{analysis_and_position, single_file_with_position, MockAnalysis},\n-        Reference, ReferenceAccess, ReferenceKind, ReferenceSearchResult, SearchScope,\n+        Reference, ReferenceKind, ReferenceSearchResult, SearchScope,\n     };\n \n     #[test]\n@@ -314,10 +306,10 @@ mod tests {\n             \"i BIND_PAT FileId(1) [33; 34)\",\n             ReferenceKind::Other,\n             &[\n-                \"FileId(1) [67; 68) Other\",\n-                \"FileId(1) [71; 72) Other\",\n-                \"FileId(1) [101; 102) Other\",\n-                \"FileId(1) [127; 128) Other\",\n+                \"FileId(1) [67; 68) Other Write\",\n+                \"FileId(1) [71; 72) Other Read\",\n+                \"FileId(1) [101; 102) Other Write\",\n+                \"FileId(1) [127; 128) Other Write\",\n             ],\n         );\n     }\n@@ -334,7 +326,7 @@ mod tests {\n             refs,\n             \"i BIND_PAT FileId(1) [12; 13)\",\n             ReferenceKind::Other,\n-            &[\"FileId(1) [38; 39) Other\"],\n+            &[\"FileId(1) [38; 39) Other Read\"],\n         );\n     }\n \n@@ -350,7 +342,7 @@ mod tests {\n             refs,\n             \"i BIND_PAT FileId(1) [12; 13)\",\n             ReferenceKind::Other,\n-            &[\"FileId(1) [38; 39) Other\"],\n+            &[\"FileId(1) [38; 39) Other Read\"],\n         );\n     }\n \n@@ -372,7 +364,7 @@ mod tests {\n             refs,\n             \"spam RECORD_FIELD_DEF FileId(1) [66; 79) [70; 74)\",\n             ReferenceKind::Other,\n-            &[\"FileId(1) [152; 156) Other\"],\n+            &[\"FileId(1) [152; 156) Other Read\"],\n         );\n     }\n \n@@ -577,9 +569,12 @@ mod tests {\n         }\"#;\n \n         let refs = get_all_refs(code);\n-        assert_eq!(refs.len(), 3);\n-        assert_eq!(refs.references[0].access, Some(ReferenceAccess::Write));\n-        assert_eq!(refs.references[1].access, Some(ReferenceAccess::Read));\n+        check_result(\n+            refs,\n+            \"i BIND_PAT FileId(1) [36; 37)\",\n+            ReferenceKind::Other,\n+            &[\"FileId(1) [55; 56) Other Write\", \"FileId(1) [59; 60) Other Read\"],\n+        );\n     }\n \n     #[test]\n@@ -595,9 +590,12 @@ mod tests {\n         }\"#;\n \n         let refs = get_all_refs(code);\n-        assert_eq!(refs.len(), 3);\n-        //assert_eq!(refs.references[0].access, Some(ReferenceAccess::Write));\n-        assert_eq!(refs.references[1].access, Some(ReferenceAccess::Write));\n+        check_result(\n+            refs,\n+            \"f RECORD_FIELD_DEF FileId(1) [32; 38) [32; 33)\",\n+            ReferenceKind::Other,\n+            &[\"FileId(1) [96; 97) Other Read\", \"FileId(1) [117; 118) Other Write\"],\n+        );\n     }\n \n     fn get_all_refs(text: &str) -> ReferenceSearchResult {\n@@ -620,7 +618,14 @@ mod tests {\n \n     impl Reference {\n         fn debug_render(&self) -> String {\n-            format!(\"{:?} {:?} {:?}\", self.file_range.file_id, self.file_range.range, self.kind)\n+            let mut s = format!(\n+                \"{:?} {:?} {:?}\",\n+                self.file_range.file_id, self.file_range.range, self.kind\n+            );\n+            if let Some(access) = self.access {\n+                s.push_str(&format!(\" {:?}\", access));\n+            }\n+            s\n         }\n \n         fn assert_match(&self, expected: &str) {"}]}