{"sha": "2287107588d92889d282e6cd3c1ca5df34cd34a5", "node_id": "C_kwDOAAsO6NoAKDIyODcxMDc1ODhkOTI4ODlkMjgyZTZjZDNjMWNhNWRmMzRjZDM0YTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-10T20:54:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-10T20:54:01Z"}, "message": "Auto merge of #98559 - jackh726:remove-reempty, r=oli-obk\n\nRemove ReEmpty\n\nr? rust-lang/types", "tree": {"sha": "efd90ebe87db4b8b9c5642b56e62728829badf29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efd90ebe87db4b8b9c5642b56e62728829badf29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2287107588d92889d282e6cd3c1ca5df34cd34a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2287107588d92889d282e6cd3c1ca5df34cd34a5", "html_url": "https://github.com/rust-lang/rust/commit/2287107588d92889d282e6cd3c1ca5df34cd34a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2287107588d92889d282e6cd3c1ca5df34cd34a5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a6ac3c225d6322caaf0ef86623cddc74e5260c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a6ac3c225d6322caaf0ef86623cddc74e5260c6", "html_url": "https://github.com/rust-lang/rust/commit/4a6ac3c225d6322caaf0ef86623cddc74e5260c6"}, {"sha": "1e54fcc1adeb3932ea7844ec1f86389a680ab86d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e54fcc1adeb3932ea7844ec1f86389a680ab86d", "html_url": "https://github.com/rust-lang/rust/commit/1e54fcc1adeb3932ea7844ec1f86389a680ab86d"}], "stats": {"total": 634, "additions": 336, "deletions": 298}, "files": [{"sha": "6c1eaa809c9055b65ce8e2892ee5dcf0d3981572", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -357,11 +357,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                 ty::BoundRegionKind::BrAnon(_) => None,\n             },\n \n-            ty::ReLateBound(..)\n-            | ty::ReVar(..)\n-            | ty::RePlaceholder(..)\n-            | ty::ReEmpty(_)\n-            | ty::ReErased => None,\n+            ty::ReLateBound(..) | ty::ReVar(..) | ty::RePlaceholder(..) | ty::ReErased => None,\n         }\n     }\n "}, {"sha": "9d088642f7773eca6e2133cc4bff4eb0b19f5657", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -109,7 +109,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         .iter()\n                         .find(|ur_vid| self.eval_equal(vid, **ur_vid))\n                         .and_then(|ur_vid| self.definitions[*ur_vid].external_name)\n-                        .unwrap_or(infcx.tcx.lifetimes.re_root_empty),\n+                        .unwrap_or(infcx.tcx.lifetimes.re_erased),\n                     _ => region,\n                 });\n \n@@ -433,7 +433,7 @@ struct ReverseMapper<'tcx> {\n \n     key: ty::OpaqueTypeKey<'tcx>,\n     map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n-    map_missing_regions_to_empty: bool,\n+    do_not_error: bool,\n \n     /// initially `Some`, set to `None` once error has been reported\n     hidden_ty: Option<Ty<'tcx>>,\n@@ -450,29 +450,19 @@ impl<'tcx> ReverseMapper<'tcx> {\n         hidden_ty: Ty<'tcx>,\n         span: Span,\n     ) -> Self {\n-        Self {\n-            tcx,\n-            key,\n-            map,\n-            map_missing_regions_to_empty: false,\n-            hidden_ty: Some(hidden_ty),\n-            span,\n-        }\n+        Self { tcx, key, map, do_not_error: false, hidden_ty: Some(hidden_ty), span }\n     }\n \n-    fn fold_kind_mapping_missing_regions_to_empty(\n-        &mut self,\n-        kind: GenericArg<'tcx>,\n-    ) -> GenericArg<'tcx> {\n-        assert!(!self.map_missing_regions_to_empty);\n-        self.map_missing_regions_to_empty = true;\n+    fn fold_kind_no_missing_regions_error(&mut self, kind: GenericArg<'tcx>) -> GenericArg<'tcx> {\n+        assert!(!self.do_not_error);\n+        self.do_not_error = true;\n         let kind = kind.fold_with(self);\n-        self.map_missing_regions_to_empty = false;\n+        self.do_not_error = false;\n         kind\n     }\n \n     fn fold_kind_normally(&mut self, kind: GenericArg<'tcx>) -> GenericArg<'tcx> {\n-        assert!(!self.map_missing_regions_to_empty);\n+        assert!(!self.do_not_error);\n         kind.fold_with(self)\n     }\n }\n@@ -496,9 +486,9 @@ impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n             ty::ReErased => return r,\n \n             // The regions that we expect from borrow checking.\n-            ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReEmpty(ty::UniverseIndex::ROOT) => {}\n+            ty::ReEarlyBound(_) | ty::ReFree(_) => {}\n \n-            ty::ReEmpty(_) | ty::RePlaceholder(_) | ty::ReVar(_) => {\n+            ty::RePlaceholder(_) | ty::ReVar(_) => {\n                 // All of the regions in the type should either have been\n                 // erased by writeback, or mapped back to named regions by\n                 // borrow checking.\n@@ -510,7 +500,7 @@ impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n         match self.map.get(&r.into()).map(|k| k.unpack()) {\n             Some(GenericArgKind::Lifetime(r1)) => r1,\n             Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n-            None if self.map_missing_regions_to_empty => self.tcx.lifetimes.re_root_empty,\n+            None if self.do_not_error => self.tcx.lifetimes.re_static,\n             None if generics.parent.is_some() => {\n                 if let Some(hidden_ty) = self.hidden_ty.take() {\n                     unexpected_hidden_region_diagnostic(\n@@ -522,7 +512,7 @@ impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                     )\n                     .emit();\n                 }\n-                self.tcx.lifetimes.re_root_empty\n+                self.tcx.lifetimes.re_static\n             }\n             None => {\n                 self.tcx\n@@ -574,7 +564,7 @@ impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                 let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n                     if index < generics.parent_count {\n                         // Accommodate missing regions in the parent kinds...\n-                        self.fold_kind_mapping_missing_regions_to_empty(kind)\n+                        self.fold_kind_no_missing_regions_error(kind)\n                     } else {\n                         // ...but not elsewhere.\n                         self.fold_kind_normally(kind)\n@@ -589,7 +579,7 @@ impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                 let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n                     if index < generics.parent_count {\n                         // Accommodate missing regions in the parent kinds...\n-                        self.fold_kind_mapping_missing_regions_to_empty(kind)\n+                        self.fold_kind_no_missing_regions_error(kind)\n                     } else {\n                         // ...but not elsewhere.\n                         self.fold_kind_normally(kind)"}, {"sha": "f1b1c33a1054362acdacbb24dd567c8dc4c85942", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -347,13 +347,6 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n \n             match outlives_bound {\n                 OutlivesBound::RegionSubRegion(r1, r2) => {\n-                    // `where Type:` is lowered to `where Type: 'empty` so that\n-                    // we check `Type` is well formed, but there's no use for\n-                    // this bound here.\n-                    if r1.is_empty() {\n-                        return;\n-                    }\n-\n                     // The bound says that `r1 <= r2`; we store `r2: r1`.\n                     let r1 = self.universal_regions.to_region_vid(r1);\n                     let r2 = self.universal_regions.to_region_vid(r2);"}, {"sha": "8cf9ed53d39d085ae58a9d47f5130ec8330845a8", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -54,13 +54,6 @@ pub struct UniversalRegions<'tcx> {\n     /// The total number of universal region variables instantiated.\n     num_universals: usize,\n \n-    /// A special region variable created for the `'empty(U0)` region.\n-    /// Note that this is **not** a \"universal\" region, as it doesn't\n-    /// represent a universally bound placeholder or any such thing.\n-    /// But we do create it here in this type because it's a useful region\n-    /// to have around in a few limited cases.\n-    pub root_empty: RegionVid,\n-\n     /// The \"defining\" type for this function, with all universal\n     /// regions instantiated. For a closure or generator, this is the\n     /// closure type, but for a top-level function it's the `FnDef`.\n@@ -323,11 +316,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n \n     /// See `UniversalRegionIndices::to_region_vid`.\n     pub fn to_region_vid(&self, r: ty::Region<'tcx>) -> RegionVid {\n-        if let ty::ReEmpty(ty::UniverseIndex::ROOT) = *r {\n-            self.root_empty\n-        } else {\n-            self.indices.to_region_vid(r)\n-        }\n+        self.indices.to_region_vid(r)\n     }\n \n     /// As part of the NLL unit tests, you can annotate a function with\n@@ -501,16 +490,10 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             _ => None,\n         };\n \n-        let root_empty = self\n-            .infcx\n-            .next_nll_region_var(NllRegionVariableOrigin::Existential { from_forall: true })\n-            .to_region_vid();\n-\n         UniversalRegions {\n             indices,\n             fr_static,\n             fr_fn_body,\n-            root_empty,\n             first_extern_index,\n             first_local_index,\n             num_universals,"}, {"sha": "7e051835b4bdf13c0991f04aecb9f41042f19678", "filename": "compiler/rustc_infer/src/errors/note_and_explain.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -27,13 +27,6 @@ impl<'a> DescriptionCtx<'a> {\n                 me.kind = \"restatic\";\n             }\n \n-            ty::ReEmpty(ty::UniverseIndex::ROOT) => me.kind = \"reempty\",\n-\n-            ty::ReEmpty(ui) => {\n-                me.kind = \"reemptyuni\";\n-                me.arg = format!(\"{:?}\", ui);\n-            }\n-\n             ty::RePlaceholder(_) => return None,\n \n             // FIXME(#13998) RePlaceholder should probably print like"}, {"sha": "9488d0a6cbb68c766f5fbf57536263768f53603d", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -180,11 +180,7 @@ impl CanonicalizeMode for CanonicalizeQueryResponse {\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n         match *r {\n-            ty::ReFree(_)\n-            | ty::ReErased\n-            | ty::ReStatic\n-            | ty::ReEmpty(ty::UniverseIndex::ROOT)\n-            | ty::ReEarlyBound(..) => r,\n+            ty::ReFree(_) | ty::ReErased | ty::ReStatic | ty::ReEarlyBound(..) => r,\n \n             ty::RePlaceholder(placeholder) => canonicalizer.canonical_var_for_region(\n                 CanonicalVarInfo { kind: CanonicalVarKind::PlaceholderRegion(placeholder) },\n@@ -199,10 +195,6 @@ impl CanonicalizeMode for CanonicalizeQueryResponse {\n                 )\n             }\n \n-            ty::ReEmpty(ui) => {\n-                bug!(\"canonicalizing 'empty in universe {:?}\", ui) // FIXME\n-            }\n-\n             _ => {\n                 // Other than `'static` or `'empty`, the query\n                 // response should be executing in a fully\n@@ -381,7 +373,6 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n             ty::ReStatic\n             | ty::ReEarlyBound(..)\n             | ty::ReFree(_)\n-            | ty::ReEmpty(_)\n             | ty::RePlaceholder(..)\n             | ty::ReErased => self.canonicalize_mode.canonicalize_free_region(self, r),\n         }"}, {"sha": "524383e381fee9b6c72fd2c577606ef2d905e19e", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -688,7 +688,6 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n \n             ty::RePlaceholder(..)\n             | ty::ReVar(..)\n-            | ty::ReEmpty(_)\n             | ty::ReStatic\n             | ty::ReEarlyBound(..)\n             | ty::ReFree(..) => {\n@@ -900,7 +899,6 @@ impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n \n             ty::RePlaceholder(..)\n             | ty::ReVar(..)\n-            | ty::ReEmpty(_)\n             | ty::ReStatic\n             | ty::ReEarlyBound(..)\n             | ty::ReFree(..) => {"}, {"sha": "9d5a128f8de3039e568e77a9bf90d0e636940f36", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -97,11 +97,6 @@ pub(super) fn note_and_explain_region<'tcx>(\n             msg_span_from_free_region(tcx, region, alt_span)\n         }\n \n-        ty::ReEmpty(ty::UniverseIndex::ROOT) => (\"the empty lifetime\".to_owned(), alt_span),\n-\n-        // uh oh, hope no user ever sees THIS\n-        ty::ReEmpty(ui) => (format!(\"the empty lifetime in universe {:?}\", ui), alt_span),\n-\n         ty::RePlaceholder(_) => return,\n \n         // FIXME(#13998) RePlaceholder should probably print like\n@@ -140,8 +135,6 @@ fn msg_span_from_free_region<'tcx>(\n             (msg, Some(span))\n         }\n         ty::ReStatic => (\"the static lifetime\".to_owned(), alt_span),\n-        ty::ReEmpty(ty::UniverseIndex::ROOT) => (\"an empty lifetime\".to_owned(), alt_span),\n-        ty::ReEmpty(ui) => (format!(\"an empty lifetime in universe {:?}\", ui), alt_span),\n         _ => bug!(\"{:?}\", region),\n     }\n }\n@@ -251,17 +244,7 @@ pub fn unexpected_hidden_region_diagnostic<'tcx>(\n \n     // Explain the region we are capturing.\n     match *hidden_region {\n-        ty::ReEmpty(ty::UniverseIndex::ROOT) => {\n-            // All lifetimes shorter than the function body are `empty` in\n-            // lexical region resolution. The default explanation of \"an empty\n-            // lifetime\" isn't really accurate here.\n-            let message = format!(\n-                \"hidden type `{}` captures lifetime smaller than the function body\",\n-                hidden_ty\n-            );\n-            err.span_note(span, &message);\n-        }\n-        ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic | ty::ReEmpty(_) => {\n+        ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic => {\n             // Assuming regionck succeeded (*), we ought to always be\n             // capturing *some* region from the fn header, and hence it\n             // ought to be free. So under normal circumstances, we will go\n@@ -387,7 +370,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     RegionResolutionError::UpperBoundUniverseConflict(\n                         _,\n                         _,\n-                        var_universe,\n+                        _,\n                         sup_origin,\n                         sup_r,\n                     ) => {\n@@ -398,7 +381,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         // placeholder. In practice, we expect more\n                         // tailored errors that don't really use this\n                         // value.\n-                        let sub_r = self.tcx.mk_region(ty::ReEmpty(var_universe));\n+                        let sub_r = self.tcx.lifetimes.re_erased;\n \n                         self.report_placeholder_failure(sup_origin, sub_r, sup_r).emit();\n                     }"}, {"sha": "fee15afc7b3aaa3077643900e3b3577a646e04fd", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -126,7 +126,6 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             | ty::ReFree(_)\n             | ty::ReVar(_)\n             | ty::RePlaceholder(..)\n-            | ty::ReEmpty(_)\n             | ty::ReErased => {\n                 // replace all free regions with 'erased\n                 self.tcx().lifetimes.re_erased"}, {"sha": "5f13b2b3deb1b6e0c7fce6f27bd78280a495238b", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 238, "deletions": 59, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -15,8 +15,9 @@ use rustc_data_structures::graph::implementation::{\n use rustc_data_structures::intern::Interned;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::ty::fold::TypeFoldable;\n+use rustc_middle::ty::PlaceholderRegion;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_middle::ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};\n+use rustc_middle::ty::{ReEarlyBound, ReErased, ReFree, ReStatic};\n use rustc_middle::ty::{ReLateBound, RePlaceholder, ReVar};\n use rustc_middle::ty::{Region, RegionVid};\n use rustc_span::Span;\n@@ -51,6 +52,13 @@ pub struct LexicalRegionResolutions<'tcx> {\n \n #[derive(Copy, Clone, Debug)]\n pub(crate) enum VarValue<'tcx> {\n+    /// Empty lifetime is for data that is never accessed.  We tag the\n+    /// empty lifetime with a universe -- the idea is that we don't\n+    /// want `exists<'a> { forall<'b> { 'b: 'a } }` to be satisfiable.\n+    /// Therefore, the `'empty` in a universe `U` is less than all\n+    /// regions visible from `U`, but not less than regions not visible\n+    /// from `U`.\n+    Empty(ty::UniverseIndex),\n     Value(Region<'tcx>),\n     ErrorValue,\n }\n@@ -117,7 +125,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         &mut self,\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n     ) -> LexicalRegionResolutions<'tcx> {\n-        let mut var_data = self.construct_var_data(self.tcx());\n+        let mut var_data = self.construct_var_data();\n \n         if cfg!(debug_assertions) {\n             self.dump_constraints();\n@@ -137,13 +145,12 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n     /// Initially, the value for all variables is set to `'empty`, the\n     /// empty region. The `expansion` phase will grow this larger.\n-    fn construct_var_data(&self, tcx: TyCtxt<'tcx>) -> LexicalRegionResolutions<'tcx> {\n+    fn construct_var_data(&self) -> LexicalRegionResolutions<'tcx> {\n         LexicalRegionResolutions {\n             values: IndexVec::from_fn_n(\n                 |vid| {\n                     let vid_universe = self.var_infos[vid].universe;\n-                    let re_empty = tcx.mk_region(ty::ReEmpty(vid_universe));\n-                    VarValue::Value(re_empty)\n+                    VarValue::Empty(vid_universe)\n                 },\n                 self.num_vars(),\n             ),\n@@ -189,39 +196,138 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n     }\n \n+    /// Gets the LUb of a given region and the empty region\n+    fn lub_empty(&self, a_region: Region<'tcx>) -> Result<Region<'tcx>, PlaceholderRegion> {\n+        match *a_region {\n+            ReLateBound(..) | ReErased => {\n+                bug!(\"cannot relate region: {:?}\", a_region);\n+            }\n+\n+            ReVar(v_id) => {\n+                span_bug!(\n+                    self.var_infos[v_id].origin.span(),\n+                    \"lub invoked with non-concrete regions: {:?}\",\n+                    a_region,\n+                );\n+            }\n+\n+            ReStatic => {\n+                // nothing lives longer than `'static`\n+                Ok(self.tcx().lifetimes.re_static)\n+            }\n+\n+            ReEarlyBound(_) | ReFree(_) => {\n+                // All empty regions are less than early-bound, free,\n+                // and scope regions.\n+                Ok(a_region)\n+            }\n+\n+            RePlaceholder(placeholder) => Err(placeholder),\n+        }\n+    }\n+\n     fn expansion(&self, var_values: &mut LexicalRegionResolutions<'tcx>) {\n+        // In the first pass, we expand region vids according to constraints we\n+        // have previously found. In the second pass, we loop through the region\n+        // vids we expanded and expand *across* region vids (effectively\n+        // \"expanding\" new `RegSubVar` constraints).\n+\n+        // Tracks the `VarSubVar` constraints generated for each region vid. We\n+        // later use this to expand across vids.\n         let mut constraints = IndexVec::from_elem_n(Vec::new(), var_values.values.len());\n+        // Tracks the changed region vids.\n         let mut changes = Vec::new();\n         for constraint in self.data.constraints.keys() {\n-            let (a_vid, a_region, b_vid, b_data) = match *constraint {\n+            match *constraint {\n                 Constraint::RegSubVar(a_region, b_vid) => {\n                     let b_data = var_values.value_mut(b_vid);\n-                    (None, a_region, b_vid, b_data)\n+\n+                    if self.expand_node(a_region, b_vid, b_data) {\n+                        changes.push(b_vid);\n+                    }\n                 }\n                 Constraint::VarSubVar(a_vid, b_vid) => match *var_values.value(a_vid) {\n                     VarValue::ErrorValue => continue,\n+                    VarValue::Empty(a_universe) => {\n+                        let b_data = var_values.value_mut(b_vid);\n+\n+                        let changed = (|| match *b_data {\n+                            VarValue::Empty(b_universe) => {\n+                                // Empty regions are ordered according to the universe\n+                                // they are associated with.\n+                                let ui = a_universe.min(b_universe);\n+\n+                                debug!(\n+                                    \"Expanding value of {:?} \\\n+                                    from empty lifetime with universe {:?} \\\n+                                    to empty lifetime with universe {:?}\",\n+                                    b_vid, b_universe, ui\n+                                );\n+\n+                                *b_data = VarValue::Empty(ui);\n+                                true\n+                            }\n+                            VarValue::Value(cur_region) => {\n+                                let lub = match self.lub_empty(cur_region) {\n+                                    Ok(r) => r,\n+                                    // If the empty and placeholder regions are in the same universe,\n+                                    // then the LUB is the Placeholder region (which is the cur_region).\n+                                    // If they are not in the same universe, the LUB is the Static lifetime.\n+                                    Err(placeholder) if a_universe == placeholder.universe => {\n+                                        cur_region\n+                                    }\n+                                    Err(_) => self.tcx().lifetimes.re_static,\n+                                };\n+\n+                                if lub == cur_region {\n+                                    return false;\n+                                }\n+\n+                                debug!(\n+                                    \"Expanding value of {:?} from {:?} to {:?}\",\n+                                    b_vid, cur_region, lub\n+                                );\n+\n+                                *b_data = VarValue::Value(lub);\n+                                true\n+                            }\n+\n+                            VarValue::ErrorValue => false,\n+                        })();\n+\n+                        if changed {\n+                            changes.push(b_vid);\n+                        }\n+                        match b_data {\n+                            VarValue::Value(Region(Interned(ReStatic, _)))\n+                            | VarValue::ErrorValue => (),\n+                            _ => {\n+                                constraints[a_vid].push((a_vid, b_vid));\n+                                constraints[b_vid].push((a_vid, b_vid));\n+                            }\n+                        }\n+                    }\n                     VarValue::Value(a_region) => {\n                         let b_data = var_values.value_mut(b_vid);\n-                        (Some(a_vid), a_region, b_vid, b_data)\n+\n+                        if self.expand_node(a_region, b_vid, b_data) {\n+                            changes.push(b_vid);\n+                        }\n+                        match b_data {\n+                            VarValue::Value(Region(Interned(ReStatic, _)))\n+                            | VarValue::ErrorValue => (),\n+                            _ => {\n+                                constraints[a_vid].push((a_vid, b_vid));\n+                                constraints[b_vid].push((a_vid, b_vid));\n+                            }\n+                        }\n                     }\n                 },\n                 Constraint::RegSubReg(..) | Constraint::VarSubReg(..) => {\n                     // These constraints are checked after expansion\n                     // is done, in `collect_errors`.\n                     continue;\n                 }\n-            };\n-            if self.expand_node(a_region, b_vid, b_data) {\n-                changes.push(b_vid);\n-            }\n-            if let Some(a_vid) = a_vid {\n-                match b_data {\n-                    VarValue::Value(Region(Interned(ReStatic, _))) | VarValue::ErrorValue => (),\n-                    _ => {\n-                        constraints[a_vid].push((a_vid, b_vid));\n-                        constraints[b_vid].push((a_vid, b_vid));\n-                    }\n-                }\n             }\n         }\n \n@@ -242,6 +348,10 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n     }\n \n+    /// Expands the value of the region represented with `b_vid` with current\n+    /// value `b_data` to the lub of `b_data` and `a_region`. The corresponds\n+    /// with the constraint `'?b: 'a` (`'a <: '?b`), where `'a` is some known\n+    /// region and `'?b` is some region variable.\n     fn expand_node(\n         &self,\n         a_region: Region<'tcx>,\n@@ -263,14 +373,28 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n \n         match *b_data {\n+            VarValue::Empty(empty_ui) => {\n+                let lub = match self.lub_empty(a_region) {\n+                    Ok(r) => r,\n+                    // If this empty region is from a universe that can\n+                    // name the placeholder, then the placeholder is\n+                    // larger; otherwise, the only ancestor is `'static`.\n+                    Err(placeholder) if empty_ui.can_name(placeholder.universe) => {\n+                        self.tcx().mk_region(RePlaceholder(placeholder))\n+                    }\n+                    Err(_) => self.tcx().lifetimes.re_static,\n+                };\n+\n+                debug!(\"Expanding value of {:?} from empty lifetime to {:?}\", b_vid, lub);\n+\n+                *b_data = VarValue::Value(lub);\n+                true\n+            }\n             VarValue::Value(cur_region) => {\n                 // This is a specialized version of the `lub_concrete_regions`\n                 // check below for a common case, here purely as an\n                 // optimization.\n                 let b_universe = self.var_infos[b_vid].universe;\n-                if let ReEmpty(a_universe) = *a_region && a_universe == b_universe {\n-                    return false;\n-                }\n \n                 let mut lub = self.lub_concrete_regions(a_region, cur_region);\n                 if lub == cur_region {\n@@ -300,6 +424,78 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n     }\n \n+    /// True if `a <= b`.\n+    fn sub_region_values(&self, a: VarValue<'tcx>, b: VarValue<'tcx>) -> bool {\n+        match (a, b) {\n+            // Error region is `'static`\n+            (VarValue::ErrorValue, _) | (_, VarValue::ErrorValue) => return true,\n+            (VarValue::Empty(a_ui), VarValue::Empty(b_ui)) => {\n+                // Empty regions are ordered according to the universe\n+                // they are associated with.\n+                a_ui.min(b_ui) == b_ui\n+            }\n+            (VarValue::Value(a), VarValue::Empty(_)) => {\n+                match *a {\n+                    ReLateBound(..) | ReErased => {\n+                        bug!(\"cannot relate region: {:?}\", a);\n+                    }\n+\n+                    ReVar(v_id) => {\n+                        span_bug!(\n+                            self.var_infos[v_id].origin.span(),\n+                            \"lub_concrete_regions invoked with non-concrete region: {:?}\",\n+                            a\n+                        );\n+                    }\n+\n+                    ReStatic | ReEarlyBound(_) | ReFree(_) => {\n+                        // nothing lives longer than `'static`\n+\n+                        // All empty regions are less than early-bound, free,\n+                        // and scope regions.\n+\n+                        false\n+                    }\n+\n+                    RePlaceholder(_) => {\n+                        // The LUB is either `a` or `'static`\n+                        false\n+                    }\n+                }\n+            }\n+            (VarValue::Empty(a_ui), VarValue::Value(b)) => {\n+                match *b {\n+                    ReLateBound(..) | ReErased => {\n+                        bug!(\"cannot relate region: {:?}\", b);\n+                    }\n+\n+                    ReVar(v_id) => {\n+                        span_bug!(\n+                            self.var_infos[v_id].origin.span(),\n+                            \"lub_concrete_regions invoked with non-concrete regions: {:?}\",\n+                            b\n+                        );\n+                    }\n+\n+                    ReStatic | ReEarlyBound(_) | ReFree(_) => {\n+                        // nothing lives longer than `'static`\n+                        // All empty regions are less than early-bound, free,\n+                        // and scope regions.\n+                        true\n+                    }\n+\n+                    RePlaceholder(placeholder) => {\n+                        // If this empty region is from a universe that can\n+                        // name the placeholder, then the placeholder is\n+                        // larger; otherwise, the only ancestor is `'static`.\n+                        if a_ui.can_name(placeholder.universe) { true } else { false }\n+                    }\n+                }\n+            }\n+            (VarValue::Value(a), VarValue::Value(b)) => self.sub_concrete_regions(a, b),\n+        }\n+    }\n+\n     /// True if `a <= b`, but not defined over inference variables.\n     #[instrument(level = \"trace\", skip(self))]\n     fn sub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> bool {\n@@ -355,37 +551,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 self.tcx().lifetimes.re_static\n             }\n \n-            (ReEmpty(_), ReEarlyBound(_) | ReFree(_)) => {\n-                // All empty regions are less than early-bound, free,\n-                // and scope regions.\n-                b\n-            }\n-\n-            (ReEarlyBound(_) | ReFree(_), ReEmpty(_)) => {\n-                // All empty regions are less than early-bound, free,\n-                // and scope regions.\n-                a\n-            }\n-\n-            (ReEmpty(a_ui), ReEmpty(b_ui)) => {\n-                // Empty regions are ordered according to the universe\n-                // they are associated with.\n-                let ui = a_ui.min(b_ui);\n-                self.tcx().mk_region(ReEmpty(ui))\n-            }\n-\n-            (ReEmpty(empty_ui), RePlaceholder(placeholder))\n-            | (RePlaceholder(placeholder), ReEmpty(empty_ui)) => {\n-                // If this empty region is from a universe that can\n-                // name the placeholder, then the placeholder is\n-                // larger; otherwise, the only ancestor is `'static`.\n-                if empty_ui.can_name(placeholder.universe) {\n-                    self.tcx().mk_region(RePlaceholder(placeholder))\n-                } else {\n-                    self.tcx().lifetimes.re_static\n-                }\n-            }\n-\n             (ReEarlyBound(_) | ReFree(_), ReEarlyBound(_) | ReFree(_)) => {\n                 self.region_rels.lub_free_regions(a, b)\n             }\n@@ -508,7 +673,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n         for (node_vid, value) in var_data.values.iter_enumerated() {\n             match *value {\n-                VarValue::Value(_) => { /* Inference successful */ }\n+                VarValue::Empty(_) | VarValue::Value(_) => { /* Inference successful */ }\n                 VarValue::ErrorValue => {\n                     // Inference impossible: this value contains\n                     // inconsistent constraints.\n@@ -829,12 +994,25 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             }\n \n             VerifyBound::OutlivedBy(r) => {\n-                self.sub_concrete_regions(min, var_values.normalize(self.tcx(), *r))\n+                let a = match *min {\n+                    ty::ReVar(rid) => var_values.values[rid],\n+                    _ => VarValue::Value(min),\n+                };\n+                let b = match **r {\n+                    ty::ReVar(rid) => var_values.values[rid],\n+                    _ => VarValue::Value(*r),\n+                };\n+                self.sub_region_values(a, b)\n             }\n \n-            VerifyBound::IsEmpty => {\n-                matches!(*min, ty::ReEmpty(_))\n-            }\n+            VerifyBound::IsEmpty => match *min {\n+                ty::ReVar(rid) => match var_values.values[rid] {\n+                    VarValue::ErrorValue => false,\n+                    VarValue::Empty(_) => true,\n+                    VarValue::Value(_) => false,\n+                },\n+                _ => false,\n+            },\n \n             VerifyBound::AnyBound(bs) => {\n                 bs.iter().any(|b| self.bound_is_met(b, var_values, generic_ty, min))\n@@ -876,6 +1054,7 @@ impl<'tcx> LexicalRegionResolutions<'tcx> {\n     ) -> ty::Region<'tcx> {\n         let result = match *r {\n             ty::ReVar(rid) => match self.values[rid] {\n+                VarValue::Empty(_) => r,\n                 VarValue::Value(r) => r,\n                 VarValue::ErrorValue => tcx.lifetimes.re_static,\n             },"}, {"sha": "e43d28ee56e3eb09b9c95412ab8f607c3e84ba0e", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -426,21 +426,21 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         data\n     }\n \n-    pub fn data(&self) -> &RegionConstraintData<'tcx> {\n+    pub(super) fn data(&self) -> &RegionConstraintData<'tcx> {\n         &self.data\n     }\n \n-    pub fn start_snapshot(&mut self) -> RegionSnapshot {\n+    pub(super) fn start_snapshot(&mut self) -> RegionSnapshot {\n         debug!(\"RegionConstraintCollector: start_snapshot\");\n         RegionSnapshot { any_unifications: self.any_unifications }\n     }\n \n-    pub fn rollback_to(&mut self, snapshot: RegionSnapshot) {\n+    pub(super) fn rollback_to(&mut self, snapshot: RegionSnapshot) {\n         debug!(\"RegionConstraintCollector: rollback_to({:?})\", snapshot);\n         self.any_unifications = snapshot.any_unifications;\n     }\n \n-    pub fn new_region_var(\n+    pub(super) fn new_region_var(\n         &mut self,\n         universe: ty::UniverseIndex,\n         origin: RegionVariableOrigin,\n@@ -455,12 +455,12 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n     }\n \n     /// Returns the universe for the given variable.\n-    pub fn var_universe(&self, vid: RegionVid) -> ty::UniverseIndex {\n+    pub(super) fn var_universe(&self, vid: RegionVid) -> ty::UniverseIndex {\n         self.var_infos[vid].universe\n     }\n \n     /// Returns the origin for the given variable.\n-    pub fn var_origin(&self, vid: RegionVid) -> RegionVariableOrigin {\n+    pub(super) fn var_origin(&self, vid: RegionVid) -> RegionVariableOrigin {\n         self.var_infos[vid].origin\n     }\n \n@@ -492,7 +492,7 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         self.undo_log.push(AddVerify(index));\n     }\n \n-    pub fn add_given(&mut self, sub: Region<'tcx>, sup: ty::RegionVid) {\n+    pub(super) fn add_given(&mut self, sub: Region<'tcx>, sup: ty::RegionVid) {\n         // cannot add givens once regions are resolved\n         if self.data.givens.insert((sub, sup)) {\n             debug!(\"add_given({:?} <= {:?})\", sub, sup);\n@@ -501,7 +501,7 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         }\n     }\n \n-    pub fn make_eqregion(\n+    pub(super) fn make_eqregion(\n         &mut self,\n         origin: SubregionOrigin<'tcx>,\n         sub: Region<'tcx>,\n@@ -530,7 +530,7 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         }\n     }\n \n-    pub fn member_constraint(\n+    pub(super) fn member_constraint(\n         &mut self,\n         key: ty::OpaqueTypeKey<'tcx>,\n         definition_span: Span,\n@@ -554,7 +554,7 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n     }\n \n     #[instrument(skip(self, origin), level = \"debug\")]\n-    pub fn make_subregion(\n+    pub(super) fn make_subregion(\n         &mut self,\n         origin: SubregionOrigin<'tcx>,\n         sub: Region<'tcx>,\n@@ -585,7 +585,7 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         }\n     }\n \n-    pub fn verify_generic_bound(\n+    pub(super) fn verify_generic_bound(\n         &mut self,\n         origin: SubregionOrigin<'tcx>,\n         kind: GenericKind<'tcx>,\n@@ -595,7 +595,7 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         self.add_verify(Verify { kind, origin, region: sub, bound });\n     }\n \n-    pub fn lub_regions(\n+    pub(super) fn lub_regions(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n         origin: SubregionOrigin<'tcx>,\n@@ -613,7 +613,7 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         }\n     }\n \n-    pub fn glb_regions(\n+    pub(super) fn glb_regions(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n         origin: SubregionOrigin<'tcx>,\n@@ -634,7 +634,7 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n     }\n \n     /// Resolves the passed RegionVid to the root RegionVid in the unification table\n-    pub fn opportunistic_resolve_var(&mut self, rid: ty::RegionVid) -> ty::RegionVid {\n+    pub(super) fn opportunistic_resolve_var(&mut self, rid: ty::RegionVid) -> ty::RegionVid {\n         self.unification_table().find(rid).vid\n     }\n \n@@ -699,7 +699,6 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n             ty::ReStatic | ty::ReErased | ty::ReFree(..) | ty::ReEarlyBound(..) => {\n                 ty::UniverseIndex::ROOT\n             }\n-            ty::ReEmpty(ui) => ui,\n             ty::RePlaceholder(placeholder) => placeholder.universe,\n             ty::ReVar(vid) => self.var_universe(vid),\n             ty::ReLateBound(..) => bug!(\"universe(): encountered bound region {:?}\", region),"}, {"sha": "afb2d5b2ba5e5a00eee16751240184c83da06320", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -276,9 +276,6 @@ pub struct CommonTypes<'tcx> {\n }\n \n pub struct CommonLifetimes<'tcx> {\n-    /// `ReEmpty` in the root universe.\n-    pub re_root_empty: Region<'tcx>,\n-\n     /// `ReStatic`\n     pub re_static: Region<'tcx>,\n \n@@ -987,11 +984,7 @@ impl<'tcx> CommonLifetimes<'tcx> {\n             ))\n         };\n \n-        CommonLifetimes {\n-            re_root_empty: mk(ty::ReEmpty(ty::UniverseIndex::ROOT)),\n-            re_static: mk(ty::ReStatic),\n-            re_erased: mk(ty::ReErased),\n-        }\n+        CommonLifetimes { re_static: mk(ty::ReStatic), re_erased: mk(ty::ReErased) }\n     }\n }\n "}, {"sha": "301d1f5052eeea1769b4daaac0c5edf9547b1bd0", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -1986,7 +1986,7 @@ impl<'tcx> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx> {\n \n             ty::ReVar(_) | ty::ReErased => false,\n \n-            ty::ReStatic | ty::ReEmpty(_) => true,\n+            ty::ReStatic => true,\n         }\n     }\n \n@@ -2070,14 +2070,6 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n                 p!(\"'static\");\n                 return Ok(self);\n             }\n-            ty::ReEmpty(ty::UniverseIndex::ROOT) => {\n-                p!(\"'<empty>\");\n-                return Ok(self);\n-            }\n-            ty::ReEmpty(ui) => {\n-                p!(write(\"'<empty:{:?}>\", ui));\n-                return Ok(self);\n-            }\n         }\n \n         p!(\"'_\");"}, {"sha": "702c2d27187eed591876283955ad64b5c93e9bc3", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -1514,7 +1514,6 @@ impl<'tcx> Region<'tcx> {\n             ty::ReStatic => true,\n             ty::ReVar(..) => false,\n             ty::RePlaceholder(placeholder) => placeholder.name.is_named(),\n-            ty::ReEmpty(_) => false,\n             ty::ReErased => false,\n         }\n     }\n@@ -1539,11 +1538,6 @@ impl<'tcx> Region<'tcx> {\n         matches!(*self, ty::RePlaceholder(..))\n     }\n \n-    #[inline]\n-    pub fn is_empty(self) -> bool {\n-        matches!(*self, ty::ReEmpty(..))\n-    }\n-\n     #[inline]\n     pub fn bound_at_or_above_binder(self, index: ty::DebruijnIndex) -> bool {\n         match *self {\n@@ -1575,7 +1569,7 @@ impl<'tcx> Region<'tcx> {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n                 flags = flags | TypeFlags::HAS_FREE_LOCAL_REGIONS;\n             }\n-            ty::ReEmpty(_) | ty::ReStatic => {\n+            ty::ReStatic => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n             }\n             ty::ReLateBound(..) => {"}, {"sha": "bd8126f617773bbd80fd9af58dbd3c6bffc30935", "filename": "compiler/rustc_symbol_mangling/src/typeid/typeid_itanium_cxx_abi.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -305,8 +305,7 @@ fn encode_region<'tcx>(\n         | RegionKind::ReFree(..)\n         | RegionKind::ReStatic\n         | RegionKind::ReVar(..)\n-        | RegionKind::RePlaceholder(..)\n-        | RegionKind::ReEmpty(..) => {\n+        | RegionKind::RePlaceholder(..) => {\n             bug!(\"encode_region: unexpected `{:?}`\", region.kind());\n         }\n     }"}, {"sha": "9d3a1a4a031aed171163b2b9bfaaf31a5e975496", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -101,6 +101,7 @@ pub fn trait_obligations<'a, 'tcx>(\n     wf.normalize(infcx)\n }\n \n+#[instrument(skip(infcx), ret)]\n pub fn predicate_obligations<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -440,6 +441,7 @@ impl<'tcx> WfPredicates<'tcx> {\n         let param_env = self.param_env;\n         let depth = self.recursion_depth;\n         while let Some(arg) = walker.next() {\n+            debug!(?arg, ?self.out);\n             let ty = match arg.unpack() {\n                 GenericArgKind::Type(ty) => ty,\n \n@@ -689,6 +691,8 @@ impl<'tcx> WfPredicates<'tcx> {\n                     ));\n                 }\n             }\n+\n+            debug!(?self.out);\n         }\n     }\n "}, {"sha": "a6a098ce73f8d7ee1c5f0f42dd36f5f72840b858", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -485,10 +485,6 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Lifetime<RustInterner<'tcx>>> for Region<'t\n                 })\n                 .intern(interner)\n             }\n-            ty::ReEmpty(ui) => {\n-                chalk_ir::LifetimeData::Empty(chalk_ir::UniverseIndex { counter: ui.index() })\n-                    .intern(interner)\n-            }\n             ty::ReErased => chalk_ir::LifetimeData::Erased.intern(interner),\n         }\n     }\n@@ -510,8 +506,8 @@ impl<'tcx> LowerInto<'tcx, Region<'tcx>> for &chalk_ir::Lifetime<RustInterner<'t\n                 name: ty::BoundRegionKind::BrAnon(p.idx as u32),\n             }),\n             chalk_ir::LifetimeData::Static => return interner.tcx.lifetimes.re_static,\n-            chalk_ir::LifetimeData::Empty(ui) => {\n-                ty::ReEmpty(ty::UniverseIndex::from_usize(ui.counter))\n+            chalk_ir::LifetimeData::Empty(_) => {\n+                bug!(\"Chalk should not have been passed an empty lifetime.\")\n             }\n             chalk_ir::LifetimeData::Erased => return interner.tcx.lifetimes.re_erased,\n             chalk_ir::LifetimeData::Phantom(void, _) => match *void {},"}, {"sha": "e164aaed6b4b8d489296dbd1be6ea0b93c8fc08a", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 4, "deletions": 29, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -3,14 +3,14 @@\n use std::cmp::{Eq, Ord, Ordering, PartialEq, PartialOrd};\n use std::{fmt, hash};\n \n+use crate::DebruijnIndex;\n use crate::FloatTy;\n+use crate::HashStableContext;\n use crate::IntTy;\n use crate::Interner;\n use crate::TyDecoder;\n use crate::TyEncoder;\n use crate::UintTy;\n-use crate::UniverseIndex;\n-use crate::{DebruijnIndex, HashStableContext};\n \n use self::RegionKind::*;\n use self::TyKind::*;\n@@ -1023,14 +1023,6 @@ pub enum RegionKind<I: Interner> {\n     /// Should not exist outside of type inference.\n     RePlaceholder(I::PlaceholderRegion),\n \n-    /// Empty lifetime is for data that is never accessed.  We tag the\n-    /// empty lifetime with a universe -- the idea is that we don't\n-    /// want `exists<'a> { forall<'b> { 'b: 'a } }` to be satisfiable.\n-    /// Therefore, the `'empty` in a universe `U` is less than all\n-    /// regions visible from `U`, but not less than regions not visible\n-    /// from `U`.\n-    ReEmpty(UniverseIndex),\n-\n     /// Erased region, used by trait selection, in MIR and during codegen.\n     ReErased,\n }\n@@ -1046,8 +1038,7 @@ const fn regionkind_discriminant<I: Interner>(value: &RegionKind<I>) -> usize {\n         ReStatic => 3,\n         ReVar(_) => 4,\n         RePlaceholder(_) => 5,\n-        ReEmpty(_) => 6,\n-        ReErased => 7,\n+        ReErased => 6,\n     }\n }\n \n@@ -1072,7 +1063,6 @@ impl<I: Interner> Clone for RegionKind<I> {\n             ReStatic => ReStatic,\n             ReVar(a) => ReVar(a.clone()),\n             RePlaceholder(a) => RePlaceholder(a.clone()),\n-            ReEmpty(a) => ReEmpty(a.clone()),\n             ReErased => ReErased,\n         }\n     }\n@@ -1099,7 +1089,6 @@ impl<I: Interner> PartialEq for RegionKind<I> {\n                 (&RePlaceholder(ref __self_0), &RePlaceholder(ref __arg_1_0)) => {\n                     __self_0 == __arg_1_0\n                 }\n-                (&ReEmpty(ref __self_0), &ReEmpty(ref __arg_1_0)) => __self_0 == __arg_1_0,\n                 (&ReErased, &ReErased) => true,\n                 _ => true,\n             }\n@@ -1144,7 +1133,6 @@ impl<I: Interner> Ord for RegionKind<I> {\n                 (&RePlaceholder(ref __self_0), &RePlaceholder(ref __arg_1_0)) => {\n                     Ord::cmp(__self_0, __arg_1_0)\n                 }\n-                (&ReEmpty(ref __self_0), &ReEmpty(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n                 (&ReErased, &ReErased) => Ordering::Equal,\n                 _ => Ordering::Equal,\n             }\n@@ -1182,10 +1170,6 @@ impl<I: Interner> hash::Hash for RegionKind<I> {\n                 hash::Hash::hash(&regionkind_discriminant(self), state);\n                 hash::Hash::hash(__self_0, state)\n             }\n-            (&ReEmpty(ref __self_0),) => {\n-                hash::Hash::hash(&regionkind_discriminant(self), state);\n-                hash::Hash::hash(__self_0, state)\n-            }\n             (&ReErased,) => {\n                 hash::Hash::hash(&regionkind_discriminant(self), state);\n             }\n@@ -1211,8 +1195,6 @@ impl<I: Interner> fmt::Debug for RegionKind<I> {\n \n             RePlaceholder(placeholder) => write!(f, \"RePlaceholder({:?})\", placeholder),\n \n-            ReEmpty(ui) => write!(f, \"ReEmpty({:?})\", ui),\n-\n             ReErased => write!(f, \"ReErased\"),\n         }\n     }\n@@ -1247,9 +1229,6 @@ where\n             RePlaceholder(a) => e.emit_enum_variant(disc, |e| {\n                 a.encode(e);\n             }),\n-            ReEmpty(a) => e.emit_enum_variant(disc, |e| {\n-                a.encode(e);\n-            }),\n             ReErased => e.emit_enum_variant(disc, |_| {}),\n         }\n     }\n@@ -1272,8 +1251,7 @@ where\n             3 => ReStatic,\n             4 => ReVar(Decodable::decode(d)),\n             5 => RePlaceholder(Decodable::decode(d)),\n-            6 => ReEmpty(Decodable::decode(d)),\n-            7 => ReErased,\n+            6 => ReErased,\n             _ => panic!(\n                 \"{}\",\n                 format!(\n@@ -1305,9 +1283,6 @@ where\n             ReErased | ReStatic => {\n                 // No variant fields to hash for these ...\n             }\n-            ReEmpty(universe) => {\n-                universe.hash_stable(hcx, hasher);\n-            }\n             ReLateBound(db, br) => {\n                 db.hash_stable(hcx, hasher);\n                 br.hash_stable(hcx, hasher);"}, {"sha": "ab143c059820dc1497f2157f3287789786d2abab", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -144,6 +144,8 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     let assumptions_in_impl_context = generic_assumptions.instantiate(tcx, &self_to_impl_substs);\n     let assumptions_in_impl_context = assumptions_in_impl_context.predicates;\n \n+    debug!(?assumptions_in_impl_context, ?dtor_predicates.predicates);\n+\n     let self_param_env = tcx.param_env(self_type_did);\n \n     // An earlier version of this code attempted to do this checking"}, {"sha": "b0ce0de1469b953dd33afd8427e8af0227f9bbc5", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -1816,6 +1816,7 @@ fn report_bivariance(\n impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n     /// Feature gates RFC 2056 -- trivial bounds, checking for global bounds that\n     /// aren't true.\n+    #[instrument(level = \"debug\", skip(self))]\n     fn check_false_global_bounds(&mut self) {\n         let tcx = self.ocx.infcx.tcx;\n         let mut span = self.span;"}, {"sha": "3e7a6c3c54895661a36619f7b2ecb48d76823693", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -1816,6 +1816,7 @@ pub fn get_infer_ret_ty<'hir>(output: &'hir hir::FnRetTy<'hir>) -> Option<&'hir\n     None\n }\n \n+#[instrument(level = \"debug\", skip(tcx))]\n fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n     use rustc_hir::Node::*;\n     use rustc_hir::*;\n@@ -2046,8 +2047,8 @@ fn early_bound_lifetimes_from_generics<'a, 'tcx: 'a>(\n /// Returns a list of type predicates for the definition with ID `def_id`, including inferred\n /// lifetime constraints. This includes all predicates returned by `explicit_predicates_of`, plus\n /// inferred constraints concerning which regions outlive other regions.\n+#[instrument(level = \"debug\", skip(tcx))]\n fn predicates_defined_on(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicates<'_> {\n-    debug!(\"predicates_defined_on({:?})\", def_id);\n     let mut result = tcx.explicit_predicates_of(def_id);\n     debug!(\"predicates_defined_on: explicit_predicates_of({:?}) = {:?}\", def_id, result,);\n     let inferred_outlives = tcx.inferred_outlives_of(def_id);"}, {"sha": "3e8d023fb551cbfd65ec426708927478326d064a", "filename": "compiler/rustc_typeck/src/outlives/utils.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Futils.rs?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -161,12 +161,6 @@ fn is_free_region(region: Region<'_>) -> bool {\n         // ignore it.  We can't put it on the struct header anyway.\n         ty::ReLateBound(..) => false,\n \n-        // This can appear in `where Self: ` bounds (#64855):\n-        //\n-        //     struct Bar<T>(<Self as Foo>::Type) where Self: ;\n-        //     struct Baz<'a>(&'a Self) where Self: ;\n-        ty::ReEmpty(_) => false,\n-\n         // These regions don't appear in types from type declarations:\n         ty::ReErased | ty::ReVar(..) | ty::RePlaceholder(..) | ty::ReFree(..) => {\n             bug!(\"unexpected region in outlives inference: {:?}\", region);"}, {"sha": "840f0c978484ddbff0e7de70b9f161fe50e48769", "filename": "compiler/rustc_typeck/src/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -411,11 +411,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 // way early-bound regions do, so we skip them here.\n             }\n \n-            ty::ReFree(..)\n-            | ty::ReVar(..)\n-            | ty::RePlaceholder(..)\n-            | ty::ReEmpty(_)\n-            | ty::ReErased => {\n+            ty::ReFree(..) | ty::ReVar(..) | ty::RePlaceholder(..) | ty::ReErased => {\n                 // We don't expect to see anything but 'static or bound\n                 // regions when visiting member types or method types.\n                 bug!("}, {"sha": "9f0b7018af5f000fa8c8bf0ef4f913b2a4410a02", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -250,7 +250,6 @@ pub(crate) fn clean_middle_region<'tcx>(region: ty::Region<'tcx>) -> Option<Life\n         | ty::ReFree(..)\n         | ty::ReVar(..)\n         | ty::RePlaceholder(..)\n-        | ty::ReEmpty(_)\n         | ty::ReErased => {\n             debug!(\"cannot clean region {:?}\", region);\n             None\n@@ -347,10 +346,6 @@ fn clean_region_outlives_predicate<'tcx>(\n ) -> Option<WherePredicate> {\n     let ty::OutlivesPredicate(a, b) = pred;\n \n-    if a.is_empty() && b.is_empty() {\n-        return None;\n-    }\n-\n     Some(WherePredicate::RegionPredicate {\n         lifetime: clean_middle_region(a).expect(\"failed to clean lifetime\"),\n         bounds: vec![GenericBound::Outlives(\n@@ -365,10 +360,6 @@ fn clean_type_outlives_predicate<'tcx>(\n ) -> Option<WherePredicate> {\n     let ty::OutlivesPredicate(ty, lt) = pred;\n \n-    if lt.is_empty() {\n-        return None;\n-    }\n-\n     Some(WherePredicate::BoundPredicate {\n         ty: clean_middle_ty(ty, cx, None),\n         bounds: vec![GenericBound::Outlives("}, {"sha": "0ab9d712d9f695daba0fb93b0d9f18000cbe52f2", "filename": "src/test/mir-opt/nll/named_lifetimes_basic.use_x.nll.0.mir", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed_lifetimes_basic.use_x.nll.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed_lifetimes_basic.use_x.nll.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed_lifetimes_basic.use_x.nll.0.mir?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -13,28 +13,27 @@\n | '_#2r | U0 | {bb0[0..=1], '_#2r}\n | '_#3r | U0 | {bb0[0..=1], '_#3r}\n | '_#4r | U0 | {bb0[0..=1], '_#4r}\n-| '_#5r | U0 | {}\n-| '_#6r | U0 | {bb0[0..=1], '_#1r}\n-| '_#7r | U0 | {bb0[0..=1], '_#2r}\n-| '_#8r | U0 | {bb0[0..=1], '_#1r}\n-| '_#9r | U0 | {bb0[0..=1], '_#3r}\n+| '_#5r | U0 | {bb0[0..=1], '_#1r}\n+| '_#6r | U0 | {bb0[0..=1], '_#2r}\n+| '_#7r | U0 | {bb0[0..=1], '_#1r}\n+| '_#8r | U0 | {bb0[0..=1], '_#3r}\n |\n | Inference Constraints\n | '_#0r live at {bb0[0..=1]}\n | '_#1r live at {bb0[0..=1]}\n | '_#2r live at {bb0[0..=1]}\n | '_#3r live at {bb0[0..=1]}\n | '_#4r live at {bb0[0..=1]}\n-| '_#1r: '_#6r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:26: 12:27) ($DIR/named-lifetimes-basic.rs:12:26: 12:27 (#0)\n-| '_#1r: '_#8r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:54: 12:55) ($DIR/named-lifetimes-basic.rs:12:54: 12:55 (#0)\n-| '_#2r: '_#7r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:42: 12:43) ($DIR/named-lifetimes-basic.rs:12:42: 12:43 (#0)\n-| '_#3r: '_#9r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:66: 12:67) ($DIR/named-lifetimes-basic.rs:12:66: 12:67 (#0)\n-| '_#6r: '_#1r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:26: 12:27) ($DIR/named-lifetimes-basic.rs:12:26: 12:27 (#0)\n-| '_#7r: '_#2r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:42: 12:43) ($DIR/named-lifetimes-basic.rs:12:42: 12:43 (#0)\n-| '_#8r: '_#1r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:54: 12:55) ($DIR/named-lifetimes-basic.rs:12:54: 12:55 (#0)\n-| '_#9r: '_#3r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:66: 12:67) ($DIR/named-lifetimes-basic.rs:12:66: 12:67 (#0)\n+| '_#1r: '_#5r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:26: 12:27) ($DIR/named-lifetimes-basic.rs:12:26: 12:27 (#0)\n+| '_#1r: '_#7r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:54: 12:55) ($DIR/named-lifetimes-basic.rs:12:54: 12:55 (#0)\n+| '_#2r: '_#6r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:42: 12:43) ($DIR/named-lifetimes-basic.rs:12:42: 12:43 (#0)\n+| '_#3r: '_#8r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:66: 12:67) ($DIR/named-lifetimes-basic.rs:12:66: 12:67 (#0)\n+| '_#5r: '_#1r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:26: 12:27) ($DIR/named-lifetimes-basic.rs:12:26: 12:27 (#0)\n+| '_#6r: '_#2r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:42: 12:43) ($DIR/named-lifetimes-basic.rs:12:42: 12:43 (#0)\n+| '_#7r: '_#1r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:54: 12:55) ($DIR/named-lifetimes-basic.rs:12:54: 12:55 (#0)\n+| '_#8r: '_#3r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:66: 12:67) ($DIR/named-lifetimes-basic.rs:12:66: 12:67 (#0)\n |\n-fn use_x(_1: &'_#6r mut i32, _2: &'_#7r u32, _3: &'_#8r u32, _4: &'_#9r u32) -> bool {\n+fn use_x(_1: &'_#5r mut i32, _2: &'_#6r u32, _3: &'_#7r u32, _4: &'_#8r u32) -> bool {\n     debug w => _1;                       // in scope 0 at $DIR/named-lifetimes-basic.rs:+0:26: +0:27\n     debug x => _2;                       // in scope 0 at $DIR/named-lifetimes-basic.rs:+0:42: +0:43\n     debug y => _3;                       // in scope 0 at $DIR/named-lifetimes-basic.rs:+0:54: +0:55"}, {"sha": "36705d18e016155f80d5b1ba254751f8978362e0", "filename": "src/test/mir-opt/nll/region_subtyping_basic.main.nll.0.32bit.mir", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/src%2Ftest%2Fmir-opt%2Fnll%2Fregion_subtyping_basic.main.nll.0.32bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/src%2Ftest%2Fmir-opt%2Fnll%2Fregion_subtyping_basic.main.nll.0.32bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion_subtyping_basic.main.nll.0.32bit.mir?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -7,19 +7,18 @@\n | Inferred Region Values\n | '_#0r | U0 | {bb0[0..=8], bb1[0..=7], bb2[0..=3], bb3[0..=3], bb4[0..=1], bb5[0..=2], bb6[0..=5], bb7[0], '_#0r, '_#1r}\n | '_#1r | U0 | {bb0[0..=8], bb1[0..=7], bb2[0..=3], bb3[0..=3], bb4[0..=1], bb5[0..=2], bb6[0..=5], bb7[0], '_#1r}\n-| '_#2r | U0 | {}\n-| '_#3r | U0 | {bb1[0..=7], bb2[0..=2]}\n-| '_#4r | U0 | {bb1[1..=7], bb2[0..=2]}\n-| '_#5r | U0 | {bb1[4..=7], bb2[0..=2]}\n+| '_#2r | U0 | {bb1[0..=7], bb2[0..=2]}\n+| '_#3r | U0 | {bb1[1..=7], bb2[0..=2]}\n+| '_#4r | U0 | {bb1[4..=7], bb2[0..=2]}\n |\n | Inference Constraints\n | '_#0r live at {bb0[0..=8], bb1[0..=7], bb2[0..=3], bb3[0..=3], bb4[0..=1], bb5[0..=2], bb6[0..=5], bb7[0]}\n | '_#1r live at {bb0[0..=8], bb1[0..=7], bb2[0..=3], bb3[0..=3], bb4[0..=1], bb5[0..=2], bb6[0..=5], bb7[0]}\n-| '_#3r live at {bb1[0]}\n-| '_#4r live at {bb1[1..=3]}\n-| '_#5r live at {bb1[4..=7], bb2[0..=2]}\n-| '_#3r: '_#4r due to Assignment at Single(bb1[0]) ($DIR/region-subtyping-basic.rs:18:13: 18:18 (#0)\n-| '_#4r: '_#5r due to Assignment at Single(bb1[3]) ($DIR/region-subtyping-basic.rs:19:13: 19:14 (#0)\n+| '_#2r live at {bb1[0]}\n+| '_#3r live at {bb1[1..=3]}\n+| '_#4r live at {bb1[4..=7], bb2[0..=2]}\n+| '_#2r: '_#3r due to Assignment at Single(bb1[0]) ($DIR/region-subtyping-basic.rs:18:13: 18:18 (#0)\n+| '_#3r: '_#4r due to Assignment at Single(bb1[3]) ($DIR/region-subtyping-basic.rs:19:13: 19:14 (#0)\n |\n fn main() -> () {\n     let mut _0: ();                      // return place in scope 0 at $DIR/region-subtyping-basic.rs:+0:11: +0:11\n@@ -33,10 +32,10 @@ fn main() -> () {\n     let _10: bool;                       // in scope 0 at $DIR/region-subtyping-basic.rs:+7:9: +7:18\n     scope 1 {\n         debug v => _1;                   // in scope 1 at $DIR/region-subtyping-basic.rs:+1:9: +1:14\n-        let _2: &'_#4r usize;            // in scope 1 at $DIR/region-subtyping-basic.rs:+2:9: +2:10\n+        let _2: &'_#3r usize;            // in scope 1 at $DIR/region-subtyping-basic.rs:+2:9: +2:10\n         scope 2 {\n             debug p => _2;               // in scope 2 at $DIR/region-subtyping-basic.rs:+2:9: +2:10\n-            let _6: &'_#5r usize;        // in scope 2 at $DIR/region-subtyping-basic.rs:+3:9: +3:10\n+            let _6: &'_#4r usize;        // in scope 2 at $DIR/region-subtyping-basic.rs:+3:9: +3:10\n             scope 3 {\n                 debug q => _6;           // in scope 3 at $DIR/region-subtyping-basic.rs:+3:9: +3:10\n             }\n@@ -56,7 +55,7 @@ fn main() -> () {\n     }\n \n     bb1: {\n-        _2 = &'_#3r _1[_3];              // bb1[0]: scope 1 at $DIR/region-subtyping-basic.rs:+2:13: +2:18\n+        _2 = &'_#2r _1[_3];              // bb1[0]: scope 1 at $DIR/region-subtyping-basic.rs:+2:13: +2:18\n         FakeRead(ForLet(None), _2);      // bb1[1]: scope 1 at $DIR/region-subtyping-basic.rs:+2:9: +2:10\n         StorageLive(_6);                 // bb1[2]: scope 2 at $DIR/region-subtyping-basic.rs:+3:9: +3:10\n         _6 = _2;                         // bb1[3]: scope 2 at $DIR/region-subtyping-basic.rs:+3:13: +3:14"}, {"sha": "4f6256a67f46f4aa2cacd39c4acb9acab8117e66", "filename": "src/test/mir-opt/nll/region_subtyping_basic.main.nll.0.64bit.mir", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/src%2Ftest%2Fmir-opt%2Fnll%2Fregion_subtyping_basic.main.nll.0.64bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/src%2Ftest%2Fmir-opt%2Fnll%2Fregion_subtyping_basic.main.nll.0.64bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion_subtyping_basic.main.nll.0.64bit.mir?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -7,19 +7,18 @@\n | Inferred Region Values\n | '_#0r | U0 | {bb0[0..=8], bb1[0..=7], bb2[0..=3], bb3[0..=3], bb4[0..=1], bb5[0..=2], bb6[0..=5], bb7[0], '_#0r, '_#1r}\n | '_#1r | U0 | {bb0[0..=8], bb1[0..=7], bb2[0..=3], bb3[0..=3], bb4[0..=1], bb5[0..=2], bb6[0..=5], bb7[0], '_#1r}\n-| '_#2r | U0 | {}\n-| '_#3r | U0 | {bb1[0..=7], bb2[0..=2]}\n-| '_#4r | U0 | {bb1[1..=7], bb2[0..=2]}\n-| '_#5r | U0 | {bb1[4..=7], bb2[0..=2]}\n+| '_#2r | U0 | {bb1[0..=7], bb2[0..=2]}\n+| '_#3r | U0 | {bb1[1..=7], bb2[0..=2]}\n+| '_#4r | U0 | {bb1[4..=7], bb2[0..=2]}\n |\n | Inference Constraints\n | '_#0r live at {bb0[0..=8], bb1[0..=7], bb2[0..=3], bb3[0..=3], bb4[0..=1], bb5[0..=2], bb6[0..=5], bb7[0]}\n | '_#1r live at {bb0[0..=8], bb1[0..=7], bb2[0..=3], bb3[0..=3], bb4[0..=1], bb5[0..=2], bb6[0..=5], bb7[0]}\n-| '_#3r live at {bb1[0]}\n-| '_#4r live at {bb1[1..=3]}\n-| '_#5r live at {bb1[4..=7], bb2[0..=2]}\n-| '_#3r: '_#4r due to Assignment at Single(bb1[0]) ($DIR/region-subtyping-basic.rs:18:13: 18:18 (#0)\n-| '_#4r: '_#5r due to Assignment at Single(bb1[3]) ($DIR/region-subtyping-basic.rs:19:13: 19:14 (#0)\n+| '_#2r live at {bb1[0]}\n+| '_#3r live at {bb1[1..=3]}\n+| '_#4r live at {bb1[4..=7], bb2[0..=2]}\n+| '_#2r: '_#3r due to Assignment at Single(bb1[0]) ($DIR/region-subtyping-basic.rs:18:13: 18:18 (#0)\n+| '_#3r: '_#4r due to Assignment at Single(bb1[3]) ($DIR/region-subtyping-basic.rs:19:13: 19:14 (#0)\n |\n fn main() -> () {\n     let mut _0: ();                      // return place in scope 0 at $DIR/region-subtyping-basic.rs:+0:11: +0:11\n@@ -33,10 +32,10 @@ fn main() -> () {\n     let _10: bool;                       // in scope 0 at $DIR/region-subtyping-basic.rs:+7:9: +7:18\n     scope 1 {\n         debug v => _1;                   // in scope 1 at $DIR/region-subtyping-basic.rs:+1:9: +1:14\n-        let _2: &'_#4r usize;            // in scope 1 at $DIR/region-subtyping-basic.rs:+2:9: +2:10\n+        let _2: &'_#3r usize;            // in scope 1 at $DIR/region-subtyping-basic.rs:+2:9: +2:10\n         scope 2 {\n             debug p => _2;               // in scope 2 at $DIR/region-subtyping-basic.rs:+2:9: +2:10\n-            let _6: &'_#5r usize;        // in scope 2 at $DIR/region-subtyping-basic.rs:+3:9: +3:10\n+            let _6: &'_#4r usize;        // in scope 2 at $DIR/region-subtyping-basic.rs:+3:9: +3:10\n             scope 3 {\n                 debug q => _6;           // in scope 3 at $DIR/region-subtyping-basic.rs:+3:9: +3:10\n             }\n@@ -56,7 +55,7 @@ fn main() -> () {\n     }\n \n     bb1: {\n-        _2 = &'_#3r _1[_3];              // bb1[0]: scope 1 at $DIR/region-subtyping-basic.rs:+2:13: +2:18\n+        _2 = &'_#2r _1[_3];              // bb1[0]: scope 1 at $DIR/region-subtyping-basic.rs:+2:13: +2:18\n         FakeRead(ForLet(None), _2);      // bb1[1]: scope 1 at $DIR/region-subtyping-basic.rs:+2:9: +2:10\n         StorageLive(_6);                 // bb1[2]: scope 2 at $DIR/region-subtyping-basic.rs:+3:9: +3:10\n         _6 = _2;                         // bb1[3]: scope 2 at $DIR/region-subtyping-basic.rs:+3:13: +3:14"}, {"sha": "8e10e70f192d20b91f6747f4af8a96a471e93f1d", "filename": "src/test/mir-opt/storage_ranges.main.nll.0.mir", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/src%2Ftest%2Fmir-opt%2Fstorage_ranges.main.nll.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/src%2Ftest%2Fmir-opt%2Fstorage_ranges.main.nll.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fstorage_ranges.main.nll.0.mir?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -7,16 +7,15 @@\n | Inferred Region Values\n | '_#0r | U0 | {bb0[0..=22], '_#0r, '_#1r}\n | '_#1r | U0 | {bb0[0..=22], '_#1r}\n-| '_#2r | U0 | {}\n-| '_#3r | U0 | {bb0[10..=11]}\n-| '_#4r | U0 | {bb0[11]}\n+| '_#2r | U0 | {bb0[10..=11]}\n+| '_#3r | U0 | {bb0[11]}\n |\n | Inference Constraints\n | '_#0r live at {bb0[0..=22]}\n | '_#1r live at {bb0[0..=22]}\n-| '_#3r live at {bb0[10]}\n-| '_#4r live at {bb0[11]}\n-| '_#3r: '_#4r due to Assignment at Single(bb0[10]) ($DIR/storage_ranges.rs:6:17: 6:25 (#0)\n+| '_#2r live at {bb0[10]}\n+| '_#3r live at {bb0[11]}\n+| '_#2r: '_#3r due to Assignment at Single(bb0[10]) ($DIR/storage_ranges.rs:6:17: 6:25 (#0)\n |\n fn main() -> () {\n     let mut _0: ();                      // return place in scope 0 at $DIR/storage_ranges.rs:+0:11: +0:11"}, {"sha": "3ab7c66d11f2fbf1ac8efdc21e682d652ccd69a2", "filename": "src/test/ui/closures/print/closure-print-generic-verbose-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/src%2Ftest%2Fui%2Fclosures%2Fprint%2Fclosure-print-generic-verbose-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/src%2Ftest%2Fui%2Fclosures%2Fprint%2Fclosure-print-generic-verbose-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fprint%2Fclosure-print-generic-verbose-1.stderr?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -2,7 +2,7 @@ error[E0382]: use of moved value: `c`\n   --> $DIR/closure-print-generic-verbose-1.rs:17:5\n    |\n LL |     let c = to_fn_once(move|| {\n-   |         - move occurs because `c` has type `[f<T>::{closure#0} closure_kind_ty=i32 closure_sig_as_fn_ptr_ty=extern \"rust-call\" fn(()) upvar_tys=(Foo<&'_#10r str>, T)]`, which does not implement the `Copy` trait\n+   |         - move occurs because `c` has type `[f<T>::{closure#0} closure_kind_ty=i32 closure_sig_as_fn_ptr_ty=extern \"rust-call\" fn(()) upvar_tys=(Foo<&'_#9r str>, T)]`, which does not implement the `Copy` trait\n ...\n LL |     c();\n    |     --- `c` moved due to this call"}, {"sha": "296131111e83476e1ae170b6d9ca90342a0bdab1", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-no-bound.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -46,7 +46,7 @@ LL | |     });\n    | |______`cell_a` escapes the function body here\n    |        argument requires that `'a` must outlive `'static`\n    |\n-   = note: requirement occurs because of the type `Cell<&'_#10r u32>`, which makes the generic argument `&'_#10r u32` invariant\n+   = note: requirement occurs because of the type `Cell<&'_#9r u32>`, which makes the generic argument `&'_#9r u32` invariant\n    = note: the struct `Cell<T>` is invariant over the parameter `T`\n    = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n "}, {"sha": "96a1bd1f07b65bb8ac269526d5ee2dcff8b9905d", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-wrong-bound.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -46,7 +46,7 @@ LL | |     });\n    | |______`cell_a` escapes the function body here\n    |        argument requires that `'a` must outlive `'static`\n    |\n-   = note: requirement occurs because of the type `Cell<&'_#11r u32>`, which makes the generic argument `&'_#11r u32` invariant\n+   = note: requirement occurs because of the type `Cell<&'_#10r u32>`, which makes the generic argument `&'_#10r u32` invariant\n    = note: the struct `Cell<T>` is invariant over the parameter `T`\n    = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n "}, {"sha": "060037ed496910f714e114d130bf25b9f0af1f93", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2287107588d92889d282e6cd3c1ca5df34cd34a5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2287107588d92889d282e6cd3c1ca5df34cd34a5/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=2287107588d92889d282e6cd3c1ca5df34cd34a5", "patch": "@@ -173,7 +173,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                 (\n                     preds.iter().any(|t| cx.tcx.is_diagnostic_item(sym::Borrow, t.def_id())),\n                     !preds.is_empty() && {\n-                        let ty_empty_region = cx.tcx.mk_imm_ref(cx.tcx.lifetimes.re_root_empty, ty);\n+                        let ty_empty_region = cx.tcx.mk_imm_ref(cx.tcx.lifetimes.re_erased, ty);\n                         preds.iter().all(|t| {\n                             let ty_params = t.trait_ref.substs.iter().skip(1).collect::<Vec<_>>();\n                             implements_trait(cx, ty_empty_region, t.def_id(), &ty_params)"}]}