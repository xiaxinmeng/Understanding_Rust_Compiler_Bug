{"sha": "3291218f476ab5e7d4603212cff91f8435046046", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyOTEyMThmNDc2YWI1ZTdkNDYwMzIxMmNmZjkxZjg0MzUwNDYwNDY=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-07-07T15:56:26Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-07-21T22:54:05Z"}, "message": "Improve caching during trait evaluation\n\nPreviously, we would 'forget' that we had `'static` regions in some\nplace during trait evaluation. This lead to us producing\n`EvaluatedToOkModuloRegions` when we could have produced\n`EvaluatedToOk`, causing us to perform unnecessary work.\n\nThis PR preserves `'static` regions when we canonicalize a predicate for\n`evaluate_obligation`, and when we 'freshen' a predicate during trait\nevaluation. Thie ensures that evaluating a predicate containing\n`'static` regions can produce `EvaluatedToOk` (assuming that we\ndon't end up introducing any region dependencies during evaluation).\n\nBuilding off of this improved caching, we use\n`predicate_must_hold_considering_regions` during fulfillment of\nprojection predicates to see if we can skip performing additional work.\nWe already do this for trait predicates, but doing this for projection\npredicates lead to mixed performance results without the above caching\nimprovements.", "tree": {"sha": "0c56ed01b7dc446e5b765c839ed301fd71719665", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c56ed01b7dc446e5b765c839ed301fd71719665"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3291218f476ab5e7d4603212cff91f8435046046", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAmD4pY8ACgkQtAh+UQ6Y\nsWR/NQ//frOhKlX1s5UnBF6xgPWkMHzcx1XQPikZ6IedI/wMxv9EdPgXmgerr4t9\nfTE7995Z7w3e0NKovcGpvgB83c4UQ3i2nOUds/pZYn3F1/7B1XdjBOxBrql8Tgr6\nyr6okKWHQ9tubDEwncuJLvK4tgxdQ7tJ39/ZtGztPp0s9m4SJivbLPhVU/5XEmlx\ngr07NckMHrsSMu8r6xhlXmW90Bms+trJvpE8SruhMLpE6NNF5o8jP2RD0U7EW3iY\nRP5gRRdfE2e9AiFbCFpHhdzu52Zb1lF5rzpTERyr4f+YPqpndsQwinyway+LndUg\nii1Di2DW4Chyoe/w/YxpOMOsiJWg0BUBEp8VAv8ZEkw7yhTRF10NJTC7a8eqaDDu\n3EyMCRkUcDKcmQyqmRvhSGJ0suKFoZnnWGYG20tDP5Ju/hY8lB1cf+614No7K0PE\nrxgWsVCO7SzkwdyeXI+4e4oAeOIpFZQz3Z9sRjvzIkyiwZKtGX9O1gYXVkXxpLql\n685RNTwxC2f4FaEqq4q7SZqCo/5Bnbi1TvbIN5YK/VACrxdDiz/WeOkKW6neZLEZ\nD5L/j+xA5nWNdMiYdWwfFIWYoJyopwkytyzG98UDI7gwjhopjbOqU3tbuvNA1y/Z\nqqMi45tOhw7QIP8DCuwN2M8VBCcKB4JpyWCquOvDI/UZzzEsWjs=\n=iCbO\n-----END PGP SIGNATURE-----", "payload": "tree 0c56ed01b7dc446e5b765c839ed301fd71719665\nparent 32c9b7b091534f6d80e7e85da0cd425acb6c9a79\nauthor Aaron Hill <aa1ronham@gmail.com> 1625673386 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1626908045 -0500\n\nImprove caching during trait evaluation\n\nPreviously, we would 'forget' that we had `'static` regions in some\nplace during trait evaluation. This lead to us producing\n`EvaluatedToOkModuloRegions` when we could have produced\n`EvaluatedToOk`, causing us to perform unnecessary work.\n\nThis PR preserves `'static` regions when we canonicalize a predicate for\n`evaluate_obligation`, and when we 'freshen' a predicate during trait\nevaluation. Thie ensures that evaluating a predicate containing\n`'static` regions can produce `EvaluatedToOk` (assuming that we\ndon't end up introducing any region dependencies during evaluation).\n\nBuilding off of this improved caching, we use\n`predicate_must_hold_considering_regions` during fulfillment of\nprojection predicates to see if we can skip performing additional work.\nWe already do this for trait predicates, but doing this for projection\npredicates lead to mixed performance results without the above caching\nimprovements.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3291218f476ab5e7d4603212cff91f8435046046", "html_url": "https://github.com/rust-lang/rust/commit/3291218f476ab5e7d4603212cff91f8435046046", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3291218f476ab5e7d4603212cff91f8435046046/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32c9b7b091534f6d80e7e85da0cd425acb6c9a79", "url": "https://api.github.com/repos/rust-lang/rust/commits/32c9b7b091534f6d80e7e85da0cd425acb6c9a79", "html_url": "https://github.com/rust-lang/rust/commit/32c9b7b091534f6d80e7e85da0cd425acb6c9a79"}], "stats": {"total": 77, "additions": 49, "deletions": 28}, "files": [{"sha": "448dd6623482cf67f6fbddc93c5921a64b4d4d87", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3291218f476ab5e7d4603212cff91f8435046046/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3291218f476ab5e7d4603212cff91f8435046046/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=3291218f476ab5e7d4603212cff91f8435046046", "patch": "@@ -102,20 +102,11 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         )\n     }\n \n-    /// A hacky variant of `canonicalize_query` that does not\n-    /// canonicalize `'static`. Unfortunately, the existing leak\n-    /// check treats `'static` differently in some cases (see also\n-    /// #33684), so if we are performing an operation that may need to\n-    /// prove \"leak-check\" related things, we leave `'static`\n-    /// alone.\n-    ///\n-    /// `'static` is also special cased when winnowing candidates when\n-    /// selecting implementation candidates, so we also have to leave `'static`\n-    /// alone for queries that do selection.\n-    //\n-    // FIXME(#48536): once the above issues are resolved, we can remove this\n-    // and just use `canonicalize_query`.\n-    pub fn canonicalize_hr_query_hack<V>(\n+    /// A variant of `canonicalize_query` that does not\n+    /// canonicalize `'static`. This is useful when\n+    /// the query implementation can perform more efficient\n+    /// handling of `'static` regions (e.g. trait evaluation).\n+    pub fn canonicalize_query_keep_static<V>(\n         &self,\n         value: V,\n         query_state: &mut OriginalQueryValues<'tcx>,"}, {"sha": "4af1bdf97a773f7e9796b857d02ce31ff6f24b32", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3291218f476ab5e7d4603212cff91f8435046046/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3291218f476ab5e7d4603212cff91f8435046046/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=3291218f476ab5e7d4603212cff91f8435046046", "patch": "@@ -47,16 +47,18 @@ pub struct TypeFreshener<'a, 'tcx> {\n     const_freshen_count: u32,\n     ty_freshen_map: FxHashMap<ty::InferTy, Ty<'tcx>>,\n     const_freshen_map: FxHashMap<ty::InferConst<'tcx>, &'tcx ty::Const<'tcx>>,\n+    keep_static: bool,\n }\n \n impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> TypeFreshener<'a, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>, keep_static: bool) -> TypeFreshener<'a, 'tcx> {\n         TypeFreshener {\n             infcx,\n             ty_freshen_count: 0,\n             const_freshen_count: 0,\n             ty_freshen_map: Default::default(),\n             const_freshen_map: Default::default(),\n+            keep_static,\n         }\n     }\n \n@@ -124,8 +126,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                 r\n             }\n \n-            ty::ReStatic\n-            | ty::ReEarlyBound(..)\n+            ty::ReEarlyBound(..)\n             | ty::ReFree(_)\n             | ty::ReVar(_)\n             | ty::RePlaceholder(..)\n@@ -134,6 +135,13 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                 // replace all free regions with 'erased\n                 self.tcx().lifetimes.re_erased\n             }\n+            ty::ReStatic => {\n+                if self.keep_static {\n+                    r\n+                } else {\n+                    self.tcx().lifetimes.re_erased\n+                }\n+            }\n         }\n     }\n "}, {"sha": "d3bfb2b2e4428090a07ea433f4f8de16598929ba", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3291218f476ab5e7d4603212cff91f8435046046/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3291218f476ab5e7d4603212cff91f8435046046/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=3291218f476ab5e7d4603212cff91f8435046046", "patch": "@@ -646,7 +646,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn freshener<'b>(&'b self) -> TypeFreshener<'b, 'tcx> {\n-        freshen::TypeFreshener::new(self)\n+        freshen::TypeFreshener::new(self, false)\n+    }\n+\n+    /// Like `freshener`, but does not replace `'static` regions.\n+    pub fn freshener_keep_static<'b>(&'b self) -> TypeFreshener<'b, 'tcx> {\n+        freshen::TypeFreshener::new(self, true)\n     }\n \n     pub fn type_is_unconstrained_numeric(&'a self, ty: Ty<'_>) -> UnconstrainedNumeric {"}, {"sha": "9ec1dd5c2ee3b302efd8c64613476c1c8b4a5820", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3291218f476ab5e7d4603212cff91f8435046046/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3291218f476ab5e7d4603212cff91f8435046046/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=3291218f476ab5e7d4603212cff91f8435046046", "patch": "@@ -365,6 +365,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                     let project_obligation = obligation.with(binder.rebind(data));\n \n                     self.process_projection_obligation(\n+                        obligation,\n                         project_obligation,\n                         &mut pending_obligation.stalled_on,\n                     )\n@@ -419,6 +420,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                     let project_obligation = obligation.with(Binder::dummy(*data));\n \n                     self.process_projection_obligation(\n+                        obligation,\n                         project_obligation,\n                         &mut pending_obligation.stalled_on,\n                     )\n@@ -666,10 +668,22 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n \n     fn process_projection_obligation(\n         &mut self,\n+        obligation: &PredicateObligation<'tcx>,\n         project_obligation: PolyProjectionObligation<'tcx>,\n         stalled_on: &mut Vec<TyOrConstInferVar<'tcx>>,\n     ) -> ProcessResult<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>> {\n         let tcx = self.selcx.tcx();\n+\n+        if obligation.predicate.is_global() {\n+            // no type variables present, can use evaluation for better caching.\n+            // FIXME: consider caching errors too.\n+            if self.selcx.infcx().predicate_must_hold_considering_regions(obligation) {\n+                return ProcessResult::Changed(vec![]);\n+            } else {\n+                tracing::debug!(\"Does NOT hold: {:?}\", obligation);\n+            }\n+        }\n+\n         match project::poly_project_and_unify_type(self.selcx, &project_obligation) {\n             Ok(Ok(Some(os))) => ProcessResult::Changed(mk_pending(os)),\n             Ok(Ok(None)) => {"}, {"sha": "2dc48e47efccdf6a9e150b8e3e88b844a82422ea", "filename": "compiler/rustc_trait_selection/src/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3291218f476ab5e7d4603212cff91f8435046046/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3291218f476ab5e7d4603212cff91f8435046046/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=3291218f476ab5e7d4603212cff91f8435046046", "patch": "@@ -64,8 +64,10 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n         let mut _orig_values = OriginalQueryValues::default();\n-        let c_pred = self\n-            .canonicalize_query(obligation.param_env.and(obligation.predicate), &mut _orig_values);\n+        let c_pred = self.canonicalize_query_keep_static(\n+            obligation.param_env.and(obligation.predicate),\n+            &mut _orig_values,\n+        );\n         // Run canonical query. If overflow occurs, rerun from scratch but this time\n         // in standard trait query mode so that overflow is handled appropriately\n         // within `SelectionContext`."}, {"sha": "3f6efa03b3a28b27694bab4c2743c857285f10ac", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3291218f476ab5e7d4603212cff91f8435046046/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3291218f476ab5e7d4603212cff91f8435046046/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=3291218f476ab5e7d4603212cff91f8435046046", "patch": "@@ -180,7 +180,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                 // so we cannot canonicalize it.\n                 let c_data = self\n                     .infcx\n-                    .canonicalize_hr_query_hack(self.param_env.and(data), &mut orig_values);\n+                    .canonicalize_query_keep_static(self.param_env.and(data), &mut orig_values);\n                 debug!(\"QueryNormalizer: c_data = {:#?}\", c_data);\n                 debug!(\"QueryNormalizer: orig_values = {:#?}\", orig_values);\n                 match tcx.normalize_projection_ty(c_data) {\n@@ -249,7 +249,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                 // so we cannot canonicalize it.\n                 let c_data = self\n                     .infcx\n-                    .canonicalize_hr_query_hack(self.param_env.and(data), &mut orig_values);\n+                    .canonicalize_query_keep_static(self.param_env.and(data), &mut orig_values);\n                 debug!(\"QueryNormalizer: c_data = {:#?}\", c_data);\n                 debug!(\"QueryNormalizer: orig_values = {:#?}\", orig_values);\n                 let normalized_ty = match tcx.normalize_projection_ty(c_data) {"}, {"sha": "fbff86618ade3172f15be2bbeb0259685ea84a8c", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3291218f476ab5e7d4603212cff91f8435046046/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3291218f476ab5e7d4603212cff91f8435046046/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=3291218f476ab5e7d4603212cff91f8435046046", "patch": "@@ -77,12 +77,13 @@ pub trait QueryTypeOp<'tcx>: fmt::Debug + Sized + TypeFoldable<'tcx> + 'tcx {\n         }\n \n         // FIXME(#33684) -- We need to use\n-        // `canonicalize_hr_query_hack` here because of things\n+        // `canonicalize_query_keep_static` here because of things\n         // like the subtype query, which go awry around\n         // `'static` otherwise.\n         let mut canonical_var_values = OriginalQueryValues::default();\n         let old_param_env = query_key.param_env;\n-        let canonical_self = infcx.canonicalize_hr_query_hack(query_key, &mut canonical_var_values);\n+        let canonical_self =\n+            infcx.canonicalize_query_keep_static(query_key, &mut canonical_var_values);\n         let canonical_result = Self::perform_query(infcx.tcx, canonical_self)?;\n \n         let InferOk { value, obligations } = infcx"}, {"sha": "95611ebc8188cfe54fc6a0258bd29d8e00ee7a35", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3291218f476ab5e7d4603212cff91f8435046046/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3291218f476ab5e7d4603212cff91f8435046046/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=3291218f476ab5e7d4603212cff91f8435046046", "patch": "@@ -216,7 +216,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>) -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx,\n-            freshener: infcx.freshener(),\n+            freshener: infcx.freshener_keep_static(),\n             intercrate: false,\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls: false,\n@@ -227,7 +227,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'tcx>) -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx,\n-            freshener: infcx.freshener(),\n+            freshener: infcx.freshener_keep_static(),\n             intercrate: true,\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls: false,\n@@ -242,7 +242,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(?allow_negative_impls, \"with_negative\");\n         SelectionContext {\n             infcx,\n-            freshener: infcx.freshener(),\n+            freshener: infcx.freshener_keep_static(),\n             intercrate: false,\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls,\n@@ -257,7 +257,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(?query_mode, \"with_query_mode\");\n         SelectionContext {\n             infcx,\n-            freshener: infcx.freshener(),\n+            freshener: infcx.freshener_keep_static(),\n             intercrate: false,\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls: false,"}]}