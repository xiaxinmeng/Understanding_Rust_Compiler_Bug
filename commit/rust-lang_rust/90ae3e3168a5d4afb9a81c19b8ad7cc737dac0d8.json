{"sha": "90ae3e3168a5d4afb9a81c19b8ad7cc737dac0d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwYWUzZTMxNjhhNWQ0YWZiOWE4MWMxOWI4YWQ3Y2M3MzdkYWMwZDg=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-12-30T23:10:55Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-12-30T23:10:55Z"}, "message": "Document copy/move/swap/assign expressions more accurately. Fix up some drift on log docs.", "tree": {"sha": "b5cd941bc740d634ed4ae67782a2b924fab4656b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5cd941bc740d634ed4ae67782a2b924fab4656b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90ae3e3168a5d4afb9a81c19b8ad7cc737dac0d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90ae3e3168a5d4afb9a81c19b8ad7cc737dac0d8", "html_url": "https://github.com/rust-lang/rust/commit/90ae3e3168a5d4afb9a81c19b8ad7cc737dac0d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90ae3e3168a5d4afb9a81c19b8ad7cc737dac0d8/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "468ced3868e96d428808a67d4b9503648dd2d84e", "url": "https://api.github.com/repos/rust-lang/rust/commits/468ced3868e96d428808a67d4b9503648dd2d84e", "html_url": "https://github.com/rust-lang/rust/commit/468ced3868e96d428808a67d4b9503648dd2d84e"}], "stats": {"total": 154, "additions": 121, "deletions": 33}, "files": [{"sha": "98891018b10aa9b7cc882b76acf7e4cedec89334", "filename": "doc/rust.texi", "status": "modified", "additions": 120, "deletions": 32, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/90ae3e3168a5d4afb9a81c19b8ad7cc737dac0d8/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/90ae3e3168a5d4afb9a81c19b8ad7cc737dac0d8/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=90ae3e3168a5d4afb9a81c19b8ad7cc737dac0d8", "patch": "@@ -1701,12 +1701,14 @@ import std::option::*;\n import std::str::@{char_at, hash@};\n \n fn main() @{\n-    // Equivalent to 'log std::math::sin(1.0);'\n-    log sin(1.0);\n-    // Equivalent to 'log std::option::some(1.0);'\n-    log some(1.0);\n-    // Equivalent to 'log std::str::hash(std::str::char_at(\"foo\"));'\n-    log hash(char_at(\"foo\"));\n+    // Equivalent to 'log(info, std::math::sin(1.0));'\n+    log(info, sin(1.0));\n+\n+    // Equivalent to 'log(info, std::option::some(1.0));'\n+    log(info, some(1.0));\n+\n+    // Equivalent to 'log(info, std::str::hash(std::str::char_at(\"foo\")));'\n+    log(info, hash(char_at(\"foo\")));\n @}\n @end example\n \n@@ -1801,7 +1803,7 @@ A special kind of function can be declared with a @code{!} character where the\n output slot type would normally be. For example:\n @example\n fn my_err(s: str) -> ! @{\n-    log s;\n+    log(info, s);\n     fail;\n @}\n @end example\n@@ -2767,6 +2769,9 @@ effects of the expression's evaluation.\n \n @menu\n * Ref.Expr.Copy::               Expression for copying a value.\n+* Ref.Expr.Move::               Expression for moving a value.\n+* Ref.Expr.Swap::               Expression for swapping two values.\n+* Ref.Expr.Assign::             Expression for moving a copy of a value.\n * Ref.Expr.Call::               Expression for calling a function.\n * Ref.Expr.Bind::               Expression for binding arguments to functions.\n * Ref.Expr.Ret::                Expression for stopping and producing a value.\n@@ -2788,43 +2793,125 @@ effects of the expression's evaluation.\n * Ref.Expr.AnonObj::            Expression for extending objects with additional methods.\n @end menu\n \n-\n @node       Ref.Expr.Copy\n @subsection Ref.Expr.Copy\n @c * Ref.Expr.Copy::                Expression for copying a value.\n @cindex Copy expression\n-@cindex Assignment operator, see @i{Copy expression}\n+@cindex Copy operator, see @i{Move expression}\n \n-A @dfn{copy expression} consists of an @emph{lval} followed by an equals-sign\n-(@code{=}) and a primitive expression. @xref{Ref.Expr}.\n+A unary @dfn{copy expression} consists of the unary @code{copy} operator\n+applied to some argument expression.\n \n-Executing a copy expression causes the value denoted by the expression --\n-either a value or a primitive combination of values -- to be copied into the\n-memory location denoted by the @emph{lval}.\n+Evaluating a copy expression first evaluates the argument expression, then\n+performs a copy of the resulting value, allocating any memory necessary to\n+hold the new copy.\n \n-A copy may entail the adjustment of reference counts, execution of destructors,\n-or similar adjustments in order to respect the path through the memory graph\n-implied by the @code{lval}, as well as any existing value held in the memory\n-being written-to. All such adjustment is automatic and implied by the @code{=}\n-operator.\n+Shared boxes (type @code{@@}) are, as usual, shallow-copied, as they may be\n+cyclic. Unique boxes, vectors and similar unique types are deep-copied.\n \n-An example of three different copy expressions:\n+Since the assignment operator @code{=} performs a copy implicitly, the unary\n+copy operator is typically only used to cause an argument to a function should\n+be copied, and the copy passed by-value. @xref{Ref.Expr.Assign}.\n+\n+An example of a copy expression:\n @example\n-x = y;\n-x.y = z;\n-x.y = z + 2;\n+fn mutate(vec: [mutable int]) @{\n+   vec[0] = 10;\n+@}\n+\n+let v = [mutable 1,2,3];\n+\n+mutate(copy v);   // Pass a copy\n+\n+assert v[0] == 1; // Original was not modified\n @end example\n \n+\n+@node       Ref.Expr.Move\n+@subsection Ref.Expr.Move\n+@c * Ref.Expr.Move::                Expression for moving a value.\n+@cindex Move expression\n+@cindex Move operator, see @i{Move expression}\n+\n+A @dfn{move experssion} consists of an @emph{lval} followed by a left-pointing\n+arrow (@code{<-}) and an @emph{rval} expression. @xref{Ref.Expr}.\n+\n+Evaluating a move expression causes, as a side effect, the @emph{rval} to be\n+@emph{moved} into the @emph{lval}. If the @emph{rval} was itself an @emph{lval},\n+it must be a local variable, as it will be de-initialized in the process.\n+\n+Evaluating a move expression does not effect reference counts nor does it\n+cause a deep copy of any unique structure pointed-to by the moved\n+@emph{rval}. Instead, the move expression represents an indivisible\n+@emph{transfer of ownership} from the right-hand-side to the left-hand-side of\n+the expression. No allocation or destruction is entailed.\n+\n+An example of three different move expressions:\n+@example\n+x <- a;\n+x[i] <- b;\n+x.y <- c;\n+@end example\n+\n+\n+@node       Ref.Expr.Swap\n+@subsection Ref.Expr.Swap\n+@c * Ref.Expr.Swap::                Expression for swapping two values.\n+@cindex Swap expression\n+@cindex Swap operator, see @i{Move expression}\n+\n+A @dfn{swap experssion} consists of an @emph{lval} followed by a bi-directional\n+arrow (@code{<->}) and another @emph{lval} expression. @xref{Ref.Expr}.\n+\n+Evaluating a swap expression causes, as a side effect, the vales held in the\n+left-hand-side and right-hand-side @emph{lvals} to be exchanged indivisibly.\n+\n+Evaluating a move expression does not effect reference counts nor does it\n+cause a deep copy of any unique structure pointed-to by the moved\n+@emph{rval}. Instead, the move expression represents an indivisible\n+@emph{exchange of ownership} between the right-hand-side to the left-hand-side\n+of the expression. No allocation or destruction is entailed.\n+\n+An example of three different swap expressions:\n+@example\n+x <-> a;\n+x[i] <-> b[i];\n+x.y <-> a.b;\n+@end example\n+\n+\n+@node       Ref.Expr.Assign\n+@subsection Ref.Expr.Assign\n+@c * Ref.Expr.Copy::                Expression for moving a copy of a value.\n+@cindex Assignment expression\n+@cindex Assignment operator, see @i{Assignment expression}\n+\n+An @dfn{assignment expression} consists of an @emph{lval} expression followed\n+by an equals-sign (@code{=}) and an @emph{rval} expression. @xref{Ref.Expr}.\n+\n+Evaluating an assignment expression is equivalent to evaluating a move\n+expression combined with a unary copy expression. For example, the following\n+two expressions have the same effect:\n+\n+@example\n+x = y\n+x <- copy y\n+@end example\n+\n+The former is simply more terse and familiar. @xref{Ref.Expr.Copy},\n+@xref{Ref.Expr.Move}.\n+\n+\n @node       Ref.Expr.Call\n @subsection Ref.Expr.Call\n @c * Ref.Expr.Call::               Expression for calling a function.\n @cindex Call expression\n @cindex Function calls\n \n A @dfn{call expression} invokes a function, providing a tuple of input slots\n-and an reference slot to serve as the function's output, bound to the @var{lval}\n-on the right hand side of the call. If the function eventually returns, then\n-the expression completes.\n+and a reference slot to serve as the function's output, bound to the\n+@var{lval} on the right hand side of the call. If the function eventually\n+returns, then the expression completes.\n \n A call expression statically requires that the precondition declared in the\n callee's signature is satisfied by the expression prestate. In this way,\n@@ -3222,7 +3309,7 @@ fn main() @{\n         choose_player(r)\n       @}\n       @{player: p, options: @{size: \"small\", _@}, _@} @{\n-        log p + \" is small\";\n+        log(info, p + \" is small\");\n       @}\n       _ @{\n         next_player();\n@@ -3445,7 +3532,7 @@ expressions can be enabled per module.\n \n Logging output is enabled by setting the @code{RUST_LOG} environment variable.\n @code{RUST_LOG} accepts a logging specification that is a comma-separated list\n-of paths. For each module containing log statements, if @code{RUST_LOG}\n+of paths. For each module containing log expressions, if @code{RUST_LOG}\n contains the path to that module or a parent of that module, then its logs\n will be output to the console. The path to an module consists of the crate\n name, any parent modules, then the module itself, all separated by double\n@@ -3457,13 +3544,14 @@ As an example, to see all the logs generated by the compiler, you would set\n just crate resolution, you would set it to @code{rustc::metadata::creader}.\n \n Note that when compiling either .rs or .rc files that don't specifiy a crate\n-name the crate is given a default name that matches the source file, sans\n-extension. In that case, to turn on logging for a program compiled from, e.g.\n-helloworld.rs, @code{RUST_LOG} should be set to @code{helloworld}.\n+name the crate is given a default name that matches the source file, with the\n+extension removed. In that case, to turn on logging for a program compiled\n+from, e.g. @code{helloworld.rs}, @code{RUST_LOG} should be set to\n+@code{helloworld}.\n \n As a convenience, the logging spec can also be set to a special psuedo-crate,\n @code{::help}. In this case, when the application starts, the runtime will\n-simply output a list of loaded modules containing log statements, then exit.\n+simply output a list of loaded modules containing log expressions, then exit.\n \n The Rust runtime itself generates logging information. The runtime's logs are\n generated for a number of artificial modules in the @code{::rt} psuedo-crate,"}, {"sha": "bf41413de3b3c2df3308e388f13a69862b910f2b", "filename": "mk/docs.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90ae3e3168a5d4afb9a81c19b8ad7cc737dac0d8/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/90ae3e3168a5d4afb9a81c19b8ad7cc737dac0d8/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=90ae3e3168a5d4afb9a81c19b8ad7cc737dac0d8", "patch": "@@ -52,7 +52,7 @@ GENERATED += nd/$(1)/Languages.txt \\\n              nd/$(1)/Menu.txt \\\n              nd/$(1)/Data\n \n-DOCS += nd/$(1)/index.html nd/$(1)/lib.css\n+DOCS += doc/$(1)/index.html nd/$(1)/lib.css\n \n endef\n "}]}