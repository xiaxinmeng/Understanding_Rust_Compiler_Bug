{"sha": "159e27aebb940926ccf1bad0b2b12087d36ad903", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1OWUyN2FlYmI5NDA5MjZjY2YxYmFkMGIyYjEyMDg3ZDM2YWQ5MDM=", "commit": {"author": {"name": "Cameron Zwarich", "email": "zwarich@mozilla.com", "date": "2014-06-14T03:48:09Z"}, "committer": {"name": "Cameron Zwarich", "email": "zwarich@mozilla.com", "date": "2014-06-14T03:48:09Z"}, "message": "Fix all violations of stronger guarantees for mutable borrows\n\nFix all violations in the Rust source tree of the stronger guarantee\nof a unique access path for mutable borrows as described in #12624.", "tree": {"sha": "fcbd53189c2eba87584deebc8ce5512d9534f6de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fcbd53189c2eba87584deebc8ce5512d9534f6de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/159e27aebb940926ccf1bad0b2b12087d36ad903", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/159e27aebb940926ccf1bad0b2b12087d36ad903", "html_url": "https://github.com/rust-lang/rust/commit/159e27aebb940926ccf1bad0b2b12087d36ad903", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/159e27aebb940926ccf1bad0b2b12087d36ad903/comments", "author": null, "committer": null, "parents": [{"sha": "036833ece95aa5fc9a1110c5691488193138eb8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/036833ece95aa5fc9a1110c5691488193138eb8f", "html_url": "https://github.com/rust-lang/rust/commit/036833ece95aa5fc9a1110c5691488193138eb8f"}], "stats": {"total": 319, "additions": 206, "deletions": 113}, "files": [{"sha": "34264aa1b814565d6644c524cfb8a98c6d741a91", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=159e27aebb940926ccf1bad0b2b12087d36ad903", "patch": "@@ -406,7 +406,8 @@ impl<T> TypedArenaChunk<T> {\n             None => {}\n             Some(mut next) => {\n                 // We assume that the next chunk is completely filled.\n-                next.destroy(next.capacity)\n+                let capacity = next.capacity;\n+                next.destroy(capacity)\n             }\n         }\n     }"}, {"sha": "29edf1db51d704a4469b18808e08188dcc6cd86f", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=159e27aebb940926ccf1bad0b2b12087d36ad903", "patch": "@@ -66,7 +66,8 @@ impl<T> Deque<T> for RingBuf<T> {\n \n     /// Return a mutable reference to the last element in the RingBuf\n     fn back_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n-        if self.nelts > 0 { Some(self.get_mut(self.nelts - 1)) } else { None }\n+        let nelts = self.nelts;\n+        if nelts > 0 { Some(self.get_mut(nelts - 1)) } else { None }\n     }\n \n     /// Remove and return the first element in the RingBuf, or None if it is empty"}, {"sha": "61e732846a1a3db6f0e43d5ec3129ef2af2610f2", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=159e27aebb940926ccf1bad0b2b12087d36ad903", "patch": "@@ -114,7 +114,8 @@ impl<T> Vec<T> {\n         unsafe {\n             let mut xs = Vec::with_capacity(length);\n             while xs.len < length {\n-                ptr::write(xs.as_mut_slice().unsafe_mut_ref(xs.len), op(xs.len));\n+                let len = xs.len;\n+                ptr::write(xs.as_mut_slice().unsafe_mut_ref(len), op(len));\n                 xs.len += 1;\n             }\n             xs\n@@ -210,7 +211,8 @@ impl<T: Clone> Vec<T> {\n         unsafe {\n             let mut xs = Vec::with_capacity(length);\n             while xs.len < length {\n-                ptr::write(xs.as_mut_slice().unsafe_mut_ref(xs.len),\n+                let len = xs.len;\n+                ptr::write(xs.as_mut_slice().unsafe_mut_ref(len),\n                            value.clone());\n                 xs.len += 1;\n             }\n@@ -321,9 +323,10 @@ impl<T:Clone> Clone for Vec<T> {\n             let this_slice = self.as_slice();\n             while vector.len < len {\n                 unsafe {\n+                    let len = vector.len;\n                     ptr::write(\n-                        vector.as_mut_slice().unsafe_mut_ref(vector.len),\n-                        this_slice.unsafe_ref(vector.len).clone());\n+                        vector.as_mut_slice().unsafe_mut_ref(len),\n+                        this_slice.unsafe_ref(len).clone());\n                 }\n                 vector.len += 1;\n             }"}, {"sha": "83eb4adfa9759605640b9e607f790f1f1fdb477f", "filename": "src/libdebug/repr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibdebug%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibdebug%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Frepr.rs?ref=159e27aebb940926ccf1bad0b2b12087d36ad903", "patch": "@@ -127,13 +127,15 @@ impl<'a> ReprVisitor<'a> {\n     #[inline]\n     pub fn get<T>(&mut self, f: |&mut ReprVisitor, &T| -> bool) -> bool {\n         unsafe {\n-            f(self, mem::transmute::<*u8,&T>(self.ptr))\n+            let ptr = self.ptr;\n+            f(self, mem::transmute::<*u8,&T>(ptr))\n         }\n     }\n \n     #[inline]\n     pub fn visit_inner(&mut self, inner: *TyDesc) -> bool {\n-        self.visit_ptr_inner(self.ptr, inner)\n+        let ptr = self.ptr;\n+        self.visit_ptr_inner(ptr, inner)\n     }\n \n     #[inline]"}, {"sha": "1c33114dc71739d90ee385cc60a4ce79aa27ab98", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=159e27aebb940926ccf1bad0b2b12087d36ad903", "patch": "@@ -637,16 +637,15 @@ impl rtio::RtioUdpSocket for UdpSocket {\n                 mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n \n         let dolock = || self.lock_nonblocking();\n-        let doread = |nb| unsafe {\n+        let n = try!(read(fd, self.read_deadline, dolock, |nb| unsafe {\n             let flags = if nb {c::MSG_DONTWAIT} else {0};\n             libc::recvfrom(fd,\n                            buf.as_mut_ptr() as *mut libc::c_void,\n                            buf.len() as msglen_t,\n                            flags,\n                            storagep,\n                            &mut addrlen) as libc::c_int\n-        };\n-        let n = try!(read(fd, self.read_deadline, dolock, doread));\n+        }));\n         sockaddr_to_addr(&storage, addrlen as uint).and_then(|addr| {\n             Ok((n as uint, addr))\n         })"}, {"sha": "cedc40df300b604c0f6f6e7c3e282df9c577d48d", "filename": "src/libregex/parse/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibregex%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibregex%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse%2Fmod.rs?ref=159e27aebb940926ccf1bad0b2b12087d36ad903", "patch": "@@ -345,18 +345,19 @@ impl<'a> Parser<'a> {\n     }\n \n     fn push_literal(&mut self, c: char) -> Result<(), Error> {\n+        let flags = self.flags;\n         match c {\n             '.' => {\n-                self.push(Dot(self.flags))\n+                self.push(Dot(flags))\n             }\n             '^' => {\n-                self.push(Begin(self.flags))\n+                self.push(Begin(flags))\n             }\n             '$' => {\n-                self.push(End(self.flags))\n+                self.push(End(flags))\n             }\n             _ => {\n-                self.push(Literal(c, self.flags))\n+                self.push(Literal(c, flags))\n             }\n         }\n         Ok(())"}, {"sha": "bc083dac6ac7512b77d49d56496c57e5577aa38a", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=159e27aebb940926ccf1bad0b2b12087d36ad903", "patch": "@@ -300,12 +300,13 @@ impl<'a, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, O> {\n         }\n \n         {\n+            let words_per_id = self.words_per_id;\n             let mut propcx = PropagationContext {\n                 dfcx: &mut *self,\n                 changed: true\n             };\n \n-            let mut temp = Vec::from_elem(self.words_per_id, 0u);\n+            let mut temp = Vec::from_elem(words_per_id, 0u);\n             let mut loop_scopes = Vec::new();\n \n             while propcx.changed {"}, {"sha": "cd876113807a973acd94f122686f72def9f9bf02", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=159e27aebb940926ccf1bad0b2b12087d36ad903", "patch": "@@ -547,11 +547,13 @@ struct Liveness<'a> {\n \n impl<'a> Liveness<'a> {\n     fn new(ir: &'a mut IrMaps<'a>, specials: Specials) -> Liveness<'a> {\n+        let num_live_nodes = ir.num_live_nodes;\n+        let num_vars = ir.num_vars;\n         Liveness {\n             ir: ir,\n             s: specials,\n-            successors: Vec::from_elem(ir.num_live_nodes, invalid_node()),\n-            users: Vec::from_elem(ir.num_live_nodes * ir.num_vars, invalid_users()),\n+            successors: Vec::from_elem(num_live_nodes, invalid_node()),\n+            users: Vec::from_elem(num_live_nodes * num_vars, invalid_users()),\n             loop_scope: Vec::new(),\n             break_ln: NodeMap::new(),\n             cont_ln: NodeMap::new(),\n@@ -826,8 +828,9 @@ impl<'a> Liveness<'a> {\n \n         debug!(\"compute: using id for block, {}\", block_to_str(body));\n \n+        let exit_ln = self.s.exit_ln;\n         let entry_ln: LiveNode =\n-            self.with_loop_nodes(body.id, self.s.exit_ln, self.s.exit_ln,\n+            self.with_loop_nodes(body.id, exit_ln, exit_ln,\n               |this| this.propagate_through_fn_block(decl, body));\n \n         // hack to skip the loop unless debug! is enabled:\n@@ -847,12 +850,13 @@ impl<'a> Liveness<'a> {\n                                   -> LiveNode {\n         // the fallthrough exit is only for those cases where we do not\n         // explicitly return:\n-        self.init_from_succ(self.s.fallthrough_ln, self.s.exit_ln);\n+        let s = self.s;\n+        self.init_from_succ(s.fallthrough_ln, s.exit_ln);\n         if blk.expr.is_none() {\n-            self.acc(self.s.fallthrough_ln, self.s.no_ret_var, ACC_READ)\n+            self.acc(s.fallthrough_ln, s.no_ret_var, ACC_READ)\n         }\n \n-        self.propagate_through_block(blk, self.s.fallthrough_ln)\n+        self.propagate_through_block(blk, s.fallthrough_ln)\n     }\n \n     fn propagate_through_block(&mut self, blk: &Block, succ: LiveNode)\n@@ -1036,7 +1040,8 @@ impl<'a> Liveness<'a> {\n \n           ExprRet(o_e) => {\n             // ignore succ and subst exit_ln:\n-            self.propagate_through_opt_expr(o_e, self.s.exit_ln)\n+            let exit_ln = self.s.exit_ln;\n+            self.propagate_through_opt_expr(o_e, exit_ln)\n           }\n \n           ExprBreak(opt_label) => {"}, {"sha": "112ecd66f4cc9023c418b2027b16ac49ce8beb9e", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=159e27aebb940926ccf1bad0b2b12087d36ad903", "patch": "@@ -1019,9 +1019,10 @@ impl<'a> Visitor<()> for SanePrivacyVisitor<'a> {\n             self.check_sane_privacy(item);\n         }\n \n+        let in_fn = self.in_fn;\n         let orig_in_fn = replace(&mut self.in_fn, match item.node {\n             ast::ItemMod(..) => false, // modules turn privacy back on\n-            _ => self.in_fn,           // otherwise we inherit\n+            _ => in_fn,           // otherwise we inherit\n         });\n         visit::walk_item(self, item, ());\n         self.in_fn = orig_in_fn;"}, {"sha": "ca7596925a9cbd706033af708f71e4efe4b911e5", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=159e27aebb940926ccf1bad0b2b12087d36ad903", "patch": "@@ -202,7 +202,8 @@ impl<'a, 'b> Context<'a, 'b> {\n             }\n             parse::CountIsNextParam => {\n                 if self.check_positional_ok() {\n-                    self.verify_arg_type(Exact(self.next_arg), Unsigned);\n+                    let next_arg = self.next_arg;\n+                    self.verify_arg_type(Exact(next_arg), Unsigned);\n                     self.next_arg += 1;\n                 }\n             }"}, {"sha": "c9122e3ceafb5e253b11d9a0243995b5c8b18c9a", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=159e27aebb940926ccf1bad0b2b12087d36ad903", "patch": "@@ -73,7 +73,8 @@ impl<'a> ParserAttr for Parser<'a> {\n \n                 let style = if self.eat(&token::NOT) {\n                     if !permit_inner {\n-                        self.span_err(self.span,\n+                        let span = self.span;\n+                        self.span_err(span,\n                                       \"an inner attribute is not permitted in \\\n                                        this context\");\n                     }"}, {"sha": "f7eac0b323f7eee74040619760ef2042dca6218f", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 54, "deletions": 28, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=159e27aebb940926ccf1bad0b2b12087d36ad903", "patch": "@@ -368,7 +368,8 @@ impl<'a> StringReader<'a> {\n                 } else {\n                     \"unterminated block comment\"\n                 };\n-                self.fatal_span(start_bpos, self.last_pos, msg);\n+                let last_bpos = self.last_pos;\n+                self.fatal_span(start_bpos, last_bpos, msg);\n             } else if self.curr_is('/') && self.nextch_is('*') {\n                 level += 1;\n                 self.bump();\n@@ -419,7 +420,8 @@ impl<'a> StringReader<'a> {\n                 rslt.push_str(exponent.as_slice());\n                 return Some(rslt);\n             } else {\n-                self.err_span(start_bpos, self.last_pos, \"scan_exponent: bad fp literal\");\n+                let last_bpos = self.last_pos;\n+                self.err_span(start_bpos, last_bpos, \"scan_exponent: bad fp literal\");\n                 rslt.push_str(\"1\"); // arbitrary placeholder exponent\n                 return Some(rslt);\n             }\n@@ -506,14 +508,16 @@ impl<'a> StringReader<'a> {\n                           else { Unsigned(ast::TyU64) };\n             }\n             if num_str.len() == 0u {\n-                self.err_span(start_bpos, self.last_pos, \"no valid digits found for number\");\n+                let last_bpos = self.last_pos;\n+                self.err_span(start_bpos, last_bpos, \"no valid digits found for number\");\n                 num_str = \"1\".to_string();\n             }\n             let parsed = match from_str_radix::<u64>(num_str.as_slice(),\n                                                      base as uint) {\n                 Some(p) => p,\n                 None => {\n-                    self.err_span(start_bpos, self.last_pos, \"int literal is too large\");\n+                    let last_bpos = self.last_pos;\n+                    self.err_span(start_bpos, last_bpos, \"int literal is too large\");\n                     1\n                 }\n             };\n@@ -546,13 +550,15 @@ impl<'a> StringReader<'a> {\n             if c == '3' && n == '2' {\n                 self.bump();\n                 self.bump();\n-                self.check_float_base(start_bpos, self.last_pos, base);\n+                let last_bpos = self.last_pos;\n+                self.check_float_base(start_bpos, last_bpos, base);\n                 return token::LIT_FLOAT(str_to_ident(num_str.as_slice()),\n                                         ast::TyF32);\n             } else if c == '6' && n == '4' {\n                 self.bump();\n                 self.bump();\n-                self.check_float_base(start_bpos, self.last_pos, base);\n+                let last_bpos = self.last_pos;\n+                self.check_float_base(start_bpos, last_bpos, base);\n                 return token::LIT_FLOAT(str_to_ident(num_str.as_slice()),\n                                         ast::TyF64);\n                 /* FIXME (#2252): if this is out of range for either a\n@@ -562,25 +568,30 @@ impl<'a> StringReader<'a> {\n                 self.bump();\n                 self.bump();\n                 self.bump();\n-                self.check_float_base(start_bpos, self.last_pos, base);\n+                let last_bpos = self.last_pos;\n+                self.check_float_base(start_bpos, last_bpos, base);\n                 return token::LIT_FLOAT(str_to_ident(num_str.as_slice()), ast::TyF128);\n             }\n-            self.err_span(start_bpos, self.last_pos, \"expected `f32`, `f64` or `f128` suffix\");\n+            let last_bpos = self.last_pos;\n+            self.err_span(start_bpos, last_bpos, \"expected `f32`, `f64` or `f128` suffix\");\n         }\n         if is_float {\n-            self.check_float_base(start_bpos, self.last_pos, base);\n+            let last_bpos = self.last_pos;\n+            self.check_float_base(start_bpos, last_bpos, base);\n             return token::LIT_FLOAT_UNSUFFIXED(str_to_ident(\n                     num_str.as_slice()));\n         } else {\n             if num_str.len() == 0u {\n-                self.err_span(start_bpos, self.last_pos, \"no valid digits found for number\");\n+                let last_bpos = self.last_pos;\n+                self.err_span(start_bpos, last_bpos, \"no valid digits found for number\");\n                 num_str = \"1\".to_string();\n             }\n             let parsed = match from_str_radix::<u64>(num_str.as_slice(),\n                                                      base as uint) {\n                 Some(p) => p,\n                 None => {\n-                    self.err_span(start_bpos, self.last_pos, \"int literal is too large\");\n+                    let last_bpos = self.last_pos;\n+                    self.err_span(start_bpos, last_bpos, \"int literal is too large\");\n                     1\n                 }\n             };\n@@ -597,10 +608,12 @@ impl<'a> StringReader<'a> {\n         let start_bpos = self.last_pos;\n         for _ in range(0, n_hex_digits) {\n             if self.is_eof() {\n-                self.fatal_span(start_bpos, self.last_pos, \"unterminated numeric character escape\");\n+                let last_bpos = self.last_pos;\n+                self.fatal_span(start_bpos, last_bpos, \"unterminated numeric character escape\");\n             }\n             if self.curr_is(delim) {\n-                self.err_span(start_bpos, self.last_pos, \"numeric character escape is too short\");\n+                let last_bpos = self.last_pos;\n+                self.err_span(start_bpos, last_bpos, \"numeric character escape is too short\");\n                 break;\n             }\n             let c = self.curr.unwrap_or('\\x00');\n@@ -616,7 +629,8 @@ impl<'a> StringReader<'a> {\n         match char::from_u32(accum_int) {\n             Some(x) => x,\n             None => {\n-                self.err_span(start_bpos, self.last_pos, \"illegal numeric character escape\");\n+                let last_bpos = self.last_pos;\n+                self.err_span(start_bpos, last_bpos, \"illegal numeric character escape\");\n                 '?'\n             }\n         }\n@@ -773,17 +787,18 @@ impl<'a> StringReader<'a> {\n                     });\n                 let keyword_checking_token =\n                     &token::IDENT(keyword_checking_ident, false);\n+                let last_bpos = self.last_pos;\n                 if token::is_keyword(token::keywords::Self,\n                                      keyword_checking_token) {\n                     self.err_span(start,\n-                                  self.last_pos,\n+                                  last_bpos,\n                                   \"invalid lifetime name: 'self \\\n                                    is no longer a special lifetime\");\n                 } else if token::is_any_keyword(keyword_checking_token) &&\n                     !token::is_keyword(token::keywords::Static,\n                                        keyword_checking_token) {\n                     self.err_span(start,\n-                                  self.last_pos,\n+                                  last_bpos,\n                                   \"invalid lifetime name\");\n                 }\n                 return token::LIFETIME(ident);\n@@ -811,7 +826,8 @@ impl<'a> StringReader<'a> {\n                                 'u' => self.scan_numeric_escape(4u, '\\''),\n                                 'U' => self.scan_numeric_escape(8u, '\\''),\n                                 c2 => {\n-                                    self.err_span_char(escaped_pos, self.last_pos,\n+                                    let last_bpos = self.last_pos;\n+                                    self.err_span_char(escaped_pos, last_bpos,\n                                                          \"unknown character escape\", c2);\n                                     c2\n                                 }\n@@ -820,17 +836,19 @@ impl<'a> StringReader<'a> {\n                     }\n                 }\n                 '\\t' | '\\n' | '\\r' | '\\'' => {\n-                    self.err_span_char( start, self.last_pos,\n+                    let last_bpos = self.last_pos;\n+                    self.err_span_char( start, last_bpos,\n                         \"character constant must be escaped\", c2);\n                 }\n                 _ => {}\n             }\n             if !self.curr_is('\\'') {\n+                let last_bpos = self.last_pos;\n                 self.fatal_span_verbose(\n                                    // Byte offsetting here is okay because the\n                                    // character before position `start` is an\n                                    // ascii single quote.\n-                                   start - BytePos(1), self.last_pos,\n+                                   start - BytePos(1), last_bpos,\n                                    \"unterminated character constant\".to_string());\n             }\n             self.bump(); // advance curr past token\n@@ -842,15 +860,17 @@ impl<'a> StringReader<'a> {\n             self.bump();\n             while !self.curr_is('\"') {\n                 if self.is_eof() {\n-                    self.fatal_span(start_bpos, self.last_pos, \"unterminated double quote string\");\n+                    let last_bpos = self.last_pos;\n+                    self.fatal_span(start_bpos, last_bpos, \"unterminated double quote string\");\n                 }\n \n                 let ch = self.curr.unwrap();\n                 self.bump();\n                 match ch {\n                   '\\\\' => {\n                     if self.is_eof() {\n-                        self.fatal_span(start_bpos, self.last_pos,\n+                        let last_bpos = self.last_pos;\n+                        self.fatal_span(start_bpos, last_bpos,\n                                \"unterminated double quote string\");\n                     }\n \n@@ -876,7 +896,8 @@ impl<'a> StringReader<'a> {\n                         accum_str.push_char(self.scan_numeric_escape(8u, '\"'));\n                       }\n                       c2 => {\n-                        self.err_span_char(escaped_pos, self.last_pos,\n+                        let last_bpos = self.last_pos;\n+                        self.err_span_char(escaped_pos, last_bpos,\n                                         \"unknown string escape\", c2);\n                       }\n                     }\n@@ -897,19 +918,23 @@ impl<'a> StringReader<'a> {\n             }\n \n             if self.is_eof() {\n-                self.fatal_span(start_bpos, self.last_pos, \"unterminated raw string\");\n+                let last_bpos = self.last_pos;\n+                self.fatal_span(start_bpos, last_bpos, \"unterminated raw string\");\n             } else if !self.curr_is('\"') {\n-                self.fatal_span_char(start_bpos, self.last_pos,\n+                let last_bpos = self.last_pos;\n+                let curr_char = self.curr.unwrap();\n+                self.fatal_span_char(start_bpos, last_bpos,\n                                 \"only `#` is allowed in raw string delimitation; \\\n                                  found illegal character\",\n-                                self.curr.unwrap());\n+                                curr_char);\n             }\n             self.bump();\n             let content_start_bpos = self.last_pos;\n             let mut content_end_bpos;\n             'outer: loop {\n                 if self.is_eof() {\n-                    self.fatal_span(start_bpos, self.last_pos, \"unterminated raw string\");\n+                    let last_bpos = self.last_pos;\n+                    self.fatal_span(start_bpos, last_bpos, \"unterminated raw string\");\n                 }\n                 if self.curr_is('\"') {\n                     content_end_bpos = self.last_pos;\n@@ -956,8 +981,9 @@ impl<'a> StringReader<'a> {\n           '^' => { return self.binop(token::CARET); }\n           '%' => { return self.binop(token::PERCENT); }\n           c => {\n-              self.fatal_span_char(self.last_pos, self.pos,\n-                              \"unknown start of token\", c);\n+              let last_bpos = self.last_pos;\n+              let bpos = self.pos;\n+              self.fatal_span_char(last_bpos, bpos, \"unknown start of token\", c);\n           }\n         }\n     }"}, {"sha": "250ed4af57198c38ff632bfa5d96c0707ca1061e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 102, "deletions": 55, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=159e27aebb940926ccf1bad0b2b12087d36ad903", "patch": "@@ -146,10 +146,12 @@ macro_rules! maybe_whole_expr (\n                         INTERPOLATED(token::NtPath(ref pt)) => (**pt).clone(),\n                         _ => unreachable!()\n                     };\n-                    Some($p.mk_expr($p.span.lo, $p.span.hi, ExprPath(pt)))\n+                    let span = $p.span;\n+                    Some($p.mk_expr(span.lo, span.hi, ExprPath(pt)))\n                 }\n                 INTERPOLATED(token::NtBlock(b)) => {\n-                    Some($p.mk_expr($p.span.lo, $p.span.hi, ExprBlock(b)))\n+                    let span = $p.span;\n+                    Some($p.mk_expr(span.lo, span.hi, ExprBlock(b)))\n                 }\n                 _ => None\n             };\n@@ -370,7 +372,8 @@ impl<'a> Parser<'a> {\n \n     pub fn unexpected_last(&mut self, t: &token::Token) -> ! {\n         let token_str = Parser::token_to_str(t);\n-        self.span_fatal(self.last_span, format!(\"unexpected token: `{}`\",\n+        let last_span = self.last_span;\n+        self.span_fatal(last_span, format!(\"unexpected token: `{}`\",\n                                                 token_str).as_slice());\n     }\n \n@@ -441,7 +444,8 @@ impl<'a> Parser<'a> {\n             && expected.iter().all(|t| *t != token::LBRACE)\n             && self.look_ahead(1, |t| *t == token::RBRACE) {\n             // matched; signal non-fatal error and recover.\n-            self.span_err(self.span,\n+            let span = self.span;\n+            self.span_err(span,\n                           \"unit-like struct construction is written with no trailing `{ }`\");\n             self.eat(&token::LBRACE);\n             self.eat(&token::RBRACE);\n@@ -560,7 +564,8 @@ impl<'a> Parser<'a> {\n     pub fn check_strict_keywords(&mut self) {\n         if token::is_strict_keyword(&self.token) {\n             let token_str = self.this_token_to_str();\n-            self.span_err(self.span,\n+            let span = self.span;\n+            self.span_err(span,\n                           format!(\"found `{}` in ident position\",\n                                   token_str).as_slice());\n         }\n@@ -581,8 +586,9 @@ impl<'a> Parser<'a> {\n         match self.token {\n             token::BINOP(token::AND) => self.bump(),\n             token::ANDAND => {\n-                let lo = self.span.lo + BytePos(1);\n-                self.replace_token(token::BINOP(token::AND), lo, self.span.hi)\n+                let span = self.span;\n+                let lo = span.lo + BytePos(1);\n+                self.replace_token(token::BINOP(token::AND), lo, span.hi)\n             }\n             _ => {\n                 let token_str = self.this_token_to_str();\n@@ -601,8 +607,9 @@ impl<'a> Parser<'a> {\n         match self.token {\n             token::BINOP(token::OR) => self.bump(),\n             token::OROR => {\n-                let lo = self.span.lo + BytePos(1);\n-                self.replace_token(token::BINOP(token::OR), lo, self.span.hi)\n+                let span = self.span;\n+                let lo = span.lo + BytePos(1);\n+                self.replace_token(token::BINOP(token::OR), lo, span.hi)\n             }\n             _ => {\n                 let found_token = self.this_token_to_str();\n@@ -644,8 +651,9 @@ impl<'a> Parser<'a> {\n                     _ => false,\n                 });\n                 if force || next_lifetime {\n-                    let lo = self.span.lo + BytePos(1);\n-                    self.replace_token(token::LT, lo, self.span.hi);\n+                    let span = self.span;\n+                    let lo = span.lo + BytePos(1);\n+                    self.replace_token(token::LT, lo, span.hi);\n                     true\n                 } else {\n                     false\n@@ -693,8 +701,9 @@ impl<'a> Parser<'a> {\n         match self.token {\n             token::GT => self.bump(),\n             token::BINOP(token::SHR) => {\n-                let lo = self.span.lo + BytePos(1);\n-                self.replace_token(token::GT, lo, self.span.hi)\n+                let span = self.span;\n+                let lo = span.lo + BytePos(1);\n+                self.replace_token(token::GT, lo, span.hi)\n             }\n             _ => {\n                 let gt_str = Parser::token_to_str(&token::GT);\n@@ -805,7 +814,8 @@ impl<'a> Parser<'a> {\n                                -> Vec<T> {\n         let result = self.parse_unspanned_seq(bra, ket, sep, f);\n         if result.is_empty() {\n-            self.span_err(self.last_span,\n+            let last_span = self.last_span;\n+            self.span_err(last_span,\n             \"nullary enum variants are written with no trailing `( )`\");\n         }\n         result\n@@ -1336,10 +1346,11 @@ impl<'a> Parser<'a> {\n         } else if self.token == token::TILDE {\n             // OWNED POINTER\n             self.bump();\n+            let last_span = self.last_span;\n             match self.token {\n                 token::LBRACKET =>\n-                    self.obsolete(self.last_span, ObsoleteOwnedVector),\n-                _ => self.obsolete(self.last_span, ObsoleteOwnedType),\n+                    self.obsolete(last_span, ObsoleteOwnedVector),\n+                _ => self.obsolete(last_span, ObsoleteOwnedType),\n             };\n             TyUniq(self.parse_ty(true))\n         } else if self.token == token::BINOP(token::STAR) {\n@@ -2375,17 +2386,18 @@ impl<'a> Parser<'a> {\n             let e = self.parse_prefix_expr();\n             hi = e.span.hi;\n             // HACK: turn ~[...] into a ~-vec\n+            let last_span = self.last_span;\n             ex = match e.node {\n               ExprVec(..) | ExprRepeat(..) => {\n-                  self.obsolete(self.last_span, ObsoleteOwnedVector);\n+                  self.obsolete(last_span, ObsoleteOwnedVector);\n                   ExprVstore(e, ExprVstoreUniq)\n               }\n               ExprLit(lit) if lit_is_str(lit) => {\n-                  self.obsolete(self.last_span, ObsoleteOwnedExpr);\n+                  self.obsolete(last_span, ObsoleteOwnedExpr);\n                   ExprVstore(e, ExprVstoreUniq)\n               }\n               _ => {\n-                  self.obsolete(self.last_span, ObsoleteOwnedExpr);\n+                  self.obsolete(last_span, ObsoleteOwnedExpr);\n                   self.mk_unary(UnUniq, e)\n               }\n             };\n@@ -2412,7 +2424,8 @@ impl<'a> Parser<'a> {\n             // HACK: turn `box [...]` into a boxed-vec\n             ex = match subexpression.node {\n                 ExprVec(..) | ExprRepeat(..) => {\n-                    self.obsolete(self.last_span, ObsoleteOwnedVector);\n+                    let last_span = self.last_span;\n+                    self.obsolete(last_span, ObsoleteOwnedVector);\n                     ExprVstore(subexpression, ExprVstoreUniq)\n                 }\n                 ExprLit(lit) if lit_is_str(lit) => {\n@@ -2843,8 +2856,9 @@ impl<'a> Parser<'a> {\n             self.bump();\n             let sub = self.parse_pat();\n             pat = PatBox(sub);\n-            hi = self.last_span.hi;\n-            self.obsolete(self.last_span, ObsoleteOwnedPattern);\n+            let last_span = self.last_span;\n+            hi = last_span.hi;\n+            self.obsolete(last_span, ObsoleteOwnedPattern);\n             return box(GC) ast::Pat {\n                 id: ast::DUMMY_NODE_ID,\n                 node: pat,\n@@ -3061,7 +3075,8 @@ impl<'a> Parser<'a> {\n                        binding_mode: ast::BindingMode)\n                        -> ast::Pat_ {\n         if !is_plain_ident(&self.token) {\n-            self.span_fatal(self.last_span,\n+            let last_span = self.last_span;\n+            self.span_fatal(last_span,\n                             \"expected identifier, found path\");\n         }\n         // why a path here, and not just an identifier?\n@@ -3079,8 +3094,9 @@ impl<'a> Parser<'a> {\n         // binding mode then we do not end up here, because the lookahead\n         // will direct us over to parse_enum_variant()\n         if self.token == token::LPAREN {\n+            let last_span = self.last_span;\n             self.span_fatal(\n-                self.last_span,\n+                last_span,\n                 \"expected identifier, found enum pattern\");\n         }\n \n@@ -3144,7 +3160,8 @@ impl<'a> Parser<'a> {\n         fn check_expected_item(p: &mut Parser, found_attrs: bool) {\n             // If we have attributes then we should have an item\n             if found_attrs {\n-                p.span_err(p.last_span, \"expected item after attributes\");\n+                let last_span = p.last_span;\n+                p.span_err(last_span, \"expected item after attributes\");\n             }\n         }\n \n@@ -3333,7 +3350,8 @@ impl<'a> Parser<'a> {\n             match self.token {\n                 token::SEMI => {\n                     if !attributes_box.is_empty() {\n-                        self.span_err(self.last_span, \"expected item after attributes\");\n+                        let last_span = self.last_span;\n+                        self.span_err(last_span, \"expected item after attributes\");\n                         attributes_box = Vec::new();\n                     }\n                     self.bump(); // empty\n@@ -3409,7 +3427,8 @@ impl<'a> Parser<'a> {\n         }\n \n         if !attributes_box.is_empty() {\n-            self.span_err(self.last_span, \"expected item after attributes\");\n+            let last_span = self.last_span;\n+            self.span_err(last_span, \"expected item after attributes\");\n         }\n \n         let hi = self.span.hi;\n@@ -3566,7 +3585,8 @@ impl<'a> Parser<'a> {\n                 if ty_param.default.is_some() {\n                     seen_default = true;\n                 } else if seen_default {\n-                    p.span_err(p.last_span,\n+                    let last_span = p.last_span;\n+                    p.span_err(last_span,\n                                \"type parameters with a default must be trailing\");\n                 }\n                 ty_param\n@@ -3591,7 +3611,8 @@ impl<'a> Parser<'a> {\n \n     fn forbid_lifetime(&mut self) {\n         if Parser::token_is_lifetime(&self.token) {\n-            self.span_fatal(self.span, \"lifetime parameters must be declared \\\n+            let span = self.span;\n+            self.span_fatal(span, \"lifetime parameters must be declared \\\n                                         prior to type parameters\");\n         }\n     }\n@@ -3609,11 +3630,13 @@ impl<'a> Parser<'a> {\n                         p.bump();\n                         if allow_variadic {\n                             if p.token != token::RPAREN {\n-                                p.span_fatal(p.span,\n+                                let span = p.span;\n+                                p.span_fatal(span,\n                                     \"`...` must be last in argument list for variadic function\");\n                             }\n                         } else {\n-                            p.span_fatal(p.span,\n+                            let span = p.span;\n+                            p.span_fatal(span,\n                                          \"only foreign functions are allowed to be variadic\");\n                         }\n                         None\n@@ -3756,7 +3779,8 @@ impl<'a> Parser<'a> {\n                     self.parse_mutability()\n                 } else { MutImmutable };\n                 if self.is_self_ident() {\n-                    self.span_err(self.span, \"cannot pass self by unsafe pointer\");\n+                    let span = self.span;\n+                    self.span_err(span, \"cannot pass self by unsafe pointer\");\n                     self.bump();\n                 }\n                 SelfValue\n@@ -4128,15 +4152,17 @@ impl<'a> Parser<'a> {\n             token::RBRACE => {}\n             #[cfg(stage0)]\n             _ => {\n+                let span = self.span;\n                 let token_str = self.this_token_to_str();\n-                self.span_fatal(self.span,\n+                self.span_fatal(span,\n                                 format!(\"expected `,`, or `\\\\}` but found `{}`\",\n                                         token_str).as_slice())\n             }\n             #[cfg(not(stage0))]\n             _ => {\n+                let span = self.span;\n                 let token_str = self.this_token_to_str();\n-                self.span_fatal(self.span,\n+                self.span_fatal(span,\n                                 format!(\"expected `,`, or `}}` but found `{}`\",\n                                         token_str).as_slice())\n             }\n@@ -4170,7 +4196,8 @@ impl<'a> Parser<'a> {\n     fn parse_for_sized(&mut self) -> Sized {\n         if self.eat_keyword(keywords::For) {\n             if !self.eat_keyword(keywords::Type) {\n-                self.span_err(self.last_span,\n+                let last_span = self.last_span;\n+                self.span_err(last_span,\n                     \"expected 'type' after for in trait item\");\n             }\n             DynSize\n@@ -4226,7 +4253,8 @@ impl<'a> Parser<'a> {\n \n         if first && attrs_remaining_len > 0u {\n             // We parsed attributes for the first item but didn't find it\n-            self.span_err(self.last_span, \"expected item after attributes\");\n+            let last_span = self.last_span;\n+            self.span_err(last_span, \"expected item after attributes\");\n         }\n \n         ast::Mod {\n@@ -4458,7 +4486,8 @@ impl<'a> Parser<'a> {\n             foreign_items: foreign_items\n         } = self.parse_foreign_items(first_item_attrs, true);\n         if ! attrs_remaining.is_empty() {\n-            self.span_err(self.last_span,\n+            let last_span = self.last_span;\n+            self.span_err(last_span,\n                           \"expected item after attributes\");\n         }\n         assert!(self.token == token::RBRACE);\n@@ -4494,8 +4523,9 @@ impl<'a> Parser<'a> {\n                 (path, the_ident)\n             }\n             _ => {\n+                let span = self.span;\n                 let token_str = self.this_token_to_str();\n-                self.span_fatal(self.span,\n+                self.span_fatal(span,\n                                 format!(\"expected extern crate name but \\\n                                          found `{}`\",\n                                         token_str).as_slice());\n@@ -4535,8 +4565,9 @@ impl<'a> Parser<'a> {\n         let m = self.parse_foreign_mod_items(abi, next);\n         self.expect(&token::RBRACE);\n \n+        let last_span = self.last_span;\n         let item = self.mk_item(lo,\n-                                self.last_span.hi,\n+                                last_span.hi,\n                                 special_idents::invalid,\n                                 ItemForeignMod(m),\n                                 visibility,\n@@ -4663,8 +4694,9 @@ impl<'a> Parser<'a> {\n                 match abi::lookup(the_string) {\n                     Some(abi) => Some(abi),\n                     None => {\n+                        let last_span = self.last_span;\n                         self.span_err(\n-                            self.last_span,\n+                            last_span,\n                             format!(\"illegal ABI: expected one of [{}], \\\n                                      found `{}`\",\n                                     abi::all_names().connect(\", \"),\n@@ -4720,7 +4752,8 @@ impl<'a> Parser<'a> {\n \n             if next_is_mod || self.eat_keyword(keywords::Crate) {\n                 if next_is_mod {\n-                   self.span_err(mk_sp(lo, self.last_span.hi),\n+                    let last_span = self.last_span;\n+                    self.span_err(mk_sp(lo, last_span.hi),\n                                  format!(\"`extern mod` is obsolete, use \\\n                                           `extern crate` instead \\\n                                           to refer to external \\\n@@ -4736,8 +4769,9 @@ impl<'a> Parser<'a> {\n                 let abi = opt_abi.unwrap_or(abi::C);\n                 let (ident, item_, extra_attrs) =\n                     self.parse_item_fn(NormalFn, abi);\n+                let last_span = self.last_span;\n                 let item = self.mk_item(lo,\n-                                        self.last_span.hi,\n+                                        last_span.hi,\n                                         ident,\n                                         item_,\n                                         visibility,\n@@ -4747,15 +4781,17 @@ impl<'a> Parser<'a> {\n                 return self.parse_item_foreign_mod(lo, opt_abi, visibility, attrs);\n             }\n \n+            let span = self.span;\n             let token_str = self.this_token_to_str();\n-            self.span_fatal(self.span,\n+            self.span_fatal(span,\n                             format!(\"expected `{}` or `fn` but found `{}`\", \"{\",\n                                     token_str).as_slice());\n         }\n \n         let is_virtual = self.eat_keyword(keywords::Virtual);\n         if is_virtual && !self.is_keyword(keywords::Struct) {\n-            self.span_err(self.span,\n+            let span = self.span;\n+            self.span_err(span,\n                           \"`virtual` keyword may only be used with `struct`\");\n         }\n \n@@ -4764,8 +4800,9 @@ impl<'a> Parser<'a> {\n             // STATIC ITEM\n             self.bump();\n             let (ident, item_, extra_attrs) = self.parse_item_const();\n+            let last_span = self.last_span;\n             let item = self.mk_item(lo,\n-                                    self.last_span.hi,\n+                                    last_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -4778,8 +4815,9 @@ impl<'a> Parser<'a> {\n             self.bump();\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_fn(NormalFn, abi::Rust);\n+            let last_span = self.last_span;\n             let item = self.mk_item(lo,\n-                                    self.last_span.hi,\n+                                    last_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -4798,8 +4836,9 @@ impl<'a> Parser<'a> {\n             self.expect_keyword(keywords::Fn);\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_fn(UnsafeFn, abi);\n+            let last_span = self.last_span;\n             let item = self.mk_item(lo,\n-                                    self.last_span.hi,\n+                                    last_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -4810,8 +4849,9 @@ impl<'a> Parser<'a> {\n             // MODULE ITEM\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_mod(attrs.as_slice());\n+            let last_span = self.last_span;\n             let item = self.mk_item(lo,\n-                                    self.last_span.hi,\n+                                    last_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -4821,8 +4861,9 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(keywords::Type) {\n             // TYPE ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_type();\n+            let last_span = self.last_span;\n             let item = self.mk_item(lo,\n-                                    self.last_span.hi,\n+                                    last_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -4832,8 +4873,9 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(keywords::Enum) {\n             // ENUM ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_enum();\n+            let last_span = self.last_span;\n             let item = self.mk_item(lo,\n-                                    self.last_span.hi,\n+                                    last_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -4843,8 +4885,9 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(keywords::Trait) {\n             // TRAIT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_trait();\n+            let last_span = self.last_span;\n             let item = self.mk_item(lo,\n-                                    self.last_span.hi,\n+                                    last_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -4854,8 +4897,9 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(keywords::Impl) {\n             // IMPL ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_impl();\n+            let last_span = self.last_span;\n             let item = self.mk_item(lo,\n-                                    self.last_span.hi,\n+                                    last_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -4865,8 +4909,9 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(keywords::Struct) {\n             // STRUCT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_struct(is_virtual);\n+            let last_span = self.last_span;\n             let item = self.mk_item(lo,\n-                                    self.last_span.hi,\n+                                    last_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -4942,8 +4987,9 @@ impl<'a> Parser<'a> {\n                                              span: mk_sp(self.span.lo,\n                                                          self.span.hi) };\n             let item_ = ItemMac(m);\n+            let last_span = self.last_span;\n             let item = self.mk_item(lo,\n-                                    self.last_span.hi,\n+                                    last_span.hi,\n                                     id,\n                                     item_,\n                                     visibility,\n@@ -4960,7 +5006,8 @@ impl<'a> Parser<'a> {\n                 s.push_str(\"priv\")\n             }\n             s.push_char('`');\n-            self.span_fatal(self.last_span, s.as_slice());\n+            let last_span = self.last_span;\n+            self.span_fatal(last_span, s.as_slice());\n         }\n         return IoviNone(attrs);\n     }"}, {"sha": "672e08af2d8ff74dbfc411c5b7bdde7e076ccb17", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=159e27aebb940926ccf1bad0b2b12087d36ad903", "patch": "@@ -322,7 +322,8 @@ impl Printer {\n                    b.offset, self.left, self.right);\n             *self.token.get_mut(self.right) = t;\n             *self.size.get_mut(self.right) = -self.right_total;\n-            self.scan_push(self.right);\n+            let right = self.right;\n+            self.scan_push(right);\n             Ok(())\n           }\n           End => {\n@@ -334,7 +335,8 @@ impl Printer {\n                 self.advance_right();\n                 *self.token.get_mut(self.right) = t;\n                 *self.size.get_mut(self.right) = -1;\n-                self.scan_push(self.right);\n+                let right = self.right;\n+                self.scan_push(right);\n                 Ok(())\n             }\n           }\n@@ -348,7 +350,8 @@ impl Printer {\n             debug!(\"pp Break({})/buffer ~[{},{}]\",\n                    b.offset, self.left, self.right);\n             self.check_stack(0);\n-            self.scan_push(self.right);\n+            let right = self.right;\n+            self.scan_push(right);\n             *self.token.get_mut(self.right) = t;\n             *self.size.get_mut(self.right) = -self.right_total;\n             self.right_total += b.blank_space;"}, {"sha": "b49c698486450e68586e67e28f45f38b4884ad70", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159e27aebb940926ccf1bad0b2b12087d36ad903/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=159e27aebb940926ccf1bad0b2b12087d36ad903", "patch": "@@ -347,7 +347,8 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         let res = format(stack.pop().unwrap(), FormatOp::from_char(cur), *flags);\n                         if res.is_err() { return res }\n                         output.push_all(res.unwrap().as_slice());\n-                        old_state = state; // will cause state to go to Nothing\n+                        // will cause state to go to Nothing\n+                        old_state = FormatPattern(*flags, *fstate);\n                     } else { return Err(\"stack is empty\".to_string()) },\n                     (FormatStateFlags,'#') => {\n                         flags.alternate = true;"}]}