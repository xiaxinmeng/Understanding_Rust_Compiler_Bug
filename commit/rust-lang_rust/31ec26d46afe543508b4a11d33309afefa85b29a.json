{"sha": "31ec26d46afe543508b4a11d33309afefa85b29a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxZWMyNmQ0NmFmZTU0MzUwOGI0YTExZDMzMzA5YWZlZmE4NWIyOWE=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-30T10:35:19Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-30T16:36:12Z"}, "message": "Make calling resource destructors work cross-crate\n\nTydescs are currently re-created for each compilation unit (and I\nguess for structural types, they have to be, though the duplication\nstill bothers me). This means a destructor can not be inlined in the\ndrop glue for a resource type, since other crates don't have access to\nthe destructor body.\n\nDestructors are now compiled as separate functions with an external\nsymbol that can be looked up in the crate (under the resource type's\ndef_id), and called from the drop glue.", "tree": {"sha": "f6cfe84a8cf5d1f82cdb9328da4d3aaeec7d1bad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6cfe84a8cf5d1f82cdb9328da4d3aaeec7d1bad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31ec26d46afe543508b4a11d33309afefa85b29a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31ec26d46afe543508b4a11d33309afefa85b29a", "html_url": "https://github.com/rust-lang/rust/commit/31ec26d46afe543508b4a11d33309afefa85b29a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31ec26d46afe543508b4a11d33309afefa85b29a/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c36a76626badd7c8e9cf2aee75f121f2acdb749", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c36a76626badd7c8e9cf2aee75f121f2acdb749", "html_url": "https://github.com/rust-lang/rust/commit/8c36a76626badd7c8e9cf2aee75f121f2acdb749"}], "stats": {"total": 89, "additions": 60, "deletions": 29}, "files": [{"sha": "c6e85b4b19c1a72c4fb0b5a3f8d0c21a3b89ef8f", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/31ec26d46afe543508b4a11d33309afefa85b29a/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ec26d46afe543508b4a11d33309afefa85b29a/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=31ec26d46afe543508b4a11d33309afefa85b29a", "patch": "@@ -18,8 +18,8 @@ import pretty::pprust;\n export get_symbol;\n export get_tag_variants;\n export get_type;\n+export get_type_param_count;\n export lookup_defs;\n-export get_type;\n export get_crate_attributes;\n export list_crate_metadata;\n export get_exported_metadata;\n@@ -98,7 +98,7 @@ fn item_type(&ebml::doc item, int this_cnum, ty::ctxt tcx) -> ty::t {\n                       bind parse_external_def_id(this_cnum, _), tcx);\n }\n \n-fn item_ty_param_count(&ebml::doc item, int this_cnum) -> uint {\n+fn item_ty_param_count(&ebml::doc item) -> uint {\n     let uint ty_param_count = 0u;\n     auto tp = tag_items_data_item_ty_param_count;\n     for each (ebml::doc p in ebml::tagged_docs(item, tp)) {\n@@ -178,11 +178,16 @@ fn get_type(ty::ctxt tcx, ast::def_id def) -> ty::ty_param_count_and_ty {\n     auto kind_ch = item_kind(item);\n     auto has_ty_params = kind_has_type_params(kind_ch);\n     if (has_ty_params) {\n-        tp_count = item_ty_param_count(item, external_crate_id);\n+        tp_count = item_ty_param_count(item);\n     } else { tp_count = 0u; }\n     ret tup(tp_count, t);\n }\n \n+fn get_type_param_count(ty::ctxt tcx, &ast::def_id def) -> uint {\n+    auto data = tcx.sess.get_external_crate(def._0).data;\n+    ret item_ty_param_count(lookup_item(def._1, data));\n+}\n+\n fn get_symbol(session::session sess, ast::def_id def) -> str {\n     auto external_crate_id = def._0;\n     auto data = sess.get_external_crate(external_crate_id).data;"}, {"sha": "839b1ebaa950c6b137737d6e83f62aa5f6cee85d", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ec26d46afe543508b4a11d33309afefa85b29a/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ec26d46afe543508b4a11d33309afefa85b29a/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=31ec26d46afe543508b4a11d33309afefa85b29a", "patch": "@@ -282,14 +282,14 @@ fn encode_info_for_item(@crate_ctxt cx, &ebml::writer ebml_w,\n                                     tps);\n         }\n         case (item_res(_, _, ?tps, ?ctor_id)) {\n-\n             auto fn_ty = node_id_type(cx, ctor_id);\n \n             ebml::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, local_def(ctor_id));\n             encode_kind(ebml_w, 'y' as u8);\n             encode_type_param_count(ebml_w, tps);\n             encode_type(cx, ebml_w, ty::ty_fn_ret(cx.tcx, fn_ty));\n+            encode_symbol(cx, ebml_w, item.id);\n             ebml::end_tag(ebml_w);\n \n             index += [tup(ctor_id, ebml_w.writer.tell())];"}, {"sha": "2f19de9230f8371c1e3dfaf66ca91fb90e6b7d73", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 51, "deletions": 25, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/31ec26d46afe543508b4a11d33309afefa85b29a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ec26d46afe543508b4a11d33309afefa85b29a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=31ec26d46afe543508b4a11d33309afefa85b29a", "patch": "@@ -2090,15 +2090,7 @@ fn make_drop_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n             decr_refcnt_maybe_free(cx, box_cell, v0, t)\n         }\n         case (ty::ty_res(?did, ?inner)) {\n-            (alt (ccx.ast_map.get(did._1)) {\n-                case (ast_map::node_item(?i)) {\n-                    alt (i.node) {\n-                        case (ast::item_res(?dtor, _, _, _)) {\n-                            drop_res(cx, v0, inner, dtor)\n-                        }\n-                    }\n-                }\n-            })\n+            trans_res_drop(cx, v0, did, inner)\n         }\n         case (ty::ty_fn(_, _, _, _, _)) {\n             auto box_cell =\n@@ -2115,8 +2107,8 @@ fn make_drop_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n     rs.bcx.build.RetVoid();\n }\n \n-fn drop_res(@block_ctxt cx, ValueRef rs, ty::t inner_t, &ast::_fn dtor)\n-    -> result {\n+fn trans_res_drop(@block_ctxt cx, ValueRef rs, &ast::def_id did,\n+                  ty::t inner_t) -> result {\n     auto ccx = cx.fcx.lcx.ccx;\n     auto tup_ty = ty::mk_imm_tup(ccx.tcx, [ty::mk_int(ccx.tcx), inner_t]);\n     auto drop_cx = new_sub_block_ctxt(cx, \"drop res\");\n@@ -2126,12 +2118,29 @@ fn drop_res(@block_ctxt cx, ValueRef rs, ty::t inner_t, &ast::_fn dtor)\n     cx = drop_flag.bcx;\n     auto null_test = cx.build.IsNull(cx.build.Load(drop_flag.val));\n     cx.build.CondBr(null_test, next_cx.llbb, drop_cx.llbb);\n-\n     cx = drop_cx;\n-    auto val = GEP_tup_like(cx,  tup_ty, rs, [0, 1]);\n+\n+    // Find and call the actual destructor.\n+    auto dtor_pair = if (did._0 == ast::local_crate) {\n+        ccx.fn_pairs.get(did._1)\n+    } else {\n+        auto params = decoder::get_type_param_count(ccx.tcx, did);\n+        auto f_t = type_of_fn(ccx, cx.sp, ast::proto_fn,\n+                              [rec(mode=ty::mo_alias(false), ty=inner_t)],\n+                              ty::mk_nil(ccx.tcx), params);\n+        get_extern_const(ccx.externs, ccx.llmod,\n+                         decoder::get_symbol(ccx.sess, did),\n+                         T_fn_pair(ccx.tn, f_t))\n+    };\n+    auto dtor_addr = cx.build.Load\n+        (cx.build.GEP(dtor_pair, [C_int(0), C_int(abi::fn_field_code)]));\n+    auto dtor_env = cx.build.Load\n+        (cx.build.GEP(dtor_pair, [C_int(0), C_int(abi::fn_field_box)]));\n+    auto val = GEP_tup_like(cx, tup_ty, rs, [0, 1]);\n     cx = val.bcx;\n-    cx.fcx.llargs.insert(dtor.decl.inputs.(0).id, val.val);\n-    cx = trans_block(cx, dtor.body, return).bcx;\n+    cx.build.FastCall(dtor_addr, [cx.fcx.llretptr, cx.fcx.lltaskptr, dtor_env]\n+                      + cx.fcx.lltydescs + [val.val]);\n+\n     cx = drop_slot(cx, val.val, inner_t).bcx;\n     cx.build.Store(C_int(0), drop_flag.val);\n     cx.build.Br(next_cx.llbb);\n@@ -7827,19 +7836,20 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::node_id ctor_id,\n     finish_fn(fcx, lltop);\n }\n \n-fn trans_res(@local_ctxt cx, &span sp, &ast::_fn f, ast::node_id ctor_id,\n-             &vec[ast::ty_param] ty_params) {\n+fn trans_res_ctor(@local_ctxt cx, &span sp, &ast::_fn dtor,\n+                  ast::node_id ctor_id, &vec[ast::ty_param] ty_params) {\n+    // Create a function for the constructor\n     auto llctor_decl = cx.ccx.item_ids.get(ctor_id);\n     auto fcx = new_fn_ctxt(cx, sp, llctor_decl);\n     auto ret_t = ty::ret_ty_of_fn(cx.ccx.tcx, ctor_id);\n     create_llargs_for_fn_args(fcx, ast::proto_fn, none[ty_self_pair],\n-                              ret_t, f.decl.inputs, ty_params);\n+                              ret_t, dtor.decl.inputs, ty_params);\n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n     auto arg_t = arg_tys_of_fn(cx.ccx, ctor_id).(0).ty;\n     auto tup_t = ty::mk_imm_tup(cx.ccx.tcx, [ty::mk_int(cx.ccx.tcx), arg_t]);\n     auto arg = load_if_immediate\n-        (bcx, fcx.llargs.get(f.decl.inputs.(0).id), arg_t);\n+        (bcx, fcx.llargs.get(dtor.decl.inputs.(0).id), arg_t);\n     auto dst = GEP_tup_like(bcx, tup_t, fcx.llretptr, [0, 1]);\n     bcx = dst.bcx;\n     bcx = copy_val(bcx, INIT, dst.val, arg, arg_t).bcx;\n@@ -7959,8 +7969,11 @@ fn trans_item(@local_ctxt cx, &ast::item item) {\n                      with *extend_path(cx, item.ident));\n             trans_obj(sub_cx, item.span, ob, ctor_id, tps);\n         }\n-        case (ast::item_res(?decl, _, ?tps, ?ctor_id)) {\n-            trans_res(cx, item.span, decl, ctor_id, tps);\n+        case (ast::item_res(?dtor, ?dtor_id, ?tps, ?ctor_id)) {\n+            trans_res_ctor(cx, item.span, dtor, ctor_id, tps);\n+            // Create a function for the destructor\n+            auto lldtor_decl = cx.ccx.item_ids.get(item.id);\n+            trans_fn(cx, item.span, dtor, lldtor_decl, none, tps, dtor_id);\n         }\n         case (ast::item_mod(?m)) {\n             auto sub_cx =\n@@ -7999,10 +8012,17 @@ fn get_pair_fn_ty(TypeRef llpairty) -> TypeRef {\n     ret struct_elt(llpairty, 0u);\n }\n \n-fn decl_fn_and_pair(&@crate_ctxt ccx, &span sp, vec[str] path, str flav,\n+fn decl_fn_and_pair(&@crate_ctxt ccx, &span sp, &vec[str] path, str flav,\n                     vec[ast::ty_param] ty_params, ast::node_id node_id) {\n+    decl_fn_and_pair_full(ccx, sp, path, flav, ty_params, node_id,\n+                          node_id_type(ccx, node_id));\n+}\n+\n+fn decl_fn_and_pair_full(&@crate_ctxt ccx, &span sp, &vec[str] path, str flav,\n+                         vec[ast::ty_param] ty_params, ast::node_id node_id,\n+                         ty::t node_type) {\n     auto llfty;\n-    alt (ty::struct(ccx.tcx, node_id_type(ccx, node_id))) {\n+    alt (ty::struct(ccx.tcx, node_type)) {\n         case (ty::ty_fn(?proto, ?inputs, ?output, _, _)) {\n             llfty =\n                 type_of_fn(ccx, sp, proto, inputs, output,\n@@ -8023,7 +8043,7 @@ fn decl_fn_and_pair(&@crate_ctxt ccx, &span sp, vec[str] path, str flav,\n     let ValueRef llfn = decl_internal_fastcall_fn(ccx.llmod, s, llfty);\n     // Declare the global constant pair that points to it.\n \n-    let str ps = mangle_exported_name(ccx, path, node_id_type(ccx, node_id));\n+    let str ps = mangle_exported_name(ccx, path, node_type);\n     register_fn_pair(ccx, ps, llfty, llfn, node_id);\n     if (is_main) {\n         if (ccx.main_fn != none[ValueRef]) {\n@@ -8295,8 +8315,14 @@ fn collect_item_2(&@crate_ctxt ccx, &@ast::item i, &vec[str] pt,\n                 ccx.obj_methods.insert(m.node.id, ());\n             }\n         }\n-        case (ast::item_res(?decl, _, ?tps, ?ctor_id)) {\n+        case (ast::item_res(_, ?dtor_id, ?tps, ?ctor_id)) {\n             decl_fn_and_pair(ccx, i.span, new_pt, \"res_ctor\", tps, ctor_id);\n+            // Note that the destructor is associated with the item's id, not\n+            // the dtor_id. This is a bit counter-intuitive, but simplifies\n+            // ty_res, which would have to carry around two def_ids otherwise\n+            // -- one to identify the type, and one to find the dtor symbol.\n+            decl_fn_and_pair_full(ccx, i.span, new_pt, \"res_dtor\", tps, i.id,\n+                                  node_id_type(ccx, dtor_id));\n         }\n         case (_) { }\n     }"}]}