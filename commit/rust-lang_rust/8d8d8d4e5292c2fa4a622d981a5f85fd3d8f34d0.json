{"sha": "8d8d8d4e5292c2fa4a622d981a5f85fd3d8f34d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkOGQ4ZDRlNTI5MmMyZmE0YTYyMmQ5ODFhNWY4NWZkM2Q4ZjM0ZDA=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-10-01T03:43:39Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-10-30T02:51:21Z"}, "message": "Enforce object safety\n\ncloses #17670\n\n[breaking-change]\n\nTraits must be object-safe if they are to be used in trait objects. This might require splitting a trait into object-safe and non-object-safe parts.\n\nSome standard library traits in std::io have been split - Reader has new traits BytesReader (for the bytes method) and AsRefReader (for by_ref), Writer has new trait AsRefWriter (for by_ref). All these new traits have blanket impls, so any type which implements Reader or Writer (respectively) will have an implmentation of the new traits. To fix your code, you just need to `use` the new trait.", "tree": {"sha": "3b1f9fe8b1999b641dd7c1f023c52310768c3209", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b1f9fe8b1999b641dd7c1f023c52310768c3209"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d8d8d4e5292c2fa4a622d981a5f85fd3d8f34d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d8d8d4e5292c2fa4a622d981a5f85fd3d8f34d0", "html_url": "https://github.com/rust-lang/rust/commit/8d8d8d4e5292c2fa4a622d981a5f85fd3d8f34d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d8d8d4e5292c2fa4a622d981a5f85fd3d8f34d0/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15dd90b6475c7a44c9b95044c91519d9464bbcc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/15dd90b6475c7a44c9b95044c91519d9464bbcc4", "html_url": "https://github.com/rust-lang/rust/commit/15dd90b6475c7a44c9b95044c91519d9464bbcc4"}], "stats": {"total": 145, "additions": 69, "deletions": 76}, "files": [{"sha": "31364748423ca2fb797b5cd00af3b6f58ab11da2", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/8d8d8d4e5292c2fa4a622d981a5f85fd3d8f34d0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8d8d4e5292c2fa4a622d981a5f85fd3d8f34d0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=8d8d8d4e5292c2fa4a622d981a5f85fd3d8f34d0", "patch": "@@ -1336,16 +1336,6 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                self.ty_to_string(rcvr_ty),\n                candidate.repr(self.tcx()));\n \n-        let mut rcvr_substs = candidate.rcvr_substs.clone();\n-\n-        if !self.enforce_object_limitations(candidate) {\n-            // Here we change `Self` from `Trait` to `err` in the case that\n-            // this is an illegal object method. This is necessary to prevent\n-            // the user from getting strange, derivative errors when the method\n-            // takes an argument/return-type of type `Self` etc.\n-            rcvr_substs.types.get_mut_slice(SelfSpace)[0] = ty::mk_err();\n-        }\n-\n         self.enforce_drop_trait_limitations(candidate);\n \n         // Determine the values for the generic parameters of the method.\n@@ -1554,71 +1544,6 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         }\n     }\n \n-    fn enforce_object_limitations(&self, candidate: &Candidate) -> bool {\n-        /*!\n-         * There are some limitations to calling functions through an\n-         * object, because (a) the self type is not known\n-         * (that's the whole point of a trait instance, after all, to\n-         * obscure the self type) and (b) the call must go through a\n-         * vtable and hence cannot be monomorphized.\n-         */\n-\n-        match candidate.origin {\n-            MethodStatic(..) |\n-            MethodTypeParam(..) |\n-            MethodStaticUnboxedClosure(..) => {\n-                return true; // not a call to a trait instance\n-            }\n-            MethodTraitObject(..) => {}\n-        }\n-\n-        match candidate.method_ty.explicit_self {\n-            ty::StaticExplicitSelfCategory => { // reason (a) above\n-                self.tcx().sess.span_err(\n-                    self.span,\n-                    \"cannot call a method without a receiver \\\n-                     through an object\");\n-                return false;\n-            }\n-\n-            ty::ByValueExplicitSelfCategory |\n-            ty::ByReferenceExplicitSelfCategory(..) |\n-            ty::ByBoxExplicitSelfCategory => {}\n-        }\n-\n-        // reason (a) above\n-        let check_for_self_ty = |ty| -> bool {\n-            if ty::type_has_self(ty) {\n-                span_err!(self.tcx().sess, self.span, E0038,\n-                    \"cannot call a method whose type contains a \\\n-                     self-type through an object\");\n-                false\n-            } else {\n-                true\n-            }\n-        };\n-        let ref sig = candidate.method_ty.fty.sig;\n-        for &input_ty in sig.inputs[1..].iter() {\n-            if !check_for_self_ty(input_ty) {\n-                return false;\n-            }\n-        }\n-        if let ty::FnConverging(result_type) = sig.output {\n-            if !check_for_self_ty(result_type) {\n-                return false;\n-            }\n-        }\n-\n-        if candidate.method_ty.generics.has_type_params(subst::FnSpace) {\n-            // reason (b) above\n-            span_err!(self.tcx().sess, self.span, E0039,\n-                \"cannot call a generic method through an object\");\n-            return false;\n-        }\n-\n-        true\n-    }\n-\n     fn enforce_drop_trait_limitations(&self, candidate: &Candidate) {\n         // No code can call the finalize method explicitly.\n         let bad = match candidate.origin {"}, {"sha": "7a5ce9a528cda1f6b5a6a0ec2e7f24b777aaafc5", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d8d8d4e5292c2fa4a622d981a5f85fd3d8f34d0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8d8d4e5292c2fa4a622d981a5f85fd3d8f34d0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=8d8d8d4e5292c2fa4a622d981a5f85fd3d8f34d0", "patch": "@@ -1687,6 +1687,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.register_unsize_obligations(span, &**u)\n             }\n             ty::UnsizeVtable(ref ty_trait, self_ty) => {\n+                vtable2::check_object_safety(self.tcx(), ty_trait, span);\n                 // If the type is `Foo+'a`, ensures that the type\n                 // being cast to `Foo+'a` implements `Foo`:\n                 vtable::register_object_cast_obligations(self,"}, {"sha": "639ba9bdf49486d777e71621329538302a94f10b", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 68, "deletions": 1, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/8d8d8d4e5292c2fa4a622d981a5f85fd3d8f34d0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8d8d4e5292c2fa4a622d981a5f85fd3d8f34d0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=8d8d8d4e5292c2fa4a622d981a5f85fd3d8f34d0", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::subst::{SelfSpace};\n+use middle::subst::{SelfSpace, FnSpace};\n use middle::traits;\n use middle::traits::{SelectionError, OutputTypeParameterMismatch, Overflow, Unimplemented};\n use middle::traits::{Obligation, obligation_for_builtin_bound};\n@@ -46,6 +46,7 @@ pub fn check_object_cast(fcx: &FnCtxt,\n \n             // Ensure that if ~T is cast to ~Trait, then T : Trait\n             push_cast_obligation(fcx, cast_expr, object_trait, referent_ty);\n+            check_object_safety(fcx.tcx(), object_trait, source_expr.span);\n         }\n \n         (&ty::ty_rptr(referent_region, ty::mt { ty: referent_ty,\n@@ -68,6 +69,8 @@ pub fn check_object_cast(fcx: &FnCtxt,\n                                infer::RelateObjectBound(source_expr.span),\n                                target_region,\n                                referent_region);\n+\n+                check_object_safety(fcx.tcx(), object_trait, source_expr.span);\n             }\n         }\n \n@@ -128,6 +131,70 @@ pub fn check_object_cast(fcx: &FnCtxt,\n     }\n }\n \n+// TODO comment\n+pub fn check_object_safety(tcx: &ty::ctxt, object_trait: &ty::TyTrait, span: Span) {\n+    let trait_items = ty::trait_items(tcx, object_trait.def_id);\n+    for item in trait_items.iter() {\n+        match *item {\n+            ty::MethodTraitItem(ref m) => check_object_safety_of_method(tcx, &**m, span),\n+            ty::TypeTraitItem(_) => {}\n+        }\n+    }\n+\n+    // TODO error messages\n+    fn check_object_safety_of_method(tcx: &ty::ctxt, method: &ty::Method, span: Span) {\n+        /*!\n+         * There are some limitations to calling functions through an\n+         * object, because (a) the self type is not known\n+         * (that's the whole point of a trait instance, after all, to\n+         * obscure the self type) and (b) the call must go through a\n+         * vtable and hence cannot be monomorphized.\n+         */\n+\n+        match method.explicit_self {\n+            ty::ByValueExplicitSelfCategory => { // reason (a) above\n+                tcx.sess.span_err(\n+                    span,\n+                    \"cannot call a method with a by-value receiver \\\n+                     through a trait object\");\n+            }\n+\n+            ty::StaticExplicitSelfCategory |\n+            ty::ByReferenceExplicitSelfCategory(..) |\n+            ty::ByBoxExplicitSelfCategory => {}\n+        }\n+\n+        // reason (a) above\n+        let check_for_self_ty = |ty| {\n+            if ty::type_has_self(ty) {\n+                span_err!(tcx.sess, span, E0038,\n+                    \"cannot call a method whose type contains a \\\n+                     self-type through an object: {}\", ::util::ppaux::ty_to_string(tcx, ty));\n+                true\n+            } else {\n+                false\n+            }\n+        };\n+        let ref sig = method.fty.sig;\n+        let mut found_self_ty = false;\n+        for &input_ty in sig.inputs.tail().iter() {\n+            if check_for_self_ty(input_ty) {\n+                found_self_ty = true;\n+                break;\n+            }\n+        }\n+        if !found_self_ty {\n+            check_for_self_ty(sig.output);\n+        }\n+\n+        if method.generics.has_type_params(FnSpace) {\n+            // reason (b) above\n+            span_err!(tcx.sess, span, E0039,\n+                \"cannot call a generic method through an object\");\n+        }\n+    }\n+}\n+\n pub fn register_object_cast_obligations(fcx: &FnCtxt,\n                                         span: Span,\n                                         object_trait: &ty::TyTrait,"}]}