{"sha": "cca4804251957646d4840bf33b3b13e3f2b645de", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjYTQ4MDQyNTE5NTc2NDZkNDg0MGJmMzNiM2IxM2UzZjJiNjQ1ZGU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-07-21T16:44:59Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-07-28T16:05:04Z"}, "message": "Code to save/load the work-products map from disk\n\nWork products are deleted if any of their inputs are dirty.", "tree": {"sha": "226e17fcdd0b9db5b0a1c4c24edf305733937d44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/226e17fcdd0b9db5b0a1c4c24edf305733937d44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cca4804251957646d4840bf33b3b13e3f2b645de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cca4804251957646d4840bf33b3b13e3f2b645de", "html_url": "https://github.com/rust-lang/rust/commit/cca4804251957646d4840bf33b3b13e3f2b645de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cca4804251957646d4840bf33b3b13e3f2b645de/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffc13b2f80dfe60895bb415175fa246d7247a33c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffc13b2f80dfe60895bb415175fa246d7247a33c", "html_url": "https://github.com/rust-lang/rust/commit/ffc13b2f80dfe60895bb415175fa246d7247a33c"}], "stats": {"total": 244, "additions": 191, "deletions": 53}, "files": [{"sha": "a48ff2533485c81dcd366809757c60e17c63c3c4", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cca4804251957646d4840bf33b3b13e3f2b645de/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca4804251957646d4840bf33b3b13e3f2b645de/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=cca4804251957646d4840bf33b3b13e3f2b645de", "patch": "@@ -88,7 +88,7 @@ pub fn compile_input(sess: &Session,\n     // We need nested scopes here, because the intermediate results can keep\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n-    let (outputs, trans) = {\n+    let (outputs, trans, id) = {\n         let krate = match phase_1_parse_input(sess, cfg, input) {\n             Ok(krate) => krate,\n             Err(mut parse_error) => {\n@@ -212,11 +212,11 @@ pub fn compile_input(sess: &Session,\n             // Discard interned strings as they are no longer required.\n             token::clear_ident_interner();\n \n-            Ok((outputs, trans))\n+            Ok((outputs, trans, id.clone()))\n         })??\n     };\n \n-    let phase5_result = phase_5_run_llvm_passes(sess, &trans, &outputs);\n+    let phase5_result = phase_5_run_llvm_passes(sess, &id, &trans, &outputs);\n \n     controller_entry_point!(after_llvm,\n                             sess,\n@@ -1020,6 +1020,7 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// Run LLVM itself, producing a bitcode file, assembly file or object file\n /// as a side effect.\n pub fn phase_5_run_llvm_passes(sess: &Session,\n+                               crate_name: &str,\n                                trans: &trans::CrateTranslation,\n                                outputs: &OutputFilenames) -> CompileResult {\n     if sess.opts.cg.no_integrated_as {\n@@ -1041,6 +1042,10 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n              || write::run_passes(sess, trans, &sess.opts.output_types, outputs));\n     }\n \n+    time(sess.time_passes(),\n+         \"serialize work products\",\n+         move || rustc_incremental::save_work_products(sess, crate_name));\n+\n     if sess.err_count() > 0 {\n         Err(sess.err_count())\n     } else {"}, {"sha": "352e5979d011e7f0e78343ab18670a984de39364", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cca4804251957646d4840bf33b3b13e3f2b645de/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca4804251957646d4840bf33b3b13e3f2b645de/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=cca4804251957646d4840bf33b3b13e3f2b645de", "patch": "@@ -19,6 +19,7 @@\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![cfg_attr(not(stage0), deny(warnings))]\n \n+#![feature(question_mark)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n \n@@ -40,3 +41,4 @@ pub use assert_dep_graph::assert_dep_graph;\n pub use calculate_svh::SvhCalculate;\n pub use persist::load_dep_graph;\n pub use persist::save_dep_graph;\n+pub use persist::save_work_products;"}, {"sha": "95e9a16f29bbe927db40164283e00576231eb789", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cca4804251957646d4840bf33b3b13e3f2b645de/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca4804251957646d4840bf33b3b13e3f2b645de/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=cca4804251957646d4840bf33b3b13e3f2b645de", "patch": "@@ -10,8 +10,9 @@\n \n //! The data that we will serialize and deserialize.\n \n-use rustc::dep_graph::DepNode;\n+use rustc::dep_graph::{DepNode, WorkProduct, WorkProductId};\n use rustc::hir::def_id::DefIndex;\n+use std::sync::Arc;\n \n use super::directory::DefPathIndex;\n \n@@ -55,6 +56,15 @@ pub struct SerializedHash {\n     pub hash: u64,\n }\n \n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n+pub struct SerializedWorkProduct {\n+    /// node that produced the work-product\n+    pub id: Arc<WorkProductId>,\n+\n+    /// work-product data itself\n+    pub work_product: WorkProduct,\n+}\n+\n /// Data for use when downstream crates get recompiled.\n #[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct SerializedMetadataHashes {"}, {"sha": "9fef2285aa7eb9761881f07a94a2cea501e559e0", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 95, "deletions": 26, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/cca4804251957646d4840bf33b3b13e3f2b645de/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca4804251957646d4840bf33b3b13e3f2b645de/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=cca4804251957646d4840bf33b3b13e3f2b645de", "patch": "@@ -14,12 +14,13 @@ use rbml::Error;\n use rbml::opaque::Decoder;\n use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::DefId;\n+use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fnv::FnvHashSet;\n use rustc_serialize::Decodable as RustcDecodable;\n use std::io::Read;\n-use std::fs::File;\n-use std::path::Path;\n+use std::fs::{self, File};\n+use std::path::{Path};\n \n use super::data::*;\n use super::directory::*;\n@@ -38,50 +39,73 @@ type CleanEdges = Vec<(DepNode<DefId>, DepNode<DefId>)>;\n /// actually it doesn't matter all that much.) See `README.md` for\n /// more general overview.\n pub fn load_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    if tcx.sess.opts.incremental.is_none() {\n+        return;\n+    }\n+\n     let _ignore = tcx.dep_graph.in_ignore();\n+    load_dep_graph_if_exists(tcx);\n+    dirty_clean::check_dirty_clean_annotations(tcx);\n+}\n \n-    if let Some(dep_graph) = dep_graph_path(tcx) {\n-        // FIXME(#32754) lock file?\n-        load_dep_graph_if_exists(tcx, &dep_graph);\n-        dirty_clean::check_dirty_clean_annotations(tcx);\n+fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    let dep_graph_path = dep_graph_path(tcx).unwrap();\n+    let dep_graph_data = match load_data(tcx.sess, &dep_graph_path) {\n+        Some(p) => p,\n+        None => return // no file\n+    };\n+\n+    let work_products_path = tcx_work_products_path(tcx).unwrap();\n+    let work_products_data = match load_data(tcx.sess, &work_products_path) {\n+        Some(p) => p,\n+        None => return // no file\n+    };\n+\n+    match decode_dep_graph(tcx, &dep_graph_data, &work_products_data) {\n+        Ok(()) => return,\n+        Err(err) => bug!(\"decoding error in dep-graph from `{}` and `{}`: {}\",\n+                         dep_graph_path.display(),\n+                         work_products_path.display(),\n+                         err),\n     }\n }\n \n-pub fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, path: &Path) {\n+fn load_data(sess: &Session, path: &Path) -> Option<Vec<u8>> {\n     if !path.exists() {\n-        return;\n+        return None;\n     }\n \n     let mut data = vec![];\n     match\n         File::open(path)\n         .and_then(|mut file| file.read_to_end(&mut data))\n     {\n-        Ok(_) => { }\n+        Ok(_) => {\n+            Some(data)\n+        }\n         Err(err) => {\n-            tcx.sess.err(\n+            sess.err(\n                 &format!(\"could not load dep-graph from `{}`: {}\",\n                          path.display(), err));\n-            return;\n+            None\n         }\n     }\n \n-    match decode_dep_graph(tcx, &data) {\n-        Ok(dirty) => dirty,\n-        Err(err) => {\n-            bug!(\"decoding error in dep-graph from `{}`: {}\", path.display(), err);\n-        }\n-    }\n }\n \n+/// Decode the dep graph and load the edges/nodes that are still clean\n+/// into `tcx.dep_graph`. On success, returns a hashset containing all\n+/// the paths of work-products from clean nodes (any work-products not\n+/// in this set can be deleted).\n pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  data: &[u8])\n+                                  dep_graph_data: &[u8],\n+                                  work_products_data: &[u8])\n                                   -> Result<(), Error>\n {\n     // Deserialize the directory and dep-graph.\n-    let mut decoder = Decoder::new(data, 0);\n-    let directory = try!(DefIdDirectory::decode(&mut decoder));\n-    let serialized_dep_graph = try!(SerializedDepGraph::decode(&mut decoder));\n+    let mut dep_graph_decoder = Decoder::new(dep_graph_data, 0);\n+    let directory = try!(DefIdDirectory::decode(&mut dep_graph_decoder));\n+    let serialized_dep_graph = try!(SerializedDepGraph::decode(&mut dep_graph_decoder));\n \n     debug!(\"decode_dep_graph: directory = {:#?}\", directory);\n     debug!(\"decode_dep_graph: serialized_dep_graph = {:#?}\", serialized_dep_graph);\n@@ -121,12 +145,18 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Add nodes and edges that are not dirty into our main graph.\n     let dep_graph = tcx.dep_graph.clone();\n     for (source, target) in clean_edges.into_iter().chain(clean_nodes) {\n-        let _task = dep_graph.in_task(target.clone());\n-        dep_graph.read(source.clone());\n-\n         debug!(\"decode_dep_graph: clean edge: {:?} -> {:?}\", source, target);\n+\n+        let _task = dep_graph.in_task(target);\n+        dep_graph.read(source);\n     }\n \n+    // Add in work-products that are still clean, and delete those that are\n+    // dirty.\n+    let mut work_product_decoder = Decoder::new(work_products_data, 0);\n+    let work_products = try!(<Vec<SerializedWorkProduct>>::decode(&mut work_product_decoder));\n+    reconcile_work_products(tcx, work_products, &dirty_nodes);\n+\n     Ok(())\n }\n \n@@ -141,9 +171,9 @@ fn initial_dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         match hash.node.map_def(|&i| retraced.def_id(i)) {\n             Some(dep_node) => {\n                 let current_hash = hcx.hash(&dep_node).unwrap();\n-                debug!(\"initial_dirty_nodes: hash of {:?} is {:?}, was {:?}\",\n-                       dep_node, current_hash, hash.hash);\n                 if current_hash != hash.hash {\n+                    debug!(\"initial_dirty_nodes: {:?} is dirty as hash is {:?}, was {:?}\",\n+                           dep_node, current_hash, hash.hash);\n                     dirty_nodes.insert(dep_node);\n                 }\n             }\n@@ -177,6 +207,8 @@ fn compute_clean_edges(serialized_edges: &[(SerializedEdge)],\n                 clean_edges.push((source, target))\n             } else {\n                 // source removed, target must be dirty\n+                debug!(\"compute_clean_edges: {:?} dirty because {:?} no longer exists\",\n+                       target, serialized_source);\n                 dirty_nodes.insert(target);\n             }\n         } else {\n@@ -213,3 +245,40 @@ fn compute_clean_edges(serialized_edges: &[(SerializedEdge)],\n \n     clean_edges\n }\n+\n+/// Go through the list of work-products produced in the previous run.\n+/// Delete any whose nodes have been found to be dirty or which are\n+/// otherwise no longer applicable.\n+fn reconcile_work_products<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     work_products: Vec<SerializedWorkProduct>,\n+                                     dirty_nodes: &DirtyNodes) {\n+    debug!(\"reconcile_work_products({:?})\", work_products);\n+    for swp in work_products {\n+        let dep_node = DepNode::WorkProduct(swp.id.clone());\n+        if dirty_nodes.contains(&dep_node) {\n+            debug!(\"reconcile_work_products: dep-node for {:?} is dirty\", swp);\n+            delete_dirty_work_product(tcx, swp);\n+        } else {\n+            let path = in_incr_comp_dir(tcx.sess, &swp.work_product.file_name).unwrap();\n+            if path.exists() {\n+                tcx.dep_graph.insert_previous_work_product(&swp.id, swp.work_product);\n+            } else {\n+                debug!(\"reconcile_work_products: file for {:?} does not exist\", swp);\n+            }\n+        }\n+    }\n+}\n+\n+fn delete_dirty_work_product(tcx: TyCtxt,\n+                             swp: SerializedWorkProduct) {\n+    debug!(\"delete_dirty_work_product({:?})\", swp);\n+    let path = in_incr_comp_dir(tcx.sess, &swp.work_product.file_name).unwrap();\n+    match fs::remove_file(&path) {\n+        Ok(()) => { }\n+        Err(err) => {\n+            tcx.sess.warn(\n+                &format!(\"file-system error deleting outdated file `{}`: {}\",\n+                         path.display(), err));\n+        }\n+    }\n+}"}, {"sha": "30e7d7873ecc15717cdcb1caf1b5f383edbf5e49", "filename": "src/librustc_incremental/persist/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cca4804251957646d4840bf33b3b13e3f2b645de/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca4804251957646d4840bf33b3b13e3f2b645de/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs?ref=cca4804251957646d4840bf33b3b13e3f2b645de", "patch": "@@ -22,3 +22,4 @@ mod util;\n \n pub use self::load::load_dep_graph;\n pub use self::save::save_dep_graph;\n+pub use self::save::save_work_products;"}, {"sha": "305250d59623c50d644da6ad3cb3e7de2f538e19", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/cca4804251957646d4840bf33b3b13e3f2b645de/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca4804251957646d4840bf33b3b13e3f2b645de/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=cca4804251957646d4840bf33b3b13e3f2b645de", "patch": "@@ -11,6 +11,7 @@\n use rbml::opaque::Encoder;\n use rustc::dep_graph::DepNode;\n use rustc::middle::cstore::LOCAL_CRATE;\n+use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc_serialize::{Encodable as RustcEncodable};\n use std::hash::{Hasher, SipHasher};\n@@ -24,19 +25,26 @@ use super::hash::*;\n use super::util::*;\n \n pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    debug!(\"save_dep_graph()\");\n     let _ignore = tcx.dep_graph.in_ignore();\n+    let sess = tcx.sess;\n     let mut hcx = HashContext::new(tcx);\n-    save_in(&mut hcx, dep_graph_path(tcx), encode_dep_graph);\n-    save_in(&mut hcx, metadata_hash_path(tcx, LOCAL_CRATE), encode_metadata_hashes);\n+    save_in(sess, dep_graph_path(tcx), |e| encode_dep_graph(&mut hcx, e));\n+    save_in(sess, metadata_hash_path(tcx, LOCAL_CRATE), |e| encode_metadata_hashes(&mut hcx, e));\n }\n \n-fn save_in<'a, 'tcx, F>(hcx: &mut HashContext<'a, 'tcx>,\n-                        opt_path_buf: Option<PathBuf>,\n-                        encode: F)\n-    where F: FnOnce(&mut HashContext<'a, 'tcx>, &mut Encoder) -> io::Result<()>\n-{\n-    let tcx = hcx.tcx;\n+pub fn save_work_products(sess: &Session, local_crate_name: &str) {\n+    debug!(\"save_work_products()\");\n+    let _ignore = sess.dep_graph.in_ignore();\n+    let path = sess_work_products_path(sess, local_crate_name);\n+    save_in(sess, path, |e| encode_work_products(sess, e));\n+}\n \n+fn save_in<F>(sess: &Session,\n+              opt_path_buf: Option<PathBuf>,\n+              encode: F)\n+    where F: FnOnce(&mut Encoder) -> io::Result<()>\n+{\n     let path_buf = match opt_path_buf {\n         Some(p) => p,\n         None => return\n@@ -49,7 +57,7 @@ fn save_in<'a, 'tcx, F>(hcx: &mut HashContext<'a, 'tcx>,\n         match fs::remove_file(&path_buf) {\n             Ok(()) => { }\n             Err(err) => {\n-                tcx.sess.err(\n+                sess.err(\n                     &format!(\"unable to delete old dep-graph at `{}`: {}\",\n                              path_buf.display(), err));\n                 return;\n@@ -59,10 +67,10 @@ fn save_in<'a, 'tcx, F>(hcx: &mut HashContext<'a, 'tcx>,\n \n     // generate the data in a memory buffer\n     let mut wr = Cursor::new(Vec::new());\n-    match encode(hcx, &mut Encoder::new(&mut wr)) {\n+    match encode(&mut Encoder::new(&mut wr)) {\n         Ok(()) => { }\n         Err(err) => {\n-            tcx.sess.err(\n+            sess.err(\n                 &format!(\"could not encode dep-graph to `{}`: {}\",\n                          path_buf.display(), err));\n             return;\n@@ -77,7 +85,7 @@ fn save_in<'a, 'tcx, F>(hcx: &mut HashContext<'a, 'tcx>,\n     {\n         Ok(_) => { }\n         Err(err) => {\n-            tcx.sess.err(\n+            sess.err(\n                 &format!(\"failed to write dep-graph to `{}`: {}\",\n                          path_buf.display(), err));\n             return;\n@@ -192,3 +200,22 @@ pub fn encode_metadata_hashes<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n \n     Ok(())\n }\n+\n+pub fn encode_work_products(sess: &Session,\n+                            encoder: &mut Encoder)\n+                            -> io::Result<()>\n+{\n+    let work_products: Vec<_> =\n+        sess.dep_graph.work_products()\n+                     .iter()\n+                     .map(|(id, work_product)| {\n+                         SerializedWorkProduct {\n+                             id: id.clone(),\n+                             work_product: work_product.clone(),\n+                         }\n+                     })\n+                     .collect();\n+\n+    work_products.encode(encoder)\n+}\n+"}, {"sha": "f1e81fdb266b9b201271281c02851e8248b16083", "filename": "src/librustc_incremental/persist/util.rs", "status": "modified", "additions": 35, "deletions": 11, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cca4804251957646d4840bf33b3b13e3f2b645de/src%2Flibrustc_incremental%2Fpersist%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca4804251957646d4840bf33b3b13e3f2b645de/src%2Flibrustc_incremental%2Fpersist%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Futil.rs?ref=cca4804251957646d4840bf33b3b13e3f2b645de", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use rustc::middle::cstore::LOCAL_CRATE;\n+use rustc::session::Session;\n use rustc::ty::TyCtxt;\n \n use std::fs;\n@@ -17,33 +18,56 @@ use std::path::{Path, PathBuf};\n use syntax::ast;\n \n pub fn dep_graph_path(tcx: TyCtxt) -> Option<PathBuf> {\n-    path(tcx, LOCAL_CRATE, \"local\")\n+    tcx_path(tcx, LOCAL_CRATE, \"local\")\n }\n \n pub fn metadata_hash_path(tcx: TyCtxt, cnum: ast::CrateNum) -> Option<PathBuf> {\n-    path(tcx, cnum, \"metadata\")\n+    tcx_path(tcx, cnum, \"metadata\")\n }\n \n-fn path(tcx: TyCtxt, cnum: ast::CrateNum, suffix: &str) -> Option<PathBuf> {\n+pub fn tcx_work_products_path(tcx: TyCtxt) -> Option<PathBuf> {\n+    let crate_name = tcx.crate_name(LOCAL_CRATE);\n+    sess_work_products_path(tcx.sess, &crate_name)\n+}\n+\n+pub fn sess_work_products_path(sess: &Session,\n+                               local_crate_name: &str)\n+                               -> Option<PathBuf> {\n+    let crate_disambiguator = sess.local_crate_disambiguator();\n+    path(sess, local_crate_name, &crate_disambiguator, \"work-products\")\n+}\n+\n+pub fn in_incr_comp_dir(sess: &Session, file_name: &str) -> Option<PathBuf> {\n+    sess.opts.incremental.as_ref().map(|incr_dir| incr_dir.join(file_name))\n+}\n+\n+fn tcx_path(tcx: TyCtxt,\n+            cnum: ast::CrateNum,\n+            middle: &str)\n+            -> Option<PathBuf> {\n+    path(tcx.sess, &tcx.crate_name(cnum), &tcx.crate_disambiguator(cnum), middle)\n+}\n+\n+fn path(sess: &Session,\n+        crate_name: &str,\n+        crate_disambiguator: &str,\n+        middle: &str)\n+        -> Option<PathBuf> {\n     // For now, just save/load dep-graph from\n     // directory/dep_graph.rbml\n-    tcx.sess.opts.incremental.as_ref().and_then(|incr_dir| {\n+    sess.opts.incremental.as_ref().and_then(|incr_dir| {\n         match create_dir_racy(&incr_dir) {\n             Ok(()) => {}\n             Err(err) => {\n-                tcx.sess.err(\n+                sess.err(\n                     &format!(\"could not create the directory `{}`: {}\",\n                              incr_dir.display(), err));\n                 return None;\n             }\n         }\n \n-        let crate_name = tcx.crate_name(cnum);\n-        let crate_disambiguator = tcx.crate_disambiguator(cnum);\n-        let file_name = format!(\"{}-{}.{}.bin\",\n-                                crate_name,\n-                                crate_disambiguator,\n-                                suffix);\n+        let file_name = format!(\"{}-{}.{}.bin\", crate_name, crate_disambiguator, middle);\n+\n         Some(incr_dir.join(file_name))\n     })\n }"}]}