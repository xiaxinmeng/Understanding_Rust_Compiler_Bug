{"sha": "b68fad670bb3612cac26e50751e4fd9150e59977", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2OGZhZDY3MGJiMzYxMmNhYzI2ZTUwNzUxZTRmZDkxNTBlNTk5Nzc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-08T00:11:23Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-01-02T22:35:05Z"}, "message": "universe transition\n\nRemove the leak-check and its associated machinery. Replace with\nmaking the solver aware of universes.", "tree": {"sha": "f2b2120ae78785039588b155141f90924d7afc18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2b2120ae78785039588b155141f90924d7afc18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b68fad670bb3612cac26e50751e4fd9150e59977", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b68fad670bb3612cac26e50751e4fd9150e59977", "html_url": "https://github.com/rust-lang/rust/commit/b68fad670bb3612cac26e50751e4fd9150e59977", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b68fad670bb3612cac26e50751e4fd9150e59977/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eba2ae526b2624c76bdb9fea41f88d2c1740c722", "url": "https://api.github.com/repos/rust-lang/rust/commits/eba2ae526b2624c76bdb9fea41f88d2c1740c722", "html_url": "https://github.com/rust-lang/rust/commit/eba2ae526b2624c76bdb9fea41f88d2c1740c722"}], "stats": {"total": 943, "additions": 144, "deletions": 799}, "files": [{"sha": "709e8c0ba9b24115683695ef3ec2ac49c26cfd35", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 30, "deletions": 477, "changes": 507, "blob_url": "https://github.com/rust-lang/rust/blob/b68fad670bb3612cac26e50751e4fd9150e59977/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b68fad670bb3612cac26e50751e4fd9150e59977/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=b68fad670bb3612cac26e50751e4fd9150e59977", "patch": "@@ -1,31 +1,23 @@\n //! Helper routines for higher-ranked things. See the `doc` module at\n //! the end of the file for details.\n \n-use super::{CombinedSnapshot,\n-            InferCtxt,\n-            HigherRankedType,\n-            SubregionOrigin,\n-            PlaceholderMap};\n use super::combine::CombineFields;\n-use super::region_constraints::{TaintDirections};\n+use super::{HigherRankedType, InferCtxt, PlaceholderMap};\n \n-use ty::{self, TyCtxt, Binder, TypeFoldable};\n-use ty::error::TypeError;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n-use syntax_pos::Span;\n-use util::nodemap::{FxHashMap, FxHashSet};\n-\n-pub struct HrMatchResult<U> {\n-    pub value: U,\n-}\n+use ty::{self, Binder, TypeFoldable};\n \n impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n-    pub fn higher_ranked_sub<T>(&mut self, a: &Binder<T>, b: &Binder<T>, a_is_expected: bool)\n-                                -> RelateResult<'tcx, Binder<T>>\n-        where T: Relate<'tcx>\n+    pub fn higher_ranked_sub<T>(\n+        &mut self,\n+        a: &Binder<T>,\n+        b: &Binder<T>,\n+        a_is_expected: bool,\n+    ) -> RelateResult<'tcx, Binder<T>>\n+    where\n+        T: Relate<'tcx>,\n     {\n-        debug!(\"higher_ranked_sub(a={:?}, b={:?})\",\n-               a, b);\n+        debug!(\"higher_ranked_sub(a={:?}, b={:?})\", a, b);\n \n         // Rather than checking the subtype relationship between `a` and `b`\n         // as-is, we need to do some extra work here in order to make sure\n@@ -35,279 +27,37 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n         // please see the large comment at the end of the file in the (inlined) module\n         // `doc`.\n \n-        // Start a snapshot so we can examine \"all bindings that were\n-        // created as part of this type comparison\".\n-        return self.infcx.commit_if_ok(|snapshot| {\n-            let span = self.trace.cause.span;\n-\n-            // First, we instantiate each bound region in the supertype with a\n-            // fresh placeholder region.\n-            let (b_prime, placeholder_map) =\n-                self.infcx.replace_bound_vars_with_placeholders(b);\n-\n-            // Next, we instantiate each bound region in the subtype\n-            // with a fresh region variable. These region variables --\n-            // but no other pre-existing region variables -- can name\n-            // the placeholders.\n-            let (a_prime, _) = self.infcx.replace_bound_vars_with_fresh_vars(\n-                span,\n-                HigherRankedType,\n-                a\n-            );\n-\n-            debug!(\"a_prime={:?}\", a_prime);\n-            debug!(\"b_prime={:?}\", b_prime);\n-\n-            // Compare types now that bound regions have been replaced.\n-            let result = self.sub(a_is_expected).relate(&a_prime, &b_prime)?;\n-\n-            // Presuming type comparison succeeds, we need to check\n-            // that the placeholder regions do not \"leak\".\n-            self.infcx.leak_check(!a_is_expected, span, &placeholder_map, snapshot)?;\n-\n-            // We are finished with the placeholder regions now so pop\n-            // them off.\n-            self.infcx.pop_placeholders(placeholder_map, snapshot);\n-\n-            debug!(\"higher_ranked_sub: OK result={:?}\", result);\n-\n-            Ok(ty::Binder::bind(result))\n-        });\n-    }\n-\n-    /// The value consists of a pair `(t, u)` where `t` is the\n-    /// *matcher* and `u` is a *value*. The idea is to find a\n-    /// substitution `S` such that `S(t) == b`, and then return\n-    /// `S(u)`. In other words, find values for the late-bound regions\n-    /// in `a` that can make `t == b` and then replace the LBR in `u`\n-    /// with those values.\n-    ///\n-    /// This routine is (as of this writing) used in trait matching,\n-    /// particularly projection.\n-    ///\n-    /// NB. It should not happen that there are LBR appearing in `U`\n-    /// that do not appear in `T`. If that happens, those regions are\n-    /// unconstrained, and this routine replaces them with `'static`.\n-    pub fn higher_ranked_match<T, U>(&mut self,\n-                                     a_pair: &Binder<(T, U)>,\n-                                     b_match: &T,\n-                                     a_is_expected: bool)\n-                                     -> RelateResult<'tcx, HrMatchResult<U>>\n-        where T: Relate<'tcx>,\n-              U: TypeFoldable<'tcx>\n-    {\n-        debug!(\"higher_ranked_match(a={:?}, b={:?})\",\n-               a_pair, b_match);\n-\n-        // Start a snapshot so we can examine \"all bindings that were\n-        // created as part of this type comparison\".\n-        return self.infcx.commit_if_ok(|snapshot| {\n-            // First, we instantiate each bound region in the matcher\n-            // with a placeholder region.\n-            let ((a_match, a_value), placeholder_map) =\n-                self.infcx.replace_bound_vars_with_placeholders(a_pair);\n+        let span = self.trace.cause.span;\n \n-            debug!(\"higher_ranked_match: a_match={:?}\", a_match);\n-            debug!(\"higher_ranked_match: placeholder_map={:?}\", placeholder_map);\n+        // First, we instantiate each bound region in the supertype with a\n+        // fresh placeholder region.\n+        let (b_prime, _) = self.infcx.replace_bound_vars_with_placeholders(b);\n \n-            // Equate types now that bound regions have been replaced.\n-            self.equate(a_is_expected).relate(&a_match, &b_match)?;\n+        // Next, we instantiate each bound region in the subtype\n+        // with a fresh region variable. These region variables --\n+        // but no other pre-existing region variables -- can name\n+        // the placeholders.\n+        let (a_prime, _) =\n+            self.infcx\n+                .replace_bound_vars_with_fresh_vars(span, HigherRankedType, a);\n \n-            // Map each placeholder region to a vector of other regions that it\n-            // must be equated with. (Note that this vector may include other\n-            // placeholder regions from `placeholder_map`.)\n-            let placeholder_resolution_map: FxHashMap<_, _> =\n-                placeholder_map\n-                .iter()\n-                .map(|(&br, &placeholder)| {\n-                    let tainted_regions =\n-                        self.infcx.tainted_regions(snapshot,\n-                                                   placeholder,\n-                                                   TaintDirections::incoming()); // [1]\n+        debug!(\"a_prime={:?}\", a_prime);\n+        debug!(\"b_prime={:?}\", b_prime);\n \n-                    // [1] this routine executes after the placeholder\n-                    // regions have been *equated* with something\n-                    // else, so examining the incoming edges ought to\n-                    // be enough to collect all constraints\n+        // Compare types now that bound regions have been replaced.\n+        let result = self.sub(a_is_expected).relate(&a_prime, &b_prime)?;\n \n-                    (placeholder, (br, tainted_regions))\n-                })\n-                .collect();\n+        debug!(\"higher_ranked_sub: OK result={:?}\", result);\n \n-            // For each placeholder region, pick a representative -- which can\n-            // be any region from the sets above, except for other members of\n-            // `placeholder_map`. There should always be a representative if things\n-            // are properly well-formed.\n-            let placeholder_representatives: FxHashMap<_, _> =\n-                placeholder_resolution_map\n-                .iter()\n-                .map(|(&placeholder, &(_, ref regions))| {\n-                    let representative =\n-                        regions.iter()\n-                               .filter(|&&r| !placeholder_resolution_map.contains_key(r))\n-                               .cloned()\n-                               .next()\n-                               .unwrap_or_else(|| {\n-                                   bug!(\"no representative region for `{:?}` in `{:?}`\",\n-                                        placeholder, regions)\n-                               });\n-\n-                    (placeholder, representative)\n-                })\n-                .collect();\n-\n-            // Equate all the members of each placeholder set with the\n-            // representative.\n-            for (placeholder, &(_br, ref regions)) in &placeholder_resolution_map {\n-                let representative = &placeholder_representatives[placeholder];\n-                debug!(\"higher_ranked_match: \\\n-                        placeholder={:?} representative={:?} regions={:?}\",\n-                       placeholder, representative, regions);\n-                for region in regions.iter()\n-                                     .filter(|&r| !placeholder_resolution_map.contains_key(r))\n-                                     .filter(|&r| r != representative)\n-                {\n-                    let origin = SubregionOrigin::Subtype(self.trace.clone());\n-                    self.infcx.borrow_region_constraints()\n-                              .make_eqregion(origin,\n-                                             *representative,\n-                                             *region);\n-                }\n-            }\n-\n-            // Replace the placeholder regions appearing in value with\n-            // their representatives\n-            let a_value =\n-                fold_regions_in(\n-                    self.tcx(),\n-                    &a_value,\n-                    |r, _| placeholder_representatives.get(&r).cloned().unwrap_or(r));\n-\n-            debug!(\"higher_ranked_match: value={:?}\", a_value);\n-\n-            // We are now done with these placeholder variables.\n-            self.infcx.pop_placeholders(placeholder_map, snapshot);\n-\n-            Ok(HrMatchResult { value: a_value })\n-        });\n+        Ok(ty::Binder::bind(result))\n     }\n }\n \n-fn fold_regions_in<'a, 'gcx, 'tcx, T, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                         unbound_value: &T,\n-                                         mut fldr: F)\n-                                         -> T\n-    where T: TypeFoldable<'tcx>,\n-          F: FnMut(ty::Region<'tcx>, ty::DebruijnIndex) -> ty::Region<'tcx>,\n-{\n-    tcx.fold_regions(unbound_value, &mut false, |region, current_depth| {\n-        // we should only be encountering \"escaping\" late-bound regions here,\n-        // because the ones at the current level should have been replaced\n-        // with fresh variables\n-        assert!(match *region {\n-            ty::ReLateBound(..) => false,\n-            _ => true\n-        });\n-\n-        fldr(region, current_depth)\n-    })\n-}\n-\n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    fn tainted_regions(&self,\n-                       snapshot: &CombinedSnapshot<'a, 'tcx>,\n-                       r: ty::Region<'tcx>,\n-                       directions: TaintDirections)\n-                       -> FxHashSet<ty::Region<'tcx>> {\n-        self.borrow_region_constraints().tainted(\n-            self.tcx,\n-            &snapshot.region_constraints_snapshot,\n-            r,\n-            directions)\n-    }\n-\n-    fn region_vars_confined_to_snapshot(&self,\n-                                        snapshot: &CombinedSnapshot<'a, 'tcx>)\n-                                        -> Vec<ty::RegionVid>\n-    {\n-        /*!\n-         * Returns the set of region variables that do not affect any\n-         * types/regions which existed before `snapshot` was\n-         * started. This is used in the sub/lub/glb computations. The\n-         * idea here is that when we are computing lub/glb of two\n-         * regions, we sometimes create intermediate region variables.\n-         * Those region variables may touch some of the placeholder or\n-         * other \"forbidden\" regions we created to replace bound\n-         * regions, but they don't really represent an \"external\"\n-         * constraint.\n-         *\n-         * However, sometimes fresh variables are created for other\n-         * purposes too, and those *may* represent an external\n-         * constraint. In particular, when a type variable is\n-         * instantiated, we create region variables for all the\n-         * regions that appear within, and if that type variable\n-         * pre-existed the snapshot, then those region variables\n-         * represent external constraints.\n-         *\n-         * An example appears in the unit test\n-         * `sub_free_bound_false_infer`.  In this test, we want to\n-         * know whether\n-         *\n-         * ```rust\n-         * fn(_#0t) <: for<'a> fn(&'a int)\n-         * ```\n-         *\n-         * Note that the subtype has a type variable. Because the type\n-         * variable can't be instantiated with a region that is bound\n-         * in the fn signature, this comparison ought to fail. But if\n-         * we're not careful, it will succeed.\n-         *\n-         * The reason is that when we walk through the subtyping\n-         * algorithm, we begin by replacing `'a` with a placeholder\n-         * variable `'1`. We then have `fn(_#0t) <: fn(&'1 int)`. This\n-         * can be made true by unifying `_#0t` with `&'1 int`. In the\n-         * process, we create a fresh variable for the placeholder\n-         * region, `'$2`, and hence we have that `_#0t == &'$2\n-         * int`. However, because `'$2` was created during the sub\n-         * computation, if we're not careful we will erroneously\n-         * assume it is one of the transient region variables\n-         * representing a lub/glb internally. Not good.\n-         *\n-         * To prevent this, we check for type variables which were\n-         * unified during the snapshot, and say that any region\n-         * variable created during the snapshot but which finds its\n-         * way into a type variable is considered to \"escape\" the\n-         * snapshot.\n-         */\n-\n-        let mut region_vars =\n-            self.borrow_region_constraints().vars_created_since_snapshot(\n-                &snapshot.region_constraints_snapshot);\n-\n-        let escaping_types =\n-            self.type_variables.borrow_mut().types_escaping_snapshot(&snapshot.type_snapshot);\n-\n-        let mut escaping_region_vars = FxHashSet::default();\n-        for ty in &escaping_types {\n-            self.tcx.collect_regions(ty, &mut escaping_region_vars);\n-        }\n-\n-        region_vars.retain(|&region_vid| {\n-            let r = ty::ReVar(region_vid);\n-            !escaping_region_vars.contains(&r)\n-        });\n-\n-        debug!(\"region_vars_confined_to_snapshot: region_vars={:?} escaping_types={:?}\",\n-               region_vars,\n-               escaping_types);\n-\n-        region_vars\n-    }\n-\n     /// Replace all regions (resp. types) bound by `binder` with placeholder\n     /// regions (resp. types) and return a map indicating which bound-region\n-    /// was replaced with what placeholder region. This is the first step of\n-    /// checking subtyping when higher-ranked things are involved.\n+    /// placeholder region. This is the first step of checking subtyping\n+    /// when higher-ranked things are involved.\n     ///\n     /// **Important:** you must call this function from within a snapshot.\n     /// Moreover, before committing the snapshot, you must eventually call\n@@ -354,201 +104,4 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         (result, map)\n     }\n-\n-    /// Searches the region constraints created since `snapshot` was started\n-    /// and checks to determine whether any of the placeholder regions created\n-    /// in `placeholder_map` would \"escape\" -- meaning that they are related to\n-    /// other regions in some way. If so, the higher-ranked subtyping doesn't\n-    /// hold. See `README.md` for more details.\n-    pub fn leak_check(&self,\n-                      overly_polymorphic: bool,\n-                      _span: Span,\n-                      placeholder_map: &PlaceholderMap<'tcx>,\n-                      snapshot: &CombinedSnapshot<'a, 'tcx>)\n-                      -> RelateResult<'tcx, ()>\n-    {\n-        debug!(\"leak_check: placeholder_map={:?}\",\n-               placeholder_map);\n-\n-        // If the user gave `-Zno-leak-check`, then skip the leak\n-        // check completely. This is wildly unsound and also not\n-        // unlikely to cause an ICE or two. It is intended for use\n-        // only during a transition period, in which the MIR typeck\n-        // uses the \"universe-style\" check, and the rest of typeck\n-        // uses the more conservative leak check.  Since the leak\n-        // check is more conservative, we can't test the\n-        // universe-style check without disabling it.\n-        if self.tcx.sess.opts.debugging_opts.no_leak_check {\n-            return Ok(());\n-        }\n-\n-        let new_vars = self.region_vars_confined_to_snapshot(snapshot);\n-        for (&placeholder_br, &placeholder) in placeholder_map {\n-            // The inputs to a placeholder variable can only\n-            // be itself or other new variables.\n-            let incoming_taints = self.tainted_regions(snapshot,\n-                                                       placeholder,\n-                                                       TaintDirections::both());\n-            for &tainted_region in &incoming_taints {\n-                // Each placeholder should only be relatable to itself\n-                // or new variables:\n-                match *tainted_region {\n-                    ty::ReVar(vid) => {\n-                        if new_vars.contains(&vid) {\n-                            continue;\n-                        }\n-                    }\n-                    _ => {\n-                        if tainted_region == placeholder { continue; }\n-                    }\n-                };\n-\n-                debug!(\"{:?} (which replaced {:?}) is tainted by {:?}\",\n-                       placeholder,\n-                       placeholder_br,\n-                       tainted_region);\n-\n-                return Err(if overly_polymorphic {\n-                    debug!(\"Overly polymorphic!\");\n-                    TypeError::RegionsOverlyPolymorphic(placeholder_br, tainted_region)\n-                } else {\n-                    debug!(\"Not as polymorphic!\");\n-                    TypeError::RegionsInsufficientlyPolymorphic(placeholder_br, tainted_region)\n-                })\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n-    /// This code converts from placeholder regions back to late-bound\n-    /// regions. It works by replacing each region in the taint set of a\n-    /// placeholder region with a bound-region. The bound region will be bound\n-    /// by the outer-most binder in `value`; the caller must ensure that there is\n-    /// such a binder and it is the right place.\n-    ///\n-    /// This routine is only intended to be used when the leak-check has\n-    /// passed; currently, it's used in the trait matching code to create\n-    /// a set of nested obligations from an impl that matches against\n-    /// something higher-ranked.  More details can be found in\n-    /// `librustc/middle/traits/README.md`.\n-    ///\n-    /// As a brief example, consider the obligation `for<'a> Fn(&'a int)\n-    /// -> &'a int`, and the impl:\n-    ///\n-    ///     impl<A,R> Fn<A,R> for SomethingOrOther\n-    ///         where A : Clone\n-    ///     { ... }\n-    ///\n-    /// Here we will have replaced `'a` with a placeholder region\n-    /// `'0`. This means that our substitution will be `{A=>&'0\n-    /// int, R=>&'0 int}`.\n-    ///\n-    /// When we apply the substitution to the bounds, we will wind up with\n-    /// `&'0 int : Clone` as a predicate. As a last step, we then go and\n-    /// replace `'0` with a late-bound region `'a`.  The depth is matched\n-    /// to the depth of the predicate, in this case 1, so that the final\n-    /// predicate is `for<'a> &'a int : Clone`.\n-    pub fn plug_leaks<T>(&self,\n-                         placeholder_map: PlaceholderMap<'tcx>,\n-                         snapshot: &CombinedSnapshot<'a, 'tcx>,\n-                         value: T) -> T\n-        where T : TypeFoldable<'tcx>\n-    {\n-        debug!(\"plug_leaks(placeholder_map={:?}, value={:?})\",\n-               placeholder_map,\n-               value);\n-\n-        if placeholder_map.is_empty() {\n-            return value;\n-        }\n-\n-        // Compute a mapping from the \"taint set\" of each placeholder\n-        // region back to the `ty::BoundRegion` that it originally\n-        // represented. Because `leak_check` passed, we know that\n-        // these taint sets are mutually disjoint.\n-        let inv_placeholder_map: FxHashMap<ty::Region<'tcx>, ty::BoundRegion> =\n-            placeholder_map\n-            .iter()\n-            .flat_map(|(&placeholder_br, &placeholder)| {\n-                self.tainted_regions(snapshot, placeholder, TaintDirections::both())\n-                    .into_iter()\n-                    .map(move |tainted_region| (tainted_region, placeholder_br))\n-            })\n-            .collect();\n-\n-        debug!(\"plug_leaks: inv_placeholder_map={:?}\",\n-               inv_placeholder_map);\n-\n-        // Remove any instantiated type variables from `value`; those can hide\n-        // references to regions from the `fold_regions` code below.\n-        let value = self.resolve_type_vars_if_possible(&value);\n-\n-        // Map any placeholder byproducts back to a late-bound\n-        // region. Put that late-bound region at whatever the outermost\n-        // binder is that we encountered in `value`. The caller is\n-        // responsible for ensuring that (a) `value` contains at least one\n-        // binder and (b) that binder is the one we want to use.\n-        let result = self.tcx.fold_regions(&value, &mut false, |r, current_depth| {\n-            match inv_placeholder_map.get(&r) {\n-                None => r,\n-                Some(br) => {\n-                    // It is the responsibility of the caller to ensure\n-                    // that each placeholder region appears within a\n-                    // binder. In practice, this routine is only used by\n-                    // trait checking, and all of the placeholder regions\n-                    // appear inside predicates, which always have\n-                    // binders, so this assert is satisfied.\n-                    assert!(current_depth > ty::INNERMOST);\n-\n-                    // since leak-check passed, this placeholder region\n-                    // should only have incoming edges from variables\n-                    // (which ought not to escape the snapshot, but we\n-                    // don't check that) or itself\n-                    assert!(\n-                        match *r {\n-                            ty::ReVar(_) => true,\n-                            ty::RePlaceholder(index) => index.name == *br,\n-                            _ => false,\n-                        },\n-                        \"leak-check would have us replace {:?} with {:?}\",\n-                        r, br);\n-\n-                    self.tcx.mk_region(ty::ReLateBound(\n-                        current_depth.shifted_out(1),\n-                        br.clone(),\n-                    ))\n-                }\n-            }\n-        });\n-\n-        self.pop_placeholders(placeholder_map, snapshot);\n-\n-        debug!(\"plug_leaks: result={:?}\", result);\n-\n-        result\n-    }\n-\n-    /// Pops the placeholder regions found in `placeholder_map` from the region\n-    /// inference context. Whenever you create placeholder regions via\n-    /// `replace_bound_vars_with_placeholders`, they must be popped before you\n-    /// commit the enclosing snapshot (if you do not commit, e.g., within a\n-    /// probe or as a result of an error, then this is not necessary, as\n-    /// popping happens as part of the rollback).\n-    ///\n-    /// Note: popping also occurs implicitly as part of `leak_check`.\n-    pub fn pop_placeholders(\n-        &self,\n-        placeholder_map: PlaceholderMap<'tcx>,\n-        snapshot: &CombinedSnapshot<'a, 'tcx>,\n-    ) {\n-        debug!(\"pop_placeholders({:?})\", placeholder_map);\n-        let placeholder_regions: FxHashSet<_> = placeholder_map.values().cloned().collect();\n-        self.borrow_region_constraints().pop_placeholders(&placeholder_regions);\n-        self.universe.set(snapshot.universe);\n-        if !placeholder_map.is_empty() {\n-            self.projection_cache.borrow_mut().rollback_placeholder(\n-                &snapshot.projection_cache_snapshot);\n-        }\n-    }\n }"}, {"sha": "bbab17f95165958482c71a2fa0ae881a7aacffc4", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 36, "deletions": 5, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b68fad670bb3612cac26e50751e4fd9150e59977/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b68fad670bb3612cac26e50751e4fd9150e59977/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=b68fad670bb3612cac26e50751e4fd9150e59977", "patch": "@@ -215,23 +215,41 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n     ) -> bool {\n         debug!(\"expand_node({:?}, {:?} == {:?})\", a_region, b_vid, b_data);\n \n-        // Check if this relationship is implied by a given.\n         match *a_region {\n+            // Check if this relationship is implied by a given.\n             ty::ReEarlyBound(_) | ty::ReFree(_) => if self.data.givens.contains(&(a_region, b_vid))\n             {\n                 debug!(\"given\");\n                 return false;\n             },\n+\n             _ => {}\n         }\n \n+\n         match *b_data {\n             VarValue::Value(cur_region) => {\n-                let lub = self.lub_concrete_regions(a_region, cur_region);\n+                let mut lub = self.lub_concrete_regions(a_region, cur_region);\n                 if lub == cur_region {\n                     return false;\n                 }\n \n+                // Watch out for `'b: !1` relationships, where the\n+                // universe of `'b` can't name the placeholder `!1`. In\n+                // that case, we have to grow `'b` to be `'static` for the\n+                // relationship to hold. This is obviously a kind of sub-optimal\n+                // choice -- in the future, when we incorporate a knowledge\n+                // of the parameter environment, we might be able to find a\n+                // tighter bound than `'static`.\n+                //\n+                // (This might e.g. arise from being asked to prove `for<'a> { 'b: 'a }`.)\n+                let b_universe = self.var_infos[b_vid].universe;\n+                if let ty::RePlaceholder(p) = lub {\n+                    if b_universe.cannot_name(p.universe) {\n+                        lub = self.tcx().types.re_static;\n+                    }\n+                }\n+\n                 debug!(\n                     \"Expanding value of {:?} from {:?} to {:?}\",\n                     b_vid, cur_region, lub\n@@ -554,10 +572,22 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n         lower_bounds.sort_by_key(region_order_key);\n         upper_bounds.sort_by_key(region_order_key);\n \n+        let node_universe = self.var_infos[node_idx].universe;\n+\n         for lower_bound in &lower_bounds {\n+            let effective_lower_bound = if let ty::RePlaceholder(p) = lower_bound.region {\n+                if node_universe.cannot_name(p.universe) {\n+                    self.tcx().types.re_static\n+                } else {\n+                    lower_bound.region\n+                }\n+            } else {\n+                lower_bound.region\n+            };\n+\n             for upper_bound in &upper_bounds {\n                 if !self.region_rels\n-                    .is_subregion_of(lower_bound.region, upper_bound.region)\n+                    .is_subregion_of(effective_lower_bound, upper_bound.region)\n                 {\n                     let origin = self.var_infos[node_idx].origin.clone();\n                     debug!(\n@@ -580,9 +610,10 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n         span_bug!(\n             self.var_infos[node_idx].origin.span(),\n             \"collect_error_for_expanding_node() could not find \\\n-             error for var {:?}, lower_bounds={:?}, \\\n-             upper_bounds={:?}\",\n+             error for var {:?} in universe {:?}, lower_bounds={:#?}, \\\n+             upper_bounds={:#?}\",\n             node_idx,\n+            node_universe,\n             lower_bounds,\n             upper_bounds\n         );"}, {"sha": "3b9affa6ffb507e64d2b2378c658ebfc558c9aa2", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 19, "deletions": 67, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/b68fad670bb3612cac26e50751e4fd9150e59977/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b68fad670bb3612cac26e50751e4fd9150e59977/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=b68fad670bb3612cac26e50751e4fd9150e59977", "patch": "@@ -32,7 +32,6 @@ use ty::{FloatVid, IntVid, TyVid};\n use util::nodemap::FxHashMap;\n \n use self::combine::CombineFields;\n-use self::higher_ranked::HrMatchResult;\n use self::lexical_region_resolve::LexicalRegionResolutions;\n use self::outlives::env::OutlivesEnvironment;\n use self::region_constraints::{GenericKind, RegionConstraintData, VarInfos, VerifyBound};\n@@ -948,39 +947,32 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             return None;\n         }\n \n-        Some(self.commit_if_ok(|snapshot| {\n-            let (\n-                ty::SubtypePredicate {\n-                    a_is_expected,\n-                    a,\n-                    b,\n-                },\n-                placeholder_map,\n-            ) = self.replace_bound_vars_with_placeholders(predicate);\n+        let (\n+            ty::SubtypePredicate {\n+                a_is_expected,\n+                a,\n+                b,\n+            },\n+            _,\n+        ) = self.replace_bound_vars_with_placeholders(predicate);\n \n-            let cause_span = cause.span;\n-            let ok = self.at(cause, param_env).sub_exp(a_is_expected, a, b)?;\n-            self.leak_check(false, cause_span, &placeholder_map, snapshot)?;\n-            self.pop_placeholders(placeholder_map, snapshot);\n-            Ok(ok.unit())\n-        }))\n+        Some(\n+            self.at(cause, param_env)\n+                .sub_exp(a_is_expected, a, b)\n+                .map(|ok| ok.unit()),\n+        )\n     }\n \n     pub fn region_outlives_predicate(\n         &self,\n         cause: &traits::ObligationCause<'tcx>,\n         predicate: &ty::PolyRegionOutlivesPredicate<'tcx>,\n-    ) -> UnitResult<'tcx> {\n-        self.commit_if_ok(|snapshot| {\n-            let (ty::OutlivesPredicate(r_a, r_b), placeholder_map) =\n-                self.replace_bound_vars_with_placeholders(predicate);\n-            let origin = SubregionOrigin::from_obligation_cause(cause, || {\n-                RelateRegionParamBound(cause.span)\n-            });\n-            self.sub_regions(origin, r_b, r_a); // `b : a` ==> `a <= b`\n-            self.leak_check(false, cause.span, &placeholder_map, snapshot)?;\n-            Ok(self.pop_placeholders(placeholder_map, snapshot))\n-        })\n+    ) {\n+        let (ty::OutlivesPredicate(r_a, r_b), _) =\n+            self.replace_bound_vars_with_placeholders(predicate);\n+        let origin =\n+            SubregionOrigin::from_obligation_cause(cause, || RelateRegionParamBound(cause.span));\n+        self.sub_regions(origin, r_b, r_a); // `b : a` ==> `a <= b`\n     }\n \n     pub fn next_ty_var_id(&self, diverging: bool, origin: TypeVariableOrigin) -> TyVid {\n@@ -1389,46 +1381,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.replace_bound_vars(value, fld_r, fld_t)\n     }\n \n-    /// Given a higher-ranked projection predicate like:\n-    ///\n-    ///     for<'a> <T as Fn<&'a u32>>::Output = &'a u32\n-    ///\n-    /// and a target trait-ref like:\n-    ///\n-    ///     <T as Fn<&'x u32>>\n-    ///\n-    /// find a substitution `S` for the higher-ranked regions (here,\n-    /// `['a => 'x]`) such that the predicate matches the trait-ref,\n-    /// and then return the value (here, `&'a u32`) but with the\n-    /// substitution applied (hence, `&'x u32`).\n-    ///\n-    /// See `higher_ranked_match` in `higher_ranked/mod.rs` for more\n-    /// details.\n-    pub fn match_poly_projection_predicate(\n-        &self,\n-        cause: ObligationCause<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        match_a: ty::PolyProjectionPredicate<'tcx>,\n-        match_b: ty::TraitRef<'tcx>,\n-    ) -> InferResult<'tcx, HrMatchResult<Ty<'tcx>>> {\n-        let match_pair = match_a.map_bound(|p| (p.projection_ty.trait_ref(self.tcx), p.ty));\n-        let trace = TypeTrace {\n-            cause,\n-            values: TraitRefs(ExpectedFound::new(\n-                true,\n-                match_pair.skip_binder().0,\n-                match_b,\n-            )),\n-        };\n-\n-        let mut combine = self.combine_fields(trace, param_env);\n-        let result = combine.higher_ranked_match(&match_pair, &match_b, true)?;\n-        Ok(InferOk {\n-            value: result,\n-            obligations: combine.obligations,\n-        })\n-    }\n-\n     /// See `verify_generic_bound` method in `region_constraints`\n     pub fn verify_generic_bound(\n         &self,"}, {"sha": "b29eb67dfa225db98738f0c31889d55c9d0d44c0", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b68fad670bb3612cac26e50751e4fd9150e59977/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b68fad670bb3612cac26e50751e4fd9150e59977/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=b68fad670bb3612cac26e50751e4fd9150e59977", "patch": "@@ -17,8 +17,6 @@ use ty::{Region, RegionVid};\n use std::collections::BTreeMap;\n use std::{cmp, fmt, mem, u32};\n \n-mod taint;\n-\n #[derive(Default)]\n pub struct RegionConstraintCollector<'tcx> {\n     /// For each `RegionVid`, the corresponding `RegionVariableOrigin`.\n@@ -826,35 +824,6 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             .collect()\n     }\n \n-    /// Computes all regions that have been related to `r0` since the\n-    /// mark `mark` was made---`r0` itself will be the first\n-    /// entry. The `directions` parameter controls what kind of\n-    /// relations are considered. For example, one can say that only\n-    /// \"incoming\" edges to `r0` are desired, in which case one will\n-    /// get the set of regions `{r|r <= r0}`. This is used when\n-    /// checking whether placeholder regions are being improperly\n-    /// related to other regions.\n-    pub fn tainted(\n-        &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n-        mark: &RegionSnapshot,\n-        r0: Region<'tcx>,\n-        directions: TaintDirections,\n-    ) -> FxHashSet<ty::Region<'tcx>> {\n-        debug!(\n-            \"tainted(mark={:?}, r0={:?}, directions={:?})\",\n-            mark, r0, directions\n-        );\n-\n-        // `result_set` acts as a worklist: we explore all outgoing\n-        // edges and add any new regions we find to result_set.  This\n-        // is not a terribly efficient implementation.\n-        let mut taint_set = taint::TaintSet::new(directions, r0);\n-        taint_set.fixed_point(tcx, &self.undo_log[mark.length..], &self.data.verifys);\n-        debug!(\"tainted: result={:?}\", taint_set);\n-        return taint_set.into_set();\n-    }\n-\n     pub fn region_constraints_added_in_snapshot(&self, mark: &RegionSnapshot) -> bool {\n         self.undo_log[mark.length..]\n             .iter()"}, {"sha": "6743f37972ae52b8cb36b7a87c590ee50aea934c", "filename": "src/librustc/infer/region_constraints/taint.rs", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/eba2ae526b2624c76bdb9fea41f88d2c1740c722/src%2Flibrustc%2Finfer%2Fregion_constraints%2Ftaint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba2ae526b2624c76bdb9fea41f88d2c1740c722/src%2Flibrustc%2Finfer%2Fregion_constraints%2Ftaint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Ftaint.rs?ref=eba2ae526b2624c76bdb9fea41f88d2c1740c722", "patch": "@@ -1,85 +0,0 @@\n-use super::*;\n-\n-#[derive(Debug)]\n-pub(super) struct TaintSet<'tcx> {\n-    directions: TaintDirections,\n-    regions: FxHashSet<ty::Region<'tcx>>,\n-}\n-\n-impl<'tcx> TaintSet<'tcx> {\n-    pub(super) fn new(directions: TaintDirections, initial_region: ty::Region<'tcx>) -> Self {\n-        let mut regions = FxHashSet::default();\n-        regions.insert(initial_region);\n-        TaintSet {\n-            directions: directions,\n-            regions: regions,\n-        }\n-    }\n-\n-    pub(super) fn fixed_point(\n-        &mut self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n-        undo_log: &[UndoLog<'tcx>],\n-        verifys: &[Verify<'tcx>],\n-    ) {\n-        let mut prev_len = 0;\n-        while prev_len < self.len() {\n-            debug!(\n-                \"tainted: prev_len = {:?} new_len = {:?}\",\n-                prev_len,\n-                self.len()\n-            );\n-\n-            prev_len = self.len();\n-\n-            for undo_entry in undo_log {\n-                match undo_entry {\n-                    &AddConstraint(Constraint::VarSubVar(a, b)) => {\n-                        self.add_edge(tcx.mk_region(ReVar(a)), tcx.mk_region(ReVar(b)));\n-                    }\n-                    &AddConstraint(Constraint::RegSubVar(a, b)) => {\n-                        self.add_edge(a, tcx.mk_region(ReVar(b)));\n-                    }\n-                    &AddConstraint(Constraint::VarSubReg(a, b)) => {\n-                        self.add_edge(tcx.mk_region(ReVar(a)), b);\n-                    }\n-                    &AddConstraint(Constraint::RegSubReg(a, b)) => {\n-                        self.add_edge(a, b);\n-                    }\n-                    &AddGiven(a, b) => {\n-                        self.add_edge(a, tcx.mk_region(ReVar(b)));\n-                    }\n-                    &AddVerify(i) => {\n-                        span_bug!(\n-                            verifys[i].origin.span(),\n-                            \"we never add verifications while doing higher-ranked things\",\n-                        )\n-                    }\n-                    &Purged | &AddCombination(..) | &AddVar(..) => {}\n-                }\n-            }\n-        }\n-    }\n-\n-    pub(super) fn into_set(self) -> FxHashSet<ty::Region<'tcx>> {\n-        self.regions\n-    }\n-\n-    fn len(&self) -> usize {\n-        self.regions.len()\n-    }\n-\n-    fn add_edge(&mut self, source: ty::Region<'tcx>, target: ty::Region<'tcx>) {\n-        if self.directions.incoming {\n-            if self.regions.contains(&target) {\n-                self.regions.insert(source);\n-            }\n-        }\n-\n-        if self.directions.outgoing {\n-            if self.regions.contains(&source) {\n-                self.regions.insert(target);\n-            }\n-        }\n-    }\n-}"}, {"sha": "92004ece26d004a30ade168bbe7a3afd5a36a432", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b68fad670bb3612cac26e50751e4fd9150e59977/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b68fad670bb3612cac26e50751e4fd9150e59977/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=b68fad670bb3612cac26e50751e4fd9150e59977", "patch": "@@ -771,13 +771,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     }\n                 }\n                 &ty::Predicate::RegionOutlives(ref binder) => {\n-                    if select\n-                        .infcx()\n-                        .region_outlives_predicate(&dummy_cause, binder)\n-                        .is_err()\n-                    {\n-                        return false;\n-                    }\n+                    let () = select.infcx().region_outlives_predicate(&dummy_cause, binder);\n                 }\n                 &ty::Predicate::TypeOutlives(ref binder) => {\n                     match ("}, {"sha": "21352ac1053a8e7c4cc106f3c64025d68284efb6", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b68fad670bb3612cac26e50751e4fd9150e59977/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b68fad670bb3612cac26e50751e4fd9150e59977/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=b68fad670bb3612cac26e50751e4fd9150e59977", "patch": "@@ -728,12 +728,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     }\n \n                     ty::Predicate::RegionOutlives(ref predicate) => {\n-                        let predicate = self.resolve_type_vars_if_possible(predicate);\n-                        let err = self.region_outlives_predicate(&obligation.cause,\n-                                                                 &predicate).err().unwrap();\n-                        struct_span_err!(self.tcx.sess, span, E0279,\n-                            \"the requirement `{}` is not satisfied (`{}`)\",\n-                            predicate, err)\n+                        // These errors should show up as region\n+                        // inference failures.\n+                        panic!(\"region outlives {:?} failed\", predicate);\n                     }\n \n                     ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {"}, {"sha": "2e00d4d4b7c3bda796d77f380c4d2b7e15926039", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b68fad670bb3612cac26e50751e4fd9150e59977/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b68fad670bb3612cac26e50751e4fd9150e59977/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=b68fad670bb3612cac26e50751e4fd9150e59977", "patch": "@@ -331,10 +331,8 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n             }\n \n             ty::Predicate::RegionOutlives(ref binder) => {\n-                match self.selcx.infcx().region_outlives_predicate(&obligation.cause, binder) {\n-                    Ok(()) => ProcessResult::Changed(vec![]),\n-                    Err(_) => ProcessResult::Error(CodeSelectionError(Unimplemented)),\n-                }\n+                let () = self.selcx.infcx().region_outlives_predicate(&obligation.cause, binder);\n+                ProcessResult::Changed(vec![])\n             }\n \n             ty::Predicate::TypeOutlives(ref binder) => {"}, {"sha": "732ca70dc78c5e111b3711807ffae6727ae69fe2", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b68fad670bb3612cac26e50751e4fd9150e59977/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b68fad670bb3612cac26e50751e4fd9150e59977/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=b68fad670bb3612cac26e50751e4fd9150e59977", "patch": "@@ -13,7 +13,7 @@ use super::{VtableImplData, VtableClosureData, VtableGeneratorData, VtableFnPoin\n use super::util;\n \n use hir::def_id::DefId;\n-use infer::{InferCtxt, InferOk};\n+use infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use infer::type_variable::TypeVariableOrigin;\n use mir::interpret::ConstValue;\n use mir::interpret::{GlobalId};\n@@ -192,28 +192,12 @@ pub fn poly_project_and_unify_type<'cx, 'gcx, 'tcx>(\n            obligation);\n \n     let infcx = selcx.infcx();\n-    infcx.commit_if_ok(|snapshot| {\n-        let (placeholder_predicate, placeholder_map) =\n+    infcx.commit_if_ok(|_| {\n+        let (placeholder_predicate, _) =\n             infcx.replace_bound_vars_with_placeholders(&obligation.predicate);\n \n-        let skol_obligation = obligation.with(placeholder_predicate);\n-        let r = match project_and_unify_type(selcx, &skol_obligation) {\n-            Ok(result) => {\n-                let span = obligation.cause.span;\n-                match infcx.leak_check(false, span, &placeholder_map, snapshot) {\n-                    Ok(()) => Ok(infcx.plug_leaks(placeholder_map, snapshot, result)),\n-                    Err(e) => {\n-                        debug!(\"poly_project_and_unify_type: leak check encountered error {:?}\", e);\n-                        Err(MismatchedProjectionTypes { err: e })\n-                    }\n-                }\n-            }\n-            Err(e) => {\n-                Err(e)\n-            }\n-        };\n-\n-        r\n+        let placeholder_obligation = obligation.with(placeholder_predicate);\n+        project_and_unify_type(selcx, &placeholder_obligation)\n     })\n }\n \n@@ -1443,17 +1427,25 @@ fn confirm_callable_candidate<'cx, 'gcx, 'tcx>(\n fn confirm_param_env_candidate<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    poly_projection: ty::PolyProjectionPredicate<'tcx>)\n+    poly_cache_entry: ty::PolyProjectionPredicate<'tcx>)\n     -> Progress<'tcx>\n {\n     let infcx = selcx.infcx();\n-    let cause = obligation.cause.clone();\n+    let cause = &obligation.cause;\n     let param_env = obligation.param_env;\n-    let trait_ref = obligation.predicate.trait_ref(infcx.tcx);\n-    match infcx.match_poly_projection_predicate(cause, param_env, poly_projection, trait_ref) {\n-        Ok(InferOk { value: ty_match, obligations }) => {\n+\n+    let (cache_entry, _) =\n+        infcx.replace_bound_vars_with_fresh_vars(\n+            cause.span,\n+            LateBoundRegionConversionTime::HigherRankedType,\n+            &poly_cache_entry);\n+\n+    let cache_trait_ref = cache_entry.projection_ty.trait_ref(infcx.tcx);\n+    let obligation_trait_ref = obligation.predicate.trait_ref(infcx.tcx);\n+    match infcx.at(cause, param_env).eq(cache_trait_ref, obligation_trait_ref) {\n+        Ok(InferOk { value: _, obligations }) => {\n             Progress {\n-                ty: ty_match.value,\n+                ty: cache_entry.ty,\n                 obligations,\n             }\n         }\n@@ -1463,7 +1455,7 @@ fn confirm_param_env_candidate<'cx, 'gcx, 'tcx>(\n                 \"Failed to unify obligation `{:?}` \\\n                  with poly_projection `{:?}`: {:?}\",\n                 obligation,\n-                poly_projection,\n+                poly_cache_entry,\n                 e);\n         }\n     }"}, {"sha": "f5e96286d184ed5e9041673e3b688b656cffbb90", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 33, "deletions": 89, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/b68fad670bb3612cac26e50751e4fd9150e59977/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b68fad670bb3612cac26e50751e4fd9150e59977/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=b68fad670bb3612cac26e50751e4fd9150e59977", "patch": "@@ -29,7 +29,7 @@ use super::{\n \n use dep_graph::{DepKind, DepNodeIndex};\n use hir::def_id::DefId;\n-use infer::{self, InferCtxt, InferOk, TypeFreshener};\n+use infer::{InferCtxt, InferOk, TypeFreshener};\n use middle::lang_items;\n use mir::interpret::GlobalId;\n use ty::fast_reject;\n@@ -44,7 +44,6 @@ use rustc_target::spec::abi::Abi;\n use std::cmp;\n use std::fmt;\n use std::iter;\n-use std::mem;\n use std::rc::Rc;\n use util::nodemap::{FxHashMap, FxHashSet};\n \n@@ -1633,8 +1632,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             _ => return,\n         }\n \n-        let result = self.infcx.probe(|snapshot| {\n-            self.match_projection_obligation_against_definition_bounds(obligation, snapshot)\n+        let result = self.infcx.probe(|_| {\n+            self.match_projection_obligation_against_definition_bounds(obligation)\n         });\n \n         if result {\n@@ -1645,16 +1644,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn match_projection_obligation_against_definition_bounds(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-        snapshot: &infer::CombinedSnapshot<'cx, 'tcx>,\n     ) -> bool {\n         let poly_trait_predicate = self.infcx()\n             .resolve_type_vars_if_possible(&obligation.predicate);\n-        let (skol_trait_predicate, placeholder_map) = self.infcx()\n+        let (skol_trait_predicate, _) = self.infcx()\n             .replace_bound_vars_with_placeholders(&poly_trait_predicate);\n         debug!(\n             \"match_projection_obligation_against_definition_bounds: \\\n-             skol_trait_predicate={:?} placeholder_map={:?}\",\n-            skol_trait_predicate, placeholder_map\n+             skol_trait_predicate={:?}\",\n+            skol_trait_predicate,\n         );\n \n         let (def_id, substs) = match skol_trait_predicate.trait_ref.self_ty().sty {\n@@ -1691,8 +1689,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         obligation,\n                         bound.clone(),\n                         skol_trait_predicate.trait_ref.clone(),\n-                        &placeholder_map,\n-                        snapshot,\n                     )\n                 })\n             });\n@@ -1710,12 +1706,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     obligation,\n                     bound,\n                     skol_trait_predicate.trait_ref.clone(),\n-                    &placeholder_map,\n-                    snapshot,\n                 );\n \n-                self.infcx.pop_placeholders(placeholder_map, snapshot);\n-\n                 assert!(result);\n                 true\n             }\n@@ -1727,20 +1719,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         trait_bound: ty::PolyTraitRef<'tcx>,\n         skol_trait_ref: ty::TraitRef<'tcx>,\n-        placeholder_map: &infer::PlaceholderMap<'tcx>,\n-        snapshot: &infer::CombinedSnapshot<'cx, 'tcx>,\n     ) -> bool {\n         debug_assert!(!skol_trait_ref.has_escaping_bound_vars());\n-        if self.infcx\n+        self.infcx\n             .at(&obligation.cause, obligation.param_env)\n             .sup(ty::Binder::dummy(skol_trait_ref), trait_bound)\n-            .is_err()\n-        {\n-            return false;\n-        }\n-\n-        self.infcx\n-            .leak_check(false, obligation.cause.span, placeholder_map, snapshot)\n             .is_ok()\n     }\n \n@@ -1942,14 +1925,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             obligation.predicate.def_id(),\n             obligation.predicate.skip_binder().trait_ref.self_ty(),\n             |impl_def_id| {\n-                self.infcx.probe(|snapshot| {\n-                    if let Ok(placeholder_map) = self.match_impl(impl_def_id, obligation, snapshot)\n+                self.infcx.probe(|_| {\n+                    if let Ok(_substs) = self.match_impl(impl_def_id, obligation)\n                     {\n                         candidates.vec.push(ImplCandidate(impl_def_id));\n-\n-                        // N.B., we can safely drop the placeholder map\n-                        // since we are in a probe.\n-                        mem::drop(placeholder_map);\n                     }\n                 });\n             },\n@@ -2607,8 +2586,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // binder moved -\\\n                 let ty: ty::Binder<Ty<'tcx>> = ty::Binder::bind(ty); // <----/\n \n-                self.infcx.in_snapshot(|snapshot| {\n-                    let (skol_ty, placeholder_map) = self.infcx\n+                self.infcx.in_snapshot(|_| {\n+                    let (skol_ty, _) = self.infcx\n                         .replace_bound_vars_with_placeholders(&ty);\n                     let Normalized {\n                         value: normalized_ty,\n@@ -2629,8 +2608,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         &[],\n                     );\n                     obligations.push(skol_obligation);\n-                    self.infcx\n-                        .plug_leaks(placeholder_map, snapshot, obligations)\n+                    obligations\n                 })\n             })\n             .collect()\n@@ -2721,9 +2699,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     }\n \n     fn confirm_projection_candidate(&mut self, obligation: &TraitObligation<'tcx>) {\n-        self.infcx.in_snapshot(|snapshot| {\n+        self.infcx.in_snapshot(|_| {\n             let result =\n-                self.match_projection_obligation_against_definition_bounds(obligation, snapshot);\n+                self.match_projection_obligation_against_definition_bounds(obligation);\n             assert!(result);\n         })\n     }\n@@ -2840,9 +2818,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             nested,\n         );\n \n-        let trait_obligations: Vec<PredicateObligation<'_>> = self.infcx.in_snapshot(|snapshot| {\n+        let trait_obligations: Vec<PredicateObligation<'_>> = self.infcx.in_snapshot(|_| {\n             let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n-            let (trait_ref, placeholder_map) = self.infcx\n+            let (trait_ref, _) = self.infcx\n                 .replace_bound_vars_with_placeholders(&poly_trait_ref);\n             let cause = obligation.derived_cause(ImplDerivedObligation);\n             self.impl_or_trait_obligations(\n@@ -2851,8 +2829,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 obligation.param_env,\n                 trait_def_id,\n                 &trait_ref.substs,\n-                placeholder_map,\n-                snapshot,\n             )\n         });\n \n@@ -2877,8 +2853,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         // First, create the substitutions by matching the impl again,\n         // this time not in a probe.\n-        self.infcx.in_snapshot(|snapshot| {\n-            let (substs, placeholder_map) = self.rematch_impl(impl_def_id, obligation, snapshot);\n+        self.infcx.in_snapshot(|_| {\n+            let substs = self.rematch_impl(impl_def_id, obligation);\n             debug!(\"confirm_impl_candidate: substs={:?}\", substs);\n             let cause = obligation.derived_cause(ImplDerivedObligation);\n             self.vtable_impl(\n@@ -2887,8 +2863,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 cause,\n                 obligation.recursion_depth + 1,\n                 obligation.param_env,\n-                placeholder_map,\n-                snapshot,\n             )\n         })\n     }\n@@ -2900,12 +2874,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         cause: ObligationCause<'tcx>,\n         recursion_depth: usize,\n         param_env: ty::ParamEnv<'tcx>,\n-        placeholder_map: infer::PlaceholderMap<'tcx>,\n-        snapshot: &infer::CombinedSnapshot<'cx, 'tcx>,\n     ) -> VtableImplData<'tcx, PredicateObligation<'tcx>> {\n         debug!(\n-            \"vtable_impl(impl_def_id={:?}, substs={:?}, recursion_depth={}, placeholder_map={:?})\",\n-            impl_def_id, substs, recursion_depth, placeholder_map\n+            \"vtable_impl(impl_def_id={:?}, substs={:?}, recursion_depth={})\",\n+            impl_def_id, substs, recursion_depth,\n         );\n \n         let mut impl_obligations = self.impl_or_trait_obligations(\n@@ -2914,8 +2886,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             param_env,\n             impl_def_id,\n             &substs.value,\n-            placeholder_map,\n-            snapshot,\n         );\n \n         debug!(\n@@ -3044,8 +3014,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             obligation, alias_def_id\n         );\n \n-        self.infcx.in_snapshot(|snapshot| {\n-            let (predicate, placeholder_map) = self.infcx\n+        self.infcx.in_snapshot(|_| {\n+            let (predicate, _) = self.infcx()\n                 .replace_bound_vars_with_placeholders(&obligation.predicate);\n             let trait_ref = predicate.trait_ref;\n             let trait_def_id = trait_ref.def_id;\n@@ -3057,8 +3027,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 obligation.param_env,\n                 trait_def_id,\n                 &substs,\n-                placeholder_map,\n-                snapshot,\n             );\n \n             debug!(\n@@ -3473,13 +3441,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         &mut self,\n         impl_def_id: DefId,\n         obligation: &TraitObligation<'tcx>,\n-        snapshot: &infer::CombinedSnapshot<'cx, 'tcx>,\n-    ) -> (\n-        Normalized<'tcx, &'tcx Substs<'tcx>>,\n-        infer::PlaceholderMap<'tcx>,\n-    ) {\n-        match self.match_impl(impl_def_id, obligation, snapshot) {\n-            Ok((substs, placeholder_map)) => (substs, placeholder_map),\n+    ) -> Normalized<'tcx, &'tcx Substs<'tcx>> {\n+        match self.match_impl(impl_def_id, obligation) {\n+            Ok(substs) => substs,\n             Err(()) => {\n                 bug!(\n                     \"Impl {:?} was matchable against {:?} but now is not\",\n@@ -3494,14 +3458,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         &mut self,\n         impl_def_id: DefId,\n         obligation: &TraitObligation<'tcx>,\n-        snapshot: &infer::CombinedSnapshot<'cx, 'tcx>,\n-    ) -> Result<\n-        (\n-            Normalized<'tcx, &'tcx Substs<'tcx>>,\n-            infer::PlaceholderMap<'tcx>,\n-        ),\n-        (),\n-    > {\n+    ) -> Result<Normalized<'tcx, &'tcx Substs<'tcx>>, ()> {\n         let impl_trait_ref = self.tcx().impl_trait_ref(impl_def_id).unwrap();\n \n         // Before we create the substitutions and everything, first\n@@ -3511,7 +3468,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return Err(());\n         }\n \n-        let (skol_obligation, placeholder_map) = self.infcx()\n+        let (skol_obligation, _) = self.infcx()\n             .replace_bound_vars_with_placeholders(&obligation.predicate);\n         let skol_obligation_trait_ref = skol_obligation.trait_ref;\n \n@@ -3543,22 +3500,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             .map_err(|e| debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e))?;\n         nested_obligations.extend(obligations);\n \n-        if let Err(e) =\n-            self.infcx\n-                .leak_check(false, obligation.cause.span, &placeholder_map, snapshot)\n-        {\n-            debug!(\"match_impl: failed leak check due to `{}`\", e);\n-            return Err(());\n-        }\n-\n         debug!(\"match_impl: success impl_substs={:?}\", impl_substs);\n-        Ok((\n-            Normalized {\n-                value: impl_substs,\n-                obligations: nested_obligations,\n-            },\n-            placeholder_map,\n-        ))\n+        Ok(Normalized {\n+            value: impl_substs,\n+            obligations: nested_obligations,\n+        })\n     }\n \n     fn fast_reject_trait_refs(\n@@ -3714,8 +3660,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         def_id: DefId,         // of impl or trait\n         substs: &Substs<'tcx>, // for impl or trait\n-        placeholder_map: infer::PlaceholderMap<'tcx>,\n-        snapshot: &infer::CombinedSnapshot<'cx, 'tcx>,\n     ) -> Vec<PredicateObligation<'tcx>> {\n         debug!(\"impl_or_trait_obligations(def_id={:?})\", def_id);\n         let tcx = self.tcx();\n@@ -3777,8 +3721,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             let mut seen = FxHashSet::default();\n             predicates.retain(|i| seen.insert(i.clone()));\n         }\n-        self.infcx()\n-            .plug_leaks(placeholder_map, snapshot, predicates)\n+\n+        predicates\n     }\n }\n "}]}