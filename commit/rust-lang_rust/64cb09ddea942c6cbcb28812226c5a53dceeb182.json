{"sha": "64cb09ddea942c6cbcb28812226c5a53dceeb182", "node_id": "C_kwDOAAsO6NoAKDY0Y2IwOWRkZWE5NDJjNmNiY2IyODgxMjIyNmM1YTUzZGNlZWIxODI", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-22T14:59:41Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-22T15:51:09Z"}, "message": "Add to macro testing infra to emit token map ids", "tree": {"sha": "89a84deeb25134bc1952acc2803cddb4ef7fadf8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89a84deeb25134bc1952acc2803cddb4ef7fadf8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64cb09ddea942c6cbcb28812226c5a53dceeb182", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64cb09ddea942c6cbcb28812226c5a53dceeb182", "html_url": "https://github.com/rust-lang/rust/commit/64cb09ddea942c6cbcb28812226c5a53dceeb182", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64cb09ddea942c6cbcb28812226c5a53dceeb182/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77f08d0fc3387beb63543510f0fbe47a516857b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/77f08d0fc3387beb63543510f0fbe47a516857b2", "html_url": "https://github.com/rust-lang/rust/commit/77f08d0fc3387beb63543510f0fbe47a516857b2"}], "stats": {"total": 168, "additions": 151, "deletions": 17}, "files": [{"sha": "c3116edc88e04d41665b6999d1d624a085b8bb3f", "filename": "crates/hir_def/src/macro_expansion_tests.rs", "status": "modified", "additions": 109, "deletions": 15, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/64cb09ddea942c6cbcb28812226c5a53dceeb182/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64cb09ddea942c6cbcb28812226c5a53dceeb182/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests.rs?ref=64cb09ddea942c6cbcb28812226c5a53dceeb182", "patch": "@@ -16,16 +16,21 @@ mod proc_macros;\n \n use std::{iter, ops::Range};\n \n+use ::mbe::TokenMap;\n use base_db::{fixture::WithFixture, SourceDatabase};\n use expect_test::Expect;\n-use hir_expand::{db::AstDatabase, InFile, MacroFile};\n+use hir_expand::{\n+    db::{AstDatabase, TokenExpander},\n+    AstId, InFile, MacroDefId, MacroDefKind, MacroFile,\n+};\n use stdx::format_to;\n use syntax::{\n     ast::{self, edit::IndentLevel},\n-    AstNode,\n-    SyntaxKind::{COMMENT, EOF, IDENT, LIFETIME_IDENT},\n-    SyntaxNode, T,\n+    AstNode, SyntaxElement,\n+    SyntaxKind::{self, COMMENT, EOF, IDENT, LIFETIME_IDENT},\n+    SyntaxNode, TextRange, T,\n };\n+use tt::{Subtree, TokenId};\n \n use crate::{\n     db::DefDatabase, nameres::ModuleSource, resolver::HasResolver, src::HasSource, test_db::TestDB,\n@@ -61,7 +66,47 @@ fn check(ra_fixture: &str, mut expect: Expect) {\n     // in the module and assume that, if impls's source is a different\n     // `HirFileId`, than it came from macro expansion.\n \n+    let mut text_edits = Vec::new();\n     let mut expansions = Vec::new();\n+\n+    for macro_ in source_file.syntax().descendants().filter_map(ast::Macro::cast) {\n+        let mut show_token_ids = false;\n+        for comment in macro_.syntax().children_with_tokens().filter(|it| it.kind() == COMMENT) {\n+            show_token_ids |= comment.to_string().contains(\"+tokenids\");\n+        }\n+        if !show_token_ids {\n+            continue;\n+        }\n+\n+        let call_offset = macro_.syntax().text_range().start().into();\n+        let file_ast_id = db.ast_id_map(source.file_id).ast_id(&macro_);\n+        let ast_id = AstId::new(source.file_id, file_ast_id.upcast());\n+        let kind = MacroDefKind::Declarative(ast_id);\n+\n+        let macro_def = db.macro_def(MacroDefId { krate, kind, local_inner: false }).unwrap();\n+        if let TokenExpander::DeclarativeMacro { mac, def_site_token_map } = &*macro_def {\n+            let tt = match &macro_ {\n+                ast::Macro::MacroRules(mac) => mac.token_tree().unwrap(),\n+                ast::Macro::MacroDef(_) => unimplemented!(\"\"),\n+            };\n+\n+            let tt_start = tt.syntax().text_range().start();\n+            tt.syntax().descendants_with_tokens().filter_map(SyntaxElement::into_token).for_each(\n+                |token| {\n+                    let range = token.text_range().checked_sub(tt_start).unwrap();\n+                    if let Some(id) = def_site_token_map.token_by_range(range) {\n+                        let offset = (range.end() + tt_start).into();\n+                        text_edits.push((offset..offset, format!(\"#{}\", id.0)));\n+                    }\n+                },\n+            );\n+            text_edits.push((\n+                call_offset..call_offset,\n+                format!(\"// call ids will be shifted by {:?}\\n\", mac.shift()),\n+            ));\n+        }\n+    }\n+\n     for macro_call in source_file.syntax().descendants().filter_map(ast::MacroCall::cast) {\n         let macro_call = InFile::new(source.file_id, &macro_call);\n         let mut error = None;\n@@ -77,24 +122,24 @@ fn check(ra_fixture: &str, mut expect: Expect) {\n         let macro_file = MacroFile { macro_call_id };\n         let mut expansion_result = db.parse_macro_expansion(macro_file);\n         expansion_result.err = expansion_result.err.or(error);\n-        expansions.push((macro_call.value.clone(), expansion_result));\n+        expansions.push((macro_call.value.clone(), expansion_result, db.macro_arg(macro_call_id)));\n     }\n \n-    let mut expanded_text = source_file.to_string();\n-\n-    for (call, exp) in expansions.into_iter().rev() {\n+    for (call, exp, arg) in expansions.into_iter().rev() {\n         let mut tree = false;\n         let mut expect_errors = false;\n+        let mut show_token_ids = false;\n         for comment in call.syntax().children_with_tokens().filter(|it| it.kind() == COMMENT) {\n             tree |= comment.to_string().contains(\"+tree\");\n             expect_errors |= comment.to_string().contains(\"+errors\");\n+            show_token_ids |= comment.to_string().contains(\"+tokenids\");\n         }\n \n         let mut expn_text = String::new();\n         if let Some(err) = exp.err {\n             format_to!(expn_text, \"/* error: {} */\", err);\n         }\n-        if let Some((parse, _token_map)) = exp.value {\n+        if let Some((parse, token_map)) = exp.value {\n             if expect_errors {\n                 assert!(!parse.errors().is_empty(), \"no parse errors in expansion\");\n                 for e in parse.errors() {\n@@ -107,7 +152,10 @@ fn check(ra_fixture: &str, mut expect: Expect) {\n                     parse.errors()\n                 );\n             }\n-            let pp = pretty_print_macro_expansion(parse.syntax_node());\n+            let pp = pretty_print_macro_expansion(\n+                parse.syntax_node(),\n+                show_token_ids.then(|| &*token_map),\n+            );\n             let indent = IndentLevel::from_node(call.syntax());\n             let pp = reindent(indent, pp);\n             format_to!(expn_text, \"{}\", pp);\n@@ -122,14 +170,41 @@ fn check(ra_fixture: &str, mut expect: Expect) {\n         }\n         let range = call.syntax().text_range();\n         let range: Range<usize> = range.into();\n-        expanded_text.replace_range(range, &expn_text)\n+\n+        if show_token_ids {\n+            if let Some((tree, map)) = arg.as_deref() {\n+                let tt_range = call.token_tree().unwrap().syntax().text_range();\n+                let mut ranges = Vec::new();\n+                extract_id_ranges(&mut ranges, &map, &tree);\n+                for (range, id) in ranges {\n+                    let idx = (tt_range.start() + range.end()).into();\n+                    text_edits.push((idx..idx, format!(\"#{}\", id.0)));\n+                }\n+            }\n+            text_edits.push((range.start..range.start, \"// \".into()));\n+            call.to_string().match_indices('\\n').for_each(|(offset, _)| {\n+                let offset = offset + 1 + range.start;\n+                text_edits.push((offset..offset, \"// \".into()));\n+            });\n+            text_edits.push((range.end..range.end, \"\\n\".into()));\n+            text_edits.push((range.end..range.end, expn_text));\n+        } else {\n+            text_edits.push((range, expn_text));\n+        }\n+    }\n+\n+    text_edits.sort_by_key(|(range, _)| range.start);\n+    text_edits.reverse();\n+    let mut expanded_text = source_file.to_string();\n+    for (range, text) in text_edits {\n+        expanded_text.replace_range(range, &text);\n     }\n \n     for decl_id in def_map[local_id].scope.declarations() {\n         if let ModuleDefId::AdtId(AdtId::StructId(struct_id)) = decl_id {\n             let src = struct_id.lookup(&db).source(&db);\n             if src.file_id.is_attr_macro(&db) || src.file_id.is_custom_derive(&db) {\n-                let pp = pretty_print_macro_expansion(src.value.syntax().clone());\n+                let pp = pretty_print_macro_expansion(src.value.syntax().clone(), None);\n                 format_to!(expanded_text, \"\\n{}\", pp)\n             }\n         }\n@@ -138,7 +213,7 @@ fn check(ra_fixture: &str, mut expect: Expect) {\n     for impl_id in def_map[local_id].scope.impls() {\n         let src = impl_id.lookup(&db).source(&db);\n         if src.file_id.is_builtin_derive(&db).is_some() {\n-            let pp = pretty_print_macro_expansion(src.value.syntax().clone());\n+            let pp = pretty_print_macro_expansion(src.value.syntax().clone(), None);\n             format_to!(expanded_text, \"\\n{}\", pp)\n         }\n     }\n@@ -147,6 +222,20 @@ fn check(ra_fixture: &str, mut expect: Expect) {\n     expect.assert_eq(&expanded_text);\n }\n \n+fn extract_id_ranges(ranges: &mut Vec<(TextRange, TokenId)>, map: &TokenMap, tree: &Subtree) {\n+    tree.token_trees.iter().for_each(|tree| match tree {\n+        tt::TokenTree::Leaf(leaf) => {\n+            let id = match leaf {\n+                tt::Leaf::Literal(it) => it.id,\n+                tt::Leaf::Punct(it) => it.id,\n+                tt::Leaf::Ident(it) => it.id,\n+            };\n+            ranges.extend(map.ranges_by_token(id, SyntaxKind::ERROR).map(|range| (range, id)));\n+        }\n+        tt::TokenTree::Subtree(tree) => extract_id_ranges(ranges, map, tree),\n+    });\n+}\n+\n fn reindent(indent: IndentLevel, pp: String) -> String {\n     if !pp.contains('\\n') {\n         return pp;\n@@ -163,7 +252,7 @@ fn reindent(indent: IndentLevel, pp: String) -> String {\n     res\n }\n \n-fn pretty_print_macro_expansion(expn: SyntaxNode) -> String {\n+fn pretty_print_macro_expansion(expn: SyntaxNode, map: Option<&TokenMap>) -> String {\n     let mut res = String::new();\n     let mut prev_kind = EOF;\n     let mut indent_level = 0;\n@@ -206,7 +295,12 @@ fn pretty_print_macro_expansion(expn: SyntaxNode) -> String {\n             res.push_str(&\"    \".repeat(level));\n         }\n         prev_kind = curr_kind;\n-        format_to!(res, \"{}\", token)\n+        format_to!(res, \"{}\", token);\n+        if let Some(map) = map {\n+            if let Some(id) = map.token_by_range(token.text_range()) {\n+                format_to!(res, \"#{}\", id.0);\n+            }\n+        }\n     }\n     res\n }"}, {"sha": "962e1e7459aeadd6658bd73222d471e773dd4f60", "filename": "crates/hir_def/src/macro_expansion_tests/mbe.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/64cb09ddea942c6cbcb28812226c5a53dceeb182/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64cb09ddea942c6cbcb28812226c5a53dceeb182/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs?ref=64cb09ddea942c6cbcb28812226c5a53dceeb182", "patch": "@@ -10,6 +10,42 @@ use expect_test::expect;\n \n use crate::macro_expansion_tests::check;\n \n+#[test]\n+fn token_mapping_smoke_test() {\n+    check(\n+        r#\"\n+// +tokenids\n+macro_rules! f {\n+    ( struct $ident:ident ) => {\n+        struct $ident {\n+            map: ::std::collections::HashSet<()>,\n+        }\n+    };\n+}\n+\n+// +tokenids\n+f!(struct MyTraitMap2);\n+\"#,\n+        expect![[r##\"\n+// call ids will be shifted by Shift(27)\n+// +tokenids\n+macro_rules! f {#0\n+    (#1 struct#2 $#3ident#4:#5ident#6 )#1 =#7>#8 {#9\n+        struct#10 $#11ident#12 {#13\n+            map#14:#15 :#16:#17std#18:#19:#20collections#21:#22:#23HashSet#24<#25(#26)#26>#27,#28\n+        }#13\n+    }#9;#29\n+}#0\n+\n+// // +tokenids\n+// f!(struct#1 MyTraitMap2#2);\n+struct#10 MyTraitMap2#29 {#13\n+    map#14:#15 ::std#18::collections#21::HashSet#24<#25(#26)#26>#27,#28\n+}#13\n+\"##]],\n+    );\n+}\n+\n #[test]\n fn mbe_smoke_test() {\n     check("}, {"sha": "409d0cc66f7e81cce3638cdfcacfae1e7bab03c9", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/64cb09ddea942c6cbcb28812226c5a53dceeb182/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64cb09ddea942c6cbcb28812226c5a53dceeb182/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=64cb09ddea942c6cbcb28812226c5a53dceeb182", "patch": "@@ -370,8 +370,9 @@ impl MacroCallId {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ExpansionInfo {\n     expanded: InFile<SyntaxNode>,\n+    /// The argument TokenTree or item for attributes\n     arg: InFile<SyntaxNode>,\n-    /// The `macro_rules!` arguments or attribute input.\n+    /// The `macro_rules!` or attribute input.\n     attr_input_or_mac_def: Option<InFile<ast::TokenTree>>,\n \n     macro_def: Arc<TokenExpander>,"}, {"sha": "dd77dd3e4b7d7db07e1bab0537f2a43bb1abc582", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/64cb09ddea942c6cbcb28812226c5a53dceeb182/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64cb09ddea942c6cbcb28812226c5a53dceeb182/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=64cb09ddea942c6cbcb28812226c5a53dceeb182", "patch": "@@ -22,7 +22,6 @@ use crate::{\n     runnables::{runnable_fn, runnable_mod},\n     FileId, FilePosition, NavigationTarget, RangeInfo, Runnable, TryToNav,\n };\n-\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct HoverConfig {\n     pub links_in_hover: bool,"}, {"sha": "833a67ad998850949cf61290e4ee37c15d6d9175", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64cb09ddea942c6cbcb28812226c5a53dceeb182/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64cb09ddea942c6cbcb28812226c5a53dceeb182/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=64cb09ddea942c6cbcb28812226c5a53dceeb182", "patch": "@@ -245,6 +245,10 @@ impl DeclarativeMacro {\n             None => (id, Origin::Def),\n         }\n     }\n+\n+    pub fn shift(&self) -> Shift {\n+        self.shift\n+    }\n }\n \n impl Rule {"}]}