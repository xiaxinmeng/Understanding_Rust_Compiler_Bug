{"sha": "b6828fd1acf11272b05c32010f9071d3e8862e76", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2ODI4ZmQxYWNmMTEyNzJiMDVjMzIwMTBmOTA3MWQzZTg4NjJlNzY=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-11-09T18:41:03Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-11-12T17:57:23Z"}, "message": "rustc_typeck: register item types for closures\n\nThis makes them closer to actual items and allows for more\ntransparent treatment.", "tree": {"sha": "3eb8bf995a454ccc896e7624b643c66850f2cf28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3eb8bf995a454ccc896e7624b643c66850f2cf28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6828fd1acf11272b05c32010f9071d3e8862e76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6828fd1acf11272b05c32010f9071d3e8862e76", "html_url": "https://github.com/rust-lang/rust/commit/b6828fd1acf11272b05c32010f9071d3e8862e76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6828fd1acf11272b05c32010f9071d3e8862e76/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca9b5664c3c4a052a044d63725239ff2e56136f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca9b5664c3c4a052a044d63725239ff2e56136f4", "html_url": "https://github.com/rust-lang/rust/commit/ca9b5664c3c4a052a044d63725239ff2e56136f4"}], "stats": {"total": 79, "additions": 49, "deletions": 30}, "files": [{"sha": "778a9d185e145ef797e857617f4ac71da4e0a5f3", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6828fd1acf11272b05c32010f9071d3e8862e76/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6828fd1acf11272b05c32010f9071d3e8862e76/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=b6828fd1acf11272b05c32010f9071d3e8862e76", "patch": "@@ -1056,7 +1056,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             stability: None,\n             deprecation: None,\n \n-            ty: None,\n+            ty: Some(self.encode_item_type(def_id)),\n             inherent_impls: LazySeq::empty(),\n             variances: LazySeq::empty(),\n             generics: Some(self.encode_generics(def_id)),"}, {"sha": "3efbd6b30c2201d9179bd644c0f9c9d38e620ea5", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 48, "deletions": 29, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/b6828fd1acf11272b05c32010f9071d3e8862e76/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6828fd1acf11272b05c32010f9071d3e8862e76/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=b6828fd1acf11272b05c32010f9071d3e8862e76", "patch": "@@ -13,7 +13,9 @@\n use super::{check_fn, Expectation, FnCtxt};\n \n use astconv::AstConv;\n+use rustc::hir::def_id::DefId;\n use rustc::ty::{self, ToPolyTraitRef, Ty};\n+use rustc::ty::subst::Substs;\n use rustc::util::common::MemoizationMap;\n use std::cmp;\n use syntax::abi::Abi;\n@@ -43,20 +45,62 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.check_closure(expr, expected_kind, decl, body, expected_sig)\n     }\n \n+    fn declare_closure(&self, def_id: DefId) {\n+        let tcx = self.tcx.global_tcx();\n+\n+        tcx.generics.memoize(def_id, || {\n+            let node_id = tcx.map.as_local_node_id(def_id).unwrap();\n+            let base_def_id = self.tcx.closure_base_def_id(def_id);\n+            let base_generics = tcx.item_generics(base_def_id);\n+\n+            // provide junk type parameter defs - the only place that\n+            // cares about anything but the length is instantiation,\n+            // and we don't do that for closures.\n+            let upvar_decls : Vec<_> = tcx.with_freevars(node_id, |fv| {\n+                fv.iter().enumerate().map(|(i, _)| ty::TypeParameterDef {\n+                    index: (base_generics.count() as u32) + (i as u32),\n+                    name: token::intern(\"<upvar>\"),\n+                    def_id: def_id,\n+                    default_def_id: base_def_id,\n+                    default: None,\n+                    object_lifetime_default: ty::ObjectLifetimeDefault::BaseDefault,\n+                    pure_wrt_drop: false,\n+                }).collect()\n+            });\n+\n+            tcx.alloc_generics(ty::Generics {\n+                parent: Some(base_def_id),\n+                parent_regions: base_generics.parent_regions +\n+                    (base_generics.regions.len() as u32),\n+                parent_types: base_generics.parent_types +\n+                    (base_generics.types.len() as u32),\n+                regions: vec![],\n+                types: upvar_decls,\n+                has_self: false,\n+            })\n+        });\n+\n+        tcx.item_types.memoize(def_id, || tcx.mk_closure(def_id, Substs::for_item(\n+            tcx, def_id,\n+            |def, _| tcx.mk_region(def.to_early_bound_region()),\n+            |def, _| tcx.mk_param_from_def(def)\n+        )));\n+    }\n+\n     fn check_closure(&self,\n                      expr: &hir::Expr,\n                      opt_kind: Option<ty::ClosureKind>,\n                      decl: &'gcx hir::FnDecl,\n                      body: &'gcx hir::Expr,\n                      expected_sig: Option<ty::FnSig<'tcx>>)\n                      -> Ty<'tcx> {\n-        let expr_def_id = self.tcx.map.local_def_id(expr.id);\n-        let base_def_id = self.tcx.closure_base_def_id(expr_def_id);\n-\n         debug!(\"check_closure opt_kind={:?} expected_sig={:?}\",\n                opt_kind,\n                expected_sig);\n \n+        let expr_def_id = self.tcx.map.local_def_id(expr.id);\n+        self.declare_closure(expr_def_id);\n+\n         let mut fn_ty = AstConv::ty_of_closure(self,\n                                                hir::Unsafety::Normal,\n                                                decl,\n@@ -66,32 +110,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Create type variables (for now) to represent the transformed\n         // types of upvars. These will be unified during the upvar\n         // inference phase (`upvar.rs`).\n-        let base_generics = self.tcx.item_generics(base_def_id);\n-        // provide junk type parameter defs - the only place that\n-        // cares about anything but the length is instantiation,\n-        // and we don't do that for closures.\n-        let upvar_decls : Vec<_> = self.tcx.with_freevars(expr.id, |fv| {\n-            fv.iter().enumerate().map(|(i, _)| ty::TypeParameterDef {\n-                index: (base_generics.count() as u32) + (i as u32),\n-                name: token::intern(\"<upvar>\"),\n-                def_id: expr_def_id,\n-                default_def_id: base_def_id,\n-                default: None,\n-                object_lifetime_default: ty::ObjectLifetimeDefault::BaseDefault,\n-                pure_wrt_drop: false,\n-            }).collect()\n-        });\n-        let num_upvars = upvar_decls.len();\n-\n-        self.tcx.generics.memoize(expr_def_id, || self.tcx.alloc_generics(ty::Generics {\n-            parent: Some(base_def_id),\n-            parent_regions: base_generics.parent_regions + (base_generics.regions.len() as u32),\n-            parent_types: base_generics.parent_types + (base_generics.types.len() as u32),\n-            regions: vec![],\n-            types: upvar_decls,\n-            has_self: false,\n-        }));\n-\n+        let num_upvars = self.tcx.with_freevars(expr.id, |fv| fv.len());\n         let upvar_tys = self.next_ty_vars(num_upvars);\n \n         debug!(\"check_closure: expr.id={:?} upvar_tys={:?}\","}]}