{"sha": "1cf2108a2b09942d6b225700b9d39dc9fa070463", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjZjIxMDhhMmIwOTk0MmQ2YjIyNTcwMGI5ZDM5ZGM5ZmEwNzA0NjM=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-05-06T15:30:00Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-05-06T15:33:54Z"}, "message": "libsyntax: convert #[deriving(IterBytes)] to generic deriving", "tree": {"sha": "7a2585595d48c90129627728e578f3dfc4879c59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a2585595d48c90129627728e578f3dfc4879c59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cf2108a2b09942d6b225700b9d39dc9fa070463", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cf2108a2b09942d6b225700b9d39dc9fa070463", "html_url": "https://github.com/rust-lang/rust/commit/1cf2108a2b09942d6b225700b9d39dc9fa070463", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cf2108a2b09942d6b225700b9d39dc9fa070463/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b20eb970e18377191465cb37f2074f467dfd61b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b20eb970e18377191465cb37f2074f467dfd61b1", "html_url": "https://github.com/rust-lang/rust/commit/b20eb970e18377191465cb37f2074f467dfd61b1"}], "stats": {"total": 284, "additions": 61, "deletions": 223}, "files": [{"sha": "c1c34c9a53a601d7dd2ab67cf38508b8802404b3", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 61, "deletions": 223, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/1cf2108a2b09942d6b225700b9d39dc9fa070463/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf2108a2b09942d6b225700b9d39dc9fa070463/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=1cf2108a2b09942d6b225700b9d39dc9fa070463", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,25 +8,37 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast;\n-use ast::*;\n+use ast::{meta_item, item, expr};\n+use codemap::span;\n use ext::base::ext_ctxt;\n use ext::build;\n-use ext::deriving::*;\n-use codemap::{span, spanned};\n-use ast_util;\n-use opt_vec;\n+use ext::deriving::generic::*;\n \n pub fn expand_deriving_iter_bytes(cx: @ext_ctxt,\n                                   span: span,\n-                                  _mitem: @meta_item,\n-                                  in_items: ~[@item])\n-                               -> ~[@item] {\n-    expand_deriving(cx,\n-                    span,\n-                    in_items,\n-                    expand_deriving_iter_bytes_struct_def,\n-                    expand_deriving_iter_bytes_enum_def)\n+                                  mitem: @meta_item,\n+                                  in_items: ~[@item]) -> ~[@item] {\n+    let trait_def = TraitDef {\n+        path: Path::new(~[~\"core\", ~\"to_bytes\", ~\"IterBytes\"]),\n+        additional_bounds: ~[],\n+        generics: LifetimeBounds::empty(),\n+        methods: ~[\n+            MethodDef {\n+                name: ~\"iter_bytes\",\n+                generics: LifetimeBounds::empty(),\n+                self_ty: borrowed_explicit_self(),\n+                args: ~[\n+                    Literal(Path::new(~[~\"bool\"])),\n+                    Literal(Path::new(~[~\"core\", ~\"to_bytes\", ~\"Cb\"]))\n+                ],\n+                ret_ty: nil_ty(),\n+                const_nonmatching: false,\n+                combine_substructure: iter_bytes_substructure\n+            }\n+        ]\n+    };\n+\n+    expand_deriving_generic(cx, span, mitem, in_items, &trait_def)\n }\n \n pub fn expand_deriving_obsolete(cx: @ext_ctxt,\n@@ -39,217 +51,43 @@ pub fn expand_deriving_obsolete(cx: @ext_ctxt,\n     in_items\n }\n \n-fn create_derived_iter_bytes_impl(cx: @ext_ctxt,\n-                                  span: span,\n-                                  type_ident: ident,\n-                                  generics: &Generics,\n-                                  method: @method)\n-                               -> @item {\n-    let methods = [ method ];\n-    let trait_path = ~[\n-        cx.ident_of(~\"core\"),\n-        cx.ident_of(~\"to_bytes\"),\n-        cx.ident_of(~\"IterBytes\")\n-    ];\n-    let trait_path = build::mk_raw_path_global(span, trait_path);\n-    create_derived_impl(cx, span, type_ident, generics, methods, trait_path,\n-                        opt_vec::Empty, opt_vec::Empty)\n-}\n-\n-// Creates a method from the given set of statements conforming to the\n-// signature of the `iter_bytes` method.\n-fn create_iter_bytes_method(cx: @ext_ctxt,\n-                            span: span,\n-                            statements: ~[@stmt])\n-                         -> @method {\n-    // Create the `lsb0` parameter.\n-    let bool_ident = cx.ident_of(~\"bool\");\n-    let lsb0_arg_type = build::mk_simple_ty_path(cx, span, bool_ident);\n-    let lsb0_ident = cx.ident_of(~\"__lsb0\");\n-    let lsb0_arg = build::mk_arg(cx, span, lsb0_ident, lsb0_arg_type);\n-\n-    // Create the `f` parameter.\n-    let core_ident = cx.ident_of(~\"core\");\n-    let to_bytes_ident = cx.ident_of(~\"to_bytes\");\n-    let cb_ident = cx.ident_of(~\"Cb\");\n-    let core_to_bytes_cb_ident = ~[ core_ident, to_bytes_ident, cb_ident ];\n-    let f_arg_type = build::mk_ty_path(cx, span, core_to_bytes_cb_ident);\n-    let f_ident = cx.ident_of(~\"__f\");\n-    let f_arg = build::mk_arg(cx, span, f_ident, f_arg_type);\n-\n-    // Create the type of the return value.\n-    let output_type = @ast::Ty { id: cx.next_id(), node: ty_nil, span: span };\n-\n-    // Create the function declaration.\n-    let inputs = ~[ lsb0_arg, f_arg ];\n-    let fn_decl = build::mk_fn_decl(inputs, output_type);\n-\n-    // Create the body block.\n-    let body_block = build::mk_block_(cx, span, statements);\n-\n-    // Create the method.\n-    let self_ty = spanned { node: sty_region(None, m_imm), span: span };\n-    let method_ident = cx.ident_of(~\"iter_bytes\");\n-    @ast::method {\n-        ident: method_ident,\n-        attrs: ~[],\n-        generics: ast_util::empty_generics(),\n-        self_ty: self_ty,\n-        purity: impure_fn,\n-        decl: fn_decl,\n-        body: body_block,\n-        id: cx.next_id(),\n-        span: span,\n-        self_id: cx.next_id(),\n-        vis: public\n-    }\n-}\n-\n-fn call_substructure_iter_bytes_method(cx: @ext_ctxt,\n-                                       span: span,\n-                                       self_field: @expr)\n-                                    -> @stmt {\n-    // Gather up the parameters we want to chain along.\n-    let lsb0_ident = cx.ident_of(~\"__lsb0\");\n-    let f_ident = cx.ident_of(~\"__f\");\n-    let lsb0_expr = build::mk_path(cx, span, ~[ lsb0_ident ]);\n-    let f_expr = build::mk_path(cx, span, ~[ f_ident ]);\n-\n-    // Call the substructure method.\n-    let iter_bytes_ident = cx.ident_of(~\"iter_bytes\");\n-    let self_call = build::mk_method_call(cx,\n-                                          span,\n-                                          self_field,\n-                                          iter_bytes_ident,\n-                                          ~[ lsb0_expr, f_expr ]);\n-\n-    // Create a statement out of this expression.\n-    build::mk_stmt(cx, span, self_call)\n-}\n-\n-fn expand_deriving_iter_bytes_struct_def(cx: @ext_ctxt,\n-                                         span: span,\n-                                         struct_def: &struct_def,\n-                                         type_ident: ident,\n-                                         generics: &Generics)\n-                                      -> @item {\n-    // Create the method.\n-    let method = expand_deriving_iter_bytes_struct_method(cx,\n-                                                          span,\n-                                                          struct_def);\n-\n-    // Create the implementation.\n-    return create_derived_iter_bytes_impl(cx,\n-                                          span,\n-                                          type_ident,\n-                                          generics,\n-                                          method);\n-}\n-\n-fn expand_deriving_iter_bytes_enum_def(cx: @ext_ctxt,\n-                                       span: span,\n-                                       enum_definition: &enum_def,\n-                                       type_ident: ident,\n-                                       generics: &Generics)\n-                                    -> @item {\n-    // Create the method.\n-    let method = expand_deriving_iter_bytes_enum_method(cx,\n-                                                        span,\n-                                                        enum_definition);\n-\n-    // Create the implementation.\n-    return create_derived_iter_bytes_impl(cx,\n-                                          span,\n-                                          type_ident,\n-                                          generics,\n-                                          method);\n-}\n-\n-fn expand_deriving_iter_bytes_struct_method(cx: @ext_ctxt,\n-                                            span: span,\n-                                            struct_def: &struct_def)\n-                                         -> @method {\n-    let self_ident = cx.ident_of(~\"self\");\n-\n-    // Create the body of the method.\n-    let mut statements = ~[];\n-    for struct_def.fields.each |struct_field| {\n-        match struct_field.node.kind {\n-            named_field(ident, _, _) => {\n-                // Create the accessor for this field.\n-                let self_field = build::mk_access(cx,\n-                                                  span,\n-                                                  ~[ self_ident ],\n-                                                  ident);\n-\n-                // Call the substructure method.\n-                let stmt = call_substructure_iter_bytes_method(cx,\n-                                                               span,\n-                                                               self_field);\n-                statements.push(stmt);\n-            }\n-            unnamed_field => {\n-                cx.span_unimpl(span,\n-                               ~\"unnamed fields with `deriving(IterBytes)`\");\n-            }\n-        }\n-    }\n-\n-    // Create the method itself.\n-    return create_iter_bytes_method(cx, span, statements);\n-}\n-\n-fn expand_deriving_iter_bytes_enum_method(cx: @ext_ctxt,\n-                                          span: span,\n-                                          enum_definition: &enum_def)\n-                                       -> @method {\n-    // Create the arms of the match in the method body.\n-    let arms = do enum_definition.variants.mapi |i, variant| {\n-        // Create the matching pattern.\n-        let pat = create_enum_variant_pattern(cx, span, variant, ~\"__self\");\n-\n-        // Determine the discriminant. We will feed this value to the byte\n-        // iteration function.\n-        let discriminant;\n-        match variant.node.disr_expr {\n-            Some(copy disr_expr) => discriminant = disr_expr,\n-            None => discriminant = build::mk_uint(cx, span, i),\n-        }\n-\n-        // Feed the discriminant to the byte iteration function.\n-        let mut stmts = ~[];\n-        let discrim_stmt = call_substructure_iter_bytes_method(cx,\n-                                                               span,\n-                                                               discriminant);\n-        stmts.push(discrim_stmt);\n-\n-        // Feed each argument in this variant to the byte iteration function\n-        // as well.\n-        for uint::range(0, variant_arg_count(cx, span, variant)) |j| {\n-            // Create the expression for this field.\n-            let field_ident = cx.ident_of(~\"__self_\" + j.to_str());\n-            let field = build::mk_path(cx, span, ~[ field_ident ]);\n-\n-            // Call the substructure method.\n-            let stmt = call_substructure_iter_bytes_method(cx, span, field);\n-            stmts.push(stmt);\n+fn iter_bytes_substructure(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr {\n+    let lsb0_f = match substr.nonself_args {\n+        [l, f] => ~[l, f],\n+        _ => cx.span_bug(span, \"Incorrect number of arguments in `deriving(IterBytes)`\")\n+    };\n+    let iter_bytes_ident = substr.method_ident;\n+    let call_iterbytes = |thing_expr| {\n+        build::mk_stmt(\n+            cx, span,\n+            build::mk_method_call(cx, span,\n+                                  thing_expr, iter_bytes_ident,\n+                                  copy lsb0_f))\n+    };\n+    let mut stmts = ~[];\n+    let fields;\n+    match *substr.fields {\n+        Struct(ref fs) => {\n+            fields = fs\n         }\n+        EnumMatching(copy index, ref variant, ref fs) => {\n+            // Determine the discriminant. We will feed this value to the byte\n+            // iteration function.\n+            let discriminant = match variant.node.disr_expr {\n+                Some(copy d)=> d,\n+                None => build::mk_uint(cx, span, index)\n+            };\n \n-        // Create the pattern body.\n-        let match_body_block = build::mk_block_(cx, span, stmts);\n+            stmts.push(call_iterbytes(discriminant));\n \n-        // Create the arm.\n-        ast::arm {\n-            pats: ~[ pat ],\n-            guard: None,\n-            body: match_body_block,\n+            fields = fs;\n         }\n-    };\n+        _ => cx.span_bug(span, \"Impossible substructure in `deriving(IterBytes)`\")\n+    }\n \n-    // Create the method body.\n-    let self_match_expr = expand_enum_or_struct_match(cx, span, arms);\n-    let self_match_stmt = build::mk_stmt(cx, span, self_match_expr);\n+    for fields.each |&(_, field, _)| {\n+        stmts.push(call_iterbytes(field));\n+    }\n \n-    // Create the method.\n-    create_iter_bytes_method(cx, span, ~[ self_match_stmt ])\n-}\n+    build::mk_block(cx, span, ~[], stmts, None)\n+}\n\\ No newline at end of file"}]}