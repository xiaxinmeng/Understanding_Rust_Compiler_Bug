{"sha": "9255bbd035ee032f1ccd47fcf93c87f7bc2e4bad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyNTViYmQwMzVlZTAzMmYxY2NkNDdmY2Y5M2M4N2Y3YmMyZTRiYWQ=", "commit": {"author": {"name": "Fabian Zaiser", "email": "fabian.zaiser@gmail.com", "date": "2018-03-26T18:15:19Z"}, "committer": {"name": "Fabian Zaiser", "email": "fabian.zaiser@gmail.com", "date": "2018-03-26T18:25:42Z"}, "message": "Implement RFC #2169 (Euclidean division).\n\nTracking issue: #49048", "tree": {"sha": "f0eafd65463def219f58c69a440fa034913ea798", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0eafd65463def219f58c69a440fa034913ea798"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9255bbd035ee032f1ccd47fcf93c87f7bc2e4bad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9255bbd035ee032f1ccd47fcf93c87f7bc2e4bad", "html_url": "https://github.com/rust-lang/rust/commit/9255bbd035ee032f1ccd47fcf93c87f7bc2e4bad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9255bbd035ee032f1ccd47fcf93c87f7bc2e4bad/comments", "author": {"login": "fanzier", "id": 5846332, "node_id": "MDQ6VXNlcjU4NDYzMzI=", "avatar_url": "https://avatars.githubusercontent.com/u/5846332?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fanzier", "html_url": "https://github.com/fanzier", "followers_url": "https://api.github.com/users/fanzier/followers", "following_url": "https://api.github.com/users/fanzier/following{/other_user}", "gists_url": "https://api.github.com/users/fanzier/gists{/gist_id}", "starred_url": "https://api.github.com/users/fanzier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fanzier/subscriptions", "organizations_url": "https://api.github.com/users/fanzier/orgs", "repos_url": "https://api.github.com/users/fanzier/repos", "events_url": "https://api.github.com/users/fanzier/events{/privacy}", "received_events_url": "https://api.github.com/users/fanzier/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fanzier", "id": 5846332, "node_id": "MDQ6VXNlcjU4NDYzMzI=", "avatar_url": "https://avatars.githubusercontent.com/u/5846332?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fanzier", "html_url": "https://github.com/fanzier", "followers_url": "https://api.github.com/users/fanzier/followers", "following_url": "https://api.github.com/users/fanzier/following{/other_user}", "gists_url": "https://api.github.com/users/fanzier/gists{/gist_id}", "starred_url": "https://api.github.com/users/fanzier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fanzier/subscriptions", "organizations_url": "https://api.github.com/users/fanzier/orgs", "repos_url": "https://api.github.com/users/fanzier/repos", "events_url": "https://api.github.com/users/fanzier/events{/privacy}", "received_events_url": "https://api.github.com/users/fanzier/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13a86f4d8555702085b97de3a42234a82ddc045d", "url": "https://api.github.com/repos/rust-lang/rust/commits/13a86f4d8555702085b97de3a42234a82ddc045d", "html_url": "https://github.com/rust-lang/rust/commit/13a86f4d8555702085b97de3a42234a82ddc045d"}], "stats": {"total": 537, "additions": 537, "deletions": 0}, "files": [{"sha": "b4a43b216e833def9a469804429318651e365dad", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 436, "deletions": 0, "changes": 436, "blob_url": "https://github.com/rust-lang/rust/blob/9255bbd035ee032f1ccd47fcf93c87f7bc2e4bad/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9255bbd035ee032f1ccd47fcf93c87f7bc2e4bad/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=9255bbd035ee032f1ccd47fcf93c87f7bc2e4bad", "patch": "@@ -633,6 +633,32 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Checked Euclidean division. Computes `self.div_euc(rhs)`, returning `None` if `rhs == 0`\n+or the division results in overflow.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!((\", stringify!($SelfT),\n+\"::min_value() + 1).checked_div_euc(-1), Some(\", stringify!($Max), \"));\n+assert_eq!(\", stringify!($SelfT), \"::min_value().checked_div_euc(-1), None);\n+assert_eq!((1\", stringify!($SelfT), \").checked_div_euc(0), None);\",\n+$EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[inline]\n+            pub fn checked_div_euc(self, rhs: Self) -> Option<Self> {\n+                if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n+                    None\n+                } else {\n+                    Some(self.div_euc(rhs))\n+                }\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Checked integer remainder. Computes `self % rhs`, returning `None` if\n `rhs == 0` or the division results in overflow.\n@@ -660,6 +686,33 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Checked Euclidean modulo. Computes `self.mod_euc(rhs)`, returning `None` if\n+`rhs == 0` or the division results in overflow.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"use std::\", stringify!($SelfT), \";\n+\n+assert_eq!(5\", stringify!($SelfT), \".checked_mod_euc(2), Some(1));\n+assert_eq!(5\", stringify!($SelfT), \".checked_mod_euc(0), None);\n+assert_eq!(\", stringify!($SelfT), \"::MIN.checked_mod_euc(-1), None);\",\n+$EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[inline]\n+            pub fn checked_mod_euc(self, rhs: Self) -> Option<Self> {\n+                if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n+                    None\n+                } else {\n+                    Some(self.mod_euc(rhs))\n+                }\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Checked negation. Computes `-self`, returning `None` if `self == MIN`.\n \n@@ -993,6 +1046,34 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Wrapping Euclidean division. Computes `self.div_euc(rhs)`, wrapping around at the\n+boundary of the type.\n+\n+The only case where such wrapping can occur is when one divides `MIN / -1` on a signed type (where\n+`MIN` is the negative minimal value for the type); this is equivalent to `-MIN`, a positive value\n+that is too large to represent in the type. In such a case, this function returns `MIN` itself.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euc(10), 10);\n+assert_eq!((-128i8).wrapping_div_euc(-1), -128);\",\n+$EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[inline]\n+            pub fn wrapping_div_euc(self, rhs: Self) -> Self {\n+                self.overflowing_div_euc(rhs).0\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Wrapping (modular) remainder. Computes `self % rhs`, wrapping around at the\n boundary of the type.\n@@ -1021,6 +1102,34 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Wrapping Euclidean modulo. Computes `self.mod_euc(rhs)`, wrapping around at the\n+boundary of the type.\n+\n+Such wrap-around never actually occurs mathematically; implementation artifacts make `x % y`\n+invalid for `MIN / -1` on a signed type (where `MIN` is the negative minimal value). In such a case,\n+this function returns `0`.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_mod_euc(10), 0);\n+assert_eq!((-128i8).wrapping_mod_euc(-1), 0);\",\n+$EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[inline]\n+            pub fn wrapping_mod_euc(self, rhs: Self) -> Self {\n+                self.overflowing_mod_euc(rhs).0\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Wrapping (modular) negation. Computes `-self`, wrapping around at the boundary\n of the type.\n@@ -1286,6 +1395,39 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Calculates the quotient of Euclidean division `self.div_euc(rhs)`.\n+\n+Returns a tuple of the divisor along with a boolean indicating whether an arithmetic overflow would\n+occur. If an overflow would occur then self is returned.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"use std::\", stringify!($SelfT), \";\n+\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euc(2), (2, false));\n+assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div_euc(-1), (\", stringify!($SelfT),\n+\"::MIN, true));\",\n+$EndFeature, \"\n+```\"),\n+            #[inline]\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            pub fn overflowing_div_euc(self, rhs: Self) -> (Self, bool) {\n+                if self == Self::min_value() && rhs == -1 {\n+                    (self, true)\n+                } else {\n+                    (self.div_euc(rhs), false)\n+                }\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Calculates the remainder when `self` is divided by `rhs`.\n \n@@ -1318,6 +1460,40 @@ $EndFeature, \"\n             }\n         }\n \n+\n+        doc_comment! {\n+            concat!(\"Calculates the modulo of Euclidean divsion `self.mod_euc(rhs)`.\n+\n+Returns a tuple of the remainder after dividing along with a boolean indicating whether an\n+arithmetic overflow would occur. If an overflow would occur then 0 is returned.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"use std::\", stringify!($SelfT), \";\n+\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_mod_euc(2), (1, false));\n+assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_mod_euc(-1), (0, true));\",\n+$EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[inline]\n+            pub fn overflowing_mod_euc(self, rhs: Self) -> (Self, bool) {\n+                if self == Self::min_value() && rhs == -1 {\n+                    (0, true)\n+                } else {\n+                    (self.mod_euc(rhs), false)\n+                }\n+            }\n+        }\n+\n+\n         doc_comment! {\n             concat!(\"Negates self, overflowing if this is equal to the minimum value.\n \n@@ -1512,6 +1688,80 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Calculates the quotient of Euclidean division of `self` by `rhs`.\n+\n+This computes the integer n such that `self = n * rhs + self.mod_euc(rhs)`.\n+In other words, the result is `self / rhs` rounded to the integer n\n+such that `self >= n * rhs`.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"let a: \", stringify!($SelfT), \" = 7; // or any other integer type\n+let b = 4;\n+\n+assert_eq!(a.div_euc(b), 1); // 7 >= 4 * 1\n+assert_eq!(a.div_euc(-b), -1); // 7 >= -4 * -1\n+assert_eq!((-a).div_euc(b), -2); // -7 >= 4 * -2\n+assert_eq!((-a).div_euc(-b), 2); // -7 >= -4 * 2\",\n+$EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            pub fn div_euc(self, rhs: Self) -> Self {\n+                let q = self / rhs;\n+                if self % rhs < 0 {\n+                    return if rhs > 0 { q - 1 } else { q + 1 }\n+                }\n+                q\n+            }\n+        }\n+\n+\n+        doc_comment! {\n+            concat!(\"Calculates the modulo `self mod rhs` by Euclidean division.\n+\n+In particular, the result `n` satisfies `0 <= n < rhs.abs()`.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"let a: \", stringify!($SelfT), \" = 7; // or any other integer type\n+let b = 4;\n+\n+assert_eq!(a.mod_euc(b), 3);\n+assert_eq!((-a).mod_euc(b), 1);\n+assert_eq!(a.mod_euc(-b), 3);\n+assert_eq!((-a).mod_euc(-b), 1);\",\n+$EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            pub fn mod_euc(self, rhs: Self) -> Self {\n+                let r = self % rhs;\n+                if r < 0 {\n+                    r + rhs.abs()\n+                } else {\n+                    r\n+                }\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Computes the absolute value of `self`.\n \n@@ -2103,6 +2353,30 @@ assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\", $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Checked Euclidean division. Computes `self.div_euc(rhs)`, returning `None`\n+if `rhs == 0`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\n+assert_eq!(1\", stringify!($SelfT), \".checked_div_euc(0), None);\n+```\"),\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[inline]\n+            pub fn checked_div_euc(self, rhs: Self) -> Option<Self> {\n+                if rhs == 0 {\n+                    None\n+                } else {\n+                    Some(self.div_euc(rhs))\n+                }\n+            }\n+        }\n+\n+\n         doc_comment! {\n             concat!(\"Checked integer remainder. Computes `self % rhs`, returning `None`\n if `rhs == 0`.\n@@ -2126,6 +2400,30 @@ assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\", $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Checked Euclidean modulo. Computes `self.mod_euc(rhs)`, returning `None`\n+if `rhs == 0`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(5\", stringify!($SelfT), \".checked_mod_euc(2), Some(1));\n+assert_eq!(5\", stringify!($SelfT), \".checked_mod_euc(0), None);\",\n+$EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[inline]\n+            pub fn checked_mod_euc(self, rhs: Self) -> Option<Self> {\n+                if rhs == 0 {\n+                    None\n+                } else {\n+                    Some(self.mod_euc(rhs))\n+                }\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Checked negation. Computes `-self`, returning `None` unless `self ==\n 0`.\n@@ -2405,6 +2703,27 @@ Basic usage:\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Wrapping Euclidean division. Computes `self.div_euc(rhs)`.\n+Wrapped division on unsigned types is just normal division.\n+There's no way wrapping could ever happen.\n+This function exists, so that all operations\n+are accounted for in the wrapping operations.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euc(10), 10);\", $EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[inline]\n+            pub fn wrapping_div_euc(self, rhs: Self) -> Self {\n+                self.div_euc(rhs)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Wrapping (modular) remainder. Computes `self % rhs`.\n Wrapped remainder calculation on unsigned types is\n@@ -2427,6 +2746,28 @@ Basic usage:\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Wrapping Euclidean modulo. Computes `self.mod_euc(rhs)`.\n+Wrapped modulo calculation on unsigned types is\n+just the regular remainder calculation.\n+There's no way wrapping could ever happen.\n+This function exists, so that all operations\n+are accounted for in the wrapping operations.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_mod_euc(10), 0);\", $EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[inline]\n+            pub fn wrapping_mod_euc(self, rhs: Self) -> Self {\n+                self % rhs\n+            }\n+        }\n+\n         /// Wrapping (modular) negation. Computes `-self`,\n         /// wrapping around at the boundary of the type.\n         ///\n@@ -2660,6 +3001,32 @@ Basic usage\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Calculates the quotient of Euclidean division `self.div_euc(rhs)`.\n+\n+Returns a tuple of the divisor along with a boolean indicating\n+whether an arithmetic overflow would occur. Note that for unsigned\n+integers overflow never occurs, so the second value is always\n+`false`.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage\n+\n+```\n+\", $Feature, \"assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euc(2), (2, false));\", $EndFeature, \"\n+```\"),\n+            #[inline]\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            pub fn overflowing_div_euc(self, rhs: Self) -> (Self, bool) {\n+                (self / rhs, false)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Calculates the remainder when `self` is divided by `rhs`.\n \n@@ -2686,6 +3053,32 @@ Basic usage\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Calculates the modulo of Euclidean division of `self.mod_euc(rhs)`.\n+\n+Returns a tuple of the modulo after dividing along with a boolean\n+indicating whether an arithmetic overflow would occur. Note that for\n+unsigned integers overflow never occurs, so the second value is\n+always `false`.\n+\n+# Panics\n+\n+This function will panic if `rhs` is 0.\n+\n+# Examples\n+\n+Basic usage\n+\n+```\n+\", $Feature, \"assert_eq!(5\", stringify!($SelfT), \".overflowing_mod_euc(2), (1, false));\", $EndFeature, \"\n+```\"),\n+            #[inline]\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            pub fn overflowing_mod_euc(self, rhs: Self) -> (Self, bool) {\n+                (self % rhs, false)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Negates self in an overflowing fashion.\n \n@@ -2843,6 +3236,49 @@ Basic usage:\n         }\n     }\n \n+            doc_comment! {\n+            concat!(\"Performs Euclidean division.\n+\n+For unsigned types, this is just the same as `self / rhs`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq(7\", stringify!($SelfT), \".div_euc(4), 1); // or any other integer type\",\n+$EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            pub fn div_euc(self, rhs: Self) -> Self {\n+                self / rhs\n+            }\n+        }\n+\n+\n+        doc_comment! {\n+            concat!(\"Calculates the Euclidean modulo `self mod rhs`.\n+\n+For unsigned types, this is just the same as `self % rhs`.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq(7\", stringify!($SelfT), \".mod_euc(4), 3); // or any other integer type\",\n+$EndFeature, \"\n+```\"),\n+            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            pub fn mod_euc(self, rhs: Self) -> Self {\n+                self % rhs\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Returns `true` if and only if `self == 2^k` for some `k`.\n "}, {"sha": "ed63f4450846260ff4886a494048dcf9e2e0d4b0", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9255bbd035ee032f1ccd47fcf93c87f7bc2e4bad/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9255bbd035ee032f1ccd47fcf93c87f7bc2e4bad/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=9255bbd035ee032f1ccd47fcf93c87f7bc2e4bad", "patch": "@@ -329,6 +329,57 @@ impl f32 {\n         unsafe { intrinsics::fmaf32(self, a, b) }\n     }\n \n+    /// Calculates Euclidean division, the matching method for `mod_euc`.\n+    ///\n+    /// This computes the integer n such that\n+    /// `self = n * rhs + self.mod_euc(rhs)`.\n+    /// In other words, the result is `self / rhs` rounded to the integer n\n+    /// such that `self >= n * rhs`.\n+    ///\n+    /// ```\n+    /// #![feature(euclidean_division)]\n+    /// let a: f32 = 7.0;\n+    /// let b = 4.0;\n+    /// assert_eq!(a.div_euc(b), 1.0); // 7.0 > 4.0 * 1.0\n+    /// assert_eq!((-a).div_euc(b), -2.0); // -7.0 >= 4.0 * -2.0\n+    /// assert_eq!(a.div_euc(-b), -1.0); // 7.0 >= -4.0 * -1.0\n+    /// assert_eq!((-a).div_euc(-b), 2.0); // -7.0 >= -4.0 * 2.0\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+    pub fn div_euc(self, rhs: f32) -> f32 {\n+        let q = (self / rhs).trunc();\n+        if self % rhs < 0.0 {\n+            return if rhs > 0.0 { q - 1.0 } else { q + 1.0 }\n+        }\n+        q\n+    }\n+\n+    /// Calculates the Euclidean modulo (self mod rhs), which is never negative.\n+    ///\n+    /// In particular, the result `n` satisfies `0 <= n < rhs.abs()`.\n+    ///\n+    /// ```\n+    /// #![feature(euclidean_division)]\n+    /// let a: f32 = 7.0;\n+    /// let b = 4.0;\n+    /// assert_eq!(a.mod_euc(b), 3.0);\n+    /// assert_eq!((-a).mod_euc(b), 1.0);\n+    /// assert_eq!(a.mod_euc(-b), 3.0);\n+    /// assert_eq!((-a).mod_euc(-b), 1.0);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+    pub fn mod_euc(self, rhs: f32) -> f32 {\n+        let r = self % rhs;\n+        if r < 0.0 {\n+            r + rhs.abs()\n+        } else {\n+            r\n+        }\n+    }\n+\n+\n     /// Takes the reciprocal (inverse) of a number, `1/x`.\n     ///\n     /// ```"}, {"sha": "320655c443c6aa7159b084c2b599d02fd5a5fa0b", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9255bbd035ee032f1ccd47fcf93c87f7bc2e4bad/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9255bbd035ee032f1ccd47fcf93c87f7bc2e4bad/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=9255bbd035ee032f1ccd47fcf93c87f7bc2e4bad", "patch": "@@ -315,6 +315,56 @@ impl f64 {\n         unsafe { intrinsics::fmaf64(self, a, b) }\n     }\n \n+    /// Calculates Euclidean division, the matching method for `mod_euc`.\n+    ///\n+    /// This computes the integer n such that\n+    /// `self = n * rhs + self.mod_euc(rhs)`.\n+    /// In other words, the result is `self / rhs` rounded to the integer n\n+    /// such that `self >= n * rhs`.\n+    ///\n+    /// ```\n+    /// #![feature(euclidean_division)]\n+    /// let a: f64 = 7.0;\n+    /// let b = 4.0;\n+    /// assert_eq!(a.div_euc(b), 1.0); // 7.0 > 4.0 * 1.0\n+    /// assert_eq!((-a).div_euc(b), -2.0); // -7.0 >= 4.0 * -2.0\n+    /// assert_eq!(a.div_euc(-b), -1.0); // 7.0 >= -4.0 * -1.0\n+    /// assert_eq!((-a).div_euc(-b), 2.0); // -7.0 >= -4.0 * 2.0\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+    pub fn div_euc(self, rhs: f64) -> f64 {\n+        let q = (self / rhs).trunc();\n+        if self % rhs < 0.0 {\n+            return if rhs > 0.0 { q - 1.0 } else { q + 1.0 }\n+        }\n+        q\n+    }\n+\n+    /// Calculates the Euclidean modulo (self mod rhs), which is never negative.\n+    ///\n+    /// In particular, the result `n` satisfies `0 <= n < rhs.abs()`.\n+    ///\n+    /// ```\n+    /// #![feature(euclidean_division)]\n+    /// let a: f64 = 7.0;\n+    /// let b = 4.0;\n+    /// assert_eq!(a.mod_euc(b), 3.0);\n+    /// assert_eq!((-a).mod_euc(b), 1.0);\n+    /// assert_eq!(a.mod_euc(-b), 3.0);\n+    /// assert_eq!((-a).mod_euc(-b), 1.0);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+    pub fn mod_euc(self, rhs: f64) -> f64 {\n+        let r = self % rhs;\n+        if r < 0.0 {\n+            r + rhs.abs()\n+        } else {\n+            r\n+        }\n+    }\n+\n     /// Takes the reciprocal (inverse) of a number, `1/x`.\n     ///\n     /// ```"}]}