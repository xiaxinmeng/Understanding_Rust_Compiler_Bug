{"sha": "a4663d2845b39f05a969af3cabe60a55dc0ee5fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0NjYzZDI4NDViMzlmMDVhOTY5YWYzY2FiZTYwYTU1ZGMwZWU1ZmM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-09T18:20:47Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-09T18:20:47Z"}, "message": "rustc: Add fast paths for vars and param folds. 3x typechecking speedup.", "tree": {"sha": "3238eb3ec0906259e0f12b18b89d202ea31bdc04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3238eb3ec0906259e0f12b18b89d202ea31bdc04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4663d2845b39f05a969af3cabe60a55dc0ee5fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4663d2845b39f05a969af3cabe60a55dc0ee5fc", "html_url": "https://github.com/rust-lang/rust/commit/a4663d2845b39f05a969af3cabe60a55dc0ee5fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4663d2845b39f05a969af3cabe60a55dc0ee5fc/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73ae684536e61ccd1571558f391ec526dbce6e9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/73ae684536e61ccd1571558f391ec526dbce6e9c", "html_url": "https://github.com/rust-lang/rust/commit/73ae684536e61ccd1571558f391ec526dbce6e9c"}], "stats": {"total": 131, "additions": 70, "deletions": 61}, "files": [{"sha": "e08eed612cd58ebecdbc52d60b173c1a74ed052f", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a4663d2845b39f05a969af3cabe60a55dc0ee5fc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4663d2845b39f05a969af3cabe60a55dc0ee5fc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=a4663d2845b39f05a969af3cabe60a55dc0ee5fc", "patch": "@@ -1260,8 +1260,7 @@ fn simplify_type(&@crate_ctxt ccx, &ty::t typ) -> ty::t {\n             case (_) { ret typ; }\n         }\n     }\n-    auto f = bind simplifier(ccx, _);\n-    ret ty::fold_ty(ccx.tcx, f, typ);\n+    ret ty::fold_ty(ccx.tcx, ty::fm_general(bind simplifier(ccx, _)), typ);\n }\n \n // Computes the size of the data part of a non-dynamically-sized tag."}, {"sha": "1c4046756e8ba9268f11550882203004aa595c0a", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 69, "deletions": 59, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/a4663d2845b39f05a969af3cabe60a55dc0ee5fc/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4663d2845b39f05a969af3cabe60a55dc0ee5fc/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=a4663d2845b39f05a969af3cabe60a55dc0ee5fc", "patch": "@@ -697,10 +697,22 @@ fn walk_ty(&ctxt cx, ty_walk walker, t ty) {\n     walker(ty);\n }\n \n-type ty_fold = fn(t) -> t;\n+tag fold_mode {\n+    fm_var(fn(int)->t);\n+    fm_param(fn(uint)->t);\n+    fm_general(fn(t)->t);\n+}\n \n-fn fold_ty(&ctxt cx, ty_fold fld, t ty_0) -> t {\n+fn fold_ty(&ctxt cx, fold_mode fld, t ty_0) -> t {\n     auto ty = ty_0;\n+\n+    // Fast paths.\n+    alt (fld) {\n+        case (fm_var(_)) { if (!type_contains_vars(cx, ty)) { ret ty; } }\n+        case (fm_param(_)) { if (!type_contains_params(cx, ty)) { ret ty; } }\n+        case (fm_general(_)) { /* no fast path */ }\n+    }\n+\n     alt (struct(cx, ty)) {\n         case (ty_nil)           { /* no-op */ }\n         case (ty_bot)           { /* no-op */ }\n@@ -788,11 +800,25 @@ fn fold_ty(&ctxt cx, ty_fold fld, t ty_0) -> t {\n             }\n             ty = copy_cname(cx, mk_obj(cx, new_methods), ty);\n         }\n-        case (ty_var(_))         { /* no-op */ }\n-        case (ty_param(_))       { /* no-op */ }\n+        case (ty_var(?id)) {\n+            alt (fld) {\n+                case (fm_var(?folder)) { ty = folder(id); }\n+                case (_) { /* no-op */ }\n+            }\n+        }\n+        case (ty_param(?id)) {\n+            alt (fld) {\n+                case (fm_param(?folder)) { ty = folder(id); }\n+                case (_) { /* no-op */ }\n+            }\n+        }\n     }\n \n-    ret fld(ty);\n+    // If this is a general type fold, then we need to run it now.\n+    alt (fld) {\n+        case (fm_general(?folder)) { ret folder(ty); }\n+        case (_) { ret ty; }\n+    }\n }\n \n // Type utilities\n@@ -2101,29 +2127,23 @@ mod unify {\n     fn resolve_all_vars(&ty_ctxt tcx, &@var_bindings vb, t typ) -> t {\n         if (!type_contains_vars(tcx, typ)) { ret typ; }\n \n-        fn folder(ty_ctxt tcx, @var_bindings vb, t typ) -> t {\n-            alt (struct(tcx, typ)) {\n-                case (ty_var(?vid)) {\n-                    // It's possible that we haven't even created the var set.\n-                    // Handle this case gracefully.\n-                    if ((vid as uint) >= ufind::set_count(vb.sets)) {\n-                        ret typ;\n-                    }\n+        fn folder(ty_ctxt tcx, @var_bindings vb, int vid) -> t {\n+            // It's possible that we haven't even created the var set.\n+            // Handle this case gracefully.\n+            if ((vid as uint) >= ufind::set_count(vb.sets)) {\n+                ret ty::mk_var(tcx, vid);\n+            }\n \n-                    auto root_id = ufind::find(vb.sets, vid as uint);\n-                    alt (smallintmap::find[t](vb.types, root_id)) {\n-                        case (some[t](?typ2)) {\n-                            ret fold_ty(tcx, bind folder(tcx, vb, _), typ2);\n-                        }\n-                        case (none[t]) { ret typ; }\n-                    }\n+            auto root_id = ufind::find(vb.sets, vid as uint);\n+            alt (smallintmap::find[t](vb.types, root_id)) {\n+                case (some[t](?typ2)) {\n+                    ret fold_ty(tcx, fm_var(bind folder(tcx, vb, _)), typ2);\n                 }\n-\n-                case (_) { ret typ; }\n+                case (none[t]) { ret ty::mk_var(tcx, vid); }\n             }\n         }\n \n-        ret fold_ty(tcx, bind folder(tcx, vb, _), typ);\n+        ret fold_ty(tcx, fm_var(bind folder(tcx, vb, _)), typ);\n     }\n \n     // If the given type is a variable, returns the structure of that type.\n@@ -2542,32 +2562,29 @@ mod unify {\n \n     fn fixup_vars(ty_ctxt tcx, @var_bindings vb, t typ) -> fixup_result {\n         fn subst_vars(ty_ctxt tcx, @var_bindings vb,\n-                      @mutable option::t[int] unresolved, t typ) -> t {\n-            alt (struct(tcx, typ)) {\n-                case (ty::ty_var(?vid)) {\n-                    if ((vid as uint) >= ufind::set_count(vb.sets)) {\n-                        *unresolved = some[int](vid);\n-                        ret typ;\n-                    }\n+                      @mutable option::t[int] unresolved, int vid) -> t {\n+            if ((vid as uint) >= ufind::set_count(vb.sets)) {\n+                *unresolved = some[int](vid);\n+                ret ty::mk_var(tcx, vid);\n+            }\n \n-                    auto root_id = ufind::find(vb.sets, vid as uint);\n-                    alt (smallintmap::find[t](vb.types, root_id)) {\n-                        case (none[t]) {\n-                            *unresolved = some[int](vid);\n-                            ret typ;\n-                        }\n-                        case (some[t](?rt)) {\n-                            ret fold_ty(tcx,\n-                                bind subst_vars(tcx, vb, unresolved, _), rt);\n-                        }\n-                    }\n+            auto root_id = ufind::find(vb.sets, vid as uint);\n+            alt (smallintmap::find[t](vb.types, root_id)) {\n+                case (none[t]) {\n+                    *unresolved = some[int](vid);\n+                    ret ty::mk_var(tcx, vid);\n+                }\n+                case (some[t](?rt)) {\n+                    ret fold_ty(tcx,\n+                        fm_var(bind subst_vars(tcx, vb, unresolved, _)), rt);\n                 }\n-                case (_) { ret typ; }\n             }\n         }\n \n         auto unresolved = @mutable none[int];\n-        auto rty = fold_ty(tcx, bind subst_vars(tcx, vb, unresolved, _), typ);\n+        auto rty = fold_ty(tcx,\n+                           fm_var(bind subst_vars(tcx, vb, unresolved, _)),\n+                           typ);\n \n         auto ur = *unresolved;\n         alt (ur) {\n@@ -2641,25 +2658,21 @@ fn type_err_to_str(&ty::type_err err) -> str {\n // Converts type parameters in a type to type variables and returns the\n // resulting type along with a list of type variable IDs.\n fn bind_params_in_type(&ctxt cx, fn()->int next_ty_var, t typ,\n-                       uint ty_param_count)\n-        -> tup(vec[int], t) {\n+                       uint ty_param_count) -> tup(vec[int], t) {\n     let vec[int] param_var_ids = [];\n     auto i = 0u;\n     while (i < ty_param_count) {\n         param_var_ids += [next_ty_var()];\n         i += 1u;\n     }\n \n-    fn binder(ctxt cx, vec[int] param_var_ids, fn()->int next_ty_var, t typ)\n-            -> t {\n-        alt (struct(cx, typ)) {\n-            case (ty_param(?index)) { ret mk_var(cx, param_var_ids.(index)); }\n-            case (_) { ret typ; }\n-        }\n+    fn binder(ctxt cx, vec[int] param_var_ids, fn()->int next_ty_var,\n+              uint index) -> t {\n+        ret mk_var(cx, param_var_ids.(index));\n     }\n \n-    auto f = bind binder(cx, param_var_ids, next_ty_var, _);\n-    auto new_typ = fold_ty(cx, f, typ);\n+    auto new_typ = fold_ty(cx,\n+        fm_param(bind binder(cx, param_var_ids, next_ty_var, _)), typ);\n     ret tup(param_var_ids, new_typ);\n }\n \n@@ -2668,14 +2681,11 @@ fn bind_params_in_type(&ctxt cx, fn()->int next_ty_var, t typ,\n fn substitute_type_params(&ctxt cx, vec[ty::t] substs, t typ) -> t {\n     if (!type_contains_params(cx, typ)) { ret typ; }\n \n-    fn substituter(ctxt cx, vec[ty::t] substs, t typ) -> t {\n-        alt (struct(cx, typ)) {\n-            case (ty_param(?idx)) { ret substs.(idx); }\n-            case (_) { ret typ; }\n-        }\n+    fn substituter(ctxt cx, vec[ty::t] substs, uint idx) -> t {\n+        ret substs.(idx);\n     }\n \n-    ret fold_ty(cx, bind substituter(cx, substs, _), typ);\n+    ret fold_ty(cx, fm_param(bind substituter(cx, substs, _)), typ);\n }\n \n fn def_has_ty_params(&ast::def def) -> bool {"}]}