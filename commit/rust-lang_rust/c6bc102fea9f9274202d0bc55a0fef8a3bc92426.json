{"sha": "c6bc102fea9f9274202d0bc55a0fef8a3bc92426", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2YmMxMDJmZWE5ZjkyNzQyMDJkMGJjNTVhMGZlZjhhM2JjOTI0MjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-03T16:58:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-03T16:58:56Z"}, "message": "Auto merge of #87515 - crlf0710:trait_upcasting_part2, r=bjorn3\n\nTrait upcasting coercion (part2)\n\nThis is the second part of trait upcasting coercion implementation.\n\nCurrently this is blocked on #86264 .\n\nThe third part might be implemented using unsafety checking\n\nr? `@bjorn3`", "tree": {"sha": "467d0caf4e7b1c0defb58a75a5585eb3f95aecbd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/467d0caf4e7b1c0defb58a75a5585eb3f95aecbd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6bc102fea9f9274202d0bc55a0fef8a3bc92426", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6bc102fea9f9274202d0bc55a0fef8a3bc92426", "html_url": "https://github.com/rust-lang/rust/commit/c6bc102fea9f9274202d0bc55a0fef8a3bc92426", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5fd37f00f1ec5e4a4b0d87f5af0b93f36aab271", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5fd37f00f1ec5e4a4b0d87f5af0b93f36aab271", "html_url": "https://github.com/rust-lang/rust/commit/d5fd37f00f1ec5e4a4b0d87f5af0b93f36aab271"}, {"sha": "3cb625e4683c43991de6fc27d6b4e0db5a34011f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cb625e4683c43991de6fc27d6b4e0db5a34011f", "html_url": "https://github.com/rust-lang/rust/commit/3cb625e4683c43991de6fc27d6b4e0db5a34011f"}], "stats": {"total": 1279, "additions": 1186, "deletions": 93}, "files": [{"sha": "d594731b4dfce5870bc9358d0a5edf466f64fe60", "filename": "compiler/rustc_codegen_cranelift/src/unsize.rs", "status": "modified", "additions": 48, "deletions": 15, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs?ref=c6bc102fea9f9274202d0bc55a0fef8a3bc92426", "patch": "@@ -25,39 +25,73 @@ pub(crate) fn unsized_info<'tcx>(\n             .bcx\n             .ins()\n             .iconst(fx.pointer_type, len.eval_usize(fx.tcx, ParamEnv::reveal_all()) as i64),\n-        (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n-            // For now, upcasts are limited to changes in marker\n-            // traits, and hence never actually require an actual\n-            // change to the vtable.\n-            old_info.expect(\"unsized_info: missing old info for trait upcast\")\n+        (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n+            let old_info =\n+                old_info.expect(\"unsized_info: missing old info for trait upcasting coercion\");\n+            if data_a.principal_def_id() == data_b.principal_def_id() {\n+                return old_info;\n+            }\n+            // trait upcasting coercion\n+\n+            // if both of the two `principal`s are `None`, this function would have returned early above.\n+            // and if one of the two `principal`s is `None`, typechecking would have rejected this case.\n+            let principal_a = data_a\n+                .principal()\n+                .expect(\"unsized_info: missing principal trait for trait upcasting coercion\");\n+            let principal_b = data_b\n+                .principal()\n+                .expect(\"unsized_info: missing principal trait for trait upcasting coercion\");\n+\n+            let vptr_entry_idx = fx.tcx.vtable_trait_upcasting_coercion_new_vptr_slot((\n+                principal_a.with_self_ty(fx.tcx, source),\n+                principal_b.with_self_ty(fx.tcx, source),\n+            ));\n+\n+            if let Some(entry_idx) = vptr_entry_idx {\n+                let entry_idx = u32::try_from(entry_idx).unwrap();\n+                let entry_offset = entry_idx * fx.pointer_type.bytes();\n+                let vptr_ptr = Pointer::new(old_info).offset_i64(fx, entry_offset.into()).load(\n+                    fx,\n+                    fx.pointer_type,\n+                    crate::vtable::vtable_memflags(),\n+                );\n+                vptr_ptr\n+            } else {\n+                old_info\n+            }\n         }\n         (_, &ty::Dynamic(ref data, ..)) => crate::vtable::get_vtable(fx, source, data.principal()),\n         _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\", source, target),\n     }\n }\n \n-/// Coerce `src` to `dst_ty`. `src_ty` must be a thin pointer.\n-fn unsize_thin_ptr<'tcx>(\n+/// Coerce `src` to `dst_ty`.\n+fn unsize_ptr<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     src: Value,\n     src_layout: TyAndLayout<'tcx>,\n     dst_layout: TyAndLayout<'tcx>,\n+    old_info: Option<Value>,\n ) -> (Value, Value) {\n     match (&src_layout.ty.kind(), &dst_layout.ty.kind()) {\n         (&ty::Ref(_, a, _), &ty::Ref(_, b, _))\n         | (&ty::Ref(_, a, _), &ty::RawPtr(ty::TypeAndMut { ty: b, .. }))\n         | (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }), &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n             assert!(!fx.layout_of(a).is_unsized());\n-            (src, unsized_info(fx, a, b, None))\n+            (src, unsized_info(fx, a, b, old_info))\n         }\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n             let (a, b) = (src_layout.ty.boxed_ty(), dst_layout.ty.boxed_ty());\n             assert!(!fx.layout_of(a).is_unsized());\n-            (src, unsized_info(fx, a, b, None))\n+            (src, unsized_info(fx, a, b, old_info))\n         }\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n             assert_eq!(def_a, def_b);\n \n+            if src_layout == dst_layout {\n+                return (src, old_info.unwrap());\n+            }\n+\n             let mut result = None;\n             for i in 0..src_layout.fields.count() {\n                 let src_f = src_layout.field(fx, i);\n@@ -71,11 +105,11 @@ fn unsize_thin_ptr<'tcx>(\n                 let dst_f = dst_layout.field(fx, i);\n                 assert_ne!(src_f.ty, dst_f.ty);\n                 assert_eq!(result, None);\n-                result = Some(unsize_thin_ptr(fx, src, src_f, dst_f));\n+                result = Some(unsize_ptr(fx, src, src_f, dst_f, old_info));\n             }\n             result.unwrap()\n         }\n-        _ => bug!(\"unsize_thin_ptr: called on bad types\"),\n+        _ => bug!(\"unsize_ptr: called on bad types\"),\n     }\n }\n \n@@ -91,12 +125,11 @@ pub(crate) fn coerce_unsized_into<'tcx>(\n     let mut coerce_ptr = || {\n         let (base, info) =\n             if fx.layout_of(src.layout().ty.builtin_deref(true).unwrap().ty).is_unsized() {\n-                // fat-ptr to fat-ptr unsize preserves the vtable\n-                // i.e., &'a fmt::Debug+Send => &'a fmt::Debug\n-                src.load_scalar_pair(fx)\n+                let (old_base, old_info) = src.load_scalar_pair(fx);\n+                unsize_ptr(fx, old_base, src.layout(), dst.layout(), Some(old_info))\n             } else {\n                 let base = src.load_scalar(fx);\n-                unsize_thin_ptr(fx, base, src.layout(), dst.layout())\n+                unsize_ptr(fx, base, src.layout(), dst.layout(), None)\n             };\n         dst.write_cvalue(fx, CValue::by_val_pair(base, info, dst.layout()));\n     };"}, {"sha": "1b31587430887e3931829a4c81f3c86e109e1b75", "filename": "compiler/rustc_codegen_cranelift/src/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs?ref=c6bc102fea9f9274202d0bc55a0fef8a3bc92426", "patch": "@@ -5,7 +5,7 @@\n use crate::constant::data_id_for_alloc_id;\n use crate::prelude::*;\n \n-fn vtable_memflags() -> MemFlags {\n+pub(crate) fn vtable_memflags() -> MemFlags {\n     let mut flags = MemFlags::trusted(); // A vtable access is always aligned and will never trap.\n     flags.set_readonly(); // A vtable is always read-only.\n     flags"}, {"sha": "87b342e844391be3f004949e120fb518be45e2a1", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 66, "deletions": 41, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=c6bc102fea9f9274202d0bc55a0fef8a3bc92426", "patch": "@@ -23,7 +23,6 @@ use rustc_middle::middle::cstore::EncodedMetadata;\n use rustc_middle::middle::lang_items;\n use rustc_middle::mir::mono::{CodegenUnit, CodegenUnitNameBuilder, MonoItem};\n use rustc_middle::ty::layout::{HasTyCtxt, TyAndLayout};\n-use rustc_middle::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Instance, Ty, TyCtxt};\n use rustc_session::cgu_reuse_tracker::CguReuse;\n@@ -32,6 +31,7 @@ use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_target::abi::{Align, LayoutOf, VariantIdx};\n \n+use std::convert::TryFrom;\n use std::ops::{Deref, DerefMut};\n use std::time::{Duration, Instant};\n \n@@ -128,55 +128,92 @@ pub fn compare_simd_types<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n ///\n /// The `old_info` argument is a bit odd. It is intended for use in an upcast,\n /// where the new vtable for an object will be derived from the old one.\n-pub fn unsized_info<'tcx, Cx: CodegenMethods<'tcx>>(\n-    cx: &Cx,\n+pub fn unsized_info<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &mut Bx,\n     source: Ty<'tcx>,\n     target: Ty<'tcx>,\n-    old_info: Option<Cx::Value>,\n-) -> Cx::Value {\n+    old_info: Option<Bx::Value>,\n+) -> Bx::Value {\n+    let cx = bx.cx();\n     let (source, target) =\n-        cx.tcx().struct_lockstep_tails_erasing_lifetimes(source, target, cx.param_env());\n+        cx.tcx().struct_lockstep_tails_erasing_lifetimes(source, target, bx.param_env());\n     match (source.kind(), target.kind()) {\n         (&ty::Array(_, len), &ty::Slice(_)) => {\n             cx.const_usize(len.eval_usize(cx.tcx(), ty::ParamEnv::reveal_all()))\n         }\n-        (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n-            // For now, upcasts are limited to changes in marker\n-            // traits, and hence never actually require an actual\n-            // change to the vtable.\n-            old_info.expect(\"unsized_info: missing old info for trait upcast\")\n+        (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n+            let old_info =\n+                old_info.expect(\"unsized_info: missing old info for trait upcasting coercion\");\n+            if data_a.principal_def_id() == data_b.principal_def_id() {\n+                return old_info;\n+            }\n+\n+            // trait upcasting coercion\n+\n+            // if both of the two `principal`s are `None`, this function would have returned early above.\n+            // and if one of the two `principal`s is `None`, typechecking would have rejected this case.\n+            let principal_a = data_a\n+                .principal()\n+                .expect(\"unsized_info: missing principal trait for trait upcasting coercion\");\n+            let principal_b = data_b\n+                .principal()\n+                .expect(\"unsized_info: missing principal trait for trait upcasting coercion\");\n+\n+            let vptr_entry_idx = cx.tcx().vtable_trait_upcasting_coercion_new_vptr_slot((\n+                principal_a.with_self_ty(cx.tcx(), source),\n+                principal_b.with_self_ty(cx.tcx(), source),\n+            ));\n+\n+            if let Some(entry_idx) = vptr_entry_idx {\n+                let ptr_ty = cx.type_i8p();\n+                let ptr_align = cx.tcx().data_layout.pointer_align.abi;\n+                let llvtable = bx.pointercast(old_info, bx.type_ptr_to(ptr_ty));\n+                let gep =\n+                    bx.inbounds_gep(llvtable, &[bx.const_usize(u64::try_from(entry_idx).unwrap())]);\n+                let new_vptr = bx.load(ptr_ty, gep, ptr_align);\n+                bx.nonnull_metadata(new_vptr);\n+                // Vtable loads are invariant.\n+                bx.set_invariant_load(new_vptr);\n+                new_vptr\n+            } else {\n+                old_info\n+            }\n         }\n         (_, &ty::Dynamic(ref data, ..)) => {\n-            let vtable_ptr = cx.layout_of(cx.tcx().mk_mut_ptr(target)).field(cx, FAT_PTR_EXTRA);\n-            cx.const_ptrcast(\n-                meth::get_vtable(cx, source, data.principal()),\n-                cx.backend_type(vtable_ptr),\n-            )\n+            let vtable_ptr_ty = cx.scalar_pair_element_backend_type(\n+                cx.layout_of(cx.tcx().mk_mut_ptr(target)),\n+                1,\n+                true,\n+            );\n+            cx.const_ptrcast(meth::get_vtable(cx, source, data.principal()), vtable_ptr_ty)\n         }\n         _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\", source, target),\n     }\n }\n \n-/// Coerces `src` to `dst_ty`. `src_ty` must be a thin pointer.\n-pub fn unsize_thin_ptr<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n+/// Coerces `src` to `dst_ty`. `src_ty` must be a pointer.\n+pub fn unsize_ptr<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     src: Bx::Value,\n     src_ty: Ty<'tcx>,\n     dst_ty: Ty<'tcx>,\n+    old_info: Option<Bx::Value>,\n ) -> (Bx::Value, Bx::Value) {\n-    debug!(\"unsize_thin_ptr: {:?} => {:?}\", src_ty, dst_ty);\n+    debug!(\"unsize_ptr: {:?} => {:?}\", src_ty, dst_ty);\n     match (src_ty.kind(), dst_ty.kind()) {\n         (&ty::Ref(_, a, _), &ty::Ref(_, b, _) | &ty::RawPtr(ty::TypeAndMut { ty: b, .. }))\n         | (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }), &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n-            assert!(bx.cx().type_is_sized(a));\n+            assert_eq!(bx.cx().type_is_sized(a), old_info.is_none());\n             let ptr_ty = bx.cx().type_ptr_to(bx.cx().backend_type(bx.cx().layout_of(b)));\n-            (bx.pointercast(src, ptr_ty), unsized_info(bx.cx(), a, b, None))\n+            (bx.pointercast(src, ptr_ty), unsized_info(bx, a, b, old_info))\n         }\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n             assert_eq!(def_a, def_b);\n-\n             let src_layout = bx.cx().layout_of(src_ty);\n             let dst_layout = bx.cx().layout_of(dst_ty);\n+            if src_ty == dst_ty {\n+                return (src, old_info.unwrap());\n+            }\n             let mut result = None;\n             for i in 0..src_layout.fields.count() {\n                 let src_f = src_layout.field(bx.cx(), i);\n@@ -190,18 +227,15 @@ pub fn unsize_thin_ptr<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 let dst_f = dst_layout.field(bx.cx(), i);\n                 assert_ne!(src_f.ty, dst_f.ty);\n                 assert_eq!(result, None);\n-                result = Some(unsize_thin_ptr(bx, src, src_f.ty, dst_f.ty));\n+                result = Some(unsize_ptr(bx, src, src_f.ty, dst_f.ty, old_info));\n             }\n             let (lldata, llextra) = result.unwrap();\n+            let lldata_ty = bx.cx().scalar_pair_element_backend_type(dst_layout, 0, true);\n+            let llextra_ty = bx.cx().scalar_pair_element_backend_type(dst_layout, 1, true);\n             // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n-            // FIXME(eddyb) move these out of this `match` arm, so they're always\n-            // applied, uniformly, no matter the source/destination types.\n-            (\n-                bx.bitcast(lldata, bx.cx().scalar_pair_element_backend_type(dst_layout, 0, true)),\n-                bx.bitcast(llextra, bx.cx().scalar_pair_element_backend_type(dst_layout, 1, true)),\n-            )\n+            (bx.bitcast(lldata, lldata_ty), bx.bitcast(llextra, llextra_ty))\n         }\n-        _ => bug!(\"unsize_thin_ptr: called on bad types\"),\n+        _ => bug!(\"unsize_ptr: called on bad types\"),\n     }\n }\n \n@@ -217,17 +251,8 @@ pub fn coerce_unsized_into<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     match (src_ty.kind(), dst_ty.kind()) {\n         (&ty::Ref(..), &ty::Ref(..) | &ty::RawPtr(..)) | (&ty::RawPtr(..), &ty::RawPtr(..)) => {\n             let (base, info) = match bx.load_operand(src).val {\n-                OperandValue::Pair(base, info) => {\n-                    // fat-ptr to fat-ptr unsize preserves the vtable\n-                    // i.e., &'a fmt::Debug+Send => &'a fmt::Debug\n-                    // So we need to pointercast the base to ensure\n-                    // the types match up.\n-                    // FIXME(eddyb) use `scalar_pair_element_backend_type` here,\n-                    // like `unsize_thin_ptr` does.\n-                    let thin_ptr = dst.layout.field(bx.cx(), FAT_PTR_ADDR);\n-                    (bx.pointercast(base, bx.cx().backend_type(thin_ptr)), info)\n-                }\n-                OperandValue::Immediate(base) => unsize_thin_ptr(bx, base, src_ty, dst_ty),\n+                OperandValue::Pair(base, info) => unsize_ptr(bx, base, src_ty, dst_ty, Some(info)),\n+                OperandValue::Immediate(base) => unsize_ptr(bx, base, src_ty, dst_ty, None),\n                 OperandValue::Ref(..) => bug!(),\n             };\n             OperandValue::Pair(base, info).store(bx, dst);"}, {"sha": "7e1dfeb2457ebb88c17f24ac56931cf1d17fa3c6", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=c6bc102fea9f9274202d0bc55a0fef8a3bc92426", "patch": "@@ -220,34 +220,23 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     }\n                     mir::CastKind::Pointer(PointerCast::Unsize) => {\n                         assert!(bx.cx().is_backend_scalar_pair(cast));\n-                        match operand.val {\n+                        let (lldata, llextra) = match operand.val {\n                             OperandValue::Pair(lldata, llextra) => {\n                                 // unsize from a fat pointer -- this is a\n-                                // \"trait-object-to-supertrait\" coercion, for\n-                                // example, `&'a fmt::Debug + Send => &'a fmt::Debug`.\n-\n-                                // HACK(eddyb) have to bitcast pointers\n-                                // until LLVM removes pointee types.\n-                                let lldata = bx.pointercast(\n-                                    lldata,\n-                                    bx.cx().scalar_pair_element_backend_type(cast, 0, true),\n-                                );\n-                                OperandValue::Pair(lldata, llextra)\n+                                // \"trait-object-to-supertrait\" coercion.\n+                                (lldata, Some(llextra))\n                             }\n                             OperandValue::Immediate(lldata) => {\n                                 // \"standard\" unsize\n-                                let (lldata, llextra) = base::unsize_thin_ptr(\n-                                    &mut bx,\n-                                    lldata,\n-                                    operand.layout.ty,\n-                                    cast.ty,\n-                                );\n-                                OperandValue::Pair(lldata, llextra)\n+                                (lldata, None)\n                             }\n                             OperandValue::Ref(..) => {\n                                 bug!(\"by-ref operand {:?} in `codegen_rvalue_operand`\", operand);\n                             }\n-                        }\n+                        };\n+                        let (lldata, llextra) =\n+                            base::unsize_ptr(&mut bx, lldata, operand.layout.ty, cast.ty, llextra);\n+                        OperandValue::Pair(lldata, llextra)\n                     }\n                     mir::CastKind::Pointer(PointerCast::MutToConstPointer)\n                     | mir::CastKind::Misc"}, {"sha": "3c16852df059a9ee6b6938cd9bb7fdffaf252679", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=c6bc102fea9f9274202d0bc55a0fef8a3bc92426", "patch": "@@ -977,6 +977,11 @@ rustc_queries! {\n         desc { |tcx| \"finding all vtable entries for trait {}\", tcx.def_path_str(key.def_id()) }\n     }\n \n+    query vtable_trait_upcasting_coercion_new_vptr_slot(key: (ty::PolyTraitRef<'tcx>, ty::PolyTraitRef<'tcx>)) -> Option<usize> {\n+        desc { |tcx| \"finding the slot within vtable for trait {} vtable ptr during trait upcasting coercion from {} vtable\",\n+            tcx.def_path_str(key.1.def_id()), tcx.def_path_str(key.0.def_id()) }\n+    }\n+\n     query codegen_fulfill_obligation(\n         key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)\n     ) -> Result<ImplSource<'tcx, ()>, ErrorReported> {"}, {"sha": "cee4c2e30aa0973c019918601828caeed5a8f025", "filename": "compiler/rustc_mir/src/interpret/cast.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs?ref=c6bc102fea9f9274202d0bc55a0fef8a3bc92426", "patch": "@@ -269,12 +269,34 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Immediate::new_slice(ptr, length.eval_usize(*self.tcx, self.param_env), self);\n                 self.write_immediate(val, dest)\n             }\n-            (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n-                // For now, upcasts are limited to changes in marker\n-                // traits, and hence never actually require an actual\n-                // change to the vtable.\n+            (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n                 let val = self.read_immediate(src)?;\n-                self.write_immediate(*val, dest)\n+                if data_a.principal_def_id() == data_b.principal_def_id() {\n+                    return self.write_immediate(*val, dest);\n+                }\n+                // trait upcasting coercion\n+                let principal_a = data_a.principal().expect(\n+                    \"unsize_into_ptr: missing principal trait for trait upcasting coercion\",\n+                );\n+                let principal_b = data_b.principal().expect(\n+                    \"unsize_into_ptr: missing principal trait for trait upcasting coercion\",\n+                );\n+\n+                let vptr_entry_idx = self.tcx.vtable_trait_upcasting_coercion_new_vptr_slot((\n+                    principal_a.with_self_ty(*self.tcx, src_pointee_ty),\n+                    principal_b.with_self_ty(*self.tcx, src_pointee_ty),\n+                ));\n+\n+                if let Some(entry_idx) = vptr_entry_idx {\n+                    let entry_idx = u64::try_from(entry_idx).unwrap();\n+                    let (old_data, old_vptr) = val.to_scalar_pair()?;\n+                    let old_vptr = self.scalar_to_ptr(old_vptr);\n+                    let new_vptr = self\n+                        .read_new_vtable_after_trait_upcasting_from_vtable(old_vptr, entry_idx)?;\n+                    self.write_immediate(Immediate::new_dyn_trait(old_data, new_vptr, self), dest)\n+                } else {\n+                    self.write_immediate(*val, dest)\n+                }\n             }\n             (_, &ty::Dynamic(ref data, _)) => {\n                 // Initial cast from sized to dyn trait"}, {"sha": "d5bc2b1e2eacb86318f983aad25f6cc49166386d", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=c6bc102fea9f9274202d0bc55a0fef8a3bc92426", "patch": "@@ -63,22 +63,36 @@ impl<'tcx, Tag: Provenance> Immediate<Tag> {\n         Immediate::ScalarPair(val.into(), Scalar::from_machine_usize(len, cx).into())\n     }\n \n-    pub fn new_dyn_trait(val: Scalar<Tag>, vtable: Pointer<Tag>, cx: &impl HasDataLayout) -> Self {\n-        Immediate::ScalarPair(val.into(), ScalarMaybeUninit::from_pointer(vtable, cx))\n+    pub fn new_dyn_trait(\n+        val: Scalar<Tag>,\n+        vtable: Pointer<Option<Tag>>,\n+        cx: &impl HasDataLayout,\n+    ) -> Self {\n+        Immediate::ScalarPair(val.into(), ScalarMaybeUninit::from_maybe_pointer(vtable, cx))\n     }\n \n     #[inline]\n     pub fn to_scalar_or_uninit(self) -> ScalarMaybeUninit<Tag> {\n         match self {\n             Immediate::Scalar(val) => val,\n-            Immediate::ScalarPair(..) => bug!(\"Got a wide pointer where a scalar was expected\"),\n+            Immediate::ScalarPair(..) => bug!(\"Got a scalar pair where a scalar was expected\"),\n         }\n     }\n \n     #[inline]\n     pub fn to_scalar(self) -> InterpResult<'tcx, Scalar<Tag>> {\n         self.to_scalar_or_uninit().check_init()\n     }\n+\n+    #[inline]\n+    pub fn to_scalar_pair(self) -> InterpResult<'tcx, (Scalar<Tag>, Scalar<Tag>)> {\n+        match self {\n+            Immediate::ScalarPair(val1, val2) => Ok((val1.check_init()?, val2.check_init()?)),\n+            Immediate::Scalar(..) => {\n+                bug!(\"Got a scalar where a scalar pair was expected\")\n+            }\n+        }\n+    }\n }\n \n // ScalarPair needs a type to interpret, so we often have an immediate and a type together"}, {"sha": "a6ba00ec6952ece9e30b54fa295720de1669fa97", "filename": "compiler/rustc_mir/src/interpret/traits.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs?ref=c6bc102fea9f9274202d0bc55a0fef8a3bc92426", "patch": "@@ -21,7 +21,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &mut self,\n         ty: Ty<'tcx>,\n         poly_trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n-    ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n+    ) -> InterpResult<'tcx, Pointer<Option<M::PointerTag>>> {\n         trace!(\"get_vtable(trait_ref={:?})\", poly_trait_ref);\n \n         let (ty, poly_trait_ref) = self.tcx.erase_regions((ty, poly_trait_ref));\n@@ -34,7 +34,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         let vtable_ptr = self.memory.global_base_pointer(Pointer::from(vtable_allocation))?;\n \n-        Ok(vtable_ptr)\n+        Ok(vtable_ptr.into())\n     }\n \n     /// Resolves the function at the specified slot in the provided\n@@ -121,4 +121,22 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n         Ok((Size::from_bytes(size), align))\n     }\n+\n+    pub fn read_new_vtable_after_trait_upcasting_from_vtable(\n+        &self,\n+        vtable: Pointer<Option<M::PointerTag>>,\n+        idx: u64,\n+    ) -> InterpResult<'tcx, Pointer<Option<M::PointerTag>>> {\n+        let pointer_size = self.pointer_size();\n+\n+        let vtable_slot = vtable.offset(pointer_size * idx, self)?;\n+        let new_vtable = self\n+            .memory\n+            .get(vtable_slot, pointer_size, self.tcx.data_layout.pointer_align.abi)?\n+            .expect(\"cannot be a ZST\");\n+\n+        let new_vtable = self.scalar_to_ptr(new_vtable.read_ptr_sized(Size::ZERO)?.check_init()?);\n+\n+        Ok(new_vtable)\n+    }\n }"}, {"sha": "ace7cffd16dafb3c22168a5fc8edcc89bc79e34e", "filename": "compiler/rustc_query_impl/src/keys.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs?ref=c6bc102fea9f9274202d0bc55a0fef8a3bc92426", "patch": "@@ -282,6 +282,16 @@ impl<'tcx> Key for ty::PolyTraitRef<'tcx> {\n     }\n }\n \n+impl<'tcx> Key for (ty::PolyTraitRef<'tcx>, ty::PolyTraitRef<'tcx>) {\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        self.0.def_id().krate == LOCAL_CRATE\n+    }\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n+        tcx.def_span(self.0.def_id())\n+    }\n+}\n+\n impl<'tcx> Key for GenericArg<'tcx> {\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {"}, {"sha": "585fcf795b7f5fb2cd0cf22615edfbfcffc68183", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=c6bc102fea9f9274202d0bc55a0fef8a3bc92426", "patch": "@@ -756,16 +756,17 @@ fn vtable_trait_first_method_offset<'tcx>(\n }\n \n /// Find slot offset for trait vptr within vtable entries of another trait\n-/// FIXME: This function is not yet used. Remove `#[allow(dead_code)]` when it's used in upcoming pr.\n-#[allow(dead_code)]\n-fn vtable_trait_vptr_slot_offset<'tcx>(\n+pub fn vtable_trait_upcasting_coercion_new_vptr_slot(\n     tcx: TyCtxt<'tcx>,\n     key: (\n-        ty::PolyTraitRef<'tcx>, // trait_to_be_found\n-        ty::PolyTraitRef<'tcx>, // trait_owning_vtable\n+        ty::PolyTraitRef<'tcx>, // trait owning vtable\n+        ty::PolyTraitRef<'tcx>, // super trait ref\n     ),\n ) -> Option<usize> {\n-    let (trait_to_be_found, trait_owning_vtable) = key;\n+    let (trait_owning_vtable, super_trait_ref) = key;\n+    let super_trait_did = super_trait_ref.def_id();\n+    // FIXME: take substsref part into account here after upcasting coercion allows the same def_id occur\n+    // multiple times.\n \n     let vtable_segment_callback = {\n         let mut vptr_offset = 0;\n@@ -776,7 +777,7 @@ fn vtable_trait_vptr_slot_offset<'tcx>(\n                 }\n                 VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n                     vptr_offset += util::count_own_vtable_entries(tcx, trait_ref);\n-                    if trait_ref == trait_to_be_found {\n+                    if trait_ref.def_id() == super_trait_did {\n                         if emit_vptr {\n                             return ControlFlow::Break(Some(vptr_offset));\n                         } else {\n@@ -810,6 +811,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         specializes: specialize::specializes,\n         codegen_fulfill_obligation: codegen::codegen_fulfill_obligation,\n         vtable_entries,\n+        vtable_trait_upcasting_coercion_new_vptr_slot,\n         subst_and_check_impossible_predicates,\n         mir_abstract_const: |tcx, def_id| {\n             let def_id = def_id.expect_local();"}, {"sha": "3697ae38f9d818f38512c4b49f4dd4f9e45c9e50", "filename": "src/doc/unstable-book/src/language-features/trait-upcasting.md", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftrait-upcasting.md", "raw_url": "https://github.com/rust-lang/rust/raw/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftrait-upcasting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftrait-upcasting.md?ref=c6bc102fea9f9274202d0bc55a0fef8a3bc92426", "patch": "@@ -0,0 +1,27 @@\n+# `trait_upcasting`\n+\n+The tracking issue for this feature is: [#65991]\n+\n+[#65991]: https://github.com/rust-lang/rust/issues/65991\n+\n+------------------------\n+\n+The `trait_upcasting` feature adds support for trait upcasting coercion. This allows a\n+trait object of type `dyn Bar` to be cast to a trait object of type `dyn Foo`\n+so long as `Bar: Foo`.\n+\n+```rust,edition2018\n+#![feature(trait_upcasting)]\n+#![allow(incomplete_features)]\n+\n+trait Foo {}\n+\n+trait Bar: Foo {}\n+\n+impl Foo for i32 {}\n+\n+impl<T: Foo + ?Sized> Bar for T {}\n+\n+let bar: &dyn Bar = &123;\n+let foo: &dyn Foo = bar;\n+```"}, {"sha": "484a222bc012d4381b170c1ac235c3c3d47034eb", "filename": "src/test/ui/traits/trait-upcasting/basic.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fbasic.rs?ref=c6bc102fea9f9274202d0bc55a0fef8a3bc92426", "patch": "@@ -0,0 +1,87 @@\n+// run-pass\n+\n+#![feature(trait_upcasting)]\n+#![allow(incomplete_features)]\n+\n+trait Foo: PartialEq<i32> + std::fmt::Debug + Send + Sync {\n+    fn a(&self) -> i32 {\n+        10\n+    }\n+\n+    fn z(&self) -> i32 {\n+        11\n+    }\n+\n+    fn y(&self) -> i32 {\n+        12\n+    }\n+}\n+\n+trait Bar: Foo {\n+    fn b(&self) -> i32 {\n+        20\n+    }\n+\n+    fn w(&self) -> i32 {\n+        21\n+    }\n+}\n+\n+trait Baz: Bar {\n+    fn c(&self) -> i32 {\n+        30\n+    }\n+}\n+\n+impl Foo for i32 {\n+    fn a(&self) -> i32 {\n+        100\n+    }\n+}\n+\n+impl Bar for i32 {\n+    fn b(&self) -> i32 {\n+        200\n+    }\n+}\n+\n+impl Baz for i32 {\n+    fn c(&self) -> i32 {\n+        300\n+    }\n+}\n+\n+fn main() {\n+    let baz: &dyn Baz = &1;\n+    let _: &dyn std::fmt::Debug = baz;\n+    assert_eq!(*baz, 1);\n+    assert_eq!(baz.a(), 100);\n+    assert_eq!(baz.b(), 200);\n+    assert_eq!(baz.c(), 300);\n+    assert_eq!(baz.z(), 11);\n+    assert_eq!(baz.y(), 12);\n+    assert_eq!(baz.w(), 21);\n+\n+    let bar: &dyn Bar = baz;\n+    let _: &dyn std::fmt::Debug = bar;\n+    assert_eq!(*bar, 1);\n+    assert_eq!(bar.a(), 100);\n+    assert_eq!(bar.b(), 200);\n+    assert_eq!(bar.z(), 11);\n+    assert_eq!(bar.y(), 12);\n+    assert_eq!(bar.w(), 21);\n+\n+    let foo: &dyn Foo = baz;\n+    let _: &dyn std::fmt::Debug = foo;\n+    assert_eq!(*foo, 1);\n+    assert_eq!(foo.a(), 100);\n+    assert_eq!(foo.z(), 11);\n+    assert_eq!(foo.y(), 12);\n+\n+    let foo: &dyn Foo = bar;\n+    let _: &dyn std::fmt::Debug = foo;\n+    assert_eq!(*foo, 1);\n+    assert_eq!(foo.a(), 100);\n+    assert_eq!(foo.z(), 11);\n+    assert_eq!(foo.y(), 12);\n+}"}, {"sha": "511e41562b2203e49cfd395e487bee2da9673fa1", "filename": "src/test/ui/traits/trait-upcasting/cyclic-trait-resolution.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fcyclic-trait-resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fcyclic-trait-resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fcyclic-trait-resolution.rs?ref=c6bc102fea9f9274202d0bc55a0fef8a3bc92426", "patch": "@@ -0,0 +1,13 @@\n+trait A: B + A {}\n+//~^ ERROR cycle detected when computing the super predicates of `A` [E0391]\n+\n+trait B {}\n+\n+impl A for () {}\n+\n+impl B for () {}\n+\n+fn main() {\n+    let a: Box<dyn A> = Box::new(());\n+    let _b: Box<dyn B> = a;\n+}"}, {"sha": "ac005725ab48527f594766d47df862f6473c1786", "filename": "src/test/ui/traits/trait-upcasting/cyclic-trait-resolution.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fcyclic-trait-resolution.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fcyclic-trait-resolution.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fcyclic-trait-resolution.stderr?ref=c6bc102fea9f9274202d0bc55a0fef8a3bc92426", "patch": "@@ -0,0 +1,21 @@\n+error[E0391]: cycle detected when computing the super predicates of `A`\n+  --> $DIR/cyclic-trait-resolution.rs:1:1\n+   |\n+LL | trait A: B + A {}\n+   | ^^^^^^^^^^^^^^\n+   |\n+note: ...which requires computing the super traits of `A`...\n+  --> $DIR/cyclic-trait-resolution.rs:1:14\n+   |\n+LL | trait A: B + A {}\n+   |              ^\n+   = note: ...which again requires computing the super predicates of `A`, completing the cycle\n+note: cycle used when collecting item types in top-level module\n+  --> $DIR/cyclic-trait-resolution.rs:1:1\n+   |\n+LL | trait A: B + A {}\n+   | ^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0391`."}, {"sha": "e4e23c1a26e78d8072b12df911b0c7eada1d2b6a", "filename": "src/test/ui/traits/trait-upcasting/diamond.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fdiamond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fdiamond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fdiamond.rs?ref=c6bc102fea9f9274202d0bc55a0fef8a3bc92426", "patch": "@@ -0,0 +1,115 @@\n+// run-pass\n+\n+#![feature(trait_upcasting)]\n+#![allow(incomplete_features)]\n+\n+trait Foo: PartialEq<i32> + std::fmt::Debug + Send + Sync {\n+    fn a(&self) -> i32 {\n+        10\n+    }\n+\n+    fn z(&self) -> i32 {\n+        11\n+    }\n+\n+    fn y(&self) -> i32 {\n+        12\n+    }\n+}\n+\n+trait Bar1: Foo {\n+    fn b(&self) -> i32 {\n+        20\n+    }\n+\n+    fn w(&self) -> i32 {\n+        21\n+    }\n+}\n+\n+trait Bar2: Foo {\n+    fn c(&self) -> i32 {\n+        30\n+    }\n+\n+    fn v(&self) -> i32 {\n+        31\n+    }\n+}\n+\n+trait Baz: Bar1 + Bar2 {\n+    fn d(&self) -> i32 {\n+        40\n+    }\n+}\n+\n+impl Foo for i32 {\n+    fn a(&self) -> i32 {\n+        100\n+    }\n+}\n+\n+impl Bar1 for i32 {\n+    fn b(&self) -> i32 {\n+        200\n+    }\n+}\n+\n+impl Bar2 for i32 {\n+    fn c(&self) -> i32 {\n+        300\n+    }\n+}\n+\n+impl Baz for i32 {\n+    fn d(&self) -> i32 {\n+        400\n+    }\n+}\n+\n+fn main() {\n+    let baz: &dyn Baz = &1;\n+    let _: &dyn std::fmt::Debug = baz;\n+    assert_eq!(*baz, 1);\n+    assert_eq!(baz.a(), 100);\n+    assert_eq!(baz.b(), 200);\n+    assert_eq!(baz.c(), 300);\n+    assert_eq!(baz.d(), 400);\n+    assert_eq!(baz.z(), 11);\n+    assert_eq!(baz.y(), 12);\n+    assert_eq!(baz.w(), 21);\n+    assert_eq!(baz.v(), 31);\n+\n+    let bar1: &dyn Bar1 = baz;\n+    let _: &dyn std::fmt::Debug = bar1;\n+    assert_eq!(*bar1, 1);\n+    assert_eq!(bar1.a(), 100);\n+    assert_eq!(bar1.b(), 200);\n+    assert_eq!(bar1.z(), 11);\n+    assert_eq!(bar1.y(), 12);\n+    assert_eq!(bar1.w(), 21);\n+\n+    let bar2: &dyn Bar2 = baz;\n+    let _: &dyn std::fmt::Debug = bar2;\n+    assert_eq!(*bar2, 1);\n+    assert_eq!(bar2.a(), 100);\n+    assert_eq!(bar2.c(), 300);\n+    assert_eq!(bar2.z(), 11);\n+    assert_eq!(bar2.y(), 12);\n+    assert_eq!(bar2.v(), 31);\n+\n+    let foo: &dyn Foo = baz;\n+    let _: &dyn std::fmt::Debug = foo;\n+    assert_eq!(*foo, 1);\n+    assert_eq!(foo.a(), 100);\n+\n+    let foo: &dyn Foo = bar1;\n+    let _: &dyn std::fmt::Debug = foo;\n+    assert_eq!(*foo, 1);\n+    assert_eq!(foo.a(), 100);\n+\n+    let foo: &dyn Foo = bar2;\n+    let _: &dyn std::fmt::Debug = foo;\n+    assert_eq!(*foo, 1);\n+    assert_eq!(foo.a(), 100);\n+}"}, {"sha": "24022450406a7a32e9da535ce7f275aee6d1c3d2", "filename": "src/test/ui/traits/trait-upcasting/invalid-upcast.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Finvalid-upcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Finvalid-upcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Finvalid-upcast.rs?ref=c6bc102fea9f9274202d0bc55a0fef8a3bc92426", "patch": "@@ -0,0 +1,87 @@\n+#![feature(trait_upcasting)]\n+#![allow(incomplete_features)]\n+\n+trait Foo {\n+    fn a(&self) -> i32 {\n+        10\n+    }\n+\n+    fn z(&self) -> i32 {\n+        11\n+    }\n+\n+    fn y(&self) -> i32 {\n+        12\n+    }\n+}\n+\n+trait Bar {\n+    fn b(&self) -> i32 {\n+        20\n+    }\n+\n+    fn w(&self) -> i32 {\n+        21\n+    }\n+}\n+\n+trait Baz {\n+    fn c(&self) -> i32 {\n+        30\n+    }\n+}\n+\n+impl Foo for i32 {\n+    fn a(&self) -> i32 {\n+        100\n+    }\n+}\n+\n+impl Bar for i32 {\n+    fn b(&self) -> i32 {\n+        200\n+    }\n+}\n+\n+impl Baz for i32 {\n+    fn c(&self) -> i32 {\n+        300\n+    }\n+}\n+\n+fn main() {\n+    let baz: &dyn Baz = &1;\n+    let _: &dyn std::fmt::Debug = baz;\n+    //~^ ERROR mismatched types [E0308]\n+    let _: &dyn Send = baz;\n+    //~^ ERROR mismatched types [E0308]\n+    let _: &dyn Sync = baz;\n+    //~^ ERROR mismatched types [E0308]\n+\n+    let bar: &dyn Bar = baz;\n+    //~^ ERROR mismatched types [E0308]\n+    let _: &dyn std::fmt::Debug = bar;\n+    //~^ ERROR mismatched types [E0308]\n+    let _: &dyn Send = bar;\n+    //~^ ERROR mismatched types [E0308]\n+    let _: &dyn Sync = bar;\n+    //~^ ERROR mismatched types [E0308]\n+\n+    let foo: &dyn Foo = baz;\n+    //~^ ERROR mismatched types [E0308]\n+    let _: &dyn std::fmt::Debug = foo;\n+    //~^ ERROR mismatched types [E0308]\n+    let _: &dyn Send = foo;\n+    //~^ ERROR mismatched types [E0308]\n+    let _: &dyn Sync = foo;\n+    //~^ ERROR mismatched types [E0308]\n+\n+    let foo: &dyn Foo = bar;\n+    //~^ ERROR mismatched types [E0308]\n+    let _: &dyn std::fmt::Debug = foo;\n+    //~^ ERROR mismatched types [E0308]\n+    let _: &dyn Send = foo;\n+    //~^ ERROR mismatched types [E0308]\n+    let _: &dyn Sync = foo;\n+    //~^ ERROR mismatched types [E0308]\n+}"}, {"sha": "b4530ed0c3a94fcbff4f622dd4c48689fc874d6f", "filename": "src/test/ui/traits/trait-upcasting/invalid-upcast.stderr", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Finvalid-upcast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Finvalid-upcast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Finvalid-upcast.stderr?ref=c6bc102fea9f9274202d0bc55a0fef8a3bc92426", "patch": "@@ -0,0 +1,168 @@\n+error[E0308]: mismatched types\n+  --> $DIR/invalid-upcast.rs:54:35\n+   |\n+LL |     let _: &dyn std::fmt::Debug = baz;\n+   |            --------------------   ^^^ expected trait `Debug`, found trait `Baz`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected reference `&dyn Debug`\n+              found reference `&dyn Baz`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/invalid-upcast.rs:56:24\n+   |\n+LL |     let _: &dyn Send = baz;\n+   |            ---------   ^^^ expected trait `Send`, found trait `Baz`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected reference `&dyn Send`\n+              found reference `&dyn Baz`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/invalid-upcast.rs:58:24\n+   |\n+LL |     let _: &dyn Sync = baz;\n+   |            ---------   ^^^ expected trait `Sync`, found trait `Baz`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected reference `&dyn Sync`\n+              found reference `&dyn Baz`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/invalid-upcast.rs:61:25\n+   |\n+LL |     let bar: &dyn Bar = baz;\n+   |              --------   ^^^ expected trait `Bar`, found trait `Baz`\n+   |              |\n+   |              expected due to this\n+   |\n+   = note: expected reference `&dyn Bar`\n+              found reference `&dyn Baz`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/invalid-upcast.rs:63:35\n+   |\n+LL |     let _: &dyn std::fmt::Debug = bar;\n+   |            --------------------   ^^^ expected trait `Debug`, found trait `Bar`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected reference `&dyn Debug`\n+              found reference `&dyn Bar`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/invalid-upcast.rs:65:24\n+   |\n+LL |     let _: &dyn Send = bar;\n+   |            ---------   ^^^ expected trait `Send`, found trait `Bar`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected reference `&dyn Send`\n+              found reference `&dyn Bar`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/invalid-upcast.rs:67:24\n+   |\n+LL |     let _: &dyn Sync = bar;\n+   |            ---------   ^^^ expected trait `Sync`, found trait `Bar`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected reference `&dyn Sync`\n+              found reference `&dyn Bar`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/invalid-upcast.rs:70:25\n+   |\n+LL |     let foo: &dyn Foo = baz;\n+   |              --------   ^^^ expected trait `Foo`, found trait `Baz`\n+   |              |\n+   |              expected due to this\n+   |\n+   = note: expected reference `&dyn Foo`\n+              found reference `&dyn Baz`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/invalid-upcast.rs:72:35\n+   |\n+LL |     let _: &dyn std::fmt::Debug = foo;\n+   |            --------------------   ^^^ expected trait `Debug`, found trait `Foo`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected reference `&dyn Debug`\n+              found reference `&dyn Foo`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/invalid-upcast.rs:74:24\n+   |\n+LL |     let _: &dyn Send = foo;\n+   |            ---------   ^^^ expected trait `Send`, found trait `Foo`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected reference `&dyn Send`\n+              found reference `&dyn Foo`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/invalid-upcast.rs:76:24\n+   |\n+LL |     let _: &dyn Sync = foo;\n+   |            ---------   ^^^ expected trait `Sync`, found trait `Foo`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected reference `&dyn Sync`\n+              found reference `&dyn Foo`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/invalid-upcast.rs:79:25\n+   |\n+LL |     let foo: &dyn Foo = bar;\n+   |              --------   ^^^ expected trait `Foo`, found trait `Bar`\n+   |              |\n+   |              expected due to this\n+   |\n+   = note: expected reference `&dyn Foo`\n+              found reference `&dyn Bar`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/invalid-upcast.rs:81:35\n+   |\n+LL |     let _: &dyn std::fmt::Debug = foo;\n+   |            --------------------   ^^^ expected trait `Debug`, found trait `Foo`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected reference `&dyn Debug`\n+              found reference `&dyn Foo`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/invalid-upcast.rs:83:24\n+   |\n+LL |     let _: &dyn Send = foo;\n+   |            ---------   ^^^ expected trait `Send`, found trait `Foo`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected reference `&dyn Send`\n+              found reference `&dyn Foo`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/invalid-upcast.rs:85:24\n+   |\n+LL |     let _: &dyn Sync = foo;\n+   |            ---------   ^^^ expected trait `Sync`, found trait `Foo`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected reference `&dyn Sync`\n+              found reference `&dyn Foo`\n+\n+error: aborting due to 15 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "052f090102e9638755f2320db56befa5308bf990", "filename": "src/test/ui/traits/trait-upcasting/lifetime.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Flifetime.rs?ref=c6bc102fea9f9274202d0bc55a0fef8a3bc92426", "patch": "@@ -0,0 +1,96 @@\n+// run-pass\n+// ignore-compare-mode-nll\n+\n+#![feature(trait_upcasting)]\n+#![allow(incomplete_features)]\n+\n+trait Foo: PartialEq<i32> + std::fmt::Debug + Send + Sync {\n+    fn a(&self) -> i32 {\n+        10\n+    }\n+\n+    fn z(&self) -> i32 {\n+        11\n+    }\n+\n+    fn y(&self) -> i32 {\n+        12\n+    }\n+}\n+\n+trait Bar: Foo {\n+    fn b(&self) -> i32 {\n+        20\n+    }\n+\n+    fn w(&self) -> i32 {\n+        21\n+    }\n+}\n+\n+trait Baz: Bar {\n+    fn c(&self) -> i32 {\n+        30\n+    }\n+}\n+\n+impl Foo for i32 {\n+    fn a(&self) -> i32 {\n+        100\n+    }\n+}\n+\n+impl Bar for i32 {\n+    fn b(&self) -> i32 {\n+        200\n+    }\n+}\n+\n+impl Baz for i32 {\n+    fn c(&self) -> i32 {\n+        300\n+    }\n+}\n+\n+// Note: upcast lifetime means a shorter lifetime.\n+fn upcast_baz<'a: 'b, 'b, T>(v: Box<dyn Baz + 'a>, _l: &'b T) -> Box<dyn Baz + 'b> {\n+    v\n+}\n+fn upcast_bar<'a: 'b, 'b, T>(v: Box<dyn Bar + 'a>, _l: &'b T) -> Box<dyn Bar + 'b> {\n+    v\n+}\n+fn upcast_foo<'a: 'b, 'b, T>(v: Box<dyn Foo + 'a>, _l: &'b T) -> Box<dyn Foo + 'b> {\n+    v\n+}\n+\n+fn main() {\n+    let v = Box::new(1);\n+    let l = &(); // dummy lifetime (shorter than `baz`)\n+\n+    let baz: Box<dyn Baz> = v.clone();\n+    let u = upcast_baz(baz, &l);\n+    assert_eq!(*u, 1);\n+    assert_eq!(u.a(), 100);\n+    assert_eq!(u.b(), 200);\n+    assert_eq!(u.c(), 300);\n+\n+    let baz: Box<dyn Baz> = v.clone();\n+    let bar: Box<dyn Bar> = baz;\n+    let u = upcast_bar(bar, &l);\n+    assert_eq!(*u, 1);\n+    assert_eq!(u.a(), 100);\n+    assert_eq!(u.b(), 200);\n+\n+    let baz: Box<dyn Baz> = v.clone();\n+    let foo: Box<dyn Foo> = baz;\n+    let u = upcast_foo(foo, &l);\n+    assert_eq!(*u, 1);\n+    assert_eq!(u.a(), 100);\n+\n+    let baz: Box<dyn Baz> = v.clone();\n+    let bar: Box<dyn Bar> = baz;\n+    let foo: Box<dyn Foo> = bar;\n+    let u = upcast_foo(foo, &l);\n+    assert_eq!(*u, 1);\n+    assert_eq!(u.a(), 100);\n+}"}, {"sha": "1164e43611a1d20aefcfa69032ba626c96c4d2ec", "filename": "src/test/ui/traits/trait-upcasting/replace-vptr.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Freplace-vptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Freplace-vptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Freplace-vptr.rs?ref=c6bc102fea9f9274202d0bc55a0fef8a3bc92426", "patch": "@@ -0,0 +1,49 @@\n+// run-pass\n+\n+#![feature(trait_upcasting)]\n+#![allow(incomplete_features)]\n+\n+trait A {\n+    fn foo_a(&self);\n+}\n+\n+trait B {\n+    fn foo_b(&self);\n+}\n+\n+trait C: A + B {\n+    fn foo_c(&self);\n+}\n+\n+struct S(i32);\n+\n+impl A for S {\n+    fn foo_a(&self) {\n+        unreachable!();\n+    }\n+}\n+\n+impl B for S {\n+    fn foo_b(&self) {\n+        assert_eq!(42, self.0);\n+    }\n+}\n+\n+impl C for S {\n+    fn foo_c(&self) {\n+        unreachable!();\n+    }\n+}\n+\n+fn invoke_inner(b: &dyn B) {\n+    b.foo_b();\n+}\n+\n+fn invoke_outer(c: &dyn C) {\n+    invoke_inner(c);\n+}\n+\n+fn main() {\n+    let s = S(42);\n+    invoke_outer(&s);\n+}"}, {"sha": "0f3cb285bf4c3446939eab534d00307518fd591b", "filename": "src/test/ui/traits/trait-upcasting/struct.rs", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fstruct.rs?ref=c6bc102fea9f9274202d0bc55a0fef8a3bc92426", "patch": "@@ -0,0 +1,174 @@\n+// run-pass\n+\n+#![feature(trait_upcasting)]\n+#![allow(incomplete_features)]\n+\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+trait Foo: PartialEq<i32> + std::fmt::Debug + Send + Sync {\n+    fn a(&self) -> i32 {\n+        10\n+    }\n+\n+    fn z(&self) -> i32 {\n+        11\n+    }\n+\n+    fn y(&self) -> i32 {\n+        12\n+    }\n+}\n+\n+trait Bar: Foo {\n+    fn b(&self) -> i32 {\n+        20\n+    }\n+\n+    fn w(&self) -> i32 {\n+        21\n+    }\n+}\n+\n+trait Baz: Bar {\n+    fn c(&self) -> i32 {\n+        30\n+    }\n+}\n+\n+impl Foo for i32 {\n+    fn a(&self) -> i32 {\n+        100\n+    }\n+}\n+\n+impl Bar for i32 {\n+    fn b(&self) -> i32 {\n+        200\n+    }\n+}\n+\n+impl Baz for i32 {\n+    fn c(&self) -> i32 {\n+        300\n+    }\n+}\n+\n+fn test_box() {\n+    let v = Box::new(1);\n+\n+    let baz: Box<dyn Baz> = v.clone();\n+    assert_eq!(*baz, 1);\n+    assert_eq!(baz.a(), 100);\n+    assert_eq!(baz.b(), 200);\n+    assert_eq!(baz.c(), 300);\n+    assert_eq!(baz.z(), 11);\n+    assert_eq!(baz.y(), 12);\n+    assert_eq!(baz.w(), 21);\n+\n+    let baz: Box<dyn Baz> = v.clone();\n+    let bar: Box<dyn Bar> = baz;\n+    assert_eq!(*bar, 1);\n+    assert_eq!(bar.a(), 100);\n+    assert_eq!(bar.b(), 200);\n+    assert_eq!(bar.z(), 11);\n+    assert_eq!(bar.y(), 12);\n+    assert_eq!(bar.w(), 21);\n+\n+    let baz: Box<dyn Baz> = v.clone();\n+    let foo: Box<dyn Foo> = baz;\n+    assert_eq!(*foo, 1);\n+    assert_eq!(foo.a(), 100);\n+    assert_eq!(foo.z(), 11);\n+    assert_eq!(foo.y(), 12);\n+\n+    let baz: Box<dyn Baz> = v.clone();\n+    let bar: Box<dyn Bar> = baz;\n+    let foo: Box<dyn Foo> = bar;\n+    assert_eq!(*foo, 1);\n+    assert_eq!(foo.a(), 100);\n+    assert_eq!(foo.z(), 11);\n+    assert_eq!(foo.y(), 12);\n+}\n+\n+fn test_rc() {\n+    let v = Rc::new(1);\n+\n+    let baz: Rc<dyn Baz> = v.clone();\n+    assert_eq!(*baz, 1);\n+    assert_eq!(baz.a(), 100);\n+    assert_eq!(baz.b(), 200);\n+    assert_eq!(baz.c(), 300);\n+    assert_eq!(baz.z(), 11);\n+    assert_eq!(baz.y(), 12);\n+    assert_eq!(baz.w(), 21);\n+\n+    let baz: Rc<dyn Baz> = v.clone();\n+    let bar: Rc<dyn Bar> = baz;\n+    assert_eq!(*bar, 1);\n+    assert_eq!(bar.a(), 100);\n+    assert_eq!(bar.b(), 200);\n+    assert_eq!(bar.z(), 11);\n+    assert_eq!(bar.y(), 12);\n+    assert_eq!(bar.w(), 21);\n+\n+    let baz: Rc<dyn Baz> = v.clone();\n+    let foo: Rc<dyn Foo> = baz;\n+    assert_eq!(*foo, 1);\n+    assert_eq!(foo.a(), 100);\n+    assert_eq!(foo.z(), 11);\n+    assert_eq!(foo.y(), 12);\n+\n+    let baz: Rc<dyn Baz> = v.clone();\n+    let bar: Rc<dyn Bar> = baz;\n+    let foo: Rc<dyn Foo> = bar;\n+    assert_eq!(*foo, 1);\n+    assert_eq!(foo.a(), 100);\n+    assert_eq!(foo.z(), 11);\n+    assert_eq!(foo.y(), 12);\n+    assert_eq!(foo.z(), 11);\n+    assert_eq!(foo.y(), 12);\n+}\n+\n+fn test_arc() {\n+    let v = Arc::new(1);\n+\n+    let baz: Arc<dyn Baz> = v.clone();\n+    assert_eq!(*baz, 1);\n+    assert_eq!(baz.a(), 100);\n+    assert_eq!(baz.b(), 200);\n+    assert_eq!(baz.c(), 300);\n+    assert_eq!(baz.z(), 11);\n+    assert_eq!(baz.y(), 12);\n+    assert_eq!(baz.w(), 21);\n+\n+    let baz: Arc<dyn Baz> = v.clone();\n+    let bar: Arc<dyn Bar> = baz;\n+    assert_eq!(*bar, 1);\n+    assert_eq!(bar.a(), 100);\n+    assert_eq!(bar.b(), 200);\n+    assert_eq!(bar.z(), 11);\n+    assert_eq!(bar.y(), 12);\n+    assert_eq!(bar.w(), 21);\n+\n+    let baz: Arc<dyn Baz> = v.clone();\n+    let foo: Arc<dyn Foo> = baz;\n+    assert_eq!(*foo, 1);\n+    assert_eq!(foo.a(), 100);\n+    assert_eq!(foo.z(), 11);\n+    assert_eq!(foo.y(), 12);\n+\n+    let baz: Arc<dyn Baz> = v.clone();\n+    let bar: Arc<dyn Bar> = baz;\n+    let foo: Arc<dyn Foo> = bar;\n+    assert_eq!(*foo, 1);\n+    assert_eq!(foo.a(), 100);\n+    assert_eq!(foo.z(), 11);\n+    assert_eq!(foo.y(), 12);\n+}\n+\n+fn main() {\n+    test_box();\n+    test_rc();\n+    test_arc();\n+}"}, {"sha": "3508e15284bf2406da408f26d33ae2b76abcdc7c", "filename": "src/test/ui/traits/trait-upcasting/subtrait-method.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fsubtrait-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fsubtrait-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fsubtrait-method.rs?ref=c6bc102fea9f9274202d0bc55a0fef8a3bc92426", "patch": "@@ -0,0 +1,70 @@\n+#![feature(trait_upcasting)]\n+#![allow(incomplete_features)]\n+\n+trait Foo: PartialEq<i32> + std::fmt::Debug + Send + Sync {\n+    fn a(&self) -> i32 {\n+        10\n+    }\n+\n+    fn z(&self) -> i32 {\n+        11\n+    }\n+\n+    fn y(&self) -> i32 {\n+        12\n+    }\n+}\n+\n+trait Bar: Foo {\n+    fn b(&self) -> i32 {\n+        20\n+    }\n+\n+    fn w(&self) -> i32 {\n+        21\n+    }\n+}\n+\n+trait Baz: Bar {\n+    fn c(&self) -> i32 {\n+        30\n+    }\n+}\n+\n+impl Foo for i32 {\n+    fn a(&self) -> i32 {\n+        100\n+    }\n+}\n+\n+impl Bar for i32 {\n+    fn b(&self) -> i32 {\n+        200\n+    }\n+}\n+\n+impl Baz for i32 {\n+    fn c(&self) -> i32 {\n+        300\n+    }\n+}\n+\n+fn main() {\n+    let baz: &dyn Baz = &1;\n+\n+    let bar: &dyn Bar = baz;\n+    bar.c();\n+    //~^ ERROR no method named `c` found for reference `&dyn Bar` in the current scope [E0599]\n+\n+    let foo: &dyn Foo = baz;\n+    foo.b();\n+    //~^ ERROR no method named `b` found for reference `&dyn Foo` in the current scope [E0599]\n+    foo.c();\n+    //~^ ERROR no method named `c` found for reference `&dyn Foo` in the current scope [E0599]\n+\n+    let foo: &dyn Foo = bar;\n+    foo.b();\n+    //~^ ERROR no method named `b` found for reference `&dyn Foo` in the current scope [E0599]\n+    foo.c();\n+    //~^ ERROR no method named `c` found for reference `&dyn Foo` in the current scope [E0599]\n+}"}, {"sha": "8c69011800b47bc0edd45a90b494860f57ddb0ba", "filename": "src/test/ui/traits/trait-upcasting/subtrait-method.stderr", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fsubtrait-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6bc102fea9f9274202d0bc55a0fef8a3bc92426/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fsubtrait-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fsubtrait-method.stderr?ref=c6bc102fea9f9274202d0bc55a0fef8a3bc92426", "patch": "@@ -0,0 +1,68 @@\n+error[E0599]: no method named `c` found for reference `&dyn Bar` in the current scope\n+  --> $DIR/subtrait-method.rs:56:9\n+   |\n+LL |     bar.c();\n+   |         ^ help: there is an associated function with a similar name: `a`\n+   |\n+   = help: items from traits can only be used if the trait is implemented and in scope\n+note: `Baz` defines an item `c`, perhaps you need to implement it\n+  --> $DIR/subtrait-method.rs:28:1\n+   |\n+LL | trait Baz: Bar {\n+   | ^^^^^^^^^^^^^^\n+\n+error[E0599]: no method named `b` found for reference `&dyn Foo` in the current scope\n+  --> $DIR/subtrait-method.rs:60:9\n+   |\n+LL |     foo.b();\n+   |         ^ help: there is an associated function with a similar name: `a`\n+   |\n+   = help: items from traits can only be used if the trait is implemented and in scope\n+note: `Bar` defines an item `b`, perhaps you need to implement it\n+  --> $DIR/subtrait-method.rs:18:1\n+   |\n+LL | trait Bar: Foo {\n+   | ^^^^^^^^^^^^^^\n+\n+error[E0599]: no method named `c` found for reference `&dyn Foo` in the current scope\n+  --> $DIR/subtrait-method.rs:62:9\n+   |\n+LL |     foo.c();\n+   |         ^ help: there is an associated function with a similar name: `a`\n+   |\n+   = help: items from traits can only be used if the trait is implemented and in scope\n+note: `Baz` defines an item `c`, perhaps you need to implement it\n+  --> $DIR/subtrait-method.rs:28:1\n+   |\n+LL | trait Baz: Bar {\n+   | ^^^^^^^^^^^^^^\n+\n+error[E0599]: no method named `b` found for reference `&dyn Foo` in the current scope\n+  --> $DIR/subtrait-method.rs:66:9\n+   |\n+LL |     foo.b();\n+   |         ^ help: there is an associated function with a similar name: `a`\n+   |\n+   = help: items from traits can only be used if the trait is implemented and in scope\n+note: `Bar` defines an item `b`, perhaps you need to implement it\n+  --> $DIR/subtrait-method.rs:18:1\n+   |\n+LL | trait Bar: Foo {\n+   | ^^^^^^^^^^^^^^\n+\n+error[E0599]: no method named `c` found for reference `&dyn Foo` in the current scope\n+  --> $DIR/subtrait-method.rs:68:9\n+   |\n+LL |     foo.c();\n+   |         ^ help: there is an associated function with a similar name: `a`\n+   |\n+   = help: items from traits can only be used if the trait is implemented and in scope\n+note: `Baz` defines an item `c`, perhaps you need to implement it\n+  --> $DIR/subtrait-method.rs:28:1\n+   |\n+LL | trait Baz: Bar {\n+   | ^^^^^^^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0599`."}]}