{"sha": "ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmM2VjNWVjZTViZGY4OTUwODEwMjI1YTlhM2JjM2NkMTkyNmUzZDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-13T11:35:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-13T11:35:59Z"}, "message": "Auto merge of #41965 - Mark-Simulacrum:rollup, r=Mark-Simulacrum\n\nRollup of 15 pull requests\n\n- Successful merges: #41820, #41860, #41876, #41896, #41912, #41916, #41918, #41921, #41923, #41934, #41935, #41940, #41942, #41943, #41951\n- Failed merges:", "tree": {"sha": "8948bc7cc6fbf6605069fa8e8d9774bc6eac8ab9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8948bc7cc6fbf6605069fa8e8d9774bc6eac8ab9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "html_url": "https://github.com/rust-lang/rust/commit/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "453cad6e658e095c6beacf12c589609dac3f4e52", "url": "https://api.github.com/repos/rust-lang/rust/commits/453cad6e658e095c6beacf12c589609dac3f4e52", "html_url": "https://github.com/rust-lang/rust/commit/453cad6e658e095c6beacf12c589609dac3f4e52"}, {"sha": "f28e3cdf54b935d6284bd554e17dc8e44f7b4deb", "url": "https://api.github.com/repos/rust-lang/rust/commits/f28e3cdf54b935d6284bd554e17dc8e44f7b4deb", "html_url": "https://github.com/rust-lang/rust/commit/f28e3cdf54b935d6284bd554e17dc8e44f7b4deb"}], "stats": {"total": 859, "additions": 475, "deletions": 384}, "files": [{"sha": "9c536111811aab1d41a261c3130e4dc862ddad9c", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -264,7 +264,7 @@ impl Config {\n             let table = match p.parse() {\n                 Some(table) => table,\n                 None => {\n-                    println!(\"failed to parse TOML configuration:\");\n+                    println!(\"failed to parse TOML configuration '{}':\", file.to_str().unwrap());\n                     for err in p.errors.iter() {\n                         let (loline, locol) = p.to_linecol(err.lo);\n                         let (hiline, hicol) = p.to_linecol(err.hi);"}, {"sha": "25da976a555e900653a45eee70d4751c7353edc8", "filename": "src/bootstrap/config.toml.example", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Fbootstrap%2Fconfig.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Fbootstrap%2Fconfig.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.toml.example?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -175,6 +175,9 @@\n [rust]\n \n # Whether or not to optimize the compiler and standard library\n+# Note: the slowness of the non optimized compiler compiling itself usually\n+#       outweighs the time gains in not doing optimizations, therefore a\n+#       full bootstrap takes much more time with optimize set to false.\n #optimize = true\n \n # Number of codegen units to use for each compiler invocation. A value of 0"}, {"sha": "67edd70a1565ab6fdb2872260f800d30e5621d53", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -309,11 +309,15 @@ pub fn openssl(build: &Build, target: &str) {\n     configure.arg(\"no-ssl3\");\n \n     let os = match target {\n+        \"aarch64-linux-android\" => \"linux-aarch64\",\n         \"aarch64-unknown-linux-gnu\" => \"linux-aarch64\",\n+        \"arm-linux-androideabi\" => \"android\",\n         \"arm-unknown-linux-gnueabi\" => \"linux-armv4\",\n         \"arm-unknown-linux-gnueabihf\" => \"linux-armv4\",\n+        \"armv7-linux-androideabi\" => \"android-armv7\",\n         \"armv7-unknown-linux-gnueabihf\" => \"linux-armv4\",\n         \"i686-apple-darwin\" => \"darwin-i386-cc\",\n+        \"i686-linux-android\" => \"android-x86\",\n         \"i686-unknown-freebsd\" => \"BSD-x86-elf\",\n         \"i686-unknown-linux-gnu\" => \"linux-elf\",\n         \"i686-unknown-linux-musl\" => \"linux-elf\",\n@@ -326,6 +330,7 @@ pub fn openssl(build: &Build, target: &str) {\n         \"powerpc64le-unknown-linux-gnu\" => \"linux-ppc64le\",\n         \"s390x-unknown-linux-gnu\" => \"linux64-s390x\",\n         \"x86_64-apple-darwin\" => \"darwin64-x86_64-cc\",\n+        \"x86_64-linux-android\" => \"linux-x86_64\",\n         \"x86_64-unknown-freebsd\" => \"BSD-x86_64\",\n         \"x86_64-unknown-linux-gnu\" => \"linux-x86_64\",\n         \"x86_64-unknown-linux-musl\" => \"linux-x86_64\",\n@@ -337,6 +342,18 @@ pub fn openssl(build: &Build, target: &str) {\n     for flag in build.cflags(target) {\n         configure.arg(flag);\n     }\n+    // There is no specific os target for android aarch64 or x86_64,\n+    // so we need to pass some extra cflags\n+    if target == \"aarch64-linux-android\" || target == \"x86_64-linux-android\" {\n+        configure.arg(\"-mandroid\");\n+        configure.arg(\"-fomit-frame-pointer\");\n+    }\n+    // Make PIE binaries\n+    // Non-PIE linker support was removed in Lollipop\n+    // https://source.android.com/security/enhancements/enhancements50\n+    if target == \"i686-linux-android\" {\n+        configure.arg(\"no-asm\");\n+    }\n     configure.current_dir(&obj);\n     println!(\"Configuring openssl for {}\", target);\n     build.run_quiet(&mut configure);"}, {"sha": "5f4578bbeb36845ac862249368c73e4420e44063", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -176,18 +176,6 @@ impl<'a> Iterator for EncodeUtf16<'a> {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a> FusedIterator for EncodeUtf16<'a> {}\n \n-// Return the initial codepoint accumulator for the first byte.\n-// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n-// for width 3, and 3 bits for width 4\n-macro_rules! utf8_first_byte {\n-    ($byte:expr, $width:expr) => (($byte & (0x7F >> $width)) as u32)\n-}\n-\n-// return the value of $ch updated with continuation byte $byte\n-macro_rules! utf8_acc_cont_byte {\n-    ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63) as u32)\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Borrow<str> for String {\n     #[inline]"}, {"sha": "67b97afb9769a33e9379ed9cf6255a0875bba515", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -119,7 +119,7 @@ pub trait Iterator {\n     /// // exactly wouldn't be possible without executing filter().\n     /// assert_eq!((0, Some(10)), iter.size_hint());\n     ///\n-    /// // Let's add one five more numbers with chain()\n+    /// // Let's add five more numbers with chain()\n     /// let iter = (0..10).filter(|x| x % 2 == 0).chain(15..20);\n     ///\n     /// // now both bounds are increased by five"}, {"sha": "b6ab1ecaf4e65643a88f325fadd305fe2428f0b1", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -104,10 +104,6 @@ mod macros;\n #[macro_use]\n mod internal_macros;\n \n-#[path = \"num/float_macros.rs\"]\n-#[macro_use]\n-mod float_macros;\n-\n #[path = \"num/int_macros.rs\"]\n #[macro_use]\n mod int_macros;"}, {"sha": "8b4002fe9af244e585adc451e65c8ffdbae26406", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -96,13 +96,6 @@ pub mod dec2flt;\n pub mod bignum;\n pub mod diy_float;\n \n-macro_rules! checked_op {\n-    ($U:ty, $op:path, $x:expr, $y:expr) => {{\n-        let (result, overflowed) = unsafe { $op($x as $U, $y as $U) };\n-        if overflowed { None } else { Some(result as Self) }\n-    }}\n-}\n-\n // `Int` + `SignedInt` implemented for signed integers\n macro_rules! int_impl {\n     ($SelfT:ty, $ActualT:ident, $UnsignedT:ty, $BITS:expr,"}, {"sha": "89960b0e4f678fdd32e3252ad4adeda67b4ab6e7", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -67,8 +67,8 @@ pub enum BoundRegion {\n     /// Fresh bound identifiers created during GLB computations.\n     BrFresh(u32),\n \n-    // Anonymous region for the implicit env pointer parameter\n-    // to a closure\n+    /// Anonymous region for the implicit env pointer parameter\n+    /// to a closure\n     BrEnv,\n }\n \n@@ -95,8 +95,8 @@ pub struct Issue32330 {\n     pub region_name: ast::Name,\n }\n \n-// NB: If you change this, you'll probably want to change the corresponding\n-// AST structure in libsyntax/ast.rs as well.\n+/// NB: If you change this, you'll probably want to change the corresponding\n+/// AST structure in libsyntax/ast.rs as well.\n #[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub enum TypeVariants<'tcx> {\n     /// The primitive boolean type. Written as `bool`.\n@@ -283,11 +283,11 @@ impl<'a, 'gcx, 'acx, 'tcx> ClosureSubsts<'tcx> {\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum ExistentialPredicate<'tcx> {\n-    // e.g. Iterator\n+    /// e.g. Iterator\n     Trait(ExistentialTraitRef<'tcx>),\n-    // e.g. Iterator::Item = T\n+    /// e.g. Iterator::Item = T\n     Projection(ExistentialProjection<'tcx>),\n-    // e.g. Send\n+    /// e.g. Send\n     AutoTrait(DefId),\n }\n \n@@ -683,8 +683,8 @@ impl<'a, 'gcx, 'tcx> ParamTy {\n /// [dbi]: http://en.wikipedia.org/wiki/De_Bruijn_index\n #[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub struct DebruijnIndex {\n-    // We maintain the invariant that this is never 0. So 1 indicates\n-    // the innermost binder. To ensure this, create with `DebruijnIndex::new`.\n+    /// We maintain the invariant that this is never 0. So 1 indicates\n+    /// the innermost binder. To ensure this, create with `DebruijnIndex::new`.\n     pub depth: u32,\n }\n \n@@ -908,7 +908,7 @@ impl DebruijnIndex {\n     }\n }\n \n-// Region utilities\n+/// Region utilities\n impl<'tcx> RegionKind<'tcx> {\n     pub fn is_bound(&self) -> bool {\n         match *self {\n@@ -972,7 +972,7 @@ impl<'tcx> RegionKind<'tcx> {\n     }\n }\n \n-// Type utilities\n+/// Type utilities\n impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     pub fn as_opt_param_ty(&self) -> Option<ty::ParamTy> {\n         match self.sty {\n@@ -995,8 +995,8 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    // Test whether this is a `()` which was produced by defaulting a\n-    // diverging type variable with feature(never_type) disabled.\n+    /// Test whether this is a `()` which was produced by defaulting a\n+    /// diverging type variable with feature(never_type) disabled.\n     pub fn is_defaulted_unit(&self) -> bool {\n         match self.sty {\n             TyTuple(_, true) => true,\n@@ -1171,18 +1171,17 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    /// panics if called on any type other than `Box<T>`\n     pub fn boxed_ty(&self) -> Ty<'tcx> {\n         match self.sty {\n             TyAdt(def, substs) if def.is_box() => substs.type_at(0),\n             _ => bug!(\"`boxed_ty` is called on non-box type {:?}\", self),\n         }\n     }\n \n-    /*\n-     A scalar type is one that denotes an atomic datum, with no sub-components.\n-     (A TyRawPtr is scalar because it represents a non-managed pointer, so its\n-     contents are abstract to rustc.)\n-    */\n+    /// A scalar type is one that denotes an atomic datum, with no sub-components.\n+    /// (A TyRawPtr is scalar because it represents a non-managed pointer, so its\n+    /// contents are abstract to rustc.)\n     pub fn is_scalar(&self) -> bool {\n         match self.sty {\n             TyBool | TyChar | TyInt(_) | TyFloat(_) | TyUint(_) |\n@@ -1278,10 +1277,10 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    // Returns the type and mutability of *ty.\n-    //\n-    // The parameter `explicit` indicates if this is an *explicit* dereference.\n-    // Some types---notably unsafe ptrs---can only be dereferenced explicitly.\n+    /// Returns the type and mutability of *ty.\n+    ///\n+    /// The parameter `explicit` indicates if this is an *explicit* dereference.\n+    /// Some types---notably unsafe ptrs---can only be dereferenced explicitly.\n     pub fn builtin_deref(&self, explicit: bool, pref: ty::LvaluePreference)\n         -> Option<TypeAndMut<'tcx>>\n     {\n@@ -1302,7 +1301,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    // Returns the type of ty[i]\n+    /// Returns the type of ty[i]\n     pub fn builtin_index(&self) -> Option<Ty<'tcx>> {\n         match self.sty {\n             TyArray(ty, _) | TySlice(ty) => Some(ty),\n@@ -1317,7 +1316,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    // Type accessors for substructures of types\n+    /// Type accessors for substructures of types\n     pub fn fn_args(&self) -> ty::Binder<&'tcx [Ty<'tcx>]> {\n         self.fn_sig().inputs()\n     }"}, {"sha": "861880aa265ec140a1072f8b25a12bc211c827e6", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use CodeSuggestion;\n+use Substitution;\n use Level;\n use RenderSpan;\n use std::fmt;\n@@ -23,7 +24,7 @@ pub struct Diagnostic {\n     pub code: Option<String>,\n     pub span: MultiSpan,\n     pub children: Vec<SubDiagnostic>,\n-    pub suggestion: Option<CodeSuggestion>,\n+    pub suggestions: Vec<CodeSuggestion>,\n }\n \n /// For example a note attached to an error.\n@@ -87,7 +88,7 @@ impl Diagnostic {\n             code: code,\n             span: MultiSpan::new(),\n             children: vec![],\n-            suggestion: None,\n+            suggestions: vec![],\n         }\n     }\n \n@@ -204,10 +205,22 @@ impl Diagnostic {\n     ///\n     /// See `diagnostic::CodeSuggestion` for more information.\n     pub fn span_suggestion(&mut self, sp: Span, msg: &str, suggestion: String) -> &mut Self {\n-        assert!(self.suggestion.is_none());\n-        self.suggestion = Some(CodeSuggestion {\n-            msp: sp.into(),\n-            substitutes: vec![suggestion],\n+        self.suggestions.push(CodeSuggestion {\n+            substitution_parts: vec![Substitution {\n+                span: sp,\n+                substitutions: vec![suggestion],\n+            }],\n+            msg: msg.to_owned(),\n+        });\n+        self\n+    }\n+\n+    pub fn span_suggestions(&mut self, sp: Span, msg: &str, suggestions: Vec<String>) -> &mut Self {\n+        self.suggestions.push(CodeSuggestion {\n+            substitution_parts: vec![Substitution {\n+                span: sp,\n+                substitutions: suggestions,\n+            }],\n             msg: msg.to_owned(),\n         });\n         self"}, {"sha": "fc5fd44f091f119d2be004159f2309cb5343150d", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -99,7 +99,10 @@ impl<'a> DiagnosticBuilder<'a> {\n \n         self.handler.emitter.borrow_mut().emit(&self);\n         self.cancel();\n-        self.handler.panic_if_treat_err_as_bug();\n+\n+        if self.level == Level::Error {\n+            self.handler.panic_if_treat_err_as_bug();\n+        }\n \n         // if self.is_fatal() {\n         //     panic!(FatalError);\n@@ -148,6 +151,11 @@ impl<'a> DiagnosticBuilder<'a> {\n                                     msg: &str,\n                                     suggestion: String)\n                                     -> &mut Self);\n+    forward!(pub fn span_suggestions(&mut self,\n+                                     sp: Span,\n+                                     msg: &str,\n+                                     suggestions: Vec<String>)\n+                                     -> &mut Self);\n     forward!(pub fn set_span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self);\n     forward!(pub fn code(&mut self, s: String) -> &mut Self);\n "}, {"sha": "03f1b94b169370826395976da0c4fa9cc2f5f787", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 54, "deletions": 50, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -35,23 +35,32 @@ impl Emitter for EmitterWriter {\n         let mut primary_span = db.span.clone();\n         let mut children = db.children.clone();\n \n-        if let Some(sugg) = db.suggestion.clone() {\n-            assert_eq!(sugg.msp.primary_spans().len(), sugg.substitutes.len());\n-            // don't display multispans as labels\n-            if sugg.substitutes.len() == 1 &&\n+        if let Some((sugg, rest)) = db.suggestions.split_first() {\n+            if rest.is_empty() &&\n+               // don't display multipart suggestions as labels\n+               sugg.substitution_parts.len() == 1 &&\n+               // don't display multi-suggestions as labels\n+               sugg.substitutions() == 1 &&\n                // don't display long messages as labels\n                sugg.msg.split_whitespace().count() < 10 &&\n                // don't display multiline suggestions as labels\n-               sugg.substitutes[0].find('\\n').is_none() {\n-                let msg = format!(\"help: {} `{}`\", sugg.msg, sugg.substitutes[0]);\n-                primary_span.push_span_label(sugg.msp.primary_spans()[0], msg);\n+               sugg.substitution_parts[0].substitutions[0].find('\\n').is_none() {\n+                let substitution = &sugg.substitution_parts[0].substitutions[0];\n+                let msg = format!(\"help: {} `{}`\", sugg.msg, substitution);\n+                primary_span.push_span_label(sugg.substitution_spans().next().unwrap(), msg);\n             } else {\n-                children.push(SubDiagnostic {\n-                    level: Level::Help,\n-                    message: Vec::new(),\n-                    span: MultiSpan::new(),\n-                    render_span: Some(Suggestion(sugg)),\n-                });\n+                // if there are multiple suggestions, print them all in full\n+                // to be consistent. We could try to figure out if we can\n+                // make one (or the first one) inline, but that would give\n+                // undue importance to a semi-random suggestion\n+                for sugg in &db.suggestions {\n+                    children.push(SubDiagnostic {\n+                        level: Level::Help,\n+                        message: Vec::new(),\n+                        span: MultiSpan::new(),\n+                        render_span: Some(Suggestion(sugg.clone())),\n+                    });\n+                }\n             }\n         }\n \n@@ -66,6 +75,10 @@ impl Emitter for EmitterWriter {\n \n /// maximum number of lines we will print for each error; arbitrary.\n pub const MAX_HIGHLIGHT_LINES: usize = 6;\n+/// maximum number of suggestions to be shown\n+///\n+/// Arbitrary, but taken from trait import suggestion limit\n+pub const MAX_SUGGESTIONS: usize = 4;\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n pub enum ColorConfig {\n@@ -95,21 +108,6 @@ struct FileWithAnnotatedLines {\n     multiline_depth: usize,\n }\n \n-\n-/// Do not use this for messages that end in `\\n` \u2013 use `println_maybe_styled` instead. See\n-/// `EmitterWriter::print_maybe_styled` for details.\n-macro_rules! print_maybe_styled {\n-    ($dst: expr, $style: expr, $($arg: tt)*) => {\n-        $dst.print_maybe_styled(format_args!($($arg)*), $style, false)\n-    }\n-}\n-\n-macro_rules! println_maybe_styled {\n-    ($dst: expr, $style: expr, $($arg: tt)*) => {\n-        $dst.print_maybe_styled(format_args!($($arg)*), $style, true)\n-    }\n-}\n-\n impl EmitterWriter {\n     pub fn stderr(color_config: ColorConfig, code_map: Option<Rc<CodeMapper>>) -> EmitterWriter {\n         if color_config.use_color() {\n@@ -1054,38 +1052,44 @@ impl EmitterWriter {\n                                -> io::Result<()> {\n         use std::borrow::Borrow;\n \n-        let primary_span = suggestion.msp.primary_span().unwrap();\n+        let primary_span = suggestion.substitution_spans().next().unwrap();\n         if let Some(ref cm) = self.cm {\n             let mut buffer = StyledBuffer::new();\n \n-            buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n-            buffer.append(0, \": \", Style::HeaderMsg);\n-            self.msg_to_buffer(&mut buffer,\n-                               &[(suggestion.msg.to_owned(), Style::NoStyle)],\n-                               max_line_num_len,\n-                               \"suggestion\",\n-                               Some(Style::HeaderMsg));\n-\n             let lines = cm.span_to_lines(primary_span).unwrap();\n \n             assert!(!lines.lines.is_empty());\n \n-            let complete = suggestion.splice_lines(cm.borrow());\n+            buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n+            buffer.append(0, \": \", Style::HeaderMsg);\n+            self.msg_to_buffer(&mut buffer,\n+                            &[(suggestion.msg.to_owned(), Style::NoStyle)],\n+                            max_line_num_len,\n+                            \"suggestion\",\n+                            Some(Style::HeaderMsg));\n \n-            // print the suggestion without any line numbers, but leave\n-            // space for them. This helps with lining up with previous\n-            // snippets from the actual error being reported.\n-            let mut lines = complete.lines();\n+            let suggestions = suggestion.splice_lines(cm.borrow());\n             let mut row_num = 1;\n-            for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n-                draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n-                buffer.append(row_num, line, Style::NoStyle);\n-                row_num += 1;\n-            }\n+            for complete in suggestions.iter().take(MAX_SUGGESTIONS) {\n+\n+                // print the suggestion without any line numbers, but leave\n+                // space for them. This helps with lining up with previous\n+                // snippets from the actual error being reported.\n+                let mut lines = complete.lines();\n+                for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n+                    draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n+                    buffer.append(row_num, line, Style::NoStyle);\n+                    row_num += 1;\n+                }\n \n-            // if we elided some lines, add an ellipsis\n-            if let Some(_) = lines.next() {\n-                buffer.append(row_num, \"...\", Style::NoStyle);\n+                // if we elided some lines, add an ellipsis\n+                if let Some(_) = lines.next() {\n+                    buffer.append(row_num, \"...\", Style::NoStyle);\n+                }\n+            }\n+            if suggestions.len() > MAX_SUGGESTIONS {\n+                let msg = format!(\"and {} other candidates\", suggestions.len() - MAX_SUGGESTIONS);\n+                buffer.append(row_num, &msg, Style::NoStyle);\n             }\n             emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n         }"}, {"sha": "7a561e3a9703f82623fa80f28de306a8e9a9882b", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 75, "deletions": 31, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -20,6 +20,7 @@\n #![allow(unused_attributes)]\n #![feature(range_contains)]\n #![feature(libc)]\n+#![feature(conservative_impl_trait)]\n \n #![cfg_attr(stage0, unstable(feature = \"rustc_private\", issue = \"27812\"))]\n #![cfg_attr(stage0, feature(rustc_private))]\n@@ -66,11 +67,35 @@ pub enum RenderSpan {\n \n #[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n pub struct CodeSuggestion {\n-    pub msp: MultiSpan,\n-    pub substitutes: Vec<String>,\n+    /// Each substitute can have multiple variants due to multiple\n+    /// applicable suggestions\n+    ///\n+    /// `foo.bar` might be replaced with `a.b` or `x.y` by replacing\n+    /// `foo` and `bar` on their own:\n+    ///\n+    /// ```\n+    /// vec![\n+    ///     (0..3, vec![\"a\", \"x\"]),\n+    ///     (4..7, vec![\"b\", \"y\"]),\n+    /// ]\n+    /// ```\n+    ///\n+    /// or by replacing the entire span:\n+    ///\n+    /// ```\n+    /// vec![(0..7, vec![\"a.b\", \"x.y\"])]\n+    /// ```\n+    pub substitution_parts: Vec<Substitution>,\n     pub msg: String,\n }\n \n+#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n+/// See the docs on `CodeSuggestion::substitutions`\n+pub struct Substitution {\n+    pub span: Span,\n+    pub substitutions: Vec<String>,\n+}\n+\n pub trait CodeMapper {\n     fn lookup_char_pos(&self, pos: BytePos) -> Loc;\n     fn span_to_lines(&self, sp: Span) -> FileLinesResult;\n@@ -80,8 +105,18 @@ pub trait CodeMapper {\n }\n \n impl CodeSuggestion {\n-    /// Returns the assembled code suggestion.\n-    pub fn splice_lines(&self, cm: &CodeMapper) -> String {\n+    /// Returns the number of substitutions\n+    fn substitutions(&self) -> usize {\n+        self.substitution_parts[0].substitutions.len()\n+    }\n+\n+    /// Returns the number of substitutions\n+    pub fn substitution_spans<'a>(&'a self) -> impl Iterator<Item = Span> + 'a {\n+        self.substitution_parts.iter().map(|sub| sub.span)\n+    }\n+\n+    /// Returns the assembled code suggestions.\n+    pub fn splice_lines(&self, cm: &CodeMapper) -> Vec<String> {\n         use syntax_pos::{CharPos, Loc, Pos};\n \n         fn push_trailing(buf: &mut String,\n@@ -103,20 +138,22 @@ impl CodeSuggestion {\n             }\n         }\n \n-        let mut primary_spans = self.msp.primary_spans().to_owned();\n-\n-        assert_eq!(primary_spans.len(), self.substitutes.len());\n-        if primary_spans.is_empty() {\n-            return format!(\"\");\n+        if self.substitution_parts.is_empty() {\n+            return vec![String::new()];\n         }\n \n+        let mut primary_spans: Vec<_> = self.substitution_parts\n+            .iter()\n+            .map(|sub| (sub.span, &sub.substitutions))\n+            .collect();\n+\n         // Assumption: all spans are in the same file, and all spans\n         // are disjoint. Sort in ascending order.\n-        primary_spans.sort_by_key(|sp| sp.lo);\n+        primary_spans.sort_by_key(|sp| sp.0.lo);\n \n         // Find the bounding span.\n-        let lo = primary_spans.iter().map(|sp| sp.lo).min().unwrap();\n-        let hi = primary_spans.iter().map(|sp| sp.hi).min().unwrap();\n+        let lo = primary_spans.iter().map(|sp| sp.0.lo).min().unwrap();\n+        let hi = primary_spans.iter().map(|sp| sp.0.hi).min().unwrap();\n         let bounding_span = Span {\n             lo: lo,\n             hi: hi,\n@@ -139,33 +176,40 @@ impl CodeSuggestion {\n         prev_hi.col = CharPos::from_usize(0);\n \n         let mut prev_line = fm.get_line(lines.lines[0].line_index);\n-        let mut buf = String::new();\n+        let mut bufs = vec![String::new(); self.substitutions()];\n \n-        for (sp, substitute) in primary_spans.iter().zip(self.substitutes.iter()) {\n+        for (sp, substitutes) in primary_spans {\n             let cur_lo = cm.lookup_char_pos(sp.lo);\n-            if prev_hi.line == cur_lo.line {\n-                push_trailing(&mut buf, prev_line, &prev_hi, Some(&cur_lo));\n-            } else {\n-                push_trailing(&mut buf, prev_line, &prev_hi, None);\n-                // push lines between the previous and current span (if any)\n-                for idx in prev_hi.line..(cur_lo.line - 1) {\n-                    if let Some(line) = fm.get_line(idx) {\n-                        buf.push_str(line);\n-                        buf.push('\\n');\n+            for (buf, substitute) in bufs.iter_mut().zip(substitutes) {\n+                if prev_hi.line == cur_lo.line {\n+                    push_trailing(buf, prev_line, &prev_hi, Some(&cur_lo));\n+                } else {\n+                    push_trailing(buf, prev_line, &prev_hi, None);\n+                    // push lines between the previous and current span (if any)\n+                    for idx in prev_hi.line..(cur_lo.line - 1) {\n+                        if let Some(line) = fm.get_line(idx) {\n+                            buf.push_str(line);\n+                            buf.push('\\n');\n+                        }\n+                    }\n+                    if let Some(cur_line) = fm.get_line(cur_lo.line - 1) {\n+                        buf.push_str(&cur_line[..cur_lo.col.to_usize()]);\n                     }\n                 }\n-                if let Some(cur_line) = fm.get_line(cur_lo.line - 1) {\n-                    buf.push_str(&cur_line[..cur_lo.col.to_usize()]);\n-                }\n+                buf.push_str(substitute);\n             }\n-            buf.push_str(substitute);\n             prev_hi = cm.lookup_char_pos(sp.hi);\n             prev_line = fm.get_line(prev_hi.line - 1);\n         }\n-        push_trailing(&mut buf, prev_line, &prev_hi, None);\n-        // remove trailing newline\n-        buf.pop();\n-        buf\n+        for buf in &mut bufs {\n+            // if the replacement already ends with a newline, don't print the next line\n+            if !buf.ends_with('\\n') {\n+                push_trailing(buf, prev_line, &prev_hi, None);\n+            }\n+            // remove trailing newline\n+            buf.pop();\n+        }\n+        bufs\n     }\n }\n "}, {"sha": "57639a1ecef7b17b359436a928f5a815602e22c7", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -150,7 +150,7 @@ impl<'a> Resolver<'a> {\n                                           view_path.span,\n                                           ResolutionError::SelfImportsOnlyAllowedWithin);\n                         } else if source_name == \"$crate\" && full_path.segments.len() == 1 {\n-                            let crate_root = self.resolve_crate_var(source.ctxt);\n+                            let crate_root = self.resolve_crate_var(source.ctxt, item.span);\n                             let crate_name = match crate_root.kind {\n                                 ModuleKind::Def(_, name) => name,\n                                 ModuleKind::Block(..) => unreachable!(),\n@@ -247,7 +247,7 @@ impl<'a> Resolver<'a> {\n \n                 // n.b. we don't need to look at the path option here, because cstore already did\n                 let crate_id = self.session.cstore.extern_mod_stmt_cnum(item.id).unwrap();\n-                let module = self.get_extern_crate_root(crate_id);\n+                let module = self.get_extern_crate_root(crate_id, item.span);\n                 self.populate_module_if_necessary(module);\n                 let used = self.process_legacy_macro_imports(item, module, expansion);\n                 let binding =\n@@ -279,7 +279,7 @@ impl<'a> Resolver<'a> {\n                     no_implicit_prelude: parent.no_implicit_prelude || {\n                         attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n                     },\n-                    ..ModuleData::new(Some(parent), module_kind, def_id)\n+                    ..ModuleData::new(Some(parent), module_kind, def_id, item.span)\n                 });\n                 self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n                 self.module_map.insert(def_id, module);\n@@ -314,7 +314,10 @@ impl<'a> Resolver<'a> {\n             ItemKind::Enum(ref enum_definition, _) => {\n                 let def = Def::Enum(self.definitions.local_def_id(item.id));\n                 let module_kind = ModuleKind::Def(def, ident.name);\n-                let module = self.new_module(parent, module_kind, parent.normal_ancestor_id);\n+                let module = self.new_module(parent,\n+                                             module_kind,\n+                                             parent.normal_ancestor_id,\n+                                             item.span);\n                 self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n \n                 for variant in &(*enum_definition).variants {\n@@ -370,7 +373,10 @@ impl<'a> Resolver<'a> {\n \n                 // Add all the items within to a new module.\n                 let module_kind = ModuleKind::Def(Def::Trait(def_id), ident.name);\n-                let module = self.new_module(parent, module_kind, parent.normal_ancestor_id);\n+                let module = self.new_module(parent,\n+                                             module_kind,\n+                                             parent.normal_ancestor_id,\n+                                             item.span);\n                 self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n                 self.current_module = module;\n             }\n@@ -418,8 +424,10 @@ impl<'a> Resolver<'a> {\n     fn build_reduced_graph_for_block(&mut self, block: &Block) {\n         let parent = self.current_module;\n         if self.block_needs_anonymous_module(block) {\n-            let module =\n-                self.new_module(parent, ModuleKind::Block(block.id), parent.normal_ancestor_id);\n+            let module = self.new_module(parent,\n+                                         ModuleKind::Block(block.id),\n+                                         parent.normal_ancestor_id,\n+                                         block.span);\n             self.block_map.insert(block.id, module);\n             self.current_module = module; // Descend into the block.\n         }\n@@ -431,10 +439,14 @@ impl<'a> Resolver<'a> {\n         let def = child.def;\n         let def_id = def.def_id();\n         let vis = self.session.cstore.visibility(def_id);\n+        let span = child.span;\n \n         match def {\n             Def::Mod(..) | Def::Enum(..) => {\n-                let module = self.new_module(parent, ModuleKind::Def(def, ident.name), def_id);\n+                let module = self.new_module(parent,\n+                                             ModuleKind::Def(def, ident.name),\n+                                             def_id,\n+                                             span);\n                 self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Variant(..) | Def::TyAlias(..) => {\n@@ -454,7 +466,10 @@ impl<'a> Resolver<'a> {\n             }\n             Def::Trait(..) => {\n                 let module_kind = ModuleKind::Def(def, ident.name);\n-                let module = self.new_module(parent, module_kind, parent.normal_ancestor_id);\n+                let module = self.new_module(parent,\n+                                             module_kind,\n+                                             parent.normal_ancestor_id,\n+                                             span);\n                 self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n \n                 for child in self.session.cstore.item_children(def_id) {\n@@ -483,18 +498,18 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn get_extern_crate_root(&mut self, cnum: CrateNum) -> Module<'a> {\n+    fn get_extern_crate_root(&mut self, cnum: CrateNum, span: Span) -> Module<'a> {\n         let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n         let name = self.session.cstore.crate_name(cnum);\n         let macros_only = self.session.cstore.dep_kind(cnum).macros_only();\n         let module_kind = ModuleKind::Def(Def::Mod(def_id), name);\n         let arenas = self.arenas;\n         *self.extern_crate_roots.entry((cnum, macros_only)).or_insert_with(|| {\n-            arenas.alloc_module(ModuleData::new(None, module_kind, def_id))\n+            arenas.alloc_module(ModuleData::new(None, module_kind, def_id, span))\n         })\n     }\n \n-    pub fn macro_def_scope(&mut self, expansion: Mark) -> Module<'a> {\n+    pub fn macro_def_scope(&mut self, expansion: Mark, span: Span) -> Module<'a> {\n         let def_id = self.macro_defs[&expansion];\n         if let Some(id) = self.definitions.as_local_node_id(def_id) {\n             self.local_macro_def_scopes[&id]\n@@ -503,7 +518,7 @@ impl<'a> Resolver<'a> {\n             self.graph_root\n         } else {\n             let module_def_id = ty::DefIdTree::parent(&*self, def_id).unwrap();\n-            self.get_extern_crate_root(module_def_id.krate)\n+            self.get_extern_crate_root(module_def_id.krate, span)\n         }\n     }\n \n@@ -593,7 +608,8 @@ impl<'a> Resolver<'a> {\n         } else {\n             for (name, span) in legacy_imports.imports {\n                 let ident = Ident::with_empty_ctxt(name);\n-                let result = self.resolve_ident_in_module(module, ident, MacroNS, false, None);\n+                let result = self.resolve_ident_in_module(module, ident, MacroNS,\n+                                                          false, false, span);\n                 if let Ok(binding) = result {\n                     let directive = macro_use_directive(span);\n                     self.potentially_unused_imports.push(directive);\n@@ -607,7 +623,7 @@ impl<'a> Resolver<'a> {\n         for (name, span) in legacy_imports.reexports {\n             self.session.cstore.export_macros(module.def_id().unwrap().krate);\n             let ident = Ident::with_empty_ctxt(name);\n-            let result = self.resolve_ident_in_module(module, ident, MacroNS, false, None);\n+            let result = self.resolve_ident_in_module(module, ident, MacroNS, false, false, span);\n             if let Ok(binding) = result {\n                 self.macro_exports.push(Export { name: name, def: binding.def(), span: span });\n             } else {"}, {"sha": "c4512cb38c4e24270b85ef4a5d8755801295bfbb", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 77, "deletions": 61, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -614,7 +614,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n             self.smart_resolve_path(ty.id, qself.as_ref(), path, PathSource::Type);\n         } else if let TyKind::ImplicitSelf = ty.node {\n             let self_ty = keywords::SelfType.ident();\n-            let def = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, Some(ty.span))\n+            let def = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, true, ty.span)\n                           .map_or(Def::Err, |d| d.def());\n             self.record_def(ty.id, PathResolution::new(def));\n         } else if let TyKind::Array(ref element, ref length) = ty.node {\n@@ -866,12 +866,18 @@ pub struct ModuleData<'a> {\n     // access the children must be preceded with a\n     // `populate_module_if_necessary` call.\n     populated: Cell<bool>,\n+\n+    /// Span of the module itself. Used for error reporting.\n+    span: Span,\n }\n \n pub type Module<'a> = &'a ModuleData<'a>;\n \n impl<'a> ModuleData<'a> {\n-    fn new(parent: Option<Module<'a>>, kind: ModuleKind, normal_ancestor_id: DefId) -> Self {\n+    fn new(parent: Option<Module<'a>>,\n+           kind: ModuleKind,\n+           normal_ancestor_id: DefId,\n+           span: Span) -> Self {\n         ModuleData {\n             parent: parent,\n             kind: kind,\n@@ -885,6 +891,7 @@ impl<'a> ModuleData<'a> {\n             globs: RefCell::new((Vec::new())),\n             traits: RefCell::new(None),\n             populated: Cell::new(normal_ancestor_id.is_local()),\n+            span: span,\n         }\n     }\n \n@@ -1261,11 +1268,11 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n         let namespace = if is_value { ValueNS } else { TypeNS };\n         let hir::Path { ref segments, span, ref mut def } = *path;\n         let path: Vec<_> = segments.iter().map(|seg| Ident::with_empty_ctxt(seg.name)).collect();\n-        match self.resolve_path(&path, Some(namespace), Some(span)) {\n+        match self.resolve_path(&path, Some(namespace), true, span) {\n             PathResult::Module(module) => *def = module.def().unwrap(),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n                 *def = path_res.base_def(),\n-            PathResult::NonModule(..) => match self.resolve_path(&path, None, Some(span)) {\n+            PathResult::NonModule(..) => match self.resolve_path(&path, None, true, span) {\n                 PathResult::Failed(msg, _) => {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 }\n@@ -1299,7 +1306,7 @@ impl<'a> Resolver<'a> {\n         let root_module_kind = ModuleKind::Def(Def::Mod(root_def_id), keywords::Invalid.name());\n         let graph_root = arenas.alloc_module(ModuleData {\n             no_implicit_prelude: attr::contains_name(&krate.attrs, \"no_implicit_prelude\"),\n-            ..ModuleData::new(None, root_module_kind, root_def_id)\n+            ..ModuleData::new(None, root_module_kind, root_def_id, krate.span)\n         });\n         let mut module_map = FxHashMap();\n         module_map.insert(DefId::local(CRATE_DEF_INDEX), graph_root);\n@@ -1431,9 +1438,14 @@ impl<'a> Resolver<'a> {\n         self.crate_loader.postprocess(krate);\n     }\n \n-    fn new_module(&self, parent: Module<'a>, kind: ModuleKind, normal_ancestor_id: DefId)\n-                  -> Module<'a> {\n-        self.arenas.alloc_module(ModuleData::new(Some(parent), kind, normal_ancestor_id))\n+    fn new_module(\n+        &self,\n+        parent: Module<'a>,\n+        kind: ModuleKind,\n+        normal_ancestor_id: DefId,\n+        span: Span,\n+    ) -> Module<'a> {\n+        self.arenas.alloc_module(ModuleData::new(Some(parent), kind, normal_ancestor_id, span))\n     }\n \n     fn record_use(&mut self, ident: Ident, ns: Namespace, binding: &'a NameBinding<'a>, span: Span)\n@@ -1491,7 +1503,8 @@ impl<'a> Resolver<'a> {\n     fn resolve_ident_in_lexical_scope(&mut self,\n                                       mut ident: Ident,\n                                       ns: Namespace,\n-                                      record_used: Option<Span>)\n+                                      record_used: bool,\n+                                      path_span: Span)\n                                       -> Option<LexicalScopeBinding<'a>> {\n         if ns == TypeNS {\n             ident = ident.unhygienize();\n@@ -1502,12 +1515,13 @@ impl<'a> Resolver<'a> {\n             if let Some(def) = self.ribs[ns][i].bindings.get(&ident).cloned() {\n                 // The ident resolves to a type parameter or local variable.\n                 return Some(LexicalScopeBinding::Def(\n-                    self.adjust_local_def(ns, i, def, record_used)\n+                    self.adjust_local_def(ns, i, def, record_used, path_span)\n                 ));\n             }\n \n             if let ModuleRibKind(module) = self.ribs[ns][i].kind {\n-                let item = self.resolve_ident_in_module(module, ident, ns, false, record_used);\n+                let item = self.resolve_ident_in_module(module, ident, ns, false,\n+                                                        record_used, path_span);\n                 if let Ok(binding) = item {\n                     // The ident resolves to an item.\n                     return Some(LexicalScopeBinding::Item(binding));\n@@ -1516,7 +1530,8 @@ impl<'a> Resolver<'a> {\n                 if let ModuleKind::Block(..) = module.kind { // We can see through blocks\n                 } else if !module.no_implicit_prelude {\n                     return self.prelude.and_then(|prelude| {\n-                        self.resolve_ident_in_module(prelude, ident, ns, false, None).ok()\n+                        self.resolve_ident_in_module(prelude, ident, ns, false,\n+                                                     false, path_span).ok()\n                     }).map(LexicalScopeBinding::Item)\n                 } else {\n                     return None;\n@@ -1536,12 +1551,12 @@ impl<'a> Resolver<'a> {\n         None\n     }\n \n-    fn resolve_crate_var(&mut self, crate_var_ctxt: SyntaxContext) -> Module<'a> {\n+    fn resolve_crate_var(&mut self, crate_var_ctxt: SyntaxContext, span: Span) -> Module<'a> {\n         let mut ctxt_data = crate_var_ctxt.data();\n         while ctxt_data.prev_ctxt != SyntaxContext::empty() {\n             ctxt_data = ctxt_data.prev_ctxt.data();\n         }\n-        let module = self.macro_def_scope(ctxt_data.outer_mark);\n+        let module = self.macro_def_scope(ctxt_data.outer_mark, span);\n         if module.is_local() { self.graph_root } else { module }\n     }\n \n@@ -2136,7 +2151,8 @@ impl<'a> Resolver<'a> {\n                 PatKind::Ident(bmode, ref ident, ref opt_pat) => {\n                     // First try to resolve the identifier as some existing\n                     // entity, then fall back to a fresh binding.\n-                    let binding = self.resolve_ident_in_lexical_scope(ident.node, ValueNS, None)\n+                    let binding = self.resolve_ident_in_lexical_scope(ident.node, ValueNS,\n+                                                                      false, pat.span)\n                                       .and_then(LexicalScopeBinding::item);\n                     let resolution = binding.map(NameBinding::def).and_then(|def| {\n                         let always_binding = !pat_src.is_refutable() || opt_pat.is_some() ||\n@@ -2242,7 +2258,7 @@ impl<'a> Resolver<'a> {\n                     (format!(\"\"), format!(\"the crate root\"))\n                 } else {\n                     let mod_path = &path[..path.len() - 1];\n-                    let mod_prefix = match this.resolve_path(mod_path, Some(TypeNS), None) {\n+                    let mod_prefix = match this.resolve_path(mod_path, Some(TypeNS), false, span) {\n                         PathResult::Module(module) => module.def(),\n                         _ => None,\n                     }.map_or(format!(\"\"), |def| format!(\"{} \", def.kind_name()));\n@@ -2272,8 +2288,10 @@ impl<'a> Resolver<'a> {\n             let name = path.last().unwrap().name;\n             let candidates = this.lookup_import_candidates(name, ns, is_expected);\n             if !candidates.is_empty() {\n+                let mut module_span = this.current_module.span;\n+                module_span.hi = module_span.lo;\n                 // Report import candidates as help and proceed searching for labels.\n-                show_candidates(&mut err, &candidates, def.is_some());\n+                show_candidates(&mut err, module_span, &candidates, def.is_some());\n             } else if is_expected(Def::Enum(DefId::local(CRATE_DEF_INDEX))) {\n                 let enum_candidates = this.lookup_import_candidates(name, ns, is_enum_variant);\n                 let mut enum_candidates = enum_candidates.iter()\n@@ -2290,9 +2308,9 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n             }\n-            if path.len() == 1 && this.self_type_is_available() {\n+            if path.len() == 1 && this.self_type_is_available(span) {\n                 if let Some(candidate) = this.lookup_assoc_candidate(name, ns, is_expected) {\n-                    let self_is_available = this.self_value_is_available(path[0].ctxt);\n+                    let self_is_available = this.self_value_is_available(path[0].ctxt, span);\n                     match candidate {\n                         AssocSuggestion::Field => {\n                             err.span_label(span, format!(\"did you mean `self.{}`?\", path_str));\n@@ -2316,7 +2334,7 @@ impl<'a> Resolver<'a> {\n             let mut levenshtein_worked = false;\n \n             // Try Levenshtein.\n-            if let Some(candidate) = this.lookup_typo_candidate(path, ns, is_expected) {\n+            if let Some(candidate) = this.lookup_typo_candidate(path, ns, is_expected, span) {\n                 err.span_label(ident_span, format!(\"did you mean `{}`?\", candidate));\n                 levenshtein_worked = true;\n             }\n@@ -2421,14 +2439,15 @@ impl<'a> Resolver<'a> {\n         resolution\n     }\n \n-    fn self_type_is_available(&mut self) -> bool {\n-        let binding = self.resolve_ident_in_lexical_scope(keywords::SelfType.ident(), TypeNS, None);\n+    fn self_type_is_available(&mut self, span: Span) -> bool {\n+        let binding = self.resolve_ident_in_lexical_scope(keywords::SelfType.ident(),\n+                                                          TypeNS, false, span);\n         if let Some(LexicalScopeBinding::Def(def)) = binding { def != Def::Err } else { false }\n     }\n \n-    fn self_value_is_available(&mut self, ctxt: SyntaxContext) -> bool {\n+    fn self_value_is_available(&mut self, ctxt: SyntaxContext, span: Span) -> bool {\n         let ident = Ident { name: keywords::SelfValue.name(), ctxt: ctxt };\n-        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, None);\n+        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, false, span);\n         if let Some(LexicalScopeBinding::Def(def)) = binding { def != Def::Err } else { false }\n     }\n \n@@ -2492,7 +2511,7 @@ impl<'a> Resolver<'a> {\n             ));\n         }\n \n-        let result = match self.resolve_path(&path, Some(ns), Some(span)) {\n+        let result = match self.resolve_path(&path, Some(ns), true, span) {\n             PathResult::NonModule(path_res) => path_res,\n             PathResult::Module(module) if !module.is_normal() => {\n                 PathResolution::new(module.def().unwrap())\n@@ -2538,7 +2557,7 @@ impl<'a> Resolver<'a> {\n         if path.len() > 1 && !global_by_default && result.base_def() != Def::Err &&\n            path[0].name != keywords::CrateRoot.name() && path[0].name != \"$crate\" {\n             let unqualified_result = {\n-                match self.resolve_path(&[*path.last().unwrap()], Some(ns), None) {\n+                match self.resolve_path(&[*path.last().unwrap()], Some(ns), false, span) {\n                     PathResult::NonModule(path_res) => path_res.base_def(),\n                     PathResult::Module(module) => module.def().unwrap(),\n                     _ => return Some(result),\n@@ -2556,7 +2575,8 @@ impl<'a> Resolver<'a> {\n     fn resolve_path(&mut self,\n                     path: &[Ident],\n                     opt_ns: Option<Namespace>, // `None` indicates a module path\n-                    record_used: Option<Span>)\n+                    record_used: bool,\n+                    path_span: Span)\n                     -> PathResult<'a> {\n         let mut module = None;\n         let mut allow_super = true;\n@@ -2585,25 +2605,25 @@ impl<'a> Resolver<'a> {\n                 module = Some(self.graph_root);\n                 continue\n             } else if i == 0 && ns == TypeNS && ident.name == \"$crate\" {\n-                module = Some(self.resolve_crate_var(ident.ctxt));\n+                module = Some(self.resolve_crate_var(ident.ctxt, path_span));\n                 continue\n             }\n \n             let binding = if let Some(module) = module {\n-                self.resolve_ident_in_module(module, ident, ns, false, record_used)\n+                self.resolve_ident_in_module(module, ident, ns, false, record_used, path_span)\n             } else if opt_ns == Some(MacroNS) {\n-                self.resolve_lexical_macro_path_segment(ident, ns, record_used)\n+                self.resolve_lexical_macro_path_segment(ident, ns, record_used, path_span)\n                     .map(MacroBinding::binding)\n             } else {\n-                match self.resolve_ident_in_lexical_scope(ident, ns, record_used) {\n+                match self.resolve_ident_in_lexical_scope(ident, ns, record_used, path_span) {\n                     Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n                     Some(LexicalScopeBinding::Def(def))\n                             if opt_ns == Some(TypeNS) || opt_ns == Some(ValueNS) => {\n                         return PathResult::NonModule(PathResolution::with_unresolved_segments(\n                             def, path.len() - 1\n                         ));\n                     }\n-                    _ => Err(if record_used.is_some() { Determined } else { Undetermined }),\n+                    _ => Err(if record_used { Determined } else { Undetermined }),\n                 }\n             };\n \n@@ -2660,12 +2680,13 @@ impl<'a> Resolver<'a> {\n                         ns: Namespace,\n                         rib_index: usize,\n                         mut def: Def,\n-                        record_used: Option<Span>) -> Def {\n+                        record_used: bool,\n+                        span: Span) -> Def {\n         let ribs = &self.ribs[ns][rib_index + 1..];\n \n         // An invalid forward use of a type parameter from a previous default.\n         if let ForwardTyParamBanRibKind = self.ribs[ns][rib_index].kind {\n-            if let Some(span) = record_used {\n+            if record_used {\n                 resolve_error(self, span,\n                         ResolutionError::ForwardDeclaredTyParam);\n             }\n@@ -2675,7 +2696,7 @@ impl<'a> Resolver<'a> {\n \n         match def {\n             Def::Upvar(..) => {\n-                span_bug!(record_used.unwrap_or(DUMMY_SP), \"unexpected {:?} in bindings\", def)\n+                span_bug!(span, \"unexpected {:?} in bindings\", def)\n             }\n             Def::Local(def_id) => {\n                 for rib in ribs {\n@@ -2701,7 +2722,7 @@ impl<'a> Resolver<'a> {\n                             let depth = vec.len();\n                             def = Def::Upvar(def_id, depth, function_id);\n \n-                            if let Some(span) = record_used {\n+                            if record_used {\n                                 vec.push(Freevar {\n                                     def: prev_def,\n                                     span: span,\n@@ -2713,15 +2734,15 @@ impl<'a> Resolver<'a> {\n                             // This was an attempt to access an upvar inside a\n                             // named function item. This is not allowed, so we\n                             // report an error.\n-                            if let Some(span) = record_used {\n+                            if record_used {\n                                 resolve_error(self, span,\n                                         ResolutionError::CannotCaptureDynamicEnvironmentInFnItem);\n                             }\n                             return Def::Err;\n                         }\n                         ConstantItemRibKind => {\n                             // Still doesn't deal with upvars\n-                            if let Some(span) = record_used {\n+                            if record_used {\n                                 resolve_error(self, span,\n                                         ResolutionError::AttemptToUseNonConstantValueInConstant);\n                             }\n@@ -2740,15 +2761,15 @@ impl<'a> Resolver<'a> {\n                         ItemRibKind => {\n                             // This was an attempt to use a type parameter outside\n                             // its scope.\n-                            if let Some(span) = record_used {\n+                            if record_used {\n                                 resolve_error(self, span,\n                                               ResolutionError::TypeParametersFromOuterFunction);\n                             }\n                             return Def::Err;\n                         }\n                         ConstantItemRibKind => {\n                             // see #9186\n-                            if let Some(span) = record_used {\n+                            if record_used {\n                                 resolve_error(self, span,\n                                               ResolutionError::OuterTypeParameterContext);\n                             }\n@@ -2844,7 +2865,8 @@ impl<'a> Resolver<'a> {\n     fn lookup_typo_candidate<FilterFn>(&mut self,\n                                        path: &[Ident],\n                                        ns: Namespace,\n-                                       filter_fn: FilterFn)\n+                                       filter_fn: FilterFn,\n+                                       span: Span)\n                                        -> Option<Symbol>\n         where FilterFn: Fn(Def) -> bool\n     {\n@@ -2896,7 +2918,8 @@ impl<'a> Resolver<'a> {\n         } else {\n             // Search in module.\n             let mod_path = &path[..path.len() - 1];\n-            if let PathResult::Module(module) = self.resolve_path(mod_path, Some(TypeNS), None) {\n+            if let PathResult::Module(module) = self.resolve_path(mod_path, Some(TypeNS),\n+                                                                  false, span) {\n                 add_module_candidates(module, &mut names);\n             }\n         }\n@@ -3397,7 +3420,10 @@ impl<'a> Resolver<'a> {\n                 continue\n             }\n             let ident = attr.path.segments[0].identifier;\n-            let result = self.resolve_lexical_macro_path_segment(ident, MacroNS, None);\n+            let result = self.resolve_lexical_macro_path_segment(ident,\n+                                                                 MacroNS,\n+                                                                 false,\n+                                                                 attr.path.span);\n             if let Ok(binding) = result {\n                 if let SyntaxExtension::AttrProcMacro(..) = *binding.binding().get_macro(self) {\n                     attr::mark_known(attr);\n@@ -3464,12 +3490,10 @@ fn import_candidate_to_paths(suggestion: &ImportSuggestion) -> (Span, String, St\n /// When an entity with a given name is not available in scope, we search for\n /// entities with that name in all crates. This method allows outputting the\n /// results of this search in a programmer-friendly way\n-fn show_candidates(session: &mut DiagnosticBuilder,\n+fn show_candidates(err: &mut DiagnosticBuilder,\n+                   span: Span,\n                    candidates: &[ImportSuggestion],\n                    better: bool) {\n-    // don't show more than MAX_CANDIDATES results, so\n-    // we're consistent with the trait suggestions\n-    const MAX_CANDIDATES: usize = 4;\n \n     // we want consistent results across executions, but candidates are produced\n     // by iterating through a hash map, so make sure they are ordered:\n@@ -3482,21 +3506,13 @@ fn show_candidates(session: &mut DiagnosticBuilder,\n         1 => \" is found in another module, you can import it\",\n         _ => \"s are found in other modules, you can import them\",\n     };\n+    let msg = format!(\"possible {}candidate{} into scope\", better, msg_diff);\n+\n+    for candidate in &mut path_strings {\n+        *candidate = format!(\"use {};\\n\", candidate);\n+    }\n \n-    let end = cmp::min(MAX_CANDIDATES, path_strings.len());\n-    session.help(&format!(\"possible {}candidate{} into scope:{}{}\",\n-                          better,\n-                          msg_diff,\n-                          &path_strings[0..end].iter().map(|candidate| {\n-                              format!(\"\\n  `use {};`\", candidate)\n-                          }).collect::<String>(),\n-                          if path_strings.len() > MAX_CANDIDATES {\n-                              format!(\"\\nand {} other candidates\",\n-                                      path_strings.len() - MAX_CANDIDATES)\n-                          } else {\n-                              \"\".to_owned()\n-                          }\n-                          ));\n+    err.span_suggestions(span, &msg, path_strings);\n }\n \n /// A somewhat inefficient routine to obtain the name of a module."}, {"sha": "c08421cb9374eb9efa04bf4183762a66c07287cc", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -123,14 +123,14 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     fn eliminate_crate_var(&mut self, item: P<ast::Item>) -> P<ast::Item> {\n-        struct EliminateCrateVar<'b, 'a: 'b>(&'b mut Resolver<'a>);\n+        struct EliminateCrateVar<'b, 'a: 'b>(&'b mut Resolver<'a>, Span);\n \n         impl<'a, 'b> Folder for EliminateCrateVar<'a, 'b> {\n             fn fold_path(&mut self, mut path: ast::Path) -> ast::Path {\n                 let ident = path.segments[0].identifier;\n                 if ident.name == \"$crate\" {\n                     path.segments[0].identifier.name = keywords::CrateRoot.name();\n-                    let module = self.0.resolve_crate_var(ident.ctxt);\n+                    let module = self.0.resolve_crate_var(ident.ctxt, self.1);\n                     if !module.is_local() {\n                         let span = path.segments[0].span;\n                         path.segments.insert(1, match module.kind {\n@@ -149,7 +149,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             }\n         }\n \n-        EliminateCrateVar(self).fold_item(item).expect_one(\"\")\n+        EliminateCrateVar(self, item.span).fold_item(item).expect_one(\"\")\n     }\n \n     fn is_whitelisted_legacy_custom_derive(&self, name: Name) -> bool {\n@@ -379,7 +379,7 @@ impl<'a> Resolver<'a> {\n                 return Err(Determinacy::Determined);\n             }\n \n-            let def = match self.resolve_path(&path, Some(MacroNS), None) {\n+            let def = match self.resolve_path(&path, Some(MacroNS), false, span) {\n                 PathResult::NonModule(path_res) => match path_res.base_def() {\n                     Def::Err => Err(Determinacy::Determined),\n                     def @ _ => Ok(def),\n@@ -401,7 +401,7 @@ impl<'a> Resolver<'a> {\n         let result = if let Some(MacroBinding::Legacy(binding)) = legacy_resolution {\n             Ok(Def::Macro(binding.def_id, MacroKind::Bang))\n         } else {\n-            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, None) {\n+            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, false, span) {\n                 Ok(binding) => Ok(binding.binding().def_ignoring_ambiguity()),\n                 Err(Determinacy::Undetermined) if !force => return Err(Determinacy::Undetermined),\n                 Err(_) => {\n@@ -421,18 +421,19 @@ impl<'a> Resolver<'a> {\n     pub fn resolve_lexical_macro_path_segment(&mut self,\n                                               ident: Ident,\n                                               ns: Namespace,\n-                                              record_used: Option<Span>)\n+                                              record_used: bool,\n+                                              path_span: Span)\n                                               -> Result<MacroBinding<'a>, Determinacy> {\n         let mut module = Some(self.current_module);\n         let mut potential_illegal_shadower = Err(Determinacy::Determined);\n         let determinacy =\n-            if record_used.is_some() { Determinacy::Determined } else { Determinacy::Undetermined };\n+            if record_used { Determinacy::Determined } else { Determinacy::Undetermined };\n         loop {\n             let result = if let Some(module) = module {\n                 // Since expanded macros may not shadow the lexical scope and\n                 // globs may not shadow global macros (both enforced below),\n                 // we resolve with restricted shadowing (indicated by the penultimate argument).\n-                self.resolve_ident_in_module(module, ident, ns, true, record_used)\n+                self.resolve_ident_in_module(module, ident, ns, true, record_used, path_span)\n                     .map(MacroBinding::Modern)\n             } else {\n                 self.global_macros.get(&ident.name).cloned().ok_or(determinacy)\n@@ -441,15 +442,18 @@ impl<'a> Resolver<'a> {\n \n             match result.map(MacroBinding::binding) {\n                 Ok(binding) => {\n-                    let span = match record_used {\n-                        Some(span) => span,\n-                        None => return result,\n-                    };\n+                    if !record_used {\n+                        return result;\n+                    }\n                     if let Ok(MacroBinding::Modern(shadower)) = potential_illegal_shadower {\n                         if shadower.def() != binding.def() {\n                             let name = ident.name;\n                             self.ambiguity_errors.push(AmbiguityError {\n-                                span: span, name: name, b1: shadower, b2: binding, lexical: true,\n+                                span: path_span,\n+                                name: name,\n+                                b1: shadower,\n+                                b2: binding,\n+                                lexical: true,\n                                 legacy: false,\n                             });\n                             return potential_illegal_shadower;\n@@ -543,7 +547,7 @@ impl<'a> Resolver<'a> {\n     pub fn finalize_current_module_macro_resolutions(&mut self) {\n         let module = self.current_module;\n         for &(ref path, span) in module.macro_resolutions.borrow().iter() {\n-            match self.resolve_path(path, Some(MacroNS), Some(span)) {\n+            match self.resolve_path(path, Some(MacroNS), true, span) {\n                 PathResult::NonModule(_) => {},\n                 PathResult::Failed(msg, _) => {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n@@ -555,7 +559,7 @@ impl<'a> Resolver<'a> {\n         for &(mark, ident, span, kind) in module.legacy_macro_resolutions.borrow().iter() {\n             let legacy_scope = &self.invocations[&mark].legacy_scope;\n             let legacy_resolution = self.resolve_legacy_scope(legacy_scope, ident.name, true);\n-            let resolution = self.resolve_lexical_macro_path_segment(ident, MacroNS, Some(span));\n+            let resolution = self.resolve_lexical_macro_path_segment(ident, MacroNS, true, span);\n             match (legacy_resolution, resolution) {\n                 (Some(MacroBinding::Legacy(legacy_binding)), Ok(MacroBinding::Modern(binding))) => {\n                     let msg1 = format!(\"`{}` could refer to the macro defined here\", ident);\n@@ -579,7 +583,7 @@ impl<'a> Resolver<'a> {\n                             format!(\"cannot find derive macro `{}` in this scope\", ident),\n                     };\n                     let mut err = self.session.struct_span_err(span, &msg);\n-                    self.suggest_macro_name(&ident.name.as_str(), kind, &mut err);\n+                    self.suggest_macro_name(&ident.name.as_str(), kind, &mut err, span);\n                     err.emit();\n                 },\n                 _ => {},\n@@ -588,7 +592,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn suggest_macro_name(&mut self, name: &str, kind: MacroKind,\n-                          err: &mut DiagnosticBuilder<'a>) {\n+                          err: &mut DiagnosticBuilder<'a>, span: Span) {\n         // First check if this is a locally-defined bang macro.\n         let suggestion = if let MacroKind::Bang = kind {\n             find_best_match_for_name(self.macro_names.iter(), name, None)\n@@ -619,7 +623,7 @@ impl<'a> Resolver<'a> {\n                 }\n             };\n             let ident = Ident::from_str(name);\n-            self.lookup_typo_candidate(&vec![ident], MacroNS, is_macro)\n+            self.lookup_typo_candidate(&vec![ident], MacroNS, is_macro, span)\n         });\n \n         if let Some(suggestion) = suggestion {"}, {"sha": "1d4ba4ed100b72e3139fbcf29b42e70e1e9eed13", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -146,15 +146,16 @@ impl<'a> Resolver<'a> {\n                                    ident: Ident,\n                                    ns: Namespace,\n                                    restricted_shadowing: bool,\n-                                   record_used: Option<Span>)\n+                                   record_used: bool,\n+                                   path_span: Span)\n                                    -> Result<&'a NameBinding<'a>, Determinacy> {\n         self.populate_module_if_necessary(module);\n \n         let resolution = self.resolution(module, ident, ns)\n             .try_borrow_mut()\n             .map_err(|_| Determined)?; // This happens when there is a cycle of imports\n \n-        if let Some(span) = record_used {\n+        if record_used {\n             if let Some(binding) = resolution.binding {\n                 if let Some(shadowed_glob) = resolution.shadows_glob {\n                     let name = ident.name;\n@@ -164,16 +165,20 @@ impl<'a> Resolver<'a> {\n                        ns != MacroNS && // In MacroNS, `try_define` always forbids this shadowing\n                        binding.def() != shadowed_glob.def() {\n                         self.ambiguity_errors.push(AmbiguityError {\n-                            span: span, name: name, lexical: false, b1: binding, b2: shadowed_glob,\n+                            span: path_span,\n+                            name: name,\n+                            lexical: false,\n+                            b1: binding,\n+                            b2: shadowed_glob,\n                             legacy: false,\n                         });\n                     }\n                 }\n-                if self.record_use(ident, ns, binding, span) {\n+                if self.record_use(ident, ns, binding, path_span) {\n                     return Ok(self.dummy_binding);\n                 }\n                 if !self.is_accessible(binding.vis) {\n-                    self.privacy_errors.push(PrivacyError(span, ident.name, binding));\n+                    self.privacy_errors.push(PrivacyError(path_span, ident.name, binding));\n                 }\n             }\n \n@@ -205,7 +210,7 @@ impl<'a> Resolver<'a> {\n                     SingleImport { source, .. } => source,\n                     _ => unreachable!(),\n                 };\n-                match self.resolve_ident_in_module(module, ident, ns, false, None) {\n+                match self.resolve_ident_in_module(module, ident, ns, false, false, path_span) {\n                     Err(Determined) => {}\n                     _ => return Err(Undetermined),\n                 }\n@@ -230,7 +235,12 @@ impl<'a> Resolver<'a> {\n         for directive in module.globs.borrow().iter() {\n             if self.is_accessible(directive.vis.get()) {\n                 if let Some(module) = directive.imported_module.get() {\n-                    let result = self.resolve_ident_in_module(module, ident, ns, false, None);\n+                    let result = self.resolve_ident_in_module(module,\n+                                                              ident,\n+                                                              ns,\n+                                                              false,\n+                                                              false,\n+                                                              path_span);\n                     if let Err(Undetermined) = result {\n                         return Err(Undetermined);\n                     }\n@@ -499,7 +509,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             // For better failure detection, pretend that the import will not define any names\n             // while resolving its module path.\n             directive.vis.set(ty::Visibility::Invisible);\n-            let result = self.resolve_path(&directive.module_path, None, None);\n+            let result = self.resolve_path(&directive.module_path, None, false, directive.span);\n             directive.vis.set(vis);\n \n             match result {\n@@ -523,7 +533,12 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         let mut indeterminate = false;\n         self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n             if let Err(Undetermined) = result[ns].get() {\n-                result[ns].set(this.resolve_ident_in_module(module, source, ns, false, None));\n+                result[ns].set(this.resolve_ident_in_module(module,\n+                                                            source,\n+                                                            ns,\n+                                                            false,\n+                                                            false,\n+                                                            directive.span));\n             } else {\n                 return\n             };\n@@ -563,14 +578,14 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         self.current_module = directive.parent;\n \n         let ImportDirective { ref module_path, span, .. } = *directive;\n-        let module_result = self.resolve_path(&module_path, None, Some(span));\n+        let module_result = self.resolve_path(&module_path, None, true, span);\n         let module = match module_result {\n             PathResult::Module(module) => module,\n             PathResult::Failed(msg, _) => {\n                 let (mut self_path, mut self_result) = (module_path.clone(), None);\n                 if !self_path.is_empty() && !token::Ident(self_path[0]).is_path_segment_keyword() {\n                     self_path[0].name = keywords::SelfValue.name();\n-                    self_result = Some(self.resolve_path(&self_path, None, None));\n+                    self_result = Some(self.resolve_path(&self_path, None, false, span));\n                 }\n                 return if let Some(PathResult::Module(..)) = self_result {\n                     Some(format!(\"Did you mean `{}`?\", names_to_string(&self_path)))\n@@ -609,7 +624,12 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                         Some(this.dummy_binding);\n                 }\n             }\n-        } else if let Ok(binding) = this.resolve_ident_in_module(module, ident, ns, false, None) {\n+        } else if let Ok(binding) = this.resolve_ident_in_module(module,\n+                                                                 ident,\n+                                                                 ns,\n+                                                                 false,\n+                                                                 false,\n+                                                                 directive.span) {\n             legacy_self_import = Some(directive);\n             let binding = this.arenas.alloc_name_binding(NameBinding {\n                 kind: NameBindingKind::Import {\n@@ -630,7 +650,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             }\n             let mut all_ns_failed = true;\n             self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n-                match this.resolve_ident_in_module(module, ident, ns, false, Some(span)) {\n+                match this.resolve_ident_in_module(module, ident, ns, false, true, span) {\n                     Ok(_) => all_ns_failed = false,\n                     _ => {}\n                 }"}, {"sha": "31f3415b1ecd026424e2de1baf2444e0e7edbe7f", "filename": "src/librustc_trans/back/msvc/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fmod.rs?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -32,6 +32,7 @@\n //! comments can also be found below leading through the various code paths.\n \n // A simple macro to make this option mess easier to read\n+#[cfg(windows)]\n macro_rules! otry {\n     ($expr:expr) => (match $expr {\n         Some(val) => val,"}, {"sha": "8e633ee59b67d7696323d460c5d553802927f23c", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -86,9 +86,6 @@ pub mod back {\n \n pub mod diagnostics;\n \n-#[macro_use]\n-mod macros;\n-\n mod abi;\n mod adt;\n mod asm;"}, {"sha": "77efcc6fb0030d9d768d644c02f30696ec91b09b", "filename": "src/librustc_trans/macros.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/453cad6e658e095c6beacf12c589609dac3f4e52/src%2Flibrustc_trans%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/453cad6e658e095c6beacf12c589609dac3f4e52/src%2Flibrustc_trans%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmacros.rs?ref=453cad6e658e095c6beacf12c589609dac3f4e52", "patch": "@@ -1,29 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-macro_rules! unpack_datum {\n-    ($bcx: ident, $inp: expr) => (\n-        {\n-            let db = $inp;\n-            $bcx = db.bcx;\n-            db.datum\n-        }\n-    )\n-}\n-\n-macro_rules! unpack_result {\n-    ($bcx: ident, $inp: expr) => (\n-        {\n-            let db = $inp;\n-            $bcx = db.bcx;\n-            db.val\n-        }\n-    )\n-}"}, {"sha": "cd27ddda1b15bdb5151f2baa5806dd1a78b3727e", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -415,8 +415,11 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                           Value(base));\n                             }\n                             if projected_ty.is_bool() {\n-                                unsafe {\n-                                    val = llvm::LLVMConstTrunc(val, Type::i1(self.ccx).to_ref());\n+                                let i1_type = Type::i1(self.ccx);\n+                                if val_ty(val) != i1_type {\n+                                    unsafe {\n+                                        val = llvm::LLVMConstTrunc(val, i1_type.to_ref());\n+                                    }\n                                 }\n                             }\n                             (Base::Value(val), extra)"}, {"sha": "60ea6ed1d8d58753f6f5643b1590bde5f4c4372f", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -193,6 +193,7 @@ nav.sub {\n \tfont-size: 17px;\n \tmargin: 30px 0 20px 0;\n \ttext-align: center;\n+\tword-wrap: break-word;\n }\n \n .location:empty {\n@@ -236,6 +237,9 @@ nav.sub {\n \toverflow: auto;\n \tpadding-left: 0;\n }\n+#search {\n+\tmargin-left: 230px;\n+}\n .content pre.line-numbers {\n \tfloat: left;\n \tborder: none;"}, {"sha": "44b62593fa3a69add0ce5065004b12fca4098f77", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -30,12 +30,10 @@ use str::{self, Utf8Error};\n /// type is a static guarantee that the underlying bytes contain no interior 0\n /// bytes and the final byte is 0.\n ///\n-/// A `CString` is created from either a byte slice or a byte vector. After\n-/// being created, a `CString` predominately inherits all of its methods from\n-/// the `Deref` implementation to `[c_char]`. Note that the underlying array\n-/// is represented as an array of `c_char` as opposed to `u8`. A `u8` slice\n-/// can be obtained with the `as_bytes` method.  Slices produced from a `CString`\n-/// do *not* contain the trailing nul terminator unless otherwise specified.\n+/// A `CString` is created from either a byte slice or a byte vector.  A `u8`\n+/// slice can be obtained with the `as_bytes` method.  Slices produced from a\n+/// `CString` do *not* contain the trailing nul terminator unless otherwise\n+/// specified.\n ///\n /// # Examples\n ///"}, {"sha": "200368be275c335e81b03e6b986fb6a8ded6c800", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -210,8 +210,8 @@ impl Builder {\n     /// configuration methods can be chained.\n     ///\n     /// If the [`stack_size`] field is not specified, the stack size\n-    /// will be the `RUST_MIN_STACK` environment variable, if it is\n-    /// not specified either, a sensible default size will be set (2MB as\n+    /// will be the `RUST_MIN_STACK` environment variable.  If it is\n+    /// not specified either, a sensible default will be set (2MB as\n     /// of the writting of this doc).\n     ///\n     /// # Examples"}, {"sha": "06335584c96108571e0136a1ba84a052270820e9", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -22,9 +22,8 @@\n use codemap::{CodeMap, FilePathMapping};\n use syntax_pos::{self, MacroBacktrace, Span, SpanLabel, MultiSpan};\n use errors::registry::Registry;\n-use errors::{Level, DiagnosticBuilder, SubDiagnostic, RenderSpan, CodeSuggestion, CodeMapper};\n+use errors::{DiagnosticBuilder, SubDiagnostic, RenderSpan, CodeSuggestion, CodeMapper};\n use errors::emitter::Emitter;\n-use errors::snippet::Style;\n \n use std::rc::Rc;\n use std::io::{self, Write};\n@@ -154,23 +153,26 @@ impl Diagnostic {\n     fn from_diagnostic_builder(db: &DiagnosticBuilder,\n                                je: &JsonEmitter)\n                                -> Diagnostic {\n-        let sugg = db.suggestion.as_ref().map(|sugg| {\n-            SubDiagnostic {\n-                level: Level::Help,\n-                message: vec![(sugg.msg.clone(), Style::NoStyle)],\n-                span: MultiSpan::new(),\n-                render_span: Some(RenderSpan::Suggestion(sugg.clone())),\n-            }\n+        let sugg = db.suggestions.iter().flat_map(|sugg| {\n+            je.render(sugg).into_iter().map(move |rendered| {\n+                Diagnostic {\n+                    message: sugg.msg.clone(),\n+                    code: None,\n+                    level: \"help\",\n+                    spans: DiagnosticSpan::from_suggestion(sugg, je),\n+                    children: vec![],\n+                    rendered: Some(rendered),\n+                }\n+            })\n         });\n-        let sugg = sugg.as_ref();\n         Diagnostic {\n             message: db.message(),\n             code: DiagnosticCode::map_opt_string(db.code.clone(), je),\n             level: db.level.to_str(),\n             spans: DiagnosticSpan::from_multispan(&db.span, je),\n-            children: db.children.iter().chain(sugg).map(|c| {\n+            children: db.children.iter().map(|c| {\n                 Diagnostic::from_sub_diagnostic(c, je)\n-            }).collect(),\n+            }).chain(sugg).collect(),\n             rendered: None,\n         }\n     }\n@@ -184,8 +186,7 @@ impl Diagnostic {\n                      .map(|sp| DiagnosticSpan::from_render_span(sp, je))\n                      .unwrap_or_else(|| DiagnosticSpan::from_multispan(&db.span, je)),\n             children: vec![],\n-            rendered: db.render_span.as_ref()\n-                                    .and_then(|rsp| je.render(rsp)),\n+            rendered: None,\n         }\n     }\n }\n@@ -278,14 +279,19 @@ impl DiagnosticSpan {\n \n     fn from_suggestion(suggestion: &CodeSuggestion, je: &JsonEmitter)\n                        -> Vec<DiagnosticSpan> {\n-        assert_eq!(suggestion.msp.span_labels().len(), suggestion.substitutes.len());\n-        suggestion.msp.span_labels()\n-                      .into_iter()\n-                      .zip(&suggestion.substitutes)\n-                      .map(|(span_label, suggestion)| {\n-                          DiagnosticSpan::from_span_label(span_label,\n-                                                          Some(suggestion),\n-                                                          je)\n+        suggestion.substitution_parts\n+                      .iter()\n+                      .flat_map(|substitution| {\n+                          substitution.substitutions.iter().map(move |suggestion| {\n+                              let span_label = SpanLabel {\n+                                  span: substitution.span,\n+                                  is_primary: true,\n+                                  label: None,\n+                              };\n+                              DiagnosticSpan::from_span_label(span_label,\n+                                                              Some(suggestion),\n+                                                              je)\n+                          })\n                       })\n                       .collect()\n     }\n@@ -294,8 +300,9 @@ impl DiagnosticSpan {\n         match *rsp {\n             RenderSpan::FullSpan(ref msp) =>\n                 DiagnosticSpan::from_multispan(msp, je),\n-            RenderSpan::Suggestion(ref suggestion) =>\n-                DiagnosticSpan::from_suggestion(suggestion, je),\n+            // regular diagnostics don't produce this anymore\n+            // FIXME(oli_obk): remove it entirely\n+            RenderSpan::Suggestion(_) => unreachable!(),\n         }\n     }\n }\n@@ -351,17 +358,8 @@ impl DiagnosticCode {\n }\n \n impl JsonEmitter {\n-    fn render(&self, render_span: &RenderSpan) -> Option<String> {\n-        use std::borrow::Borrow;\n-\n-        match *render_span {\n-            RenderSpan::FullSpan(_) => {\n-                None\n-            }\n-            RenderSpan::Suggestion(ref suggestion) => {\n-                Some(suggestion.splice_lines(self.cm.borrow()))\n-            }\n-        }\n+    fn render(&self, suggestion: &CodeSuggestion) -> Vec<String> {\n+        suggestion.splice_lines(&*self.cm)\n     }\n }\n "}, {"sha": "31c7cc33676776487a41e6247add158c0edf673a", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -25,12 +25,6 @@ macro_rules! pathvec {\n     )\n }\n \n-macro_rules! path {\n-    ($($x:tt)*) => (\n-        ::ext::deriving::generic::ty::Path::new( pathvec![ $($x)* ] )\n-    )\n-}\n-\n macro_rules! path_local {\n     ($x:ident) => (\n         ::deriving::generic::ty::Path::new_local(stringify!($x))"}, {"sha": "001c1f2eddca1e3ccbeabaf58450b6296547847c", "filename": "src/test/compile-fail/issue-35675.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftest%2Fcompile-fail%2Fissue-35675.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftest%2Fcompile-fail%2Fissue-35675.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-35675.rs?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum Fruit {\n+// these two HELPs are actually in a new line between this line and the `enum Fruit` line\n+enum Fruit { //~ HELP possible candidate is found in another module, you can import it into scope\n+    //~^ HELP possible candidate is found in another module, you can import it into scope\n     Apple(i64),\n     //~^ HELP there is an enum variant `Fruit::Apple`, did you mean to use `Fruit`?\n     //~| HELP there is an enum variant `Fruit::Apple`, did you mean to use `Fruit`?\n@@ -21,7 +23,6 @@ fn should_return_fruit() -> Apple {\n     Apple(5)\n     //~^ ERROR cannot find function `Apple` in this scope\n     //~| NOTE not found in this scope\n-    //~| HELP possible candidate is found in another module, you can import it into scope\n }\n \n fn should_return_fruit_too() -> Fruit::Apple {\n@@ -30,7 +31,6 @@ fn should_return_fruit_too() -> Fruit::Apple {\n     Apple(5)\n     //~^ ERROR cannot find function `Apple` in this scope\n     //~| NOTE not found in this scope\n-    //~| HELP possible candidate is found in another module, you can import it into scope\n }\n \n fn foo() -> Ok {"}, {"sha": "276067d7d7491e662c57bb5a1a93b02002edfbc2", "filename": "src/test/run-pass/issue-41744.rs", "status": "renamed", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftest%2Frun-pass%2Fissue-41744.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftest%2Frun-pass%2Fissue-41744.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-41744.rs?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,13 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![doc(hidden)]\n+trait Tc {}\n+impl Tc for bool {}\n \n-macro_rules! assert_approx_eq {\n-    ($a:expr, $b:expr) => ({\n-        use num::Float;\n-        let (a, b) = (&$a, &$b);\n-        assert!((*a - *b).abs() < 1.0e-6,\n-                \"{} is not approximately equal to {}\", *a, *b);\n-    })\n+fn main() {\n+    let _: &[&Tc] = &[&true];\n }", "previous_filename": "src/libcore/num/float_macros.rs"}, {"sha": "17c5d5d15d40479415e0c5503c248ace94e25045", "filename": "src/test/ui/resolve/enums-are-namespaced-xc.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftest%2Fui%2Fresolve%2Fenums-are-namespaced-xc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftest%2Fui%2Fresolve%2Fenums-are-namespaced-xc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fenums-are-namespaced-xc.stderr?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -4,26 +4,26 @@ error[E0425]: cannot find value `A` in module `namespaced_enums`\n 15 |     let _ = namespaced_enums::A;\n    |                               ^ not found in `namespaced_enums`\n    |\n-   = help: possible candidate is found in another module, you can import it into scope:\n-             `use namespaced_enums::Foo::A;`\n+help: possible candidate is found in another module, you can import it into scope\n+   | use namespaced_enums::Foo::A;\n \n error[E0425]: cannot find function `B` in module `namespaced_enums`\n   --> $DIR/enums-are-namespaced-xc.rs:18:31\n    |\n 18 |     let _ = namespaced_enums::B(10);\n    |                               ^ not found in `namespaced_enums`\n    |\n-   = help: possible candidate is found in another module, you can import it into scope:\n-             `use namespaced_enums::Foo::B;`\n+help: possible candidate is found in another module, you can import it into scope\n+   | use namespaced_enums::Foo::B;\n \n error[E0422]: cannot find struct, variant or union type `C` in module `namespaced_enums`\n   --> $DIR/enums-are-namespaced-xc.rs:21:31\n    |\n 21 |     let _ = namespaced_enums::C { a: 10 };\n    |                               ^ not found in `namespaced_enums`\n    |\n-   = help: possible candidate is found in another module, you can import it into scope:\n-             `use namespaced_enums::Foo::C;`\n+help: possible candidate is found in another module, you can import it into scope\n+   | use namespaced_enums::Foo::C;\n \n error: aborting due to 3 previous errors\n "}, {"sha": "63d2ce109142c70116181304aad38511fcb51325", "filename": "src/test/ui/resolve/issue-16058.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftest%2Fui%2Fresolve%2Fissue-16058.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftest%2Fui%2Fresolve%2Fissue-16058.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-16058.stderr?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -4,10 +4,10 @@ error[E0574]: expected struct, variant or union type, found enum `Result`\n 19 |         Result {\n    |         ^^^^^^ not a struct, variant or union type\n    |\n-   = help: possible better candidates are found in other modules, you can import them into scope:\n-             `use std::fmt::Result;`\n-             `use std::io::Result;`\n-             `use std::thread::Result;`\n+help: possible better candidates are found in other modules, you can import them into scope\n+   | use std::fmt::Result;\n+   | use std::io::Result;\n+   | use std::thread::Result;\n \n error: aborting due to previous error\n "}, {"sha": "c0438abfe43b45cd5458eb302868063ff96c15df", "filename": "src/test/ui/resolve/issue-17518.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftest%2Fui%2Fresolve%2Fissue-17518.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftest%2Fui%2Fresolve%2Fissue-17518.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-17518.stderr?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -4,8 +4,8 @@ error[E0422]: cannot find struct, variant or union type `E` in this scope\n 16 |     E { name: \"foobar\" }; //~ ERROR unresolved struct, variant or union type `E`\n    |     ^ not found in this scope\n    |\n-   = help: possible candidate is found in another module, you can import it into scope:\n-             `use SomeEnum::E;`\n+help: possible candidate is found in another module, you can import it into scope\n+   | use SomeEnum::E;\n \n error: aborting due to previous error\n "}, {"sha": "7315d295f7b8427a9c84cafe3cfa3a37539d3d89", "filename": "src/test/ui/resolve/issue-21221-1.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-1.stderr?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -4,23 +4,23 @@ error[E0405]: cannot find trait `Mul` in this scope\n 53 | impl Mul for Foo {\n    |      ^^^ not found in this scope\n    |\n-   = help: possible candidates are found in other modules, you can import them into scope:\n-             `use mul1::Mul;`\n-             `use mul2::Mul;`\n-             `use std::ops::Mul;`\n+help: possible candidates are found in other modules, you can import them into scope\n+   | use mul1::Mul;\n+   | use mul2::Mul;\n+   | use std::ops::Mul;\n \n error[E0412]: cannot find type `Mul` in this scope\n   --> $DIR/issue-21221-1.rs:72:16\n    |\n 72 | fn getMul() -> Mul {\n    |                ^^^ not found in this scope\n    |\n-   = help: possible candidates are found in other modules, you can import them into scope:\n-             `use mul1::Mul;`\n-             `use mul2::Mul;`\n-             `use mul3::Mul;`\n-             `use mul4::Mul;`\n-           and 2 other candidates\n+help: possible candidates are found in other modules, you can import them into scope\n+   | use mul1::Mul;\n+   | use mul2::Mul;\n+   | use mul3::Mul;\n+   | use mul4::Mul;\n+and 2 other candidates\n \n error[E0405]: cannot find trait `ThisTraitReallyDoesntExistInAnyModuleReally` in this scope\n   --> $DIR/issue-21221-1.rs:83:6\n@@ -34,8 +34,8 @@ error[E0405]: cannot find trait `Div` in this scope\n 88 | impl Div for Foo {\n    |      ^^^ not found in this scope\n    |\n-   = help: possible candidate is found in another module, you can import it into scope:\n-             `use std::ops::Div;`\n+help: possible candidate is found in another module, you can import it into scope\n+   | use std::ops::Div;\n \n error: cannot continue compilation due to previous error\n "}, {"sha": "f0b22754e6444607af28f16310bbe92a490c5f7e", "filename": "src/test/ui/resolve/issue-21221-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-2.stderr?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -4,8 +4,8 @@ error[E0405]: cannot find trait `T` in this scope\n 28 | impl T for Foo { }\n    |      ^ not found in this scope\n    |\n-   = help: possible candidate is found in another module, you can import it into scope:\n-             `use foo::bar::T;`\n+help: possible candidate is found in another module, you can import it into scope\n+   | use foo::bar::T;\n \n error: main function not found\n "}, {"sha": "a4a2496b19ae4c0b85c070945fa4fff4d35e0f54", "filename": "src/test/ui/resolve/issue-21221-3.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-3.stderr?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -4,8 +4,8 @@ error[E0405]: cannot find trait `OuterTrait` in this scope\n 25 | impl OuterTrait for Foo {}\n    |      ^^^^^^^^^^ not found in this scope\n    |\n-   = help: possible candidate is found in another module, you can import it into scope:\n-             `use issue_21221_3::outer::OuterTrait;`\n+help: possible candidate is found in another module, you can import it into scope\n+   | use issue_21221_3::outer::OuterTrait;\n \n error: cannot continue compilation due to previous error\n "}, {"sha": "dc2f22717313320616be267464421c8f15841708", "filename": "src/test/ui/resolve/issue-21221-4.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-4.stderr?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -4,8 +4,8 @@ error[E0405]: cannot find trait `T` in this scope\n 20 | impl T for Foo {}\n    |      ^ not found in this scope\n    |\n-   = help: possible candidate is found in another module, you can import it into scope:\n-             `use issue_21221_4::T;`\n+help: possible candidate is found in another module, you can import it into scope\n+   | use issue_21221_4::T;\n \n error: cannot continue compilation due to previous error\n "}, {"sha": "0bf39dc55cee76a5b30d073f3c532380d2b7c5af", "filename": "src/test/ui/resolve/issue-3907.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftest%2Fui%2Fresolve%2Fissue-3907.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftest%2Fui%2Fresolve%2Fissue-3907.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-3907.stderr?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -4,8 +4,8 @@ error[E0404]: expected trait, found type alias `Foo`\n 20 | impl Foo for S { //~ ERROR expected trait, found type alias `Foo`\n    |      ^^^ type aliases cannot be used for traits\n    |\n-   = help: possible better candidate is found in another module, you can import it into scope:\n-             `use issue_3907::Foo;`\n+help: possible better candidate is found in another module, you can import it into scope\n+   | use issue_3907::Foo;\n \n error: cannot continue compilation due to previous error\n "}, {"sha": "19940ff4586d2e3baf028f71ebecec7ba96804f9", "filename": "src/test/ui/resolve/privacy-struct-ctor.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.stderr?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -8,8 +8,8 @@ error[E0423]: expected value, found struct `Z`\n    |         did you mean `S`?\n    |         constructor is not visible here due to private fields\n    |\n-   = help: possible better candidate is found in another module, you can import it into scope:\n-             `use m::n::Z;`\n+help: possible better candidate is found in another module, you can import it into scope\n+   | use m::n::Z;\n \n error[E0423]: expected value, found struct `S`\n   --> $DIR/privacy-struct-ctor.rs:36:5\n@@ -20,8 +20,8 @@ error[E0423]: expected value, found struct `S`\n    |     did you mean `S { /* fields */ }`?\n    |     constructor is not visible here due to private fields\n    |\n-   = help: possible better candidate is found in another module, you can import it into scope:\n-             `use m::S;`\n+help: possible better candidate is found in another module, you can import it into scope\n+   | use m::S;\n \n error[E0423]: expected value, found struct `xcrate::S`\n   --> $DIR/privacy-struct-ctor.rs:42:5\n@@ -32,8 +32,8 @@ error[E0423]: expected value, found struct `xcrate::S`\n    |     did you mean `xcrate::S { /* fields */ }`?\n    |     constructor is not visible here due to private fields\n    |\n-   = help: possible better candidate is found in another module, you can import it into scope:\n-             `use m::S;`\n+help: possible better candidate is found in another module, you can import it into scope\n+   | use m::S;\n \n error: tuple struct `Z` is private\n   --> $DIR/privacy-struct-ctor.rs:25:9"}, {"sha": "e53ea6a55afb5dc3a9b1028bba5f5d89312fe0e9", "filename": "src/test/ui/span/issue-35987.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftest%2Fui%2Fspan%2Fissue-35987.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftest%2Fui%2Fspan%2Fissue-35987.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-35987.stderr?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -4,8 +4,8 @@ error[E0404]: expected trait, found type parameter `Add`\n 15 | impl<T: Clone, Add> Add for Foo<T> {\n    |                     ^^^ not a trait\n    |\n-   = help: possible better candidate is found in another module, you can import it into scope:\n-             `use std::ops::Add;`\n+help: possible better candidate is found in another module, you can import it into scope\n+   | use std::ops::Add;\n \n error: main function not found\n "}, {"sha": "8b7da2267cdedc191fb7e3f9e0e1f64c3368475f", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -23,12 +23,15 @@ static LICENSES: &'static [&'static str] = &[\n     \"Unlicense/MIT\",\n ];\n \n-/// These MPL licensed projects are acceptable, but only these.\n+// These are exceptions to Rust's permissive licensing policy, and\n+// should be considered bugs. Exceptions are only allowed in Rust\n+// tooling. It is _crucial_ that no exception crates be dependencies\n+// of the Rust runtime (std / test).\n static EXCEPTIONS: &'static [&'static str] = &[\n-    \"mdbook\",\n-    \"openssl\",\n-    \"pest\",\n-    \"thread-id\",\n+    \"mdbook\", // MPL2, mdbook\n+    \"openssl\", // BSD+advertising clause, cargo, mdbook\n+    \"pest\", // MPL2, mdbook via handlebars\n+    \"thread-id\", // Apache-2.0, mdbook\n ];\n \n pub fn check(path: &Path, bad: &mut bool) {"}, {"sha": "8bf683de8704aedde2b69566a9084e243d3e0c49", "filename": "src/tools/tidy/src/style.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs?ref=ef3ec5ece5bdf8950810225a9a3bc3cd1926e3d5", "patch": "@@ -107,6 +107,11 @@ pub fn check(path: &Path, bad: &mut bool) {\n \n         contents.truncate(0);\n         t!(t!(File::open(file), file).read_to_string(&mut contents));\n+\n+        if contents.is_empty() {\n+            tidy_error!(bad, \"{}: empty file\", file.display());\n+        }\n+\n         let skip_cr = contents.contains(\"ignore-tidy-cr\");\n         let skip_tab = contents.contains(\"ignore-tidy-tab\");\n         let skip_length = contents.contains(\"ignore-tidy-linelength\");"}]}