{"sha": "88e7862dd05ff939cd498eb0ad2f3383bad33171", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4ZTc4NjJkZDA1ZmY5MzljZDQ5OGViMGFkMmYzMzgzYmFkMzMxNzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-04T05:52:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-04T05:52:43Z"}, "message": "Auto merge of #83267 - ssomers:btree_prune_range_search_overlap, r=Mark-Simulacrum\n\nBTree: no longer search arrays twice to check Ord\n\nA possible addition to / partial replacement of #83147: no longer linearly search the upper bound of a range in the initial portion of the keys we already know are below the lower bound.\n- Should be faster: fewer key comparisons at the cost of some instructions dealing with offsets\n- Makes code a little more complicated.\n- No longer detects ill-defined `Ord` implementations, but that wasn't a publicised feature, and was quite incomplete, and was only done in the `range` and `range_mut` methods.\nr? `@Mark-Simulacrum`", "tree": {"sha": "dabfa04986cc6520f56a2ad9507a3213a3909f36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dabfa04986cc6520f56a2ad9507a3213a3909f36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88e7862dd05ff939cd498eb0ad2f3383bad33171", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88e7862dd05ff939cd498eb0ad2f3383bad33171", "html_url": "https://github.com/rust-lang/rust/commit/88e7862dd05ff939cd498eb0ad2f3383bad33171", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88e7862dd05ff939cd498eb0ad2f3383bad33171/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0850c37bd390ca9eac644031565f74dd747596a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/0850c37bd390ca9eac644031565f74dd747596a6", "html_url": "https://github.com/rust-lang/rust/commit/0850c37bd390ca9eac644031565f74dd747596a6"}, {"sha": "fd6e4e41b7608c6fcdd34aedfc2d88b27b1ada05", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd6e4e41b7608c6fcdd34aedfc2d88b27b1ada05", "html_url": "https://github.com/rust-lang/rust/commit/fd6e4e41b7608c6fcdd34aedfc2d88b27b1ada05"}], "stats": {"total": 70, "additions": 43, "deletions": 27}, "files": [{"sha": "3a74b6a6fa85c8f29d366769df6b37ce1b30a2c0", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88e7862dd05ff939cd498eb0ad2f3383bad33171/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88e7862dd05ff939cd498eb0ad2f3383bad33171/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=88e7862dd05ff939cd498eb0ad2f3383bad33171", "patch": "@@ -776,7 +776,6 @@ fn test_range_backwards_4() {\n }\n \n #[test]\n-#[should_panic]\n fn test_range_finding_ill_order_in_map() {\n     let mut map = BTreeMap::new();\n     map.insert(Cyclic3::B, ());\n@@ -789,7 +788,6 @@ fn test_range_finding_ill_order_in_map() {\n }\n \n #[test]\n-#[should_panic]\n fn test_range_finding_ill_order_in_range_ord() {\n     // Has proper order the first time asked, then flips around.\n     struct EvilTwin(i32);"}, {"sha": "4399feaccc9b7a6b137cb9954601bb9eda5d7f8a", "filename": "library/alloc/src/collections/btree/navigate.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/88e7862dd05ff939cd498eb0ad2f3383bad33171/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88e7862dd05ff939cd498eb0ad2f3383bad33171/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=88e7862dd05ff939cd498eb0ad2f3383bad33171", "patch": "@@ -29,11 +29,18 @@ impl<BorrowType, K, V> LeafRange<BorrowType, K, V> {\n \n impl<BorrowType: marker::BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n     /// Finds the distinct leaf edges delimiting a specified range in a tree.\n-    /// Returns either a pair of different handles into the same tree or a pair\n-    /// of empty options.\n+    ///\n+    /// If such distinct edges exist, returns them in ascending order, meaning\n+    /// that a non-zero number of calls to `next_unchecked` on the `front` of\n+    /// the result and/or calls to `next_back_unchecked` on the `back` of the\n+    /// result will eventually reach the same edge.\n+    ///\n+    /// If there are no such edges, i.e., if the tree contains no key within\n+    /// the range, returns a pair of empty options.\n+    ///\n     /// # Safety\n-    /// Unless `BorrowType` is `Immut`, do not use the duplicate handles to\n-    /// visit the same KV twice.\n+    /// Unless `BorrowType` is `Immut`, do not use the handles to visit the same\n+    /// KV twice.\n     unsafe fn find_leaf_edges_spanning_range<Q: ?Sized, R>(\n         self,\n         range: R,"}, {"sha": "5651a03c47a43e4f7361d2395697d5646a739ce4", "filename": "library/alloc/src/collections/btree/search.rs", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/88e7862dd05ff939cd498eb0ad2f3383bad33171/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88e7862dd05ff939cd498eb0ad2f3383bad33171/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs?ref=88e7862dd05ff939cd498eb0ad2f3383bad33171", "patch": "@@ -68,13 +68,16 @@ impl<BorrowType: marker::BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Lea\n     /// of the range is different from the edge matching the upper bound, i.e.,\n     /// the nearest node that has at least one key contained in the range.\n     ///\n-    /// If found, returns an `Ok` with that node, the pair of edge indices in it\n-    /// delimiting the range, and the corresponding pair of bounds for\n-    /// continuing the search in the child nodes, in case the node is internal.\n+    /// If found, returns an `Ok` with that node, the strictly ascending pair of\n+    /// edge indices in the node delimiting the range, and the corresponding\n+    /// pair of bounds for continuing the search in the child nodes, in case\n+    /// the node is internal.\n     ///\n     /// If not found, returns an `Err` with the leaf edge matching the entire\n     /// range.\n     ///\n+    /// As a diagnostic service, panics if the range specifies impossible bounds.\n+    ///\n     /// The result is meaningful only if the tree is ordered by key.\n     pub fn search_tree_for_bifurcation<'r, Q: ?Sized, R>(\n         mut self,\n@@ -112,10 +115,8 @@ impl<BorrowType: marker::BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Lea\n         let mut upper_bound = SearchBound::from_range(end);\n         loop {\n             let (lower_edge_idx, lower_child_bound) = self.find_lower_bound_index(lower_bound);\n-            let (upper_edge_idx, upper_child_bound) = self.find_upper_bound_index(upper_bound);\n-            if lower_edge_idx > upper_edge_idx {\n-                panic!(\"Ord is ill-defined in BTreeMap range\")\n-            }\n+            let (upper_edge_idx, upper_child_bound) =\n+                unsafe { self.find_upper_bound_index(upper_bound, lower_edge_idx) };\n             if lower_edge_idx < upper_edge_idx {\n                 return Ok((\n                     self,\n@@ -125,6 +126,7 @@ impl<BorrowType: marker::BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Lea\n                     upper_child_bound,\n                 ));\n             }\n+            debug_assert_eq!(lower_edge_idx, upper_edge_idx);\n             let common_edge = unsafe { Handle::new_edge(self, lower_edge_idx) };\n             match common_edge.force() {\n                 Leaf(common_edge) => return Err(common_edge),\n@@ -164,7 +166,7 @@ impl<BorrowType: marker::BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Lea\n         Q: ?Sized + Ord,\n         K: Borrow<Q>,\n     {\n-        let (edge_idx, bound) = self.find_upper_bound_index(bound);\n+        let (edge_idx, bound) = unsafe { self.find_upper_bound_index(bound, 0) };\n         let edge = unsafe { Handle::new_edge(self, edge_idx) };\n         (edge, bound)\n     }\n@@ -183,29 +185,33 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         Q: Ord,\n         K: Borrow<Q>,\n     {\n-        match self.find_key_index(key) {\n+        match unsafe { self.find_key_index(key, 0) } {\n             IndexResult::KV(idx) => Found(unsafe { Handle::new_kv(self, idx) }),\n             IndexResult::Edge(idx) => GoDown(unsafe { Handle::new_edge(self, idx) }),\n         }\n     }\n \n     /// Returns either the KV index in the node at which the key (or an equivalent)\n-    /// exists, or the edge index where the key belongs.\n+    /// exists, or the edge index where the key belongs, starting from a particular index.\n     ///\n     /// The result is meaningful only if the tree is ordered by key, like the tree\n     /// in a `BTreeMap` is.\n-    fn find_key_index<Q: ?Sized>(&self, key: &Q) -> IndexResult\n+    ///\n+    /// # Safety\n+    /// `start_index` must be a valid edge index for the node.\n+    unsafe fn find_key_index<Q: ?Sized>(&self, key: &Q, start_index: usize) -> IndexResult\n     where\n         Q: Ord,\n         K: Borrow<Q>,\n     {\n         let node = self.reborrow();\n         let keys = node.keys();\n-        for (i, k) in keys.iter().enumerate() {\n+        debug_assert!(start_index <= keys.len());\n+        for (offset, k) in unsafe { keys.get_unchecked(start_index..) }.iter().enumerate() {\n             match key.cmp(k.borrow()) {\n                 Ordering::Greater => {}\n-                Ordering::Equal => return IndexResult::KV(i),\n-                Ordering::Less => return IndexResult::Edge(i),\n+                Ordering::Equal => return IndexResult::KV(start_index + offset),\n+                Ordering::Less => return IndexResult::Edge(start_index + offset),\n             }\n         }\n         IndexResult::Edge(keys.len())\n@@ -225,11 +231,11 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         K: Borrow<Q>,\n     {\n         match bound {\n-            Included(key) => match self.find_key_index(key) {\n+            Included(key) => match unsafe { self.find_key_index(key, 0) } {\n                 IndexResult::KV(idx) => (idx, AllExcluded),\n                 IndexResult::Edge(idx) => (idx, bound),\n             },\n-            Excluded(key) => match self.find_key_index(key) {\n+            Excluded(key) => match unsafe { self.find_key_index(key, 0) } {\n                 IndexResult::KV(idx) => (idx + 1, AllIncluded),\n                 IndexResult::Edge(idx) => (idx, bound),\n             },\n@@ -238,26 +244,31 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         }\n     }\n \n-    /// Clone of `find_lower_bound_index` for the upper bound.\n-    fn find_upper_bound_index<'r, Q>(\n+    /// Mirror image of `find_lower_bound_index` for the upper bound,\n+    /// with an additional parameter to skip part of the key array.\n+    ///\n+    /// # Safety\n+    /// `start_index` must be a valid edge index for the node.\n+    unsafe fn find_upper_bound_index<'r, Q>(\n         &self,\n         bound: SearchBound<&'r Q>,\n+        start_index: usize,\n     ) -> (usize, SearchBound<&'r Q>)\n     where\n         Q: ?Sized + Ord,\n         K: Borrow<Q>,\n     {\n         match bound {\n-            Included(key) => match self.find_key_index(key) {\n+            Included(key) => match unsafe { self.find_key_index(key, start_index) } {\n                 IndexResult::KV(idx) => (idx + 1, AllExcluded),\n                 IndexResult::Edge(idx) => (idx, bound),\n             },\n-            Excluded(key) => match self.find_key_index(key) {\n+            Excluded(key) => match unsafe { self.find_key_index(key, start_index) } {\n                 IndexResult::KV(idx) => (idx, AllIncluded),\n                 IndexResult::Edge(idx) => (idx, bound),\n             },\n             AllIncluded => (self.len(), AllIncluded),\n-            AllExcluded => (0, AllExcluded),\n+            AllExcluded => (start_index, AllExcluded),\n         }\n     }\n }"}]}