{"sha": "ffdc740446585502bd179cb608a033dd74a41e39", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmZGM3NDA0NDY1ODU1MDJiZDE3OWNiNjA4YTAzM2RkNzRhNDFlMzk=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-02-26T04:27:57Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-02-26T12:53:00Z"}, "message": "Add recursive support in original_range", "tree": {"sha": "2ae365b1556c2e666669991a8aaffa362e0c2598", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ae365b1556c2e666669991a8aaffa362e0c2598"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffdc740446585502bd179cb608a033dd74a41e39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffdc740446585502bd179cb608a033dd74a41e39", "html_url": "https://github.com/rust-lang/rust/commit/ffdc740446585502bd179cb608a033dd74a41e39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffdc740446585502bd179cb608a033dd74a41e39/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80f8e474a0c6a1cf477afc2141f9d6182f8b05a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/80f8e474a0c6a1cf477afc2141f9d6182f8b05a3", "html_url": "https://github.com/rust-lang/rust/commit/80f8e474a0c6a1cf477afc2141f9d6182f8b05a3"}], "stats": {"total": 72, "additions": 58, "deletions": 14}, "files": [{"sha": "96bc791eba8af82cb3573efc1ac83715c870927b", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 37, "deletions": 14, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ffdc740446585502bd179cb608a033dd74a41e39/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffdc740446585502bd179cb608a033dd74a41e39/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=ffdc740446585502bd179cb608a033dd74a41e39", "patch": "@@ -7,7 +7,10 @@ use hir_def::{\n     DefWithBodyId, TraitId,\n };\n use ra_db::{FileId, FileRange};\n-use ra_syntax::{ast, match_ast, AstNode, SyntaxNode, SyntaxToken, TextRange, TextUnit};\n+use ra_syntax::{\n+    algo::find_covering_element, ast, match_ast, AstNode, NodeOrToken, SyntaxElement, SyntaxNode,\n+    SyntaxToken, TextRange, TextUnit,\n+};\n use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::{\n@@ -333,10 +336,28 @@ impl<'a, DB: HirDatabase> SemanticsScope<'a, DB> {\n \n // FIXME: Change `HasSource` trait to work with `Semantics` and remove this?\n pub fn original_range(db: &impl HirDatabase, node: InFile<&SyntaxNode>) -> FileRange {\n-    if let Some((range, Origin::Call)) = original_range_and_origin(db, node) {\n-        return range;\n+    let mut elem: InFile<SyntaxElement> = node.map(|n| n.clone().into());\n+\n+    while let Some((range, Origin::Call)) = original_range_and_origin(db, elem.as_ref()) {\n+        let original_file = range.file_id.original_file(db);\n+\n+        if range.file_id == original_file.into() {\n+            return FileRange { file_id: original_file, range: range.value };\n+        }\n+\n+        // Fail to mapping up more, return the original file range instead\n+        if range.file_id != elem.file_id {\n+            if let Some(root) = db.parse_or_expand(range.file_id) {\n+                elem = range.with_value(find_covering_element(&root, range.value));\n+                continue;\n+            }\n+        }\n+\n+        log::error!(\"Fail to mapping up more for {:?}\", range);\n+        return FileRange { file_id: range.file_id.original_file(db), range: range.value };\n     }\n \n+    // Fall back to whole macro call\n     if let Some(expansion) = node.file_id.expansion_info(db) {\n         if let Some(call_node) = expansion.call_node() {\n             return FileRange {\n@@ -351,15 +372,22 @@ pub fn original_range(db: &impl HirDatabase, node: InFile<&SyntaxNode>) -> FileR\n \n fn original_range_and_origin(\n     db: &impl HirDatabase,\n-    node: InFile<&SyntaxNode>,\n-) -> Option<(FileRange, Origin)> {\n-    let expansion = node.file_id.expansion_info(db)?;\n+    elem: InFile<&SyntaxElement>,\n+) -> Option<(InFile<TextRange>, Origin)> {\n+    let expansion = elem.file_id.expansion_info(db)?;\n+\n+    let node = match elem.as_ref().value {\n+        NodeOrToken::Node(it) => elem.with_value(it),\n+        NodeOrToken::Token(it) => {\n+            let (tt, origin) = expansion.map_token_up(elem.with_value(it))?;\n+            return Some((tt.map(|it| it.text_range()), origin));\n+        }\n+    };\n \n     // the input node has only one token ?\n     let single = node.value.first_token()? == node.value.last_token()?;\n \n-    // FIXME: We should handle recurside macro expansions\n-    let (range, origin) = node.value.descendants().find_map(|it| {\n+    return Some(node.value.descendants().find_map(|it| {\n         let first = it.first_token()?;\n         let last = it.last_token()?;\n \n@@ -380,12 +408,7 @@ fn original_range_and_origin(\n             first.with_value(union_range(first.value.text_range(), last.value.text_range())),\n             first_origin,\n         ))\n-    })?;\n-\n-    return Some((\n-        FileRange { file_id: range.file_id.original_file(db), range: range.value },\n-        origin,\n-    ));\n+    })?);\n \n     fn union_range(a: TextRange, b: TextRange) -> TextRange {\n         let start = a.start().min(b.start());"}, {"sha": "29b16e602f9821bdc0f4dd64d830ffef8b6da773", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ffdc740446585502bd179cb608a033dd74a41e39/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffdc740446585502bd179cb608a033dd74a41e39/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=ffdc740446585502bd179cb608a033dd74a41e39", "patch": "@@ -753,6 +753,27 @@ fn func(foo: i32) { if true { <|>foo; }; }\n         assert_eq!(hover_on, \"bar\")\n     }\n \n+    #[test]\n+    fn test_hover_through_expr_in_macro_recursive() {\n+        let hover_on = check_hover_result(\n+            \"\n+            //- /lib.rs\n+            macro_rules! id_deep {\n+                ($($tt:tt)*) => { $($tt)* }\n+            }\n+            macro_rules! id {\n+                ($($tt:tt)*) => { id_deep!($($tt)*) }\n+            }\n+            fn foo(bar:u32) {\n+                let a = id!(ba<|>r);\n+            }\n+            \",\n+            &[\"u32\"],\n+        );\n+\n+        assert_eq!(hover_on, \"bar\")\n+    }\n+\n     #[test]\n     fn test_hover_non_ascii_space_doc() {\n         check_hover_result("}]}