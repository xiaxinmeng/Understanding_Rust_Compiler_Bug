{"sha": "a3f4a1b6adf9d5e8664f0dbccc62d425d1bab7b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzZjRhMWI2YWRmOWQ1ZTg2NjRmMGRiY2NjNjJkNDI1ZDFiYWI3YjE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-20T01:51:09Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-20T01:52:35Z"}, "message": "rt: Split out shapes into rust_shape.cpp and rust_shape.h so that shape code can be written outside of rust_shape.cpp", "tree": {"sha": "2136ad5a234cb19027f53aaf6e5b612824bbea2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2136ad5a234cb19027f53aaf6e5b612824bbea2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3f4a1b6adf9d5e8664f0dbccc62d425d1bab7b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3f4a1b6adf9d5e8664f0dbccc62d425d1bab7b1", "html_url": "https://github.com/rust-lang/rust/commit/a3f4a1b6adf9d5e8664f0dbccc62d425d1bab7b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3f4a1b6adf9d5e8664f0dbccc62d425d1bab7b1/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e417e78e2b9757931613d0587e5ca1b7fb9085f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e417e78e2b9757931613d0587e5ca1b7fb9085f1", "html_url": "https://github.com/rust-lang/rust/commit/e417e78e2b9757931613d0587e5ca1b7fb9085f1"}], "stats": {"total": 1872, "additions": 956, "deletions": 916}, "files": [{"sha": "aecb9254158f1cdbe0ad510cd8dd30202ea30cbf", "filename": "src/rt/rust_shape.cpp", "status": "modified", "additions": 1, "deletions": 916, "changes": 917, "blob_url": "https://github.com/rust-lang/rust/blob/a3f4a1b6adf9d5e8664f0dbccc62d425d1bab7b1/src%2Frt%2Frust_shape.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/a3f4a1b6adf9d5e8664f0dbccc62d425d1bab7b1/src%2Frt%2Frust_shape.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.cpp?ref=a3f4a1b6adf9d5e8664f0dbccc62d425d1bab7b1", "patch": "@@ -11,20 +11,7 @@\n #include <cstdio>\n #include <cstdlib>\n #include \"rust_internal.h\"\n-\n-#define ARENA_SIZE          256\n-\n-#define DPRINT(fmt,...)     fprintf(stderr, fmt, ##__VA_ARGS__)\n-#define DPRINTCX(cx)        print::print_cx(cx)\n-\n-//#define DPRINT(fmt,...)\n-//#define DPRINTCX(cx)\n-\n-#ifdef _MSC_VER\n-#define ALIGNOF     __alignof\n-#else\n-#define ALIGNOF     __alignof__\n-#endif\n+#include \"rust_shape.h\"\n \n namespace shape {\n \n@@ -39,150 +26,13 @@ struct type_param;\n \n // Constants\n \n-const uint8_t SHAPE_U8 = 0u;\n-const uint8_t SHAPE_U16 = 1u;\n-const uint8_t SHAPE_U32 = 2u;\n-const uint8_t SHAPE_U64 = 3u;\n-const uint8_t SHAPE_I8 = 4u;\n-const uint8_t SHAPE_I16 = 5u;\n-const uint8_t SHAPE_I32 = 6u;\n-const uint8_t SHAPE_I64 = 7u;\n-const uint8_t SHAPE_F32 = 8u;\n-const uint8_t SHAPE_F64 = 9u;\n-const uint8_t SHAPE_EVEC = 10u;\n-const uint8_t SHAPE_IVEC = 11u;\n-const uint8_t SHAPE_TAG = 12u;\n-const uint8_t SHAPE_BOX = 13u;\n-const uint8_t SHAPE_STRUCT = 17u;\n-const uint8_t SHAPE_FN = 18u;\n-const uint8_t SHAPE_OBJ = 19u;\n-const uint8_t SHAPE_RES = 20u;\n-const uint8_t SHAPE_VAR = 21u;\n-\n const uint8_t CMP_EQ = 0u;\n const uint8_t CMP_LT = 1u;\n const uint8_t CMP_LE = 2u;\n \n-\n-// Utility classes\n-\n-struct size_align {\n-    size_t size;\n-    size_t alignment;\n-\n-    size_align(size_t in_size = 0, size_t in_align = 1) :\n-        size(in_size), alignment(in_align) {}\n-\n-    bool is_set() const { return alignment != 0; }\n-\n-    inline void set(size_t in_size, size_t in_align) {\n-        size = in_size;\n-        alignment = in_align;\n-    }\n-\n-    inline void add(const size_align &other) {\n-        add(other.size, other.alignment);\n-    }\n-\n-    inline void add(size_t extra_size, size_t extra_align) {\n-        size += extra_size;\n-        alignment = max(alignment, extra_align);\n-    }\n-\n-    static inline size_align make(size_t in_size) {\n-        size_align sa;\n-        sa.size = sa.alignment = in_size;\n-        return sa;\n-    }\n-\n-    static inline size_align make(size_t in_size, size_t in_align) {\n-        size_align sa;\n-        sa.size = in_size;\n-        sa.alignment = in_align;\n-        return sa;\n-    }\n-};\n-\n-struct tag_info {\n-    uint16_t tag_id;                        // The tag ID.\n-    const uint8_t *info_ptr;                // Pointer to the info table.\n-    uint16_t variant_count;                 // Number of variants in the tag.\n-    const uint8_t *largest_variants_ptr;    // Ptr to largest variants table.\n-    size_align tag_sa;                      // Size and align of this tag.\n-    uint16_t n_params;                      // Number of type parameters.\n-    const type_param *params;               // Array of type parameters.\n-};\n-\n-\n-// Pointer pairs for structural comparison\n-\n-template<typename T>\n-class data_pair {\n-public:\n-    T fst, snd;\n-\n-    data_pair() {}\n-    data_pair(T &in_fst, T &in_snd) : fst(in_fst), snd(in_snd) {}\n-\n-    inline void operator=(const T rhs) { fst = snd = rhs; }\n-\n-    static data_pair<T> make(T &fst, T &snd) {\n-        data_pair<T> data(fst, snd);\n-        return data;\n-    }\n-};\n-\n-class ptr_pair {\n-public:\n-    uint8_t *fst, *snd;\n-\n-    template<typename T>\n-    struct data { typedef data_pair<T> t; };\n-\n-    ptr_pair(uint8_t *in_fst, uint8_t *in_snd) : fst(in_fst), snd(in_snd) {}\n-\n-    ptr_pair(data_pair<uint8_t *> &other) : fst(other.fst), snd(other.snd) {}\n-\n-    inline void operator=(uint8_t *rhs) { fst = snd = rhs; }\n-\n-    inline ptr_pair operator+(size_t n) const {\n-        return make(fst + n, snd + n);\n-    }\n-\n-    inline ptr_pair operator+=(size_t n) {\n-        fst += n; snd += n;\n-        return *this;\n-    }\n-\n-    inline ptr_pair operator-(size_t n) const {\n-        return make(fst - n, snd - n);\n-    }\n-\n-    inline bool operator<(const ptr_pair &other) const {\n-        return fst < other.fst && snd < other.snd;\n-    }\n-\n-    static inline ptr_pair make(uint8_t *fst, uint8_t *snd) {\n-        ptr_pair self(fst, snd);\n-        return self;\n-    }\n-\n-    static inline ptr_pair make(const data_pair<uint8_t *> &pair) {\n-        ptr_pair self(pair.fst, pair.snd);\n-        return self;\n-    }\n-};\n-\n }   // end namespace shape\n \n \n-inline shape::ptr_pair\n-align_to(const shape::ptr_pair &pair, size_t n) {\n-    return shape::ptr_pair::make(align_to(pair.fst, n),\n-                                 align_to(pair.snd, n));\n-}\n-\n-\n namespace shape {\n \n // NB: This function does not align.\n@@ -203,434 +53,8 @@ get_dp(ptr_pair &ptr) {\n     return data;\n }\n \n-// Pointer wrappers for data traversals\n-\n-class ptr {\n-private:\n-    uint8_t *p;\n-\n-public:\n-    template<typename T>\n-    struct data { typedef T t; };\n-\n-    ptr(uint8_t *in_p)\n-    : p(in_p) {}\n-\n-    ptr(uintptr_t in_p)\n-    : p((uint8_t *)in_p) {}\n-\n-    inline ptr operator+(const size_t amount) const {\n-        return make(p + amount);\n-    }\n-    inline ptr &operator+=(const size_t amount) { p += amount; return *this; }\n-    inline bool operator<(const ptr other) { return p < other.p; }\n-    inline ptr operator++() { ptr rv(*this); p++; return rv; }\n-    inline uint8_t operator*() { return *p; }\n-\n-    template<typename T>\n-    inline operator T *() { return (T *)p; }\n-\n-    inline operator uintptr_t() { return (uintptr_t)p; }\n-\n-    static inline ptr make(uint8_t *in_p) {\n-        ptr self(in_p);\n-        return self;\n-    }\n-};\n-\n-template<typename T>\n-static inline T\n-bump_dp(ptr &dp) {\n-    T x = *((T *)dp);\n-    dp += sizeof(T);\n-    return x;\n-}\n-\n-template<typename T>\n-static inline T\n-get_dp(ptr dp) {\n-    return *((T *)dp);\n-}\n-\n-\n-// Contexts\n-\n-// The base context, an abstract class. We use the curiously recurring\n-// template pattern here to avoid virtual dispatch.\n-template<typename T>\n-class ctxt {\n-public:\n-    const uint8_t *sp;                  // shape pointer\n-    const type_param *params;           // shapes of type parameters\n-    const rust_shape_tables *tables;\n-    rust_task *task;\n-\n-    ctxt(rust_task *in_task,\n-         const uint8_t *in_sp,\n-         const type_param *in_params,\n-         const rust_shape_tables *in_tables)\n-    : sp(in_sp), params(in_params), tables(in_tables), task(in_task) {}\n-\n-    template<typename U>\n-    ctxt(const ctxt<U> &other,\n-         const uint8_t *in_sp = NULL,\n-         const type_param *in_params = NULL,\n-         const rust_shape_tables *in_tables = NULL)\n-    : sp(in_sp ? in_sp : other.sp),\n-      params(in_params ? in_params : other.params),\n-      tables(in_tables ? in_tables : other.tables),\n-      task(other.task) {}\n-\n-    void walk(bool align);\n-    void walk_reset(bool align);\n-\n-    std::pair<const uint8_t *,const uint8_t *>\n-    get_variant_sp(tag_info &info, uint32_t variant_id);\n-\n-protected:\n-    inline uint8_t peek() { return *sp; }\n-\n-    static inline uint16_t get_u16(const uint8_t *addr);\n-    static inline uint16_t get_u16_bump(const uint8_t *&addr);\n-    inline size_align get_size_align(const uint8_t *&addr);\n-\n-private:\n-    void walk_evec(bool align);\n-    void walk_ivec(bool align);\n-    void walk_tag(bool align);\n-    void walk_box(bool align);\n-    void walk_struct(bool align);\n-    void walk_res(bool align);\n-    void walk_var(bool align);\n-};\n-\n-\n-struct rust_fn {\n-    void (*code)(uint8_t *rv, rust_task *task, void *env, ...);\n-    void *env;\n-};\n-\n-struct rust_closure {\n-    type_desc *tydesc;\n-    uint32_t target_0;\n-    uint32_t target_1;\n-    uint32_t bindings[0];\n-\n-    uint8_t *get_bindings() const { return (uint8_t *)bindings; }\n-};\n-\n-struct rust_obj_box {\n-    type_desc *tydesc;\n-\n-    uint8_t *get_bindings() const { return (uint8_t *)this; }\n-};\n-\n-struct rust_vtable {\n-    CDECL void (*dtor)(void *rv, rust_task *task, rust_obj obj);\n-};\n-\n-struct rust_obj {\n-    rust_vtable *vtable;\n-    void *box;\n-};\n-\n-\n-// Arenas; these functions must execute very quickly, so we use an arena\n-// instead of malloc or new.\n-\n-class arena {\n-    uint8_t *ptr;\n-    uint8_t data[ARENA_SIZE];\n-\n-public:\n-    arena() : ptr(data) {}\n-\n-    template<typename T>\n-    inline T *alloc(size_t count = 1) {\n-        // FIXME: align\n-        size_t sz = count * sizeof(T);\n-        T *rv = (T *)ptr;\n-        ptr += sz;\n-        if (ptr > &data[ARENA_SIZE]) {\n-            fprintf(stderr, \"Arena space exhausted, sorry\\n\");\n-            abort();\n-        }\n-        return rv;\n-    }\n-};\n-\n-\n-// Type parameters\n-\n-struct type_param {\n-    const uint8_t *shape;\n-    const rust_shape_tables *tables;\n-    const struct type_param *params;    // subparameters\n-\n-    template<typename T>\n-    inline void set(ctxt<T> *cx) {\n-        shape = cx->sp;\n-        tables = cx->tables;\n-        params = cx->params;\n-    }\n-\n-    static type_param *make(const type_desc *tydesc, arena &arena) {\n-        uint32_t n_params = tydesc->n_params;\n-        if (!n_params)\n-            return NULL;\n-\n-        type_param *ptrs = arena.alloc<type_param>(n_params);\n-        for (uint32_t i = 0; i < n_params; i++) {\n-            const type_desc *subtydesc = tydesc->first_param[i];\n-            ptrs[i].shape = subtydesc->shape;\n-            ptrs[i].tables = subtydesc->shape_tables;\n-            ptrs[i].params = make(subtydesc, arena);\n-        }\n-        return ptrs;\n-    }\n-};\n-\n-\n-// Traversals\n-\n-#define WALK_NUMBER(c_type) \\\n-    static_cast<T *>(this)->template walk_number<c_type>(align)\n-#define WALK_SIMPLE(method) static_cast<T *>(this)->method(align)\n-\n-template<typename T>\n-void\n-ctxt<T>::walk(bool align) {\n-    switch (*sp++) {\n-    case SHAPE_U8:      WALK_NUMBER(uint8_t);   break;\n-    case SHAPE_U16:     WALK_NUMBER(uint16_t);  break;\n-    case SHAPE_U32:     WALK_NUMBER(uint32_t);  break;\n-    case SHAPE_U64:     WALK_NUMBER(uint64_t);  break;\n-    case SHAPE_I8:      WALK_NUMBER(int8_t);    break;\n-    case SHAPE_I16:     WALK_NUMBER(int16_t);   break;\n-    case SHAPE_I32:     WALK_NUMBER(int32_t);   break;\n-    case SHAPE_I64:     WALK_NUMBER(int64_t);   break;\n-    case SHAPE_F32:     WALK_NUMBER(float);     break;\n-    case SHAPE_F64:     WALK_NUMBER(double);    break;\n-    case SHAPE_EVEC:    walk_evec(align);       break;\n-    case SHAPE_IVEC:    walk_ivec(align);       break;\n-    case SHAPE_TAG:     walk_tag(align);        break;\n-    case SHAPE_BOX:     walk_box(align);        break;\n-    case SHAPE_STRUCT:  walk_struct(align);     break;\n-    case SHAPE_FN:      WALK_SIMPLE(walk_fn);   break;\n-    case SHAPE_OBJ:     WALK_SIMPLE(walk_obj);  break;\n-    case SHAPE_RES:     walk_res(align);        break;\n-    case SHAPE_VAR:     walk_var(align);        break;\n-    default:            abort();\n-    }\n-}\n-\n-template<typename T>\n-void\n-ctxt<T>::walk_reset(bool align) {\n-    const uint8_t *old_sp = sp;\n-    walk(align);\n-    sp = old_sp;\n-}\n-\n-template<typename T>\n-uint16_t\n-ctxt<T>::get_u16(const uint8_t *addr) {\n-    return *reinterpret_cast<const uint16_t *>(addr);\n-}\n-\n-template<typename T>\n-uint16_t\n-ctxt<T>::get_u16_bump(const uint8_t *&addr) {\n-    uint16_t result = get_u16(addr);\n-    addr += sizeof(uint16_t);\n-    return result;\n-}\n-\n-template<typename T>\n-size_align\n-ctxt<T>::get_size_align(const uint8_t *&addr) {\n-    size_align result;\n-    result.size = get_u16_bump(addr);\n-    result.alignment = *addr++;\n-    return result;\n-}\n-\n-// Returns a pointer to the beginning and a pointer to the end of the shape of\n-// the tag variant with the given ID.\n-template<typename T>\n-std::pair<const uint8_t *,const uint8_t *>\n-ctxt<T>::get_variant_sp(tag_info &tinfo, uint32_t variant_id) {\n-    uint16_t variant_offset = get_u16(tinfo.info_ptr +\n-                                      variant_id * sizeof(uint16_t));\n-    const uint8_t *variant_ptr = tables->tags + variant_offset;\n-    uint16_t variant_len = get_u16_bump(variant_ptr);\n-    const uint8_t *variant_end = variant_ptr + variant_len;\n-    return std::make_pair(variant_ptr, variant_end);\n-}\n-\n-template<typename T>\n-void\n-ctxt<T>::walk_evec(bool align) {\n-    bool is_pod = *sp++;\n-\n-    uint16_t sp_size = get_u16_bump(sp);\n-    const uint8_t *end_sp = sp + sp_size;\n-\n-    static_cast<T *>(this)->walk_evec(align, is_pod, sp_size);\n-\n-    sp = end_sp;\n-}\n-\n-template<typename T>\n-void\n-ctxt<T>::walk_ivec(bool align) {\n-    bool is_pod = *sp++;\n-    size_align elem_sa = get_size_align(sp);\n-\n-    uint16_t sp_size = get_u16_bump(sp);\n-    const uint8_t *end_sp = sp + sp_size;\n-\n-    // FIXME: Hack to work around our incorrect alignment in some cases.\n-    if (elem_sa.alignment == 8)\n-        elem_sa.alignment = 4;\n-\n-    static_cast<T *>(this)->walk_ivec(align, is_pod, elem_sa);\n-\n-    sp = end_sp;\n-}\n-\n-template<typename T>\n-void\n-ctxt<T>::walk_tag(bool align) {\n-    tag_info tinfo;\n-    tinfo.tag_id = get_u16_bump(sp);\n-\n-    // Determine the info pointer.\n-    uint16_t info_offset = get_u16(tables->tags +\n-                                   tinfo.tag_id * sizeof(uint16_t));\n-    tinfo.info_ptr = tables->tags + info_offset;\n-\n-    tinfo.variant_count = get_u16_bump(tinfo.info_ptr);\n-\n-    // Determine the largest-variants pointer.\n-    uint16_t largest_variants_offset = get_u16_bump(tinfo.info_ptr);\n-    tinfo.largest_variants_ptr = tables->tags + largest_variants_offset;\n-\n-    // Determine the size and alignment.\n-    tinfo.tag_sa = get_size_align(tinfo.info_ptr);\n-\n-    // Determine the number of parameters.\n-    tinfo.n_params = get_u16_bump(sp);\n-\n-    // Read in the tag type parameters.\n-    type_param params[tinfo.n_params];\n-    for (uint16_t i = 0; i < tinfo.n_params; i++) {\n-        uint16_t len = get_u16_bump(sp);\n-        params[i].set(this);\n-        sp += len;\n-    }\n-\n-    tinfo.params = params;\n-\n-    // Call to the implementation.\n-    static_cast<T *>(this)->walk_tag(align, tinfo);\n-}\n-\n-template<typename T>\n-void\n-ctxt<T>::walk_box(bool align) {\n-    uint16_t sp_size = get_u16_bump(sp);\n-    const uint8_t *end_sp = sp + sp_size;\n-\n-    static_cast<T *>(this)->walk_box(align);\n-\n-    sp = end_sp;\n-}\n-\n-template<typename T>\n-void\n-ctxt<T>::walk_struct(bool align) {\n-    uint16_t sp_size = get_u16_bump(sp);\n-    const uint8_t *end_sp = sp + sp_size;\n-\n-    static_cast<T *>(this)->walk_struct(align, end_sp);\n-\n-    sp = end_sp;\n-}\n-\n-template<typename T>\n-void\n-ctxt<T>::walk_res(bool align) {\n-    uint16_t dtor_offset = get_u16_bump(sp);\n-    const rust_fn **resources =\n-        reinterpret_cast<const rust_fn **>(tables->resources);\n-    const rust_fn *dtor = resources[dtor_offset];\n-\n-    uint16_t n_ty_params = get_u16_bump(sp);\n-\n-    uint16_t ty_params_size = get_u16_bump(sp);\n-    const uint8_t *ty_params_sp = sp;\n-    sp += ty_params_size;\n-\n-    uint16_t sp_size = get_u16_bump(sp);\n-    const uint8_t *end_sp = sp + sp_size;\n-\n-    static_cast<T *>(this)->walk_res(align, dtor, n_ty_params, ty_params_sp);\n-\n-    sp = end_sp;\n-}\n-\n-template<typename T>\n-void\n-ctxt<T>::walk_var(bool align) {\n-    uint8_t param = *sp++;\n-    static_cast<T *>(this)->walk_var(align, param);\n-}\n-\n-\n // A shape printer, useful for debugging\n \n-class print : public ctxt<print> {\n-public:\n-    template<typename T>\n-    print(const ctxt<T> &other,\n-          const uint8_t *in_sp = NULL,\n-          const type_param *in_params = NULL,\n-          const rust_shape_tables *in_tables = NULL)\n-    : ctxt<print>(other, in_sp, in_params, in_tables) {}\n-\n-    void walk_tag(bool align, tag_info &tinfo);\n-    void walk_struct(bool align, const uint8_t *end_sp);\n-    void walk_res(bool align, const rust_fn *dtor, uint16_t n_ty_params,\n-                  const uint8_t *ty_params_sp);\n-    void walk_var(bool align, uint8_t param);\n-\n-    void walk_evec(bool align, bool is_pod, uint16_t sp_size) {\n-        DPRINT(\"evec<\"); walk(align); DPRINT(\">\");\n-    }\n-    void walk_ivec(bool align, bool is_pod, size_align &elem_sa) {\n-        DPRINT(\"ivec<\"); walk(align); DPRINT(\">\");\n-    }\n-    void walk_box(bool align) {\n-        DPRINT(\"box<\"); walk(align); DPRINT(\">\");\n-    }\n-\n-    void walk_port(bool align)                  { DPRINT(\"port\"); }\n-    void walk_chan(bool align)                  { DPRINT(\"chan\"); }\n-    void walk_task(bool align)                  { DPRINT(\"task\"); }\n-    void walk_fn(bool align)                    { DPRINT(\"fn\");   }\n-    void walk_obj(bool align)                   { DPRINT(\"obj\");  }\n-\n-    template<typename T>\n-    void walk_number(bool align) {}\n-\n-    template<typename T>\n-    static void print_cx(const T *cx) {\n-        print self(*cx);\n-        self.walk(false);\n-    }\n-};\n-\n void\n print::walk_tag(bool align, tag_info &tinfo) {\n     DPRINT(\"tag%u\", tinfo.tag_id);\n@@ -720,78 +144,6 @@ template<>\n void print::walk_number<double>(bool align)     { DPRINT(\"f64\"); }\n \n \n-//\n-// Size-of (which also computes alignment). Be warned: this is an expensive\n-// operation.\n-//\n-// TODO: Maybe dynamic_size_of() should call into this somehow?\n-//\n-\n-class size_of : public ctxt<size_of> {\n-private:\n-    size_align sa;\n-\n-public:\n-    size_of(const size_of &other,\n-            const uint8_t *in_sp = NULL,\n-            const type_param *in_params = NULL,\n-            const rust_shape_tables *in_tables = NULL)\n-    : ctxt<size_of>(other, in_sp, in_params, in_tables) {}\n-\n-    template<typename T>\n-    size_of(const ctxt<T> &other,\n-            const uint8_t *in_sp = NULL,\n-            const type_param *in_params = NULL,\n-            const rust_shape_tables *in_tables = NULL)\n-    : ctxt<size_of>(other, in_sp, in_params, in_tables) {}\n-\n-    void walk_tag(bool align, tag_info &tinfo);\n-    void walk_struct(bool align, const uint8_t *end_sp);\n-    void walk_ivec(bool align, bool is_pod, size_align &elem_sa);\n-\n-    void walk_box(bool align)   { sa.set(sizeof(void *),   sizeof(void *)); }\n-    void walk_port(bool align)  { sa.set(sizeof(void *),   sizeof(void *)); }\n-    void walk_chan(bool align)  { sa.set(sizeof(void *),   sizeof(void *)); }\n-    void walk_task(bool align)  { sa.set(sizeof(void *),   sizeof(void *)); }\n-    void walk_fn(bool align)    { sa.set(sizeof(void *)*2, sizeof(void *)); }\n-    void walk_obj(bool align)   { sa.set(sizeof(void *)*2, sizeof(void *)); }\n-\n-    void walk_evec(bool align, bool is_pod, uint16_t sp_size) {\n-        sa.set(sizeof(void *), sizeof(void *));\n-    }\n-\n-    void walk_var(bool align, uint8_t param_index) {\n-        const type_param *param = &params[param_index];\n-        size_of sub(*this, param->shape, param->params, param->tables);\n-        sub.walk(align);\n-        sa = sub.sa;\n-    }\n-\n-    void walk_res(bool align, const rust_fn *dtor, uint16_t n_ty_params,\n-                  const uint8_t *ty_params_sp) {\n-        abort();    // TODO\n-    }\n-\n-    template<typename T>\n-    void walk_number(bool align) { sa.set(sizeof(T), ALIGNOF(T)); }\n-\n-    void compute_tag_size(tag_info &tinfo);\n-\n-    template<typename T>\n-    static void compute_tag_size(const ctxt<T> &other_cx, tag_info &tinfo) {\n-        size_of cx(other_cx);\n-        cx.compute_tag_size(tinfo);\n-    }\n-\n-    template<typename T>\n-    static size_align get(const ctxt<T> &other_cx, unsigned back_up = 0) {\n-        size_of cx(other_cx, other_cx.sp - back_up);\n-        cx.walk(false);\n-        assert(cx.sa.alignment > 0);\n-        return cx.sa;\n-    }\n-};\n-\n void\n size_of::compute_tag_size(tag_info &tinfo) {\n     // If the precalculated size and alignment are good, use them.\n@@ -869,194 +221,6 @@ size_of::walk_ivec(bool align, bool is_pod, size_align &elem_sa) {\n }\n \n \n-// An abstract class (again using the curiously recurring template pattern)\n-// for methods that actually manipulate the data involved.\n-\n-#define DATA_SIMPLE(ty, call) \\\n-    if (align) dp = align_to(dp, sizeof(ty)); \\\n-    U end_dp = dp + sizeof(ty); \\\n-    static_cast<T *>(this)->call; \\\n-    dp = end_dp;\n-\n-template<typename T,typename U>\n-class data : public ctxt< data<T,U> > {\n-protected:\n-    void walk_box_contents(bool align);\n-    void walk_variant(bool align, tag_info &tinfo, uint32_t variant);\n-\n-    static std::pair<uint8_t *,uint8_t *> get_evec_data_range(ptr dp);\n-    static std::pair<uint8_t *,uint8_t *> get_ivec_data_range(ptr dp);\n-    static std::pair<ptr_pair,ptr_pair> get_evec_data_range(ptr_pair &dp);\n-    static std::pair<ptr_pair,ptr_pair> get_ivec_data_range(ptr_pair &dp);\n-\n-public:\n-    U dp;\n-\n-    data(rust_task *in_task,\n-         const uint8_t *in_sp,\n-         const type_param *in_params,\n-         const rust_shape_tables *in_tables,\n-         U const &in_dp)\n-    : ctxt< data<T,U> >(in_task, in_sp, in_params, in_tables), dp(in_dp) {}\n-\n-    void walk_tag(bool align, tag_info &tinfo);\n-    void walk_ivec(bool align, bool is_pod, size_align &elem_sa);\n-\n-    void walk_struct(bool align, const uint8_t *end_sp) {\n-        static_cast<T *>(this)->walk_struct(align, end_sp);\n-    }\n-\n-    void walk_evec(bool align, bool is_pod, uint16_t sp_size) {\n-        DATA_SIMPLE(void *, walk_evec(align, is_pod, sp_size));\n-    }\n-\n-    void walk_box(bool align)   { DATA_SIMPLE(void *, walk_box(align)); }\n-    void walk_port(bool align)  { DATA_SIMPLE(void *, walk_port(align)); }\n-    void walk_chan(bool align)  { DATA_SIMPLE(void *, walk_chan(align)); }\n-    void walk_task(bool align)  { DATA_SIMPLE(void *, walk_task(align)); }\n-\n-    void walk_fn(bool align) {\n-        if (align) dp = align_to(dp, sizeof(void *));\n-        static_cast<T *>(this)->walk_fn(align);\n-        dp += sizeof(void *) * 2;\n-    }\n-\n-    void walk_obj(bool align) {\n-        if (align) dp = align_to(dp, sizeof(void *));\n-        static_cast<T *>(this)->walk_obj(align);\n-        dp += sizeof(void *) * 2;\n-    }\n-\n-    void walk_res(bool align, const rust_fn *dtor, uint16_t n_ty_params,\n-                  const uint8_t *ty_params_sp) {\n-        // Delegate to the implementation.\n-        static_cast<T *>(this)->walk_res(align, dtor, n_ty_params,\n-                                         ty_params_sp);\n-    }\n-\n-    void walk_var(bool align, uint8_t param_index) {\n-        const type_param *param = &this->params[param_index];\n-        T sub(*static_cast<T *>(this), param->shape, param->params,\n-              param->tables);\n-        static_cast<T *>(this)->walk_subcontext(align, sub);\n-        dp = sub.dp;\n-    }\n-\n-    template<typename W>\n-    void walk_number(bool align) { DATA_SIMPLE(W, walk_number<W>()); }\n-};\n-\n-template<typename T,typename U>\n-void\n-data<T,U>::walk_box_contents(bool align) {\n-    typename U::template data<uint8_t *>::t box_ptr = bump_dp<uint8_t *>(dp);\n-\n-    U ref_count_dp(box_ptr);\n-    T sub(*static_cast<T *>(this), ref_count_dp + sizeof(uint32_t));\n-    static_cast<T *>(this)->walk_box_contents(align, sub, ref_count_dp);\n-}\n-\n-template<typename T,typename U>\n-void\n-data<T,U>::walk_variant(bool align, tag_info &tinfo, uint32_t variant_id) {\n-    std::pair<const uint8_t *,const uint8_t *> variant_ptr_and_end =\n-        this->get_variant_sp(tinfo, variant_id);\n-    static_cast<T *>(this)->walk_variant(align, tinfo, variant_id,\n-                                         variant_ptr_and_end);\n-}\n-\n-template<typename T,typename U>\n-std::pair<uint8_t *,uint8_t *>\n-data<T,U>::get_evec_data_range(ptr dp) {\n-    rust_evec *vp = bump_dp<rust_evec *>(dp);\n-    return std::make_pair(vp->data, vp->data + vp->fill);\n-}\n-\n-template<typename T,typename U>\n-std::pair<uint8_t *,uint8_t *>\n-data<T,U>::get_ivec_data_range(ptr dp) {\n-    size_t fill = bump_dp<size_t>(dp);\n-    bump_dp<size_t>(dp);    // Skip over alloc.\n-    uint8_t *payload_dp = dp;\n-    rust_ivec_payload payload = bump_dp<rust_ivec_payload>(dp);\n-\n-    uint8_t *start, *end;\n-    if (!fill) {\n-        if (!payload.ptr) {             // Zero length.\n-            start = end = NULL;\n-        } else {                        // On heap.\n-            fill = payload.ptr->fill;\n-            start = payload.ptr->data;\n-            end = start + fill;\n-        }\n-    } else {                            // On stack.\n-        start = payload_dp;\n-        end = start + fill;\n-    }\n-\n-    return std::make_pair(start, end);\n-}\n-\n-template<typename T,typename U>\n-std::pair<ptr_pair,ptr_pair>\n-data<T,U>::get_evec_data_range(ptr_pair &dp) {\n-    std::pair<uint8_t *,uint8_t *> fst = get_evec_data_range(dp.fst);\n-    std::pair<uint8_t *,uint8_t *> snd = get_evec_data_range(dp.snd);\n-    ptr_pair start(fst.first, snd.first);\n-    ptr_pair end(fst.second, snd.second);\n-    return std::make_pair(start, end);\n-}\n-\n-template<typename T,typename U>\n-std::pair<ptr_pair,ptr_pair>\n-data<T,U>::get_ivec_data_range(ptr_pair &dp) {\n-    std::pair<uint8_t *,uint8_t *> fst = get_ivec_data_range(dp.fst);\n-    std::pair<uint8_t *,uint8_t *> snd = get_ivec_data_range(dp.snd);\n-    ptr_pair start(fst.first, snd.first);\n-    ptr_pair end(fst.second, snd.second);\n-    return std::make_pair(start, end);\n-}\n-\n-template<typename T,typename U>\n-void\n-data<T,U>::walk_ivec(bool align, bool is_pod, size_align &elem_sa) {\n-    if (!elem_sa.is_set())\n-        elem_sa = size_of::get(*this);\n-    else if (elem_sa.alignment == 8)\n-        elem_sa.alignment = 4;  // FIXME: This is an awful hack.\n-\n-    // Get a pointer to the interior vector, and determine its size.\n-    if (align) dp = align_to(dp, ALIGNOF(rust_ivec *));\n-    U end_dp = dp + sizeof(rust_ivec) - sizeof(uintptr_t) + elem_sa.size * 4;\n-\n-    // Call to the implementation.\n-    static_cast<T *>(this)->walk_ivec(align, is_pod, elem_sa);\n-\n-    dp = end_dp;\n-}\n-\n-template<typename T,typename U>\n-void\n-data<T,U>::walk_tag(bool align, tag_info &tinfo) {\n-    size_of::compute_tag_size(*this, tinfo);\n-\n-    if (tinfo.variant_count > 1 && align)\n-        dp = align_to(dp, ALIGNOF(uint32_t));\n-\n-    U end_dp = dp + tinfo.tag_sa.size;\n-\n-    typename U::template data<uint32_t>::t tag_variant;\n-    if (tinfo.variant_count > 1)\n-        tag_variant = bump_dp<uint32_t>(dp);\n-    else\n-        tag_variant = 0;\n-\n-    static_cast<T *>(this)->walk_tag(align, tinfo, tag_variant);\n-\n-    dp = end_dp;\n-}\n-\n-\n // Copy constructors\n \n #if 0\n@@ -1231,85 +395,6 @@ cmp::walk_variant(bool align, tag_info &tinfo, uint32_t variant_id,\n \n // Polymorphic logging, for convenience\n \n-class log : public data<log,ptr> {\n-    friend class data<log,ptr>;\n-\n-private:\n-    std::ostream &out;\n-    bool in_string;\n-\n-    log(log &other,\n-        const uint8_t *in_sp,\n-        const type_param *in_params,\n-        const rust_shape_tables *in_tables = NULL)\n-    : data<log,ptr>(other.task,\n-                    in_sp,\n-                    in_params,\n-                    in_tables ? in_tables : other.tables,\n-                    other.dp),\n-      out(other.out) {}\n-\n-    log(log &other, ptr in_dp)\n-    : data<log,ptr>(other.task, other.sp, other.params, other.tables, in_dp),\n-      out(other.out) {}\n-\n-    void walk_string(const std::pair<ptr,ptr> &data);\n-\n-    void walk_evec(bool align, bool is_pod, uint16_t sp_size) {\n-        walk_vec(align, is_pod, get_evec_data_range(dp));\n-    }\n-\n-    void walk_ivec(bool align, bool is_pod, size_align &elem_sa) {\n-        walk_vec(align, is_pod, get_ivec_data_range(dp));\n-    }\n-\n-    void walk_tag(bool align, tag_info &tinfo, uint32_t tag_variant) {\n-        out << \"tag\" << tag_variant;\n-        data<log,ptr>::walk_variant(align, tinfo, tag_variant);\n-    }\n-\n-    void walk_box(bool align) {\n-        out << \"@\";\n-        data<log,ptr>::walk_box_contents(align);\n-    }\n-\n-    void walk_fn(bool align) { out << \"fn\"; }\n-    void walk_obj(bool align) { out << \"obj\"; }\n-    void walk_port(bool align) { out << \"port\"; }\n-    void walk_chan(bool align) { out << \"chan\"; }\n-    void walk_task(bool align) { out << \"task\"; }\n-\n-    void walk_res(bool align, const rust_fn *dtor, uint16_t n_ty_params,\n-                  const uint8_t *ty_params_sp) {\n-        out << \"res\";   // TODO\n-    }\n-\n-    void walk_subcontext(bool align, log &sub) { sub.walk(align); }\n-\n-    void walk_box_contents(bool align, log &sub, ptr &ref_count_dp) {\n-        sub.walk(true);\n-    }\n-\n-    void walk_struct(bool align, const uint8_t *end_sp);\n-    void walk_vec(bool align, bool is_pod, const std::pair<ptr,ptr> &data);\n-    void walk_variant(bool align, tag_info &tinfo, uint32_t variant_id,\n-                      const std::pair<const uint8_t *,const uint8_t *>\n-                      variant_ptr_and_end);\n-\n-    template<typename T>\n-    void walk_number() { out << get_dp<T>(dp); }\n-\n-public:\n-    log(rust_task *in_task,\n-        const uint8_t *in_sp,\n-        const type_param *in_params,\n-        const rust_shape_tables *in_tables,\n-        uint8_t *in_data,\n-        std::ostream &in_out)\n-    : data<log,ptr>(in_task, in_sp, in_params, in_tables, in_data),\n-      out(in_out) {}\n-};\n-\n void\n log::walk_string(const std::pair<ptr,ptr> &data) {\n     out << \"\\\"\" << std::hex;"}, {"sha": "d0e72005a34637170d26322388cd54ee3daaae7e", "filename": "src/rt/rust_shape.h", "status": "added", "additions": 955, "deletions": 0, "changes": 955, "blob_url": "https://github.com/rust-lang/rust/blob/a3f4a1b6adf9d5e8664f0dbccc62d425d1bab7b1/src%2Frt%2Frust_shape.h", "raw_url": "https://github.com/rust-lang/rust/raw/a3f4a1b6adf9d5e8664f0dbccc62d425d1bab7b1/src%2Frt%2Frust_shape.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.h?ref=a3f4a1b6adf9d5e8664f0dbccc62d425d1bab7b1", "patch": "@@ -0,0 +1,955 @@\n+// Functions that interpret the shape of a type to perform various low-level\n+// actions, such as copying, freeing, comparing, and so on.\n+\n+#ifndef RUST_SHAPE_H\n+#define RUST_SHAPE_H\n+\n+#include \"rust_internal.h\"\n+\n+#ifdef _MSC_VER\n+#define ALIGNOF     __alignof\n+#else\n+#define ALIGNOF     __alignof__\n+#endif\n+\n+#define ARENA_SIZE          256\n+\n+#define DPRINT(fmt,...)     fprintf(stderr, fmt, ##__VA_ARGS__)\n+#define DPRINTCX(cx)        print::print_cx(cx)\n+\n+//#define DPRINT(fmt,...)\n+//#define DPRINTCX(cx)\n+\n+\n+namespace shape {\n+\n+\n+// Constants\n+\n+const uint8_t SHAPE_U8 = 0u;\n+const uint8_t SHAPE_U16 = 1u;\n+const uint8_t SHAPE_U32 = 2u;\n+const uint8_t SHAPE_U64 = 3u;\n+const uint8_t SHAPE_I8 = 4u;\n+const uint8_t SHAPE_I16 = 5u;\n+const uint8_t SHAPE_I32 = 6u;\n+const uint8_t SHAPE_I64 = 7u;\n+const uint8_t SHAPE_F32 = 8u;\n+const uint8_t SHAPE_F64 = 9u;\n+const uint8_t SHAPE_EVEC = 10u;\n+const uint8_t SHAPE_IVEC = 11u;\n+const uint8_t SHAPE_TAG = 12u;\n+const uint8_t SHAPE_BOX = 13u;\n+const uint8_t SHAPE_STRUCT = 17u;\n+const uint8_t SHAPE_FN = 18u;\n+const uint8_t SHAPE_OBJ = 19u;\n+const uint8_t SHAPE_RES = 20u;\n+const uint8_t SHAPE_VAR = 21u;\n+\n+\n+// Forward declarations\n+\n+struct rust_obj;\n+struct size_align;\n+struct type_param;\n+\n+\n+// Arenas; these functions must execute very quickly, so we use an arena\n+// instead of malloc or new.\n+\n+class arena {\n+    uint8_t *ptr;\n+    uint8_t data[ARENA_SIZE];\n+\n+public:\n+    arena() : ptr(data) {}\n+\n+    template<typename T>\n+    inline T *alloc(size_t count = 1) {\n+        // FIXME: align\n+        size_t sz = count * sizeof(T);\n+        T *rv = (T *)ptr;\n+        ptr += sz;\n+        if (ptr > &data[ARENA_SIZE]) {\n+            fprintf(stderr, \"Arena space exhausted, sorry\\n\");\n+            abort();\n+        }\n+        return rv;\n+    }\n+};\n+\n+\n+// Utility classes\n+\n+struct size_align {\n+    size_t size;\n+    size_t alignment;\n+\n+    size_align(size_t in_size = 0, size_t in_align = 1) :\n+        size(in_size), alignment(in_align) {}\n+\n+    bool is_set() const { return alignment != 0; }\n+\n+    inline void set(size_t in_size, size_t in_align) {\n+        size = in_size;\n+        alignment = in_align;\n+    }\n+\n+    inline void add(const size_align &other) {\n+        add(other.size, other.alignment);\n+    }\n+\n+    inline void add(size_t extra_size, size_t extra_align) {\n+        size += extra_size;\n+        alignment = max(alignment, extra_align);\n+    }\n+\n+    static inline size_align make(size_t in_size) {\n+        size_align sa;\n+        sa.size = sa.alignment = in_size;\n+        return sa;\n+    }\n+\n+    static inline size_align make(size_t in_size, size_t in_align) {\n+        size_align sa;\n+        sa.size = in_size;\n+        sa.alignment = in_align;\n+        return sa;\n+    }\n+};\n+\n+struct tag_info {\n+    uint16_t tag_id;                        // The tag ID.\n+    const uint8_t *info_ptr;                // Pointer to the info table.\n+    uint16_t variant_count;                 // Number of variants in the tag.\n+    const uint8_t *largest_variants_ptr;    // Ptr to largest variants table.\n+    size_align tag_sa;                      // Size and align of this tag.\n+    uint16_t n_params;                      // Number of type parameters.\n+    const type_param *params;               // Array of type parameters.\n+};\n+\n+\n+// Contexts\n+\n+// The base context, an abstract class. We use the curiously recurring\n+// template pattern here to avoid virtual dispatch.\n+template<typename T>\n+class ctxt {\n+public:\n+    const uint8_t *sp;                  // shape pointer\n+    const type_param *params;           // shapes of type parameters\n+    const rust_shape_tables *tables;\n+    rust_task *task;\n+\n+    ctxt(rust_task *in_task,\n+         const uint8_t *in_sp,\n+         const type_param *in_params,\n+         const rust_shape_tables *in_tables)\n+    : sp(in_sp), params(in_params), tables(in_tables), task(in_task) {}\n+\n+    template<typename U>\n+    ctxt(const ctxt<U> &other,\n+         const uint8_t *in_sp = NULL,\n+         const type_param *in_params = NULL,\n+         const rust_shape_tables *in_tables = NULL)\n+    : sp(in_sp ? in_sp : other.sp),\n+      params(in_params ? in_params : other.params),\n+      tables(in_tables ? in_tables : other.tables),\n+      task(other.task) {}\n+\n+    void walk(bool align);\n+    void walk_reset(bool align);\n+\n+    std::pair<const uint8_t *,const uint8_t *>\n+    get_variant_sp(tag_info &info, uint32_t variant_id);\n+\n+protected:\n+    inline uint8_t peek() { return *sp; }\n+\n+    static inline uint16_t get_u16(const uint8_t *addr);\n+    static inline uint16_t get_u16_bump(const uint8_t *&addr);\n+    inline size_align get_size_align(const uint8_t *&addr);\n+\n+private:\n+    void walk_evec(bool align);\n+    void walk_ivec(bool align);\n+    void walk_tag(bool align);\n+    void walk_box(bool align);\n+    void walk_struct(bool align);\n+    void walk_res(bool align);\n+    void walk_var(bool align);\n+};\n+\n+\n+// Core Rust types\n+\n+struct rust_fn {\n+    void (*code)(uint8_t *rv, rust_task *task, void *env, ...);\n+    void *env;\n+};\n+\n+struct rust_closure {\n+    type_desc *tydesc;\n+    uint32_t target_0;\n+    uint32_t target_1;\n+    uint32_t bindings[0];\n+\n+    uint8_t *get_bindings() const { return (uint8_t *)bindings; }\n+};\n+\n+struct rust_obj_box {\n+    type_desc *tydesc;\n+\n+    uint8_t *get_bindings() const { return (uint8_t *)this; }\n+};\n+\n+struct rust_vtable {\n+    CDECL void (*dtor)(void *rv, rust_task *task, rust_obj obj);\n+};\n+\n+struct rust_obj {\n+    rust_vtable *vtable;\n+    void *box;\n+};\n+\n+\n+// Type parameters\n+\n+struct type_param {\n+    const uint8_t *shape;\n+    const rust_shape_tables *tables;\n+    const struct type_param *params;    // subparameters\n+\n+    template<typename T>\n+    inline void set(ctxt<T> *cx) {\n+        shape = cx->sp;\n+        tables = cx->tables;\n+        params = cx->params;\n+    }\n+\n+    static type_param *make(const type_desc *tydesc, arena &arena) {\n+        uint32_t n_params = tydesc->n_params;\n+        if (!n_params)\n+            return NULL;\n+\n+        type_param *ptrs = arena.alloc<type_param>(n_params);\n+        for (uint32_t i = 0; i < n_params; i++) {\n+            const type_desc *subtydesc = tydesc->first_param[i];\n+            ptrs[i].shape = subtydesc->shape;\n+            ptrs[i].tables = subtydesc->shape_tables;\n+            ptrs[i].params = make(subtydesc, arena);\n+        }\n+        return ptrs;\n+    }\n+};\n+\n+\n+// Traversals\n+\n+#define WALK_NUMBER(c_type) \\\n+    static_cast<T *>(this)->template walk_number<c_type>(align)\n+#define WALK_SIMPLE(method) static_cast<T *>(this)->method(align)\n+\n+template<typename T>\n+void\n+ctxt<T>::walk(bool align) {\n+    switch (*sp++) {\n+    case SHAPE_U8:      WALK_NUMBER(uint8_t);   break;\n+    case SHAPE_U16:     WALK_NUMBER(uint16_t);  break;\n+    case SHAPE_U32:     WALK_NUMBER(uint32_t);  break;\n+    case SHAPE_U64:     WALK_NUMBER(uint64_t);  break;\n+    case SHAPE_I8:      WALK_NUMBER(int8_t);    break;\n+    case SHAPE_I16:     WALK_NUMBER(int16_t);   break;\n+    case SHAPE_I32:     WALK_NUMBER(int32_t);   break;\n+    case SHAPE_I64:     WALK_NUMBER(int64_t);   break;\n+    case SHAPE_F32:     WALK_NUMBER(float);     break;\n+    case SHAPE_F64:     WALK_NUMBER(double);    break;\n+    case SHAPE_EVEC:    walk_evec(align);       break;\n+    case SHAPE_IVEC:    walk_ivec(align);       break;\n+    case SHAPE_TAG:     walk_tag(align);        break;\n+    case SHAPE_BOX:     walk_box(align);        break;\n+    case SHAPE_STRUCT:  walk_struct(align);     break;\n+    case SHAPE_FN:      WALK_SIMPLE(walk_fn);   break;\n+    case SHAPE_OBJ:     WALK_SIMPLE(walk_obj);  break;\n+    case SHAPE_RES:     walk_res(align);        break;\n+    case SHAPE_VAR:     walk_var(align);        break;\n+    default:            abort();\n+    }\n+}\n+\n+template<typename T>\n+void\n+ctxt<T>::walk_reset(bool align) {\n+    const uint8_t *old_sp = sp;\n+    walk(align);\n+    sp = old_sp;\n+}\n+\n+template<typename T>\n+uint16_t\n+ctxt<T>::get_u16(const uint8_t *addr) {\n+    return *reinterpret_cast<const uint16_t *>(addr);\n+}\n+\n+template<typename T>\n+uint16_t\n+ctxt<T>::get_u16_bump(const uint8_t *&addr) {\n+    uint16_t result = get_u16(addr);\n+    addr += sizeof(uint16_t);\n+    return result;\n+}\n+\n+template<typename T>\n+size_align\n+ctxt<T>::get_size_align(const uint8_t *&addr) {\n+    size_align result;\n+    result.size = get_u16_bump(addr);\n+    result.alignment = *addr++;\n+    return result;\n+}\n+\n+// Returns a pointer to the beginning and a pointer to the end of the shape of\n+// the tag variant with the given ID.\n+template<typename T>\n+std::pair<const uint8_t *,const uint8_t *>\n+ctxt<T>::get_variant_sp(tag_info &tinfo, uint32_t variant_id) {\n+    uint16_t variant_offset = get_u16(tinfo.info_ptr +\n+                                      variant_id * sizeof(uint16_t));\n+    const uint8_t *variant_ptr = tables->tags + variant_offset;\n+    uint16_t variant_len = get_u16_bump(variant_ptr);\n+    const uint8_t *variant_end = variant_ptr + variant_len;\n+    return std::make_pair(variant_ptr, variant_end);\n+}\n+\n+template<typename T>\n+void\n+ctxt<T>::walk_evec(bool align) {\n+    bool is_pod = *sp++;\n+\n+    uint16_t sp_size = get_u16_bump(sp);\n+    const uint8_t *end_sp = sp + sp_size;\n+\n+    static_cast<T *>(this)->walk_evec(align, is_pod, sp_size);\n+\n+    sp = end_sp;\n+}\n+\n+template<typename T>\n+void\n+ctxt<T>::walk_ivec(bool align) {\n+    bool is_pod = *sp++;\n+    size_align elem_sa = get_size_align(sp);\n+\n+    uint16_t sp_size = get_u16_bump(sp);\n+    const uint8_t *end_sp = sp + sp_size;\n+\n+    // FIXME: Hack to work around our incorrect alignment in some cases.\n+    if (elem_sa.alignment == 8)\n+        elem_sa.alignment = 4;\n+\n+    static_cast<T *>(this)->walk_ivec(align, is_pod, elem_sa);\n+\n+    sp = end_sp;\n+}\n+\n+template<typename T>\n+void\n+ctxt<T>::walk_tag(bool align) {\n+    tag_info tinfo;\n+    tinfo.tag_id = get_u16_bump(sp);\n+\n+    // Determine the info pointer.\n+    uint16_t info_offset = get_u16(tables->tags +\n+                                   tinfo.tag_id * sizeof(uint16_t));\n+    tinfo.info_ptr = tables->tags + info_offset;\n+\n+    tinfo.variant_count = get_u16_bump(tinfo.info_ptr);\n+\n+    // Determine the largest-variants pointer.\n+    uint16_t largest_variants_offset = get_u16_bump(tinfo.info_ptr);\n+    tinfo.largest_variants_ptr = tables->tags + largest_variants_offset;\n+\n+    // Determine the size and alignment.\n+    tinfo.tag_sa = get_size_align(tinfo.info_ptr);\n+\n+    // Determine the number of parameters.\n+    tinfo.n_params = get_u16_bump(sp);\n+\n+    // Read in the tag type parameters.\n+    type_param params[tinfo.n_params];\n+    for (uint16_t i = 0; i < tinfo.n_params; i++) {\n+        uint16_t len = get_u16_bump(sp);\n+        params[i].set(this);\n+        sp += len;\n+    }\n+\n+    tinfo.params = params;\n+\n+    // Call to the implementation.\n+    static_cast<T *>(this)->walk_tag(align, tinfo);\n+}\n+\n+template<typename T>\n+void\n+ctxt<T>::walk_box(bool align) {\n+    uint16_t sp_size = get_u16_bump(sp);\n+    const uint8_t *end_sp = sp + sp_size;\n+\n+    static_cast<T *>(this)->walk_box(align);\n+\n+    sp = end_sp;\n+}\n+\n+template<typename T>\n+void\n+ctxt<T>::walk_struct(bool align) {\n+    uint16_t sp_size = get_u16_bump(sp);\n+    const uint8_t *end_sp = sp + sp_size;\n+\n+    static_cast<T *>(this)->walk_struct(align, end_sp);\n+\n+    sp = end_sp;\n+}\n+\n+template<typename T>\n+void\n+ctxt<T>::walk_res(bool align) {\n+    uint16_t dtor_offset = get_u16_bump(sp);\n+    const rust_fn **resources =\n+        reinterpret_cast<const rust_fn **>(tables->resources);\n+    const rust_fn *dtor = resources[dtor_offset];\n+\n+    uint16_t n_ty_params = get_u16_bump(sp);\n+\n+    uint16_t ty_params_size = get_u16_bump(sp);\n+    const uint8_t *ty_params_sp = sp;\n+    sp += ty_params_size;\n+\n+    uint16_t sp_size = get_u16_bump(sp);\n+    const uint8_t *end_sp = sp + sp_size;\n+\n+    static_cast<T *>(this)->walk_res(align, dtor, n_ty_params, ty_params_sp);\n+\n+    sp = end_sp;\n+}\n+\n+template<typename T>\n+void\n+ctxt<T>::walk_var(bool align) {\n+    uint8_t param = *sp++;\n+    static_cast<T *>(this)->walk_var(align, param);\n+}\n+\n+// A shape printer, useful for debugging\n+\n+class print : public ctxt<print> {\n+public:\n+    template<typename T>\n+    print(const ctxt<T> &other,\n+          const uint8_t *in_sp = NULL,\n+          const type_param *in_params = NULL,\n+          const rust_shape_tables *in_tables = NULL)\n+    : ctxt<print>(other, in_sp, in_params, in_tables) {}\n+\n+    void walk_tag(bool align, tag_info &tinfo);\n+    void walk_struct(bool align, const uint8_t *end_sp);\n+    void walk_res(bool align, const rust_fn *dtor, uint16_t n_ty_params,\n+                  const uint8_t *ty_params_sp);\n+    void walk_var(bool align, uint8_t param);\n+\n+    void walk_evec(bool align, bool is_pod, uint16_t sp_size) {\n+        DPRINT(\"evec<\"); walk(align); DPRINT(\">\");\n+    }\n+    void walk_ivec(bool align, bool is_pod, size_align &elem_sa) {\n+        DPRINT(\"ivec<\"); walk(align); DPRINT(\">\");\n+    }\n+    void walk_box(bool align) {\n+        DPRINT(\"box<\"); walk(align); DPRINT(\">\");\n+    }\n+\n+    void walk_port(bool align)                  { DPRINT(\"port\"); }\n+    void walk_chan(bool align)                  { DPRINT(\"chan\"); }\n+    void walk_task(bool align)                  { DPRINT(\"task\"); }\n+    void walk_fn(bool align)                    { DPRINT(\"fn\");   }\n+    void walk_obj(bool align)                   { DPRINT(\"obj\");  }\n+\n+    template<typename T>\n+    void walk_number(bool align) {}\n+\n+    template<typename T>\n+    static void print_cx(const T *cx) {\n+        print self(*cx);\n+        self.walk(false);\n+    }\n+};\n+\n+//\n+// Size-of (which also computes alignment). Be warned: this is an expensive\n+// operation.\n+//\n+// TODO: Maybe dynamic_size_of() should call into this somehow?\n+//\n+\n+class size_of : public ctxt<size_of> {\n+private:\n+    size_align sa;\n+\n+public:\n+    size_of(const size_of &other,\n+            const uint8_t *in_sp = NULL,\n+            const type_param *in_params = NULL,\n+            const rust_shape_tables *in_tables = NULL)\n+    : ctxt<size_of>(other, in_sp, in_params, in_tables) {}\n+\n+    template<typename T>\n+    size_of(const ctxt<T> &other,\n+            const uint8_t *in_sp = NULL,\n+            const type_param *in_params = NULL,\n+            const rust_shape_tables *in_tables = NULL)\n+    : ctxt<size_of>(other, in_sp, in_params, in_tables) {}\n+\n+    void walk_tag(bool align, tag_info &tinfo);\n+    void walk_struct(bool align, const uint8_t *end_sp);\n+    void walk_ivec(bool align, bool is_pod, size_align &elem_sa);\n+\n+    void walk_box(bool align)   { sa.set(sizeof(void *),   sizeof(void *)); }\n+    void walk_port(bool align)  { sa.set(sizeof(void *),   sizeof(void *)); }\n+    void walk_chan(bool align)  { sa.set(sizeof(void *),   sizeof(void *)); }\n+    void walk_task(bool align)  { sa.set(sizeof(void *),   sizeof(void *)); }\n+    void walk_fn(bool align)    { sa.set(sizeof(void *)*2, sizeof(void *)); }\n+    void walk_obj(bool align)   { sa.set(sizeof(void *)*2, sizeof(void *)); }\n+\n+    void walk_evec(bool align, bool is_pod, uint16_t sp_size) {\n+        sa.set(sizeof(void *), sizeof(void *));\n+    }\n+\n+    void walk_var(bool align, uint8_t param_index) {\n+        const type_param *param = &params[param_index];\n+        size_of sub(*this, param->shape, param->params, param->tables);\n+        sub.walk(align);\n+        sa = sub.sa;\n+    }\n+\n+    void walk_res(bool align, const rust_fn *dtor, uint16_t n_ty_params,\n+                  const uint8_t *ty_params_sp) {\n+        abort();    // TODO\n+    }\n+\n+    template<typename T>\n+    void walk_number(bool align) { sa.set(sizeof(T), ALIGNOF(T)); }\n+\n+    void compute_tag_size(tag_info &tinfo);\n+\n+    template<typename T>\n+    static void compute_tag_size(const ctxt<T> &other_cx, tag_info &tinfo) {\n+        size_of cx(other_cx);\n+        cx.compute_tag_size(tinfo);\n+    }\n+\n+    template<typename T>\n+    static size_align get(const ctxt<T> &other_cx, unsigned back_up = 0) {\n+        size_of cx(other_cx, other_cx.sp - back_up);\n+        cx.walk(false);\n+        assert(cx.sa.alignment > 0);\n+        return cx.sa;\n+    }\n+};\n+\n+\n+// Pointer wrappers for data traversals\n+\n+class ptr {\n+private:\n+    uint8_t *p;\n+\n+public:\n+    template<typename T>\n+    struct data { typedef T t; };\n+\n+    ptr(uint8_t *in_p)\n+    : p(in_p) {}\n+\n+    ptr(uintptr_t in_p)\n+    : p((uint8_t *)in_p) {}\n+\n+    inline ptr operator+(const size_t amount) const {\n+        return make(p + amount);\n+    }\n+    inline ptr &operator+=(const size_t amount) { p += amount; return *this; }\n+    inline bool operator<(const ptr other) { return p < other.p; }\n+    inline ptr operator++() { ptr rv(*this); p++; return rv; }\n+    inline uint8_t operator*() { return *p; }\n+\n+    template<typename T>\n+    inline operator T *() { return (T *)p; }\n+\n+    inline operator uintptr_t() { return (uintptr_t)p; }\n+\n+    static inline ptr make(uint8_t *in_p) {\n+        ptr self(in_p);\n+        return self;\n+    }\n+};\n+\n+template<typename T>\n+static inline T\n+bump_dp(ptr &dp) {\n+    T x = *((T *)dp);\n+    dp += sizeof(T);\n+    return x;\n+}\n+\n+template<typename T>\n+static inline T\n+get_dp(ptr dp) {\n+    return *((T *)dp);\n+}\n+\n+\n+// Pointer pairs for structural comparison\n+\n+template<typename T>\n+class data_pair {\n+public:\n+    T fst, snd;\n+\n+    data_pair() {}\n+    data_pair(T &in_fst, T &in_snd) : fst(in_fst), snd(in_snd) {}\n+\n+    inline void operator=(const T rhs) { fst = snd = rhs; }\n+\n+    static data_pair<T> make(T &fst, T &snd) {\n+        data_pair<T> data(fst, snd);\n+        return data;\n+    }\n+};\n+\n+class ptr_pair {\n+public:\n+    uint8_t *fst, *snd;\n+\n+    template<typename T>\n+    struct data { typedef data_pair<T> t; };\n+\n+    ptr_pair(uint8_t *in_fst, uint8_t *in_snd) : fst(in_fst), snd(in_snd) {}\n+\n+    ptr_pair(data_pair<uint8_t *> &other) : fst(other.fst), snd(other.snd) {}\n+\n+    inline void operator=(uint8_t *rhs) { fst = snd = rhs; }\n+\n+    inline ptr_pair operator+(size_t n) const {\n+        return make(fst + n, snd + n);\n+    }\n+\n+    inline ptr_pair operator+=(size_t n) {\n+        fst += n; snd += n;\n+        return *this;\n+    }\n+\n+    inline ptr_pair operator-(size_t n) const {\n+        return make(fst - n, snd - n);\n+    }\n+\n+    inline bool operator<(const ptr_pair &other) const {\n+        return fst < other.fst && snd < other.snd;\n+    }\n+\n+    static inline ptr_pair make(uint8_t *fst, uint8_t *snd) {\n+        ptr_pair self(fst, snd);\n+        return self;\n+    }\n+\n+    static inline ptr_pair make(const data_pair<uint8_t *> &pair) {\n+        ptr_pair self(pair.fst, pair.snd);\n+        return self;\n+    }\n+};\n+\n+}   // end namespace shape\n+\n+\n+inline shape::ptr_pair\n+align_to(const shape::ptr_pair &pair, size_t n) {\n+    return shape::ptr_pair::make(align_to(pair.fst, n),\n+                                 align_to(pair.snd, n));\n+}\n+\n+\n+namespace shape {\n+\n+// An abstract class (again using the curiously recurring template pattern)\n+// for methods that actually manipulate the data involved.\n+\n+#define DATA_SIMPLE(ty, call) \\\n+    if (align) dp = align_to(dp, sizeof(ty)); \\\n+    U end_dp = dp + sizeof(ty); \\\n+    static_cast<T *>(this)->call; \\\n+    dp = end_dp;\n+\n+template<typename T,typename U>\n+class data : public ctxt< data<T,U> > {\n+protected:\n+    void walk_box_contents(bool align);\n+    void walk_variant(bool align, tag_info &tinfo, uint32_t variant);\n+\n+    static std::pair<uint8_t *,uint8_t *> get_evec_data_range(ptr dp);\n+    static std::pair<uint8_t *,uint8_t *> get_ivec_data_range(ptr dp);\n+    static std::pair<ptr_pair,ptr_pair> get_evec_data_range(ptr_pair &dp);\n+    static std::pair<ptr_pair,ptr_pair> get_ivec_data_range(ptr_pair &dp);\n+\n+public:\n+    U dp;\n+\n+    data(rust_task *in_task,\n+         const uint8_t *in_sp,\n+         const type_param *in_params,\n+         const rust_shape_tables *in_tables,\n+         U const &in_dp)\n+    : ctxt< data<T,U> >(in_task, in_sp, in_params, in_tables), dp(in_dp) {}\n+\n+    void walk_tag(bool align, tag_info &tinfo);\n+    void walk_ivec(bool align, bool is_pod, size_align &elem_sa);\n+\n+    void walk_struct(bool align, const uint8_t *end_sp) {\n+        static_cast<T *>(this)->walk_struct(align, end_sp);\n+    }\n+\n+    void walk_evec(bool align, bool is_pod, uint16_t sp_size) {\n+        DATA_SIMPLE(void *, walk_evec(align, is_pod, sp_size));\n+    }\n+\n+    void walk_box(bool align)   { DATA_SIMPLE(void *, walk_box(align)); }\n+    void walk_port(bool align)  { DATA_SIMPLE(void *, walk_port(align)); }\n+    void walk_chan(bool align)  { DATA_SIMPLE(void *, walk_chan(align)); }\n+    void walk_task(bool align)  { DATA_SIMPLE(void *, walk_task(align)); }\n+\n+    void walk_fn(bool align) {\n+        if (align) dp = align_to(dp, sizeof(void *));\n+        static_cast<T *>(this)->walk_fn(align);\n+        dp += sizeof(void *) * 2;\n+    }\n+\n+    void walk_obj(bool align) {\n+        if (align) dp = align_to(dp, sizeof(void *));\n+        static_cast<T *>(this)->walk_obj(align);\n+        dp += sizeof(void *) * 2;\n+    }\n+\n+    void walk_res(bool align, const rust_fn *dtor, uint16_t n_ty_params,\n+                  const uint8_t *ty_params_sp) {\n+        // Delegate to the implementation.\n+        static_cast<T *>(this)->walk_res(align, dtor, n_ty_params,\n+                                         ty_params_sp);\n+    }\n+\n+    void walk_var(bool align, uint8_t param_index) {\n+        const type_param *param = &this->params[param_index];\n+        T sub(*static_cast<T *>(this), param->shape, param->params,\n+              param->tables);\n+        static_cast<T *>(this)->walk_subcontext(align, sub);\n+        dp = sub.dp;\n+    }\n+\n+    template<typename W>\n+    void walk_number(bool align) { DATA_SIMPLE(W, walk_number<W>()); }\n+};\n+\n+template<typename T,typename U>\n+void\n+data<T,U>::walk_box_contents(bool align) {\n+    typename U::template data<uint8_t *>::t box_ptr = bump_dp<uint8_t *>(dp);\n+\n+    U ref_count_dp(box_ptr);\n+    T sub(*static_cast<T *>(this), ref_count_dp + sizeof(uint32_t));\n+    static_cast<T *>(this)->walk_box_contents(align, sub, ref_count_dp);\n+}\n+\n+template<typename T,typename U>\n+void\n+data<T,U>::walk_variant(bool align, tag_info &tinfo, uint32_t variant_id) {\n+    std::pair<const uint8_t *,const uint8_t *> variant_ptr_and_end =\n+        this->get_variant_sp(tinfo, variant_id);\n+    static_cast<T *>(this)->walk_variant(align, tinfo, variant_id,\n+                                         variant_ptr_and_end);\n+}\n+\n+template<typename T,typename U>\n+std::pair<uint8_t *,uint8_t *>\n+data<T,U>::get_evec_data_range(ptr dp) {\n+    rust_evec *vp = bump_dp<rust_evec *>(dp);\n+    return std::make_pair(vp->data, vp->data + vp->fill);\n+}\n+\n+template<typename T,typename U>\n+std::pair<uint8_t *,uint8_t *>\n+data<T,U>::get_ivec_data_range(ptr dp) {\n+    size_t fill = bump_dp<size_t>(dp);\n+    bump_dp<size_t>(dp);    // Skip over alloc.\n+    uint8_t *payload_dp = dp;\n+    rust_ivec_payload payload = bump_dp<rust_ivec_payload>(dp);\n+\n+    uint8_t *start, *end;\n+    if (!fill) {\n+        if (!payload.ptr) {             // Zero length.\n+            start = end = NULL;\n+        } else {                        // On heap.\n+            fill = payload.ptr->fill;\n+            start = payload.ptr->data;\n+            end = start + fill;\n+        }\n+    } else {                            // On stack.\n+        start = payload_dp;\n+        end = start + fill;\n+    }\n+\n+    return std::make_pair(start, end);\n+}\n+\n+template<typename T,typename U>\n+std::pair<ptr_pair,ptr_pair>\n+data<T,U>::get_evec_data_range(ptr_pair &dp) {\n+    std::pair<uint8_t *,uint8_t *> fst = get_evec_data_range(dp.fst);\n+    std::pair<uint8_t *,uint8_t *> snd = get_evec_data_range(dp.snd);\n+    ptr_pair start(fst.first, snd.first);\n+    ptr_pair end(fst.second, snd.second);\n+    return std::make_pair(start, end);\n+}\n+\n+template<typename T,typename U>\n+std::pair<ptr_pair,ptr_pair>\n+data<T,U>::get_ivec_data_range(ptr_pair &dp) {\n+    std::pair<uint8_t *,uint8_t *> fst = get_ivec_data_range(dp.fst);\n+    std::pair<uint8_t *,uint8_t *> snd = get_ivec_data_range(dp.snd);\n+    ptr_pair start(fst.first, snd.first);\n+    ptr_pair end(fst.second, snd.second);\n+    return std::make_pair(start, end);\n+}\n+\n+template<typename T,typename U>\n+void\n+data<T,U>::walk_ivec(bool align, bool is_pod, size_align &elem_sa) {\n+    if (!elem_sa.is_set())\n+        elem_sa = size_of::get(*this);\n+    else if (elem_sa.alignment == 8)\n+        elem_sa.alignment = 4;  // FIXME: This is an awful hack.\n+\n+    // Get a pointer to the interior vector, and determine its size.\n+    if (align) dp = align_to(dp, ALIGNOF(rust_ivec *));\n+    U end_dp = dp + sizeof(rust_ivec) - sizeof(uintptr_t) + elem_sa.size * 4;\n+\n+    // Call to the implementation.\n+    static_cast<T *>(this)->walk_ivec(align, is_pod, elem_sa);\n+\n+    dp = end_dp;\n+}\n+\n+template<typename T,typename U>\n+void\n+data<T,U>::walk_tag(bool align, tag_info &tinfo) {\n+    size_of::compute_tag_size(*this, tinfo);\n+\n+    if (tinfo.variant_count > 1 && align)\n+        dp = align_to(dp, ALIGNOF(uint32_t));\n+\n+    U end_dp = dp + tinfo.tag_sa.size;\n+\n+    typename U::template data<uint32_t>::t tag_variant;\n+    if (tinfo.variant_count > 1)\n+        tag_variant = bump_dp<uint32_t>(dp);\n+    else\n+        tag_variant = 0;\n+\n+    static_cast<T *>(this)->walk_tag(align, tinfo, tag_variant);\n+\n+    dp = end_dp;\n+}\n+\n+\n+// Polymorphic logging, for convenience\n+\n+class log : public data<log,ptr> {\n+    friend class data<log,ptr>;\n+\n+private:\n+    std::ostream &out;\n+    bool in_string;\n+\n+    log(log &other,\n+        const uint8_t *in_sp,\n+        const type_param *in_params,\n+        const rust_shape_tables *in_tables = NULL)\n+    : data<log,ptr>(other.task,\n+                    in_sp,\n+                    in_params,\n+                    in_tables ? in_tables : other.tables,\n+                    other.dp),\n+      out(other.out) {}\n+\n+    log(log &other, ptr in_dp)\n+    : data<log,ptr>(other.task, other.sp, other.params, other.tables, in_dp),\n+      out(other.out) {}\n+\n+    void walk_string(const std::pair<ptr,ptr> &data);\n+\n+    void walk_evec(bool align, bool is_pod, uint16_t sp_size) {\n+        walk_vec(align, is_pod, get_evec_data_range(dp));\n+    }\n+\n+    void walk_ivec(bool align, bool is_pod, size_align &elem_sa) {\n+        walk_vec(align, is_pod, get_ivec_data_range(dp));\n+    }\n+\n+    void walk_tag(bool align, tag_info &tinfo, uint32_t tag_variant) {\n+        out << \"tag\" << tag_variant;\n+        data<log,ptr>::walk_variant(align, tinfo, tag_variant);\n+    }\n+\n+    void walk_box(bool align) {\n+        out << \"@\";\n+        data<log,ptr>::walk_box_contents(align);\n+    }\n+\n+    void walk_fn(bool align) { out << \"fn\"; }\n+    void walk_obj(bool align) { out << \"obj\"; }\n+    void walk_port(bool align) { out << \"port\"; }\n+    void walk_chan(bool align) { out << \"chan\"; }\n+    void walk_task(bool align) { out << \"task\"; }\n+\n+    void walk_res(bool align, const rust_fn *dtor, uint16_t n_ty_params,\n+                  const uint8_t *ty_params_sp) {\n+        out << \"res\";   // TODO\n+    }\n+\n+    void walk_subcontext(bool align, log &sub) { sub.walk(align); }\n+\n+    void walk_box_contents(bool align, log &sub, ptr &ref_count_dp) {\n+        if (ref_count_dp == 0)\n+            out << \"(null)\";\n+        else\n+            sub.walk(true);\n+    }\n+\n+    void walk_struct(bool align, const uint8_t *end_sp);\n+    void walk_vec(bool align, bool is_pod, const std::pair<ptr,ptr> &data);\n+    void walk_variant(bool align, tag_info &tinfo, uint32_t variant_id,\n+                      const std::pair<const uint8_t *,const uint8_t *>\n+                      variant_ptr_and_end);\n+\n+    template<typename T>\n+    void walk_number() { out << get_dp<T>(dp); }\n+\n+public:\n+    log(rust_task *in_task,\n+        const uint8_t *in_sp,\n+        const type_param *in_params,\n+        const rust_shape_tables *in_tables,\n+        uint8_t *in_data,\n+        std::ostream &in_out)\n+    : data<log,ptr>(in_task, in_sp, in_params, in_tables, in_data),\n+      out(in_out) {}\n+};\n+\n+}   // end namespace shape\n+\n+#endif\n+"}]}